# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AzureFunctionEventSubscriptionDestinationArgs',
    'BoolEqualsAdvancedFilterArgs',
    'ConnectionStateArgs',
    'DeadLetterWithResourceIdentityArgs',
    'DeliveryWithResourceIdentityArgs',
    'DynamicDeliveryAttributeMappingArgs',
    'EventHubEventSubscriptionDestinationArgs',
    'EventSubscriptionFilterArgs',
    'EventSubscriptionIdentityArgs',
    'EventTypeInfoArgs',
    'HybridConnectionEventSubscriptionDestinationArgs',
    'IdentityInfoArgs',
    'InboundIpRuleArgs',
    'InlineEventPropertiesArgs',
    'IsNotNullAdvancedFilterArgs',
    'IsNullOrUndefinedAdvancedFilterArgs',
    'JsonFieldWithDefaultArgs',
    'JsonFieldArgs',
    'JsonInputSchemaMappingArgs',
    'NumberGreaterThanAdvancedFilterArgs',
    'NumberGreaterThanOrEqualsAdvancedFilterArgs',
    'NumberInAdvancedFilterArgs',
    'NumberInRangeAdvancedFilterArgs',
    'NumberLessThanAdvancedFilterArgs',
    'NumberLessThanOrEqualsAdvancedFilterArgs',
    'NumberNotInAdvancedFilterArgs',
    'NumberNotInRangeAdvancedFilterArgs',
    'PartnerAuthorizationArgs',
    'PartnerTopicInfoArgs',
    'PartnerArgs',
    'PrivateEndpointArgs',
    'RetryPolicyArgs',
    'ServiceBusQueueEventSubscriptionDestinationArgs',
    'ServiceBusTopicEventSubscriptionDestinationArgs',
    'StaticDeliveryAttributeMappingArgs',
    'StorageBlobDeadLetterDestinationArgs',
    'StorageQueueEventSubscriptionDestinationArgs',
    'StringBeginsWithAdvancedFilterArgs',
    'StringContainsAdvancedFilterArgs',
    'StringEndsWithAdvancedFilterArgs',
    'StringInAdvancedFilterArgs',
    'StringNotBeginsWithAdvancedFilterArgs',
    'StringNotContainsAdvancedFilterArgs',
    'StringNotEndsWithAdvancedFilterArgs',
    'StringNotInAdvancedFilterArgs',
    'UserIdentityPropertiesArgs',
    'WebHookEventSubscriptionDestinationArgs',
]

@pulumi.input_type
class AzureFunctionEventSubscriptionDestinationArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[str],
                 delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
                 max_events_per_batch: Optional[pulumi.Input[int]] = None,
                 preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Information about the azure function destination for an event subscription.
        :param pulumi.Input[str] endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'AzureFunction'.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]] delivery_attribute_mappings: Delivery attribute details.
        :param pulumi.Input[int] max_events_per_batch: Maximum number of events per batch.
        :param pulumi.Input[int] preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        :param pulumi.Input[str] resource_id: The Azure Resource Id that represents the endpoint of the Azure Function destination of an event subscription.
        """
        AzureFunctionEventSubscriptionDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_type=endpoint_type,
            delivery_attribute_mappings=delivery_attribute_mappings,
            max_events_per_batch=max_events_per_batch,
            preferred_batch_size_in_kilobytes=preferred_batch_size_in_kilobytes,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_type: Optional[pulumi.Input[str]] = None,
             delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
             max_events_per_batch: Optional[pulumi.Input[int]] = None,
             preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if endpoint_type is None:
            raise TypeError("Missing 'endpoint_type' argument")
        if delivery_attribute_mappings is None and 'deliveryAttributeMappings' in kwargs:
            delivery_attribute_mappings = kwargs['deliveryAttributeMappings']
        if max_events_per_batch is None and 'maxEventsPerBatch' in kwargs:
            max_events_per_batch = kwargs['maxEventsPerBatch']
        if preferred_batch_size_in_kilobytes is None and 'preferredBatchSizeInKilobytes' in kwargs:
            preferred_batch_size_in_kilobytes = kwargs['preferredBatchSizeInKilobytes']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("endpoint_type", 'AzureFunction')
        if delivery_attribute_mappings is not None:
            _setter("delivery_attribute_mappings", delivery_attribute_mappings)
        if max_events_per_batch is None:
            max_events_per_batch = 1
        if max_events_per_batch is not None:
            _setter("max_events_per_batch", max_events_per_batch)
        if preferred_batch_size_in_kilobytes is None:
            preferred_batch_size_in_kilobytes = 64
        if preferred_batch_size_in_kilobytes is not None:
            _setter("preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[str]:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'AzureFunction'.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @delivery_attribute_mappings.setter
    def delivery_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]):
        pulumi.set(self, "delivery_attribute_mappings", value)

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @max_events_per_batch.setter
    def max_events_per_batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_events_per_batch", value)

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[pulumi.Input[int]]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")

    @preferred_batch_size_in_kilobytes.setter
    def preferred_batch_size_in_kilobytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preferred_batch_size_in_kilobytes", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Resource Id that represents the endpoint of the Azure Function destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class BoolEqualsAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[bool]] = None):
        """
        BoolEquals Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'BoolEquals'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[bool] value: The boolean filter value.
        """
        BoolEqualsAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'BoolEquals')
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'BoolEquals'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[bool]]:
        """
        The boolean filter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ConnectionStateArgs:
    def __init__(__self__, *,
                 actions_required: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[Union[str, 'PersistedConnectionStatus']]] = None):
        """
        ConnectionState information.
        :param pulumi.Input[str] actions_required: Actions required (if any).
        :param pulumi.Input[str] description: Description of the connection state.
        :param pulumi.Input[Union[str, 'PersistedConnectionStatus']] status: Status of the connection.
        """
        ConnectionStateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions_required=actions_required,
            description=description,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions_required: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[Union[str, 'PersistedConnectionStatus']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions_required is None and 'actionsRequired' in kwargs:
            actions_required = kwargs['actionsRequired']

        if actions_required is not None:
            _setter("actions_required", actions_required)
        if description is not None:
            _setter("description", description)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[str]]:
        """
        Actions required (if any).
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "actions_required", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the connection state.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'PersistedConnectionStatus']]]:
        """
        Status of the connection.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'PersistedConnectionStatus']]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class DeadLetterWithResourceIdentityArgs:
    def __init__(__self__, *,
                 dead_letter_destination: Optional[pulumi.Input['StorageBlobDeadLetterDestinationArgs']] = None,
                 identity: Optional[pulumi.Input['EventSubscriptionIdentityArgs']] = None):
        """
        Information about the deadletter destination with resource identity.
        :param pulumi.Input['StorageBlobDeadLetterDestinationArgs'] dead_letter_destination: Information about the destination where events have to be delivered for the event subscription.
               Uses the managed identity setup on the parent resource (namely, topic or domain) to acquire the authentication tokens being used during delivery / dead-lettering.
        :param pulumi.Input['EventSubscriptionIdentityArgs'] identity: The identity to use when dead-lettering events.
        """
        DeadLetterWithResourceIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dead_letter_destination=dead_letter_destination,
            identity=identity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dead_letter_destination: Optional[pulumi.Input['StorageBlobDeadLetterDestinationArgs']] = None,
             identity: Optional[pulumi.Input['EventSubscriptionIdentityArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dead_letter_destination is None and 'deadLetterDestination' in kwargs:
            dead_letter_destination = kwargs['deadLetterDestination']

        if dead_letter_destination is not None:
            _setter("dead_letter_destination", dead_letter_destination)
        if identity is not None:
            _setter("identity", identity)

    @property
    @pulumi.getter(name="deadLetterDestination")
    def dead_letter_destination(self) -> Optional[pulumi.Input['StorageBlobDeadLetterDestinationArgs']]:
        """
        Information about the destination where events have to be delivered for the event subscription.
        Uses the managed identity setup on the parent resource (namely, topic or domain) to acquire the authentication tokens being used during delivery / dead-lettering.
        """
        return pulumi.get(self, "dead_letter_destination")

    @dead_letter_destination.setter
    def dead_letter_destination(self, value: Optional[pulumi.Input['StorageBlobDeadLetterDestinationArgs']]):
        pulumi.set(self, "dead_letter_destination", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input['EventSubscriptionIdentityArgs']]:
        """
        The identity to use when dead-lettering events.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input['EventSubscriptionIdentityArgs']]):
        pulumi.set(self, "identity", value)


@pulumi.input_type
class DeliveryWithResourceIdentityArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[Union['AzureFunctionEventSubscriptionDestinationArgs', 'EventHubEventSubscriptionDestinationArgs', 'HybridConnectionEventSubscriptionDestinationArgs', 'ServiceBusQueueEventSubscriptionDestinationArgs', 'ServiceBusTopicEventSubscriptionDestinationArgs', 'StorageQueueEventSubscriptionDestinationArgs', 'WebHookEventSubscriptionDestinationArgs']]] = None,
                 identity: Optional[pulumi.Input['EventSubscriptionIdentityArgs']] = None):
        """
        Information about the delivery for an event subscription with resource identity.
        :param pulumi.Input[Union['AzureFunctionEventSubscriptionDestinationArgs', 'EventHubEventSubscriptionDestinationArgs', 'HybridConnectionEventSubscriptionDestinationArgs', 'ServiceBusQueueEventSubscriptionDestinationArgs', 'ServiceBusTopicEventSubscriptionDestinationArgs', 'StorageQueueEventSubscriptionDestinationArgs', 'WebHookEventSubscriptionDestinationArgs']] destination: Information about the destination where events have to be delivered for the event subscription.
               Uses Azure Event Grid's identity to acquire the authentication tokens being used during delivery / dead-lettering.
        :param pulumi.Input['EventSubscriptionIdentityArgs'] identity: The identity to use when delivering events.
        """
        DeliveryWithResourceIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            identity=identity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[Union['AzureFunctionEventSubscriptionDestinationArgs', 'EventHubEventSubscriptionDestinationArgs', 'HybridConnectionEventSubscriptionDestinationArgs', 'ServiceBusQueueEventSubscriptionDestinationArgs', 'ServiceBusTopicEventSubscriptionDestinationArgs', 'StorageQueueEventSubscriptionDestinationArgs', 'WebHookEventSubscriptionDestinationArgs']]] = None,
             identity: Optional[pulumi.Input['EventSubscriptionIdentityArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)
        if identity is not None:
            _setter("identity", identity)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[Union['AzureFunctionEventSubscriptionDestinationArgs', 'EventHubEventSubscriptionDestinationArgs', 'HybridConnectionEventSubscriptionDestinationArgs', 'ServiceBusQueueEventSubscriptionDestinationArgs', 'ServiceBusTopicEventSubscriptionDestinationArgs', 'StorageQueueEventSubscriptionDestinationArgs', 'WebHookEventSubscriptionDestinationArgs']]]:
        """
        Information about the destination where events have to be delivered for the event subscription.
        Uses Azure Event Grid's identity to acquire the authentication tokens being used during delivery / dead-lettering.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[Union['AzureFunctionEventSubscriptionDestinationArgs', 'EventHubEventSubscriptionDestinationArgs', 'HybridConnectionEventSubscriptionDestinationArgs', 'ServiceBusQueueEventSubscriptionDestinationArgs', 'ServiceBusTopicEventSubscriptionDestinationArgs', 'StorageQueueEventSubscriptionDestinationArgs', 'WebHookEventSubscriptionDestinationArgs']]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input['EventSubscriptionIdentityArgs']]:
        """
        The identity to use when delivering events.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input['EventSubscriptionIdentityArgs']]):
        pulumi.set(self, "identity", value)


@pulumi.input_type
class DynamicDeliveryAttributeMappingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 source_field: Optional[pulumi.Input[str]] = None):
        """
        Dynamic delivery attribute mapping details.
        :param pulumi.Input[str] type: Type of the delivery attribute or header name.
               Expected value is 'Dynamic'.
        :param pulumi.Input[str] name: Name of the delivery attribute or header.
        :param pulumi.Input[str] source_field: JSON path in the event which contains attribute value.
        """
        DynamicDeliveryAttributeMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            name=name,
            source_field=source_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             source_field: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if source_field is None and 'sourceField' in kwargs:
            source_field = kwargs['sourceField']

        _setter("type", 'Dynamic')
        if name is not None:
            _setter("name", name)
        if source_field is not None:
            _setter("source_field", source_field)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the delivery attribute or header name.
        Expected value is 'Dynamic'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the delivery attribute or header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[pulumi.Input[str]]:
        """
        JSON path in the event which contains attribute value.
        """
        return pulumi.get(self, "source_field")

    @source_field.setter
    def source_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_field", value)


@pulumi.input_type
class EventHubEventSubscriptionDestinationArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[str],
                 delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Information about the event hub destination for an event subscription.
        :param pulumi.Input[str] endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'EventHub'.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]] delivery_attribute_mappings: Delivery attribute details.
        :param pulumi.Input[str] resource_id: The Azure Resource Id that represents the endpoint of an Event Hub destination of an event subscription.
        """
        EventHubEventSubscriptionDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_type=endpoint_type,
            delivery_attribute_mappings=delivery_attribute_mappings,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_type: Optional[pulumi.Input[str]] = None,
             delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if endpoint_type is None:
            raise TypeError("Missing 'endpoint_type' argument")
        if delivery_attribute_mappings is None and 'deliveryAttributeMappings' in kwargs:
            delivery_attribute_mappings = kwargs['deliveryAttributeMappings']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("endpoint_type", 'EventHub')
        if delivery_attribute_mappings is not None:
            _setter("delivery_attribute_mappings", delivery_attribute_mappings)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[str]:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'EventHub'.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @delivery_attribute_mappings.setter
    def delivery_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]):
        pulumi.set(self, "delivery_attribute_mappings", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Resource Id that represents the endpoint of an Event Hub destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class EventSubscriptionFilterArgs:
    def __init__(__self__, *,
                 advanced_filters: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BoolEqualsAdvancedFilterArgs', 'IsNotNullAdvancedFilterArgs', 'IsNullOrUndefinedAdvancedFilterArgs', 'NumberGreaterThanAdvancedFilterArgs', 'NumberGreaterThanOrEqualsAdvancedFilterArgs', 'NumberInAdvancedFilterArgs', 'NumberInRangeAdvancedFilterArgs', 'NumberLessThanAdvancedFilterArgs', 'NumberLessThanOrEqualsAdvancedFilterArgs', 'NumberNotInAdvancedFilterArgs', 'NumberNotInRangeAdvancedFilterArgs', 'StringBeginsWithAdvancedFilterArgs', 'StringContainsAdvancedFilterArgs', 'StringEndsWithAdvancedFilterArgs', 'StringInAdvancedFilterArgs', 'StringNotBeginsWithAdvancedFilterArgs', 'StringNotContainsAdvancedFilterArgs', 'StringNotEndsWithAdvancedFilterArgs', 'StringNotInAdvancedFilterArgs']]]]] = None,
                 enable_advanced_filtering_on_arrays: Optional[pulumi.Input[bool]] = None,
                 included_event_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_subject_case_sensitive: Optional[pulumi.Input[bool]] = None,
                 subject_begins_with: Optional[pulumi.Input[str]] = None,
                 subject_ends_with: Optional[pulumi.Input[str]] = None):
        """
        Filter for the Event Subscription.
        :param pulumi.Input[Sequence[pulumi.Input[Union['BoolEqualsAdvancedFilterArgs', 'IsNotNullAdvancedFilterArgs', 'IsNullOrUndefinedAdvancedFilterArgs', 'NumberGreaterThanAdvancedFilterArgs', 'NumberGreaterThanOrEqualsAdvancedFilterArgs', 'NumberInAdvancedFilterArgs', 'NumberInRangeAdvancedFilterArgs', 'NumberLessThanAdvancedFilterArgs', 'NumberLessThanOrEqualsAdvancedFilterArgs', 'NumberNotInAdvancedFilterArgs', 'NumberNotInRangeAdvancedFilterArgs', 'StringBeginsWithAdvancedFilterArgs', 'StringContainsAdvancedFilterArgs', 'StringEndsWithAdvancedFilterArgs', 'StringInAdvancedFilterArgs', 'StringNotBeginsWithAdvancedFilterArgs', 'StringNotContainsAdvancedFilterArgs', 'StringNotEndsWithAdvancedFilterArgs', 'StringNotInAdvancedFilterArgs']]]] advanced_filters: An array of advanced filters that are used for filtering event subscriptions.
        :param pulumi.Input[bool] enable_advanced_filtering_on_arrays: Allows advanced filters to be evaluated against an array of values instead of expecting a singular value.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_event_types: A list of applicable event types that need to be part of the event subscription. If it is desired to subscribe to all default event types, set the IncludedEventTypes to null.
        :param pulumi.Input[bool] is_subject_case_sensitive: Specifies if the SubjectBeginsWith and SubjectEndsWith properties of the filter
               should be compared in a case sensitive manner.
        :param pulumi.Input[str] subject_begins_with: An optional string to filter events for an event subscription based on a resource path prefix.
               The format of this depends on the publisher of the events.
               Wildcard characters are not supported in this path.
        :param pulumi.Input[str] subject_ends_with: An optional string to filter events for an event subscription based on a resource path suffix.
               Wildcard characters are not supported in this path.
        """
        EventSubscriptionFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advanced_filters=advanced_filters,
            enable_advanced_filtering_on_arrays=enable_advanced_filtering_on_arrays,
            included_event_types=included_event_types,
            is_subject_case_sensitive=is_subject_case_sensitive,
            subject_begins_with=subject_begins_with,
            subject_ends_with=subject_ends_with,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advanced_filters: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BoolEqualsAdvancedFilterArgs', 'IsNotNullAdvancedFilterArgs', 'IsNullOrUndefinedAdvancedFilterArgs', 'NumberGreaterThanAdvancedFilterArgs', 'NumberGreaterThanOrEqualsAdvancedFilterArgs', 'NumberInAdvancedFilterArgs', 'NumberInRangeAdvancedFilterArgs', 'NumberLessThanAdvancedFilterArgs', 'NumberLessThanOrEqualsAdvancedFilterArgs', 'NumberNotInAdvancedFilterArgs', 'NumberNotInRangeAdvancedFilterArgs', 'StringBeginsWithAdvancedFilterArgs', 'StringContainsAdvancedFilterArgs', 'StringEndsWithAdvancedFilterArgs', 'StringInAdvancedFilterArgs', 'StringNotBeginsWithAdvancedFilterArgs', 'StringNotContainsAdvancedFilterArgs', 'StringNotEndsWithAdvancedFilterArgs', 'StringNotInAdvancedFilterArgs']]]]] = None,
             enable_advanced_filtering_on_arrays: Optional[pulumi.Input[bool]] = None,
             included_event_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             is_subject_case_sensitive: Optional[pulumi.Input[bool]] = None,
             subject_begins_with: Optional[pulumi.Input[str]] = None,
             subject_ends_with: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if advanced_filters is None and 'advancedFilters' in kwargs:
            advanced_filters = kwargs['advancedFilters']
        if enable_advanced_filtering_on_arrays is None and 'enableAdvancedFilteringOnArrays' in kwargs:
            enable_advanced_filtering_on_arrays = kwargs['enableAdvancedFilteringOnArrays']
        if included_event_types is None and 'includedEventTypes' in kwargs:
            included_event_types = kwargs['includedEventTypes']
        if is_subject_case_sensitive is None and 'isSubjectCaseSensitive' in kwargs:
            is_subject_case_sensitive = kwargs['isSubjectCaseSensitive']
        if subject_begins_with is None and 'subjectBeginsWith' in kwargs:
            subject_begins_with = kwargs['subjectBeginsWith']
        if subject_ends_with is None and 'subjectEndsWith' in kwargs:
            subject_ends_with = kwargs['subjectEndsWith']

        if advanced_filters is not None:
            _setter("advanced_filters", advanced_filters)
        if enable_advanced_filtering_on_arrays is not None:
            _setter("enable_advanced_filtering_on_arrays", enable_advanced_filtering_on_arrays)
        if included_event_types is not None:
            _setter("included_event_types", included_event_types)
        if is_subject_case_sensitive is None:
            is_subject_case_sensitive = False
        if is_subject_case_sensitive is not None:
            _setter("is_subject_case_sensitive", is_subject_case_sensitive)
        if subject_begins_with is not None:
            _setter("subject_begins_with", subject_begins_with)
        if subject_ends_with is not None:
            _setter("subject_ends_with", subject_ends_with)

    @property
    @pulumi.getter(name="advancedFilters")
    def advanced_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['BoolEqualsAdvancedFilterArgs', 'IsNotNullAdvancedFilterArgs', 'IsNullOrUndefinedAdvancedFilterArgs', 'NumberGreaterThanAdvancedFilterArgs', 'NumberGreaterThanOrEqualsAdvancedFilterArgs', 'NumberInAdvancedFilterArgs', 'NumberInRangeAdvancedFilterArgs', 'NumberLessThanAdvancedFilterArgs', 'NumberLessThanOrEqualsAdvancedFilterArgs', 'NumberNotInAdvancedFilterArgs', 'NumberNotInRangeAdvancedFilterArgs', 'StringBeginsWithAdvancedFilterArgs', 'StringContainsAdvancedFilterArgs', 'StringEndsWithAdvancedFilterArgs', 'StringInAdvancedFilterArgs', 'StringNotBeginsWithAdvancedFilterArgs', 'StringNotContainsAdvancedFilterArgs', 'StringNotEndsWithAdvancedFilterArgs', 'StringNotInAdvancedFilterArgs']]]]]:
        """
        An array of advanced filters that are used for filtering event subscriptions.
        """
        return pulumi.get(self, "advanced_filters")

    @advanced_filters.setter
    def advanced_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BoolEqualsAdvancedFilterArgs', 'IsNotNullAdvancedFilterArgs', 'IsNullOrUndefinedAdvancedFilterArgs', 'NumberGreaterThanAdvancedFilterArgs', 'NumberGreaterThanOrEqualsAdvancedFilterArgs', 'NumberInAdvancedFilterArgs', 'NumberInRangeAdvancedFilterArgs', 'NumberLessThanAdvancedFilterArgs', 'NumberLessThanOrEqualsAdvancedFilterArgs', 'NumberNotInAdvancedFilterArgs', 'NumberNotInRangeAdvancedFilterArgs', 'StringBeginsWithAdvancedFilterArgs', 'StringContainsAdvancedFilterArgs', 'StringEndsWithAdvancedFilterArgs', 'StringInAdvancedFilterArgs', 'StringNotBeginsWithAdvancedFilterArgs', 'StringNotContainsAdvancedFilterArgs', 'StringNotEndsWithAdvancedFilterArgs', 'StringNotInAdvancedFilterArgs']]]]]):
        pulumi.set(self, "advanced_filters", value)

    @property
    @pulumi.getter(name="enableAdvancedFilteringOnArrays")
    def enable_advanced_filtering_on_arrays(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows advanced filters to be evaluated against an array of values instead of expecting a singular value.
        """
        return pulumi.get(self, "enable_advanced_filtering_on_arrays")

    @enable_advanced_filtering_on_arrays.setter
    def enable_advanced_filtering_on_arrays(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_advanced_filtering_on_arrays", value)

    @property
    @pulumi.getter(name="includedEventTypes")
    def included_event_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of applicable event types that need to be part of the event subscription. If it is desired to subscribe to all default event types, set the IncludedEventTypes to null.
        """
        return pulumi.get(self, "included_event_types")

    @included_event_types.setter
    def included_event_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_event_types", value)

    @property
    @pulumi.getter(name="isSubjectCaseSensitive")
    def is_subject_case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the SubjectBeginsWith and SubjectEndsWith properties of the filter
        should be compared in a case sensitive manner.
        """
        return pulumi.get(self, "is_subject_case_sensitive")

    @is_subject_case_sensitive.setter
    def is_subject_case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_subject_case_sensitive", value)

    @property
    @pulumi.getter(name="subjectBeginsWith")
    def subject_begins_with(self) -> Optional[pulumi.Input[str]]:
        """
        An optional string to filter events for an event subscription based on a resource path prefix.
        The format of this depends on the publisher of the events.
        Wildcard characters are not supported in this path.
        """
        return pulumi.get(self, "subject_begins_with")

    @subject_begins_with.setter
    def subject_begins_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_begins_with", value)

    @property
    @pulumi.getter(name="subjectEndsWith")
    def subject_ends_with(self) -> Optional[pulumi.Input[str]]:
        """
        An optional string to filter events for an event subscription based on a resource path suffix.
        Wildcard characters are not supported in this path.
        """
        return pulumi.get(self, "subject_ends_with")

    @subject_ends_with.setter
    def subject_ends_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_ends_with", value)


@pulumi.input_type
class EventSubscriptionIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'EventSubscriptionIdentityType']]] = None,
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        The identity information with the event subscription.
        :param pulumi.Input[Union[str, 'EventSubscriptionIdentityType']] type: The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identity.
        :param pulumi.Input[str] user_assigned_identity: The user identity associated with the resource.
        """
        EventSubscriptionIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            user_assigned_identity=user_assigned_identity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[Union[str, 'EventSubscriptionIdentityType']]] = None,
             user_assigned_identity: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if user_assigned_identity is None and 'userAssignedIdentity' in kwargs:
            user_assigned_identity = kwargs['userAssignedIdentity']

        if type is not None:
            _setter("type", type)
        if user_assigned_identity is not None:
            _setter("user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'EventSubscriptionIdentityType']]]:
        """
        The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'EventSubscriptionIdentityType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The user identity associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


@pulumi.input_type
class EventTypeInfoArgs:
    def __init__(__self__, *,
                 inline_event_types: Optional[pulumi.Input[Mapping[str, pulumi.Input['InlineEventPropertiesArgs']]]] = None,
                 kind: Optional[pulumi.Input[Union[str, 'EventDefinitionKind']]] = None):
        """
        The event type information for Channels.
        :param pulumi.Input[Mapping[str, pulumi.Input['InlineEventPropertiesArgs']]] inline_event_types: A collection of inline event types for the resource. The inline event type keys are of type string which represents the name of the event.
               An example of a valid inline event name is "Contoso.OrderCreated".
               The inline event type values are of type InlineEventProperties and will contain additional information for every inline event type.
        :param pulumi.Input[Union[str, 'EventDefinitionKind']] kind: The kind of event type used.
        """
        EventTypeInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inline_event_types=inline_event_types,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inline_event_types: Optional[pulumi.Input[Mapping[str, pulumi.Input['InlineEventPropertiesArgs']]]] = None,
             kind: Optional[pulumi.Input[Union[str, 'EventDefinitionKind']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if inline_event_types is None and 'inlineEventTypes' in kwargs:
            inline_event_types = kwargs['inlineEventTypes']

        if inline_event_types is not None:
            _setter("inline_event_types", inline_event_types)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter(name="inlineEventTypes")
    def inline_event_types(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['InlineEventPropertiesArgs']]]]:
        """
        A collection of inline event types for the resource. The inline event type keys are of type string which represents the name of the event.
        An example of a valid inline event name is "Contoso.OrderCreated".
        The inline event type values are of type InlineEventProperties and will contain additional information for every inline event type.
        """
        return pulumi.get(self, "inline_event_types")

    @inline_event_types.setter
    def inline_event_types(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['InlineEventPropertiesArgs']]]]):
        pulumi.set(self, "inline_event_types", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[str, 'EventDefinitionKind']]]:
        """
        The kind of event type used.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[str, 'EventDefinitionKind']]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class HybridConnectionEventSubscriptionDestinationArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[str],
                 delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Information about the HybridConnection destination for an event subscription.
        :param pulumi.Input[str] endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'HybridConnection'.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]] delivery_attribute_mappings: Delivery attribute details.
        :param pulumi.Input[str] resource_id: The Azure Resource ID of an hybrid connection that is the destination of an event subscription.
        """
        HybridConnectionEventSubscriptionDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_type=endpoint_type,
            delivery_attribute_mappings=delivery_attribute_mappings,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_type: Optional[pulumi.Input[str]] = None,
             delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if endpoint_type is None:
            raise TypeError("Missing 'endpoint_type' argument")
        if delivery_attribute_mappings is None and 'deliveryAttributeMappings' in kwargs:
            delivery_attribute_mappings = kwargs['deliveryAttributeMappings']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("endpoint_type", 'HybridConnection')
        if delivery_attribute_mappings is not None:
            _setter("delivery_attribute_mappings", delivery_attribute_mappings)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[str]:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'HybridConnection'.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @delivery_attribute_mappings.setter
    def delivery_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]):
        pulumi.set(self, "delivery_attribute_mappings", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Resource ID of an hybrid connection that is the destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class IdentityInfoArgs:
    def __init__(__self__, *,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'IdentityType']]] = None,
                 user_assigned_identities: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgs']]]] = None):
        """
        The identity information for the resource.
        :param pulumi.Input[str] principal_id: The principal ID of resource identity.
        :param pulumi.Input[str] tenant_id: The tenant ID of resource.
        :param pulumi.Input[Union[str, 'IdentityType']] type: The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identity.
        :param pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgs']]] user_assigned_identities: The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
               '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
               This property is currently not used and reserved for future usage.
        """
        IdentityInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[pulumi.Input[str]] = None,
             tenant_id: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[Union[str, 'IdentityType']]] = None,
             user_assigned_identities: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        if principal_id is not None:
            _setter("principal_id", principal_id)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'IdentityType']]]:
        """
        The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'IdentityType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgs']]]]:
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        This property is currently not used and reserved for future usage.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityPropertiesArgs']]]]):
        pulumi.set(self, "user_assigned_identities", value)


@pulumi.input_type
class InboundIpRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[Union[str, 'IpActionType']]] = None,
                 ip_mask: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Union[str, 'IpActionType']] action: Action to perform based on the match or no match of the IpMask.
        :param pulumi.Input[str] ip_mask: IP Address in CIDR notation e.g., 10.0.0.0/8.
        """
        InboundIpRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip_mask=ip_mask,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[Union[str, 'IpActionType']]] = None,
             ip_mask: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_mask is None and 'ipMask' in kwargs:
            ip_mask = kwargs['ipMask']

        if action is not None:
            _setter("action", action)
        if ip_mask is not None:
            _setter("ip_mask", ip_mask)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[Union[str, 'IpActionType']]]:
        """
        Action to perform based on the match or no match of the IpMask.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[Union[str, 'IpActionType']]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> Optional[pulumi.Input[str]]:
        """
        IP Address in CIDR notation e.g., 10.0.0.0/8.
        """
        return pulumi.get(self, "ip_mask")

    @ip_mask.setter
    def ip_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_mask", value)


@pulumi.input_type
class InlineEventPropertiesArgs:
    def __init__(__self__, *,
                 data_schema_url: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 documentation_url: Optional[pulumi.Input[str]] = None):
        """
        Additional information about every inline event.
        :param pulumi.Input[str] data_schema_url: The dataSchemaUrl for the inline event.
        :param pulumi.Input[str] description: The description for the inline event.
        :param pulumi.Input[str] display_name: The displayName for the inline event.
        :param pulumi.Input[str] documentation_url: The documentationUrl for the inline event.
        """
        InlineEventPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_schema_url=data_schema_url,
            description=description,
            display_name=display_name,
            documentation_url=documentation_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_schema_url: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             documentation_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_schema_url is None and 'dataSchemaUrl' in kwargs:
            data_schema_url = kwargs['dataSchemaUrl']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if documentation_url is None and 'documentationUrl' in kwargs:
            documentation_url = kwargs['documentationUrl']

        if data_schema_url is not None:
            _setter("data_schema_url", data_schema_url)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if documentation_url is not None:
            _setter("documentation_url", documentation_url)

    @property
    @pulumi.getter(name="dataSchemaUrl")
    def data_schema_url(self) -> Optional[pulumi.Input[str]]:
        """
        The dataSchemaUrl for the inline event.
        """
        return pulumi.get(self, "data_schema_url")

    @data_schema_url.setter
    def data_schema_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_schema_url", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for the inline event.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The displayName for the inline event.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> Optional[pulumi.Input[str]]:
        """
        The documentationUrl for the inline event.
        """
        return pulumi.get(self, "documentation_url")

    @documentation_url.setter
    def documentation_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "documentation_url", value)


@pulumi.input_type
class IsNotNullAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None):
        """
        IsNotNull Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'IsNotNull'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        """
        IsNotNullAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'IsNotNull')
        if key is not None:
            _setter("key", key)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'IsNotNull'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class IsNullOrUndefinedAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None):
        """
        IsNullOrUndefined Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'IsNullOrUndefined'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        """
        IsNullOrUndefinedAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'IsNullOrUndefined')
        if key is not None:
            _setter("key", key)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'IsNullOrUndefined'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class JsonFieldWithDefaultArgs:
    def __init__(__self__, *,
                 default_value: Optional[pulumi.Input[str]] = None,
                 source_field: Optional[pulumi.Input[str]] = None):
        """
        This is used to express the source of an input schema mapping for a single target field
        in the Event Grid Event schema. This is currently used in the mappings for the 'subject',
        'eventtype' and 'dataversion' properties. This represents a field in the input event schema
        along with a default value to be used, and at least one of these two properties should be provided.
        :param pulumi.Input[str] default_value: The default value to be used for mapping when a SourceField is not provided or if there's no property with the specified name in the published JSON event payload.
        :param pulumi.Input[str] source_field: Name of a field in the input event schema that's to be used as the source of a mapping.
        """
        JsonFieldWithDefaultArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_value=default_value,
            source_field=source_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_value: Optional[pulumi.Input[str]] = None,
             source_field: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_value is None and 'defaultValue' in kwargs:
            default_value = kwargs['defaultValue']
        if source_field is None and 'sourceField' in kwargs:
            source_field = kwargs['sourceField']

        if default_value is not None:
            _setter("default_value", default_value)
        if source_field is not None:
            _setter("source_field", source_field)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value to be used for mapping when a SourceField is not provided or if there's no property with the specified name in the published JSON event payload.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of a field in the input event schema that's to be used as the source of a mapping.
        """
        return pulumi.get(self, "source_field")

    @source_field.setter
    def source_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_field", value)


@pulumi.input_type
class JsonFieldArgs:
    def __init__(__self__, *,
                 source_field: Optional[pulumi.Input[str]] = None):
        """
        This is used to express the source of an input schema mapping for a single target field in the Event Grid Event schema. This is currently used in the mappings for the 'id', 'topic' and 'eventtime' properties. This represents a field in the input event schema.
        :param pulumi.Input[str] source_field: Name of a field in the input event schema that's to be used as the source of a mapping.
        """
        JsonFieldArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_field=source_field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_field: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_field is None and 'sourceField' in kwargs:
            source_field = kwargs['sourceField']

        if source_field is not None:
            _setter("source_field", source_field)

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[pulumi.Input[str]]:
        """
        Name of a field in the input event schema that's to be used as the source of a mapping.
        """
        return pulumi.get(self, "source_field")

    @source_field.setter
    def source_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_field", value)


@pulumi.input_type
class JsonInputSchemaMappingArgs:
    def __init__(__self__, *,
                 input_schema_mapping_type: pulumi.Input[str],
                 data_version: Optional[pulumi.Input['JsonFieldWithDefaultArgs']] = None,
                 event_time: Optional[pulumi.Input['JsonFieldArgs']] = None,
                 event_type: Optional[pulumi.Input['JsonFieldWithDefaultArgs']] = None,
                 id: Optional[pulumi.Input['JsonFieldArgs']] = None,
                 subject: Optional[pulumi.Input['JsonFieldWithDefaultArgs']] = None,
                 topic: Optional[pulumi.Input['JsonFieldArgs']] = None):
        """
        This enables publishing to Event Grid using a custom input schema. This can be used to map properties from a custom input JSON schema to the Event Grid event schema.
        :param pulumi.Input[str] input_schema_mapping_type: Type of the custom mapping
               Expected value is 'Json'.
        :param pulumi.Input['JsonFieldWithDefaultArgs'] data_version: The mapping information for the DataVersion property of the Event Grid Event.
        :param pulumi.Input['JsonFieldArgs'] event_time: The mapping information for the EventTime property of the Event Grid Event.
        :param pulumi.Input['JsonFieldWithDefaultArgs'] event_type: The mapping information for the EventType property of the Event Grid Event.
        :param pulumi.Input['JsonFieldArgs'] id: The mapping information for the Id property of the Event Grid Event.
        :param pulumi.Input['JsonFieldWithDefaultArgs'] subject: The mapping information for the Subject property of the Event Grid Event.
        :param pulumi.Input['JsonFieldArgs'] topic: The mapping information for the Topic property of the Event Grid Event.
        """
        JsonInputSchemaMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_schema_mapping_type=input_schema_mapping_type,
            data_version=data_version,
            event_time=event_time,
            event_type=event_type,
            id=id,
            subject=subject,
            topic=topic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_schema_mapping_type: Optional[pulumi.Input[str]] = None,
             data_version: Optional[pulumi.Input['JsonFieldWithDefaultArgs']] = None,
             event_time: Optional[pulumi.Input['JsonFieldArgs']] = None,
             event_type: Optional[pulumi.Input['JsonFieldWithDefaultArgs']] = None,
             id: Optional[pulumi.Input['JsonFieldArgs']] = None,
             subject: Optional[pulumi.Input['JsonFieldWithDefaultArgs']] = None,
             topic: Optional[pulumi.Input['JsonFieldArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if input_schema_mapping_type is None and 'inputSchemaMappingType' in kwargs:
            input_schema_mapping_type = kwargs['inputSchemaMappingType']
        if input_schema_mapping_type is None:
            raise TypeError("Missing 'input_schema_mapping_type' argument")
        if data_version is None and 'dataVersion' in kwargs:
            data_version = kwargs['dataVersion']
        if event_time is None and 'eventTime' in kwargs:
            event_time = kwargs['eventTime']
        if event_type is None and 'eventType' in kwargs:
            event_type = kwargs['eventType']

        _setter("input_schema_mapping_type", 'Json')
        if data_version is not None:
            _setter("data_version", data_version)
        if event_time is not None:
            _setter("event_time", event_time)
        if event_type is not None:
            _setter("event_type", event_type)
        if id is not None:
            _setter("id", id)
        if subject is not None:
            _setter("subject", subject)
        if topic is not None:
            _setter("topic", topic)

    @property
    @pulumi.getter(name="inputSchemaMappingType")
    def input_schema_mapping_type(self) -> pulumi.Input[str]:
        """
        Type of the custom mapping
        Expected value is 'Json'.
        """
        return pulumi.get(self, "input_schema_mapping_type")

    @input_schema_mapping_type.setter
    def input_schema_mapping_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_schema_mapping_type", value)

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional[pulumi.Input['JsonFieldWithDefaultArgs']]:
        """
        The mapping information for the DataVersion property of the Event Grid Event.
        """
        return pulumi.get(self, "data_version")

    @data_version.setter
    def data_version(self, value: Optional[pulumi.Input['JsonFieldWithDefaultArgs']]):
        pulumi.set(self, "data_version", value)

    @property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> Optional[pulumi.Input['JsonFieldArgs']]:
        """
        The mapping information for the EventTime property of the Event Grid Event.
        """
        return pulumi.get(self, "event_time")

    @event_time.setter
    def event_time(self, value: Optional[pulumi.Input['JsonFieldArgs']]):
        pulumi.set(self, "event_time", value)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input['JsonFieldWithDefaultArgs']]:
        """
        The mapping information for the EventType property of the Event Grid Event.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input['JsonFieldWithDefaultArgs']]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input['JsonFieldArgs']]:
        """
        The mapping information for the Id property of the Event Grid Event.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input['JsonFieldArgs']]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input['JsonFieldWithDefaultArgs']]:
        """
        The mapping information for the Subject property of the Event Grid Event.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input['JsonFieldWithDefaultArgs']]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['JsonFieldArgs']]:
        """
        The mapping information for the Topic property of the Event Grid Event.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['JsonFieldArgs']]):
        pulumi.set(self, "topic", value)


@pulumi.input_type
class NumberGreaterThanAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[float]] = None):
        """
        NumberGreaterThan Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberGreaterThan'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[float] value: The filter value.
        """
        NumberGreaterThanAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'NumberGreaterThan')
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberGreaterThan'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[float]]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NumberGreaterThanOrEqualsAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[float]] = None):
        """
        NumberGreaterThanOrEquals Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberGreaterThanOrEquals'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[float] value: The filter value.
        """
        NumberGreaterThanOrEqualsAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'NumberGreaterThanOrEquals')
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberGreaterThanOrEquals'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[float]]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NumberInAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]] = None):
        """
        NumberIn Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberIn'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] values: The set of filter values.
        """
        NumberInAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'NumberIn')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberIn'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class NumberInRangeAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]] = None):
        """
        NumberInRange Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberInRange'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]] values: The set of filter values.
        """
        NumberInRangeAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'NumberInRange')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberInRange'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class NumberLessThanAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[float]] = None):
        """
        NumberLessThan Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberLessThan'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[float] value: The filter value.
        """
        NumberLessThanAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'NumberLessThan')
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberLessThan'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[float]]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NumberLessThanOrEqualsAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[float]] = None):
        """
        NumberLessThanOrEquals Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberLessThanOrEquals'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[float] value: The filter value.
        """
        NumberLessThanOrEqualsAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'NumberLessThanOrEquals')
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberLessThanOrEquals'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[float]]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NumberNotInAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]] = None):
        """
        NumberNotIn Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberNotIn'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] values: The set of filter values.
        """
        NumberNotInAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'NumberNotIn')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberNotIn'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class NumberNotInRangeAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]] = None):
        """
        NumberNotInRange Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberNotInRange'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]] values: The set of filter values.
        """
        NumberNotInRangeAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'NumberNotInRange')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberNotInRange'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class PartnerAuthorizationArgs:
    def __init__(__self__, *,
                 authorized_partners_list: Optional[pulumi.Input[Sequence[pulumi.Input['PartnerArgs']]]] = None,
                 default_maximum_expiration_time_in_days: Optional[pulumi.Input[int]] = None):
        """
        The partner authorization details.
        :param pulumi.Input[Sequence[pulumi.Input['PartnerArgs']]] authorized_partners_list: The list of authorized partners.
        :param pulumi.Input[int] default_maximum_expiration_time_in_days: Time used to validate the authorization expiration time for each authorized partner. If DefaultMaximumExpirationTimeInDays is
               not specified, the default is 7 days. Otherwise, allowed values are between 1 and 365 days.
        """
        PartnerAuthorizationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorized_partners_list=authorized_partners_list,
            default_maximum_expiration_time_in_days=default_maximum_expiration_time_in_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorized_partners_list: Optional[pulumi.Input[Sequence[pulumi.Input['PartnerArgs']]]] = None,
             default_maximum_expiration_time_in_days: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authorized_partners_list is None and 'authorizedPartnersList' in kwargs:
            authorized_partners_list = kwargs['authorizedPartnersList']
        if default_maximum_expiration_time_in_days is None and 'defaultMaximumExpirationTimeInDays' in kwargs:
            default_maximum_expiration_time_in_days = kwargs['defaultMaximumExpirationTimeInDays']

        if authorized_partners_list is not None:
            _setter("authorized_partners_list", authorized_partners_list)
        if default_maximum_expiration_time_in_days is not None:
            _setter("default_maximum_expiration_time_in_days", default_maximum_expiration_time_in_days)

    @property
    @pulumi.getter(name="authorizedPartnersList")
    def authorized_partners_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PartnerArgs']]]]:
        """
        The list of authorized partners.
        """
        return pulumi.get(self, "authorized_partners_list")

    @authorized_partners_list.setter
    def authorized_partners_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PartnerArgs']]]]):
        pulumi.set(self, "authorized_partners_list", value)

    @property
    @pulumi.getter(name="defaultMaximumExpirationTimeInDays")
    def default_maximum_expiration_time_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Time used to validate the authorization expiration time for each authorized partner. If DefaultMaximumExpirationTimeInDays is
        not specified, the default is 7 days. Otherwise, allowed values are between 1 and 365 days.
        """
        return pulumi.get(self, "default_maximum_expiration_time_in_days")

    @default_maximum_expiration_time_in_days.setter
    def default_maximum_expiration_time_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_maximum_expiration_time_in_days", value)


@pulumi.input_type
class PartnerTopicInfoArgs:
    def __init__(__self__, *,
                 azure_subscription_id: Optional[pulumi.Input[str]] = None,
                 event_type_info: Optional[pulumi.Input['EventTypeInfoArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resource_group_name: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        Properties of the corresponding partner topic of a Channel.
        :param pulumi.Input[str] azure_subscription_id: Azure subscription ID of the subscriber. The partner topic associated with the channel will be
               created under this Azure subscription.
        :param pulumi.Input['EventTypeInfoArgs'] event_type_info: Event Type Information for the partner topic. This information is provided by the publisher and can be used by the 
               subscriber to view different types of events that are published.
        :param pulumi.Input[str] name: Name of the partner topic associated with the channel.
        :param pulumi.Input[str] resource_group_name: Azure Resource Group of the subscriber. The partner topic associated with the channel will be
               created under this resource group.
        :param pulumi.Input[str] source: The source information is provided by the publisher to determine the scope or context from which the events
               are originating. This information can be used by the subscriber during the approval process of the
               created partner topic.
        """
        PartnerTopicInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_subscription_id=azure_subscription_id,
            event_type_info=event_type_info,
            name=name,
            resource_group_name=resource_group_name,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_subscription_id: Optional[pulumi.Input[str]] = None,
             event_type_info: Optional[pulumi.Input['EventTypeInfoArgs']] = None,
             name: Optional[pulumi.Input[str]] = None,
             resource_group_name: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_subscription_id is None and 'azureSubscriptionId' in kwargs:
            azure_subscription_id = kwargs['azureSubscriptionId']
        if event_type_info is None and 'eventTypeInfo' in kwargs:
            event_type_info = kwargs['eventTypeInfo']
        if resource_group_name is None and 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']

        if azure_subscription_id is not None:
            _setter("azure_subscription_id", azure_subscription_id)
        if event_type_info is not None:
            _setter("event_type_info", event_type_info)
        if name is not None:
            _setter("name", name)
        if resource_group_name is not None:
            _setter("resource_group_name", resource_group_name)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure subscription ID of the subscriber. The partner topic associated with the channel will be
        created under this Azure subscription.
        """
        return pulumi.get(self, "azure_subscription_id")

    @azure_subscription_id.setter
    def azure_subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_subscription_id", value)

    @property
    @pulumi.getter(name="eventTypeInfo")
    def event_type_info(self) -> Optional[pulumi.Input['EventTypeInfoArgs']]:
        """
        Event Type Information for the partner topic. This information is provided by the publisher and can be used by the 
        subscriber to view different types of events that are published.
        """
        return pulumi.get(self, "event_type_info")

    @event_type_info.setter
    def event_type_info(self, value: Optional[pulumi.Input['EventTypeInfoArgs']]):
        pulumi.set(self, "event_type_info", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the partner topic associated with the channel.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Resource Group of the subscriber. The partner topic associated with the channel will be
        created under this resource group.
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source information is provided by the publisher to determine the scope or context from which the events
        are originating. This information can be used by the subscriber during the approval process of the
        created partner topic.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class PartnerArgs:
    def __init__(__self__, *,
                 authorization_expiration_time_in_utc: Optional[pulumi.Input[str]] = None,
                 partner_name: Optional[pulumi.Input[str]] = None,
                 partner_registration_immutable_id: Optional[pulumi.Input[str]] = None):
        """
        Information about the partner.
        :param pulumi.Input[str] authorization_expiration_time_in_utc: Expiration time of the partner authorization. If this timer expires, any request from this partner to create, update or delete resources in subscriber's
               context will fail. If specified, the allowed values are between 1 to the value of defaultMaximumExpirationTimeInDays specified in PartnerConfiguration.
               If not specified, the default value will be the value of defaultMaximumExpirationTimeInDays specified in PartnerConfiguration or 7 if this value is not specified.
        :param pulumi.Input[str] partner_name: The partner name.
        :param pulumi.Input[str] partner_registration_immutable_id: The immutableId of the corresponding partner registration.
        """
        PartnerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization_expiration_time_in_utc=authorization_expiration_time_in_utc,
            partner_name=partner_name,
            partner_registration_immutable_id=partner_registration_immutable_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization_expiration_time_in_utc: Optional[pulumi.Input[str]] = None,
             partner_name: Optional[pulumi.Input[str]] = None,
             partner_registration_immutable_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if authorization_expiration_time_in_utc is None and 'authorizationExpirationTimeInUtc' in kwargs:
            authorization_expiration_time_in_utc = kwargs['authorizationExpirationTimeInUtc']
        if partner_name is None and 'partnerName' in kwargs:
            partner_name = kwargs['partnerName']
        if partner_registration_immutable_id is None and 'partnerRegistrationImmutableId' in kwargs:
            partner_registration_immutable_id = kwargs['partnerRegistrationImmutableId']

        if authorization_expiration_time_in_utc is not None:
            _setter("authorization_expiration_time_in_utc", authorization_expiration_time_in_utc)
        if partner_name is not None:
            _setter("partner_name", partner_name)
        if partner_registration_immutable_id is not None:
            _setter("partner_registration_immutable_id", partner_registration_immutable_id)

    @property
    @pulumi.getter(name="authorizationExpirationTimeInUtc")
    def authorization_expiration_time_in_utc(self) -> Optional[pulumi.Input[str]]:
        """
        Expiration time of the partner authorization. If this timer expires, any request from this partner to create, update or delete resources in subscriber's
        context will fail. If specified, the allowed values are between 1 to the value of defaultMaximumExpirationTimeInDays specified in PartnerConfiguration.
        If not specified, the default value will be the value of defaultMaximumExpirationTimeInDays specified in PartnerConfiguration or 7 if this value is not specified.
        """
        return pulumi.get(self, "authorization_expiration_time_in_utc")

    @authorization_expiration_time_in_utc.setter
    def authorization_expiration_time_in_utc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_expiration_time_in_utc", value)

    @property
    @pulumi.getter(name="partnerName")
    def partner_name(self) -> Optional[pulumi.Input[str]]:
        """
        The partner name.
        """
        return pulumi.get(self, "partner_name")

    @partner_name.setter
    def partner_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partner_name", value)

    @property
    @pulumi.getter(name="partnerRegistrationImmutableId")
    def partner_registration_immutable_id(self) -> Optional[pulumi.Input[str]]:
        """
        The immutableId of the corresponding partner registration.
        """
        return pulumi.get(self, "partner_registration_immutable_id")

    @partner_registration_immutable_id.setter
    def partner_registration_immutable_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partner_registration_immutable_id", value)


@pulumi.input_type
class PrivateEndpointArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        PrivateEndpoint information.
        :param pulumi.Input[str] id: The ARM identifier for Private Endpoint.
        """
        PrivateEndpointArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM identifier for Private Endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class RetryPolicyArgs:
    def __init__(__self__, *,
                 event_time_to_live_in_minutes: Optional[pulumi.Input[int]] = None,
                 max_delivery_attempts: Optional[pulumi.Input[int]] = None):
        """
        Information about the retry policy for an event subscription.
        :param pulumi.Input[int] event_time_to_live_in_minutes: Time To Live (in minutes) for events.
        :param pulumi.Input[int] max_delivery_attempts: Maximum number of delivery retry attempts for events.
        """
        RetryPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_time_to_live_in_minutes=event_time_to_live_in_minutes,
            max_delivery_attempts=max_delivery_attempts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_time_to_live_in_minutes: Optional[pulumi.Input[int]] = None,
             max_delivery_attempts: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if event_time_to_live_in_minutes is None and 'eventTimeToLiveInMinutes' in kwargs:
            event_time_to_live_in_minutes = kwargs['eventTimeToLiveInMinutes']
        if max_delivery_attempts is None and 'maxDeliveryAttempts' in kwargs:
            max_delivery_attempts = kwargs['maxDeliveryAttempts']

        if event_time_to_live_in_minutes is None:
            event_time_to_live_in_minutes = 1440
        if event_time_to_live_in_minutes is not None:
            _setter("event_time_to_live_in_minutes", event_time_to_live_in_minutes)
        if max_delivery_attempts is None:
            max_delivery_attempts = 30
        if max_delivery_attempts is not None:
            _setter("max_delivery_attempts", max_delivery_attempts)

    @property
    @pulumi.getter(name="eventTimeToLiveInMinutes")
    def event_time_to_live_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Time To Live (in minutes) for events.
        """
        return pulumi.get(self, "event_time_to_live_in_minutes")

    @event_time_to_live_in_minutes.setter
    def event_time_to_live_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "event_time_to_live_in_minutes", value)

    @property
    @pulumi.getter(name="maxDeliveryAttempts")
    def max_delivery_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of delivery retry attempts for events.
        """
        return pulumi.get(self, "max_delivery_attempts")

    @max_delivery_attempts.setter
    def max_delivery_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_delivery_attempts", value)


@pulumi.input_type
class ServiceBusQueueEventSubscriptionDestinationArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[str],
                 delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Information about the service bus destination for an event subscription.
        :param pulumi.Input[str] endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'ServiceBusQueue'.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]] delivery_attribute_mappings: Delivery attribute details.
        :param pulumi.Input[str] resource_id: The Azure Resource Id that represents the endpoint of the Service Bus destination of an event subscription.
        """
        ServiceBusQueueEventSubscriptionDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_type=endpoint_type,
            delivery_attribute_mappings=delivery_attribute_mappings,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_type: Optional[pulumi.Input[str]] = None,
             delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if endpoint_type is None:
            raise TypeError("Missing 'endpoint_type' argument")
        if delivery_attribute_mappings is None and 'deliveryAttributeMappings' in kwargs:
            delivery_attribute_mappings = kwargs['deliveryAttributeMappings']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("endpoint_type", 'ServiceBusQueue')
        if delivery_attribute_mappings is not None:
            _setter("delivery_attribute_mappings", delivery_attribute_mappings)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[str]:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'ServiceBusQueue'.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @delivery_attribute_mappings.setter
    def delivery_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]):
        pulumi.set(self, "delivery_attribute_mappings", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Resource Id that represents the endpoint of the Service Bus destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class ServiceBusTopicEventSubscriptionDestinationArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[str],
                 delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Information about the service bus topic destination for an event subscription.
        :param pulumi.Input[str] endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'ServiceBusTopic'.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]] delivery_attribute_mappings: Delivery attribute details.
        :param pulumi.Input[str] resource_id: The Azure Resource Id that represents the endpoint of the Service Bus Topic destination of an event subscription.
        """
        ServiceBusTopicEventSubscriptionDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_type=endpoint_type,
            delivery_attribute_mappings=delivery_attribute_mappings,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_type: Optional[pulumi.Input[str]] = None,
             delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if endpoint_type is None:
            raise TypeError("Missing 'endpoint_type' argument")
        if delivery_attribute_mappings is None and 'deliveryAttributeMappings' in kwargs:
            delivery_attribute_mappings = kwargs['deliveryAttributeMappings']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("endpoint_type", 'ServiceBusTopic')
        if delivery_attribute_mappings is not None:
            _setter("delivery_attribute_mappings", delivery_attribute_mappings)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[str]:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'ServiceBusTopic'.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @delivery_attribute_mappings.setter
    def delivery_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]):
        pulumi.set(self, "delivery_attribute_mappings", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Resource Id that represents the endpoint of the Service Bus Topic destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class StaticDeliveryAttributeMappingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Static delivery attribute mapping details.
        :param pulumi.Input[str] type: Type of the delivery attribute or header name.
               Expected value is 'Static'.
        :param pulumi.Input[bool] is_secret: Boolean flag to tell if the attribute contains sensitive information .
        :param pulumi.Input[str] name: Name of the delivery attribute or header.
        :param pulumi.Input[str] value: Value of the delivery attribute.
        """
        StaticDeliveryAttributeMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            is_secret=is_secret,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             is_secret: Optional[pulumi.Input[bool]] = None,
             name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if is_secret is None and 'isSecret' in kwargs:
            is_secret = kwargs['isSecret']

        _setter("type", 'Static')
        if is_secret is None:
            is_secret = False
        if is_secret is not None:
            _setter("is_secret", is_secret)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the delivery attribute or header name.
        Expected value is 'Static'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag to tell if the attribute contains sensitive information .
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the delivery attribute or header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the delivery attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class StorageBlobDeadLetterDestinationArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[str],
                 blob_container_name: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Information about the storage blob based dead letter destination.
        :param pulumi.Input[str] endpoint_type: Type of the endpoint for the dead letter destination
               Expected value is 'StorageBlob'.
        :param pulumi.Input[str] blob_container_name: The name of the Storage blob container that is the destination of the deadletter events
        :param pulumi.Input[str] resource_id: The Azure Resource ID of the storage account that is the destination of the deadletter events
        """
        StorageBlobDeadLetterDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_type=endpoint_type,
            blob_container_name=blob_container_name,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_type: Optional[pulumi.Input[str]] = None,
             blob_container_name: Optional[pulumi.Input[str]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if endpoint_type is None:
            raise TypeError("Missing 'endpoint_type' argument")
        if blob_container_name is None and 'blobContainerName' in kwargs:
            blob_container_name = kwargs['blobContainerName']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("endpoint_type", 'StorageBlob')
        if blob_container_name is not None:
            _setter("blob_container_name", blob_container_name)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[str]:
        """
        Type of the endpoint for the dead letter destination
        Expected value is 'StorageBlob'.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="blobContainerName")
    def blob_container_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Storage blob container that is the destination of the deadletter events
        """
        return pulumi.get(self, "blob_container_name")

    @blob_container_name.setter
    def blob_container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "blob_container_name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Resource ID of the storage account that is the destination of the deadletter events
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class StorageQueueEventSubscriptionDestinationArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[str],
                 queue_message_time_to_live_in_seconds: Optional[pulumi.Input[float]] = None,
                 queue_name: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Information about the storage queue destination for an event subscription.
        :param pulumi.Input[str] endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'StorageQueue'.
        :param pulumi.Input[float] queue_message_time_to_live_in_seconds: Storage queue message time to live in seconds.
        :param pulumi.Input[str] queue_name: The name of the Storage queue under a storage account that is the destination of an event subscription.
        :param pulumi.Input[str] resource_id: The Azure Resource ID of the storage account that contains the queue that is the destination of an event subscription.
        """
        StorageQueueEventSubscriptionDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_type=endpoint_type,
            queue_message_time_to_live_in_seconds=queue_message_time_to_live_in_seconds,
            queue_name=queue_name,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_type: Optional[pulumi.Input[str]] = None,
             queue_message_time_to_live_in_seconds: Optional[pulumi.Input[float]] = None,
             queue_name: Optional[pulumi.Input[str]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if endpoint_type is None:
            raise TypeError("Missing 'endpoint_type' argument")
        if queue_message_time_to_live_in_seconds is None and 'queueMessageTimeToLiveInSeconds' in kwargs:
            queue_message_time_to_live_in_seconds = kwargs['queueMessageTimeToLiveInSeconds']
        if queue_name is None and 'queueName' in kwargs:
            queue_name = kwargs['queueName']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        _setter("endpoint_type", 'StorageQueue')
        if queue_message_time_to_live_in_seconds is not None:
            _setter("queue_message_time_to_live_in_seconds", queue_message_time_to_live_in_seconds)
        if queue_name is not None:
            _setter("queue_name", queue_name)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[str]:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'StorageQueue'.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="queueMessageTimeToLiveInSeconds")
    def queue_message_time_to_live_in_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Storage queue message time to live in seconds.
        """
        return pulumi.get(self, "queue_message_time_to_live_in_seconds")

    @queue_message_time_to_live_in_seconds.setter
    def queue_message_time_to_live_in_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "queue_message_time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Storage queue under a storage account that is the destination of an event subscription.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Resource ID of the storage account that contains the queue that is the destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class StringBeginsWithAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        StringBeginsWith Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringBeginsWith'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The set of filter values.
        """
        StringBeginsWithAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'StringBeginsWith')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringBeginsWith'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class StringContainsAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        StringContains Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringContains'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The set of filter values.
        """
        StringContainsAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'StringContains')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringContains'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class StringEndsWithAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        StringEndsWith Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringEndsWith'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The set of filter values.
        """
        StringEndsWithAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'StringEndsWith')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringEndsWith'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class StringInAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        StringIn Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringIn'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The set of filter values.
        """
        StringInAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'StringIn')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringIn'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class StringNotBeginsWithAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        StringNotBeginsWith Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotBeginsWith'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The set of filter values.
        """
        StringNotBeginsWithAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'StringNotBeginsWith')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotBeginsWith'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class StringNotContainsAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        StringNotContains Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotContains'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The set of filter values.
        """
        StringNotContainsAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'StringNotContains')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotContains'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class StringNotEndsWithAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        StringNotEndsWith Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotEndsWith'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The set of filter values.
        """
        StringNotEndsWithAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'StringNotEndsWith')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotEndsWith'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class StringNotInAdvancedFilterArgs:
    def __init__(__self__, *,
                 operator_type: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        StringNotIn Advanced Filter.
        :param pulumi.Input[str] operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotIn'.
        :param pulumi.Input[str] key: The field/property in the event based on which you want to filter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The set of filter values.
        """
        StringNotInAdvancedFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator_type=operator_type,
            key=key,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator_type: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator_type is None and 'operatorType' in kwargs:
            operator_type = kwargs['operatorType']
        if operator_type is None:
            raise TypeError("Missing 'operator_type' argument")

        _setter("operator_type", 'StringNotIn')
        if key is not None:
            _setter("key", key)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> pulumi.Input[str]:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotIn'.
        """
        return pulumi.get(self, "operator_type")

    @operator_type.setter
    def operator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_type", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class UserIdentityPropertiesArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None):
        """
        The information about the user identity.
        :param pulumi.Input[str] client_id: The client id of user assigned identity.
        :param pulumi.Input[str] principal_id: The principal id of user assigned identity.
        """
        UserIdentityPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            principal_id=principal_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             principal_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']

        if client_id is not None:
            _setter("client_id", client_id)
        if principal_id is not None:
            _setter("principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)


@pulumi.input_type
class WebHookEventSubscriptionDestinationArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[str],
                 azure_active_directory_application_id_or_uri: Optional[pulumi.Input[str]] = None,
                 azure_active_directory_tenant_id: Optional[pulumi.Input[str]] = None,
                 delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
                 endpoint_url: Optional[pulumi.Input[str]] = None,
                 max_events_per_batch: Optional[pulumi.Input[int]] = None,
                 preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None):
        """
        Information about the webhook destination for an event subscription.
        :param pulumi.Input[str] endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'WebHook'.
        :param pulumi.Input[str] azure_active_directory_application_id_or_uri: The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        :param pulumi.Input[str] azure_active_directory_tenant_id: The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]] delivery_attribute_mappings: Delivery attribute details.
        :param pulumi.Input[str] endpoint_url: The URL that represents the endpoint of the destination of an event subscription.
        :param pulumi.Input[int] max_events_per_batch: Maximum number of events per batch.
        :param pulumi.Input[int] preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        """
        WebHookEventSubscriptionDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_type=endpoint_type,
            azure_active_directory_application_id_or_uri=azure_active_directory_application_id_or_uri,
            azure_active_directory_tenant_id=azure_active_directory_tenant_id,
            delivery_attribute_mappings=delivery_attribute_mappings,
            endpoint_url=endpoint_url,
            max_events_per_batch=max_events_per_batch,
            preferred_batch_size_in_kilobytes=preferred_batch_size_in_kilobytes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_type: Optional[pulumi.Input[str]] = None,
             azure_active_directory_application_id_or_uri: Optional[pulumi.Input[str]] = None,
             azure_active_directory_tenant_id: Optional[pulumi.Input[str]] = None,
             delivery_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]] = None,
             endpoint_url: Optional[pulumi.Input[str]] = None,
             max_events_per_batch: Optional[pulumi.Input[int]] = None,
             preferred_batch_size_in_kilobytes: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if endpoint_type is None:
            raise TypeError("Missing 'endpoint_type' argument")
        if azure_active_directory_application_id_or_uri is None and 'azureActiveDirectoryApplicationIdOrUri' in kwargs:
            azure_active_directory_application_id_or_uri = kwargs['azureActiveDirectoryApplicationIdOrUri']
        if azure_active_directory_tenant_id is None and 'azureActiveDirectoryTenantId' in kwargs:
            azure_active_directory_tenant_id = kwargs['azureActiveDirectoryTenantId']
        if delivery_attribute_mappings is None and 'deliveryAttributeMappings' in kwargs:
            delivery_attribute_mappings = kwargs['deliveryAttributeMappings']
        if endpoint_url is None and 'endpointUrl' in kwargs:
            endpoint_url = kwargs['endpointUrl']
        if max_events_per_batch is None and 'maxEventsPerBatch' in kwargs:
            max_events_per_batch = kwargs['maxEventsPerBatch']
        if preferred_batch_size_in_kilobytes is None and 'preferredBatchSizeInKilobytes' in kwargs:
            preferred_batch_size_in_kilobytes = kwargs['preferredBatchSizeInKilobytes']

        _setter("endpoint_type", 'WebHook')
        if azure_active_directory_application_id_or_uri is not None:
            _setter("azure_active_directory_application_id_or_uri", azure_active_directory_application_id_or_uri)
        if azure_active_directory_tenant_id is not None:
            _setter("azure_active_directory_tenant_id", azure_active_directory_tenant_id)
        if delivery_attribute_mappings is not None:
            _setter("delivery_attribute_mappings", delivery_attribute_mappings)
        if endpoint_url is not None:
            _setter("endpoint_url", endpoint_url)
        if max_events_per_batch is None:
            max_events_per_batch = 1
        if max_events_per_batch is not None:
            _setter("max_events_per_batch", max_events_per_batch)
        if preferred_batch_size_in_kilobytes is None:
            preferred_batch_size_in_kilobytes = 64
        if preferred_batch_size_in_kilobytes is not None:
            _setter("preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[str]:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'WebHook'.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="azureActiveDirectoryApplicationIdOrUri")
    def azure_active_directory_application_id_or_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "azure_active_directory_application_id_or_uri")

    @azure_active_directory_application_id_or_uri.setter
    def azure_active_directory_application_id_or_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_active_directory_application_id_or_uri", value)

    @property
    @pulumi.getter(name="azureActiveDirectoryTenantId")
    def azure_active_directory_tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "azure_active_directory_tenant_id")

    @azure_active_directory_tenant_id.setter
    def azure_active_directory_tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_active_directory_tenant_id", value)

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @delivery_attribute_mappings.setter
    def delivery_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DynamicDeliveryAttributeMappingArgs', 'StaticDeliveryAttributeMappingArgs']]]]]):
        pulumi.set(self, "delivery_attribute_mappings", value)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL that represents the endpoint of the destination of an event subscription.
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_url", value)

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @max_events_per_batch.setter
    def max_events_per_batch(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_events_per_batch", value)

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[pulumi.Input[int]]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")

    @preferred_batch_size_in_kilobytes.setter
    def preferred_batch_size_in_kilobytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preferred_batch_size_in_kilobytes", value)


