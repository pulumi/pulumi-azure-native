# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AzureFunctionEventSubscriptionDestinationResponse',
    'BoolEqualsAdvancedFilterResponse',
    'BoolEqualsFilterResponse',
    'ClientCertificateAuthenticationResponse',
    'ConnectionStateResponse',
    'CustomDomainConfigurationResponse',
    'CustomDomainIdentityResponse',
    'DeadLetterWithResourceIdentityResponse',
    'DeliveryConfigurationResponse',
    'DeliveryWithResourceIdentityResponse',
    'DynamicDeliveryAttributeMappingResponse',
    'DynamicRoutingEnrichmentResponse',
    'EventHubEventSubscriptionDestinationResponse',
    'EventSubscriptionFilterResponse',
    'EventSubscriptionIdentityResponse',
    'EventTypeInfoResponse',
    'FiltersConfigurationResponse',
    'HybridConnectionEventSubscriptionDestinationResponse',
    'IdentityInfoResponse',
    'InboundIpRuleResponse',
    'InlineEventPropertiesResponse',
    'IsNotNullAdvancedFilterResponse',
    'IsNotNullFilterResponse',
    'IsNullOrUndefinedAdvancedFilterResponse',
    'IsNullOrUndefinedFilterResponse',
    'JsonFieldResponse',
    'JsonFieldWithDefaultResponse',
    'JsonInputSchemaMappingResponse',
    'MonitorAlertEventSubscriptionDestinationResponse',
    'NamespaceSkuResponse',
    'NamespaceTopicEventSubscriptionDestinationResponse',
    'NumberGreaterThanAdvancedFilterResponse',
    'NumberGreaterThanFilterResponse',
    'NumberGreaterThanOrEqualsAdvancedFilterResponse',
    'NumberGreaterThanOrEqualsFilterResponse',
    'NumberInAdvancedFilterResponse',
    'NumberInFilterResponse',
    'NumberInRangeAdvancedFilterResponse',
    'NumberInRangeFilterResponse',
    'NumberLessThanAdvancedFilterResponse',
    'NumberLessThanFilterResponse',
    'NumberLessThanOrEqualsAdvancedFilterResponse',
    'NumberLessThanOrEqualsFilterResponse',
    'NumberNotInAdvancedFilterResponse',
    'NumberNotInFilterResponse',
    'NumberNotInRangeAdvancedFilterResponse',
    'NumberNotInRangeFilterResponse',
    'PartnerAuthorizationResponse',
    'PartnerResponse',
    'PartnerTopicInfoResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'PushInfoResponse',
    'QueueInfoResponse',
    'RetryPolicyResponse',
    'RoutingEnrichmentsResponse',
    'RoutingIdentityInfoResponse',
    'ServiceBusQueueEventSubscriptionDestinationResponse',
    'ServiceBusTopicEventSubscriptionDestinationResponse',
    'StaticDeliveryAttributeMappingResponse',
    'StaticStringRoutingEnrichmentResponse',
    'StorageBlobDeadLetterDestinationResponse',
    'StorageQueueEventSubscriptionDestinationResponse',
    'StringBeginsWithAdvancedFilterResponse',
    'StringBeginsWithFilterResponse',
    'StringContainsAdvancedFilterResponse',
    'StringContainsFilterResponse',
    'StringEndsWithAdvancedFilterResponse',
    'StringEndsWithFilterResponse',
    'StringInAdvancedFilterResponse',
    'StringInFilterResponse',
    'StringNotBeginsWithAdvancedFilterResponse',
    'StringNotBeginsWithFilterResponse',
    'StringNotContainsAdvancedFilterResponse',
    'StringNotContainsFilterResponse',
    'StringNotEndsWithAdvancedFilterResponse',
    'StringNotEndsWithFilterResponse',
    'StringNotInAdvancedFilterResponse',
    'StringNotInFilterResponse',
    'SystemDataResponse',
    'TopicSpacesConfigurationResponse',
    'TopicsConfigurationResponse',
    'UserIdentityPropertiesResponse',
    'WebHookEventSubscriptionDestinationResponse',
]

@pulumi.output_type
class AzureFunctionEventSubscriptionDestinationResponse(dict):
    """
    Information about the azure function destination for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "deliveryAttributeMappings":
            suggest = "delivery_attribute_mappings"
        elif key == "maxEventsPerBatch":
            suggest = "max_events_per_batch"
        elif key == "preferredBatchSizeInKilobytes":
            suggest = "preferred_batch_size_in_kilobytes"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFunctionEventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFunctionEventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFunctionEventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 delivery_attribute_mappings: Optional[Sequence[Any]] = None,
                 max_events_per_batch: Optional[builtins.int] = None,
                 preferred_batch_size_in_kilobytes: Optional[builtins.int] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Information about the azure function destination for an event subscription.
        :param builtins.str endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'AzureFunction'.
        :param Sequence[Union['DynamicDeliveryAttributeMappingResponse', 'StaticDeliveryAttributeMappingResponse']] delivery_attribute_mappings: Delivery attribute details.
        :param builtins.int max_events_per_batch: Maximum number of events per batch.
        :param builtins.int preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        :param builtins.str resource_id: The Azure Resource Id that represents the endpoint of the Azure Function destination of an event subscription.
        """
        pulumi.set(__self__, "endpoint_type", 'AzureFunction')
        if delivery_attribute_mappings is not None:
            pulumi.set(__self__, "delivery_attribute_mappings", delivery_attribute_mappings)
        if max_events_per_batch is None:
            max_events_per_batch = 1
        if max_events_per_batch is not None:
            pulumi.set(__self__, "max_events_per_batch", max_events_per_batch)
        if preferred_batch_size_in_kilobytes is None:
            preferred_batch_size_in_kilobytes = 64
        if preferred_batch_size_in_kilobytes is not None:
            pulumi.set(__self__, "preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'AzureFunction'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[Sequence[Any]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[builtins.int]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[builtins.int]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The Azure Resource Id that represents the endpoint of the Azure Function destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class BoolEqualsAdvancedFilterResponse(dict):
    """
    BoolEquals Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BoolEqualsAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BoolEqualsAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BoolEqualsAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.bool] = None):
        """
        BoolEquals Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'BoolEquals'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.bool value: The boolean filter value.
        """
        pulumi.set(__self__, "operator_type", 'BoolEquals')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'BoolEquals'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.bool]:
        """
        The boolean filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BoolEqualsFilterResponse(dict):
    """
    BoolEquals Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BoolEqualsFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BoolEqualsFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BoolEqualsFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.bool] = None):
        """
        BoolEquals Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'BoolEquals'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.bool value: The boolean filter value.
        """
        pulumi.set(__self__, "operator_type", 'BoolEquals')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'BoolEquals'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.bool]:
        """
        The boolean filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClientCertificateAuthenticationResponse(dict):
    """
    The certificate authentication properties for the client.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedThumbprints":
            suggest = "allowed_thumbprints"
        elif key == "validationScheme":
            suggest = "validation_scheme"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientCertificateAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientCertificateAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientCertificateAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_thumbprints: Optional[Sequence[builtins.str]] = None,
                 validation_scheme: Optional[builtins.str] = None):
        """
        The certificate authentication properties for the client.
        :param Sequence[builtins.str] allowed_thumbprints: The list of thumbprints that are allowed during client authentication. This property is required only if the validationScheme is 'ThumbprintMatch'.
        :param builtins.str validation_scheme: The validation scheme used to authenticate the client. Default value is SubjectMatchesAuthenticationName.
        """
        if allowed_thumbprints is not None:
            pulumi.set(__self__, "allowed_thumbprints", allowed_thumbprints)
        if validation_scheme is not None:
            pulumi.set(__self__, "validation_scheme", validation_scheme)

    @property
    @pulumi.getter(name="allowedThumbprints")
    def allowed_thumbprints(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of thumbprints that are allowed during client authentication. This property is required only if the validationScheme is 'ThumbprintMatch'.
        """
        return pulumi.get(self, "allowed_thumbprints")

    @property
    @pulumi.getter(name="validationScheme")
    def validation_scheme(self) -> Optional[builtins.str]:
        """
        The validation scheme used to authenticate the client. Default value is SubjectMatchesAuthenticationName.
        """
        return pulumi.get(self, "validation_scheme")


@pulumi.output_type
class ConnectionStateResponse(dict):
    """
    ConnectionState information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        ConnectionState information.
        :param builtins.str actions_required: Actions required (if any).
        :param builtins.str description: Description of the connection state.
        :param builtins.str status: Status of the connection.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[builtins.str]:
        """
        Actions required (if any).
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the connection state.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Status of the connection.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class CustomDomainConfigurationResponse(dict):
    """
    A custom domain configuration that allows users to publish to their own domain name.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullyQualifiedDomainName":
            suggest = "fully_qualified_domain_name"
        elif key == "certificateUrl":
            suggest = "certificate_url"
        elif key == "expectedTxtRecordName":
            suggest = "expected_txt_record_name"
        elif key == "expectedTxtRecordValue":
            suggest = "expected_txt_record_value"
        elif key == "validationState":
            suggest = "validation_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fully_qualified_domain_name: builtins.str,
                 certificate_url: Optional[builtins.str] = None,
                 expected_txt_record_name: Optional[builtins.str] = None,
                 expected_txt_record_value: Optional[builtins.str] = None,
                 identity: Optional['outputs.CustomDomainIdentityResponse'] = None,
                 validation_state: Optional[builtins.str] = None):
        """
        A custom domain configuration that allows users to publish to their own domain name.
        :param builtins.str fully_qualified_domain_name: Fully Qualified Domain Name (FQDN) for the custom domain.
        :param builtins.str certificate_url: The URL for the certificate that is used for publishing to the custom domain. We currently support certificates stored in Azure Key Vault only. While certificate URL can be either
               versioned URL of the following format https://{key-vault-name}.vault.azure.net/certificates/{certificate-name}/{version-id}, or unversioned URL of the following format (e.g.,
               https://contosovault.vault.azure.net/certificates/contosocert, we support unversioned certificate URL only (e.g., https://contosovault.vault.azure.net/certificates/contosocert)
        :param builtins.str expected_txt_record_name: Expected DNS TXT record name. Event Grid will check for a TXT record with this name in the DNS record set of the custom domain name to prove ownership over the domain.
               The values under this TXT record must contain the expected TXT record value.
        :param builtins.str expected_txt_record_value: Expected DNS TXT record value. Event Grid will check for a TXT record with this value in the DNS record set of the custom domain name to prove ownership over the domain.
        :param 'CustomDomainIdentityResponse' identity: Identity info for accessing the certificate for the custom domain. This identity info must match an identity that has been set on the namespace.
        :param builtins.str validation_state: Validation state for the custom domain. This is a read only property and is initially set to 'Pending' and will be updated to 'Approved' by Event Grid only after ownership of the domain name has been successfully validated.
        """
        pulumi.set(__self__, "fully_qualified_domain_name", fully_qualified_domain_name)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)
        if expected_txt_record_name is not None:
            pulumi.set(__self__, "expected_txt_record_name", expected_txt_record_name)
        if expected_txt_record_value is not None:
            pulumi.set(__self__, "expected_txt_record_value", expected_txt_record_value)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if validation_state is not None:
            pulumi.set(__self__, "validation_state", validation_state)

    @property
    @pulumi.getter(name="fullyQualifiedDomainName")
    def fully_qualified_domain_name(self) -> builtins.str:
        """
        Fully Qualified Domain Name (FQDN) for the custom domain.
        """
        return pulumi.get(self, "fully_qualified_domain_name")

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[builtins.str]:
        """
        The URL for the certificate that is used for publishing to the custom domain. We currently support certificates stored in Azure Key Vault only. While certificate URL can be either
        versioned URL of the following format https://{key-vault-name}.vault.azure.net/certificates/{certificate-name}/{version-id}, or unversioned URL of the following format (e.g.,
        https://contosovault.vault.azure.net/certificates/contosocert, we support unversioned certificate URL only (e.g., https://contosovault.vault.azure.net/certificates/contosocert)
        """
        return pulumi.get(self, "certificate_url")

    @property
    @pulumi.getter(name="expectedTxtRecordName")
    def expected_txt_record_name(self) -> Optional[builtins.str]:
        """
        Expected DNS TXT record name. Event Grid will check for a TXT record with this name in the DNS record set of the custom domain name to prove ownership over the domain.
        The values under this TXT record must contain the expected TXT record value.
        """
        return pulumi.get(self, "expected_txt_record_name")

    @property
    @pulumi.getter(name="expectedTxtRecordValue")
    def expected_txt_record_value(self) -> Optional[builtins.str]:
        """
        Expected DNS TXT record value. Event Grid will check for a TXT record with this value in the DNS record set of the custom domain name to prove ownership over the domain.
        """
        return pulumi.get(self, "expected_txt_record_value")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.CustomDomainIdentityResponse']:
        """
        Identity info for accessing the certificate for the custom domain. This identity info must match an identity that has been set on the namespace.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="validationState")
    def validation_state(self) -> Optional[builtins.str]:
        """
        Validation state for the custom domain. This is a read only property and is initially set to 'Pending' and will be updated to 'Approved' by Event Grid only after ownership of the domain name has been successfully validated.
        """
        return pulumi.get(self, "validation_state")


@pulumi.output_type
class CustomDomainIdentityResponse(dict):
    """
    The identity information for retrieving the certificate for the custom domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[builtins.str] = None,
                 user_assigned_identity: Optional[builtins.str] = None):
        """
        The identity information for retrieving the certificate for the custom domain.
        :param builtins.str type: The type of managed identity used. Can be either 'SystemAssigned' or 'UserAssigned'.
        :param builtins.str user_assigned_identity: The user identity associated with the resource.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The type of managed identity used. Can be either 'SystemAssigned' or 'UserAssigned'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[builtins.str]:
        """
        The user identity associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class DeadLetterWithResourceIdentityResponse(dict):
    """
    Information about the deadletter destination with resource identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deadLetterDestination":
            suggest = "dead_letter_destination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeadLetterWithResourceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeadLetterWithResourceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeadLetterWithResourceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dead_letter_destination: Optional['outputs.StorageBlobDeadLetterDestinationResponse'] = None,
                 identity: Optional['outputs.EventSubscriptionIdentityResponse'] = None):
        """
        Information about the deadletter destination with resource identity.
        :param 'StorageBlobDeadLetterDestinationResponse' dead_letter_destination: Information about the destination where events have to be delivered for the event subscription.
               Uses the managed identity setup on the parent resource (namely, topic or domain) to acquire the authentication tokens being used during dead-lettering.
        :param 'EventSubscriptionIdentityResponse' identity: The identity to use when dead-lettering events.
        """
        if dead_letter_destination is not None:
            pulumi.set(__self__, "dead_letter_destination", dead_letter_destination)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @property
    @pulumi.getter(name="deadLetterDestination")
    def dead_letter_destination(self) -> Optional['outputs.StorageBlobDeadLetterDestinationResponse']:
        """
        Information about the destination where events have to be delivered for the event subscription.
        Uses the managed identity setup on the parent resource (namely, topic or domain) to acquire the authentication tokens being used during dead-lettering.
        """
        return pulumi.get(self, "dead_letter_destination")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.EventSubscriptionIdentityResponse']:
        """
        The identity to use when dead-lettering events.
        """
        return pulumi.get(self, "identity")


@pulumi.output_type
class DeliveryConfigurationResponse(dict):
    """
    Properties of the delivery configuration information of the event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryMode":
            suggest = "delivery_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeliveryConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeliveryConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeliveryConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_mode: Optional[builtins.str] = None,
                 push: Optional['outputs.PushInfoResponse'] = None,
                 queue: Optional['outputs.QueueInfoResponse'] = None):
        """
        Properties of the delivery configuration information of the event subscription.
        :param builtins.str delivery_mode: Delivery mode of the event subscription.
        :param 'PushInfoResponse' push: This property should be populated when deliveryMode is push and represents information about the push subscription.
        :param 'QueueInfoResponse' queue: This property should be populated when deliveryMode is queue and represents information about the queue subscription.
        """
        if delivery_mode is not None:
            pulumi.set(__self__, "delivery_mode", delivery_mode)
        if push is not None:
            pulumi.set(__self__, "push", push)
        if queue is not None:
            pulumi.set(__self__, "queue", queue)

    @property
    @pulumi.getter(name="deliveryMode")
    def delivery_mode(self) -> Optional[builtins.str]:
        """
        Delivery mode of the event subscription.
        """
        return pulumi.get(self, "delivery_mode")

    @property
    @pulumi.getter
    def push(self) -> Optional['outputs.PushInfoResponse']:
        """
        This property should be populated when deliveryMode is push and represents information about the push subscription.
        """
        return pulumi.get(self, "push")

    @property
    @pulumi.getter
    def queue(self) -> Optional['outputs.QueueInfoResponse']:
        """
        This property should be populated when deliveryMode is queue and represents information about the queue subscription.
        """
        return pulumi.get(self, "queue")


@pulumi.output_type
class DeliveryWithResourceIdentityResponse(dict):
    """
    Information about the delivery for an event subscription with resource identity.
    """
    def __init__(__self__, *,
                 destination: Optional[Any] = None,
                 identity: Optional['outputs.EventSubscriptionIdentityResponse'] = None):
        """
        Information about the delivery for an event subscription with resource identity.
        :param Union['AzureFunctionEventSubscriptionDestinationResponse', 'EventHubEventSubscriptionDestinationResponse', 'HybridConnectionEventSubscriptionDestinationResponse', 'MonitorAlertEventSubscriptionDestinationResponse', 'NamespaceTopicEventSubscriptionDestinationResponse', 'ServiceBusQueueEventSubscriptionDestinationResponse', 'ServiceBusTopicEventSubscriptionDestinationResponse', 'StorageQueueEventSubscriptionDestinationResponse', 'WebHookEventSubscriptionDestinationResponse'] destination: Information about the destination where events have to be delivered for the event subscription.
               Uses the managed identity setup on the parent resource (namely, topic or domain) to acquire the authentication tokens being used during delivery.
        :param 'EventSubscriptionIdentityResponse' identity: The identity to use when delivering events.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @property
    @pulumi.getter
    def destination(self) -> Optional[Any]:
        """
        Information about the destination where events have to be delivered for the event subscription.
        Uses the managed identity setup on the parent resource (namely, topic or domain) to acquire the authentication tokens being used during delivery.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.EventSubscriptionIdentityResponse']:
        """
        The identity to use when delivering events.
        """
        return pulumi.get(self, "identity")


@pulumi.output_type
class DynamicDeliveryAttributeMappingResponse(dict):
    """
    Dynamic delivery attribute mapping details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceField":
            suggest = "source_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamicDeliveryAttributeMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamicDeliveryAttributeMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamicDeliveryAttributeMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 name: Optional[builtins.str] = None,
                 source_field: Optional[builtins.str] = None):
        """
        Dynamic delivery attribute mapping details.
        :param builtins.str type: Type of the delivery attribute or header name.
               Expected value is 'Dynamic'.
        :param builtins.str name: Name of the delivery attribute or header.
        :param builtins.str source_field: JSON path in the event which contains attribute value.
        """
        pulumi.set(__self__, "type", 'Dynamic')
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_field is not None:
            pulumi.set(__self__, "source_field", source_field)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the delivery attribute or header name.
        Expected value is 'Dynamic'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the delivery attribute or header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[builtins.str]:
        """
        JSON path in the event which contains attribute value.
        """
        return pulumi.get(self, "source_field")


@pulumi.output_type
class DynamicRoutingEnrichmentResponse(dict):
    def __init__(__self__, *,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str key: Dynamic routing enrichment key.
        :param builtins.str value: Dynamic routing enrichment value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        Dynamic routing enrichment key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Dynamic routing enrichment value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventHubEventSubscriptionDestinationResponse(dict):
    """
    Information about the event hub destination for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "deliveryAttributeMappings":
            suggest = "delivery_attribute_mappings"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventHubEventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventHubEventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventHubEventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 delivery_attribute_mappings: Optional[Sequence[Any]] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Information about the event hub destination for an event subscription.
        :param builtins.str endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'EventHub'.
        :param Sequence[Union['DynamicDeliveryAttributeMappingResponse', 'StaticDeliveryAttributeMappingResponse']] delivery_attribute_mappings: Delivery attribute details.
        :param builtins.str resource_id: The Azure Resource Id that represents the endpoint of an Event Hub destination of an event subscription.
        """
        pulumi.set(__self__, "endpoint_type", 'EventHub')
        if delivery_attribute_mappings is not None:
            pulumi.set(__self__, "delivery_attribute_mappings", delivery_attribute_mappings)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'EventHub'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[Sequence[Any]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The Azure Resource Id that represents the endpoint of an Event Hub destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class EventSubscriptionFilterResponse(dict):
    """
    Filter for the Event Subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedFilters":
            suggest = "advanced_filters"
        elif key == "enableAdvancedFilteringOnArrays":
            suggest = "enable_advanced_filtering_on_arrays"
        elif key == "includedEventTypes":
            suggest = "included_event_types"
        elif key == "isSubjectCaseSensitive":
            suggest = "is_subject_case_sensitive"
        elif key == "subjectBeginsWith":
            suggest = "subject_begins_with"
        elif key == "subjectEndsWith":
            suggest = "subject_ends_with"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSubscriptionFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSubscriptionFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSubscriptionFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_filters: Optional[Sequence[Any]] = None,
                 enable_advanced_filtering_on_arrays: Optional[builtins.bool] = None,
                 included_event_types: Optional[Sequence[builtins.str]] = None,
                 is_subject_case_sensitive: Optional[builtins.bool] = None,
                 subject_begins_with: Optional[builtins.str] = None,
                 subject_ends_with: Optional[builtins.str] = None):
        """
        Filter for the Event Subscription.
        :param Sequence[Union['BoolEqualsAdvancedFilterResponse', 'IsNotNullAdvancedFilterResponse', 'IsNullOrUndefinedAdvancedFilterResponse', 'NumberGreaterThanAdvancedFilterResponse', 'NumberGreaterThanOrEqualsAdvancedFilterResponse', 'NumberInAdvancedFilterResponse', 'NumberInRangeAdvancedFilterResponse', 'NumberLessThanAdvancedFilterResponse', 'NumberLessThanOrEqualsAdvancedFilterResponse', 'NumberNotInAdvancedFilterResponse', 'NumberNotInRangeAdvancedFilterResponse', 'StringBeginsWithAdvancedFilterResponse', 'StringContainsAdvancedFilterResponse', 'StringEndsWithAdvancedFilterResponse', 'StringInAdvancedFilterResponse', 'StringNotBeginsWithAdvancedFilterResponse', 'StringNotContainsAdvancedFilterResponse', 'StringNotEndsWithAdvancedFilterResponse', 'StringNotInAdvancedFilterResponse']] advanced_filters: An array of advanced filters that are used for filtering event subscriptions.
        :param builtins.bool enable_advanced_filtering_on_arrays: Allows advanced filters to be evaluated against an array of values instead of expecting a singular value.
        :param Sequence[builtins.str] included_event_types: A list of applicable event types that need to be part of the event subscription. If it is desired to subscribe to all default event types, set the IncludedEventTypes to null.
        :param builtins.bool is_subject_case_sensitive: Specifies if the SubjectBeginsWith and SubjectEndsWith properties of the filter
               should be compared in a case sensitive manner.
        :param builtins.str subject_begins_with: An optional string to filter events for an event subscription based on a resource path prefix.
               The format of this depends on the publisher of the events.
               Wildcard characters are not supported in this path.
        :param builtins.str subject_ends_with: An optional string to filter events for an event subscription based on a resource path suffix.
               Wildcard characters are not supported in this path.
        """
        if advanced_filters is not None:
            pulumi.set(__self__, "advanced_filters", advanced_filters)
        if enable_advanced_filtering_on_arrays is not None:
            pulumi.set(__self__, "enable_advanced_filtering_on_arrays", enable_advanced_filtering_on_arrays)
        if included_event_types is not None:
            pulumi.set(__self__, "included_event_types", included_event_types)
        if is_subject_case_sensitive is None:
            is_subject_case_sensitive = False
        if is_subject_case_sensitive is not None:
            pulumi.set(__self__, "is_subject_case_sensitive", is_subject_case_sensitive)
        if subject_begins_with is not None:
            pulumi.set(__self__, "subject_begins_with", subject_begins_with)
        if subject_ends_with is not None:
            pulumi.set(__self__, "subject_ends_with", subject_ends_with)

    @property
    @pulumi.getter(name="advancedFilters")
    def advanced_filters(self) -> Optional[Sequence[Any]]:
        """
        An array of advanced filters that are used for filtering event subscriptions.
        """
        return pulumi.get(self, "advanced_filters")

    @property
    @pulumi.getter(name="enableAdvancedFilteringOnArrays")
    def enable_advanced_filtering_on_arrays(self) -> Optional[builtins.bool]:
        """
        Allows advanced filters to be evaluated against an array of values instead of expecting a singular value.
        """
        return pulumi.get(self, "enable_advanced_filtering_on_arrays")

    @property
    @pulumi.getter(name="includedEventTypes")
    def included_event_types(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of applicable event types that need to be part of the event subscription. If it is desired to subscribe to all default event types, set the IncludedEventTypes to null.
        """
        return pulumi.get(self, "included_event_types")

    @property
    @pulumi.getter(name="isSubjectCaseSensitive")
    def is_subject_case_sensitive(self) -> Optional[builtins.bool]:
        """
        Specifies if the SubjectBeginsWith and SubjectEndsWith properties of the filter
        should be compared in a case sensitive manner.
        """
        return pulumi.get(self, "is_subject_case_sensitive")

    @property
    @pulumi.getter(name="subjectBeginsWith")
    def subject_begins_with(self) -> Optional[builtins.str]:
        """
        An optional string to filter events for an event subscription based on a resource path prefix.
        The format of this depends on the publisher of the events.
        Wildcard characters are not supported in this path.
        """
        return pulumi.get(self, "subject_begins_with")

    @property
    @pulumi.getter(name="subjectEndsWith")
    def subject_ends_with(self) -> Optional[builtins.str]:
        """
        An optional string to filter events for an event subscription based on a resource path suffix.
        Wildcard characters are not supported in this path.
        """
        return pulumi.get(self, "subject_ends_with")


@pulumi.output_type
class EventSubscriptionIdentityResponse(dict):
    """
    The identity information with the event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSubscriptionIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSubscriptionIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSubscriptionIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[builtins.str] = None,
                 user_assigned_identity: Optional[builtins.str] = None):
        """
        The identity information with the event subscription.
        :param builtins.str type: The type of managed identity used. Can be either 'SystemAssigned' or 'UserAssigned'.
        :param builtins.str user_assigned_identity: The user identity associated with the resource.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The type of managed identity used. Can be either 'SystemAssigned' or 'UserAssigned'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[builtins.str]:
        """
        The user identity associated with the resource.
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class EventTypeInfoResponse(dict):
    """
    The event type information for Channels.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inlineEventTypes":
            suggest = "inline_event_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTypeInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTypeInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTypeInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inline_event_types: Optional[Mapping[str, 'outputs.InlineEventPropertiesResponse']] = None,
                 kind: Optional[builtins.str] = None):
        """
        The event type information for Channels.
        :param Mapping[str, 'InlineEventPropertiesResponse'] inline_event_types: A collection of inline event types for the resource. The inline event type keys are of type string which represents the name of the event.
               An example of a valid inline event name is "Contoso.OrderCreated".
               The inline event type values are of type InlineEventProperties and will contain additional information for every inline event type.
        :param builtins.str kind: The kind of event type used.
        """
        if inline_event_types is not None:
            pulumi.set(__self__, "inline_event_types", inline_event_types)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="inlineEventTypes")
    def inline_event_types(self) -> Optional[Mapping[str, 'outputs.InlineEventPropertiesResponse']]:
        """
        A collection of inline event types for the resource. The inline event type keys are of type string which represents the name of the event.
        An example of a valid inline event name is "Contoso.OrderCreated".
        The inline event type values are of type InlineEventProperties and will contain additional information for every inline event type.
        """
        return pulumi.get(self, "inline_event_types")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        The kind of event type used.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class FiltersConfigurationResponse(dict):
    """
    Filters configuration for the Event Subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedEventTypes":
            suggest = "included_event_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FiltersConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FiltersConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FiltersConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Optional[Sequence[Any]] = None,
                 included_event_types: Optional[Sequence[builtins.str]] = None):
        """
        Filters configuration for the Event Subscription.
        :param Sequence[Union['BoolEqualsFilterResponse', 'IsNotNullFilterResponse', 'IsNullOrUndefinedFilterResponse', 'NumberGreaterThanFilterResponse', 'NumberGreaterThanOrEqualsFilterResponse', 'NumberInFilterResponse', 'NumberInRangeFilterResponse', 'NumberLessThanFilterResponse', 'NumberLessThanOrEqualsFilterResponse', 'NumberNotInFilterResponse', 'NumberNotInRangeFilterResponse', 'StringBeginsWithFilterResponse', 'StringContainsFilterResponse', 'StringEndsWithFilterResponse', 'StringInFilterResponse', 'StringNotBeginsWithFilterResponse', 'StringNotContainsFilterResponse', 'StringNotEndsWithFilterResponse', 'StringNotInFilterResponse']] filters: An array of filters that are used for filtering event subscriptions.
        :param Sequence[builtins.str] included_event_types: A list of applicable event types that need to be part of the event subscription. If it is desired to subscribe to all default event types, set the IncludedEventTypes to null.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if included_event_types is not None:
            pulumi.set(__self__, "included_event_types", included_event_types)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence[Any]]:
        """
        An array of filters that are used for filtering event subscriptions.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="includedEventTypes")
    def included_event_types(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of applicable event types that need to be part of the event subscription. If it is desired to subscribe to all default event types, set the IncludedEventTypes to null.
        """
        return pulumi.get(self, "included_event_types")


@pulumi.output_type
class HybridConnectionEventSubscriptionDestinationResponse(dict):
    """
    Information about the HybridConnection destination for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "deliveryAttributeMappings":
            suggest = "delivery_attribute_mappings"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridConnectionEventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridConnectionEventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridConnectionEventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 delivery_attribute_mappings: Optional[Sequence[Any]] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Information about the HybridConnection destination for an event subscription.
        :param builtins.str endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'HybridConnection'.
        :param Sequence[Union['DynamicDeliveryAttributeMappingResponse', 'StaticDeliveryAttributeMappingResponse']] delivery_attribute_mappings: Delivery attribute details.
        :param builtins.str resource_id: The Azure Resource ID of an hybrid connection that is the destination of an event subscription.
        """
        pulumi.set(__self__, "endpoint_type", 'HybridConnection')
        if delivery_attribute_mappings is not None:
            pulumi.set(__self__, "delivery_attribute_mappings", delivery_attribute_mappings)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'HybridConnection'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[Sequence[Any]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The Azure Resource ID of an hybrid connection that is the destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class IdentityInfoResponse(dict):
    """
    The identity information for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserIdentityPropertiesResponse']] = None):
        """
        The identity information for the resource.
        :param builtins.str principal_id: The principal ID of resource identity.
        :param builtins.str tenant_id: The tenant ID of resource.
        :param builtins.str type: The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identity.
        :param Mapping[str, 'UserIdentityPropertiesResponse'] user_assigned_identities: The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
               '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
               This property is currently not used and reserved for future usage.
        """
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[builtins.str]:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove any identity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserIdentityPropertiesResponse']]:
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form:
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        This property is currently not used and reserved for future usage.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class InboundIpRuleResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipMask":
            suggest = "ip_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InboundIpRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InboundIpRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InboundIpRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 ip_mask: Optional[builtins.str] = None):
        """
        :param builtins.str action: Action to perform based on the match or no match of the IpMask.
        :param builtins.str ip_mask: IP Address in CIDR notation e.g., 10.0.0.0/8.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if ip_mask is not None:
            pulumi.set(__self__, "ip_mask", ip_mask)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Action to perform based on the match or no match of the IpMask.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> Optional[builtins.str]:
        """
        IP Address in CIDR notation e.g., 10.0.0.0/8.
        """
        return pulumi.get(self, "ip_mask")


@pulumi.output_type
class InlineEventPropertiesResponse(dict):
    """
    Additional information about every inline event.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSchemaUrl":
            suggest = "data_schema_url"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "documentationUrl":
            suggest = "documentation_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InlineEventPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InlineEventPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InlineEventPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_schema_url: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 documentation_url: Optional[builtins.str] = None):
        """
        Additional information about every inline event.
        :param builtins.str data_schema_url: The dataSchemaUrl for the inline event.
        :param builtins.str description: The description for the inline event.
        :param builtins.str display_name: The displayName for the inline event.
        :param builtins.str documentation_url: The documentationUrl for the inline event.
        """
        if data_schema_url is not None:
            pulumi.set(__self__, "data_schema_url", data_schema_url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if documentation_url is not None:
            pulumi.set(__self__, "documentation_url", documentation_url)

    @property
    @pulumi.getter(name="dataSchemaUrl")
    def data_schema_url(self) -> Optional[builtins.str]:
        """
        The dataSchemaUrl for the inline event.
        """
        return pulumi.get(self, "data_schema_url")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description for the inline event.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        The displayName for the inline event.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="documentationUrl")
    def documentation_url(self) -> Optional[builtins.str]:
        """
        The documentationUrl for the inline event.
        """
        return pulumi.get(self, "documentation_url")


@pulumi.output_type
class IsNotNullAdvancedFilterResponse(dict):
    """
    IsNotNull Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IsNotNullAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IsNotNullAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IsNotNullAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None):
        """
        IsNotNull Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'IsNotNull'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        """
        pulumi.set(__self__, "operator_type", 'IsNotNull')
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'IsNotNull'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class IsNotNullFilterResponse(dict):
    """
    IsNotNull Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IsNotNullFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IsNotNullFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IsNotNullFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None):
        """
        IsNotNull Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'IsNotNull'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        """
        pulumi.set(__self__, "operator_type", 'IsNotNull')
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'IsNotNull'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class IsNullOrUndefinedAdvancedFilterResponse(dict):
    """
    IsNullOrUndefined Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IsNullOrUndefinedAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IsNullOrUndefinedAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IsNullOrUndefinedAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None):
        """
        IsNullOrUndefined Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'IsNullOrUndefined'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        """
        pulumi.set(__self__, "operator_type", 'IsNullOrUndefined')
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'IsNullOrUndefined'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class IsNullOrUndefinedFilterResponse(dict):
    """
    IsNullOrUndefined Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IsNullOrUndefinedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IsNullOrUndefinedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IsNullOrUndefinedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None):
        """
        IsNullOrUndefined Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'IsNullOrUndefined'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        """
        pulumi.set(__self__, "operator_type", 'IsNullOrUndefined')
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'IsNullOrUndefined'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class JsonFieldResponse(dict):
    """
    This is used to express the source of an input schema mapping for a single target field in the Event Grid Event schema. This is currently used in the mappings for the 'id', 'topic' and 'eventtime' properties. This represents a field in the input event schema.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceField":
            suggest = "source_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JsonFieldResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JsonFieldResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JsonFieldResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_field: Optional[builtins.str] = None):
        """
        This is used to express the source of an input schema mapping for a single target field in the Event Grid Event schema. This is currently used in the mappings for the 'id', 'topic' and 'eventtime' properties. This represents a field in the input event schema.
        :param builtins.str source_field: Name of a field in the input event schema that's to be used as the source of a mapping.
        """
        if source_field is not None:
            pulumi.set(__self__, "source_field", source_field)

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[builtins.str]:
        """
        Name of a field in the input event schema that's to be used as the source of a mapping.
        """
        return pulumi.get(self, "source_field")


@pulumi.output_type
class JsonFieldWithDefaultResponse(dict):
    """
    This is used to express the source of an input schema mapping for a single target field
    in the Event Grid Event schema. This is currently used in the mappings for the 'subject',
    'eventtype' and 'dataversion' properties. This represents a field in the input event schema
    along with a default value to be used, and at least one of these two properties should be provided.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "sourceField":
            suggest = "source_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JsonFieldWithDefaultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JsonFieldWithDefaultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JsonFieldWithDefaultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: Optional[builtins.str] = None,
                 source_field: Optional[builtins.str] = None):
        """
        This is used to express the source of an input schema mapping for a single target field
        in the Event Grid Event schema. This is currently used in the mappings for the 'subject',
        'eventtype' and 'dataversion' properties. This represents a field in the input event schema
        along with a default value to be used, and at least one of these two properties should be provided.
        :param builtins.str default_value: The default value to be used for mapping when a SourceField is not provided or if there's no property with the specified name in the published JSON event payload.
        :param builtins.str source_field: Name of a field in the input event schema that's to be used as the source of a mapping.
        """
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if source_field is not None:
            pulumi.set(__self__, "source_field", source_field)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[builtins.str]:
        """
        The default value to be used for mapping when a SourceField is not provided or if there's no property with the specified name in the published JSON event payload.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="sourceField")
    def source_field(self) -> Optional[builtins.str]:
        """
        Name of a field in the input event schema that's to be used as the source of a mapping.
        """
        return pulumi.get(self, "source_field")


@pulumi.output_type
class JsonInputSchemaMappingResponse(dict):
    """
    This enables publishing to Event Grid using a custom input schema. This can be used to map properties from a custom input JSON schema to the Event Grid event schema.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputSchemaMappingType":
            suggest = "input_schema_mapping_type"
        elif key == "dataVersion":
            suggest = "data_version"
        elif key == "eventTime":
            suggest = "event_time"
        elif key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JsonInputSchemaMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JsonInputSchemaMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JsonInputSchemaMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_schema_mapping_type: builtins.str,
                 data_version: Optional['outputs.JsonFieldWithDefaultResponse'] = None,
                 event_time: Optional['outputs.JsonFieldResponse'] = None,
                 event_type: Optional['outputs.JsonFieldWithDefaultResponse'] = None,
                 id: Optional['outputs.JsonFieldResponse'] = None,
                 subject: Optional['outputs.JsonFieldWithDefaultResponse'] = None,
                 topic: Optional['outputs.JsonFieldResponse'] = None):
        """
        This enables publishing to Event Grid using a custom input schema. This can be used to map properties from a custom input JSON schema to the Event Grid event schema.
        :param builtins.str input_schema_mapping_type: Type of the custom mapping
               Expected value is 'Json'.
        :param 'JsonFieldWithDefaultResponse' data_version: The mapping information for the DataVersion property of the Event Grid Event.
        :param 'JsonFieldResponse' event_time: The mapping information for the EventTime property of the Event Grid Event.
        :param 'JsonFieldWithDefaultResponse' event_type: The mapping information for the EventType property of the Event Grid Event.
        :param 'JsonFieldResponse' id: The mapping information for the Id property of the Event Grid Event.
        :param 'JsonFieldWithDefaultResponse' subject: The mapping information for the Subject property of the Event Grid Event.
        :param 'JsonFieldResponse' topic: The mapping information for the Topic property of the Event Grid Event.
        """
        pulumi.set(__self__, "input_schema_mapping_type", 'Json')
        if data_version is not None:
            pulumi.set(__self__, "data_version", data_version)
        if event_time is not None:
            pulumi.set(__self__, "event_time", event_time)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="inputSchemaMappingType")
    def input_schema_mapping_type(self) -> builtins.str:
        """
        Type of the custom mapping
        Expected value is 'Json'.
        """
        return pulumi.get(self, "input_schema_mapping_type")

    @property
    @pulumi.getter(name="dataVersion")
    def data_version(self) -> Optional['outputs.JsonFieldWithDefaultResponse']:
        """
        The mapping information for the DataVersion property of the Event Grid Event.
        """
        return pulumi.get(self, "data_version")

    @property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> Optional['outputs.JsonFieldResponse']:
        """
        The mapping information for the EventTime property of the Event Grid Event.
        """
        return pulumi.get(self, "event_time")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional['outputs.JsonFieldWithDefaultResponse']:
        """
        The mapping information for the EventType property of the Event Grid Event.
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def id(self) -> Optional['outputs.JsonFieldResponse']:
        """
        The mapping information for the Id property of the Event Grid Event.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def subject(self) -> Optional['outputs.JsonFieldWithDefaultResponse']:
        """
        The mapping information for the Subject property of the Event Grid Event.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def topic(self) -> Optional['outputs.JsonFieldResponse']:
        """
        The mapping information for the Topic property of the Event Grid Event.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class MonitorAlertEventSubscriptionDestinationResponse(dict):
    """
    Information about the Monitor Alert destination for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "actionGroups":
            suggest = "action_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorAlertEventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorAlertEventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorAlertEventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 action_groups: Optional[Sequence[builtins.str]] = None,
                 description: Optional[builtins.str] = None,
                 severity: Optional[builtins.str] = None):
        """
        Information about the Monitor Alert destination for an event subscription.
        :param builtins.str endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'MonitorAlert'.
        :param Sequence[builtins.str] action_groups: The list of ARM Ids of Action Groups that will be triggered on every Alert fired through this event subscription.
               Each resource ARM Id should follow this pattern: /subscriptions/{AzureSubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Insights/actionGroups/{ActionGroupName}.
        :param builtins.str description: The description that will be attached to every Alert fired through this event subscription.
        :param builtins.str severity: The severity that will be attached to every Alert fired through this event subscription.
               This field must be provided.
        """
        pulumi.set(__self__, "endpoint_type", 'MonitorAlert')
        if action_groups is not None:
            pulumi.set(__self__, "action_groups", action_groups)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'MonitorAlert'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="actionGroups")
    def action_groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of ARM Ids of Action Groups that will be triggered on every Alert fired through this event subscription.
        Each resource ARM Id should follow this pattern: /subscriptions/{AzureSubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Insights/actionGroups/{ActionGroupName}.
        """
        return pulumi.get(self, "action_groups")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The description that will be attached to every Alert fired through this event subscription.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def severity(self) -> Optional[builtins.str]:
        """
        The severity that will be attached to every Alert fired through this event subscription.
        This field must be provided.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class NamespaceSkuResponse(dict):
    """
    Represents available Sku pricing tiers.
    """
    def __init__(__self__, *,
                 capacity: Optional[builtins.int] = None,
                 name: Optional[builtins.str] = None):
        """
        Represents available Sku pricing tiers.
        :param builtins.int capacity: Specifies the number of Throughput Units that defines the capacity for the namespace. The property default value is
               1 which signifies 1 Throughput Unit = 1MB/s ingress and 2MB/s egress per namespace. Min capacity is 1 and
               max allowed capacity is 20.
        :param builtins.str name: The name of the SKU.
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[builtins.int]:
        """
        Specifies the number of Throughput Units that defines the capacity for the namespace. The property default value is
        1 which signifies 1 Throughput Unit = 1MB/s ingress and 2MB/s egress per namespace. Min capacity is 1 and
        max allowed capacity is 20.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the SKU.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NamespaceTopicEventSubscriptionDestinationResponse(dict):
    """
    Information about the Namespace Topic destination for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceTopicEventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceTopicEventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceTopicEventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 resource_id: Optional[builtins.str] = None):
        """
        Information about the Namespace Topic destination for an event subscription.
        :param builtins.str endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'NamespaceTopic'.
        :param builtins.str resource_id: The Azure resource Id that represents the endpoint of the Event Grid Namespace Topic destination of an event subscription.
               This field is required and the Namespace Topic resource listed must already exist.
               The resource ARM Id should follow this pattern: /subscriptions/{AzureSubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.EventGrid/namespaces/{NamespaceName}/topics/{TopicName}.
        """
        pulumi.set(__self__, "endpoint_type", 'NamespaceTopic')
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'NamespaceTopic'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The Azure resource Id that represents the endpoint of the Event Grid Namespace Topic destination of an event subscription.
        This field is required and the Namespace Topic resource listed must already exist.
        The resource ARM Id should follow this pattern: /subscriptions/{AzureSubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.EventGrid/namespaces/{NamespaceName}/topics/{TopicName}.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class NumberGreaterThanAdvancedFilterResponse(dict):
    """
    NumberGreaterThan Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberGreaterThanAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberGreaterThanAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberGreaterThanAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.float] = None):
        """
        NumberGreaterThan Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberGreaterThan'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.float value: The filter value.
        """
        pulumi.set(__self__, "operator_type", 'NumberGreaterThan')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberGreaterThan'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.float]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NumberGreaterThanFilterResponse(dict):
    """
    NumberGreaterThan Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberGreaterThanFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberGreaterThanFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberGreaterThanFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.float] = None):
        """
        NumberGreaterThan Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberGreaterThan'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.float value: The filter value.
        """
        pulumi.set(__self__, "operator_type", 'NumberGreaterThan')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberGreaterThan'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.float]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NumberGreaterThanOrEqualsAdvancedFilterResponse(dict):
    """
    NumberGreaterThanOrEquals Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberGreaterThanOrEqualsAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberGreaterThanOrEqualsAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberGreaterThanOrEqualsAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.float] = None):
        """
        NumberGreaterThanOrEquals Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberGreaterThanOrEquals'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.float value: The filter value.
        """
        pulumi.set(__self__, "operator_type", 'NumberGreaterThanOrEquals')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberGreaterThanOrEquals'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.float]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NumberGreaterThanOrEqualsFilterResponse(dict):
    """
    NumberGreaterThanOrEquals Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberGreaterThanOrEqualsFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberGreaterThanOrEqualsFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberGreaterThanOrEqualsFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.float] = None):
        """
        NumberGreaterThanOrEquals Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberGreaterThanOrEquals'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.float value: The filter value.
        """
        pulumi.set(__self__, "operator_type", 'NumberGreaterThanOrEquals')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberGreaterThanOrEquals'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.float]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NumberInAdvancedFilterResponse(dict):
    """
    NumberIn Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberInAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberInAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberInAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.float]] = None):
        """
        NumberIn Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberIn'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.float] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'NumberIn')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberIn'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.float]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NumberInFilterResponse(dict):
    """
    NumberIn Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberInFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberInFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberInFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.float]] = None):
        """
        NumberIn Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberIn'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.float] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'NumberIn')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberIn'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.float]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NumberInRangeAdvancedFilterResponse(dict):
    """
    NumberInRange Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberInRangeAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberInRangeAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberInRangeAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[Sequence[builtins.float]]] = None):
        """
        NumberInRange Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberInRange'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[Sequence[builtins.float]] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'NumberInRange')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberInRange'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[Sequence[builtins.float]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NumberInRangeFilterResponse(dict):
    """
    NumberInRange Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberInRangeFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberInRangeFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberInRangeFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[Sequence[builtins.float]]] = None):
        """
        NumberInRange Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberInRange'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[Sequence[builtins.float]] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'NumberInRange')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberInRange'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[Sequence[builtins.float]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NumberLessThanAdvancedFilterResponse(dict):
    """
    NumberLessThan Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberLessThanAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberLessThanAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberLessThanAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.float] = None):
        """
        NumberLessThan Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberLessThan'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.float value: The filter value.
        """
        pulumi.set(__self__, "operator_type", 'NumberLessThan')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberLessThan'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.float]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NumberLessThanFilterResponse(dict):
    """
    NumberLessThan Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberLessThanFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberLessThanFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberLessThanFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.float] = None):
        """
        NumberLessThan Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberLessThan'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.float value: The filter value.
        """
        pulumi.set(__self__, "operator_type", 'NumberLessThan')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberLessThan'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.float]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NumberLessThanOrEqualsAdvancedFilterResponse(dict):
    """
    NumberLessThanOrEquals Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberLessThanOrEqualsAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberLessThanOrEqualsAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberLessThanOrEqualsAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.float] = None):
        """
        NumberLessThanOrEquals Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberLessThanOrEquals'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.float value: The filter value.
        """
        pulumi.set(__self__, "operator_type", 'NumberLessThanOrEquals')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberLessThanOrEquals'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.float]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NumberLessThanOrEqualsFilterResponse(dict):
    """
    NumberLessThanOrEquals Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberLessThanOrEqualsFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberLessThanOrEqualsFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberLessThanOrEqualsFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.float] = None):
        """
        NumberLessThanOrEquals Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberLessThanOrEquals'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param builtins.float value: The filter value.
        """
        pulumi.set(__self__, "operator_type", 'NumberLessThanOrEquals')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberLessThanOrEquals'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.float]:
        """
        The filter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NumberNotInAdvancedFilterResponse(dict):
    """
    NumberNotIn Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberNotInAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberNotInAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberNotInAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.float]] = None):
        """
        NumberNotIn Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberNotIn'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.float] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'NumberNotIn')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberNotIn'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.float]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NumberNotInFilterResponse(dict):
    """
    NumberNotIn Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberNotInFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberNotInFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberNotInFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.float]] = None):
        """
        NumberNotIn Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberNotIn'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.float] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'NumberNotIn')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberNotIn'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.float]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NumberNotInRangeAdvancedFilterResponse(dict):
    """
    NumberNotInRange Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberNotInRangeAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberNotInRangeAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberNotInRangeAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[Sequence[builtins.float]]] = None):
        """
        NumberNotInRange Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberNotInRange'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[Sequence[builtins.float]] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'NumberNotInRange')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberNotInRange'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[Sequence[builtins.float]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NumberNotInRangeFilterResponse(dict):
    """
    NumberNotInRange Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NumberNotInRangeFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NumberNotInRangeFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NumberNotInRangeFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[Sequence[builtins.float]]] = None):
        """
        NumberNotInRange Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'NumberNotInRange'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[Sequence[builtins.float]] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'NumberNotInRange')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'NumberNotInRange'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[Sequence[builtins.float]]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class PartnerAuthorizationResponse(dict):
    """
    The partner authorization details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedPartnersList":
            suggest = "authorized_partners_list"
        elif key == "defaultMaximumExpirationTimeInDays":
            suggest = "default_maximum_expiration_time_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnerAuthorizationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnerAuthorizationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnerAuthorizationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_partners_list: Optional[Sequence['outputs.PartnerResponse']] = None,
                 default_maximum_expiration_time_in_days: Optional[builtins.int] = None):
        """
        The partner authorization details.
        :param Sequence['PartnerResponse'] authorized_partners_list: The list of authorized partners.
        :param builtins.int default_maximum_expiration_time_in_days: Time used to validate the authorization expiration time for each authorized partner. If DefaultMaximumExpirationTimeInDays is
               not specified, the default is 7 days. Otherwise, allowed values are between 1 and 365 days.
        """
        if authorized_partners_list is not None:
            pulumi.set(__self__, "authorized_partners_list", authorized_partners_list)
        if default_maximum_expiration_time_in_days is not None:
            pulumi.set(__self__, "default_maximum_expiration_time_in_days", default_maximum_expiration_time_in_days)

    @property
    @pulumi.getter(name="authorizedPartnersList")
    def authorized_partners_list(self) -> Optional[Sequence['outputs.PartnerResponse']]:
        """
        The list of authorized partners.
        """
        return pulumi.get(self, "authorized_partners_list")

    @property
    @pulumi.getter(name="defaultMaximumExpirationTimeInDays")
    def default_maximum_expiration_time_in_days(self) -> Optional[builtins.int]:
        """
        Time used to validate the authorization expiration time for each authorized partner. If DefaultMaximumExpirationTimeInDays is
        not specified, the default is 7 days. Otherwise, allowed values are between 1 and 365 days.
        """
        return pulumi.get(self, "default_maximum_expiration_time_in_days")


@pulumi.output_type
class PartnerResponse(dict):
    """
    Information about the partner.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationExpirationTimeInUtc":
            suggest = "authorization_expiration_time_in_utc"
        elif key == "partnerName":
            suggest = "partner_name"
        elif key == "partnerRegistrationImmutableId":
            suggest = "partner_registration_immutable_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_expiration_time_in_utc: Optional[builtins.str] = None,
                 partner_name: Optional[builtins.str] = None,
                 partner_registration_immutable_id: Optional[builtins.str] = None):
        """
        Information about the partner.
        :param builtins.str authorization_expiration_time_in_utc: Expiration time of the partner authorization. If this timer expires, any request from this partner to create, update or delete resources in subscriber's
               context will fail. If specified, the allowed values are between 1 to the value of defaultMaximumExpirationTimeInDays specified in PartnerConfiguration.
               If not specified, the default value will be the value of defaultMaximumExpirationTimeInDays specified in PartnerConfiguration or 7 if this value is not specified.
        :param builtins.str partner_name: The partner name.
        :param builtins.str partner_registration_immutable_id: The immutableId of the corresponding partner registration.
        """
        if authorization_expiration_time_in_utc is not None:
            pulumi.set(__self__, "authorization_expiration_time_in_utc", authorization_expiration_time_in_utc)
        if partner_name is not None:
            pulumi.set(__self__, "partner_name", partner_name)
        if partner_registration_immutable_id is not None:
            pulumi.set(__self__, "partner_registration_immutable_id", partner_registration_immutable_id)

    @property
    @pulumi.getter(name="authorizationExpirationTimeInUtc")
    def authorization_expiration_time_in_utc(self) -> Optional[builtins.str]:
        """
        Expiration time of the partner authorization. If this timer expires, any request from this partner to create, update or delete resources in subscriber's
        context will fail. If specified, the allowed values are between 1 to the value of defaultMaximumExpirationTimeInDays specified in PartnerConfiguration.
        If not specified, the default value will be the value of defaultMaximumExpirationTimeInDays specified in PartnerConfiguration or 7 if this value is not specified.
        """
        return pulumi.get(self, "authorization_expiration_time_in_utc")

    @property
    @pulumi.getter(name="partnerName")
    def partner_name(self) -> Optional[builtins.str]:
        """
        The partner name.
        """
        return pulumi.get(self, "partner_name")

    @property
    @pulumi.getter(name="partnerRegistrationImmutableId")
    def partner_registration_immutable_id(self) -> Optional[builtins.str]:
        """
        The immutableId of the corresponding partner registration.
        """
        return pulumi.get(self, "partner_registration_immutable_id")


@pulumi.output_type
class PartnerTopicInfoResponse(dict):
    """
    Properties of the corresponding partner topic of a Channel.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureSubscriptionId":
            suggest = "azure_subscription_id"
        elif key == "eventTypeInfo":
            suggest = "event_type_info"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnerTopicInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnerTopicInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnerTopicInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_subscription_id: Optional[builtins.str] = None,
                 event_type_info: Optional['outputs.EventTypeInfoResponse'] = None,
                 name: Optional[builtins.str] = None,
                 resource_group_name: Optional[builtins.str] = None,
                 source: Optional[builtins.str] = None):
        """
        Properties of the corresponding partner topic of a Channel.
        :param builtins.str azure_subscription_id: Azure subscription ID of the subscriber. The partner topic associated with the channel will be
               created under this Azure subscription.
        :param 'EventTypeInfoResponse' event_type_info: Event Type Information for the partner topic. This information is provided by the publisher and can be used by the 
               subscriber to view different types of events that are published.
        :param builtins.str name: Name of the partner topic associated with the channel.
        :param builtins.str resource_group_name: Azure Resource Group of the subscriber. The partner topic associated with the channel will be
               created under this resource group.
        :param builtins.str source: The source information is provided by the publisher to determine the scope or context from which the events
               are originating. This information can be used by the subscriber during the approval process of the
               created partner topic.
        """
        if azure_subscription_id is not None:
            pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        if event_type_info is not None:
            pulumi.set(__self__, "event_type_info", event_type_info)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> Optional[builtins.str]:
        """
        Azure subscription ID of the subscriber. The partner topic associated with the channel will be
        created under this Azure subscription.
        """
        return pulumi.get(self, "azure_subscription_id")

    @property
    @pulumi.getter(name="eventTypeInfo")
    def event_type_info(self) -> Optional['outputs.EventTypeInfoResponse']:
        """
        Event Type Information for the partner topic. This information is provided by the publisher and can be used by the 
        subscriber to view different types of events that are published.
        """
        return pulumi.get(self, "event_type_info")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the partner topic associated with the channel.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[builtins.str]:
        """
        Azure Resource Group of the subscriber. The partner topic associated with the channel will be
        created under this resource group.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def source(self) -> Optional[builtins.str]:
        """
        The source information is provided by the publisher to determine the scope or context from which the events
        are originating. This information can be used by the subscriber during the approval process of the
        created partner topic.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 type: builtins.str,
                 group_ids: Optional[Sequence[builtins.str]] = None,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.ConnectionStateResponse'] = None,
                 provisioning_state: Optional[builtins.str] = None):
        """
        :param builtins.str id: Fully qualified identifier of the resource.
        :param builtins.str name: Name of the resource.
        :param builtins.str type: Type of the resource.
        :param Sequence[builtins.str] group_ids: GroupIds from the private link service resource.
        :param 'PrivateEndpointResponse' private_endpoint: The Private Endpoint resource for this Connection.
        :param 'ConnectionStateResponse' private_link_service_connection_state: Details about the state of the connection.
        :param builtins.str provisioning_state: Provisioning state of the Private Endpoint Connection.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Fully qualified identifier of the resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the resource.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        GroupIds from the private link service resource.
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The Private Endpoint resource for this Connection.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.ConnectionStateResponse']:
        """
        Details about the state of the connection.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[builtins.str]:
        """
        Provisioning state of the Private Endpoint Connection.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    PrivateEndpoint information.
    """
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        """
        PrivateEndpoint information.
        :param builtins.str id: The ARM identifier for Private Endpoint.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The ARM identifier for Private Endpoint.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PushInfoResponse(dict):
    """
    Properties of the destination info for event subscription supporting push.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deadLetterDestinationWithResourceIdentity":
            suggest = "dead_letter_destination_with_resource_identity"
        elif key == "deliveryWithResourceIdentity":
            suggest = "delivery_with_resource_identity"
        elif key == "eventTimeToLive":
            suggest = "event_time_to_live"
        elif key == "maxDeliveryCount":
            suggest = "max_delivery_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PushInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PushInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PushInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dead_letter_destination_with_resource_identity: Optional['outputs.DeadLetterWithResourceIdentityResponse'] = None,
                 delivery_with_resource_identity: Optional['outputs.DeliveryWithResourceIdentityResponse'] = None,
                 destination: Optional[Any] = None,
                 event_time_to_live: Optional[builtins.str] = None,
                 max_delivery_count: Optional[builtins.int] = None):
        """
        Properties of the destination info for event subscription supporting push.
        :param 'DeadLetterWithResourceIdentityResponse' dead_letter_destination_with_resource_identity: The dead letter destination of the event subscription. Any event that cannot be delivered to its' destination is sent to the dead letter destination.
               Uses the managed identity setup on the parent resource (namely, namespace) to acquire the authentication tokens being used during dead-lettering.
        :param 'DeliveryWithResourceIdentityResponse' delivery_with_resource_identity: Information about the destination where events have to be delivered for the event subscription.
               Uses the managed identity setup on the parent resource (namely, topic or domain) to acquire the authentication tokens being used during delivery.
        :param Union['AzureFunctionEventSubscriptionDestinationResponse', 'EventHubEventSubscriptionDestinationResponse', 'HybridConnectionEventSubscriptionDestinationResponse', 'MonitorAlertEventSubscriptionDestinationResponse', 'NamespaceTopicEventSubscriptionDestinationResponse', 'ServiceBusQueueEventSubscriptionDestinationResponse', 'ServiceBusTopicEventSubscriptionDestinationResponse', 'StorageQueueEventSubscriptionDestinationResponse', 'WebHookEventSubscriptionDestinationResponse'] destination: Information about the destination where events have to be delivered for the event subscription.
               Uses Azure Event Grid's identity to acquire the authentication tokens being used during delivery.
        :param builtins.str event_time_to_live: Time span duration in ISO 8601 format that determines how long messages are available to the subscription from the time the message was published.
               This duration value is expressed using the following format: \\'P(n)Y(n)M(n)DT(n)H(n)M(n)S\\', where:
                   - (n) is replaced by the value of each time element that follows the (n).
                   - P is the duration (or Period) designator and is always placed at the beginning of the duration.
                   - Y is the year designator, and it follows the value for the number of years.
                   - M is the month designator, and it follows the value for the number of months.
                   - W is the week designator, and it follows the value for the number of weeks.
                   - D is the day designator, and it follows the value for the number of days.
                   - T is the time designator, and it precedes the time components.
                   - H is the hour designator, and it follows the value for the number of hours.
                   - M is the minute designator, and it follows the value for the number of minutes.
                   - S is the second designator, and it follows the value for the number of seconds.
               This duration value cannot be set greater than the topics EventRetentionInDays. It is is an optional field where its minimum value is 1 minute, and its maximum is determined
               by topics EventRetentionInDays value. The followings are examples of valid values:
                   - \\'P0DT23H12M\\' or \\'PT23H12M\\': for duration of 23 hours and 12 minutes.
                   - \\'P1D\\' or \\'P1DT0H0M0S\\': for duration of 1 day.
        :param builtins.int max_delivery_count: The maximum delivery count of the events.
        """
        if dead_letter_destination_with_resource_identity is not None:
            pulumi.set(__self__, "dead_letter_destination_with_resource_identity", dead_letter_destination_with_resource_identity)
        if delivery_with_resource_identity is not None:
            pulumi.set(__self__, "delivery_with_resource_identity", delivery_with_resource_identity)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if event_time_to_live is not None:
            pulumi.set(__self__, "event_time_to_live", event_time_to_live)
        if max_delivery_count is not None:
            pulumi.set(__self__, "max_delivery_count", max_delivery_count)

    @property
    @pulumi.getter(name="deadLetterDestinationWithResourceIdentity")
    def dead_letter_destination_with_resource_identity(self) -> Optional['outputs.DeadLetterWithResourceIdentityResponse']:
        """
        The dead letter destination of the event subscription. Any event that cannot be delivered to its' destination is sent to the dead letter destination.
        Uses the managed identity setup on the parent resource (namely, namespace) to acquire the authentication tokens being used during dead-lettering.
        """
        return pulumi.get(self, "dead_letter_destination_with_resource_identity")

    @property
    @pulumi.getter(name="deliveryWithResourceIdentity")
    def delivery_with_resource_identity(self) -> Optional['outputs.DeliveryWithResourceIdentityResponse']:
        """
        Information about the destination where events have to be delivered for the event subscription.
        Uses the managed identity setup on the parent resource (namely, topic or domain) to acquire the authentication tokens being used during delivery.
        """
        return pulumi.get(self, "delivery_with_resource_identity")

    @property
    @pulumi.getter
    def destination(self) -> Optional[Any]:
        """
        Information about the destination where events have to be delivered for the event subscription.
        Uses Azure Event Grid's identity to acquire the authentication tokens being used during delivery.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="eventTimeToLive")
    def event_time_to_live(self) -> Optional[builtins.str]:
        """
        Time span duration in ISO 8601 format that determines how long messages are available to the subscription from the time the message was published.
        This duration value is expressed using the following format: \\'P(n)Y(n)M(n)DT(n)H(n)M(n)S\\', where:
            - (n) is replaced by the value of each time element that follows the (n).
            - P is the duration (or Period) designator and is always placed at the beginning of the duration.
            - Y is the year designator, and it follows the value for the number of years.
            - M is the month designator, and it follows the value for the number of months.
            - W is the week designator, and it follows the value for the number of weeks.
            - D is the day designator, and it follows the value for the number of days.
            - T is the time designator, and it precedes the time components.
            - H is the hour designator, and it follows the value for the number of hours.
            - M is the minute designator, and it follows the value for the number of minutes.
            - S is the second designator, and it follows the value for the number of seconds.
        This duration value cannot be set greater than the topics EventRetentionInDays. It is is an optional field where its minimum value is 1 minute, and its maximum is determined
        by topics EventRetentionInDays value. The followings are examples of valid values:
            - \\'P0DT23H12M\\' or \\'PT23H12M\\': for duration of 23 hours and 12 minutes.
            - \\'P1D\\' or \\'P1DT0H0M0S\\': for duration of 1 day.
        """
        return pulumi.get(self, "event_time_to_live")

    @property
    @pulumi.getter(name="maxDeliveryCount")
    def max_delivery_count(self) -> Optional[builtins.int]:
        """
        The maximum delivery count of the events.
        """
        return pulumi.get(self, "max_delivery_count")


@pulumi.output_type
class QueueInfoResponse(dict):
    """
    Properties of the Queue info for event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deadLetterDestinationWithResourceIdentity":
            suggest = "dead_letter_destination_with_resource_identity"
        elif key == "eventTimeToLive":
            suggest = "event_time_to_live"
        elif key == "maxDeliveryCount":
            suggest = "max_delivery_count"
        elif key == "receiveLockDurationInSeconds":
            suggest = "receive_lock_duration_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dead_letter_destination_with_resource_identity: Optional['outputs.DeadLetterWithResourceIdentityResponse'] = None,
                 event_time_to_live: Optional[builtins.str] = None,
                 max_delivery_count: Optional[builtins.int] = None,
                 receive_lock_duration_in_seconds: Optional[builtins.int] = None):
        """
        Properties of the Queue info for event subscription.
        :param 'DeadLetterWithResourceIdentityResponse' dead_letter_destination_with_resource_identity: The dead letter destination of the event subscription. Any event that cannot be delivered to its' destination is sent to the dead letter destination.
               Uses the managed identity setup on the parent resource (namely, topic) to acquire the authentication tokens being used during delivery / dead-lettering.
        :param builtins.str event_time_to_live: Time span duration in ISO 8601 format that determines how long messages are available to the subscription from the time the message was published.
               This duration value is expressed using the following format: \\'P(n)Y(n)M(n)DT(n)H(n)M(n)S\\', where:
                   - (n) is replaced by the value of each time element that follows the (n).
                   - P is the duration (or Period) designator and is always placed at the beginning of the duration.
                   - Y is the year designator, and it follows the value for the number of years.
                   - M is the month designator, and it follows the value for the number of months.
                   - W is the week designator, and it follows the value for the number of weeks.
                   - D is the day designator, and it follows the value for the number of days.
                   - T is the time designator, and it precedes the time components.
                   - H is the hour designator, and it follows the value for the number of hours.
                   - M is the minute designator, and it follows the value for the number of minutes.
                   - S is the second designator, and it follows the value for the number of seconds.
               This duration value cannot be set greater than the topics EventRetentionInDays. It is is an optional field where its minimum value is 1 minute, and its maximum is determined
               by topics EventRetentionInDays value. The followings are examples of valid values:
                   - \\'P0DT23H12M\\' or \\'PT23H12M\\': for duration of 23 hours and 12 minutes.
                   - \\'P1D\\' or \\'P1DT0H0M0S\\': for duration of 1 day.
        :param builtins.int max_delivery_count: The maximum delivery count of the events.
        :param builtins.int receive_lock_duration_in_seconds: Maximum period in seconds in which once the message is in received (by the client) state and waiting to be accepted, released or rejected.
               If this time elapsed after a message has been received by the client and not transitioned into accepted (not processed), released or rejected,
               the message is available for redelivery. This is an optional field, where default is 60 seconds, minimum is 60 seconds and maximum is 300 seconds.
        """
        if dead_letter_destination_with_resource_identity is not None:
            pulumi.set(__self__, "dead_letter_destination_with_resource_identity", dead_letter_destination_with_resource_identity)
        if event_time_to_live is not None:
            pulumi.set(__self__, "event_time_to_live", event_time_to_live)
        if max_delivery_count is not None:
            pulumi.set(__self__, "max_delivery_count", max_delivery_count)
        if receive_lock_duration_in_seconds is not None:
            pulumi.set(__self__, "receive_lock_duration_in_seconds", receive_lock_duration_in_seconds)

    @property
    @pulumi.getter(name="deadLetterDestinationWithResourceIdentity")
    def dead_letter_destination_with_resource_identity(self) -> Optional['outputs.DeadLetterWithResourceIdentityResponse']:
        """
        The dead letter destination of the event subscription. Any event that cannot be delivered to its' destination is sent to the dead letter destination.
        Uses the managed identity setup on the parent resource (namely, topic) to acquire the authentication tokens being used during delivery / dead-lettering.
        """
        return pulumi.get(self, "dead_letter_destination_with_resource_identity")

    @property
    @pulumi.getter(name="eventTimeToLive")
    def event_time_to_live(self) -> Optional[builtins.str]:
        """
        Time span duration in ISO 8601 format that determines how long messages are available to the subscription from the time the message was published.
        This duration value is expressed using the following format: \\'P(n)Y(n)M(n)DT(n)H(n)M(n)S\\', where:
            - (n) is replaced by the value of each time element that follows the (n).
            - P is the duration (or Period) designator and is always placed at the beginning of the duration.
            - Y is the year designator, and it follows the value for the number of years.
            - M is the month designator, and it follows the value for the number of months.
            - W is the week designator, and it follows the value for the number of weeks.
            - D is the day designator, and it follows the value for the number of days.
            - T is the time designator, and it precedes the time components.
            - H is the hour designator, and it follows the value for the number of hours.
            - M is the minute designator, and it follows the value for the number of minutes.
            - S is the second designator, and it follows the value for the number of seconds.
        This duration value cannot be set greater than the topics EventRetentionInDays. It is is an optional field where its minimum value is 1 minute, and its maximum is determined
        by topics EventRetentionInDays value. The followings are examples of valid values:
            - \\'P0DT23H12M\\' or \\'PT23H12M\\': for duration of 23 hours and 12 minutes.
            - \\'P1D\\' or \\'P1DT0H0M0S\\': for duration of 1 day.
        """
        return pulumi.get(self, "event_time_to_live")

    @property
    @pulumi.getter(name="maxDeliveryCount")
    def max_delivery_count(self) -> Optional[builtins.int]:
        """
        The maximum delivery count of the events.
        """
        return pulumi.get(self, "max_delivery_count")

    @property
    @pulumi.getter(name="receiveLockDurationInSeconds")
    def receive_lock_duration_in_seconds(self) -> Optional[builtins.int]:
        """
        Maximum period in seconds in which once the message is in received (by the client) state and waiting to be accepted, released or rejected.
        If this time elapsed after a message has been received by the client and not transitioned into accepted (not processed), released or rejected,
        the message is available for redelivery. This is an optional field, where default is 60 seconds, minimum is 60 seconds and maximum is 300 seconds.
        """
        return pulumi.get(self, "receive_lock_duration_in_seconds")


@pulumi.output_type
class RetryPolicyResponse(dict):
    """
    Information about the retry policy for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventTimeToLiveInMinutes":
            suggest = "event_time_to_live_in_minutes"
        elif key == "maxDeliveryAttempts":
            suggest = "max_delivery_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetryPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetryPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetryPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_time_to_live_in_minutes: Optional[builtins.int] = None,
                 max_delivery_attempts: Optional[builtins.int] = None):
        """
        Information about the retry policy for an event subscription.
        :param builtins.int event_time_to_live_in_minutes: Time To Live (in minutes) for events.
        :param builtins.int max_delivery_attempts: Maximum number of delivery retry attempts for events.
        """
        if event_time_to_live_in_minutes is None:
            event_time_to_live_in_minutes = 1440
        if event_time_to_live_in_minutes is not None:
            pulumi.set(__self__, "event_time_to_live_in_minutes", event_time_to_live_in_minutes)
        if max_delivery_attempts is None:
            max_delivery_attempts = 30
        if max_delivery_attempts is not None:
            pulumi.set(__self__, "max_delivery_attempts", max_delivery_attempts)

    @property
    @pulumi.getter(name="eventTimeToLiveInMinutes")
    def event_time_to_live_in_minutes(self) -> Optional[builtins.int]:
        """
        Time To Live (in minutes) for events.
        """
        return pulumi.get(self, "event_time_to_live_in_minutes")

    @property
    @pulumi.getter(name="maxDeliveryAttempts")
    def max_delivery_attempts(self) -> Optional[builtins.int]:
        """
        Maximum number of delivery retry attempts for events.
        """
        return pulumi.get(self, "max_delivery_attempts")


@pulumi.output_type
class RoutingEnrichmentsResponse(dict):
    def __init__(__self__, *,
                 dynamic: Optional[Sequence['outputs.DynamicRoutingEnrichmentResponse']] = None,
                 static: Optional[Sequence['outputs.StaticStringRoutingEnrichmentResponse']] = None):
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def dynamic(self) -> Optional[Sequence['outputs.DynamicRoutingEnrichmentResponse']]:
        return pulumi.get(self, "dynamic")

    @property
    @pulumi.getter
    def static(self) -> Optional[Sequence['outputs.StaticStringRoutingEnrichmentResponse']]:
        return pulumi.get(self, "static")


@pulumi.output_type
class RoutingIdentityInfoResponse(dict):
    """
    Routing identity info for topic spaces configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutingIdentityInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutingIdentityInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutingIdentityInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[builtins.str] = None,
                 user_assigned_identity: Optional[builtins.str] = None):
        """
        Routing identity info for topic spaces configuration.
        :param builtins.str type: Routing identity type for topic spaces configuration.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Routing identity type for topic spaces configuration.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[builtins.str]:
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class ServiceBusQueueEventSubscriptionDestinationResponse(dict):
    """
    Information about the service bus destination for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "deliveryAttributeMappings":
            suggest = "delivery_attribute_mappings"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceBusQueueEventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceBusQueueEventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceBusQueueEventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 delivery_attribute_mappings: Optional[Sequence[Any]] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Information about the service bus destination for an event subscription.
        :param builtins.str endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'ServiceBusQueue'.
        :param Sequence[Union['DynamicDeliveryAttributeMappingResponse', 'StaticDeliveryAttributeMappingResponse']] delivery_attribute_mappings: Delivery attribute details.
        :param builtins.str resource_id: The Azure Resource Id that represents the endpoint of the Service Bus destination of an event subscription.
        """
        pulumi.set(__self__, "endpoint_type", 'ServiceBusQueue')
        if delivery_attribute_mappings is not None:
            pulumi.set(__self__, "delivery_attribute_mappings", delivery_attribute_mappings)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'ServiceBusQueue'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[Sequence[Any]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The Azure Resource Id that represents the endpoint of the Service Bus destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ServiceBusTopicEventSubscriptionDestinationResponse(dict):
    """
    Information about the service bus topic destination for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "deliveryAttributeMappings":
            suggest = "delivery_attribute_mappings"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceBusTopicEventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceBusTopicEventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceBusTopicEventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 delivery_attribute_mappings: Optional[Sequence[Any]] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Information about the service bus topic destination for an event subscription.
        :param builtins.str endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'ServiceBusTopic'.
        :param Sequence[Union['DynamicDeliveryAttributeMappingResponse', 'StaticDeliveryAttributeMappingResponse']] delivery_attribute_mappings: Delivery attribute details.
        :param builtins.str resource_id: The Azure Resource Id that represents the endpoint of the Service Bus Topic destination of an event subscription.
        """
        pulumi.set(__self__, "endpoint_type", 'ServiceBusTopic')
        if delivery_attribute_mappings is not None:
            pulumi.set(__self__, "delivery_attribute_mappings", delivery_attribute_mappings)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'ServiceBusTopic'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[Sequence[Any]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The Azure Resource Id that represents the endpoint of the Service Bus Topic destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class StaticDeliveryAttributeMappingResponse(dict):
    """
    Static delivery attribute mapping details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSecret":
            suggest = "is_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticDeliveryAttributeMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticDeliveryAttributeMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticDeliveryAttributeMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 is_secret: Optional[builtins.bool] = None,
                 name: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        Static delivery attribute mapping details.
        :param builtins.str type: Type of the delivery attribute or header name.
               Expected value is 'Static'.
        :param builtins.bool is_secret: Boolean flag to tell if the attribute contains sensitive information .
        :param builtins.str name: Name of the delivery attribute or header.
        :param builtins.str value: Value of the delivery attribute.
        """
        pulumi.set(__self__, "type", 'Static')
        if is_secret is None:
            is_secret = False
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the delivery attribute or header name.
        Expected value is 'Static'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[builtins.bool]:
        """
        Boolean flag to tell if the attribute contains sensitive information .
        """
        return pulumi.get(self, "is_secret")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the delivery attribute or header.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value of the delivery attribute.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class StaticStringRoutingEnrichmentResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticStringRoutingEnrichmentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticStringRoutingEnrichmentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticStringRoutingEnrichmentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str value_type: Static routing enrichment value type. For e.g. this property value can be 'String'.
               Expected value is 'String'.
        :param builtins.str key: Static routing enrichment key.
        :param builtins.str value: String type routing enrichment value.
        """
        pulumi.set(__self__, "value_type", 'String')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> builtins.str:
        """
        Static routing enrichment value type. For e.g. this property value can be 'String'.
        Expected value is 'String'.
        """
        return pulumi.get(self, "value_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        Static routing enrichment key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        String type routing enrichment value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class StorageBlobDeadLetterDestinationResponse(dict):
    """
    Information about the storage blob based dead letter destination.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "blobContainerName":
            suggest = "blob_container_name"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageBlobDeadLetterDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageBlobDeadLetterDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageBlobDeadLetterDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 blob_container_name: Optional[builtins.str] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Information about the storage blob based dead letter destination.
        :param builtins.str endpoint_type: Type of the endpoint for the dead letter destination
               Expected value is 'StorageBlob'.
        :param builtins.str blob_container_name: The name of the Storage blob container that is the destination of the deadletter events
        :param builtins.str resource_id: The Azure Resource ID of the storage account that is the destination of the deadletter events
        """
        pulumi.set(__self__, "endpoint_type", 'StorageBlob')
        if blob_container_name is not None:
            pulumi.set(__self__, "blob_container_name", blob_container_name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the dead letter destination
        Expected value is 'StorageBlob'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="blobContainerName")
    def blob_container_name(self) -> Optional[builtins.str]:
        """
        The name of the Storage blob container that is the destination of the deadletter events
        """
        return pulumi.get(self, "blob_container_name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The Azure Resource ID of the storage account that is the destination of the deadletter events
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class StorageQueueEventSubscriptionDestinationResponse(dict):
    """
    Information about the storage queue destination for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "queueMessageTimeToLiveInSeconds":
            suggest = "queue_message_time_to_live_in_seconds"
        elif key == "queueName":
            suggest = "queue_name"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageQueueEventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageQueueEventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageQueueEventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 queue_message_time_to_live_in_seconds: Optional[builtins.float] = None,
                 queue_name: Optional[builtins.str] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Information about the storage queue destination for an event subscription.
        :param builtins.str endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'StorageQueue'.
        :param builtins.float queue_message_time_to_live_in_seconds: Storage queue message time to live in seconds. This value cannot be zero or negative with the exception of using -1 to indicate that the Time To Live of the message is Infinite.
        :param builtins.str queue_name: The name of the Storage queue under a storage account that is the destination of an event subscription.
        :param builtins.str resource_id: The Azure Resource ID of the storage account that contains the queue that is the destination of an event subscription.
        """
        pulumi.set(__self__, "endpoint_type", 'StorageQueue')
        if queue_message_time_to_live_in_seconds is not None:
            pulumi.set(__self__, "queue_message_time_to_live_in_seconds", queue_message_time_to_live_in_seconds)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'StorageQueue'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="queueMessageTimeToLiveInSeconds")
    def queue_message_time_to_live_in_seconds(self) -> Optional[builtins.float]:
        """
        Storage queue message time to live in seconds. This value cannot be zero or negative with the exception of using -1 to indicate that the Time To Live of the message is Infinite.
        """
        return pulumi.get(self, "queue_message_time_to_live_in_seconds")

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[builtins.str]:
        """
        The name of the Storage queue under a storage account that is the destination of an event subscription.
        """
        return pulumi.get(self, "queue_name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The Azure Resource ID of the storage account that contains the queue that is the destination of an event subscription.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class StringBeginsWithAdvancedFilterResponse(dict):
    """
    StringBeginsWith Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringBeginsWithAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringBeginsWithAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringBeginsWithAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringBeginsWith Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringBeginsWith'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringBeginsWith')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringBeginsWith'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringBeginsWithFilterResponse(dict):
    """
    StringBeginsWith Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringBeginsWithFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringBeginsWithFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringBeginsWithFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringBeginsWith Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringBeginsWith'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringBeginsWith')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringBeginsWith'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringContainsAdvancedFilterResponse(dict):
    """
    StringContains Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringContainsAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringContainsAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringContainsAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringContains Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringContains'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringContains')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringContains'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringContainsFilterResponse(dict):
    """
    StringContains Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringContainsFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringContainsFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringContainsFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringContains Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringContains'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringContains')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringContains'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringEndsWithAdvancedFilterResponse(dict):
    """
    StringEndsWith Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringEndsWithAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringEndsWithAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringEndsWithAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringEndsWith Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringEndsWith'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringEndsWith')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringEndsWith'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringEndsWithFilterResponse(dict):
    """
    StringEndsWith Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringEndsWithFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringEndsWithFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringEndsWithFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringEndsWith Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringEndsWith'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringEndsWith')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringEndsWith'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringInAdvancedFilterResponse(dict):
    """
    StringIn Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringInAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringInAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringInAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringIn Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringIn'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringIn')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringIn'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringInFilterResponse(dict):
    """
    StringIn Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringInFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringInFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringInFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringIn Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringIn'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringIn')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringIn'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringNotBeginsWithAdvancedFilterResponse(dict):
    """
    StringNotBeginsWith Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringNotBeginsWithAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringNotBeginsWithAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringNotBeginsWithAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringNotBeginsWith Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotBeginsWith'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringNotBeginsWith')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotBeginsWith'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringNotBeginsWithFilterResponse(dict):
    """
    StringNotBeginsWith Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringNotBeginsWithFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringNotBeginsWithFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringNotBeginsWithFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringNotBeginsWith Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotBeginsWith'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringNotBeginsWith')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotBeginsWith'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringNotContainsAdvancedFilterResponse(dict):
    """
    StringNotContains Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringNotContainsAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringNotContainsAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringNotContainsAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringNotContains Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotContains'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringNotContains')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotContains'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringNotContainsFilterResponse(dict):
    """
    StringNotContains Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringNotContainsFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringNotContainsFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringNotContainsFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringNotContains Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotContains'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringNotContains')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotContains'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringNotEndsWithAdvancedFilterResponse(dict):
    """
    StringNotEndsWith Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringNotEndsWithAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringNotEndsWithAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringNotEndsWithAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringNotEndsWith Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotEndsWith'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringNotEndsWith')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotEndsWith'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringNotEndsWithFilterResponse(dict):
    """
    StringNotEndsWith Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringNotEndsWithFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringNotEndsWithFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringNotEndsWithFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringNotEndsWith Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotEndsWith'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringNotEndsWith')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotEndsWith'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringNotInAdvancedFilterResponse(dict):
    """
    StringNotIn Advanced Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringNotInAdvancedFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringNotInAdvancedFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringNotInAdvancedFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringNotIn Advanced Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotIn'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringNotIn')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotIn'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class StringNotInFilterResponse(dict):
    """
    StringNotIn Filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorType":
            suggest = "operator_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StringNotInFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StringNotInFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StringNotInFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_type: builtins.str,
                 key: Optional[builtins.str] = None,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        StringNotIn Filter.
        :param builtins.str operator_type: The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
               Expected value is 'StringNotIn'.
        :param builtins.str key: The field/property in the event based on which you want to filter.
        :param Sequence[builtins.str] values: The set of filter values.
        """
        pulumi.set(__self__, "operator_type", 'StringNotIn')
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="operatorType")
    def operator_type(self) -> builtins.str:
        """
        The operator type used for filtering, e.g., NumberIn, StringContains, BoolEquals and others.
        Expected value is 'StringNotIn'.
        """
        return pulumi.get(self, "operator_type")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The field/property in the event based on which you want to filter.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        The set of filter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TopicSpacesConfigurationResponse(dict):
    """
    Properties of the Topic Spaces Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomains":
            suggest = "custom_domains"
        elif key == "maximumClientSessionsPerAuthenticationName":
            suggest = "maximum_client_sessions_per_authentication_name"
        elif key == "maximumSessionExpiryInHours":
            suggest = "maximum_session_expiry_in_hours"
        elif key == "routeTopicResourceId":
            suggest = "route_topic_resource_id"
        elif key == "routingEnrichments":
            suggest = "routing_enrichments"
        elif key == "routingIdentityInfo":
            suggest = "routing_identity_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicSpacesConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicSpacesConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicSpacesConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: builtins.str,
                 custom_domains: Optional[Sequence['outputs.CustomDomainConfigurationResponse']] = None,
                 maximum_client_sessions_per_authentication_name: Optional[builtins.int] = None,
                 maximum_session_expiry_in_hours: Optional[builtins.int] = None,
                 route_topic_resource_id: Optional[builtins.str] = None,
                 routing_enrichments: Optional['outputs.RoutingEnrichmentsResponse'] = None,
                 routing_identity_info: Optional['outputs.RoutingIdentityInfoResponse'] = None,
                 state: Optional[builtins.str] = None):
        """
        Properties of the Topic Spaces Configuration.
        :param builtins.str hostname: The endpoint for the topic spaces configuration. This is a read-only property.
        :param Sequence['CustomDomainConfigurationResponse'] custom_domains: List of custom domain configurations for the namespace.
        :param builtins.int maximum_client_sessions_per_authentication_name: The maximum number of sessions per authentication name. The property default value is 1.
               Min allowed value is 1 and max allowed value is 100.
        :param builtins.int maximum_session_expiry_in_hours: The maximum session expiry in hours. The property default value is 1 hour.
               Min allowed value is 1 hour and max allowed value is 8 hours.
        :param builtins.str route_topic_resource_id: Fully qualified Azure Resource Id for the Event Grid Topic to which events will be routed to from TopicSpaces under a namespace.
               This property should be in the following format '/subscriptions/{subId}/resourcegroups/{resourceGroupName}/providers/microsoft.EventGrid/topics/{topicName}'.
               This topic should reside in the same region where namespace is located.
        :param 'RoutingEnrichmentsResponse' routing_enrichments: Routing enrichments for topic spaces configuration
        :param 'RoutingIdentityInfoResponse' routing_identity_info: Routing identity info for topic spaces configuration.
        :param builtins.str state: Indicate if Topic Spaces Configuration is enabled for the namespace. Default is Disabled.
        """
        pulumi.set(__self__, "hostname", hostname)
        if custom_domains is not None:
            pulumi.set(__self__, "custom_domains", custom_domains)
        if maximum_client_sessions_per_authentication_name is not None:
            pulumi.set(__self__, "maximum_client_sessions_per_authentication_name", maximum_client_sessions_per_authentication_name)
        if maximum_session_expiry_in_hours is not None:
            pulumi.set(__self__, "maximum_session_expiry_in_hours", maximum_session_expiry_in_hours)
        if route_topic_resource_id is not None:
            pulumi.set(__self__, "route_topic_resource_id", route_topic_resource_id)
        if routing_enrichments is not None:
            pulumi.set(__self__, "routing_enrichments", routing_enrichments)
        if routing_identity_info is not None:
            pulumi.set(__self__, "routing_identity_info", routing_identity_info)
        if state is None:
            state = 'Disabled'
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def hostname(self) -> builtins.str:
        """
        The endpoint for the topic spaces configuration. This is a read-only property.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="customDomains")
    def custom_domains(self) -> Optional[Sequence['outputs.CustomDomainConfigurationResponse']]:
        """
        List of custom domain configurations for the namespace.
        """
        return pulumi.get(self, "custom_domains")

    @property
    @pulumi.getter(name="maximumClientSessionsPerAuthenticationName")
    def maximum_client_sessions_per_authentication_name(self) -> Optional[builtins.int]:
        """
        The maximum number of sessions per authentication name. The property default value is 1.
        Min allowed value is 1 and max allowed value is 100.
        """
        return pulumi.get(self, "maximum_client_sessions_per_authentication_name")

    @property
    @pulumi.getter(name="maximumSessionExpiryInHours")
    def maximum_session_expiry_in_hours(self) -> Optional[builtins.int]:
        """
        The maximum session expiry in hours. The property default value is 1 hour.
        Min allowed value is 1 hour and max allowed value is 8 hours.
        """
        return pulumi.get(self, "maximum_session_expiry_in_hours")

    @property
    @pulumi.getter(name="routeTopicResourceId")
    def route_topic_resource_id(self) -> Optional[builtins.str]:
        """
        Fully qualified Azure Resource Id for the Event Grid Topic to which events will be routed to from TopicSpaces under a namespace.
        This property should be in the following format '/subscriptions/{subId}/resourcegroups/{resourceGroupName}/providers/microsoft.EventGrid/topics/{topicName}'.
        This topic should reside in the same region where namespace is located.
        """
        return pulumi.get(self, "route_topic_resource_id")

    @property
    @pulumi.getter(name="routingEnrichments")
    def routing_enrichments(self) -> Optional['outputs.RoutingEnrichmentsResponse']:
        """
        Routing enrichments for topic spaces configuration
        """
        return pulumi.get(self, "routing_enrichments")

    @property
    @pulumi.getter(name="routingIdentityInfo")
    def routing_identity_info(self) -> Optional['outputs.RoutingIdentityInfoResponse']:
        """
        Routing identity info for topic spaces configuration.
        """
        return pulumi.get(self, "routing_identity_info")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        Indicate if Topic Spaces Configuration is enabled for the namespace. Default is Disabled.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class TopicsConfigurationResponse(dict):
    """
    Properties of the Topics Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomains":
            suggest = "custom_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: builtins.str,
                 custom_domains: Optional[Sequence['outputs.CustomDomainConfigurationResponse']] = None):
        """
        Properties of the Topics Configuration.
        :param builtins.str hostname: The hostname for the topics configuration. This is a read-only property.
        :param Sequence['CustomDomainConfigurationResponse'] custom_domains: List of custom domain configurations for the namespace.
        """
        pulumi.set(__self__, "hostname", hostname)
        if custom_domains is not None:
            pulumi.set(__self__, "custom_domains", custom_domains)

    @property
    @pulumi.getter
    def hostname(self) -> builtins.str:
        """
        The hostname for the topics configuration. This is a read-only property.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="customDomains")
    def custom_domains(self) -> Optional[Sequence['outputs.CustomDomainConfigurationResponse']]:
        """
        List of custom domain configurations for the namespace.
        """
        return pulumi.get(self, "custom_domains")


@pulumi.output_type
class UserIdentityPropertiesResponse(dict):
    """
    The information about the user identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserIdentityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserIdentityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserIdentityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 principal_id: Optional[builtins.str] = None):
        """
        The information about the user identity.
        :param builtins.str client_id: The client id of user assigned identity.
        :param builtins.str principal_id: The principal id of user assigned identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[builtins.str]:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class WebHookEventSubscriptionDestinationResponse(dict):
    """
    Information about the webhook destination for an event subscription.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointBaseUrl":
            suggest = "endpoint_base_url"
        elif key == "endpointType":
            suggest = "endpoint_type"
        elif key == "azureActiveDirectoryApplicationIdOrUri":
            suggest = "azure_active_directory_application_id_or_uri"
        elif key == "azureActiveDirectoryTenantId":
            suggest = "azure_active_directory_tenant_id"
        elif key == "deliveryAttributeMappings":
            suggest = "delivery_attribute_mappings"
        elif key == "endpointUrl":
            suggest = "endpoint_url"
        elif key == "maxEventsPerBatch":
            suggest = "max_events_per_batch"
        elif key == "minimumTlsVersionAllowed":
            suggest = "minimum_tls_version_allowed"
        elif key == "preferredBatchSizeInKilobytes":
            suggest = "preferred_batch_size_in_kilobytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebHookEventSubscriptionDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebHookEventSubscriptionDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebHookEventSubscriptionDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_base_url: builtins.str,
                 endpoint_type: builtins.str,
                 azure_active_directory_application_id_or_uri: Optional[builtins.str] = None,
                 azure_active_directory_tenant_id: Optional[builtins.str] = None,
                 delivery_attribute_mappings: Optional[Sequence[Any]] = None,
                 endpoint_url: Optional[builtins.str] = None,
                 max_events_per_batch: Optional[builtins.int] = None,
                 minimum_tls_version_allowed: Optional[builtins.str] = None,
                 preferred_batch_size_in_kilobytes: Optional[builtins.int] = None):
        """
        Information about the webhook destination for an event subscription.
        :param builtins.str endpoint_base_url: The base URL that represents the endpoint of the destination of an event subscription.
        :param builtins.str endpoint_type: Type of the endpoint for the event subscription destination.
               Expected value is 'WebHook'.
        :param builtins.str azure_active_directory_application_id_or_uri: The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        :param builtins.str azure_active_directory_tenant_id: The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        :param Sequence[Union['DynamicDeliveryAttributeMappingResponse', 'StaticDeliveryAttributeMappingResponse']] delivery_attribute_mappings: Delivery attribute details.
        :param builtins.str endpoint_url: The URL that represents the endpoint of the destination of an event subscription.
        :param builtins.int max_events_per_batch: Maximum number of events per batch.
        :param builtins.str minimum_tls_version_allowed: Minimum TLS version that should be supported by webhook endpoint
        :param builtins.int preferred_batch_size_in_kilobytes: Preferred batch size in Kilobytes.
        """
        pulumi.set(__self__, "endpoint_base_url", endpoint_base_url)
        pulumi.set(__self__, "endpoint_type", 'WebHook')
        if azure_active_directory_application_id_or_uri is not None:
            pulumi.set(__self__, "azure_active_directory_application_id_or_uri", azure_active_directory_application_id_or_uri)
        if azure_active_directory_tenant_id is not None:
            pulumi.set(__self__, "azure_active_directory_tenant_id", azure_active_directory_tenant_id)
        if delivery_attribute_mappings is not None:
            pulumi.set(__self__, "delivery_attribute_mappings", delivery_attribute_mappings)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if max_events_per_batch is None:
            max_events_per_batch = 1
        if max_events_per_batch is not None:
            pulumi.set(__self__, "max_events_per_batch", max_events_per_batch)
        if minimum_tls_version_allowed is not None:
            pulumi.set(__self__, "minimum_tls_version_allowed", minimum_tls_version_allowed)
        if preferred_batch_size_in_kilobytes is None:
            preferred_batch_size_in_kilobytes = 64
        if preferred_batch_size_in_kilobytes is not None:
            pulumi.set(__self__, "preferred_batch_size_in_kilobytes", preferred_batch_size_in_kilobytes)

    @property
    @pulumi.getter(name="endpointBaseUrl")
    def endpoint_base_url(self) -> builtins.str:
        """
        The base URL that represents the endpoint of the destination of an event subscription.
        """
        return pulumi.get(self, "endpoint_base_url")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of the endpoint for the event subscription destination.
        Expected value is 'WebHook'.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="azureActiveDirectoryApplicationIdOrUri")
    def azure_active_directory_application_id_or_uri(self) -> Optional[builtins.str]:
        """
        The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "azure_active_directory_application_id_or_uri")

    @property
    @pulumi.getter(name="azureActiveDirectoryTenantId")
    def azure_active_directory_tenant_id(self) -> Optional[builtins.str]:
        """
        The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
        """
        return pulumi.get(self, "azure_active_directory_tenant_id")

    @property
    @pulumi.getter(name="deliveryAttributeMappings")
    def delivery_attribute_mappings(self) -> Optional[Sequence[Any]]:
        """
        Delivery attribute details.
        """
        return pulumi.get(self, "delivery_attribute_mappings")

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[builtins.str]:
        """
        The URL that represents the endpoint of the destination of an event subscription.
        """
        return pulumi.get(self, "endpoint_url")

    @property
    @pulumi.getter(name="maxEventsPerBatch")
    def max_events_per_batch(self) -> Optional[builtins.int]:
        """
        Maximum number of events per batch.
        """
        return pulumi.get(self, "max_events_per_batch")

    @property
    @pulumi.getter(name="minimumTlsVersionAllowed")
    def minimum_tls_version_allowed(self) -> Optional[builtins.str]:
        """
        Minimum TLS version that should be supported by webhook endpoint
        """
        return pulumi.get(self, "minimum_tls_version_allowed")

    @property
    @pulumi.getter(name="preferredBatchSizeInKilobytes")
    def preferred_batch_size_in_kilobytes(self) -> Optional[builtins.int]:
        """
        Preferred batch size in Kilobytes.
        """
        return pulumi.get(self, "preferred_batch_size_in_kilobytes")


