# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'APIServerAccessProfileResponse',
    'AbsoluteMonthlyScheduleResponse',
    'AdvancedNetworkingObservabilityResponse',
    'AdvancedNetworkingResponse',
    'AdvancedNetworkingSecurityResponse',
    'AgentPoolGatewayProfileResponse',
    'AgentPoolNetworkProfileResponse',
    'AgentPoolSecurityProfileResponse',
    'AgentPoolStatusResponse',
    'AgentPoolUpgradeSettingsResponse',
    'AgentPoolWindowsProfileResponse',
    'AgentProfileResponse',
    'AutoUpgradeNodeImageSelectionResponse',
    'AzureKeyVaultKmsResponse',
    'ClusterUpgradeSettingsResponse',
    'ContainerServiceLinuxProfileResponse',
    'ContainerServiceNetworkProfileResponse',
    'ContainerServiceSshConfigurationResponse',
    'ContainerServiceSshPublicKeyResponse',
    'CreationDataResponse',
    'CredentialResultResponse',
    'DailyScheduleResponse',
    'DateSpanResponse',
    'DelegatedResourceResponse',
    'ErrorAdditionalInfoResponse',
    'ErrorDetailResponse',
    'ExtendedLocationResponse',
    'FleetCredentialResultResponse',
    'FleetHubProfileResponse',
    'GPUProfileResponse',
    'IPTagResponse',
    'IdentityBindingManagedIdentityProfileResponse',
    'IdentityBindingOidcIssuerProfileResponse',
    'IdentityBindingPropertiesResponse',
    'IstioCertificateAuthorityResponse',
    'IstioComponentsResponse',
    'IstioEgressGatewayResponse',
    'IstioIngressGatewayResponse',
    'IstioPluginCertificateAuthorityResponse',
    'IstioServiceMeshResponse',
    'JWTAuthenticatorClaimMappingExpressionResponse',
    'JWTAuthenticatorClaimMappingsResponse',
    'JWTAuthenticatorExtraClaimMappingExpressionResponse',
    'JWTAuthenticatorIssuerResponse',
    'JWTAuthenticatorPropertiesResponse',
    'JWTAuthenticatorValidationRuleResponse',
    'KubeletConfigResponse',
    'LabelSelectorRequirementResponse',
    'LabelSelectorResponse',
    'LinuxOSConfigResponse',
    'MaintenanceWindowResponse',
    'ManagedClusterAADProfileResponse',
    'ManagedClusterAIToolchainOperatorProfileResponse',
    'ManagedClusterAPIServerAccessProfileResponse',
    'ManagedClusterAddonProfileResponse',
    'ManagedClusterAddonProfileResponseIdentity',
    'ManagedClusterAgentPoolProfileResponse',
    'ManagedClusterAutoUpgradeProfileResponse',
    'ManagedClusterAzureMonitorProfileKubeStateMetricsResponse',
    'ManagedClusterAzureMonitorProfileMetricsResponse',
    'ManagedClusterAzureMonitorProfileResponse',
    'ManagedClusterBootstrapProfileResponse',
    'ManagedClusterCostAnalysisResponse',
    'ManagedClusterHTTPProxyConfigResponse',
    'ManagedClusterIdentityResponse',
    'ManagedClusterIdentityResponseUserAssignedIdentities',
    'ManagedClusterIngressProfileNginxResponse',
    'ManagedClusterIngressProfileResponse',
    'ManagedClusterIngressProfileWebAppRoutingResponse',
    'ManagedClusterLoadBalancerProfileResponse',
    'ManagedClusterLoadBalancerProfileResponseManagedOutboundIPs',
    'ManagedClusterLoadBalancerProfileResponseOutboundIPPrefixes',
    'ManagedClusterLoadBalancerProfileResponseOutboundIPs',
    'ManagedClusterManagedOutboundIPProfileResponse',
    'ManagedClusterMetricsProfileResponse',
    'ManagedClusterNATGatewayProfileResponse',
    'ManagedClusterNodeProvisioningProfileResponse',
    'ManagedClusterNodeResourceGroupProfileResponse',
    'ManagedClusterOIDCIssuerProfileResponse',
    'ManagedClusterPodIdentityExceptionResponse',
    'ManagedClusterPodIdentityProfileResponse',
    'ManagedClusterPodIdentityProvisioningErrorBodyResponse',
    'ManagedClusterPodIdentityProvisioningErrorResponse',
    'ManagedClusterPodIdentityResponse',
    'ManagedClusterPodIdentityResponseProvisioningInfo',
    'ManagedClusterPropertiesForSnapshotResponse',
    'ManagedClusterPropertiesResponseAutoScalerProfile',
    'ManagedClusterSKUResponse',
    'ManagedClusterSecurityProfileDefenderResponse',
    'ManagedClusterSecurityProfileDefenderSecurityMonitoringResponse',
    'ManagedClusterSecurityProfileImageCleanerResponse',
    'ManagedClusterSecurityProfileResponse',
    'ManagedClusterSecurityProfileWorkloadIdentityResponse',
    'ManagedClusterServicePrincipalProfileResponse',
    'ManagedClusterStaticEgressGatewayProfileResponse',
    'ManagedClusterStatusResponse',
    'ManagedClusterStorageProfileBlobCSIDriverResponse',
    'ManagedClusterStorageProfileDiskCSIDriverResponse',
    'ManagedClusterStorageProfileFileCSIDriverResponse',
    'ManagedClusterStorageProfileResponse',
    'ManagedClusterStorageProfileSnapshotControllerResponse',
    'ManagedClusterUpdateResponse',
    'ManagedClusterUpgradeSpecResponse',
    'ManagedClusterWindowsProfileResponse',
    'ManagedClusterWorkloadAutoScalerProfileKedaResponse',
    'ManagedClusterWorkloadAutoScalerProfileResponse',
    'ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscalerResponse',
    'ManagedServiceIdentityResponse',
    'ManualScaleProfileResponse',
    'MemberUpdateStatusResponse',
    'NamespacePropertiesResponse',
    'NetworkPoliciesResponse',
    'NetworkProfileForSnapshotResponse',
    'NodeCustomizationPropertiesResponse',
    'NodeCustomizationScriptResponse',
    'NodeImageSelectionResponse',
    'NodeImageSelectionStatusResponse',
    'NodeImageVersionResponse',
    'PortRangeResponse',
    'PowerStateResponse',
    'PrivateEndpointResponse',
    'PrivateLinkResourceResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'RelativeMonthlyScheduleResponse',
    'ResourceQuotaResponse',
    'ResourceReferenceResponse',
    'ScaleProfileResponse',
    'ScheduleResponse',
    'ServiceMeshProfileResponse',
    'SysctlConfigResponse',
    'SystemDataResponse',
    'TimeInWeekResponse',
    'TimeSpanResponse',
    'UpdateGroupResponse',
    'UpdateGroupStatusResponse',
    'UpdateRunStatusResponse',
    'UpdateRunStrategyResponse',
    'UpdateStageResponse',
    'UpdateStageStatusResponse',
    'UpdateStatusResponse',
    'UpgradeOverrideSettingsResponse',
    'UserAssignedIdentityResponse',
    'VirtualMachineNodesResponse',
    'VirtualMachinesProfileResponse',
    'WaitStatusResponse',
    'WeeklyScheduleResponse',
    'WindowsGmsaProfileResponse',
]

@pulumi.output_type
class APIServerAccessProfileResponse(dict):
    """
    Access profile for the Fleet hub API server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enablePrivateCluster":
            suggest = "enable_private_cluster"
        elif key == "enableVnetIntegration":
            suggest = "enable_vnet_integration"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in APIServerAccessProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        APIServerAccessProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        APIServerAccessProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_private_cluster: Optional[_builtins.bool] = None,
                 enable_vnet_integration: Optional[_builtins.bool] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        Access profile for the Fleet hub API server.
        :param _builtins.bool enable_private_cluster: Whether to create the Fleet hub as a private cluster or not.
        :param _builtins.bool enable_vnet_integration: Whether to enable apiserver vnet integration for the Fleet hub or not.
        :param _builtins.str subnet_id: The subnet to be used when apiserver vnet integration is enabled. It is required when creating a new Fleet with BYO vnet.
        """
        if enable_private_cluster is not None:
            pulumi.set(__self__, "enable_private_cluster", enable_private_cluster)
        if enable_vnet_integration is not None:
            pulumi.set(__self__, "enable_vnet_integration", enable_vnet_integration)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="enablePrivateCluster")
    def enable_private_cluster(self) -> Optional[_builtins.bool]:
        """
        Whether to create the Fleet hub as a private cluster or not.
        """
        return pulumi.get(self, "enable_private_cluster")

    @_builtins.property
    @pulumi.getter(name="enableVnetIntegration")
    def enable_vnet_integration(self) -> Optional[_builtins.bool]:
        """
        Whether to enable apiserver vnet integration for the Fleet hub or not.
        """
        return pulumi.get(self, "enable_vnet_integration")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The subnet to be used when apiserver vnet integration is enabled. It is required when creating a new Fleet with BYO vnet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AbsoluteMonthlyScheduleResponse(dict):
    """
    For schedules like: 'recur every month on the 15th' or 'recur every 3 months on the 20th'.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "intervalMonths":
            suggest = "interval_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AbsoluteMonthlyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AbsoluteMonthlyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AbsoluteMonthlyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_month: _builtins.int,
                 interval_months: _builtins.int):
        """
        For schedules like: 'recur every month on the 15th' or 'recur every 3 months on the 20th'.
        :param _builtins.int day_of_month: The date of the month.
        :param _builtins.int interval_months: Specifies the number of months between each set of occurrences.
        """
        pulumi.set(__self__, "day_of_month", day_of_month)
        pulumi.set(__self__, "interval_months", interval_months)

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> _builtins.int:
        """
        The date of the month.
        """
        return pulumi.get(self, "day_of_month")

    @_builtins.property
    @pulumi.getter(name="intervalMonths")
    def interval_months(self) -> _builtins.int:
        """
        Specifies the number of months between each set of occurrences.
        """
        return pulumi.get(self, "interval_months")


@pulumi.output_type
class AdvancedNetworkingObservabilityResponse(dict):
    """
    Observability profile to enable advanced network metrics and flow logs with historical contexts.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Observability profile to enable advanced network metrics and flow logs with historical contexts.
        :param _builtins.bool enabled: Indicates the enablement of Advanced Networking observability functionalities on clusters.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates the enablement of Advanced Networking observability functionalities on clusters.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AdvancedNetworkingResponse(dict):
    """
    Advanced Networking profile for enabling observability and security feature suite on a cluster. For more information see aka.ms/aksadvancednetworking.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 observability: Optional['outputs.AdvancedNetworkingObservabilityResponse'] = None,
                 security: Optional['outputs.AdvancedNetworkingSecurityResponse'] = None):
        """
        Advanced Networking profile for enabling observability and security feature suite on a cluster. For more information see aka.ms/aksadvancednetworking.
        :param _builtins.bool enabled: Indicates the enablement of Advanced Networking functionalities of observability and security on AKS clusters. When this is set to true, all observability and security features will be set to enabled unless explicitly disabled. If not specified, the default is false.
        :param 'AdvancedNetworkingObservabilityResponse' observability: Observability profile to enable advanced network metrics and flow logs with historical contexts.
        :param 'AdvancedNetworkingSecurityResponse' security: Security profile to enable security features on cilium based cluster.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if observability is not None:
            pulumi.set(__self__, "observability", observability)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates the enablement of Advanced Networking functionalities of observability and security on AKS clusters. When this is set to true, all observability and security features will be set to enabled unless explicitly disabled. If not specified, the default is false.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def observability(self) -> Optional['outputs.AdvancedNetworkingObservabilityResponse']:
        """
        Observability profile to enable advanced network metrics and flow logs with historical contexts.
        """
        return pulumi.get(self, "observability")

    @_builtins.property
    @pulumi.getter
    def security(self) -> Optional['outputs.AdvancedNetworkingSecurityResponse']:
        """
        Security profile to enable security features on cilium based cluster.
        """
        return pulumi.get(self, "security")


@pulumi.output_type
class AdvancedNetworkingSecurityResponse(dict):
    """
    Security profile to enable security features on cilium based cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedNetworkPolicies":
            suggest = "advanced_network_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedNetworkingSecurityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedNetworkingSecurityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedNetworkingSecurityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_network_policies: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        Security profile to enable security features on cilium based cluster.
        :param _builtins.str advanced_network_policies: Enable advanced network policies. This allows users to configure Layer 7 network policies (FQDN, HTTP, Kafka). Policies themselves must be configured via the Cilium Network Policy resources, see https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not specified, the default value is FQDN if security.enabled is set to true.
        :param _builtins.bool enabled: This feature allows user to configure network policy based on DNS (FQDN) names. It can be enabled only on cilium based clusters. If not specified, the default is false.
        """
        if advanced_network_policies is not None:
            pulumi.set(__self__, "advanced_network_policies", advanced_network_policies)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="advancedNetworkPolicies")
    def advanced_network_policies(self) -> Optional[_builtins.str]:
        """
        Enable advanced network policies. This allows users to configure Layer 7 network policies (FQDN, HTTP, Kafka). Policies themselves must be configured via the Cilium Network Policy resources, see https://docs.cilium.io/en/latest/security/policy/index.html. This can be enabled only on cilium-based clusters. If not specified, the default value is FQDN if security.enabled is set to true.
        """
        return pulumi.get(self, "advanced_network_policies")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        This feature allows user to configure network policy based on DNS (FQDN) names. It can be enabled only on cilium based clusters. If not specified, the default is false.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AgentPoolGatewayProfileResponse(dict):
    """
    Profile of the managed cluster gateway agent pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIPPrefixSize":
            suggest = "public_ip_prefix_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentPoolGatewayProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentPoolGatewayProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentPoolGatewayProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ip_prefix_size: Optional[_builtins.int] = None):
        """
        Profile of the managed cluster gateway agent pool.
        :param _builtins.int public_ip_prefix_size: The Gateway agent pool associates one public IPPrefix for each static egress gateway to provide public egress. The size of Public IPPrefix should be selected by the user. Each node in the agent pool is assigned with one IP from the IPPrefix. The IPPrefix size thus serves as a cap on the size of the Gateway agent pool. Due to Azure public IPPrefix size limitation, the valid value range is [28, 31] (/31 = 2 nodes/IPs, /30 = 4 nodes/IPs, /29 = 8 nodes/IPs, /28 = 16 nodes/IPs). The default value is 31.
        """
        if public_ip_prefix_size is None:
            public_ip_prefix_size = 31
        if public_ip_prefix_size is not None:
            pulumi.set(__self__, "public_ip_prefix_size", public_ip_prefix_size)

    @_builtins.property
    @pulumi.getter(name="publicIPPrefixSize")
    def public_ip_prefix_size(self) -> Optional[_builtins.int]:
        """
        The Gateway agent pool associates one public IPPrefix for each static egress gateway to provide public egress. The size of Public IPPrefix should be selected by the user. Each node in the agent pool is assigned with one IP from the IPPrefix. The IPPrefix size thus serves as a cap on the size of the Gateway agent pool. Due to Azure public IPPrefix size limitation, the valid value range is [28, 31] (/31 = 2 nodes/IPs, /30 = 4 nodes/IPs, /29 = 8 nodes/IPs, /28 = 16 nodes/IPs). The default value is 31.
        """
        return pulumi.get(self, "public_ip_prefix_size")


@pulumi.output_type
class AgentPoolNetworkProfileResponse(dict):
    """
    Network settings of an agent pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedHostPorts":
            suggest = "allowed_host_ports"
        elif key == "applicationSecurityGroups":
            suggest = "application_security_groups"
        elif key == "nodePublicIPTags":
            suggest = "node_public_ip_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentPoolNetworkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentPoolNetworkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentPoolNetworkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_host_ports: Optional[Sequence['outputs.PortRangeResponse']] = None,
                 application_security_groups: Optional[Sequence[_builtins.str]] = None,
                 node_public_ip_tags: Optional[Sequence['outputs.IPTagResponse']] = None):
        """
        Network settings of an agent pool.
        :param Sequence['PortRangeResponse'] allowed_host_ports: The port ranges that are allowed to access. The specified ranges are allowed to overlap.
        :param Sequence[_builtins.str] application_security_groups: The IDs of the application security groups which agent pool will associate when created.
        :param Sequence['IPTagResponse'] node_public_ip_tags: IPTags of instance-level public IPs.
        """
        if allowed_host_ports is not None:
            pulumi.set(__self__, "allowed_host_ports", allowed_host_ports)
        if application_security_groups is not None:
            pulumi.set(__self__, "application_security_groups", application_security_groups)
        if node_public_ip_tags is not None:
            pulumi.set(__self__, "node_public_ip_tags", node_public_ip_tags)

    @_builtins.property
    @pulumi.getter(name="allowedHostPorts")
    def allowed_host_ports(self) -> Optional[Sequence['outputs.PortRangeResponse']]:
        """
        The port ranges that are allowed to access. The specified ranges are allowed to overlap.
        """
        return pulumi.get(self, "allowed_host_ports")

    @_builtins.property
    @pulumi.getter(name="applicationSecurityGroups")
    def application_security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IDs of the application security groups which agent pool will associate when created.
        """
        return pulumi.get(self, "application_security_groups")

    @_builtins.property
    @pulumi.getter(name="nodePublicIPTags")
    def node_public_ip_tags(self) -> Optional[Sequence['outputs.IPTagResponse']]:
        """
        IPTags of instance-level public IPs.
        """
        return pulumi.get(self, "node_public_ip_tags")


@pulumi.output_type
class AgentPoolSecurityProfileResponse(dict):
    """
    The security settings of an agent pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableSecureBoot":
            suggest = "enable_secure_boot"
        elif key == "enableVTPM":
            suggest = "enable_vtpm"
        elif key == "sshAccess":
            suggest = "ssh_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentPoolSecurityProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentPoolSecurityProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentPoolSecurityProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_secure_boot: Optional[_builtins.bool] = None,
                 enable_vtpm: Optional[_builtins.bool] = None,
                 ssh_access: Optional[_builtins.str] = None):
        """
        The security settings of an agent pool.
        :param _builtins.bool enable_secure_boot: Secure Boot is a feature of Trusted Launch which ensures that only signed operating systems and drivers can boot. For more details, see aka.ms/aks/trustedlaunch.  If not specified, the default is false.
        :param _builtins.bool enable_vtpm: vTPM is a Trusted Launch feature for configuring a dedicated secure vault for keys and measurements held locally on the node. For more details, see aka.ms/aks/trustedlaunch. If not specified, the default is false.
        :param _builtins.str ssh_access: SSH access method of an agent pool.
        """
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)
        if enable_vtpm is not None:
            pulumi.set(__self__, "enable_vtpm", enable_vtpm)
        if ssh_access is not None:
            pulumi.set(__self__, "ssh_access", ssh_access)

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[_builtins.bool]:
        """
        Secure Boot is a feature of Trusted Launch which ensures that only signed operating systems and drivers can boot. For more details, see aka.ms/aks/trustedlaunch.  If not specified, the default is false.
        """
        return pulumi.get(self, "enable_secure_boot")

    @_builtins.property
    @pulumi.getter(name="enableVTPM")
    def enable_vtpm(self) -> Optional[_builtins.bool]:
        """
        vTPM is a Trusted Launch feature for configuring a dedicated secure vault for keys and measurements held locally on the node. For more details, see aka.ms/aks/trustedlaunch. If not specified, the default is false.
        """
        return pulumi.get(self, "enable_vtpm")

    @_builtins.property
    @pulumi.getter(name="sshAccess")
    def ssh_access(self) -> Optional[_builtins.str]:
        """
        SSH access method of an agent pool.
        """
        return pulumi.get(self, "ssh_access")


@pulumi.output_type
class AgentPoolStatusResponse(dict):
    """
    Contains read-only information about the Agent Pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningError":
            suggest = "provisioning_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentPoolStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentPoolStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentPoolStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_error: 'outputs.ErrorDetailResponse'):
        """
        Contains read-only information about the Agent Pool.
        :param 'ErrorDetailResponse' provisioning_error: The error detail information of the agent pool. Preserves the detailed info of failure. If there was no error, this field is omitted.
        """
        pulumi.set(__self__, "provisioning_error", provisioning_error)

    @_builtins.property
    @pulumi.getter(name="provisioningError")
    def provisioning_error(self) -> 'outputs.ErrorDetailResponse':
        """
        The error detail information of the agent pool. Preserves the detailed info of failure. If there was no error, this field is omitted.
        """
        return pulumi.get(self, "provisioning_error")


@pulumi.output_type
class AgentPoolUpgradeSettingsResponse(dict):
    """
    Settings for upgrading an agentpool
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainTimeoutInMinutes":
            suggest = "drain_timeout_in_minutes"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"
        elif key == "nodeSoakDurationInMinutes":
            suggest = "node_soak_duration_in_minutes"
        elif key == "undrainableNodeBehavior":
            suggest = "undrainable_node_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentPoolUpgradeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentPoolUpgradeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentPoolUpgradeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_timeout_in_minutes: Optional[_builtins.int] = None,
                 max_surge: Optional[_builtins.str] = None,
                 max_unavailable: Optional[_builtins.str] = None,
                 node_soak_duration_in_minutes: Optional[_builtins.int] = None,
                 undrainable_node_behavior: Optional[_builtins.str] = None):
        """
        Settings for upgrading an agentpool
        :param _builtins.int drain_timeout_in_minutes: The drain timeout for a node. The amount of time (in minutes) to wait on eviction of pods and graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is exceeded, the upgrade fails. If not specified, the default is 30 minutes.
        :param _builtins.str max_surge: The maximum number or percentage of nodes that are surged during upgrade. This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 10%. For more information, including best practices, see: https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
        :param _builtins.str max_unavailable: The maximum number or percentage of nodes that can be simultaneously unavailable during upgrade. This can either be set to an integer (e.g. '1') or a percentage (e.g. '5%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 0. For more information, including best practices, see: https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
        :param _builtins.int node_soak_duration_in_minutes: The soak duration for a node. The amount of time (in minutes) to wait after draining a node and before reimaging it and moving on to next node. If not specified, the default is 0 minutes.
        :param _builtins.str undrainable_node_behavior: Defines the behavior for undrainable nodes during upgrade. The most common cause of undrainable nodes is Pod Disruption Budgets (PDBs), but other issues, such as pod termination grace period is exceeding the remaining per-node drain timeout or pod is still being in a running state, can also cause undrainable nodes.
        """
        if drain_timeout_in_minutes is not None:
            pulumi.set(__self__, "drain_timeout_in_minutes", drain_timeout_in_minutes)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if node_soak_duration_in_minutes is not None:
            pulumi.set(__self__, "node_soak_duration_in_minutes", node_soak_duration_in_minutes)
        if undrainable_node_behavior is not None:
            pulumi.set(__self__, "undrainable_node_behavior", undrainable_node_behavior)

    @_builtins.property
    @pulumi.getter(name="drainTimeoutInMinutes")
    def drain_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        The drain timeout for a node. The amount of time (in minutes) to wait on eviction of pods and graceful termination per node. This eviction wait time honors waiting on pod disruption budgets. If this time is exceeded, the upgrade fails. If not specified, the default is 30 minutes.
        """
        return pulumi.get(self, "drain_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.str]:
        """
        The maximum number or percentage of nodes that are surged during upgrade. This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 10%. For more information, including best practices, see: https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.str]:
        """
        The maximum number or percentage of nodes that can be simultaneously unavailable during upgrade. This can either be set to an integer (e.g. '1') or a percentage (e.g. '5%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 0. For more information, including best practices, see: https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster
        """
        return pulumi.get(self, "max_unavailable")

    @_builtins.property
    @pulumi.getter(name="nodeSoakDurationInMinutes")
    def node_soak_duration_in_minutes(self) -> Optional[_builtins.int]:
        """
        The soak duration for a node. The amount of time (in minutes) to wait after draining a node and before reimaging it and moving on to next node. If not specified, the default is 0 minutes.
        """
        return pulumi.get(self, "node_soak_duration_in_minutes")

    @_builtins.property
    @pulumi.getter(name="undrainableNodeBehavior")
    def undrainable_node_behavior(self) -> Optional[_builtins.str]:
        """
        Defines the behavior for undrainable nodes during upgrade. The most common cause of undrainable nodes is Pod Disruption Budgets (PDBs), but other issues, such as pod termination grace period is exceeding the remaining per-node drain timeout or pod is still being in a running state, can also cause undrainable nodes.
        """
        return pulumi.get(self, "undrainable_node_behavior")


@pulumi.output_type
class AgentPoolWindowsProfileResponse(dict):
    """
    The Windows agent pool's specific profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableOutboundNat":
            suggest = "disable_outbound_nat"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentPoolWindowsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentPoolWindowsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentPoolWindowsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_outbound_nat: Optional[_builtins.bool] = None):
        """
        The Windows agent pool's specific profile.
        :param _builtins.bool disable_outbound_nat: Whether to disable OutboundNAT in windows nodes. The default value is false. Outbound NAT can only be disabled if the cluster outboundType is NAT Gateway and the Windows agent pool does not have node public IP enabled.
        """
        if disable_outbound_nat is not None:
            pulumi.set(__self__, "disable_outbound_nat", disable_outbound_nat)

    @_builtins.property
    @pulumi.getter(name="disableOutboundNat")
    def disable_outbound_nat(self) -> Optional[_builtins.bool]:
        """
        Whether to disable OutboundNAT in windows nodes. The default value is false. Outbound NAT can only be disabled if the cluster outboundType is NAT Gateway and the Windows agent pool does not have node public IP enabled.
        """
        return pulumi.get(self, "disable_outbound_nat")


@pulumi.output_type
class AgentProfileResponse(dict):
    """
    Agent profile for the Fleet hub.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "vmSize":
            suggest = "vm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[_builtins.str] = None,
                 vm_size: Optional[_builtins.str] = None):
        """
        Agent profile for the Fleet hub.
        :param _builtins.str subnet_id: The ID of the subnet which the Fleet hub node will join on startup. If this is not specified, a vnet and subnet will be generated and used.
        :param _builtins.str vm_size: The virtual machine size of the Fleet hub.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet which the Fleet hub node will join on startup. If this is not specified, a vnet and subnet will be generated and used.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[_builtins.str]:
        """
        The virtual machine size of the Fleet hub.
        """
        return pulumi.get(self, "vm_size")


@pulumi.output_type
class AutoUpgradeNodeImageSelectionResponse(dict):
    """
    The node image upgrade to be applied to the target clusters in auto upgrade.
    """
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        The node image upgrade to be applied to the target clusters in auto upgrade.
        :param _builtins.str type: The node image upgrade type.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The node image upgrade type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AzureKeyVaultKmsResponse(dict):
    """
    Azure Key Vault key management service settings for the security profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"
        elif key == "keyVaultNetworkAccess":
            suggest = "key_vault_network_access"
        elif key == "keyVaultResourceId":
            suggest = "key_vault_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureKeyVaultKmsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureKeyVaultKmsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureKeyVaultKmsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 key_id: Optional[_builtins.str] = None,
                 key_vault_network_access: Optional[_builtins.str] = None,
                 key_vault_resource_id: Optional[_builtins.str] = None):
        """
        Azure Key Vault key management service settings for the security profile.
        :param _builtins.bool enabled: Whether to enable Azure Key Vault key management service. The default is false.
        :param _builtins.str key_id: Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        :param _builtins.str key_vault_network_access: Network access of the key vault. Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.
        :param _builtins.str key_vault_resource_id: Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if key_vault_network_access is None:
            key_vault_network_access = 'Public'
        if key_vault_network_access is not None:
            pulumi.set(__self__, "key_vault_network_access", key_vault_network_access)
        if key_vault_resource_id is not None:
            pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Azure Key Vault key management service. The default is false.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[_builtins.str]:
        """
        Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="keyVaultNetworkAccess")
    def key_vault_network_access(self) -> Optional[_builtins.str]:
        """
        Network access of the key vault. Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.
        """
        return pulumi.get(self, "key_vault_network_access")

    @_builtins.property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> Optional[_builtins.str]:
        """
        Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        """
        return pulumi.get(self, "key_vault_resource_id")


@pulumi.output_type
class ClusterUpgradeSettingsResponse(dict):
    """
    Settings for upgrading a cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overrideSettings":
            suggest = "override_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpgradeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpgradeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpgradeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 override_settings: Optional['outputs.UpgradeOverrideSettingsResponse'] = None):
        """
        Settings for upgrading a cluster.
        :param 'UpgradeOverrideSettingsResponse' override_settings: Settings for overrides.
        """
        if override_settings is not None:
            pulumi.set(__self__, "override_settings", override_settings)

    @_builtins.property
    @pulumi.getter(name="overrideSettings")
    def override_settings(self) -> Optional['outputs.UpgradeOverrideSettingsResponse']:
        """
        Settings for overrides.
        """
        return pulumi.get(self, "override_settings")


@pulumi.output_type
class ContainerServiceLinuxProfileResponse(dict):
    """
    Profile for Linux VMs in the container service cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerServiceLinuxProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerServiceLinuxProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerServiceLinuxProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: _builtins.str,
                 ssh: 'outputs.ContainerServiceSshConfigurationResponse'):
        """
        Profile for Linux VMs in the container service cluster.
        :param _builtins.str admin_username: The administrator username to use for Linux VMs.
        :param 'ContainerServiceSshConfigurationResponse' ssh: The SSH configuration for Linux-based VMs running on Azure.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "ssh", ssh)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> _builtins.str:
        """
        The administrator username to use for Linux VMs.
        """
        return pulumi.get(self, "admin_username")

    @_builtins.property
    @pulumi.getter
    def ssh(self) -> 'outputs.ContainerServiceSshConfigurationResponse':
        """
        The SSH configuration for Linux-based VMs running on Azure.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class ContainerServiceNetworkProfileResponse(dict):
    """
    Profile of network configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedNetworking":
            suggest = "advanced_networking"
        elif key == "dnsServiceIP":
            suggest = "dns_service_ip"
        elif key == "ipFamilies":
            suggest = "ip_families"
        elif key == "loadBalancerProfile":
            suggest = "load_balancer_profile"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "natGatewayProfile":
            suggest = "nat_gateway_profile"
        elif key == "networkDataplane":
            suggest = "network_dataplane"
        elif key == "networkMode":
            suggest = "network_mode"
        elif key == "networkPlugin":
            suggest = "network_plugin"
        elif key == "networkPluginMode":
            suggest = "network_plugin_mode"
        elif key == "networkPolicy":
            suggest = "network_policy"
        elif key == "outboundType":
            suggest = "outbound_type"
        elif key == "podCidr":
            suggest = "pod_cidr"
        elif key == "podCidrs":
            suggest = "pod_cidrs"
        elif key == "serviceCidr":
            suggest = "service_cidr"
        elif key == "serviceCidrs":
            suggest = "service_cidrs"
        elif key == "staticEgressGatewayProfile":
            suggest = "static_egress_gateway_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerServiceNetworkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerServiceNetworkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerServiceNetworkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_networking: Optional['outputs.AdvancedNetworkingResponse'] = None,
                 dns_service_ip: Optional[_builtins.str] = None,
                 ip_families: Optional[Sequence[_builtins.str]] = None,
                 load_balancer_profile: Optional['outputs.ManagedClusterLoadBalancerProfileResponse'] = None,
                 load_balancer_sku: Optional[_builtins.str] = None,
                 nat_gateway_profile: Optional['outputs.ManagedClusterNATGatewayProfileResponse'] = None,
                 network_dataplane: Optional[_builtins.str] = None,
                 network_mode: Optional[_builtins.str] = None,
                 network_plugin: Optional[_builtins.str] = None,
                 network_plugin_mode: Optional[_builtins.str] = None,
                 network_policy: Optional[_builtins.str] = None,
                 outbound_type: Optional[_builtins.str] = None,
                 pod_cidr: Optional[_builtins.str] = None,
                 pod_cidrs: Optional[Sequence[_builtins.str]] = None,
                 service_cidr: Optional[_builtins.str] = None,
                 service_cidrs: Optional[Sequence[_builtins.str]] = None,
                 static_egress_gateway_profile: Optional['outputs.ManagedClusterStaticEgressGatewayProfileResponse'] = None):
        """
        Profile of network configuration.
        :param 'AdvancedNetworkingResponse' advanced_networking: Advanced Networking profile for enabling observability and security feature suite on a cluster. For more information see aka.ms/aksadvancednetworking.
        :param _builtins.str dns_service_ip: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
        :param Sequence[_builtins.str] ip_families: The IP families used to specify IP versions available to the cluster. IP families are used to determine single-stack or dual-stack clusters. For single-stack, the expected value is IPv4. For dual-stack, the expected values are IPv4 and IPv6.
        :param 'ManagedClusterLoadBalancerProfileResponse' load_balancer_profile: Profile of the cluster load balancer.
        :param _builtins.str load_balancer_sku: The load balancer sku for the managed cluster. The default is 'standard'. See [Azure Load Balancer SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information about the differences between load balancer SKUs.
        :param 'ManagedClusterNATGatewayProfileResponse' nat_gateway_profile: Profile of the cluster NAT gateway.
        :param _builtins.str network_dataplane: Network dataplane used in the Kubernetes cluster.
        :param _builtins.str network_mode: The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other than 'azure'.
        :param _builtins.str network_plugin: Network plugin used for building the Kubernetes network.
        :param _builtins.str network_plugin_mode: The mode the network plugin should use.
        :param _builtins.str network_policy: Network policy used for building the Kubernetes network.
        :param _builtins.str outbound_type: The outbound (egress) routing method. This can only be set at cluster creation time and cannot be changed later. For more information see [egress outbound type](https://docs.microsoft.com/azure/aks/egress-outboundtype).
        :param _builtins.str pod_cidr: A CIDR notation IP range from which to assign pod IPs when kubenet is used.
        :param Sequence[_builtins.str] pod_cidrs: The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
        :param _builtins.str service_cidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
        :param Sequence[_builtins.str] service_cidrs: The CIDR notation IP ranges from which to assign service cluster IPs. One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking. They must not overlap with any Subnet IP ranges.
        :param 'ManagedClusterStaticEgressGatewayProfileResponse' static_egress_gateway_profile: The profile for Static Egress Gateway addon. For more details about Static Egress Gateway, see https://aka.ms/aks/static-egress-gateway.
        """
        if advanced_networking is not None:
            pulumi.set(__self__, "advanced_networking", advanced_networking)
        if dns_service_ip is None:
            dns_service_ip = '10.0.0.10'
        if dns_service_ip is not None:
            pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        if ip_families is not None:
            pulumi.set(__self__, "ip_families", ip_families)
        if load_balancer_profile is not None:
            pulumi.set(__self__, "load_balancer_profile", load_balancer_profile)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if nat_gateway_profile is not None:
            pulumi.set(__self__, "nat_gateway_profile", nat_gateway_profile)
        if network_dataplane is not None:
            pulumi.set(__self__, "network_dataplane", network_dataplane)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if network_plugin is not None:
            pulumi.set(__self__, "network_plugin", network_plugin)
        if network_plugin_mode is not None:
            pulumi.set(__self__, "network_plugin_mode", network_plugin_mode)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)
        if outbound_type is None:
            outbound_type = 'loadBalancer'
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)
        if pod_cidr is None:
            pod_cidr = '10.244.0.0/16'
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_cidrs is not None:
            pulumi.set(__self__, "pod_cidrs", pod_cidrs)
        if service_cidr is None:
            service_cidr = '10.0.0.0/16'
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if service_cidrs is not None:
            pulumi.set(__self__, "service_cidrs", service_cidrs)
        if static_egress_gateway_profile is not None:
            pulumi.set(__self__, "static_egress_gateway_profile", static_egress_gateway_profile)

    @_builtins.property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional['outputs.AdvancedNetworkingResponse']:
        """
        Advanced Networking profile for enabling observability and security feature suite on a cluster. For more information see aka.ms/aksadvancednetworking.
        """
        return pulumi.get(self, "advanced_networking")

    @_builtins.property
    @pulumi.getter(name="dnsServiceIP")
    def dns_service_ip(self) -> Optional[_builtins.str]:
        """
        An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
        """
        return pulumi.get(self, "dns_service_ip")

    @_builtins.property
    @pulumi.getter(name="ipFamilies")
    def ip_families(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IP families used to specify IP versions available to the cluster. IP families are used to determine single-stack or dual-stack clusters. For single-stack, the expected value is IPv4. For dual-stack, the expected values are IPv4 and IPv6.
        """
        return pulumi.get(self, "ip_families")

    @_builtins.property
    @pulumi.getter(name="loadBalancerProfile")
    def load_balancer_profile(self) -> Optional['outputs.ManagedClusterLoadBalancerProfileResponse']:
        """
        Profile of the cluster load balancer.
        """
        return pulumi.get(self, "load_balancer_profile")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[_builtins.str]:
        """
        The load balancer sku for the managed cluster. The default is 'standard'. See [Azure Load Balancer SKUs](https://docs.microsoft.com/azure/load-balancer/skus) for more information about the differences between load balancer SKUs.
        """
        return pulumi.get(self, "load_balancer_sku")

    @_builtins.property
    @pulumi.getter(name="natGatewayProfile")
    def nat_gateway_profile(self) -> Optional['outputs.ManagedClusterNATGatewayProfileResponse']:
        """
        Profile of the cluster NAT gateway.
        """
        return pulumi.get(self, "nat_gateway_profile")

    @_builtins.property
    @pulumi.getter(name="networkDataplane")
    def network_dataplane(self) -> Optional[_builtins.str]:
        """
        Network dataplane used in the Kubernetes cluster.
        """
        return pulumi.get(self, "network_dataplane")

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[_builtins.str]:
        """
        The network mode Azure CNI is configured with. This cannot be specified if networkPlugin is anything other than 'azure'.
        """
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> Optional[_builtins.str]:
        """
        Network plugin used for building the Kubernetes network.
        """
        return pulumi.get(self, "network_plugin")

    @_builtins.property
    @pulumi.getter(name="networkPluginMode")
    def network_plugin_mode(self) -> Optional[_builtins.str]:
        """
        The mode the network plugin should use.
        """
        return pulumi.get(self, "network_plugin_mode")

    @_builtins.property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional[_builtins.str]:
        """
        Network policy used for building the Kubernetes network.
        """
        return pulumi.get(self, "network_policy")

    @_builtins.property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[_builtins.str]:
        """
        The outbound (egress) routing method. This can only be set at cluster creation time and cannot be changed later. For more information see [egress outbound type](https://docs.microsoft.com/azure/aks/egress-outboundtype).
        """
        return pulumi.get(self, "outbound_type")

    @_builtins.property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[_builtins.str]:
        """
        A CIDR notation IP range from which to assign pod IPs when kubenet is used.
        """
        return pulumi.get(self, "pod_cidr")

    @_builtins.property
    @pulumi.getter(name="podCidrs")
    def pod_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The CIDR notation IP ranges from which to assign pod IPs. One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
        """
        return pulumi.get(self, "pod_cidrs")

    @_builtins.property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[_builtins.str]:
        """
        A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
        """
        return pulumi.get(self, "service_cidr")

    @_builtins.property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The CIDR notation IP ranges from which to assign service cluster IPs. One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking. They must not overlap with any Subnet IP ranges.
        """
        return pulumi.get(self, "service_cidrs")

    @_builtins.property
    @pulumi.getter(name="staticEgressGatewayProfile")
    def static_egress_gateway_profile(self) -> Optional['outputs.ManagedClusterStaticEgressGatewayProfileResponse']:
        """
        The profile for Static Egress Gateway addon. For more details about Static Egress Gateway, see https://aka.ms/aks/static-egress-gateway.
        """
        return pulumi.get(self, "static_egress_gateway_profile")


@pulumi.output_type
class ContainerServiceSshConfigurationResponse(dict):
    """
    SSH configuration for Linux-based VMs running on Azure.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKeys":
            suggest = "public_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerServiceSshConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerServiceSshConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerServiceSshConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_keys: Sequence['outputs.ContainerServiceSshPublicKeyResponse']):
        """
        SSH configuration for Linux-based VMs running on Azure.
        :param Sequence['ContainerServiceSshPublicKeyResponse'] public_keys: The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        """
        pulumi.set(__self__, "public_keys", public_keys)

    @_builtins.property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Sequence['outputs.ContainerServiceSshPublicKeyResponse']:
        """
        The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        """
        return pulumi.get(self, "public_keys")


@pulumi.output_type
class ContainerServiceSshPublicKeyResponse(dict):
    """
    Contains information about SSH certificate public key data.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyData":
            suggest = "key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerServiceSshPublicKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerServiceSshPublicKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerServiceSshPublicKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_data: _builtins.str):
        """
        Contains information about SSH certificate public key data.
        :param _builtins.str key_data: Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers.
        """
        pulumi.set(__self__, "key_data", key_data)

    @_builtins.property
    @pulumi.getter(name="keyData")
    def key_data(self) -> _builtins.str:
        """
        Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers.
        """
        return pulumi.get(self, "key_data")


@pulumi.output_type
class CreationDataResponse(dict):
    """
    Data used when creating a target resource from a source resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceResourceId":
            suggest = "source_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CreationDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CreationDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CreationDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_resource_id: Optional[_builtins.str] = None):
        """
        Data used when creating a target resource from a source resource.
        :param _builtins.str source_resource_id: This is the ARM ID of the source object to be used to create the target object.
        """
        if source_resource_id is not None:
            pulumi.set(__self__, "source_resource_id", source_resource_id)

    @_builtins.property
    @pulumi.getter(name="sourceResourceId")
    def source_resource_id(self) -> Optional[_builtins.str]:
        """
        This is the ARM ID of the source object to be used to create the target object.
        """
        return pulumi.get(self, "source_resource_id")


@pulumi.output_type
class CredentialResultResponse(dict):
    """
    The credential result response.
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        The credential result response.
        :param _builtins.str name: The name of the credential.
        :param _builtins.str value: Base64-encoded Kubernetes configuration file.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Base64-encoded Kubernetes configuration file.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DailyScheduleResponse(dict):
    """
    For schedules like: 'recur every day' or 'recur every 3 days'.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalDays":
            suggest = "interval_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DailyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DailyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DailyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_days: _builtins.int):
        """
        For schedules like: 'recur every day' or 'recur every 3 days'.
        :param _builtins.int interval_days: Specifies the number of days between each set of occurrences.
        """
        pulumi.set(__self__, "interval_days", interval_days)

    @_builtins.property
    @pulumi.getter(name="intervalDays")
    def interval_days(self) -> _builtins.int:
        """
        Specifies the number of days between each set of occurrences.
        """
        return pulumi.get(self, "interval_days")


@pulumi.output_type
class DateSpanResponse(dict):
    """
    A date range. For example, between '2022-12-23' and '2023-01-05'.
    """
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        """
        A date range. For example, between '2022-12-23' and '2023-01-05'.
        :param _builtins.str end: The end date of the date span.
        :param _builtins.str start: The start date of the date span.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        """
        The end date of the date span.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        The start date of the date span.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class DelegatedResourceResponse(dict):
    """
    Delegated resource properties - internal use only.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referralResource":
            suggest = "referral_resource"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DelegatedResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DelegatedResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DelegatedResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: Optional[_builtins.str] = None,
                 referral_resource: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        Delegated resource properties - internal use only.
        :param _builtins.str location: The source resource location - internal use only.
        :param _builtins.str referral_resource: The delegation id of the referral delegation (optional) - internal use only.
        :param _builtins.str resource_id: The ARM resource id of the delegated resource - internal use only.
        :param _builtins.str tenant_id: The tenant id of the delegated resource - internal use only.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if referral_resource is not None:
            pulumi.set(__self__, "referral_resource", referral_resource)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        The source resource location - internal use only.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="referralResource")
    def referral_resource(self) -> Optional[_builtins.str]:
        """
        The delegation id of the referral delegation (optional) - internal use only.
        """
        return pulumi.get(self, "referral_resource")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        The ARM resource id of the delegated resource - internal use only.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The tenant id of the delegated resource - internal use only.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ErrorAdditionalInfoResponse(dict):
    """
    The resource management error additional info.
    """
    def __init__(__self__, *,
                 info: Any,
                 type: _builtins.str):
        """
        The resource management error additional info.
        :param Any info: The additional info.
        :param _builtins.str type: The additional info type.
        """
        pulumi.set(__self__, "info", info)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def info(self) -> Any:
        """
        The additional info.
        """
        return pulumi.get(self, "info")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The additional info type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ErrorDetailResponse(dict):
    """
    The error detail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInfo":
            suggest = "additional_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ErrorDetailResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_info: Sequence['outputs.ErrorAdditionalInfoResponse'],
                 code: _builtins.str,
                 details: Sequence['outputs.ErrorDetailResponse'],
                 message: _builtins.str,
                 target: _builtins.str):
        """
        The error detail.
        :param Sequence['ErrorAdditionalInfoResponse'] additional_info: The error additional info.
        :param _builtins.str code: The error code.
        :param Sequence['ErrorDetailResponse'] details: The error details.
        :param _builtins.str message: The error message.
        :param _builtins.str target: The error target.
        """
        pulumi.set(__self__, "additional_info", additional_info)
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Sequence['outputs.ErrorAdditionalInfoResponse']:
        """
        The error additional info.
        """
        return pulumi.get(self, "additional_info")

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailResponse']:
        """
        The error details.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The error message.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    """
    The complex type of the extended location.
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        The complex type of the extended location.
        :param _builtins.str name: The name of the extended location.
        :param _builtins.str type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FleetCredentialResultResponse(dict):
    """
    One credential result item.
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        One credential result item.
        :param _builtins.str name: The name of the credential.
        :param _builtins.str value: Base64-encoded Kubernetes configuration file.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the credential.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Base64-encoded Kubernetes configuration file.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FleetHubProfileResponse(dict):
    """
    The FleetHubProfile configures the fleet hub.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubernetesVersion":
            suggest = "kubernetes_version"
        elif key == "portalFqdn":
            suggest = "portal_fqdn"
        elif key == "agentProfile":
            suggest = "agent_profile"
        elif key == "apiServerAccessProfile":
            suggest = "api_server_access_profile"
        elif key == "dnsPrefix":
            suggest = "dns_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetHubProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetHubProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetHubProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 kubernetes_version: _builtins.str,
                 portal_fqdn: _builtins.str,
                 agent_profile: Optional['outputs.AgentProfileResponse'] = None,
                 api_server_access_profile: Optional['outputs.APIServerAccessProfileResponse'] = None,
                 dns_prefix: Optional[_builtins.str] = None):
        """
        The FleetHubProfile configures the fleet hub.
        :param _builtins.str fqdn: The FQDN of the Fleet hub.
        :param _builtins.str kubernetes_version: The Kubernetes version of the Fleet hub.
        :param _builtins.str portal_fqdn: The Azure Portal FQDN of the Fleet hub.
        :param 'AgentProfileResponse' agent_profile: The agent profile for the Fleet hub.
        :param 'APIServerAccessProfileResponse' api_server_access_profile: The access profile for the Fleet hub API server.
        :param _builtins.str dns_prefix: DNS prefix used to create the FQDN for the Fleet hub.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "portal_fqdn", portal_fqdn)
        if agent_profile is not None:
            pulumi.set(__self__, "agent_profile", agent_profile)
        if api_server_access_profile is not None:
            pulumi.set(__self__, "api_server_access_profile", api_server_access_profile)
        if dns_prefix is not None:
            pulumi.set(__self__, "dns_prefix", dns_prefix)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        The FQDN of the Fleet hub.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> _builtins.str:
        """
        The Kubernetes version of the Fleet hub.
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter(name="portalFqdn")
    def portal_fqdn(self) -> _builtins.str:
        """
        The Azure Portal FQDN of the Fleet hub.
        """
        return pulumi.get(self, "portal_fqdn")

    @_builtins.property
    @pulumi.getter(name="agentProfile")
    def agent_profile(self) -> Optional['outputs.AgentProfileResponse']:
        """
        The agent profile for the Fleet hub.
        """
        return pulumi.get(self, "agent_profile")

    @_builtins.property
    @pulumi.getter(name="apiServerAccessProfile")
    def api_server_access_profile(self) -> Optional['outputs.APIServerAccessProfileResponse']:
        """
        The access profile for the Fleet hub API server.
        """
        return pulumi.get(self, "api_server_access_profile")

    @_builtins.property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> Optional[_builtins.str]:
        """
        DNS prefix used to create the FQDN for the Fleet hub.
        """
        return pulumi.get(self, "dns_prefix")


@pulumi.output_type
class GPUProfileResponse(dict):
    """
    GPU settings for the Agent Pool.
    """
    def __init__(__self__, *,
                 driver: Optional[_builtins.str] = None):
        """
        GPU settings for the Agent Pool.
        :param _builtins.str driver: Whether to install GPU drivers. When it's not specified, default is Install.
        """
        if driver is not None:
            pulumi.set(__self__, "driver", driver)

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[_builtins.str]:
        """
        Whether to install GPU drivers. When it's not specified, default is Install.
        """
        return pulumi.get(self, "driver")


@pulumi.output_type
class IPTagResponse(dict):
    """
    Contains the IPTag associated with the object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipTagType":
            suggest = "ip_tag_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IPTagResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IPTagResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IPTagResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_tag_type: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        Contains the IPTag associated with the object.
        :param _builtins.str ip_tag_type: The IP tag type. Example: RoutingPreference.
        :param _builtins.str tag: The value of the IP tag associated with the public IP. Example: Internet.
        """
        if ip_tag_type is not None:
            pulumi.set(__self__, "ip_tag_type", ip_tag_type)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="ipTagType")
    def ip_tag_type(self) -> Optional[_builtins.str]:
        """
        The IP tag type. Example: RoutingPreference.
        """
        return pulumi.get(self, "ip_tag_type")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        The value of the IP tag associated with the public IP. Example: Internet.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class IdentityBindingManagedIdentityProfileResponse(dict):
    """
    Managed identity profile for the identity binding.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityBindingManagedIdentityProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityBindingManagedIdentityProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityBindingManagedIdentityProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 object_id: _builtins.str,
                 resource_id: _builtins.str,
                 tenant_id: _builtins.str):
        """
        Managed identity profile for the identity binding.
        :param _builtins.str client_id: The client ID of the managed identity.
        :param _builtins.str object_id: The object ID of the managed identity.
        :param _builtins.str resource_id: The resource ID of the managed identity.
        :param _builtins.str tenant_id: The tenant ID of the managed identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the managed identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> _builtins.str:
        """
        The object ID of the managed identity.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The resource ID of the managed identity.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the managed identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class IdentityBindingOidcIssuerProfileResponse(dict):
    """
    IdentityBinding OIDC issuer profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oidcIssuerUrl":
            suggest = "oidc_issuer_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityBindingOidcIssuerProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityBindingOidcIssuerProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityBindingOidcIssuerProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oidc_issuer_url: _builtins.str):
        """
        IdentityBinding OIDC issuer profile.
        :param _builtins.str oidc_issuer_url: The OIDC issuer URL of the IdentityBinding.
        """
        pulumi.set(__self__, "oidc_issuer_url", oidc_issuer_url)

    @_builtins.property
    @pulumi.getter(name="oidcIssuerUrl")
    def oidc_issuer_url(self) -> _builtins.str:
        """
        The OIDC issuer URL of the IdentityBinding.
        """
        return pulumi.get(self, "oidc_issuer_url")


@pulumi.output_type
class IdentityBindingPropertiesResponse(dict):
    """
    IdentityBinding properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedIdentity":
            suggest = "managed_identity"
        elif key == "oidcIssuer":
            suggest = "oidc_issuer"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityBindingPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityBindingPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityBindingPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_identity: 'outputs.IdentityBindingManagedIdentityProfileResponse',
                 oidc_issuer: 'outputs.IdentityBindingOidcIssuerProfileResponse',
                 provisioning_state: _builtins.str):
        """
        IdentityBinding properties.
        :param 'IdentityBindingManagedIdentityProfileResponse' managed_identity: Managed identity profile for the identity binding.
        :param 'IdentityBindingOidcIssuerProfileResponse' oidc_issuer: The OIDC issuer URL of the IdentityBinding.
        :param _builtins.str provisioning_state: The status of the last operation.
        """
        pulumi.set(__self__, "managed_identity", managed_identity)
        pulumi.set(__self__, "oidc_issuer", oidc_issuer)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @_builtins.property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> 'outputs.IdentityBindingManagedIdentityProfileResponse':
        """
        Managed identity profile for the identity binding.
        """
        return pulumi.get(self, "managed_identity")

    @_builtins.property
    @pulumi.getter(name="oidcIssuer")
    def oidc_issuer(self) -> 'outputs.IdentityBindingOidcIssuerProfileResponse':
        """
        The OIDC issuer URL of the IdentityBinding.
        """
        return pulumi.get(self, "oidc_issuer")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class IstioCertificateAuthorityResponse(dict):
    """
    Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin certificates as described here https://aka.ms/asm-plugin-ca
    """
    def __init__(__self__, *,
                 plugin: Optional['outputs.IstioPluginCertificateAuthorityResponse'] = None):
        """
        Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin certificates as described here https://aka.ms/asm-plugin-ca
        :param 'IstioPluginCertificateAuthorityResponse' plugin: Plugin certificates information for Service Mesh.
        """
        if plugin is not None:
            pulumi.set(__self__, "plugin", plugin)

    @_builtins.property
    @pulumi.getter
    def plugin(self) -> Optional['outputs.IstioPluginCertificateAuthorityResponse']:
        """
        Plugin certificates information for Service Mesh.
        """
        return pulumi.get(self, "plugin")


@pulumi.output_type
class IstioComponentsResponse(dict):
    """
    Istio components configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "egressGateways":
            suggest = "egress_gateways"
        elif key == "ingressGateways":
            suggest = "ingress_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IstioComponentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IstioComponentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IstioComponentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 egress_gateways: Optional[Sequence['outputs.IstioEgressGatewayResponse']] = None,
                 ingress_gateways: Optional[Sequence['outputs.IstioIngressGatewayResponse']] = None):
        """
        Istio components configuration.
        :param Sequence['IstioEgressGatewayResponse'] egress_gateways: Istio egress gateways.
        :param Sequence['IstioIngressGatewayResponse'] ingress_gateways: Istio ingress gateways.
        """
        if egress_gateways is not None:
            pulumi.set(__self__, "egress_gateways", egress_gateways)
        if ingress_gateways is not None:
            pulumi.set(__self__, "ingress_gateways", ingress_gateways)

    @_builtins.property
    @pulumi.getter(name="egressGateways")
    def egress_gateways(self) -> Optional[Sequence['outputs.IstioEgressGatewayResponse']]:
        """
        Istio egress gateways.
        """
        return pulumi.get(self, "egress_gateways")

    @_builtins.property
    @pulumi.getter(name="ingressGateways")
    def ingress_gateways(self) -> Optional[Sequence['outputs.IstioIngressGatewayResponse']]:
        """
        Istio ingress gateways.
        """
        return pulumi.get(self, "ingress_gateways")


@pulumi.output_type
class IstioEgressGatewayResponse(dict):
    """
    Istio egress gateway configuration.
    """
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        Istio egress gateway configuration.
        :param _builtins.bool enabled: Whether to enable the egress gateway.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable the egress gateway.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class IstioIngressGatewayResponse(dict):
    """
    Istio ingress gateway configuration. For now, we support up to one external ingress gateway named `aks-istio-ingressgateway-external` and one internal ingress gateway named `aks-istio-ingressgateway-internal`.
    """
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 mode: _builtins.str):
        """
        Istio ingress gateway configuration. For now, we support up to one external ingress gateway named `aks-istio-ingressgateway-external` and one internal ingress gateway named `aks-istio-ingressgateway-internal`.
        :param _builtins.bool enabled: Whether to enable the ingress gateway.
        :param _builtins.str mode: Mode of an ingress gateway.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable the ingress gateway.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mode of an ingress gateway.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class IstioPluginCertificateAuthorityResponse(dict):
    """
    Plugin certificates information for Service Mesh.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certChainObjectName":
            suggest = "cert_chain_object_name"
        elif key == "certObjectName":
            suggest = "cert_object_name"
        elif key == "keyObjectName":
            suggest = "key_object_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "rootCertObjectName":
            suggest = "root_cert_object_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IstioPluginCertificateAuthorityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IstioPluginCertificateAuthorityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IstioPluginCertificateAuthorityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_chain_object_name: Optional[_builtins.str] = None,
                 cert_object_name: Optional[_builtins.str] = None,
                 key_object_name: Optional[_builtins.str] = None,
                 key_vault_id: Optional[_builtins.str] = None,
                 root_cert_object_name: Optional[_builtins.str] = None):
        """
        Plugin certificates information for Service Mesh.
        :param _builtins.str cert_chain_object_name: Certificate chain object name in Azure Key Vault.
        :param _builtins.str cert_object_name: Intermediate certificate object name in Azure Key Vault.
        :param _builtins.str key_object_name: Intermediate certificate private key object name in Azure Key Vault.
        :param _builtins.str key_vault_id: The resource ID of the Key Vault.
        :param _builtins.str root_cert_object_name: Root certificate object name in Azure Key Vault.
        """
        if cert_chain_object_name is not None:
            pulumi.set(__self__, "cert_chain_object_name", cert_chain_object_name)
        if cert_object_name is not None:
            pulumi.set(__self__, "cert_object_name", cert_object_name)
        if key_object_name is not None:
            pulumi.set(__self__, "key_object_name", key_object_name)
        if key_vault_id is not None:
            pulumi.set(__self__, "key_vault_id", key_vault_id)
        if root_cert_object_name is not None:
            pulumi.set(__self__, "root_cert_object_name", root_cert_object_name)

    @_builtins.property
    @pulumi.getter(name="certChainObjectName")
    def cert_chain_object_name(self) -> Optional[_builtins.str]:
        """
        Certificate chain object name in Azure Key Vault.
        """
        return pulumi.get(self, "cert_chain_object_name")

    @_builtins.property
    @pulumi.getter(name="certObjectName")
    def cert_object_name(self) -> Optional[_builtins.str]:
        """
        Intermediate certificate object name in Azure Key Vault.
        """
        return pulumi.get(self, "cert_object_name")

    @_builtins.property
    @pulumi.getter(name="keyObjectName")
    def key_object_name(self) -> Optional[_builtins.str]:
        """
        Intermediate certificate private key object name in Azure Key Vault.
        """
        return pulumi.get(self, "key_object_name")

    @_builtins.property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[_builtins.str]:
        """
        The resource ID of the Key Vault.
        """
        return pulumi.get(self, "key_vault_id")

    @_builtins.property
    @pulumi.getter(name="rootCertObjectName")
    def root_cert_object_name(self) -> Optional[_builtins.str]:
        """
        Root certificate object name in Azure Key Vault.
        """
        return pulumi.get(self, "root_cert_object_name")


@pulumi.output_type
class IstioServiceMeshResponse(dict):
    """
    Istio service mesh configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthority":
            suggest = "certificate_authority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IstioServiceMeshResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IstioServiceMeshResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IstioServiceMeshResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority: Optional['outputs.IstioCertificateAuthorityResponse'] = None,
                 components: Optional['outputs.IstioComponentsResponse'] = None,
                 revisions: Optional[Sequence[_builtins.str]] = None):
        """
        Istio service mesh configuration.
        :param 'IstioCertificateAuthorityResponse' certificate_authority: Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin certificates as described here https://aka.ms/asm-plugin-ca
        :param 'IstioComponentsResponse' components: Istio components configuration.
        :param Sequence[_builtins.str] revisions: The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary upgrade is in progress, this can only hold two consecutive values. For more information, see: https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
        """
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if revisions is not None:
            pulumi.set(__self__, "revisions", revisions)

    @_builtins.property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional['outputs.IstioCertificateAuthorityResponse']:
        """
        Istio Service Mesh Certificate Authority (CA) configuration. For now, we only support plugin certificates as described here https://aka.ms/asm-plugin-ca
        """
        return pulumi.get(self, "certificate_authority")

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional['outputs.IstioComponentsResponse']:
        """
        Istio components configuration.
        """
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter
    def revisions(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of revisions of the Istio control plane. When an upgrade is not in progress, this holds one value. When canary upgrade is in progress, this can only hold two consecutive values. For more information, see: https://learn.microsoft.com/en-us/azure/aks/istio-upgrade
        """
        return pulumi.get(self, "revisions")


@pulumi.output_type
class JWTAuthenticatorClaimMappingExpressionResponse(dict):
    """
    The claim mapping expression for JWTAuthenticator.
    """
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        The claim mapping expression for JWTAuthenticator.
        :param _builtins.str expression: The CEL expression used to access token claims.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        The CEL expression used to access token claims.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class JWTAuthenticatorClaimMappingsResponse(dict):
    """
    The claim mappings for JWTAuthenticator.
    """
    def __init__(__self__, *,
                 username: 'outputs.JWTAuthenticatorClaimMappingExpressionResponse',
                 extra: Optional[Sequence['outputs.JWTAuthenticatorExtraClaimMappingExpressionResponse']] = None,
                 groups: Optional['outputs.JWTAuthenticatorClaimMappingExpressionResponse'] = None,
                 uid: Optional['outputs.JWTAuthenticatorClaimMappingExpressionResponse'] = None):
        """
        The claim mappings for JWTAuthenticator.
        :param 'JWTAuthenticatorClaimMappingExpressionResponse' username: The expression to extract username attribute from the token claims.
        :param Sequence['JWTAuthenticatorExtraClaimMappingExpressionResponse'] extra: The expression to extract extra attribute from the token claims. When not provided, no extra attributes are extracted from the token claims.
        :param 'JWTAuthenticatorClaimMappingExpressionResponse' groups: The expression to extract groups attribute from the token claims. When not provided, no groups are extracted from the token claims.
        :param 'JWTAuthenticatorClaimMappingExpressionResponse' uid: The expression to extract uid attribute from the token claims. When not provided, no uid is extracted from the token claims.
        """
        pulumi.set(__self__, "username", username)
        if extra is not None:
            pulumi.set(__self__, "extra", extra)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def username(self) -> 'outputs.JWTAuthenticatorClaimMappingExpressionResponse':
        """
        The expression to extract username attribute from the token claims.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def extra(self) -> Optional[Sequence['outputs.JWTAuthenticatorExtraClaimMappingExpressionResponse']]:
        """
        The expression to extract extra attribute from the token claims. When not provided, no extra attributes are extracted from the token claims.
        """
        return pulumi.get(self, "extra")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional['outputs.JWTAuthenticatorClaimMappingExpressionResponse']:
        """
        The expression to extract groups attribute from the token claims. When not provided, no groups are extracted from the token claims.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional['outputs.JWTAuthenticatorClaimMappingExpressionResponse']:
        """
        The expression to extract uid attribute from the token claims. When not provided, no uid is extracted from the token claims.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class JWTAuthenticatorExtraClaimMappingExpressionResponse(dict):
    """
    The extra claim mapping expression for JWTAuthenticator.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueExpression":
            suggest = "value_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JWTAuthenticatorExtraClaimMappingExpressionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JWTAuthenticatorExtraClaimMappingExpressionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JWTAuthenticatorExtraClaimMappingExpressionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 value_expression: _builtins.str):
        """
        The extra claim mapping expression for JWTAuthenticator.
        :param _builtins.str key: The key of the extra attribute.
        :param _builtins.str value_expression: The CEL expression used to extract the value of the extra attribute.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value_expression", value_expression)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the extra attribute.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="valueExpression")
    def value_expression(self) -> _builtins.str:
        """
        The CEL expression used to extract the value of the extra attribute.
        """
        return pulumi.get(self, "value_expression")


@pulumi.output_type
class JWTAuthenticatorIssuerResponse(dict):
    """
    The OIDC issuer details for JWTAuthenticator.
    """
    def __init__(__self__, *,
                 audiences: Sequence[_builtins.str],
                 url: _builtins.str):
        """
        The OIDC issuer details for JWTAuthenticator.
        :param Sequence[_builtins.str] audiences: The set of acceptable audiences the JWT must be issued to. At least one is required. When multiple is set, AudienceMatchPolicy is used in API Server configuration.
        :param _builtins.str url: The issuer URL. The URL must begin with the scheme https and cannot contain a query string or fragment. This must match the "iss" claim in the presented JWT, and the issuer returned from discovery.
        """
        pulumi.set(__self__, "audiences", audiences)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Sequence[_builtins.str]:
        """
        The set of acceptable audiences the JWT must be issued to. At least one is required. When multiple is set, AudienceMatchPolicy is used in API Server configuration.
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The issuer URL. The URL must begin with the scheme https and cannot contain a query string or fragment. This must match the "iss" claim in the presented JWT, and the issuer returned from discovery.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class JWTAuthenticatorPropertiesResponse(dict):
    """
    The properties of JWTAuthenticator. For details on how to configure the properties of a JWT authenticator, please refer to the Kubernetes documentation: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration. Please note that not all fields available in the Kubernetes documentation are supported by AKS. For troubleshooting, please see https://aka.ms/aks-external-issuers-docs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "claimMappings":
            suggest = "claim_mappings"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "claimValidationRules":
            suggest = "claim_validation_rules"
        elif key == "userValidationRules":
            suggest = "user_validation_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JWTAuthenticatorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JWTAuthenticatorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JWTAuthenticatorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 claim_mappings: 'outputs.JWTAuthenticatorClaimMappingsResponse',
                 issuer: 'outputs.JWTAuthenticatorIssuerResponse',
                 provisioning_state: _builtins.str,
                 claim_validation_rules: Optional[Sequence['outputs.JWTAuthenticatorValidationRuleResponse']] = None,
                 user_validation_rules: Optional[Sequence['outputs.JWTAuthenticatorValidationRuleResponse']] = None):
        """
        The properties of JWTAuthenticator. For details on how to configure the properties of a JWT authenticator, please refer to the Kubernetes documentation: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#using-authentication-configuration. Please note that not all fields available in the Kubernetes documentation are supported by AKS. For troubleshooting, please see https://aka.ms/aks-external-issuers-docs.
        :param 'JWTAuthenticatorClaimMappingsResponse' claim_mappings: The mappings that define how user attributes are extracted from the token claims.
        :param 'JWTAuthenticatorIssuerResponse' issuer: The JWT OIDC issuer details.
        :param _builtins.str provisioning_state: The current provisioning state of the JWT authenticator.
        :param Sequence['JWTAuthenticatorValidationRuleResponse'] claim_validation_rules: The rules that are applied to validate token claims to authenticate users. All the expressions must evaluate to true for validation to succeed.
        :param Sequence['JWTAuthenticatorValidationRuleResponse'] user_validation_rules: The rules that are applied to the mapped user before completing authentication. All the expressions must evaluate to true for validation to succeed.
        """
        pulumi.set(__self__, "claim_mappings", claim_mappings)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if claim_validation_rules is not None:
            pulumi.set(__self__, "claim_validation_rules", claim_validation_rules)
        if user_validation_rules is not None:
            pulumi.set(__self__, "user_validation_rules", user_validation_rules)

    @_builtins.property
    @pulumi.getter(name="claimMappings")
    def claim_mappings(self) -> 'outputs.JWTAuthenticatorClaimMappingsResponse':
        """
        The mappings that define how user attributes are extracted from the token claims.
        """
        return pulumi.get(self, "claim_mappings")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> 'outputs.JWTAuthenticatorIssuerResponse':
        """
        The JWT OIDC issuer details.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The current provisioning state of the JWT authenticator.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="claimValidationRules")
    def claim_validation_rules(self) -> Optional[Sequence['outputs.JWTAuthenticatorValidationRuleResponse']]:
        """
        The rules that are applied to validate token claims to authenticate users. All the expressions must evaluate to true for validation to succeed.
        """
        return pulumi.get(self, "claim_validation_rules")

    @_builtins.property
    @pulumi.getter(name="userValidationRules")
    def user_validation_rules(self) -> Optional[Sequence['outputs.JWTAuthenticatorValidationRuleResponse']]:
        """
        The rules that are applied to the mapped user before completing authentication. All the expressions must evaluate to true for validation to succeed.
        """
        return pulumi.get(self, "user_validation_rules")


@pulumi.output_type
class JWTAuthenticatorValidationRuleResponse(dict):
    """
    The validation rule for JWTAuthenticator.
    """
    def __init__(__self__, *,
                 expression: _builtins.str,
                 message: Optional[_builtins.str] = None):
        """
        The validation rule for JWTAuthenticator.
        :param _builtins.str expression: The CEL expression used to validate the claim or attribute.
        :param _builtins.str message: The validation error message.
        """
        pulumi.set(__self__, "expression", expression)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        The CEL expression used to validate the claim or attribute.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The validation error message.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class KubeletConfigResponse(dict):
    """
    Kubelet configurations of agent nodes. See [AKS custom node configuration](https://docs.microsoft.com/azure/aks/custom-node-configuration) for more details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedUnsafeSysctls":
            suggest = "allowed_unsafe_sysctls"
        elif key == "containerLogMaxFiles":
            suggest = "container_log_max_files"
        elif key == "containerLogMaxSizeMB":
            suggest = "container_log_max_size_mb"
        elif key == "cpuCfsQuota":
            suggest = "cpu_cfs_quota"
        elif key == "cpuCfsQuotaPeriod":
            suggest = "cpu_cfs_quota_period"
        elif key == "cpuManagerPolicy":
            suggest = "cpu_manager_policy"
        elif key == "failSwapOn":
            suggest = "fail_swap_on"
        elif key == "imageGcHighThreshold":
            suggest = "image_gc_high_threshold"
        elif key == "imageGcLowThreshold":
            suggest = "image_gc_low_threshold"
        elif key == "podMaxPids":
            suggest = "pod_max_pids"
        elif key == "topologyManagerPolicy":
            suggest = "topology_manager_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubeletConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubeletConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubeletConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_unsafe_sysctls: Optional[Sequence[_builtins.str]] = None,
                 container_log_max_files: Optional[_builtins.int] = None,
                 container_log_max_size_mb: Optional[_builtins.int] = None,
                 cpu_cfs_quota: Optional[_builtins.bool] = None,
                 cpu_cfs_quota_period: Optional[_builtins.str] = None,
                 cpu_manager_policy: Optional[_builtins.str] = None,
                 fail_swap_on: Optional[_builtins.bool] = None,
                 image_gc_high_threshold: Optional[_builtins.int] = None,
                 image_gc_low_threshold: Optional[_builtins.int] = None,
                 pod_max_pids: Optional[_builtins.int] = None,
                 topology_manager_policy: Optional[_builtins.str] = None):
        """
        Kubelet configurations of agent nodes. See [AKS custom node configuration](https://docs.microsoft.com/azure/aks/custom-node-configuration) for more details.
        :param Sequence[_builtins.str] allowed_unsafe_sysctls: Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in `*`).
        :param _builtins.int container_log_max_files: The maximum number of container log files that can be present for a container. The number must be  2.
        :param _builtins.int container_log_max_size_mb: The maximum size (e.g. 10Mi) of container log file before it is rotated.
        :param _builtins.bool cpu_cfs_quota: If CPU CFS quota enforcement is enabled for containers that specify CPU limits. The default is true.
        :param _builtins.str cpu_cfs_quota_period: The CPU CFS quota period value. The default is '100ms.' Valid values are a sequence of decimal numbers with an optional fraction and a unit suffix. For example: '300ms', '2h45m'. Supported units are 'ns', 'us', 'ms', 's', 'm', and 'h'.
        :param _builtins.str cpu_manager_policy: The CPU Manager policy to use. The default is 'none'. See [Kubernetes CPU management policies](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#cpu-management-policies) for more information. Allowed values are 'none' and 'static'.
        :param _builtins.bool fail_swap_on: If set to true it will make the Kubelet fail to start if swap is enabled on the node.
        :param _builtins.int image_gc_high_threshold: The percent of disk usage after which image garbage collection is always run. To disable image garbage collection, set to 100. The default is 85%
        :param _builtins.int image_gc_low_threshold: The percent of disk usage before which image garbage collection is never run. This cannot be set higher than imageGcHighThreshold. The default is 80%
        :param _builtins.int pod_max_pids: The maximum number of processes per pod.
        :param _builtins.str topology_manager_policy: The Topology Manager policy to use. For more information see [Kubernetes Topology Manager](https://kubernetes.io/docs/tasks/administer-cluster/topology-manager). The default is 'none'. Allowed values are 'none', 'best-effort', 'restricted', and 'single-numa-node'.
        """
        if allowed_unsafe_sysctls is not None:
            pulumi.set(__self__, "allowed_unsafe_sysctls", allowed_unsafe_sysctls)
        if container_log_max_files is not None:
            pulumi.set(__self__, "container_log_max_files", container_log_max_files)
        if container_log_max_size_mb is not None:
            pulumi.set(__self__, "container_log_max_size_mb", container_log_max_size_mb)
        if cpu_cfs_quota is not None:
            pulumi.set(__self__, "cpu_cfs_quota", cpu_cfs_quota)
        if cpu_cfs_quota_period is not None:
            pulumi.set(__self__, "cpu_cfs_quota_period", cpu_cfs_quota_period)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if fail_swap_on is not None:
            pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        if image_gc_high_threshold is not None:
            pulumi.set(__self__, "image_gc_high_threshold", image_gc_high_threshold)
        if image_gc_low_threshold is not None:
            pulumi.set(__self__, "image_gc_low_threshold", image_gc_low_threshold)
        if pod_max_pids is not None:
            pulumi.set(__self__, "pod_max_pids", pod_max_pids)
        if topology_manager_policy is not None:
            pulumi.set(__self__, "topology_manager_policy", topology_manager_policy)

    @_builtins.property
    @pulumi.getter(name="allowedUnsafeSysctls")
    def allowed_unsafe_sysctls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in `*`).
        """
        return pulumi.get(self, "allowed_unsafe_sysctls")

    @_builtins.property
    @pulumi.getter(name="containerLogMaxFiles")
    def container_log_max_files(self) -> Optional[_builtins.int]:
        """
        The maximum number of container log files that can be present for a container. The number must be  2.
        """
        return pulumi.get(self, "container_log_max_files")

    @_builtins.property
    @pulumi.getter(name="containerLogMaxSizeMB")
    def container_log_max_size_mb(self) -> Optional[_builtins.int]:
        """
        The maximum size (e.g. 10Mi) of container log file before it is rotated.
        """
        return pulumi.get(self, "container_log_max_size_mb")

    @_builtins.property
    @pulumi.getter(name="cpuCfsQuota")
    def cpu_cfs_quota(self) -> Optional[_builtins.bool]:
        """
        If CPU CFS quota enforcement is enabled for containers that specify CPU limits. The default is true.
        """
        return pulumi.get(self, "cpu_cfs_quota")

    @_builtins.property
    @pulumi.getter(name="cpuCfsQuotaPeriod")
    def cpu_cfs_quota_period(self) -> Optional[_builtins.str]:
        """
        The CPU CFS quota period value. The default is '100ms.' Valid values are a sequence of decimal numbers with an optional fraction and a unit suffix. For example: '300ms', '2h45m'. Supported units are 'ns', 'us', 'ms', 's', 'm', and 'h'.
        """
        return pulumi.get(self, "cpu_cfs_quota_period")

    @_builtins.property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[_builtins.str]:
        """
        The CPU Manager policy to use. The default is 'none'. See [Kubernetes CPU management policies](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#cpu-management-policies) for more information. Allowed values are 'none' and 'static'.
        """
        return pulumi.get(self, "cpu_manager_policy")

    @_builtins.property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[_builtins.bool]:
        """
        If set to true it will make the Kubelet fail to start if swap is enabled on the node.
        """
        return pulumi.get(self, "fail_swap_on")

    @_builtins.property
    @pulumi.getter(name="imageGcHighThreshold")
    def image_gc_high_threshold(self) -> Optional[_builtins.int]:
        """
        The percent of disk usage after which image garbage collection is always run. To disable image garbage collection, set to 100. The default is 85%
        """
        return pulumi.get(self, "image_gc_high_threshold")

    @_builtins.property
    @pulumi.getter(name="imageGcLowThreshold")
    def image_gc_low_threshold(self) -> Optional[_builtins.int]:
        """
        The percent of disk usage before which image garbage collection is never run. This cannot be set higher than imageGcHighThreshold. The default is 80%
        """
        return pulumi.get(self, "image_gc_low_threshold")

    @_builtins.property
    @pulumi.getter(name="podMaxPids")
    def pod_max_pids(self) -> Optional[_builtins.int]:
        """
        The maximum number of processes per pod.
        """
        return pulumi.get(self, "pod_max_pids")

    @_builtins.property
    @pulumi.getter(name="topologyManagerPolicy")
    def topology_manager_policy(self) -> Optional[_builtins.str]:
        """
        The Topology Manager policy to use. For more information see [Kubernetes Topology Manager](https://kubernetes.io/docs/tasks/administer-cluster/topology-manager). The default is 'none'. Allowed values are 'none', 'best-effort', 'restricted', and 'single-numa-node'.
        """
        return pulumi.get(self, "topology_manager_policy")


@pulumi.output_type
class LabelSelectorRequirementResponse(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param _builtins.str key: key is the label key that the selector applies to.
        :param _builtins.str operator: operator represents a key's relationship to a set of values. Valid operators are In and NotIn
        :param Sequence[_builtins.str] values: values is an array of string values, the values array must be non-empty.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In and NotIn
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        values is an array of string values, the values array must be non-empty.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class LabelSelectorResponse(dict):
    """
    A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelSelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelSelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelSelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.LabelSelectorRequirementResponse']] = None,
                 match_labels: Optional[Sequence[_builtins.str]] = None):
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param Sequence['LabelSelectorRequirementResponse'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Sequence[_builtins.str] match_labels: matchLabels is an array of {key=value} pairs. A single {key=value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is `key`, the operator is `In`, and the values array contains only `value`. The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.LabelSelectorRequirementResponse']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        matchLabels is an array of {key=value} pairs. A single {key=value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is `key`, the operator is `In`, and the values array contains only `value`. The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class LinuxOSConfigResponse(dict):
    """
    OS configurations of Linux agent nodes. See [AKS custom node configuration](https://docs.microsoft.com/azure/aks/custom-node-configuration) for more details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "swapFileSizeMB":
            suggest = "swap_file_size_mb"
        elif key == "transparentHugePageDefrag":
            suggest = "transparent_huge_page_defrag"
        elif key == "transparentHugePageEnabled":
            suggest = "transparent_huge_page_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxOSConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxOSConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxOSConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 swap_file_size_mb: Optional[_builtins.int] = None,
                 sysctls: Optional['outputs.SysctlConfigResponse'] = None,
                 transparent_huge_page_defrag: Optional[_builtins.str] = None,
                 transparent_huge_page_enabled: Optional[_builtins.str] = None):
        """
        OS configurations of Linux agent nodes. See [AKS custom node configuration](https://docs.microsoft.com/azure/aks/custom-node-configuration) for more details.
        :param _builtins.int swap_file_size_mb: The size in MB of a swap file that will be created on each node.
        :param 'SysctlConfigResponse' sysctls: Sysctl settings for Linux agent nodes.
        :param _builtins.str transparent_huge_page_defrag: Whether the kernel should make aggressive use of memory compaction to make more hugepages available. Valid values are 'always', 'defer', 'defer+madvise', 'madvise' and 'never'. The default is 'madvise'. For more information see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).
        :param _builtins.str transparent_huge_page_enabled: Whether transparent hugepages are enabled. Valid values are 'always', 'madvise', and 'never'. The default is 'always'. For more information see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).
        """
        if swap_file_size_mb is not None:
            pulumi.set(__self__, "swap_file_size_mb", swap_file_size_mb)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if transparent_huge_page_defrag is not None:
            pulumi.set(__self__, "transparent_huge_page_defrag", transparent_huge_page_defrag)
        if transparent_huge_page_enabled is not None:
            pulumi.set(__self__, "transparent_huge_page_enabled", transparent_huge_page_enabled)

    @_builtins.property
    @pulumi.getter(name="swapFileSizeMB")
    def swap_file_size_mb(self) -> Optional[_builtins.int]:
        """
        The size in MB of a swap file that will be created on each node.
        """
        return pulumi.get(self, "swap_file_size_mb")

    @_builtins.property
    @pulumi.getter
    def sysctls(self) -> Optional['outputs.SysctlConfigResponse']:
        """
        Sysctl settings for Linux agent nodes.
        """
        return pulumi.get(self, "sysctls")

    @_builtins.property
    @pulumi.getter(name="transparentHugePageDefrag")
    def transparent_huge_page_defrag(self) -> Optional[_builtins.str]:
        """
        Whether the kernel should make aggressive use of memory compaction to make more hugepages available. Valid values are 'always', 'defer', 'defer+madvise', 'madvise' and 'never'. The default is 'madvise'. For more information see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).
        """
        return pulumi.get(self, "transparent_huge_page_defrag")

    @_builtins.property
    @pulumi.getter(name="transparentHugePageEnabled")
    def transparent_huge_page_enabled(self) -> Optional[_builtins.str]:
        """
        Whether transparent hugepages are enabled. Valid values are 'always', 'madvise', and 'never'. The default is 'always'. For more information see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).
        """
        return pulumi.get(self, "transparent_huge_page_enabled")


@pulumi.output_type
class MaintenanceWindowResponse(dict):
    """
    Maintenance window used to configure scheduled auto-upgrade for a Managed Cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationHours":
            suggest = "duration_hours"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "notAllowedDates":
            suggest = "not_allowed_dates"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "utcOffset":
            suggest = "utc_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_hours: Optional[_builtins.int] = None,
                 schedule: 'outputs.ScheduleResponse',
                 start_time: _builtins.str,
                 not_allowed_dates: Optional[Sequence['outputs.DateSpanResponse']] = None,
                 start_date: Optional[_builtins.str] = None,
                 utc_offset: Optional[_builtins.str] = None):
        """
        Maintenance window used to configure scheduled auto-upgrade for a Managed Cluster.
        :param _builtins.int duration_hours: Length of maintenance window range from 4 to 24 hours.
        :param 'ScheduleResponse' schedule: Recurrence schedule for the maintenance window.
        :param _builtins.str start_time: The start time of the maintenance window. Accepted values are from '00:00' to '23:59'. 'utcOffset' applies to this field. For example: '02:00' with 'utcOffset: +02:00' means UTC time '00:00'.
        :param Sequence['DateSpanResponse'] not_allowed_dates: Date ranges on which upgrade is not allowed. 'utcOffset' applies to this field. For example, with 'utcOffset: +02:00' and 'dateSpan' being '2022-12-23' to '2023-01-03', maintenance will be blocked from '2022-12-22 22:00' to '2023-01-03 22:00' in UTC time.
        :param _builtins.str start_date: The date the maintenance window activates. If the current date is before this date, the maintenance window is inactive and will not be used for upgrades. If not specified, the maintenance window will be active right away.
        :param _builtins.str utc_offset: The UTC offset in format +/-HH:mm. For example, '+05:30' for IST and '-07:00' for PST. If not specified, the default is '+00:00'.
        """
        if duration_hours is None:
            duration_hours = 24
        pulumi.set(__self__, "duration_hours", duration_hours)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "start_time", start_time)
        if not_allowed_dates is not None:
            pulumi.set(__self__, "not_allowed_dates", not_allowed_dates)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if utc_offset is not None:
            pulumi.set(__self__, "utc_offset", utc_offset)

    @_builtins.property
    @pulumi.getter(name="durationHours")
    def duration_hours(self) -> _builtins.int:
        """
        Length of maintenance window range from 4 to 24 hours.
        """
        return pulumi.get(self, "duration_hours")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> 'outputs.ScheduleResponse':
        """
        Recurrence schedule for the maintenance window.
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the maintenance window. Accepted values are from '00:00' to '23:59'. 'utcOffset' applies to this field. For example: '02:00' with 'utcOffset: +02:00' means UTC time '00:00'.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="notAllowedDates")
    def not_allowed_dates(self) -> Optional[Sequence['outputs.DateSpanResponse']]:
        """
        Date ranges on which upgrade is not allowed. 'utcOffset' applies to this field. For example, with 'utcOffset: +02:00' and 'dateSpan' being '2022-12-23' to '2023-01-03', maintenance will be blocked from '2022-12-22 22:00' to '2023-01-03 22:00' in UTC time.
        """
        return pulumi.get(self, "not_allowed_dates")

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[_builtins.str]:
        """
        The date the maintenance window activates. If the current date is before this date, the maintenance window is inactive and will not be used for upgrades. If not specified, the maintenance window will be active right away.
        """
        return pulumi.get(self, "start_date")

    @_builtins.property
    @pulumi.getter(name="utcOffset")
    def utc_offset(self) -> Optional[_builtins.str]:
        """
        The UTC offset in format +/-HH:mm. For example, '+05:30' for IST and '-07:00' for PST. If not specified, the default is '+00:00'.
        """
        return pulumi.get(self, "utc_offset")


@pulumi.output_type
class ManagedClusterAADProfileResponse(dict):
    """
    AADProfile specifies attributes for Azure Active Directory integration. For more details see [managed AAD on AKS](https://docs.microsoft.com/azure/aks/managed-aad).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminGroupObjectIDs":
            suggest = "admin_group_object_ids"
        elif key == "clientAppID":
            suggest = "client_app_id"
        elif key == "enableAzureRBAC":
            suggest = "enable_azure_rbac"
        elif key == "serverAppID":
            suggest = "server_app_id"
        elif key == "serverAppSecret":
            suggest = "server_app_secret"
        elif key == "tenantID":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterAADProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterAADProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterAADProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_group_object_ids: Optional[Sequence[_builtins.str]] = None,
                 client_app_id: Optional[_builtins.str] = None,
                 enable_azure_rbac: Optional[_builtins.bool] = None,
                 managed: Optional[_builtins.bool] = None,
                 server_app_id: Optional[_builtins.str] = None,
                 server_app_secret: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        AADProfile specifies attributes for Azure Active Directory integration. For more details see [managed AAD on AKS](https://docs.microsoft.com/azure/aks/managed-aad).
        :param Sequence[_builtins.str] admin_group_object_ids: The list of AAD group object IDs that will have admin role of the cluster.
        :param _builtins.str client_app_id: (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        :param _builtins.bool enable_azure_rbac: Whether to enable Azure RBAC for Kubernetes authorization.
        :param _builtins.bool managed: Whether to enable managed AAD.
        :param _builtins.str server_app_id: (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        :param _builtins.str server_app_secret: (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        :param _builtins.str tenant_id: The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        """
        if admin_group_object_ids is not None:
            pulumi.set(__self__, "admin_group_object_ids", admin_group_object_ids)
        if client_app_id is not None:
            pulumi.set(__self__, "client_app_id", client_app_id)
        if enable_azure_rbac is not None:
            pulumi.set(__self__, "enable_azure_rbac", enable_azure_rbac)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if server_app_id is not None:
            pulumi.set(__self__, "server_app_id", server_app_id)
        if server_app_secret is not None:
            pulumi.set(__self__, "server_app_secret", server_app_secret)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="adminGroupObjectIDs")
    def admin_group_object_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of AAD group object IDs that will have admin role of the cluster.
        """
        return pulumi.get(self, "admin_group_object_ids")

    @_builtins.property
    @pulumi.getter(name="clientAppID")
    def client_app_id(self) -> Optional[_builtins.str]:
        """
        (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        """
        return pulumi.get(self, "client_app_id")

    @_builtins.property
    @pulumi.getter(name="enableAzureRBAC")
    def enable_azure_rbac(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Azure RBAC for Kubernetes authorization.
        """
        return pulumi.get(self, "enable_azure_rbac")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> Optional[_builtins.bool]:
        """
        Whether to enable managed AAD.
        """
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter(name="serverAppID")
    def server_app_id(self) -> Optional[_builtins.str]:
        """
        (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        """
        return pulumi.get(self, "server_app_id")

    @_builtins.property
    @pulumi.getter(name="serverAppSecret")
    def server_app_secret(self) -> Optional[_builtins.str]:
        """
        (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        """
        return pulumi.get(self, "server_app_secret")

    @_builtins.property
    @pulumi.getter(name="tenantID")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ManagedClusterAIToolchainOperatorProfileResponse(dict):
    """
    When enabling the operator, a set of AKS managed CRDs and controllers will be installed in the cluster. The operator automates the deployment of OSS models for inference and/or training purposes. It provides a set of preset models and enables distributed inference against them.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        When enabling the operator, a set of AKS managed CRDs and controllers will be installed in the cluster. The operator automates the deployment of OSS models for inference and/or training purposes. It provides a set of preset models and enables distributed inference against them.
        :param _builtins.bool enabled: Whether to enable AI toolchain operator to the cluster. Indicates if AI toolchain operator  enabled or not.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable AI toolchain operator to the cluster. Indicates if AI toolchain operator  enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterAPIServerAccessProfileResponse(dict):
    """
    Access profile for managed cluster API server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedIPRanges":
            suggest = "authorized_ip_ranges"
        elif key == "disableRunCommand":
            suggest = "disable_run_command"
        elif key == "enablePrivateCluster":
            suggest = "enable_private_cluster"
        elif key == "enablePrivateClusterPublicFQDN":
            suggest = "enable_private_cluster_public_fqdn"
        elif key == "enableVnetIntegration":
            suggest = "enable_vnet_integration"
        elif key == "privateDNSZone":
            suggest = "private_dns_zone"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterAPIServerAccessProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterAPIServerAccessProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterAPIServerAccessProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 disable_run_command: Optional[_builtins.bool] = None,
                 enable_private_cluster: Optional[_builtins.bool] = None,
                 enable_private_cluster_public_fqdn: Optional[_builtins.bool] = None,
                 enable_vnet_integration: Optional[_builtins.bool] = None,
                 private_dns_zone: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        Access profile for managed cluster API server.
        :param Sequence[_builtins.str] authorized_ip_ranges: The IP ranges authorized to access the Kubernetes API server. IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        :param _builtins.bool disable_run_command: Whether to disable run command for the cluster or not.
        :param _builtins.bool enable_private_cluster: Whether to create the cluster as a private cluster or not. For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        :param _builtins.bool enable_private_cluster_public_fqdn: Whether to create additional public FQDN for private cluster or not.
        :param _builtins.bool enable_vnet_integration: Whether to enable apiserver vnet integration for the cluster or not. See aka.ms/AksVnetIntegration for more details.
        :param _builtins.str private_dns_zone: The private DNS zone mode for the cluster. The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are 'system' and 'none'.
        :param _builtins.str subnet_id: The subnet to be used when apiserver vnet integration is enabled. It is required when creating a new cluster with BYO Vnet, or when updating an existing cluster to enable apiserver vnet integration.
        """
        if authorized_ip_ranges is not None:
            pulumi.set(__self__, "authorized_ip_ranges", authorized_ip_ranges)
        if disable_run_command is not None:
            pulumi.set(__self__, "disable_run_command", disable_run_command)
        if enable_private_cluster is not None:
            pulumi.set(__self__, "enable_private_cluster", enable_private_cluster)
        if enable_private_cluster_public_fqdn is not None:
            pulumi.set(__self__, "enable_private_cluster_public_fqdn", enable_private_cluster_public_fqdn)
        if enable_vnet_integration is not None:
            pulumi.set(__self__, "enable_vnet_integration", enable_vnet_integration)
        if private_dns_zone is not None:
            pulumi.set(__self__, "private_dns_zone", private_dns_zone)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="authorizedIPRanges")
    def authorized_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IP ranges authorized to access the Kubernetes API server. IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        """
        return pulumi.get(self, "authorized_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="disableRunCommand")
    def disable_run_command(self) -> Optional[_builtins.bool]:
        """
        Whether to disable run command for the cluster or not.
        """
        return pulumi.get(self, "disable_run_command")

    @_builtins.property
    @pulumi.getter(name="enablePrivateCluster")
    def enable_private_cluster(self) -> Optional[_builtins.bool]:
        """
        Whether to create the cluster as a private cluster or not. For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        """
        return pulumi.get(self, "enable_private_cluster")

    @_builtins.property
    @pulumi.getter(name="enablePrivateClusterPublicFQDN")
    def enable_private_cluster_public_fqdn(self) -> Optional[_builtins.bool]:
        """
        Whether to create additional public FQDN for private cluster or not.
        """
        return pulumi.get(self, "enable_private_cluster_public_fqdn")

    @_builtins.property
    @pulumi.getter(name="enableVnetIntegration")
    def enable_vnet_integration(self) -> Optional[_builtins.bool]:
        """
        Whether to enable apiserver vnet integration for the cluster or not. See aka.ms/AksVnetIntegration for more details.
        """
        return pulumi.get(self, "enable_vnet_integration")

    @_builtins.property
    @pulumi.getter(name="privateDNSZone")
    def private_dns_zone(self) -> Optional[_builtins.str]:
        """
        The private DNS zone mode for the cluster. The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are 'system' and 'none'.
        """
        return pulumi.get(self, "private_dns_zone")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The subnet to be used when apiserver vnet integration is enabled. It is required when creating a new cluster with BYO Vnet, or when updating an existing cluster to enable apiserver vnet integration.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class ManagedClusterAddonProfileResponse(dict):
    """
    A Kubernetes add-on profile for a managed cluster.
    """
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 identity: 'outputs.ManagedClusterAddonProfileResponseIdentity',
                 config: Optional[Mapping[str, _builtins.str]] = None):
        """
        A Kubernetes add-on profile for a managed cluster.
        :param _builtins.bool enabled: Whether the add-on is enabled or not.
        :param 'ManagedClusterAddonProfileResponseIdentity' identity: Information of user assigned identity used by this add-on.
        :param Mapping[str, _builtins.str] config: Key-value pairs for configuring an add-on.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "identity", identity)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether the add-on is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> 'outputs.ManagedClusterAddonProfileResponseIdentity':
        """
        Information of user assigned identity used by this add-on.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key-value pairs for configuring an add-on.
        """
        return pulumi.get(self, "config")


@pulumi.output_type
class ManagedClusterAddonProfileResponseIdentity(dict):
    """
    Information of user assigned identity used by this add-on.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterAddonProfileResponseIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterAddonProfileResponseIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterAddonProfileResponseIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None):
        """
        Information of user assigned identity used by this add-on.
        :param _builtins.str client_id: The client ID of the user assigned identity.
        :param _builtins.str object_id: The object ID of the user assigned identity.
        :param _builtins.str resource_id: The resource ID of the user assigned identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client ID of the user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The object ID of the user assigned identity.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        The resource ID of the user assigned identity.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ManagedClusterAgentPoolProfileResponse(dict):
    """
    Profile for the container service agent pool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentOrchestratorVersion":
            suggest = "current_orchestrator_version"
        elif key == "eTag":
            suggest = "e_tag"
        elif key == "nodeImageVersion":
            suggest = "node_image_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "capacityReservationGroupID":
            suggest = "capacity_reservation_group_id"
        elif key == "creationData":
            suggest = "creation_data"
        elif key == "enableAutoScaling":
            suggest = "enable_auto_scaling"
        elif key == "enableEncryptionAtHost":
            suggest = "enable_encryption_at_host"
        elif key == "enableFIPS":
            suggest = "enable_fips"
        elif key == "enableNodePublicIP":
            suggest = "enable_node_public_ip"
        elif key == "enableUltraSSD":
            suggest = "enable_ultra_ssd"
        elif key == "gatewayProfile":
            suggest = "gateway_profile"
        elif key == "gpuInstanceProfile":
            suggest = "gpu_instance_profile"
        elif key == "gpuProfile":
            suggest = "gpu_profile"
        elif key == "hostGroupID":
            suggest = "host_group_id"
        elif key == "kubeletConfig":
            suggest = "kubelet_config"
        elif key == "kubeletDiskType":
            suggest = "kubelet_disk_type"
        elif key == "linuxOSConfig":
            suggest = "linux_os_config"
        elif key == "maxCount":
            suggest = "max_count"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "messageOfTheDay":
            suggest = "message_of_the_day"
        elif key == "minCount":
            suggest = "min_count"
        elif key == "networkProfile":
            suggest = "network_profile"
        elif key == "nodeLabels":
            suggest = "node_labels"
        elif key == "nodePublicIPPrefixID":
            suggest = "node_public_ip_prefix_id"
        elif key == "nodeTaints":
            suggest = "node_taints"
        elif key == "orchestratorVersion":
            suggest = "orchestrator_version"
        elif key == "osDiskSizeGB":
            suggest = "os_disk_size_gb"
        elif key == "osDiskType":
            suggest = "os_disk_type"
        elif key == "osSKU":
            suggest = "os_sku"
        elif key == "osType":
            suggest = "os_type"
        elif key == "podIPAllocationMode":
            suggest = "pod_ip_allocation_mode"
        elif key == "podSubnetID":
            suggest = "pod_subnet_id"
        elif key == "powerState":
            suggest = "power_state"
        elif key == "proximityPlacementGroupID":
            suggest = "proximity_placement_group_id"
        elif key == "scaleDownMode":
            suggest = "scale_down_mode"
        elif key == "scaleSetEvictionPolicy":
            suggest = "scale_set_eviction_policy"
        elif key == "scaleSetPriority":
            suggest = "scale_set_priority"
        elif key == "securityProfile":
            suggest = "security_profile"
        elif key == "spotMaxPrice":
            suggest = "spot_max_price"
        elif key == "upgradeSettings":
            suggest = "upgrade_settings"
        elif key == "virtualMachineNodesStatus":
            suggest = "virtual_machine_nodes_status"
        elif key == "virtualMachinesProfile":
            suggest = "virtual_machines_profile"
        elif key == "vmSize":
            suggest = "vm_size"
        elif key == "vnetSubnetID":
            suggest = "vnet_subnet_id"
        elif key == "windowsProfile":
            suggest = "windows_profile"
        elif key == "workloadRuntime":
            suggest = "workload_runtime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterAgentPoolProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterAgentPoolProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterAgentPoolProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_orchestrator_version: _builtins.str,
                 e_tag: _builtins.str,
                 name: _builtins.str,
                 node_image_version: _builtins.str,
                 provisioning_state: _builtins.str,
                 availability_zones: Optional[Sequence[_builtins.str]] = None,
                 capacity_reservation_group_id: Optional[_builtins.str] = None,
                 count: Optional[_builtins.int] = None,
                 creation_data: Optional['outputs.CreationDataResponse'] = None,
                 enable_auto_scaling: Optional[_builtins.bool] = None,
                 enable_encryption_at_host: Optional[_builtins.bool] = None,
                 enable_fips: Optional[_builtins.bool] = None,
                 enable_node_public_ip: Optional[_builtins.bool] = None,
                 enable_ultra_ssd: Optional[_builtins.bool] = None,
                 gateway_profile: Optional['outputs.AgentPoolGatewayProfileResponse'] = None,
                 gpu_instance_profile: Optional[_builtins.str] = None,
                 gpu_profile: Optional['outputs.GPUProfileResponse'] = None,
                 host_group_id: Optional[_builtins.str] = None,
                 kubelet_config: Optional['outputs.KubeletConfigResponse'] = None,
                 kubelet_disk_type: Optional[_builtins.str] = None,
                 linux_os_config: Optional['outputs.LinuxOSConfigResponse'] = None,
                 max_count: Optional[_builtins.int] = None,
                 max_pods: Optional[_builtins.int] = None,
                 message_of_the_day: Optional[_builtins.str] = None,
                 min_count: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 network_profile: Optional['outputs.AgentPoolNetworkProfileResponse'] = None,
                 node_labels: Optional[Mapping[str, _builtins.str]] = None,
                 node_public_ip_prefix_id: Optional[_builtins.str] = None,
                 node_taints: Optional[Sequence[_builtins.str]] = None,
                 orchestrator_version: Optional[_builtins.str] = None,
                 os_disk_size_gb: Optional[_builtins.int] = None,
                 os_disk_type: Optional[_builtins.str] = None,
                 os_sku: Optional[_builtins.str] = None,
                 os_type: Optional[_builtins.str] = None,
                 pod_ip_allocation_mode: Optional[_builtins.str] = None,
                 pod_subnet_id: Optional[_builtins.str] = None,
                 power_state: Optional['outputs.PowerStateResponse'] = None,
                 proximity_placement_group_id: Optional[_builtins.str] = None,
                 scale_down_mode: Optional[_builtins.str] = None,
                 scale_set_eviction_policy: Optional[_builtins.str] = None,
                 scale_set_priority: Optional[_builtins.str] = None,
                 security_profile: Optional['outputs.AgentPoolSecurityProfileResponse'] = None,
                 spot_max_price: Optional[_builtins.float] = None,
                 status: Optional['outputs.AgentPoolStatusResponse'] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 upgrade_settings: Optional['outputs.AgentPoolUpgradeSettingsResponse'] = None,
                 virtual_machine_nodes_status: Optional[Sequence['outputs.VirtualMachineNodesResponse']] = None,
                 virtual_machines_profile: Optional['outputs.VirtualMachinesProfileResponse'] = None,
                 vm_size: Optional[_builtins.str] = None,
                 vnet_subnet_id: Optional[_builtins.str] = None,
                 windows_profile: Optional['outputs.AgentPoolWindowsProfileResponse'] = None,
                 workload_runtime: Optional[_builtins.str] = None):
        """
        Profile for the container service agent pool.
        :param _builtins.str current_orchestrator_version: The version of Kubernetes the Agent Pool is running. If orchestratorVersion is a fully specified version <major.minor.patch>, this field will be exactly equal to it. If orchestratorVersion is <major.minor>, this field will contain the full <major.minor.patch> version being used.
        :param _builtins.str e_tag: Unique read-only string used to implement optimistic concurrency. The eTag value will change when the resource is updated. Specify an if-match or if-none-match header with the eTag value for a subsequent request to enable optimistic concurrency per the normal etag convention.
        :param _builtins.str name: Unique name of the agent pool profile in the context of the subscription and resource group. Windows agent pool names must be 6 characters or less.
        :param _builtins.str node_image_version: The version of node image
        :param _builtins.str provisioning_state: The current deployment or provisioning state.
        :param Sequence[_builtins.str] availability_zones: The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType property is 'VirtualMachineScaleSets'.
        :param _builtins.str capacity_reservation_group_id: AKS will associate the specified agent pool with the Capacity Reservation Group.
        :param _builtins.int count: Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
        :param 'CreationDataResponse' creation_data: CreationData to be used to specify the source Snapshot ID if the node pool will be created/upgraded using a snapshot.
        :param _builtins.bool enable_auto_scaling: Whether to enable auto-scaler
        :param _builtins.bool enable_encryption_at_host: Whether to enable host based OS and data drive encryption. This is only supported on certain VM sizes and in certain Azure regions. For more information, see: https://docs.microsoft.com/azure/aks/enable-host-encryption
        :param _builtins.bool enable_fips: Whether to use a FIPS-enabled OS. See [Add a FIPS-enabled node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview) for more details.
        :param _builtins.bool enable_node_public_ip: Whether each node is allocated its own public IP. Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine to minimize hops. For more information see [assigning a public IP per node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools). The default is false.
        :param _builtins.bool enable_ultra_ssd: Whether to enable UltraSSD
        :param 'AgentPoolGatewayProfileResponse' gateway_profile: Profile specific to a managed agent pool in Gateway mode. This field cannot be set if agent pool mode is not Gateway.
        :param _builtins.str gpu_instance_profile: GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
        :param 'GPUProfileResponse' gpu_profile: GPU settings for the Agent Pool.
        :param _builtins.str host_group_id: The fully qualified resource ID of the Dedicated Host Group to provision virtual machines from, used only in creation scenario and not allowed to changed once set. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}. For more information see [Azure dedicated hosts](https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts).
        :param 'KubeletConfigResponse' kubelet_config: The Kubelet configuration on the agent pool nodes.
        :param _builtins.str kubelet_disk_type: Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.
        :param 'LinuxOSConfigResponse' linux_os_config: The OS configuration of Linux agent nodes.
        :param _builtins.int max_count: The maximum number of nodes for auto-scaling
        :param _builtins.int max_pods: The maximum number of pods that can run on a node.
        :param _builtins.str message_of_the_day: Message of the day for Linux nodes, base64-encoded. A base64-encoded string which will be written to /etc/motd after decoding. This allows customization of the message of the day for Linux nodes. It must not be specified for Windows nodes. It must be a static string (i.e., will be printed raw and not be executed as a script).
        :param _builtins.int min_count: The minimum number of nodes for auto-scaling
        :param _builtins.str mode: The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times. For additional information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
        :param 'AgentPoolNetworkProfileResponse' network_profile: Network-related settings of an agent pool.
        :param Mapping[str, _builtins.str] node_labels: The node labels to be persisted across all nodes in agent pool.
        :param _builtins.str node_public_ip_prefix_id: The public IP prefix ID which VM nodes should use IPs from. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
        :param Sequence[_builtins.str] node_taints: The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
        :param _builtins.str orchestrator_version: The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version as the control plane. The node pool minor version must be within two minor versions of the control plane version. The node pool version cannot be greater than the control plane version. For more information see [upgrading a node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
        :param _builtins.int os_disk_size_gb: OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.
        :param _builtins.str os_disk_type: The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after creation. For more information see [Ephemeral OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
        :param _builtins.str os_sku: Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019 when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.
        :param _builtins.str os_type: The operating system type. The default is Linux.
        :param _builtins.str pod_ip_allocation_mode: Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with podSubnetId. The default is 'DynamicIndividual'.
        :param _builtins.str pod_subnet_id: The ID of the subnet which pods will join when launched. If omitted, pod IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        :param 'PowerStateResponse' power_state: Whether the Agent Pool is running or stopped. When an Agent Pool is first created it is initially Running. The Agent Pool can be stopped by setting this field to Stopped. A stopped Agent Pool stops all of its VMs and does not accrue billing charges. An Agent Pool can only be stopped if it is Running and provisioning state is Succeeded
        :param _builtins.str proximity_placement_group_id: The ID for Proximity Placement Group.
        :param _builtins.str scale_down_mode: The scale down mode to use when scaling the Agent Pool. This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete.
        :param _builtins.str scale_set_eviction_policy: The Virtual Machine Scale Set eviction policy to use. This cannot be specified unless the scaleSetPriority is 'Spot'. If not specified, the default is 'Delete'.
        :param _builtins.str scale_set_priority: The Virtual Machine Scale Set priority. If not specified, the default is 'Regular'.
        :param 'AgentPoolSecurityProfileResponse' security_profile: The security settings of an agent pool.
        :param _builtins.float spot_max_price: The max price (in US Dollars) you are willing to pay for spot instances. Possible values are any decimal value greater than zero or -1 which indicates default price to be up-to on-demand. Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing, see [spot VMs pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
        :param 'AgentPoolStatusResponse' status: Contains read-only information about the Agent Pool.
        :param Mapping[str, _builtins.str] tags: The tags to be persisted on the agent pool virtual machine scale set.
        :param _builtins.str type: The type of Agent Pool.
        :param 'AgentPoolUpgradeSettingsResponse' upgrade_settings: Settings for upgrading the agentpool
        :param Sequence['VirtualMachineNodesResponse'] virtual_machine_nodes_status: The status of nodes in a VirtualMachines agent pool.
        :param 'VirtualMachinesProfileResponse' virtual_machines_profile: Specifications on VirtualMachines agent pool.
        :param _builtins.str vm_size: The size of the agent pool VMs. VM size availability varies by region. If a node contains insufficient compute resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see: https://docs.microsoft.com/azure/aks/quotas-skus-regions
        :param _builtins.str vnet_subnet_id: The ID of the subnet which agent pool nodes and optionally pods will join on startup. If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        :param 'AgentPoolWindowsProfileResponse' windows_profile: The Windows agent pool's specific profile.
        :param _builtins.str workload_runtime: Determines the type of workload a node can run.
        """
        pulumi.set(__self__, "current_orchestrator_version", current_orchestrator_version)
        pulumi.set(__self__, "e_tag", e_tag)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_image_version", node_image_version)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if capacity_reservation_group_id is not None:
            pulumi.set(__self__, "capacity_reservation_group_id", capacity_reservation_group_id)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if creation_data is not None:
            pulumi.set(__self__, "creation_data", creation_data)
        if enable_auto_scaling is not None:
            pulumi.set(__self__, "enable_auto_scaling", enable_auto_scaling)
        if enable_encryption_at_host is not None:
            pulumi.set(__self__, "enable_encryption_at_host", enable_encryption_at_host)
        if enable_fips is not None:
            pulumi.set(__self__, "enable_fips", enable_fips)
        if enable_node_public_ip is not None:
            pulumi.set(__self__, "enable_node_public_ip", enable_node_public_ip)
        if enable_ultra_ssd is not None:
            pulumi.set(__self__, "enable_ultra_ssd", enable_ultra_ssd)
        if gateway_profile is not None:
            pulumi.set(__self__, "gateway_profile", gateway_profile)
        if gpu_instance_profile is not None:
            pulumi.set(__self__, "gpu_instance_profile", gpu_instance_profile)
        if gpu_profile is not None:
            pulumi.set(__self__, "gpu_profile", gpu_profile)
        if host_group_id is not None:
            pulumi.set(__self__, "host_group_id", host_group_id)
        if kubelet_config is not None:
            pulumi.set(__self__, "kubelet_config", kubelet_config)
        if kubelet_disk_type is not None:
            pulumi.set(__self__, "kubelet_disk_type", kubelet_disk_type)
        if linux_os_config is not None:
            pulumi.set(__self__, "linux_os_config", linux_os_config)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if message_of_the_day is not None:
            pulumi.set(__self__, "message_of_the_day", message_of_the_day)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if network_profile is not None:
            pulumi.set(__self__, "network_profile", network_profile)
        if node_labels is not None:
            pulumi.set(__self__, "node_labels", node_labels)
        if node_public_ip_prefix_id is not None:
            pulumi.set(__self__, "node_public_ip_prefix_id", node_public_ip_prefix_id)
        if node_taints is not None:
            pulumi.set(__self__, "node_taints", node_taints)
        if orchestrator_version is not None:
            pulumi.set(__self__, "orchestrator_version", orchestrator_version)
        if os_disk_size_gb is not None:
            pulumi.set(__self__, "os_disk_size_gb", os_disk_size_gb)
        if os_disk_type is not None:
            pulumi.set(__self__, "os_disk_type", os_disk_type)
        if os_sku is not None:
            pulumi.set(__self__, "os_sku", os_sku)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if pod_ip_allocation_mode is not None:
            pulumi.set(__self__, "pod_ip_allocation_mode", pod_ip_allocation_mode)
        if pod_subnet_id is not None:
            pulumi.set(__self__, "pod_subnet_id", pod_subnet_id)
        if power_state is not None:
            pulumi.set(__self__, "power_state", power_state)
        if proximity_placement_group_id is not None:
            pulumi.set(__self__, "proximity_placement_group_id", proximity_placement_group_id)
        if scale_down_mode is not None:
            pulumi.set(__self__, "scale_down_mode", scale_down_mode)
        if scale_set_eviction_policy is not None:
            pulumi.set(__self__, "scale_set_eviction_policy", scale_set_eviction_policy)
        if scale_set_priority is not None:
            pulumi.set(__self__, "scale_set_priority", scale_set_priority)
        if security_profile is not None:
            pulumi.set(__self__, "security_profile", security_profile)
        if spot_max_price is not None:
            pulumi.set(__self__, "spot_max_price", spot_max_price)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if upgrade_settings is not None:
            pulumi.set(__self__, "upgrade_settings", upgrade_settings)
        if virtual_machine_nodes_status is not None:
            pulumi.set(__self__, "virtual_machine_nodes_status", virtual_machine_nodes_status)
        if virtual_machines_profile is not None:
            pulumi.set(__self__, "virtual_machines_profile", virtual_machines_profile)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)
        if vnet_subnet_id is not None:
            pulumi.set(__self__, "vnet_subnet_id", vnet_subnet_id)
        if windows_profile is not None:
            pulumi.set(__self__, "windows_profile", windows_profile)
        if workload_runtime is not None:
            pulumi.set(__self__, "workload_runtime", workload_runtime)

    @_builtins.property
    @pulumi.getter(name="currentOrchestratorVersion")
    def current_orchestrator_version(self) -> _builtins.str:
        """
        The version of Kubernetes the Agent Pool is running. If orchestratorVersion is a fully specified version <major.minor.patch>, this field will be exactly equal to it. If orchestratorVersion is <major.minor>, this field will contain the full <major.minor.patch> version being used.
        """
        return pulumi.get(self, "current_orchestrator_version")

    @_builtins.property
    @pulumi.getter(name="eTag")
    def e_tag(self) -> _builtins.str:
        """
        Unique read-only string used to implement optimistic concurrency. The eTag value will change when the resource is updated. Specify an if-match or if-none-match header with the eTag value for a subsequent request to enable optimistic concurrency per the normal etag convention.
        """
        return pulumi.get(self, "e_tag")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Unique name of the agent pool profile in the context of the subscription and resource group. Windows agent pool names must be 6 characters or less.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeImageVersion")
    def node_image_version(self) -> _builtins.str:
        """
        The version of node image
        """
        return pulumi.get(self, "node_image_version")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The current deployment or provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType property is 'VirtualMachineScaleSets'.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="capacityReservationGroupID")
    def capacity_reservation_group_id(self) -> Optional[_builtins.str]:
        """
        AKS will associate the specified agent pool with the Capacity Reservation Group.
        """
        return pulumi.get(self, "capacity_reservation_group_id")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="creationData")
    def creation_data(self) -> Optional['outputs.CreationDataResponse']:
        """
        CreationData to be used to specify the source Snapshot ID if the node pool will be created/upgraded using a snapshot.
        """
        return pulumi.get(self, "creation_data")

    @_builtins.property
    @pulumi.getter(name="enableAutoScaling")
    def enable_auto_scaling(self) -> Optional[_builtins.bool]:
        """
        Whether to enable auto-scaler
        """
        return pulumi.get(self, "enable_auto_scaling")

    @_builtins.property
    @pulumi.getter(name="enableEncryptionAtHost")
    def enable_encryption_at_host(self) -> Optional[_builtins.bool]:
        """
        Whether to enable host based OS and data drive encryption. This is only supported on certain VM sizes and in certain Azure regions. For more information, see: https://docs.microsoft.com/azure/aks/enable-host-encryption
        """
        return pulumi.get(self, "enable_encryption_at_host")

    @_builtins.property
    @pulumi.getter(name="enableFIPS")
    def enable_fips(self) -> Optional[_builtins.bool]:
        """
        Whether to use a FIPS-enabled OS. See [Add a FIPS-enabled node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview) for more details.
        """
        return pulumi.get(self, "enable_fips")

    @_builtins.property
    @pulumi.getter(name="enableNodePublicIP")
    def enable_node_public_ip(self) -> Optional[_builtins.bool]:
        """
        Whether each node is allocated its own public IP. Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine to minimize hops. For more information see [assigning a public IP per node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools). The default is false.
        """
        return pulumi.get(self, "enable_node_public_ip")

    @_builtins.property
    @pulumi.getter(name="enableUltraSSD")
    def enable_ultra_ssd(self) -> Optional[_builtins.bool]:
        """
        Whether to enable UltraSSD
        """
        return pulumi.get(self, "enable_ultra_ssd")

    @_builtins.property
    @pulumi.getter(name="gatewayProfile")
    def gateway_profile(self) -> Optional['outputs.AgentPoolGatewayProfileResponse']:
        """
        Profile specific to a managed agent pool in Gateway mode. This field cannot be set if agent pool mode is not Gateway.
        """
        return pulumi.get(self, "gateway_profile")

    @_builtins.property
    @pulumi.getter(name="gpuInstanceProfile")
    def gpu_instance_profile(self) -> Optional[_builtins.str]:
        """
        GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
        """
        return pulumi.get(self, "gpu_instance_profile")

    @_builtins.property
    @pulumi.getter(name="gpuProfile")
    def gpu_profile(self) -> Optional['outputs.GPUProfileResponse']:
        """
        GPU settings for the Agent Pool.
        """
        return pulumi.get(self, "gpu_profile")

    @_builtins.property
    @pulumi.getter(name="hostGroupID")
    def host_group_id(self) -> Optional[_builtins.str]:
        """
        The fully qualified resource ID of the Dedicated Host Group to provision virtual machines from, used only in creation scenario and not allowed to changed once set. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}. For more information see [Azure dedicated hosts](https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts).
        """
        return pulumi.get(self, "host_group_id")

    @_builtins.property
    @pulumi.getter(name="kubeletConfig")
    def kubelet_config(self) -> Optional['outputs.KubeletConfigResponse']:
        """
        The Kubelet configuration on the agent pool nodes.
        """
        return pulumi.get(self, "kubelet_config")

    @_builtins.property
    @pulumi.getter(name="kubeletDiskType")
    def kubelet_disk_type(self) -> Optional[_builtins.str]:
        """
        Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.
        """
        return pulumi.get(self, "kubelet_disk_type")

    @_builtins.property
    @pulumi.getter(name="linuxOSConfig")
    def linux_os_config(self) -> Optional['outputs.LinuxOSConfigResponse']:
        """
        The OS configuration of Linux agent nodes.
        """
        return pulumi.get(self, "linux_os_config")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        The maximum number of nodes for auto-scaling
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[_builtins.int]:
        """
        The maximum number of pods that can run on a node.
        """
        return pulumi.get(self, "max_pods")

    @_builtins.property
    @pulumi.getter(name="messageOfTheDay")
    def message_of_the_day(self) -> Optional[_builtins.str]:
        """
        Message of the day for Linux nodes, base64-encoded. A base64-encoded string which will be written to /etc/motd after decoding. This allows customization of the message of the day for Linux nodes. It must not be specified for Windows nodes. It must be a static string (i.e., will be printed raw and not be executed as a script).
        """
        return pulumi.get(self, "message_of_the_day")

    @_builtins.property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[_builtins.int]:
        """
        The minimum number of nodes for auto-scaling
        """
        return pulumi.get(self, "min_count")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The mode of an agent pool. A cluster must have at least one 'System' Agent Pool at all times. For additional information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="networkProfile")
    def network_profile(self) -> Optional['outputs.AgentPoolNetworkProfileResponse']:
        """
        Network-related settings of an agent pool.
        """
        return pulumi.get(self, "network_profile")

    @_builtins.property
    @pulumi.getter(name="nodeLabels")
    def node_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The node labels to be persisted across all nodes in agent pool.
        """
        return pulumi.get(self, "node_labels")

    @_builtins.property
    @pulumi.getter(name="nodePublicIPPrefixID")
    def node_public_ip_prefix_id(self) -> Optional[_builtins.str]:
        """
        The public IP prefix ID which VM nodes should use IPs from. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
        """
        return pulumi.get(self, "node_public_ip_prefix_id")

    @_builtins.property
    @pulumi.getter(name="nodeTaints")
    def node_taints(self) -> Optional[Sequence[_builtins.str]]:
        """
        The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
        """
        return pulumi.get(self, "node_taints")

    @_builtins.property
    @pulumi.getter(name="orchestratorVersion")
    def orchestrator_version(self) -> Optional[_builtins.str]:
        """
        The version of Kubernetes specified by the user. Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version as the control plane. The node pool minor version must be within two minor versions of the control plane version. The node pool version cannot be greater than the control plane version. For more information see [upgrading a node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
        """
        return pulumi.get(self, "orchestrator_version")

    @_builtins.property
    @pulumi.getter(name="osDiskSizeGB")
    def os_disk_size_gb(self) -> Optional[_builtins.int]:
        """
        OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.
        """
        return pulumi.get(self, "os_disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="osDiskType")
    def os_disk_type(self) -> Optional[_builtins.str]:
        """
        The OS disk type to be used for machines in the agent pool. The default is 'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after creation. For more information see [Ephemeral OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
        """
        return pulumi.get(self, "os_disk_type")

    @_builtins.property
    @pulumi.getter(name="osSKU")
    def os_sku(self) -> Optional[_builtins.str]:
        """
        Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019 when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.
        """
        return pulumi.get(self, "os_sku")

    @_builtins.property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[_builtins.str]:
        """
        The operating system type. The default is Linux.
        """
        return pulumi.get(self, "os_type")

    @_builtins.property
    @pulumi.getter(name="podIPAllocationMode")
    def pod_ip_allocation_mode(self) -> Optional[_builtins.str]:
        """
        Pod IP Allocation Mode. The IP allocation mode for pods in the agent pool. Must be used with podSubnetId. The default is 'DynamicIndividual'.
        """
        return pulumi.get(self, "pod_ip_allocation_mode")

    @_builtins.property
    @pulumi.getter(name="podSubnetID")
    def pod_subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet which pods will join when launched. If omitted, pod IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        """
        return pulumi.get(self, "pod_subnet_id")

    @_builtins.property
    @pulumi.getter(name="powerState")
    def power_state(self) -> Optional['outputs.PowerStateResponse']:
        """
        Whether the Agent Pool is running or stopped. When an Agent Pool is first created it is initially Running. The Agent Pool can be stopped by setting this field to Stopped. A stopped Agent Pool stops all of its VMs and does not accrue billing charges. An Agent Pool can only be stopped if it is Running and provisioning state is Succeeded
        """
        return pulumi.get(self, "power_state")

    @_builtins.property
    @pulumi.getter(name="proximityPlacementGroupID")
    def proximity_placement_group_id(self) -> Optional[_builtins.str]:
        """
        The ID for Proximity Placement Group.
        """
        return pulumi.get(self, "proximity_placement_group_id")

    @_builtins.property
    @pulumi.getter(name="scaleDownMode")
    def scale_down_mode(self) -> Optional[_builtins.str]:
        """
        The scale down mode to use when scaling the Agent Pool. This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete.
        """
        return pulumi.get(self, "scale_down_mode")

    @_builtins.property
    @pulumi.getter(name="scaleSetEvictionPolicy")
    def scale_set_eviction_policy(self) -> Optional[_builtins.str]:
        """
        The Virtual Machine Scale Set eviction policy to use. This cannot be specified unless the scaleSetPriority is 'Spot'. If not specified, the default is 'Delete'.
        """
        return pulumi.get(self, "scale_set_eviction_policy")

    @_builtins.property
    @pulumi.getter(name="scaleSetPriority")
    def scale_set_priority(self) -> Optional[_builtins.str]:
        """
        The Virtual Machine Scale Set priority. If not specified, the default is 'Regular'.
        """
        return pulumi.get(self, "scale_set_priority")

    @_builtins.property
    @pulumi.getter(name="securityProfile")
    def security_profile(self) -> Optional['outputs.AgentPoolSecurityProfileResponse']:
        """
        The security settings of an agent pool.
        """
        return pulumi.get(self, "security_profile")

    @_builtins.property
    @pulumi.getter(name="spotMaxPrice")
    def spot_max_price(self) -> Optional[_builtins.float]:
        """
        The max price (in US Dollars) you are willing to pay for spot instances. Possible values are any decimal value greater than zero or -1 which indicates default price to be up-to on-demand. Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing, see [spot VMs pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
        """
        return pulumi.get(self, "spot_max_price")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.AgentPoolStatusResponse']:
        """
        Contains read-only information about the Agent Pool.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The tags to be persisted on the agent pool virtual machine scale set.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of Agent Pool.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="upgradeSettings")
    def upgrade_settings(self) -> Optional['outputs.AgentPoolUpgradeSettingsResponse']:
        """
        Settings for upgrading the agentpool
        """
        return pulumi.get(self, "upgrade_settings")

    @_builtins.property
    @pulumi.getter(name="virtualMachineNodesStatus")
    def virtual_machine_nodes_status(self) -> Optional[Sequence['outputs.VirtualMachineNodesResponse']]:
        """
        The status of nodes in a VirtualMachines agent pool.
        """
        return pulumi.get(self, "virtual_machine_nodes_status")

    @_builtins.property
    @pulumi.getter(name="virtualMachinesProfile")
    def virtual_machines_profile(self) -> Optional['outputs.VirtualMachinesProfileResponse']:
        """
        Specifications on VirtualMachines agent pool.
        """
        return pulumi.get(self, "virtual_machines_profile")

    @_builtins.property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[_builtins.str]:
        """
        The size of the agent pool VMs. VM size availability varies by region. If a node contains insufficient compute resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see: https://docs.microsoft.com/azure/aks/quotas-skus-regions
        """
        return pulumi.get(self, "vm_size")

    @_builtins.property
    @pulumi.getter(name="vnetSubnetID")
    def vnet_subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet which agent pool nodes and optionally pods will join on startup. If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        """
        return pulumi.get(self, "vnet_subnet_id")

    @_builtins.property
    @pulumi.getter(name="windowsProfile")
    def windows_profile(self) -> Optional['outputs.AgentPoolWindowsProfileResponse']:
        """
        The Windows agent pool's specific profile.
        """
        return pulumi.get(self, "windows_profile")

    @_builtins.property
    @pulumi.getter(name="workloadRuntime")
    def workload_runtime(self) -> Optional[_builtins.str]:
        """
        Determines the type of workload a node can run.
        """
        return pulumi.get(self, "workload_runtime")


@pulumi.output_type
class ManagedClusterAutoUpgradeProfileResponse(dict):
    """
    Auto upgrade profile for a managed cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeOSUpgradeChannel":
            suggest = "node_os_upgrade_channel"
        elif key == "upgradeChannel":
            suggest = "upgrade_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterAutoUpgradeProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterAutoUpgradeProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterAutoUpgradeProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_os_upgrade_channel: Optional[_builtins.str] = None,
                 upgrade_channel: Optional[_builtins.str] = None):
        """
        Auto upgrade profile for a managed cluster.
        :param _builtins.str node_os_upgrade_channel: Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is NodeImage.
        :param _builtins.str upgrade_channel: The upgrade channel for auto upgrade. The default is 'none'. For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        """
        if node_os_upgrade_channel is not None:
            pulumi.set(__self__, "node_os_upgrade_channel", node_os_upgrade_channel)
        if upgrade_channel is not None:
            pulumi.set(__self__, "upgrade_channel", upgrade_channel)

    @_builtins.property
    @pulumi.getter(name="nodeOSUpgradeChannel")
    def node_os_upgrade_channel(self) -> Optional[_builtins.str]:
        """
        Node OS Upgrade Channel. Manner in which the OS on your nodes is updated. The default is NodeImage.
        """
        return pulumi.get(self, "node_os_upgrade_channel")

    @_builtins.property
    @pulumi.getter(name="upgradeChannel")
    def upgrade_channel(self) -> Optional[_builtins.str]:
        """
        The upgrade channel for auto upgrade. The default is 'none'. For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        """
        return pulumi.get(self, "upgrade_channel")


@pulumi.output_type
class ManagedClusterAzureMonitorProfileKubeStateMetricsResponse(dict):
    """
    Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricAnnotationsAllowList":
            suggest = "metric_annotations_allow_list"
        elif key == "metricLabelsAllowlist":
            suggest = "metric_labels_allowlist"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterAzureMonitorProfileKubeStateMetricsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterAzureMonitorProfileKubeStateMetricsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterAzureMonitorProfileKubeStateMetricsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_annotations_allow_list: Optional[_builtins.str] = None,
                 metric_labels_allowlist: Optional[_builtins.str] = None):
        """
        Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for details.
        :param _builtins.str metric_annotations_allow_list: Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By default the metric contains only resource name and namespace labels.
        :param _builtins.str metric_labels_allowlist: Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default the metric contains only resource name and namespace labels.
        """
        if metric_annotations_allow_list is not None:
            pulumi.set(__self__, "metric_annotations_allow_list", metric_annotations_allow_list)
        if metric_labels_allowlist is not None:
            pulumi.set(__self__, "metric_labels_allowlist", metric_labels_allowlist)

    @_builtins.property
    @pulumi.getter(name="metricAnnotationsAllowList")
    def metric_annotations_allow_list(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By default the metric contains only resource name and namespace labels.
        """
        return pulumi.get(self, "metric_annotations_allow_list")

    @_builtins.property
    @pulumi.getter(name="metricLabelsAllowlist")
    def metric_labels_allowlist(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default the metric contains only resource name and namespace labels.
        """
        return pulumi.get(self, "metric_labels_allowlist")


@pulumi.output_type
class ManagedClusterAzureMonitorProfileMetricsResponse(dict):
    """
    Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See aka.ms/AzureManagedPrometheus for an overview.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeStateMetrics":
            suggest = "kube_state_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterAzureMonitorProfileMetricsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterAzureMonitorProfileMetricsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterAzureMonitorProfileMetricsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 kube_state_metrics: Optional['outputs.ManagedClusterAzureMonitorProfileKubeStateMetricsResponse'] = None):
        """
        Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See aka.ms/AzureManagedPrometheus for an overview.
        :param _builtins.bool enabled: Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling.
        :param 'ManagedClusterAzureMonitorProfileKubeStateMetricsResponse' kube_state_metrics: Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for details.
        """
        pulumi.set(__self__, "enabled", enabled)
        if kube_state_metrics is not None:
            pulumi.set(__self__, "kube_state_metrics", kube_state_metrics)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="kubeStateMetrics")
    def kube_state_metrics(self) -> Optional['outputs.ManagedClusterAzureMonitorProfileKubeStateMetricsResponse']:
        """
        Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the kube-state-metrics pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for details.
        """
        return pulumi.get(self, "kube_state_metrics")


@pulumi.output_type
class ManagedClusterAzureMonitorProfileResponse(dict):
    """
    Azure Monitor addon profiles for monitoring the managed cluster.
    """
    def __init__(__self__, *,
                 metrics: Optional['outputs.ManagedClusterAzureMonitorProfileMetricsResponse'] = None):
        """
        Azure Monitor addon profiles for monitoring the managed cluster.
        :param 'ManagedClusterAzureMonitorProfileMetricsResponse' metrics: Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See aka.ms/AzureManagedPrometheus for an overview.
        """
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.ManagedClusterAzureMonitorProfileMetricsResponse']:
        """
        Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes infrastructure metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See aka.ms/AzureManagedPrometheus for an overview.
        """
        return pulumi.get(self, "metrics")


@pulumi.output_type
class ManagedClusterBootstrapProfileResponse(dict):
    """
    The bootstrap profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactSource":
            suggest = "artifact_source"
        elif key == "containerRegistryId":
            suggest = "container_registry_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterBootstrapProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterBootstrapProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterBootstrapProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_source: Optional[_builtins.str] = None,
                 container_registry_id: Optional[_builtins.str] = None):
        """
        The bootstrap profile.
        :param _builtins.str artifact_source: The artifact source. The source where the artifacts are downloaded from.
        :param _builtins.str container_registry_id: The resource Id of Azure Container Registry. The registry must have private network access, premium SKU and zone redundancy.
        """
        if artifact_source is None:
            artifact_source = 'Direct'
        if artifact_source is not None:
            pulumi.set(__self__, "artifact_source", artifact_source)
        if container_registry_id is not None:
            pulumi.set(__self__, "container_registry_id", container_registry_id)

    @_builtins.property
    @pulumi.getter(name="artifactSource")
    def artifact_source(self) -> Optional[_builtins.str]:
        """
        The artifact source. The source where the artifacts are downloaded from.
        """
        return pulumi.get(self, "artifact_source")

    @_builtins.property
    @pulumi.getter(name="containerRegistryId")
    def container_registry_id(self) -> Optional[_builtins.str]:
        """
        The resource Id of Azure Container Registry. The registry must have private network access, premium SKU and zone redundancy.
        """
        return pulumi.get(self, "container_registry_id")


@pulumi.output_type
class ManagedClusterCostAnalysisResponse(dict):
    """
    The cost analysis configuration for the cluster
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        The cost analysis configuration for the cluster
        :param _builtins.bool enabled: Whether to enable cost analysis. The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal. If not specified, the default is false. For more information see aka.ms/aks/docs/cost-analysis.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable cost analysis. The Managed Cluster sku.tier must be set to 'Standard' or 'Premium' to enable this feature. Enabling this will add Kubernetes Namespace and Deployment details to the Cost Analysis views in the Azure portal. If not specified, the default is false. For more information see aka.ms/aks/docs/cost-analysis.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterHTTPProxyConfigResponse(dict):
    """
    Cluster HTTP proxy configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpProxy":
            suggest = "http_proxy"
        elif key == "httpsProxy":
            suggest = "https_proxy"
        elif key == "noProxy":
            suggest = "no_proxy"
        elif key == "trustedCa":
            suggest = "trusted_ca"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterHTTPProxyConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterHTTPProxyConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterHTTPProxyConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_proxy: Optional[_builtins.str] = None,
                 https_proxy: Optional[_builtins.str] = None,
                 no_proxy: Optional[Sequence[_builtins.str]] = None,
                 trusted_ca: Optional[_builtins.str] = None):
        """
        Cluster HTTP proxy configuration.
        :param _builtins.str http_proxy: The HTTP proxy server endpoint to use.
        :param _builtins.str https_proxy: The HTTPS proxy server endpoint to use.
        :param Sequence[_builtins.str] no_proxy: The endpoints that should not go through proxy.
        :param _builtins.str trusted_ca: Alternative CA cert to use for connecting to proxy servers.
        """
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)
        if trusted_ca is not None:
            pulumi.set(__self__, "trusted_ca", trusted_ca)

    @_builtins.property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[_builtins.str]:
        """
        The HTTP proxy server endpoint to use.
        """
        return pulumi.get(self, "http_proxy")

    @_builtins.property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[_builtins.str]:
        """
        The HTTPS proxy server endpoint to use.
        """
        return pulumi.get(self, "https_proxy")

    @_builtins.property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[Sequence[_builtins.str]]:
        """
        The endpoints that should not go through proxy.
        """
        return pulumi.get(self, "no_proxy")

    @_builtins.property
    @pulumi.getter(name="trustedCa")
    def trusted_ca(self) -> Optional[_builtins.str]:
        """
        Alternative CA cert to use for connecting to proxy servers.
        """
        return pulumi.get(self, "trusted_ca")


@pulumi.output_type
class ManagedClusterIdentityResponse(dict):
    """
    Identity for the managed cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "delegatedResources":
            suggest = "delegated_resources"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 delegated_resources: Optional[Mapping[str, 'outputs.DelegatedResourceResponse']] = None,
                 type: Optional[_builtins.str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.ManagedClusterIdentityResponseUserAssignedIdentities']] = None):
        """
        Identity for the managed cluster.
        :param _builtins.str principal_id: The principal id of the system assigned identity which is used by master components.
        :param _builtins.str tenant_id: The tenant id of the system assigned identity which is used by master components.
        :param Mapping[str, 'DelegatedResourceResponse'] delegated_resources: The delegated identity resources assigned to this managed cluster. This can only be set by another Azure Resource Provider, and managed cluster only accept one delegated identity resource. Internal use only.
        :param _builtins.str type: The type of identity used for the managed cluster. For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
        :param Mapping[str, 'ManagedClusterIdentityResponseUserAssignedIdentities'] user_assigned_identities: The user identity associated with the managed cluster. This identity will be used in control plane. Only one user assigned identity is allowed. The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if delegated_resources is not None:
            pulumi.set(__self__, "delegated_resources", delegated_resources)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal id of the system assigned identity which is used by master components.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant id of the system assigned identity which is used by master components.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="delegatedResources")
    def delegated_resources(self) -> Optional[Mapping[str, 'outputs.DelegatedResourceResponse']]:
        """
        The delegated identity resources assigned to this managed cluster. This can only be set by another Azure Resource Provider, and managed cluster only accept one delegated identity resource. Internal use only.
        """
        return pulumi.get(self, "delegated_resources")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of identity used for the managed cluster. For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.ManagedClusterIdentityResponseUserAssignedIdentities']]:
        """
        The user identity associated with the managed cluster. This identity will be used in control plane. Only one user assigned identity is allowed. The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ManagedClusterIdentityResponseUserAssignedIdentities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterIdentityResponseUserAssignedIdentities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        :param _builtins.str client_id: The client id of user assigned identity.
        :param _builtins.str principal_id: The principal id of user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class ManagedClusterIngressProfileNginxResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultIngressControllerType":
            suggest = "default_ingress_controller_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterIngressProfileNginxResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterIngressProfileNginxResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterIngressProfileNginxResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_ingress_controller_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_ingress_controller_type: Ingress type for the default NginxIngressController custom resource
        """
        if default_ingress_controller_type is not None:
            pulumi.set(__self__, "default_ingress_controller_type", default_ingress_controller_type)

    @_builtins.property
    @pulumi.getter(name="defaultIngressControllerType")
    def default_ingress_controller_type(self) -> Optional[_builtins.str]:
        """
        Ingress type for the default NginxIngressController custom resource
        """
        return pulumi.get(self, "default_ingress_controller_type")


@pulumi.output_type
class ManagedClusterIngressProfileResponse(dict):
    """
    Ingress profile for the container service cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webAppRouting":
            suggest = "web_app_routing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterIngressProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterIngressProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterIngressProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 web_app_routing: Optional['outputs.ManagedClusterIngressProfileWebAppRoutingResponse'] = None):
        """
        Ingress profile for the container service cluster.
        :param 'ManagedClusterIngressProfileWebAppRoutingResponse' web_app_routing: App Routing settings for the ingress profile. You can find an overview and onboarding guide for this feature at https://learn.microsoft.com/en-us/azure/aks/app-routing?tabs=default%2Cdeploy-app-default.
        """
        if web_app_routing is not None:
            pulumi.set(__self__, "web_app_routing", web_app_routing)

    @_builtins.property
    @pulumi.getter(name="webAppRouting")
    def web_app_routing(self) -> Optional['outputs.ManagedClusterIngressProfileWebAppRoutingResponse']:
        """
        App Routing settings for the ingress profile. You can find an overview and onboarding guide for this feature at https://learn.microsoft.com/en-us/azure/aks/app-routing?tabs=default%2Cdeploy-app-default.
        """
        return pulumi.get(self, "web_app_routing")


@pulumi.output_type
class ManagedClusterIngressProfileWebAppRoutingResponse(dict):
    """
    Application Routing add-on settings for the ingress profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsZoneResourceIds":
            suggest = "dns_zone_resource_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterIngressProfileWebAppRoutingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterIngressProfileWebAppRoutingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterIngressProfileWebAppRoutingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: 'outputs.UserAssignedIdentityResponse',
                 dns_zone_resource_ids: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 nginx: Optional['outputs.ManagedClusterIngressProfileNginxResponse'] = None):
        """
        Application Routing add-on settings for the ingress profile.
        :param 'UserAssignedIdentityResponse' identity: Managed identity of the Application Routing add-on. This is the identity that should be granted permissions, for example, to manage the associated Azure DNS resource and get certificates from Azure Key Vault. See [this overview of the add-on](https://learn.microsoft.com/en-us/azure/aks/web-app-routing?tabs=with-osm) for more instructions.
        :param Sequence[_builtins.str] dns_zone_resource_ids: Resource IDs of the DNS zones to be associated with the Application Routing add-on. Used only when Application Routing add-on is enabled. Public and private DNS zones can be in different resource groups, but all public DNS zones must be in the same resource group and all private DNS zones must be in the same resource group.
        :param _builtins.bool enabled: Whether to enable the Application Routing add-on.
        :param 'ManagedClusterIngressProfileNginxResponse' nginx: Configuration for the default NginxIngressController. See more at https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller.
        """
        pulumi.set(__self__, "identity", identity)
        if dns_zone_resource_ids is not None:
            pulumi.set(__self__, "dns_zone_resource_ids", dns_zone_resource_ids)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if nginx is not None:
            pulumi.set(__self__, "nginx", nginx)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> 'outputs.UserAssignedIdentityResponse':
        """
        Managed identity of the Application Routing add-on. This is the identity that should be granted permissions, for example, to manage the associated Azure DNS resource and get certificates from Azure Key Vault. See [this overview of the add-on](https://learn.microsoft.com/en-us/azure/aks/web-app-routing?tabs=with-osm) for more instructions.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter(name="dnsZoneResourceIds")
    def dns_zone_resource_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Resource IDs of the DNS zones to be associated with the Application Routing add-on. Used only when Application Routing add-on is enabled. Public and private DNS zones can be in different resource groups, but all public DNS zones must be in the same resource group and all private DNS zones must be in the same resource group.
        """
        return pulumi.get(self, "dns_zone_resource_ids")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable the Application Routing add-on.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def nginx(self) -> Optional['outputs.ManagedClusterIngressProfileNginxResponse']:
        """
        Configuration for the default NginxIngressController. See more at https://learn.microsoft.com/en-us/azure/aks/app-routing-nginx-configuration#the-default-nginx-ingress-controller.
        """
        return pulumi.get(self, "nginx")


@pulumi.output_type
class ManagedClusterLoadBalancerProfileResponse(dict):
    """
    Profile of the managed cluster load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveOutboundIPs":
            suggest = "effective_outbound_ips"
        elif key == "allocatedOutboundPorts":
            suggest = "allocated_outbound_ports"
        elif key == "backendPoolType":
            suggest = "backend_pool_type"
        elif key == "enableMultipleStandardLoadBalancers":
            suggest = "enable_multiple_standard_load_balancers"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "managedOutboundIPs":
            suggest = "managed_outbound_ips"
        elif key == "outboundIPPrefixes":
            suggest = "outbound_ip_prefixes"
        elif key == "outboundIPs":
            suggest = "outbound_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterLoadBalancerProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterLoadBalancerProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterLoadBalancerProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_outbound_ips: Sequence['outputs.ResourceReferenceResponse'],
                 allocated_outbound_ports: Optional[_builtins.int] = None,
                 backend_pool_type: Optional[_builtins.str] = None,
                 enable_multiple_standard_load_balancers: Optional[_builtins.bool] = None,
                 idle_timeout_in_minutes: Optional[_builtins.int] = None,
                 managed_outbound_ips: Optional['outputs.ManagedClusterLoadBalancerProfileResponseManagedOutboundIPs'] = None,
                 outbound_ip_prefixes: Optional['outputs.ManagedClusterLoadBalancerProfileResponseOutboundIPPrefixes'] = None,
                 outbound_ips: Optional['outputs.ManagedClusterLoadBalancerProfileResponseOutboundIPs'] = None):
        """
        Profile of the managed cluster load balancer.
        :param Sequence['ResourceReferenceResponse'] effective_outbound_ips: The effective outbound IP resources of the cluster load balancer.
        :param _builtins.int allocated_outbound_ports: The desired number of allocated SNAT ports per VM. Allowed values are in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
        :param _builtins.str backend_pool_type: The type of the managed inbound Load Balancer BackendPool.
        :param _builtins.bool enable_multiple_standard_load_balancers: Enable multiple standard load balancers per AKS cluster or not.
        :param _builtins.int idle_timeout_in_minutes: Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120 (inclusive). The default value is 30 minutes.
        :param 'ManagedClusterLoadBalancerProfileResponseManagedOutboundIPs' managed_outbound_ips: Desired managed outbound IPs for the cluster load balancer.
        :param 'ManagedClusterLoadBalancerProfileResponseOutboundIPPrefixes' outbound_ip_prefixes: Desired outbound IP Prefix resources for the cluster load balancer.
        :param 'ManagedClusterLoadBalancerProfileResponseOutboundIPs' outbound_ips: Desired outbound IP resources for the cluster load balancer.
        """
        pulumi.set(__self__, "effective_outbound_ips", effective_outbound_ips)
        if allocated_outbound_ports is None:
            allocated_outbound_ports = 0
        if allocated_outbound_ports is not None:
            pulumi.set(__self__, "allocated_outbound_ports", allocated_outbound_ports)
        if backend_pool_type is None:
            backend_pool_type = 'NodeIPConfiguration'
        if backend_pool_type is not None:
            pulumi.set(__self__, "backend_pool_type", backend_pool_type)
        if enable_multiple_standard_load_balancers is not None:
            pulumi.set(__self__, "enable_multiple_standard_load_balancers", enable_multiple_standard_load_balancers)
        if idle_timeout_in_minutes is None:
            idle_timeout_in_minutes = 30
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if managed_outbound_ips is not None:
            pulumi.set(__self__, "managed_outbound_ips", managed_outbound_ips)
        if outbound_ip_prefixes is not None:
            pulumi.set(__self__, "outbound_ip_prefixes", outbound_ip_prefixes)
        if outbound_ips is not None:
            pulumi.set(__self__, "outbound_ips", outbound_ips)

    @_builtins.property
    @pulumi.getter(name="effectiveOutboundIPs")
    def effective_outbound_ips(self) -> Sequence['outputs.ResourceReferenceResponse']:
        """
        The effective outbound IP resources of the cluster load balancer.
        """
        return pulumi.get(self, "effective_outbound_ips")

    @_builtins.property
    @pulumi.getter(name="allocatedOutboundPorts")
    def allocated_outbound_ports(self) -> Optional[_builtins.int]:
        """
        The desired number of allocated SNAT ports per VM. Allowed values are in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
        """
        return pulumi.get(self, "allocated_outbound_ports")

    @_builtins.property
    @pulumi.getter(name="backendPoolType")
    def backend_pool_type(self) -> Optional[_builtins.str]:
        """
        The type of the managed inbound Load Balancer BackendPool.
        """
        return pulumi.get(self, "backend_pool_type")

    @_builtins.property
    @pulumi.getter(name="enableMultipleStandardLoadBalancers")
    def enable_multiple_standard_load_balancers(self) -> Optional[_builtins.bool]:
        """
        Enable multiple standard load balancers per AKS cluster or not.
        """
        return pulumi.get(self, "enable_multiple_standard_load_balancers")

    @_builtins.property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120 (inclusive). The default value is 30 minutes.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="managedOutboundIPs")
    def managed_outbound_ips(self) -> Optional['outputs.ManagedClusterLoadBalancerProfileResponseManagedOutboundIPs']:
        """
        Desired managed outbound IPs for the cluster load balancer.
        """
        return pulumi.get(self, "managed_outbound_ips")

    @_builtins.property
    @pulumi.getter(name="outboundIPPrefixes")
    def outbound_ip_prefixes(self) -> Optional['outputs.ManagedClusterLoadBalancerProfileResponseOutboundIPPrefixes']:
        """
        Desired outbound IP Prefix resources for the cluster load balancer.
        """
        return pulumi.get(self, "outbound_ip_prefixes")

    @_builtins.property
    @pulumi.getter(name="outboundIPs")
    def outbound_ips(self) -> Optional['outputs.ManagedClusterLoadBalancerProfileResponseOutboundIPs']:
        """
        Desired outbound IP resources for the cluster load balancer.
        """
        return pulumi.get(self, "outbound_ips")


@pulumi.output_type
class ManagedClusterLoadBalancerProfileResponseManagedOutboundIPs(dict):
    """
    Desired managed outbound IPs for the cluster load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countIPv6":
            suggest = "count_i_pv6"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterLoadBalancerProfileResponseManagedOutboundIPs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterLoadBalancerProfileResponseManagedOutboundIPs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterLoadBalancerProfileResponseManagedOutboundIPs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None,
                 count_i_pv6: Optional[_builtins.int] = None):
        """
        Desired managed outbound IPs for the cluster load balancer.
        :param _builtins.int count: The desired number of IPv4 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1. 
        :param _builtins.int count_i_pv6: The desired number of IPv6 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack. 
        """
        if count is None:
            count = 1
        if count is not None:
            pulumi.set(__self__, "count", count)
        if count_i_pv6 is None:
            count_i_pv6 = 0
        if count_i_pv6 is not None:
            pulumi.set(__self__, "count_i_pv6", count_i_pv6)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        The desired number of IPv4 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1. 
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="countIPv6")
    def count_i_pv6(self) -> Optional[_builtins.int]:
        """
        The desired number of IPv6 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack. 
        """
        return pulumi.get(self, "count_i_pv6")


@pulumi.output_type
class ManagedClusterLoadBalancerProfileResponseOutboundIPPrefixes(dict):
    """
    Desired outbound IP Prefix resources for the cluster load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIPPrefixes":
            suggest = "public_ip_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterLoadBalancerProfileResponseOutboundIPPrefixes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterLoadBalancerProfileResponseOutboundIPPrefixes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterLoadBalancerProfileResponseOutboundIPPrefixes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ip_prefixes: Optional[Sequence['outputs.ResourceReferenceResponse']] = None):
        """
        Desired outbound IP Prefix resources for the cluster load balancer.
        :param Sequence['ResourceReferenceResponse'] public_ip_prefixes: A list of public IP prefix resources.
        """
        if public_ip_prefixes is not None:
            pulumi.set(__self__, "public_ip_prefixes", public_ip_prefixes)

    @_builtins.property
    @pulumi.getter(name="publicIPPrefixes")
    def public_ip_prefixes(self) -> Optional[Sequence['outputs.ResourceReferenceResponse']]:
        """
        A list of public IP prefix resources.
        """
        return pulumi.get(self, "public_ip_prefixes")


@pulumi.output_type
class ManagedClusterLoadBalancerProfileResponseOutboundIPs(dict):
    """
    Desired outbound IP resources for the cluster load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIPs":
            suggest = "public_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterLoadBalancerProfileResponseOutboundIPs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterLoadBalancerProfileResponseOutboundIPs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterLoadBalancerProfileResponseOutboundIPs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ips: Optional[Sequence['outputs.ResourceReferenceResponse']] = None):
        """
        Desired outbound IP resources for the cluster load balancer.
        :param Sequence['ResourceReferenceResponse'] public_ips: A list of public IP resources.
        """
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)

    @_builtins.property
    @pulumi.getter(name="publicIPs")
    def public_ips(self) -> Optional[Sequence['outputs.ResourceReferenceResponse']]:
        """
        A list of public IP resources.
        """
        return pulumi.get(self, "public_ips")


@pulumi.output_type
class ManagedClusterManagedOutboundIPProfileResponse(dict):
    """
    Profile of the managed outbound IP resources of the managed cluster.
    """
    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None):
        """
        Profile of the managed outbound IP resources of the managed cluster.
        :param _builtins.int count: The desired number of outbound IPs created/managed by Azure. Allowed values must be in the range of 1 to 16 (inclusive). The default value is 1. 
        """
        if count is None:
            count = 1
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        The desired number of outbound IPs created/managed by Azure. Allowed values must be in the range of 1 to 16 (inclusive). The default value is 1. 
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class ManagedClusterMetricsProfileResponse(dict):
    """
    The metrics profile for the ManagedCluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "costAnalysis":
            suggest = "cost_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterMetricsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterMetricsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterMetricsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cost_analysis: Optional['outputs.ManagedClusterCostAnalysisResponse'] = None):
        """
        The metrics profile for the ManagedCluster.
        :param 'ManagedClusterCostAnalysisResponse' cost_analysis: The configuration for detailed per-Kubernetes resource cost analysis.
        """
        if cost_analysis is not None:
            pulumi.set(__self__, "cost_analysis", cost_analysis)

    @_builtins.property
    @pulumi.getter(name="costAnalysis")
    def cost_analysis(self) -> Optional['outputs.ManagedClusterCostAnalysisResponse']:
        """
        The configuration for detailed per-Kubernetes resource cost analysis.
        """
        return pulumi.get(self, "cost_analysis")


@pulumi.output_type
class ManagedClusterNATGatewayProfileResponse(dict):
    """
    Profile of the managed cluster NAT gateway.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveOutboundIPs":
            suggest = "effective_outbound_ips"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "managedOutboundIPProfile":
            suggest = "managed_outbound_ip_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterNATGatewayProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterNATGatewayProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterNATGatewayProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_outbound_ips: Sequence['outputs.ResourceReferenceResponse'],
                 idle_timeout_in_minutes: Optional[_builtins.int] = None,
                 managed_outbound_ip_profile: Optional['outputs.ManagedClusterManagedOutboundIPProfileResponse'] = None):
        """
        Profile of the managed cluster NAT gateway.
        :param Sequence['ResourceReferenceResponse'] effective_outbound_ips: The effective outbound IP resources of the cluster NAT gateway.
        :param _builtins.int idle_timeout_in_minutes: Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120 (inclusive). The default value is 4 minutes.
        :param 'ManagedClusterManagedOutboundIPProfileResponse' managed_outbound_ip_profile: Profile of the managed outbound IP resources of the cluster NAT gateway.
        """
        pulumi.set(__self__, "effective_outbound_ips", effective_outbound_ips)
        if idle_timeout_in_minutes is None:
            idle_timeout_in_minutes = 4
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if managed_outbound_ip_profile is not None:
            pulumi.set(__self__, "managed_outbound_ip_profile", managed_outbound_ip_profile)

    @_builtins.property
    @pulumi.getter(name="effectiveOutboundIPs")
    def effective_outbound_ips(self) -> Sequence['outputs.ResourceReferenceResponse']:
        """
        The effective outbound IP resources of the cluster NAT gateway.
        """
        return pulumi.get(self, "effective_outbound_ips")

    @_builtins.property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120 (inclusive). The default value is 4 minutes.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @_builtins.property
    @pulumi.getter(name="managedOutboundIPProfile")
    def managed_outbound_ip_profile(self) -> Optional['outputs.ManagedClusterManagedOutboundIPProfileResponse']:
        """
        Profile of the managed outbound IP resources of the cluster NAT gateway.
        """
        return pulumi.get(self, "managed_outbound_ip_profile")


@pulumi.output_type
class ManagedClusterNodeProvisioningProfileResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultNodePools":
            suggest = "default_node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterNodeProvisioningProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterNodeProvisioningProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterNodeProvisioningProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_node_pools: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_node_pools: The set of default Karpenter NodePools (CRDs) configured for node provisioning. This field has no effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause the default Karpenter NodePools to be deleted, which will drain and delete the nodes associated with those pools. It is strongly recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If not specified, the default is Auto. For more information see aka.ms/aks/nap#node-pools.
        :param _builtins.str mode: The node provisioning mode. If not specified, the default is Manual.
        """
        if default_node_pools is None:
            default_node_pools = 'Auto'
        if default_node_pools is not None:
            pulumi.set(__self__, "default_node_pools", default_node_pools)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="defaultNodePools")
    def default_node_pools(self) -> Optional[_builtins.str]:
        """
        The set of default Karpenter NodePools (CRDs) configured for node provisioning. This field has no effect unless mode is 'Auto'. Warning: Changing this from Auto to None on an existing cluster will cause the default Karpenter NodePools to be deleted, which will drain and delete the nodes associated with those pools. It is strongly recommended to not do this unless there are idle nodes ready to take the pods evicted by that action. If not specified, the default is Auto. For more information see aka.ms/aks/nap#node-pools.
        """
        return pulumi.get(self, "default_node_pools")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The node provisioning mode. If not specified, the default is Manual.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ManagedClusterNodeResourceGroupProfileResponse(dict):
    """
    Node resource group lockdown profile for a managed cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionLevel":
            suggest = "restriction_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterNodeResourceGroupProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterNodeResourceGroupProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterNodeResourceGroupProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restriction_level: Optional[_builtins.str] = None):
        """
        Node resource group lockdown profile for a managed cluster.
        :param _builtins.str restriction_level: The restriction level applied to the cluster's node resource group. If not specified, the default is 'Unrestricted'
        """
        if restriction_level is not None:
            pulumi.set(__self__, "restriction_level", restriction_level)

    @_builtins.property
    @pulumi.getter(name="restrictionLevel")
    def restriction_level(self) -> Optional[_builtins.str]:
        """
        The restriction level applied to the cluster's node resource group. If not specified, the default is 'Unrestricted'
        """
        return pulumi.get(self, "restriction_level")


@pulumi.output_type
class ManagedClusterOIDCIssuerProfileResponse(dict):
    """
    The OIDC issuer profile of the Managed Cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuerURL":
            suggest = "issuer_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterOIDCIssuerProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterOIDCIssuerProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterOIDCIssuerProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issuer_url: _builtins.str,
                 enabled: Optional[_builtins.bool] = None):
        """
        The OIDC issuer profile of the Managed Cluster.
        :param _builtins.str issuer_url: The OIDC issuer url of the Managed Cluster.
        :param _builtins.bool enabled: Whether the OIDC issuer is enabled.
        """
        pulumi.set(__self__, "issuer_url", issuer_url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="issuerURL")
    def issuer_url(self) -> _builtins.str:
        """
        The OIDC issuer url of the Managed Cluster.
        """
        return pulumi.get(self, "issuer_url")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether the OIDC issuer is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterPodIdentityExceptionResponse(dict):
    """
    A pod identity exception, which allows pods with certain labels to access the Azure Instance Metadata Service (IMDS) endpoint without being intercepted by the node-managed identity (NMI) server. See [disable AAD Pod Identity for a specific Pod/Application](https://azure.github.io/aad-pod-identity/docs/configure/application_exception/) for more details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podLabels":
            suggest = "pod_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterPodIdentityExceptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterPodIdentityExceptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterPodIdentityExceptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 namespace: _builtins.str,
                 pod_labels: Mapping[str, _builtins.str]):
        """
        A pod identity exception, which allows pods with certain labels to access the Azure Instance Metadata Service (IMDS) endpoint without being intercepted by the node-managed identity (NMI) server. See [disable AAD Pod Identity for a specific Pod/Application](https://azure.github.io/aad-pod-identity/docs/configure/application_exception/) for more details.
        :param _builtins.str name: The name of the pod identity exception.
        :param _builtins.str namespace: The namespace of the pod identity exception.
        :param Mapping[str, _builtins.str] pod_labels: The pod labels to match.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "pod_labels", pod_labels)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the pod identity exception.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace of the pod identity exception.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="podLabels")
    def pod_labels(self) -> Mapping[str, _builtins.str]:
        """
        The pod labels to match.
        """
        return pulumi.get(self, "pod_labels")


@pulumi.output_type
class ManagedClusterPodIdentityProfileResponse(dict):
    """
    The pod identity profile of the Managed Cluster. See [use AAD pod identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on pod identity integration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowNetworkPluginKubenet":
            suggest = "allow_network_plugin_kubenet"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"
        elif key == "userAssignedIdentityExceptions":
            suggest = "user_assigned_identity_exceptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterPodIdentityProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterPodIdentityProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterPodIdentityProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_network_plugin_kubenet: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 user_assigned_identities: Optional[Sequence['outputs.ManagedClusterPodIdentityResponse']] = None,
                 user_assigned_identity_exceptions: Optional[Sequence['outputs.ManagedClusterPodIdentityExceptionResponse']] = None):
        """
        The pod identity profile of the Managed Cluster. See [use AAD pod identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on pod identity integration.
        :param _builtins.bool allow_network_plugin_kubenet: Whether pod identity is allowed to run on clusters with Kubenet networking. Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities) for more information.
        :param _builtins.bool enabled: Whether the pod identity addon is enabled.
        :param Sequence['ManagedClusterPodIdentityResponse'] user_assigned_identities: The pod identities to use in the cluster.
        :param Sequence['ManagedClusterPodIdentityExceptionResponse'] user_assigned_identity_exceptions: The pod identity exceptions to allow.
        """
        if allow_network_plugin_kubenet is not None:
            pulumi.set(__self__, "allow_network_plugin_kubenet", allow_network_plugin_kubenet)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)
        if user_assigned_identity_exceptions is not None:
            pulumi.set(__self__, "user_assigned_identity_exceptions", user_assigned_identity_exceptions)

    @_builtins.property
    @pulumi.getter(name="allowNetworkPluginKubenet")
    def allow_network_plugin_kubenet(self) -> Optional[_builtins.bool]:
        """
        Whether pod identity is allowed to run on clusters with Kubenet networking. Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities) for more information.
        """
        return pulumi.get(self, "allow_network_plugin_kubenet")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether the pod identity addon is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Sequence['outputs.ManagedClusterPodIdentityResponse']]:
        """
        The pod identities to use in the cluster.
        """
        return pulumi.get(self, "user_assigned_identities")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityExceptions")
    def user_assigned_identity_exceptions(self) -> Optional[Sequence['outputs.ManagedClusterPodIdentityExceptionResponse']]:
        """
        The pod identity exceptions to allow.
        """
        return pulumi.get(self, "user_assigned_identity_exceptions")


@pulumi.output_type
class ManagedClusterPodIdentityProvisioningErrorBodyResponse(dict):
    """
    An error response from the pod identity provisioning.
    """
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 details: Optional[Sequence['outputs.ManagedClusterPodIdentityProvisioningErrorBodyResponse']] = None,
                 message: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None):
        """
        An error response from the pod identity provisioning.
        :param _builtins.str code: An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
        :param Sequence['ManagedClusterPodIdentityProvisioningErrorBodyResponse'] details: A list of additional details about the error.
        :param _builtins.str message: A message describing the error, intended to be suitable for display in a user interface.
        :param _builtins.str target: The target of the particular error. For example, the name of the property in error.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.ManagedClusterPodIdentityProvisioningErrorBodyResponse']]:
        """
        A list of additional details about the error.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        A message describing the error, intended to be suitable for display in a user interface.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        The target of the particular error. For example, the name of the property in error.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ManagedClusterPodIdentityProvisioningErrorResponse(dict):
    """
    An error response from the pod identity provisioning.
    """
    def __init__(__self__, *,
                 error: Optional['outputs.ManagedClusterPodIdentityProvisioningErrorBodyResponse'] = None):
        """
        An error response from the pod identity provisioning.
        :param 'ManagedClusterPodIdentityProvisioningErrorBodyResponse' error: Details about the error.
        """
        if error is not None:
            pulumi.set(__self__, "error", error)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional['outputs.ManagedClusterPodIdentityProvisioningErrorBodyResponse']:
        """
        Details about the error.
        """
        return pulumi.get(self, "error")


@pulumi.output_type
class ManagedClusterPodIdentityResponse(dict):
    """
    Details about the pod identity assigned to the Managed Cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningInfo":
            suggest = "provisioning_info"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "bindingSelector":
            suggest = "binding_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterPodIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterPodIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterPodIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: 'outputs.UserAssignedIdentityResponse',
                 name: _builtins.str,
                 namespace: _builtins.str,
                 provisioning_info: 'outputs.ManagedClusterPodIdentityResponseProvisioningInfo',
                 provisioning_state: _builtins.str,
                 binding_selector: Optional[_builtins.str] = None):
        """
        Details about the pod identity assigned to the Managed Cluster.
        :param 'UserAssignedIdentityResponse' identity: The user assigned identity details.
        :param _builtins.str name: The name of the pod identity.
        :param _builtins.str namespace: The namespace of the pod identity.
        :param _builtins.str provisioning_state: The current provisioning state of the pod identity.
        :param _builtins.str binding_selector: The binding selector to use for the AzureIdentityBinding resource.
        """
        pulumi.set(__self__, "identity", identity)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "provisioning_info", provisioning_info)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if binding_selector is not None:
            pulumi.set(__self__, "binding_selector", binding_selector)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> 'outputs.UserAssignedIdentityResponse':
        """
        The user assigned identity details.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the pod identity.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace of the pod identity.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="provisioningInfo")
    def provisioning_info(self) -> 'outputs.ManagedClusterPodIdentityResponseProvisioningInfo':
        return pulumi.get(self, "provisioning_info")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The current provisioning state of the pod identity.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="bindingSelector")
    def binding_selector(self) -> Optional[_builtins.str]:
        """
        The binding selector to use for the AzureIdentityBinding resource.
        """
        return pulumi.get(self, "binding_selector")


@pulumi.output_type
class ManagedClusterPodIdentityResponseProvisioningInfo(dict):
    def __init__(__self__, *,
                 error: Optional['outputs.ManagedClusterPodIdentityProvisioningErrorResponse'] = None):
        """
        :param 'ManagedClusterPodIdentityProvisioningErrorResponse' error: Pod identity assignment error (if any).
        """
        if error is not None:
            pulumi.set(__self__, "error", error)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional['outputs.ManagedClusterPodIdentityProvisioningErrorResponse']:
        """
        Pod identity assignment error (if any).
        """
        return pulumi.get(self, "error")


@pulumi.output_type
class ManagedClusterPropertiesForSnapshotResponse(dict):
    """
    managed cluster properties for snapshot, these properties are read only.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkProfile":
            suggest = "network_profile"
        elif key == "enableRbac":
            suggest = "enable_rbac"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterPropertiesForSnapshotResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterPropertiesForSnapshotResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterPropertiesForSnapshotResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_profile: 'outputs.NetworkProfileForSnapshotResponse',
                 enable_rbac: Optional[_builtins.bool] = None,
                 kubernetes_version: Optional[_builtins.str] = None,
                 sku: Optional['outputs.ManagedClusterSKUResponse'] = None):
        """
        managed cluster properties for snapshot, these properties are read only.
        :param 'NetworkProfileForSnapshotResponse' network_profile: The current network profile.
        :param _builtins.bool enable_rbac: Whether the cluster has enabled Kubernetes Role-Based Access Control or not.
        :param _builtins.str kubernetes_version: The current kubernetes version.
        :param 'ManagedClusterSKUResponse' sku: The current managed cluster sku.
        """
        pulumi.set(__self__, "network_profile", network_profile)
        if enable_rbac is not None:
            pulumi.set(__self__, "enable_rbac", enable_rbac)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)

    @_builtins.property
    @pulumi.getter(name="networkProfile")
    def network_profile(self) -> 'outputs.NetworkProfileForSnapshotResponse':
        """
        The current network profile.
        """
        return pulumi.get(self, "network_profile")

    @_builtins.property
    @pulumi.getter(name="enableRbac")
    def enable_rbac(self) -> Optional[_builtins.bool]:
        """
        Whether the cluster has enabled Kubernetes Role-Based Access Control or not.
        """
        return pulumi.get(self, "enable_rbac")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        """
        The current kubernetes version.
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter
    def sku(self) -> Optional['outputs.ManagedClusterSKUResponse']:
        """
        The current managed cluster sku.
        """
        return pulumi.get(self, "sku")


@pulumi.output_type
class ManagedClusterPropertiesResponseAutoScalerProfile(dict):
    """
    Parameters to be applied to the cluster-autoscaler when enabled
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "balanceSimilarNodeGroups":
            suggest = "balance_similar_node_groups"
        elif key == "daemonsetEvictionForEmptyNodes":
            suggest = "daemonset_eviction_for_empty_nodes"
        elif key == "daemonsetEvictionForOccupiedNodes":
            suggest = "daemonset_eviction_for_occupied_nodes"
        elif key == "ignoreDaemonsetsUtilization":
            suggest = "ignore_daemonsets_utilization"
        elif key == "maxEmptyBulkDelete":
            suggest = "max_empty_bulk_delete"
        elif key == "maxGracefulTerminationSec":
            suggest = "max_graceful_termination_sec"
        elif key == "maxNodeProvisionTime":
            suggest = "max_node_provision_time"
        elif key == "maxTotalUnreadyPercentage":
            suggest = "max_total_unready_percentage"
        elif key == "newPodScaleUpDelay":
            suggest = "new_pod_scale_up_delay"
        elif key == "okTotalUnreadyCount":
            suggest = "ok_total_unready_count"
        elif key == "scaleDownDelayAfterAdd":
            suggest = "scale_down_delay_after_add"
        elif key == "scaleDownDelayAfterDelete":
            suggest = "scale_down_delay_after_delete"
        elif key == "scaleDownDelayAfterFailure":
            suggest = "scale_down_delay_after_failure"
        elif key == "scaleDownUnneededTime":
            suggest = "scale_down_unneeded_time"
        elif key == "scaleDownUnreadyTime":
            suggest = "scale_down_unready_time"
        elif key == "scaleDownUtilizationThreshold":
            suggest = "scale_down_utilization_threshold"
        elif key == "scanInterval":
            suggest = "scan_interval"
        elif key == "skipNodesWithLocalStorage":
            suggest = "skip_nodes_with_local_storage"
        elif key == "skipNodesWithSystemPods":
            suggest = "skip_nodes_with_system_pods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterPropertiesResponseAutoScalerProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterPropertiesResponseAutoScalerProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterPropertiesResponseAutoScalerProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 balance_similar_node_groups: Optional[_builtins.str] = None,
                 daemonset_eviction_for_empty_nodes: Optional[_builtins.bool] = None,
                 daemonset_eviction_for_occupied_nodes: Optional[_builtins.bool] = None,
                 expander: Optional[_builtins.str] = None,
                 ignore_daemonsets_utilization: Optional[_builtins.bool] = None,
                 max_empty_bulk_delete: Optional[_builtins.str] = None,
                 max_graceful_termination_sec: Optional[_builtins.str] = None,
                 max_node_provision_time: Optional[_builtins.str] = None,
                 max_total_unready_percentage: Optional[_builtins.str] = None,
                 new_pod_scale_up_delay: Optional[_builtins.str] = None,
                 ok_total_unready_count: Optional[_builtins.str] = None,
                 scale_down_delay_after_add: Optional[_builtins.str] = None,
                 scale_down_delay_after_delete: Optional[_builtins.str] = None,
                 scale_down_delay_after_failure: Optional[_builtins.str] = None,
                 scale_down_unneeded_time: Optional[_builtins.str] = None,
                 scale_down_unready_time: Optional[_builtins.str] = None,
                 scale_down_utilization_threshold: Optional[_builtins.str] = None,
                 scan_interval: Optional[_builtins.str] = None,
                 skip_nodes_with_local_storage: Optional[_builtins.str] = None,
                 skip_nodes_with_system_pods: Optional[_builtins.str] = None):
        """
        Parameters to be applied to the cluster-autoscaler when enabled
        :param _builtins.str balance_similar_node_groups: Detects similar node pools and balances the number of nodes between them. Valid values are 'true' and 'false'
        :param _builtins.bool daemonset_eviction_for_empty_nodes: DaemonSet pods will be gracefully terminated from empty nodes. If set to true, all daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.
        :param _builtins.bool daemonset_eviction_for_occupied_nodes: DaemonSet pods will be gracefully terminated from non-empty nodes. If set to true, all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.
        :param _builtins.str expander: The expander to use when scaling up. If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more information.
        :param _builtins.bool ignore_daemonsets_utilization: Should CA ignore DaemonSet pods when calculating resource utilization for scaling down. If set to true, the resources used by daemonset will be taken into account when making scaling down decisions.
        :param _builtins.str max_empty_bulk_delete: The maximum number of empty nodes that can be deleted at the same time. This must be a positive integer. The default is 10.
        :param _builtins.str max_graceful_termination_sec: The maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. The default is 600.
        :param _builtins.str max_node_provision_time: The maximum time the autoscaler waits for a node to be provisioned. The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        :param _builtins.str max_total_unready_percentage: The maximum percentage of unready nodes in the cluster. After this percentage is exceeded, cluster autoscaler halts operations. The default is 45. The maximum is 100 and the minimum is 0.
        :param _builtins.str new_pod_scale_up_delay: Ignore unscheduled pods before they're a certain age. For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        :param _builtins.str ok_total_unready_count: The number of allowed unready nodes, irrespective of max-total-unready-percentage. This must be an integer. The default is 3.
        :param _builtins.str scale_down_delay_after_add: How long after scale up that scale down evaluation resumes. The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        :param _builtins.str scale_down_delay_after_delete: How long after node deletion that scale down evaluation resumes. The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        :param _builtins.str scale_down_delay_after_failure: How long after scale down failure that scale down evaluation resumes. The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        :param _builtins.str scale_down_unneeded_time: How long a node should be unneeded before it is eligible for scale down. The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        :param _builtins.str scale_down_unready_time: How long an unready node should be unneeded before it is eligible for scale down. The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        :param _builtins.str scale_down_utilization_threshold: Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. The default is '0.5'.
        :param _builtins.str scan_interval: How often cluster is reevaluated for scale up or down. The default is '10'. Values must be an integer number of seconds.
        :param _builtins.str skip_nodes_with_local_storage: If cluster autoscaler will skip deleting nodes with pods with local storage, for example, EmptyDir or HostPath. The default is true.
        :param _builtins.str skip_nodes_with_system_pods: If cluster autoscaler will skip deleting nodes with pods from kube-system (except for DaemonSet or mirror pods). The default is true.
        """
        if balance_similar_node_groups is not None:
            pulumi.set(__self__, "balance_similar_node_groups", balance_similar_node_groups)
        if daemonset_eviction_for_empty_nodes is not None:
            pulumi.set(__self__, "daemonset_eviction_for_empty_nodes", daemonset_eviction_for_empty_nodes)
        if daemonset_eviction_for_occupied_nodes is not None:
            pulumi.set(__self__, "daemonset_eviction_for_occupied_nodes", daemonset_eviction_for_occupied_nodes)
        if expander is not None:
            pulumi.set(__self__, "expander", expander)
        if ignore_daemonsets_utilization is not None:
            pulumi.set(__self__, "ignore_daemonsets_utilization", ignore_daemonsets_utilization)
        if max_empty_bulk_delete is not None:
            pulumi.set(__self__, "max_empty_bulk_delete", max_empty_bulk_delete)
        if max_graceful_termination_sec is not None:
            pulumi.set(__self__, "max_graceful_termination_sec", max_graceful_termination_sec)
        if max_node_provision_time is not None:
            pulumi.set(__self__, "max_node_provision_time", max_node_provision_time)
        if max_total_unready_percentage is not None:
            pulumi.set(__self__, "max_total_unready_percentage", max_total_unready_percentage)
        if new_pod_scale_up_delay is not None:
            pulumi.set(__self__, "new_pod_scale_up_delay", new_pod_scale_up_delay)
        if ok_total_unready_count is not None:
            pulumi.set(__self__, "ok_total_unready_count", ok_total_unready_count)
        if scale_down_delay_after_add is not None:
            pulumi.set(__self__, "scale_down_delay_after_add", scale_down_delay_after_add)
        if scale_down_delay_after_delete is not None:
            pulumi.set(__self__, "scale_down_delay_after_delete", scale_down_delay_after_delete)
        if scale_down_delay_after_failure is not None:
            pulumi.set(__self__, "scale_down_delay_after_failure", scale_down_delay_after_failure)
        if scale_down_unneeded_time is not None:
            pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_unready_time is not None:
            pulumi.set(__self__, "scale_down_unready_time", scale_down_unready_time)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)
        if scan_interval is not None:
            pulumi.set(__self__, "scan_interval", scan_interval)
        if skip_nodes_with_local_storage is not None:
            pulumi.set(__self__, "skip_nodes_with_local_storage", skip_nodes_with_local_storage)
        if skip_nodes_with_system_pods is not None:
            pulumi.set(__self__, "skip_nodes_with_system_pods", skip_nodes_with_system_pods)

    @_builtins.property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> Optional[_builtins.str]:
        """
        Detects similar node pools and balances the number of nodes between them. Valid values are 'true' and 'false'
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @_builtins.property
    @pulumi.getter(name="daemonsetEvictionForEmptyNodes")
    def daemonset_eviction_for_empty_nodes(self) -> Optional[_builtins.bool]:
        """
        DaemonSet pods will be gracefully terminated from empty nodes. If set to true, all daemonset pods on empty nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.
        """
        return pulumi.get(self, "daemonset_eviction_for_empty_nodes")

    @_builtins.property
    @pulumi.getter(name="daemonsetEvictionForOccupiedNodes")
    def daemonset_eviction_for_occupied_nodes(self) -> Optional[_builtins.bool]:
        """
        DaemonSet pods will be gracefully terminated from non-empty nodes. If set to true, all daemonset pods on occupied nodes will be evicted before deletion of the node. If the daemonset pod cannot be evicted another node will be chosen for scaling. If set to false, the node will be deleted without ensuring that daemonset pods are deleted or evicted.
        """
        return pulumi.get(self, "daemonset_eviction_for_occupied_nodes")

    @_builtins.property
    @pulumi.getter
    def expander(self) -> Optional[_builtins.str]:
        """
        The expander to use when scaling up. If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more information.
        """
        return pulumi.get(self, "expander")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonsetsUtilization")
    def ignore_daemonsets_utilization(self) -> Optional[_builtins.bool]:
        """
        Should CA ignore DaemonSet pods when calculating resource utilization for scaling down. If set to true, the resources used by daemonset will be taken into account when making scaling down decisions.
        """
        return pulumi.get(self, "ignore_daemonsets_utilization")

    @_builtins.property
    @pulumi.getter(name="maxEmptyBulkDelete")
    def max_empty_bulk_delete(self) -> Optional[_builtins.str]:
        """
        The maximum number of empty nodes that can be deleted at the same time. This must be a positive integer. The default is 10.
        """
        return pulumi.get(self, "max_empty_bulk_delete")

    @_builtins.property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> Optional[_builtins.str]:
        """
        The maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. The default is 600.
        """
        return pulumi.get(self, "max_graceful_termination_sec")

    @_builtins.property
    @pulumi.getter(name="maxNodeProvisionTime")
    def max_node_provision_time(self) -> Optional[_builtins.str]:
        """
        The maximum time the autoscaler waits for a node to be provisioned. The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        """
        return pulumi.get(self, "max_node_provision_time")

    @_builtins.property
    @pulumi.getter(name="maxTotalUnreadyPercentage")
    def max_total_unready_percentage(self) -> Optional[_builtins.str]:
        """
        The maximum percentage of unready nodes in the cluster. After this percentage is exceeded, cluster autoscaler halts operations. The default is 45. The maximum is 100 and the minimum is 0.
        """
        return pulumi.get(self, "max_total_unready_percentage")

    @_builtins.property
    @pulumi.getter(name="newPodScaleUpDelay")
    def new_pod_scale_up_delay(self) -> Optional[_builtins.str]:
        """
        Ignore unscheduled pods before they're a certain age. For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        """
        return pulumi.get(self, "new_pod_scale_up_delay")

    @_builtins.property
    @pulumi.getter(name="okTotalUnreadyCount")
    def ok_total_unready_count(self) -> Optional[_builtins.str]:
        """
        The number of allowed unready nodes, irrespective of max-total-unready-percentage. This must be an integer. The default is 3.
        """
        return pulumi.get(self, "ok_total_unready_count")

    @_builtins.property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> Optional[_builtins.str]:
        """
        How long after scale up that scale down evaluation resumes. The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @_builtins.property
    @pulumi.getter(name="scaleDownDelayAfterDelete")
    def scale_down_delay_after_delete(self) -> Optional[_builtins.str]:
        """
        How long after node deletion that scale down evaluation resumes. The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        """
        return pulumi.get(self, "scale_down_delay_after_delete")

    @_builtins.property
    @pulumi.getter(name="scaleDownDelayAfterFailure")
    def scale_down_delay_after_failure(self) -> Optional[_builtins.str]:
        """
        How long after scale down failure that scale down evaluation resumes. The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        """
        return pulumi.get(self, "scale_down_delay_after_failure")

    @_builtins.property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[_builtins.str]:
        """
        How long a node should be unneeded before it is eligible for scale down. The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        """
        return pulumi.get(self, "scale_down_unneeded_time")

    @_builtins.property
    @pulumi.getter(name="scaleDownUnreadyTime")
    def scale_down_unready_time(self) -> Optional[_builtins.str]:
        """
        How long an unready node should be unneeded before it is eligible for scale down. The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        """
        return pulumi.get(self, "scale_down_unready_time")

    @_builtins.property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[_builtins.str]:
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. The default is '0.5'.
        """
        return pulumi.get(self, "scale_down_utilization_threshold")

    @_builtins.property
    @pulumi.getter(name="scanInterval")
    def scan_interval(self) -> Optional[_builtins.str]:
        """
        How often cluster is reevaluated for scale up or down. The default is '10'. Values must be an integer number of seconds.
        """
        return pulumi.get(self, "scan_interval")

    @_builtins.property
    @pulumi.getter(name="skipNodesWithLocalStorage")
    def skip_nodes_with_local_storage(self) -> Optional[_builtins.str]:
        """
        If cluster autoscaler will skip deleting nodes with pods with local storage, for example, EmptyDir or HostPath. The default is true.
        """
        return pulumi.get(self, "skip_nodes_with_local_storage")

    @_builtins.property
    @pulumi.getter(name="skipNodesWithSystemPods")
    def skip_nodes_with_system_pods(self) -> Optional[_builtins.str]:
        """
        If cluster autoscaler will skip deleting nodes with pods from kube-system (except for DaemonSet or mirror pods). The default is true.
        """
        return pulumi.get(self, "skip_nodes_with_system_pods")


@pulumi.output_type
class ManagedClusterSKUResponse(dict):
    """
    The SKU of a Managed Cluster.
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 tier: Optional[_builtins.str] = None):
        """
        The SKU of a Managed Cluster.
        :param _builtins.str name: The name of a managed cluster SKU.
        :param _builtins.str tier: If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of a managed cluster SKU.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class ManagedClusterSecurityProfileDefenderResponse(dict):
    """
    Microsoft Defender settings for the security profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsWorkspaceResourceId":
            suggest = "log_analytics_workspace_resource_id"
        elif key == "securityMonitoring":
            suggest = "security_monitoring"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterSecurityProfileDefenderResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterSecurityProfileDefenderResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterSecurityProfileDefenderResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_workspace_resource_id: Optional[_builtins.str] = None,
                 security_monitoring: Optional['outputs.ManagedClusterSecurityProfileDefenderSecurityMonitoringResponse'] = None):
        """
        Microsoft Defender settings for the security profile.
        :param _builtins.str log_analytics_workspace_resource_id: Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.
        :param 'ManagedClusterSecurityProfileDefenderSecurityMonitoringResponse' security_monitoring: Microsoft Defender threat detection for Cloud settings for the security profile.
        """
        if log_analytics_workspace_resource_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_resource_id", log_analytics_workspace_resource_id)
        if security_monitoring is not None:
            pulumi.set(__self__, "security_monitoring", security_monitoring)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceResourceId")
    def log_analytics_workspace_resource_id(self) -> Optional[_builtins.str]:
        """
        Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.
        """
        return pulumi.get(self, "log_analytics_workspace_resource_id")

    @_builtins.property
    @pulumi.getter(name="securityMonitoring")
    def security_monitoring(self) -> Optional['outputs.ManagedClusterSecurityProfileDefenderSecurityMonitoringResponse']:
        """
        Microsoft Defender threat detection for Cloud settings for the security profile.
        """
        return pulumi.get(self, "security_monitoring")


@pulumi.output_type
class ManagedClusterSecurityProfileDefenderSecurityMonitoringResponse(dict):
    """
    Microsoft Defender settings for the security profile threat detection.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Microsoft Defender settings for the security profile threat detection.
        :param _builtins.bool enabled: Whether to enable Defender threat detection
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Defender threat detection
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterSecurityProfileImageCleanerResponse(dict):
    """
    Image Cleaner removes unused images from nodes, freeing up disk space and helping to reduce attack surface area. Here are settings for the security profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalHours":
            suggest = "interval_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterSecurityProfileImageCleanerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterSecurityProfileImageCleanerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterSecurityProfileImageCleanerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 interval_hours: Optional[_builtins.int] = None):
        """
        Image Cleaner removes unused images from nodes, freeing up disk space and helping to reduce attack surface area. Here are settings for the security profile.
        :param _builtins.bool enabled: Whether to enable Image Cleaner on AKS cluster.
        :param _builtins.int interval_hours: Image Cleaner scanning interval in hours.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Image Cleaner on AKS cluster.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[_builtins.int]:
        """
        Image Cleaner scanning interval in hours.
        """
        return pulumi.get(self, "interval_hours")


@pulumi.output_type
class ManagedClusterSecurityProfileResponse(dict):
    """
    Security profile for the container service cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureKeyVaultKms":
            suggest = "azure_key_vault_kms"
        elif key == "customCATrustCertificates":
            suggest = "custom_ca_trust_certificates"
        elif key == "imageCleaner":
            suggest = "image_cleaner"
        elif key == "workloadIdentity":
            suggest = "workload_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterSecurityProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterSecurityProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterSecurityProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_key_vault_kms: Optional['outputs.AzureKeyVaultKmsResponse'] = None,
                 custom_ca_trust_certificates: Optional[Sequence[_builtins.str]] = None,
                 defender: Optional['outputs.ManagedClusterSecurityProfileDefenderResponse'] = None,
                 image_cleaner: Optional['outputs.ManagedClusterSecurityProfileImageCleanerResponse'] = None,
                 workload_identity: Optional['outputs.ManagedClusterSecurityProfileWorkloadIdentityResponse'] = None):
        """
        Security profile for the container service cluster.
        :param 'AzureKeyVaultKmsResponse' azure_key_vault_kms: Azure Key Vault [key management service](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/) settings for the security profile.
        :param Sequence[_builtins.str] custom_ca_trust_certificates: A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
        :param 'ManagedClusterSecurityProfileDefenderResponse' defender: Microsoft Defender settings for the security profile.
        :param 'ManagedClusterSecurityProfileImageCleanerResponse' image_cleaner: Image Cleaner settings for the security profile.
        :param 'ManagedClusterSecurityProfileWorkloadIdentityResponse' workload_identity: Workload identity settings for the security profile. Workload identity enables Kubernetes applications to access Azure cloud resources securely with Azure AD. See https://aka.ms/aks/wi for more details.
        """
        if azure_key_vault_kms is not None:
            pulumi.set(__self__, "azure_key_vault_kms", azure_key_vault_kms)
        if custom_ca_trust_certificates is not None:
            pulumi.set(__self__, "custom_ca_trust_certificates", custom_ca_trust_certificates)
        if defender is not None:
            pulumi.set(__self__, "defender", defender)
        if image_cleaner is not None:
            pulumi.set(__self__, "image_cleaner", image_cleaner)
        if workload_identity is not None:
            pulumi.set(__self__, "workload_identity", workload_identity)

    @_builtins.property
    @pulumi.getter(name="azureKeyVaultKms")
    def azure_key_vault_kms(self) -> Optional['outputs.AzureKeyVaultKmsResponse']:
        """
        Azure Key Vault [key management service](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/) settings for the security profile.
        """
        return pulumi.get(self, "azure_key_vault_kms")

    @_builtins.property
    @pulumi.getter(name="customCATrustCertificates")
    def custom_ca_trust_certificates(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of up to 10 base64 encoded CAs that will be added to the trust store on all nodes in the cluster. For more information see [Custom CA Trust Certificates](https://learn.microsoft.com/en-us/azure/aks/custom-certificate-authority).
        """
        return pulumi.get(self, "custom_ca_trust_certificates")

    @_builtins.property
    @pulumi.getter
    def defender(self) -> Optional['outputs.ManagedClusterSecurityProfileDefenderResponse']:
        """
        Microsoft Defender settings for the security profile.
        """
        return pulumi.get(self, "defender")

    @_builtins.property
    @pulumi.getter(name="imageCleaner")
    def image_cleaner(self) -> Optional['outputs.ManagedClusterSecurityProfileImageCleanerResponse']:
        """
        Image Cleaner settings for the security profile.
        """
        return pulumi.get(self, "image_cleaner")

    @_builtins.property
    @pulumi.getter(name="workloadIdentity")
    def workload_identity(self) -> Optional['outputs.ManagedClusterSecurityProfileWorkloadIdentityResponse']:
        """
        Workload identity settings for the security profile. Workload identity enables Kubernetes applications to access Azure cloud resources securely with Azure AD. See https://aka.ms/aks/wi for more details.
        """
        return pulumi.get(self, "workload_identity")


@pulumi.output_type
class ManagedClusterSecurityProfileWorkloadIdentityResponse(dict):
    """
    Workload identity settings for the security profile.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Workload identity settings for the security profile.
        :param _builtins.bool enabled: Whether to enable workload identity.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable workload identity.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterServicePrincipalProfileResponse(dict):
    """
    Information about a service principal identity for the cluster to use for manipulating Azure APIs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterServicePrincipalProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterServicePrincipalProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterServicePrincipalProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 secret: Optional[_builtins.str] = None):
        """
        Information about a service principal identity for the cluster to use for manipulating Azure APIs.
        :param _builtins.str client_id: The ID for the service principal.
        :param _builtins.str secret: The secret password associated with the service principal in plain text.
        """
        pulumi.set(__self__, "client_id", client_id)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The ID for the service principal.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        The secret password associated with the service principal in plain text.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ManagedClusterStaticEgressGatewayProfileResponse(dict):
    """
    The Static Egress Gateway addon configuration for the cluster.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        The Static Egress Gateway addon configuration for the cluster.
        :param _builtins.bool enabled: Enable Static Egress Gateway addon. Indicates if Static Egress Gateway addon is enabled or not.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable Static Egress Gateway addon. Indicates if Static Egress Gateway addon is enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterStatusResponse(dict):
    """
    Contains read-only information about the Managed Cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningError":
            suggest = "provisioning_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_error: 'outputs.ErrorDetailResponse'):
        """
        Contains read-only information about the Managed Cluster.
        :param 'ErrorDetailResponse' provisioning_error: The error details information of the managed cluster. Preserves the detailed info of failure. If there was no error, this field is omitted.
        """
        pulumi.set(__self__, "provisioning_error", provisioning_error)

    @_builtins.property
    @pulumi.getter(name="provisioningError")
    def provisioning_error(self) -> 'outputs.ErrorDetailResponse':
        """
        The error details information of the managed cluster. Preserves the detailed info of failure. If there was no error, this field is omitted.
        """
        return pulumi.get(self, "provisioning_error")


@pulumi.output_type
class ManagedClusterStorageProfileBlobCSIDriverResponse(dict):
    """
    AzureBlob CSI Driver settings for the storage profile.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        AzureBlob CSI Driver settings for the storage profile.
        :param _builtins.bool enabled: Whether to enable AzureBlob CSI Driver. The default value is false.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable AzureBlob CSI Driver. The default value is false.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterStorageProfileDiskCSIDriverResponse(dict):
    """
    AzureDisk CSI Driver settings for the storage profile.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        AzureDisk CSI Driver settings for the storage profile.
        :param _builtins.bool enabled: Whether to enable AzureDisk CSI Driver. The default value is true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable AzureDisk CSI Driver. The default value is true.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterStorageProfileFileCSIDriverResponse(dict):
    """
    AzureFile CSI Driver settings for the storage profile.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        AzureFile CSI Driver settings for the storage profile.
        :param _builtins.bool enabled: Whether to enable AzureFile CSI Driver. The default value is true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable AzureFile CSI Driver. The default value is true.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterStorageProfileResponse(dict):
    """
    Storage profile for the container service cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobCSIDriver":
            suggest = "blob_csi_driver"
        elif key == "diskCSIDriver":
            suggest = "disk_csi_driver"
        elif key == "fileCSIDriver":
            suggest = "file_csi_driver"
        elif key == "snapshotController":
            suggest = "snapshot_controller"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterStorageProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterStorageProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterStorageProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_csi_driver: Optional['outputs.ManagedClusterStorageProfileBlobCSIDriverResponse'] = None,
                 disk_csi_driver: Optional['outputs.ManagedClusterStorageProfileDiskCSIDriverResponse'] = None,
                 file_csi_driver: Optional['outputs.ManagedClusterStorageProfileFileCSIDriverResponse'] = None,
                 snapshot_controller: Optional['outputs.ManagedClusterStorageProfileSnapshotControllerResponse'] = None):
        """
        Storage profile for the container service cluster.
        :param 'ManagedClusterStorageProfileBlobCSIDriverResponse' blob_csi_driver: AzureBlob CSI Driver settings for the storage profile.
        :param 'ManagedClusterStorageProfileDiskCSIDriverResponse' disk_csi_driver: AzureDisk CSI Driver settings for the storage profile.
        :param 'ManagedClusterStorageProfileFileCSIDriverResponse' file_csi_driver: AzureFile CSI Driver settings for the storage profile.
        :param 'ManagedClusterStorageProfileSnapshotControllerResponse' snapshot_controller: Snapshot Controller settings for the storage profile.
        """
        if blob_csi_driver is not None:
            pulumi.set(__self__, "blob_csi_driver", blob_csi_driver)
        if disk_csi_driver is not None:
            pulumi.set(__self__, "disk_csi_driver", disk_csi_driver)
        if file_csi_driver is not None:
            pulumi.set(__self__, "file_csi_driver", file_csi_driver)
        if snapshot_controller is not None:
            pulumi.set(__self__, "snapshot_controller", snapshot_controller)

    @_builtins.property
    @pulumi.getter(name="blobCSIDriver")
    def blob_csi_driver(self) -> Optional['outputs.ManagedClusterStorageProfileBlobCSIDriverResponse']:
        """
        AzureBlob CSI Driver settings for the storage profile.
        """
        return pulumi.get(self, "blob_csi_driver")

    @_builtins.property
    @pulumi.getter(name="diskCSIDriver")
    def disk_csi_driver(self) -> Optional['outputs.ManagedClusterStorageProfileDiskCSIDriverResponse']:
        """
        AzureDisk CSI Driver settings for the storage profile.
        """
        return pulumi.get(self, "disk_csi_driver")

    @_builtins.property
    @pulumi.getter(name="fileCSIDriver")
    def file_csi_driver(self) -> Optional['outputs.ManagedClusterStorageProfileFileCSIDriverResponse']:
        """
        AzureFile CSI Driver settings for the storage profile.
        """
        return pulumi.get(self, "file_csi_driver")

    @_builtins.property
    @pulumi.getter(name="snapshotController")
    def snapshot_controller(self) -> Optional['outputs.ManagedClusterStorageProfileSnapshotControllerResponse']:
        """
        Snapshot Controller settings for the storage profile.
        """
        return pulumi.get(self, "snapshot_controller")


@pulumi.output_type
class ManagedClusterStorageProfileSnapshotControllerResponse(dict):
    """
    Snapshot Controller settings for the storage profile.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Snapshot Controller settings for the storage profile.
        :param _builtins.bool enabled: Whether to enable Snapshot Controller. The default value is true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Snapshot Controller. The default value is true.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterUpdateResponse(dict):
    """
    The update to be applied to the ManagedClusters.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeImageSelection":
            suggest = "node_image_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterUpdateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterUpdateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterUpdateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 upgrade: 'outputs.ManagedClusterUpgradeSpecResponse',
                 node_image_selection: Optional['outputs.NodeImageSelectionResponse'] = None):
        """
        The update to be applied to the ManagedClusters.
        :param 'ManagedClusterUpgradeSpecResponse' upgrade: The upgrade to apply to the ManagedClusters.
        :param 'NodeImageSelectionResponse' node_image_selection: The node image upgrade to be applied to the target nodes in update run.
        """
        pulumi.set(__self__, "upgrade", upgrade)
        if node_image_selection is not None:
            pulumi.set(__self__, "node_image_selection", node_image_selection)

    @_builtins.property
    @pulumi.getter
    def upgrade(self) -> 'outputs.ManagedClusterUpgradeSpecResponse':
        """
        The upgrade to apply to the ManagedClusters.
        """
        return pulumi.get(self, "upgrade")

    @_builtins.property
    @pulumi.getter(name="nodeImageSelection")
    def node_image_selection(self) -> Optional['outputs.NodeImageSelectionResponse']:
        """
        The node image upgrade to be applied to the target nodes in update run.
        """
        return pulumi.get(self, "node_image_selection")


@pulumi.output_type
class ManagedClusterUpgradeSpecResponse(dict):
    """
    The upgrade to apply to a ManagedCluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubernetesVersion":
            suggest = "kubernetes_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterUpgradeSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterUpgradeSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterUpgradeSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 kubernetes_version: Optional[_builtins.str] = None):
        """
        The upgrade to apply to a ManagedCluster.
        :param _builtins.str type: ManagedClusterUpgradeType is the type of upgrade to be applied.
        :param _builtins.str kubernetes_version: The Kubernetes version to upgrade the member clusters to.
        """
        pulumi.set(__self__, "type", type)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        ManagedClusterUpgradeType is the type of upgrade to be applied.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        """
        The Kubernetes version to upgrade the member clusters to.
        """
        return pulumi.get(self, "kubernetes_version")


@pulumi.output_type
class ManagedClusterWindowsProfileResponse(dict):
    """
    Profile for Windows VMs in the managed cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "adminPassword":
            suggest = "admin_password"
        elif key == "enableCSIProxy":
            suggest = "enable_csi_proxy"
        elif key == "gmsaProfile":
            suggest = "gmsa_profile"
        elif key == "licenseType":
            suggest = "license_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterWindowsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterWindowsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterWindowsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: _builtins.str,
                 admin_password: Optional[_builtins.str] = None,
                 enable_csi_proxy: Optional[_builtins.bool] = None,
                 gmsa_profile: Optional['outputs.WindowsGmsaProfileResponse'] = None,
                 license_type: Optional[_builtins.str] = None):
        """
        Profile for Windows VMs in the managed cluster.
        :param _builtins.str admin_username: Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        :param _builtins.str admin_password: Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\\W_]) <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        :param _builtins.bool enable_csi_proxy: Whether to enable CSI proxy. For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        :param 'WindowsGmsaProfileResponse' gmsa_profile: The Windows gMSA Profile in the Managed Cluster.
        :param _builtins.str license_type: The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if enable_csi_proxy is not None:
            pulumi.set(__self__, "enable_csi_proxy", enable_csi_proxy)
        if gmsa_profile is not None:
            pulumi.set(__self__, "gmsa_profile", gmsa_profile)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)

    @_builtins.property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> _builtins.str:
        """
        Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        """
        return pulumi.get(self, "admin_username")

    @_builtins.property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[_builtins.str]:
        """
        Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\\W_]) <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        """
        return pulumi.get(self, "admin_password")

    @_builtins.property
    @pulumi.getter(name="enableCSIProxy")
    def enable_csi_proxy(self) -> Optional[_builtins.bool]:
        """
        Whether to enable CSI proxy. For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        """
        return pulumi.get(self, "enable_csi_proxy")

    @_builtins.property
    @pulumi.getter(name="gmsaProfile")
    def gmsa_profile(self) -> Optional['outputs.WindowsGmsaProfileResponse']:
        """
        The Windows gMSA Profile in the Managed Cluster.
        """
        return pulumi.get(self, "gmsa_profile")

    @_builtins.property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[_builtins.str]:
        """
        The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.
        """
        return pulumi.get(self, "license_type")


@pulumi.output_type
class ManagedClusterWorkloadAutoScalerProfileKedaResponse(dict):
    """
    KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
    """
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
        :param _builtins.bool enabled: Whether to enable KEDA.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable KEDA.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedClusterWorkloadAutoScalerProfileResponse(dict):
    """
    Workload Auto-scaler profile for the managed cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verticalPodAutoscaler":
            suggest = "vertical_pod_autoscaler"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedClusterWorkloadAutoScalerProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedClusterWorkloadAutoScalerProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedClusterWorkloadAutoScalerProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keda: Optional['outputs.ManagedClusterWorkloadAutoScalerProfileKedaResponse'] = None,
                 vertical_pod_autoscaler: Optional['outputs.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscalerResponse'] = None):
        """
        Workload Auto-scaler profile for the managed cluster.
        :param 'ManagedClusterWorkloadAutoScalerProfileKedaResponse' keda: KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
        :param 'ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscalerResponse' vertical_pod_autoscaler: VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
        """
        if keda is not None:
            pulumi.set(__self__, "keda", keda)
        if vertical_pod_autoscaler is not None:
            pulumi.set(__self__, "vertical_pod_autoscaler", vertical_pod_autoscaler)

    @_builtins.property
    @pulumi.getter
    def keda(self) -> Optional['outputs.ManagedClusterWorkloadAutoScalerProfileKedaResponse']:
        """
        KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
        """
        return pulumi.get(self, "keda")

    @_builtins.property
    @pulumi.getter(name="verticalPodAutoscaler")
    def vertical_pod_autoscaler(self) -> Optional['outputs.ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscalerResponse']:
        """
        VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
        """
        return pulumi.get(self, "vertical_pod_autoscaler")


@pulumi.output_type
class ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscalerResponse(dict):
    """
    VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        VPA (Vertical Pod Autoscaler) settings for the workload auto-scaler profile.
        :param _builtins.bool enabled: Whether to enable VPA. Default value is false.
        """
        if enabled is None:
            enabled = False
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable VPA. Default value is false.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param _builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ManualScaleProfileResponse(dict):
    """
    Specifications on number of machines.
    """
    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None,
                 size: Optional[_builtins.str] = None):
        """
        Specifications on number of machines.
        :param _builtins.int count: Number of nodes.
        :param _builtins.str size: VM size that AKS will use when creating and scaling e.g. 'Standard_E4s_v3', 'Standard_E16s_v3' or 'Standard_D16s_v5'.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of nodes.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        VM size that AKS will use when creating and scaling e.g. 'Standard_E4s_v3', 'Standard_E16s_v3' or 'Standard_D16s_v5'.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class MemberUpdateStatusResponse(dict):
    """
    The status of a member update operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterResourceId":
            suggest = "cluster_resource_id"
        elif key == "operationId":
            suggest = "operation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemberUpdateStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemberUpdateStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemberUpdateStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_resource_id: _builtins.str,
                 message: _builtins.str,
                 name: _builtins.str,
                 operation_id: _builtins.str,
                 status: 'outputs.UpdateStatusResponse'):
        """
        The status of a member update operation.
        :param _builtins.str cluster_resource_id: The Azure resource id of the target Kubernetes cluster.
        :param _builtins.str message: The status message after processing the member update operation.
        :param _builtins.str name: The name of the FleetMember.
        :param _builtins.str operation_id: The operation resource id of the latest attempt to perform the operation.
        :param 'UpdateStatusResponse' status: The status of the MemberUpdate operation.
        """
        pulumi.set(__self__, "cluster_resource_id", cluster_resource_id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_id", operation_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="clusterResourceId")
    def cluster_resource_id(self) -> _builtins.str:
        """
        The Azure resource id of the target Kubernetes cluster.
        """
        return pulumi.get(self, "cluster_resource_id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The status message after processing the member update operation.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the FleetMember.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="operationId")
    def operation_id(self) -> _builtins.str:
        """
        The operation resource id of the latest attempt to perform the operation.
        """
        return pulumi.get(self, "operation_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.UpdateStatusResponse':
        """
        The status of the MemberUpdate operation.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class NamespacePropertiesResponse(dict):
    """
    Properties of a namespace managed by ARM
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "adoptionPolicy":
            suggest = "adoption_policy"
        elif key == "defaultNetworkPolicy":
            suggest = "default_network_policy"
        elif key == "defaultResourceQuota":
            suggest = "default_resource_quota"
        elif key == "deletePolicy":
            suggest = "delete_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespacePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespacePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespacePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 adoption_policy: Optional[_builtins.str] = None,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 default_network_policy: Optional['outputs.NetworkPoliciesResponse'] = None,
                 default_resource_quota: Optional['outputs.ResourceQuotaResponse'] = None,
                 delete_policy: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None):
        """
        Properties of a namespace managed by ARM
        :param _builtins.str provisioning_state: The current provisioning state of the namespace.
        :param _builtins.str adoption_policy: Action if Kubernetes namespace with same name already exists.
        :param Mapping[str, _builtins.str] annotations: The annotations of managed namespace.
        :param 'NetworkPoliciesResponse' default_network_policy: The default network policy enforced upon the namespace. Customers can have other Kubernetes network policy objects under the namespace. All the network policies will be enforced.
        :param 'ResourceQuotaResponse' default_resource_quota: The default resource quota enforced upon the namespace. Customers can have other Kubernetes resource quota objects under the namespace. All the resource quotas will be enforced.
        :param _builtins.str delete_policy: Delete options of a namespace.
        :param Mapping[str, _builtins.str] labels: The labels of managed namespace.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if adoption_policy is not None:
            pulumi.set(__self__, "adoption_policy", adoption_policy)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if default_network_policy is not None:
            pulumi.set(__self__, "default_network_policy", default_network_policy)
        if default_resource_quota is not None:
            pulumi.set(__self__, "default_resource_quota", default_resource_quota)
        if delete_policy is not None:
            pulumi.set(__self__, "delete_policy", delete_policy)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The current provisioning state of the namespace.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="adoptionPolicy")
    def adoption_policy(self) -> Optional[_builtins.str]:
        """
        Action if Kubernetes namespace with same name already exists.
        """
        return pulumi.get(self, "adoption_policy")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The annotations of managed namespace.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="defaultNetworkPolicy")
    def default_network_policy(self) -> Optional['outputs.NetworkPoliciesResponse']:
        """
        The default network policy enforced upon the namespace. Customers can have other Kubernetes network policy objects under the namespace. All the network policies will be enforced.
        """
        return pulumi.get(self, "default_network_policy")

    @_builtins.property
    @pulumi.getter(name="defaultResourceQuota")
    def default_resource_quota(self) -> Optional['outputs.ResourceQuotaResponse']:
        """
        The default resource quota enforced upon the namespace. Customers can have other Kubernetes resource quota objects under the namespace. All the resource quotas will be enforced.
        """
        return pulumi.get(self, "default_resource_quota")

    @_builtins.property
    @pulumi.getter(name="deletePolicy")
    def delete_policy(self) -> Optional[_builtins.str]:
        """
        Delete options of a namespace.
        """
        return pulumi.get(self, "delete_policy")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The labels of managed namespace.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class NetworkPoliciesResponse(dict):
    """
    Default network policy of the namespace, specifying ingress and egress rules.
    """
    def __init__(__self__, *,
                 egress: Optional[_builtins.str] = None,
                 ingress: Optional[_builtins.str] = None):
        """
        Default network policy of the namespace, specifying ingress and egress rules.
        :param _builtins.str egress: Egress policy for the network.
        :param _builtins.str ingress: Ingress policy for the network.
        """
        if egress is None:
            egress = 'AllowAll'
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ingress is None:
            ingress = 'AllowSameNamespace'
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[_builtins.str]:
        """
        Egress policy for the network.
        """
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional[_builtins.str]:
        """
        Ingress policy for the network.
        """
        return pulumi.get(self, "ingress")


@pulumi.output_type
class NetworkProfileForSnapshotResponse(dict):
    """
    network profile for managed cluster snapshot, these properties are read only.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "networkMode":
            suggest = "network_mode"
        elif key == "networkPlugin":
            suggest = "network_plugin"
        elif key == "networkPluginMode":
            suggest = "network_plugin_mode"
        elif key == "networkPolicy":
            suggest = "network_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkProfileForSnapshotResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkProfileForSnapshotResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkProfileForSnapshotResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_balancer_sku: Optional[_builtins.str] = None,
                 network_mode: Optional[_builtins.str] = None,
                 network_plugin: Optional[_builtins.str] = None,
                 network_plugin_mode: Optional[_builtins.str] = None,
                 network_policy: Optional[_builtins.str] = None):
        """
        network profile for managed cluster snapshot, these properties are read only.
        :param _builtins.str load_balancer_sku: loadBalancerSku for managed cluster snapshot.
        :param _builtins.str network_mode: networkMode for managed cluster snapshot.
        :param _builtins.str network_plugin: networkPlugin for managed cluster snapshot.
        :param _builtins.str network_plugin_mode: NetworkPluginMode for managed cluster snapshot.
        :param _builtins.str network_policy: networkPolicy for managed cluster snapshot.
        """
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if network_plugin is not None:
            pulumi.set(__self__, "network_plugin", network_plugin)
        if network_plugin_mode is not None:
            pulumi.set(__self__, "network_plugin_mode", network_plugin_mode)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[_builtins.str]:
        """
        loadBalancerSku for managed cluster snapshot.
        """
        return pulumi.get(self, "load_balancer_sku")

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[_builtins.str]:
        """
        networkMode for managed cluster snapshot.
        """
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> Optional[_builtins.str]:
        """
        networkPlugin for managed cluster snapshot.
        """
        return pulumi.get(self, "network_plugin")

    @_builtins.property
    @pulumi.getter(name="networkPluginMode")
    def network_plugin_mode(self) -> Optional[_builtins.str]:
        """
        NetworkPluginMode for managed cluster snapshot.
        """
        return pulumi.get(self, "network_plugin_mode")

    @_builtins.property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional[_builtins.str]:
        """
        networkPolicy for managed cluster snapshot.
        """
        return pulumi.get(self, "network_policy")


@pulumi.output_type
class NodeCustomizationPropertiesResponse(dict):
    """
    The properties of the Node Customization resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "containerImages":
            suggest = "container_images"
        elif key == "customizationScripts":
            suggest = "customization_scripts"
        elif key == "identityProfile":
            suggest = "identity_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeCustomizationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeCustomizationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeCustomizationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 version: _builtins.str,
                 container_images: Optional[Sequence[_builtins.str]] = None,
                 customization_scripts: Optional[Sequence['outputs.NodeCustomizationScriptResponse']] = None,
                 identity_profile: Optional['outputs.UserAssignedIdentityResponse'] = None):
        """
        The properties of the Node Customization resource.
        :param _builtins.str provisioning_state: The provisioning state of the node customization.
        :param _builtins.str version: An auto-generated value that changes when the other fields of the image customization are changed.
        :param Sequence[_builtins.str] container_images: The list of container images to cache on nodes. See https://kubernetes.io/docs/concepts/containers/images/#image-names
        :param Sequence['NodeCustomizationScriptResponse'] customization_scripts: The scripts to customize the node before or after image capture.
        :param 'UserAssignedIdentityResponse' identity_profile: The identity used to execute node customization tasks during image build time and provisioning time. 
               If not specified the default agentpool identity will be used.
               This does not affect provisioned nodes.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "version", version)
        if container_images is not None:
            pulumi.set(__self__, "container_images", container_images)
        if customization_scripts is not None:
            pulumi.set(__self__, "customization_scripts", customization_scripts)
        if identity_profile is not None:
            pulumi.set(__self__, "identity_profile", identity_profile)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the node customization.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        An auto-generated value that changes when the other fields of the image customization are changed.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="containerImages")
    def container_images(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of container images to cache on nodes. See https://kubernetes.io/docs/concepts/containers/images/#image-names
        """
        return pulumi.get(self, "container_images")

    @_builtins.property
    @pulumi.getter(name="customizationScripts")
    def customization_scripts(self) -> Optional[Sequence['outputs.NodeCustomizationScriptResponse']]:
        """
        The scripts to customize the node before or after image capture.
        """
        return pulumi.get(self, "customization_scripts")

    @_builtins.property
    @pulumi.getter(name="identityProfile")
    def identity_profile(self) -> Optional['outputs.UserAssignedIdentityResponse']:
        """
        The identity used to execute node customization tasks during image build time and provisioning time. 
        If not specified the default agentpool identity will be used.
        This does not affect provisioned nodes.
        """
        return pulumi.get(self, "identity_profile")


@pulumi.output_type
class NodeCustomizationScriptResponse(dict):
    """
    Node customization script
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionPoint":
            suggest = "execution_point"
        elif key == "scriptType":
            suggest = "script_type"
        elif key == "rebootAfter":
            suggest = "reboot_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeCustomizationScriptResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeCustomizationScriptResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeCustomizationScriptResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_point: _builtins.str,
                 name: _builtins.str,
                 script_type: _builtins.str,
                 reboot_after: Optional[_builtins.bool] = None,
                 script: Optional[_builtins.str] = None):
        """
        Node customization script
        :param _builtins.str execution_point: The stage at which the script is executed.
               Specifying `NodeImageBuildTime` will ensure changes are persisted into the node image.
        :param _builtins.str name: The name for the customization script. 
               Must be unique within the node customization resource.
               Can only contain lowercase alphanumeric,'-' or '.' characters.
        :param _builtins.str script_type: The runtime environment for the script (e.g. Bash).
        :param _builtins.bool reboot_after: Whether the node should reboot after successful script execution.
        :param _builtins.str script: The script content to be executed in plain text. Do not include secrets.
        """
        pulumi.set(__self__, "execution_point", execution_point)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "script_type", script_type)
        if reboot_after is not None:
            pulumi.set(__self__, "reboot_after", reboot_after)
        if script is not None:
            pulumi.set(__self__, "script", script)

    @_builtins.property
    @pulumi.getter(name="executionPoint")
    def execution_point(self) -> _builtins.str:
        """
        The stage at which the script is executed.
        Specifying `NodeImageBuildTime` will ensure changes are persisted into the node image.
        """
        return pulumi.get(self, "execution_point")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name for the customization script. 
        Must be unique within the node customization resource.
        Can only contain lowercase alphanumeric,'-' or '.' characters.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="scriptType")
    def script_type(self) -> _builtins.str:
        """
        The runtime environment for the script (e.g. Bash).
        """
        return pulumi.get(self, "script_type")

    @_builtins.property
    @pulumi.getter(name="rebootAfter")
    def reboot_after(self) -> Optional[_builtins.bool]:
        """
        Whether the node should reboot after successful script execution.
        """
        return pulumi.get(self, "reboot_after")

    @_builtins.property
    @pulumi.getter
    def script(self) -> Optional[_builtins.str]:
        """
        The script content to be executed in plain text. Do not include secrets.
        """
        return pulumi.get(self, "script")


@pulumi.output_type
class NodeImageSelectionResponse(dict):
    """
    The node image upgrade to be applied to the target nodes in update run.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customNodeImageVersions":
            suggest = "custom_node_image_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeImageSelectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeImageSelectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeImageSelectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 custom_node_image_versions: Optional[Sequence['outputs.NodeImageVersionResponse']] = None):
        """
        The node image upgrade to be applied to the target nodes in update run.
        :param _builtins.str type: The node image upgrade type.
        :param Sequence['NodeImageVersionResponse'] custom_node_image_versions: Custom node image versions to upgrade the nodes to. This field is required if node image selection type is Custom. Otherwise, it must be empty. For each node image family (e.g., 'AKSUbuntu-1804gen2containerd'), this field can contain at most one version (e.g., only one of 'AKSUbuntu-1804gen2containerd-2023.01.12' or 'AKSUbuntu-1804gen2containerd-2023.02.12', not both). If the nodes belong to a family without a matching image version in this field, they are not upgraded.
        """
        pulumi.set(__self__, "type", type)
        if custom_node_image_versions is not None:
            pulumi.set(__self__, "custom_node_image_versions", custom_node_image_versions)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The node image upgrade type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="customNodeImageVersions")
    def custom_node_image_versions(self) -> Optional[Sequence['outputs.NodeImageVersionResponse']]:
        """
        Custom node image versions to upgrade the nodes to. This field is required if node image selection type is Custom. Otherwise, it must be empty. For each node image family (e.g., 'AKSUbuntu-1804gen2containerd'), this field can contain at most one version (e.g., only one of 'AKSUbuntu-1804gen2containerd-2023.01.12' or 'AKSUbuntu-1804gen2containerd-2023.02.12', not both). If the nodes belong to a family without a matching image version in this field, they are not upgraded.
        """
        return pulumi.get(self, "custom_node_image_versions")


@pulumi.output_type
class NodeImageSelectionStatusResponse(dict):
    """
    The node image upgrade specs for the update run.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedNodeImageVersions":
            suggest = "selected_node_image_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeImageSelectionStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeImageSelectionStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeImageSelectionStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_node_image_versions: Sequence['outputs.NodeImageVersionResponse']):
        """
        The node image upgrade specs for the update run.
        :param Sequence['NodeImageVersionResponse'] selected_node_image_versions: The image versions to upgrade the nodes to.
        """
        pulumi.set(__self__, "selected_node_image_versions", selected_node_image_versions)

    @_builtins.property
    @pulumi.getter(name="selectedNodeImageVersions")
    def selected_node_image_versions(self) -> Sequence['outputs.NodeImageVersionResponse']:
        """
        The image versions to upgrade the nodes to.
        """
        return pulumi.get(self, "selected_node_image_versions")


@pulumi.output_type
class NodeImageVersionResponse(dict):
    """
    The node upgrade image version.
    """
    def __init__(__self__, *,
                 version: _builtins.str):
        """
        The node upgrade image version.
        :param _builtins.str version: The image version to upgrade the nodes to (e.g., 'AKSUbuntu-1804gen2containerd-2022.12.13').
        """
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The image version to upgrade the nodes to (e.g., 'AKSUbuntu-1804gen2containerd-2022.12.13').
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class PortRangeResponse(dict):
    """
    The port range.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portEnd":
            suggest = "port_end"
        elif key == "portStart":
            suggest = "port_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortRangeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortRangeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortRangeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_end: Optional[_builtins.int] = None,
                 port_start: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        The port range.
        :param _builtins.int port_end: The maximum port that is included in the range. It should be ranged from 1 to 65535, and be greater than or equal to portStart.
        :param _builtins.int port_start: The minimum port that is included in the range. It should be ranged from 1 to 65535, and be less than or equal to portEnd.
        :param _builtins.str protocol: The network protocol of the port.
        """
        if port_end is not None:
            pulumi.set(__self__, "port_end", port_end)
        if port_start is not None:
            pulumi.set(__self__, "port_start", port_start)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="portEnd")
    def port_end(self) -> Optional[_builtins.int]:
        """
        The maximum port that is included in the range. It should be ranged from 1 to 65535, and be greater than or equal to portStart.
        """
        return pulumi.get(self, "port_end")

    @_builtins.property
    @pulumi.getter(name="portStart")
    def port_start(self) -> Optional[_builtins.int]:
        """
        The minimum port that is included in the range. It should be ranged from 1 to 65535, and be less than or equal to portEnd.
        """
        return pulumi.get(self, "port_start")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The network protocol of the port.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class PowerStateResponse(dict):
    """
    Describes the Power State of the cluster
    """
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None):
        """
        Describes the Power State of the cluster
        :param _builtins.str code: Tells whether the cluster is Running or Stopped
        """
        if code is not None:
            pulumi.set(__self__, "code", code)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        Tells whether the cluster is Running or Stopped
        """
        return pulumi.get(self, "code")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    Private endpoint which a connection belongs to.
    """
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        Private endpoint which a connection belongs to.
        :param _builtins.str id: The resource ID of the private endpoint
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The resource ID of the private endpoint
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkResourceResponse(dict):
    """
    A private link resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkServiceID":
            suggest = "private_link_service_id"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "requiredMembers":
            suggest = "required_members"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_link_service_id: _builtins.str,
                 group_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 required_members: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        """
        A private link resource
        :param _builtins.str private_link_service_id: The private link service ID of the resource, this field is exposed only to NRP internally.
        :param _builtins.str group_id: The group ID of the resource.
        :param _builtins.str id: The ID of the private link resource.
        :param _builtins.str name: The name of the private link resource.
        :param Sequence[_builtins.str] required_members: The RequiredMembers of the resource
        :param _builtins.str type: The resource type.
        """
        pulumi.set(__self__, "private_link_service_id", private_link_service_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required_members is not None:
            pulumi.set(__self__, "required_members", required_members)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceID")
    def private_link_service_id(self) -> _builtins.str:
        """
        The private link service ID of the resource, this field is exposed only to NRP internally.
        """
        return pulumi.get(self, "private_link_service_id")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        """
        The group ID of the resource.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the private link resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the private link resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="requiredMembers")
    def required_members(self) -> Optional[Sequence[_builtins.str]]:
        """
        The RequiredMembers of the resource
        """
        return pulumi.get(self, "required_members")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The resource type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    The state of a private link service connection.
    """
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        The state of a private link service connection.
        :param _builtins.str description: The private link service connection description.
        :param _builtins.str status: The private link service connection status.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The private link service connection description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The private link service connection status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RelativeMonthlyScheduleResponse(dict):
    """
    For schedules like: 'recur every month on the first Monday' or 'recur every 3 months on last Friday'.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "intervalMonths":
            suggest = "interval_months"
        elif key == "weekIndex":
            suggest = "week_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RelativeMonthlyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RelativeMonthlyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RelativeMonthlyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: _builtins.str,
                 interval_months: _builtins.int,
                 week_index: _builtins.str):
        """
        For schedules like: 'recur every month on the first Monday' or 'recur every 3 months on last Friday'.
        :param _builtins.str day_of_week: Specifies on which day of the week the maintenance occurs.
        :param _builtins.int interval_months: Specifies the number of months between each set of occurrences.
        :param _builtins.str week_index: The week index. Specifies on which week of the month the dayOfWeek applies.
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "interval_months", interval_months)
        pulumi.set(__self__, "week_index", week_index)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> _builtins.str:
        """
        Specifies on which day of the week the maintenance occurs.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="intervalMonths")
    def interval_months(self) -> _builtins.int:
        """
        Specifies the number of months between each set of occurrences.
        """
        return pulumi.get(self, "interval_months")

    @_builtins.property
    @pulumi.getter(name="weekIndex")
    def week_index(self) -> _builtins.str:
        """
        The week index. Specifies on which week of the month the dayOfWeek applies.
        """
        return pulumi.get(self, "week_index")


@pulumi.output_type
class ResourceQuotaResponse(dict):
    """
    Resource quota for the namespace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceQuotaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceQuotaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceQuotaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_limit: Optional[_builtins.str] = None,
                 cpu_request: Optional[_builtins.str] = None,
                 memory_limit: Optional[_builtins.str] = None,
                 memory_request: Optional[_builtins.str] = None):
        """
        Resource quota for the namespace.
        :param _builtins.str cpu_limit: CPU limit of the namespace in one-thousandth CPU form. See [CPU resource units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu) for more details.
        :param _builtins.str cpu_request: CPU request of the namespace in one-thousandth CPU form. See [CPU resource units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu) for more details.
        :param _builtins.str memory_limit: Memory limit of the namespace in the power-of-two equivalents form: Ei, Pi, Ti, Gi, Mi, Ki. See [Memory resource units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory) for more details.
        :param _builtins.str memory_request: Memory request of the namespace in the power-of-two equivalents form: Ei, Pi, Ti, Gi, Mi, Ki. See [Memory resource units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory) for more details.
        """
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @_builtins.property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[_builtins.str]:
        """
        CPU limit of the namespace in one-thousandth CPU form. See [CPU resource units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu) for more details.
        """
        return pulumi.get(self, "cpu_limit")

    @_builtins.property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[_builtins.str]:
        """
        CPU request of the namespace in one-thousandth CPU form. See [CPU resource units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu) for more details.
        """
        return pulumi.get(self, "cpu_request")

    @_builtins.property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[_builtins.str]:
        """
        Memory limit of the namespace in the power-of-two equivalents form: Ei, Pi, Ti, Gi, Mi, Ki. See [Memory resource units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory) for more details.
        """
        return pulumi.get(self, "memory_limit")

    @_builtins.property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[_builtins.str]:
        """
        Memory request of the namespace in the power-of-two equivalents form: Ei, Pi, Ti, Gi, Mi, Ki. See [Memory resource units](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-memory) for more details.
        """
        return pulumi.get(self, "memory_request")


@pulumi.output_type
class ResourceReferenceResponse(dict):
    """
    A reference to an Azure resource.
    """
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        A reference to an Azure resource.
        :param _builtins.str id: The fully qualified Azure resource id.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The fully qualified Azure resource id.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ScaleProfileResponse(dict):
    """
    Specifications on how to scale a VirtualMachines agent pool.
    """
    def __init__(__self__, *,
                 manual: Optional[Sequence['outputs.ManualScaleProfileResponse']] = None):
        """
        Specifications on how to scale a VirtualMachines agent pool.
        :param Sequence['ManualScaleProfileResponse'] manual: Specifications on how to scale the VirtualMachines agent pool to a fixed size.
        """
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @_builtins.property
    @pulumi.getter
    def manual(self) -> Optional[Sequence['outputs.ManualScaleProfileResponse']]:
        """
        Specifications on how to scale the VirtualMachines agent pool to a fixed size.
        """
        return pulumi.get(self, "manual")


@pulumi.output_type
class ScheduleResponse(dict):
    """
    One and only one of the schedule types should be specified. Choose either 'daily', 'weekly', 'absoluteMonthly' or 'relativeMonthly' for your maintenance schedule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteMonthly":
            suggest = "absolute_monthly"
        elif key == "relativeMonthly":
            suggest = "relative_monthly"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_monthly: Optional['outputs.AbsoluteMonthlyScheduleResponse'] = None,
                 daily: Optional['outputs.DailyScheduleResponse'] = None,
                 relative_monthly: Optional['outputs.RelativeMonthlyScheduleResponse'] = None,
                 weekly: Optional['outputs.WeeklyScheduleResponse'] = None):
        """
        One and only one of the schedule types should be specified. Choose either 'daily', 'weekly', 'absoluteMonthly' or 'relativeMonthly' for your maintenance schedule.
        :param 'AbsoluteMonthlyScheduleResponse' absolute_monthly: For schedules like: 'recur every month on the 15th' or 'recur every 3 months on the 20th'.
        :param 'DailyScheduleResponse' daily: For schedules like: 'recur every day' or 'recur every 3 days'.
        :param 'RelativeMonthlyScheduleResponse' relative_monthly: For schedules like: 'recur every month on the first Monday' or 'recur every 3 months on last Friday'.
        :param 'WeeklyScheduleResponse' weekly: For schedules like: 'recur every Monday' or 'recur every 3 weeks on Wednesday'.
        """
        if absolute_monthly is not None:
            pulumi.set(__self__, "absolute_monthly", absolute_monthly)
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if relative_monthly is not None:
            pulumi.set(__self__, "relative_monthly", relative_monthly)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter(name="absoluteMonthly")
    def absolute_monthly(self) -> Optional['outputs.AbsoluteMonthlyScheduleResponse']:
        """
        For schedules like: 'recur every month on the 15th' or 'recur every 3 months on the 20th'.
        """
        return pulumi.get(self, "absolute_monthly")

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional['outputs.DailyScheduleResponse']:
        """
        For schedules like: 'recur every day' or 'recur every 3 days'.
        """
        return pulumi.get(self, "daily")

    @_builtins.property
    @pulumi.getter(name="relativeMonthly")
    def relative_monthly(self) -> Optional['outputs.RelativeMonthlyScheduleResponse']:
        """
        For schedules like: 'recur every month on the first Monday' or 'recur every 3 months on last Friday'.
        """
        return pulumi.get(self, "relative_monthly")

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional['outputs.WeeklyScheduleResponse']:
        """
        For schedules like: 'recur every Monday' or 'recur every 3 weeks on Wednesday'.
        """
        return pulumi.get(self, "weekly")


@pulumi.output_type
class ServiceMeshProfileResponse(dict):
    """
    Service mesh profile for a managed cluster.
    """
    def __init__(__self__, *,
                 mode: _builtins.str,
                 istio: Optional['outputs.IstioServiceMeshResponse'] = None):
        """
        Service mesh profile for a managed cluster.
        :param _builtins.str mode: Mode of the service mesh.
        :param 'IstioServiceMeshResponse' istio: Istio service mesh configuration.
        """
        pulumi.set(__self__, "mode", mode)
        if istio is not None:
            pulumi.set(__self__, "istio", istio)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mode of the service mesh.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def istio(self) -> Optional['outputs.IstioServiceMeshResponse']:
        """
        Istio service mesh configuration.
        """
        return pulumi.get(self, "istio")


@pulumi.output_type
class SysctlConfigResponse(dict):
    """
    Sysctl settings for Linux agent nodes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fsAioMaxNr":
            suggest = "fs_aio_max_nr"
        elif key == "fsFileMax":
            suggest = "fs_file_max"
        elif key == "fsInotifyMaxUserWatches":
            suggest = "fs_inotify_max_user_watches"
        elif key == "fsNrOpen":
            suggest = "fs_nr_open"
        elif key == "kernelThreadsMax":
            suggest = "kernel_threads_max"
        elif key == "netCoreNetdevMaxBacklog":
            suggest = "net_core_netdev_max_backlog"
        elif key == "netCoreOptmemMax":
            suggest = "net_core_optmem_max"
        elif key == "netCoreRmemDefault":
            suggest = "net_core_rmem_default"
        elif key == "netCoreRmemMax":
            suggest = "net_core_rmem_max"
        elif key == "netCoreSomaxconn":
            suggest = "net_core_somaxconn"
        elif key == "netCoreWmemDefault":
            suggest = "net_core_wmem_default"
        elif key == "netCoreWmemMax":
            suggest = "net_core_wmem_max"
        elif key == "netIpv4IpLocalPortRange":
            suggest = "net_ipv4_ip_local_port_range"
        elif key == "netIpv4NeighDefaultGcThresh1":
            suggest = "net_ipv4_neigh_default_gc_thresh1"
        elif key == "netIpv4NeighDefaultGcThresh2":
            suggest = "net_ipv4_neigh_default_gc_thresh2"
        elif key == "netIpv4NeighDefaultGcThresh3":
            suggest = "net_ipv4_neigh_default_gc_thresh3"
        elif key == "netIpv4TcpFinTimeout":
            suggest = "net_ipv4_tcp_fin_timeout"
        elif key == "netIpv4TcpKeepaliveProbes":
            suggest = "net_ipv4_tcp_keepalive_probes"
        elif key == "netIpv4TcpKeepaliveTime":
            suggest = "net_ipv4_tcp_keepalive_time"
        elif key == "netIpv4TcpMaxSynBacklog":
            suggest = "net_ipv4_tcp_max_syn_backlog"
        elif key == "netIpv4TcpMaxTwBuckets":
            suggest = "net_ipv4_tcp_max_tw_buckets"
        elif key == "netIpv4TcpTwReuse":
            suggest = "net_ipv4_tcp_tw_reuse"
        elif key == "netIpv4TcpkeepaliveIntvl":
            suggest = "net_ipv4_tcpkeepalive_intvl"
        elif key == "netNetfilterNfConntrackBuckets":
            suggest = "net_netfilter_nf_conntrack_buckets"
        elif key == "netNetfilterNfConntrackMax":
            suggest = "net_netfilter_nf_conntrack_max"
        elif key == "vmMaxMapCount":
            suggest = "vm_max_map_count"
        elif key == "vmSwappiness":
            suggest = "vm_swappiness"
        elif key == "vmVfsCachePressure":
            suggest = "vm_vfs_cache_pressure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SysctlConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SysctlConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SysctlConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fs_aio_max_nr: Optional[_builtins.int] = None,
                 fs_file_max: Optional[_builtins.int] = None,
                 fs_inotify_max_user_watches: Optional[_builtins.int] = None,
                 fs_nr_open: Optional[_builtins.int] = None,
                 kernel_threads_max: Optional[_builtins.int] = None,
                 net_core_netdev_max_backlog: Optional[_builtins.int] = None,
                 net_core_optmem_max: Optional[_builtins.int] = None,
                 net_core_rmem_default: Optional[_builtins.int] = None,
                 net_core_rmem_max: Optional[_builtins.int] = None,
                 net_core_somaxconn: Optional[_builtins.int] = None,
                 net_core_wmem_default: Optional[_builtins.int] = None,
                 net_core_wmem_max: Optional[_builtins.int] = None,
                 net_ipv4_ip_local_port_range: Optional[_builtins.str] = None,
                 net_ipv4_neigh_default_gc_thresh1: Optional[_builtins.int] = None,
                 net_ipv4_neigh_default_gc_thresh2: Optional[_builtins.int] = None,
                 net_ipv4_neigh_default_gc_thresh3: Optional[_builtins.int] = None,
                 net_ipv4_tcp_fin_timeout: Optional[_builtins.int] = None,
                 net_ipv4_tcp_keepalive_probes: Optional[_builtins.int] = None,
                 net_ipv4_tcp_keepalive_time: Optional[_builtins.int] = None,
                 net_ipv4_tcp_max_syn_backlog: Optional[_builtins.int] = None,
                 net_ipv4_tcp_max_tw_buckets: Optional[_builtins.int] = None,
                 net_ipv4_tcp_tw_reuse: Optional[_builtins.bool] = None,
                 net_ipv4_tcpkeepalive_intvl: Optional[_builtins.int] = None,
                 net_netfilter_nf_conntrack_buckets: Optional[_builtins.int] = None,
                 net_netfilter_nf_conntrack_max: Optional[_builtins.int] = None,
                 vm_max_map_count: Optional[_builtins.int] = None,
                 vm_swappiness: Optional[_builtins.int] = None,
                 vm_vfs_cache_pressure: Optional[_builtins.int] = None):
        """
        Sysctl settings for Linux agent nodes.
        :param _builtins.int fs_aio_max_nr: Sysctl setting fs.aio-max-nr.
        :param _builtins.int fs_file_max: Sysctl setting fs.file-max.
        :param _builtins.int fs_inotify_max_user_watches: Sysctl setting fs.inotify.max_user_watches.
        :param _builtins.int fs_nr_open: Sysctl setting fs.nr_open.
        :param _builtins.int kernel_threads_max: Sysctl setting kernel.threads-max.
        :param _builtins.int net_core_netdev_max_backlog: Sysctl setting net.core.netdev_max_backlog.
        :param _builtins.int net_core_optmem_max: Sysctl setting net.core.optmem_max.
        :param _builtins.int net_core_rmem_default: Sysctl setting net.core.rmem_default.
        :param _builtins.int net_core_rmem_max: Sysctl setting net.core.rmem_max.
        :param _builtins.int net_core_somaxconn: Sysctl setting net.core.somaxconn.
        :param _builtins.int net_core_wmem_default: Sysctl setting net.core.wmem_default.
        :param _builtins.int net_core_wmem_max: Sysctl setting net.core.wmem_max.
        :param _builtins.str net_ipv4_ip_local_port_range: Sysctl setting net.ipv4.ip_local_port_range.
        :param _builtins.int net_ipv4_neigh_default_gc_thresh1: Sysctl setting net.ipv4.neigh.default.gc_thresh1.
        :param _builtins.int net_ipv4_neigh_default_gc_thresh2: Sysctl setting net.ipv4.neigh.default.gc_thresh2.
        :param _builtins.int net_ipv4_neigh_default_gc_thresh3: Sysctl setting net.ipv4.neigh.default.gc_thresh3.
        :param _builtins.int net_ipv4_tcp_fin_timeout: Sysctl setting net.ipv4.tcp_fin_timeout.
        :param _builtins.int net_ipv4_tcp_keepalive_probes: Sysctl setting net.ipv4.tcp_keepalive_probes.
        :param _builtins.int net_ipv4_tcp_keepalive_time: Sysctl setting net.ipv4.tcp_keepalive_time.
        :param _builtins.int net_ipv4_tcp_max_syn_backlog: Sysctl setting net.ipv4.tcp_max_syn_backlog.
        :param _builtins.int net_ipv4_tcp_max_tw_buckets: Sysctl setting net.ipv4.tcp_max_tw_buckets.
        :param _builtins.bool net_ipv4_tcp_tw_reuse: Sysctl setting net.ipv4.tcp_tw_reuse.
        :param _builtins.int net_ipv4_tcpkeepalive_intvl: Sysctl setting net.ipv4.tcp_keepalive_intvl.
        :param _builtins.int net_netfilter_nf_conntrack_buckets: Sysctl setting net.netfilter.nf_conntrack_buckets.
        :param _builtins.int net_netfilter_nf_conntrack_max: Sysctl setting net.netfilter.nf_conntrack_max.
        :param _builtins.int vm_max_map_count: Sysctl setting vm.max_map_count.
        :param _builtins.int vm_swappiness: Sysctl setting vm.swappiness.
        :param _builtins.int vm_vfs_cache_pressure: Sysctl setting vm.vfs_cache_pressure.
        """
        if fs_aio_max_nr is not None:
            pulumi.set(__self__, "fs_aio_max_nr", fs_aio_max_nr)
        if fs_file_max is not None:
            pulumi.set(__self__, "fs_file_max", fs_file_max)
        if fs_inotify_max_user_watches is not None:
            pulumi.set(__self__, "fs_inotify_max_user_watches", fs_inotify_max_user_watches)
        if fs_nr_open is not None:
            pulumi.set(__self__, "fs_nr_open", fs_nr_open)
        if kernel_threads_max is not None:
            pulumi.set(__self__, "kernel_threads_max", kernel_threads_max)
        if net_core_netdev_max_backlog is not None:
            pulumi.set(__self__, "net_core_netdev_max_backlog", net_core_netdev_max_backlog)
        if net_core_optmem_max is not None:
            pulumi.set(__self__, "net_core_optmem_max", net_core_optmem_max)
        if net_core_rmem_default is not None:
            pulumi.set(__self__, "net_core_rmem_default", net_core_rmem_default)
        if net_core_rmem_max is not None:
            pulumi.set(__self__, "net_core_rmem_max", net_core_rmem_max)
        if net_core_somaxconn is not None:
            pulumi.set(__self__, "net_core_somaxconn", net_core_somaxconn)
        if net_core_wmem_default is not None:
            pulumi.set(__self__, "net_core_wmem_default", net_core_wmem_default)
        if net_core_wmem_max is not None:
            pulumi.set(__self__, "net_core_wmem_max", net_core_wmem_max)
        if net_ipv4_ip_local_port_range is not None:
            pulumi.set(__self__, "net_ipv4_ip_local_port_range", net_ipv4_ip_local_port_range)
        if net_ipv4_neigh_default_gc_thresh1 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh1", net_ipv4_neigh_default_gc_thresh1)
        if net_ipv4_neigh_default_gc_thresh2 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh2", net_ipv4_neigh_default_gc_thresh2)
        if net_ipv4_neigh_default_gc_thresh3 is not None:
            pulumi.set(__self__, "net_ipv4_neigh_default_gc_thresh3", net_ipv4_neigh_default_gc_thresh3)
        if net_ipv4_tcp_fin_timeout is not None:
            pulumi.set(__self__, "net_ipv4_tcp_fin_timeout", net_ipv4_tcp_fin_timeout)
        if net_ipv4_tcp_keepalive_probes is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_probes", net_ipv4_tcp_keepalive_probes)
        if net_ipv4_tcp_keepalive_time is not None:
            pulumi.set(__self__, "net_ipv4_tcp_keepalive_time", net_ipv4_tcp_keepalive_time)
        if net_ipv4_tcp_max_syn_backlog is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_syn_backlog", net_ipv4_tcp_max_syn_backlog)
        if net_ipv4_tcp_max_tw_buckets is not None:
            pulumi.set(__self__, "net_ipv4_tcp_max_tw_buckets", net_ipv4_tcp_max_tw_buckets)
        if net_ipv4_tcp_tw_reuse is not None:
            pulumi.set(__self__, "net_ipv4_tcp_tw_reuse", net_ipv4_tcp_tw_reuse)
        if net_ipv4_tcpkeepalive_intvl is not None:
            pulumi.set(__self__, "net_ipv4_tcpkeepalive_intvl", net_ipv4_tcpkeepalive_intvl)
        if net_netfilter_nf_conntrack_buckets is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_buckets", net_netfilter_nf_conntrack_buckets)
        if net_netfilter_nf_conntrack_max is not None:
            pulumi.set(__self__, "net_netfilter_nf_conntrack_max", net_netfilter_nf_conntrack_max)
        if vm_max_map_count is not None:
            pulumi.set(__self__, "vm_max_map_count", vm_max_map_count)
        if vm_swappiness is not None:
            pulumi.set(__self__, "vm_swappiness", vm_swappiness)
        if vm_vfs_cache_pressure is not None:
            pulumi.set(__self__, "vm_vfs_cache_pressure", vm_vfs_cache_pressure)

    @_builtins.property
    @pulumi.getter(name="fsAioMaxNr")
    def fs_aio_max_nr(self) -> Optional[_builtins.int]:
        """
        Sysctl setting fs.aio-max-nr.
        """
        return pulumi.get(self, "fs_aio_max_nr")

    @_builtins.property
    @pulumi.getter(name="fsFileMax")
    def fs_file_max(self) -> Optional[_builtins.int]:
        """
        Sysctl setting fs.file-max.
        """
        return pulumi.get(self, "fs_file_max")

    @_builtins.property
    @pulumi.getter(name="fsInotifyMaxUserWatches")
    def fs_inotify_max_user_watches(self) -> Optional[_builtins.int]:
        """
        Sysctl setting fs.inotify.max_user_watches.
        """
        return pulumi.get(self, "fs_inotify_max_user_watches")

    @_builtins.property
    @pulumi.getter(name="fsNrOpen")
    def fs_nr_open(self) -> Optional[_builtins.int]:
        """
        Sysctl setting fs.nr_open.
        """
        return pulumi.get(self, "fs_nr_open")

    @_builtins.property
    @pulumi.getter(name="kernelThreadsMax")
    def kernel_threads_max(self) -> Optional[_builtins.int]:
        """
        Sysctl setting kernel.threads-max.
        """
        return pulumi.get(self, "kernel_threads_max")

    @_builtins.property
    @pulumi.getter(name="netCoreNetdevMaxBacklog")
    def net_core_netdev_max_backlog(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.core.netdev_max_backlog.
        """
        return pulumi.get(self, "net_core_netdev_max_backlog")

    @_builtins.property
    @pulumi.getter(name="netCoreOptmemMax")
    def net_core_optmem_max(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.core.optmem_max.
        """
        return pulumi.get(self, "net_core_optmem_max")

    @_builtins.property
    @pulumi.getter(name="netCoreRmemDefault")
    def net_core_rmem_default(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.core.rmem_default.
        """
        return pulumi.get(self, "net_core_rmem_default")

    @_builtins.property
    @pulumi.getter(name="netCoreRmemMax")
    def net_core_rmem_max(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.core.rmem_max.
        """
        return pulumi.get(self, "net_core_rmem_max")

    @_builtins.property
    @pulumi.getter(name="netCoreSomaxconn")
    def net_core_somaxconn(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.core.somaxconn.
        """
        return pulumi.get(self, "net_core_somaxconn")

    @_builtins.property
    @pulumi.getter(name="netCoreWmemDefault")
    def net_core_wmem_default(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.core.wmem_default.
        """
        return pulumi.get(self, "net_core_wmem_default")

    @_builtins.property
    @pulumi.getter(name="netCoreWmemMax")
    def net_core_wmem_max(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.core.wmem_max.
        """
        return pulumi.get(self, "net_core_wmem_max")

    @_builtins.property
    @pulumi.getter(name="netIpv4IpLocalPortRange")
    def net_ipv4_ip_local_port_range(self) -> Optional[_builtins.str]:
        """
        Sysctl setting net.ipv4.ip_local_port_range.
        """
        return pulumi.get(self, "net_ipv4_ip_local_port_range")

    @_builtins.property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh1")
    def net_ipv4_neigh_default_gc_thresh1(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.ipv4.neigh.default.gc_thresh1.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh1")

    @_builtins.property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh2")
    def net_ipv4_neigh_default_gc_thresh2(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.ipv4.neigh.default.gc_thresh2.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh2")

    @_builtins.property
    @pulumi.getter(name="netIpv4NeighDefaultGcThresh3")
    def net_ipv4_neigh_default_gc_thresh3(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.ipv4.neigh.default.gc_thresh3.
        """
        return pulumi.get(self, "net_ipv4_neigh_default_gc_thresh3")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpFinTimeout")
    def net_ipv4_tcp_fin_timeout(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.ipv4.tcp_fin_timeout.
        """
        return pulumi.get(self, "net_ipv4_tcp_fin_timeout")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpKeepaliveProbes")
    def net_ipv4_tcp_keepalive_probes(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.ipv4.tcp_keepalive_probes.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_probes")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpKeepaliveTime")
    def net_ipv4_tcp_keepalive_time(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.ipv4.tcp_keepalive_time.
        """
        return pulumi.get(self, "net_ipv4_tcp_keepalive_time")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpMaxSynBacklog")
    def net_ipv4_tcp_max_syn_backlog(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.ipv4.tcp_max_syn_backlog.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_syn_backlog")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpMaxTwBuckets")
    def net_ipv4_tcp_max_tw_buckets(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.ipv4.tcp_max_tw_buckets.
        """
        return pulumi.get(self, "net_ipv4_tcp_max_tw_buckets")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpTwReuse")
    def net_ipv4_tcp_tw_reuse(self) -> Optional[_builtins.bool]:
        """
        Sysctl setting net.ipv4.tcp_tw_reuse.
        """
        return pulumi.get(self, "net_ipv4_tcp_tw_reuse")

    @_builtins.property
    @pulumi.getter(name="netIpv4TcpkeepaliveIntvl")
    def net_ipv4_tcpkeepalive_intvl(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.ipv4.tcp_keepalive_intvl.
        """
        return pulumi.get(self, "net_ipv4_tcpkeepalive_intvl")

    @_builtins.property
    @pulumi.getter(name="netNetfilterNfConntrackBuckets")
    def net_netfilter_nf_conntrack_buckets(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.netfilter.nf_conntrack_buckets.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_buckets")

    @_builtins.property
    @pulumi.getter(name="netNetfilterNfConntrackMax")
    def net_netfilter_nf_conntrack_max(self) -> Optional[_builtins.int]:
        """
        Sysctl setting net.netfilter.nf_conntrack_max.
        """
        return pulumi.get(self, "net_netfilter_nf_conntrack_max")

    @_builtins.property
    @pulumi.getter(name="vmMaxMapCount")
    def vm_max_map_count(self) -> Optional[_builtins.int]:
        """
        Sysctl setting vm.max_map_count.
        """
        return pulumi.get(self, "vm_max_map_count")

    @_builtins.property
    @pulumi.getter(name="vmSwappiness")
    def vm_swappiness(self) -> Optional[_builtins.int]:
        """
        Sysctl setting vm.swappiness.
        """
        return pulumi.get(self, "vm_swappiness")

    @_builtins.property
    @pulumi.getter(name="vmVfsCachePressure")
    def vm_vfs_cache_pressure(self) -> Optional[_builtins.int]:
        """
        Sysctl setting vm.vfs_cache_pressure.
        """
        return pulumi.get(self, "vm_vfs_cache_pressure")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TimeInWeekResponse(dict):
    """
    Time in a week.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hourSlots":
            suggest = "hour_slots"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeInWeekResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeInWeekResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeInWeekResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: Optional[_builtins.str] = None,
                 hour_slots: Optional[Sequence[_builtins.int]] = None):
        """
        Time in a week.
        :param _builtins.str day: The day of the week.
        :param Sequence[_builtins.int] hour_slots: A list of hours in the day used to identify a time range. Each integer hour represents a time range beginning at 0m after the hour ending at the next hour (non-inclusive). 0 corresponds to 00:00 UTC, 23 corresponds to 23:00 UTC. Specifying [0, 1] means the 00:00 - 02:00 UTC time range.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour_slots is not None:
            pulumi.set(__self__, "hour_slots", hour_slots)

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        The day of the week.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter(name="hourSlots")
    def hour_slots(self) -> Optional[Sequence[_builtins.int]]:
        """
        A list of hours in the day used to identify a time range. Each integer hour represents a time range beginning at 0m after the hour ending at the next hour (non-inclusive). 0 corresponds to 00:00 UTC, 23 corresponds to 23:00 UTC. Specifying [0, 1] means the 00:00 - 02:00 UTC time range.
        """
        return pulumi.get(self, "hour_slots")


@pulumi.output_type
class TimeSpanResponse(dict):
    """
    A time range. For example, between 2021-05-25T13:00:00Z and 2021-05-25T14:00:00Z.
    """
    def __init__(__self__, *,
                 end: Optional[_builtins.str] = None,
                 start: Optional[_builtins.str] = None):
        """
        A time range. For example, between 2021-05-25T13:00:00Z and 2021-05-25T14:00:00Z.
        :param _builtins.str end: The end of a time span
        :param _builtins.str start: The start of a time span
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.str]:
        """
        The end of a time span
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> Optional[_builtins.str]:
        """
        The start of a time span
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class UpdateGroupResponse(dict):
    """
    A group to be updated.
    """
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        A group to be updated.
        :param _builtins.str name: Name of the group.
               It must match a group name of an existing fleet member. 
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the group.
        It must match a group name of an existing fleet member. 
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class UpdateGroupStatusResponse(dict):
    """
    The status of a UpdateGroup.
    """
    def __init__(__self__, *,
                 members: Sequence['outputs.MemberUpdateStatusResponse'],
                 name: _builtins.str,
                 status: 'outputs.UpdateStatusResponse'):
        """
        The status of a UpdateGroup.
        :param Sequence['MemberUpdateStatusResponse'] members: The list of member this UpdateGroup updates.
        :param _builtins.str name: The name of the UpdateGroup.
        :param 'UpdateStatusResponse' status: The status of the UpdateGroup.
        """
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Sequence['outputs.MemberUpdateStatusResponse']:
        """
        The list of member this UpdateGroup updates.
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the UpdateGroup.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.UpdateStatusResponse':
        """
        The status of the UpdateGroup.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class UpdateRunStatusResponse(dict):
    """
    The status of a UpdateRun.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeImageSelection":
            suggest = "node_image_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateRunStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateRunStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateRunStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_image_selection: 'outputs.NodeImageSelectionStatusResponse',
                 stages: Sequence['outputs.UpdateStageStatusResponse'],
                 status: 'outputs.UpdateStatusResponse'):
        """
        The status of a UpdateRun.
        :param 'NodeImageSelectionStatusResponse' node_image_selection: The node image upgrade specs for the update run. It is only set in update run when `NodeImageSelection.type` is `Consistent`.
        :param Sequence['UpdateStageStatusResponse'] stages: The stages composing an update run. Stages are run sequentially withing an UpdateRun.
        :param 'UpdateStatusResponse' status: The status of the UpdateRun.
        """
        pulumi.set(__self__, "node_image_selection", node_image_selection)
        pulumi.set(__self__, "stages", stages)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="nodeImageSelection")
    def node_image_selection(self) -> 'outputs.NodeImageSelectionStatusResponse':
        """
        The node image upgrade specs for the update run. It is only set in update run when `NodeImageSelection.type` is `Consistent`.
        """
        return pulumi.get(self, "node_image_selection")

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Sequence['outputs.UpdateStageStatusResponse']:
        """
        The stages composing an update run. Stages are run sequentially withing an UpdateRun.
        """
        return pulumi.get(self, "stages")

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.UpdateStatusResponse':
        """
        The status of the UpdateRun.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class UpdateRunStrategyResponse(dict):
    """
    Defines the update sequence of the clusters via stages and groups.

    Stages within a run are executed sequentially one after another.
    Groups within a stage are executed in parallel.
    Member clusters within a group are updated sequentially one after another.

    A valid strategy contains no duplicate groups within or across stages.
    """
    def __init__(__self__, *,
                 stages: Sequence['outputs.UpdateStageResponse']):
        """
        Defines the update sequence of the clusters via stages and groups.

        Stages within a run are executed sequentially one after another.
        Groups within a stage are executed in parallel.
        Member clusters within a group are updated sequentially one after another.

        A valid strategy contains no duplicate groups within or across stages.
        :param Sequence['UpdateStageResponse'] stages: The list of stages that compose this update run. Min size: 1.
        """
        pulumi.set(__self__, "stages", stages)

    @_builtins.property
    @pulumi.getter
    def stages(self) -> Sequence['outputs.UpdateStageResponse']:
        """
        The list of stages that compose this update run. Min size: 1.
        """
        return pulumi.get(self, "stages")


@pulumi.output_type
class UpdateStageResponse(dict):
    """
    Defines a stage which contains the groups to update and the steps to take (e.g., wait for a time period) before starting the next stage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterStageWaitInSeconds":
            suggest = "after_stage_wait_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateStageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateStageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateStageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 after_stage_wait_in_seconds: Optional[_builtins.int] = None,
                 groups: Optional[Sequence['outputs.UpdateGroupResponse']] = None):
        """
        Defines a stage which contains the groups to update and the steps to take (e.g., wait for a time period) before starting the next stage.
        :param _builtins.str name: The name of the stage. Must be unique within the UpdateRun.
        :param _builtins.int after_stage_wait_in_seconds: The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        :param Sequence['UpdateGroupResponse'] groups: Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
        pulumi.set(__self__, "name", name)
        if after_stage_wait_in_seconds is not None:
            pulumi.set(__self__, "after_stage_wait_in_seconds", after_stage_wait_in_seconds)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the stage. Must be unique within the UpdateRun.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="afterStageWaitInSeconds")
    def after_stage_wait_in_seconds(self) -> Optional[_builtins.int]:
        """
        The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        """
        return pulumi.get(self, "after_stage_wait_in_seconds")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.UpdateGroupResponse']]:
        """
        Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
        return pulumi.get(self, "groups")


@pulumi.output_type
class UpdateStageStatusResponse(dict):
    """
    The status of a UpdateStage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterStageWaitStatus":
            suggest = "after_stage_wait_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateStageStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateStageStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateStageStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 after_stage_wait_status: 'outputs.WaitStatusResponse',
                 groups: Sequence['outputs.UpdateGroupStatusResponse'],
                 name: _builtins.str,
                 status: 'outputs.UpdateStatusResponse'):
        """
        The status of a UpdateStage.
        :param 'WaitStatusResponse' after_stage_wait_status: The status of the wait period configured on the UpdateStage.
        :param Sequence['UpdateGroupStatusResponse'] groups: The list of groups to be updated as part of this UpdateStage.
        :param _builtins.str name: The name of the UpdateStage.
        :param 'UpdateStatusResponse' status: The status of the UpdateStage.
        """
        pulumi.set(__self__, "after_stage_wait_status", after_stage_wait_status)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="afterStageWaitStatus")
    def after_stage_wait_status(self) -> 'outputs.WaitStatusResponse':
        """
        The status of the wait period configured on the UpdateStage.
        """
        return pulumi.get(self, "after_stage_wait_status")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.UpdateGroupStatusResponse']:
        """
        The list of groups to be updated as part of this UpdateStage.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the UpdateStage.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.UpdateStatusResponse':
        """
        The status of the UpdateStage.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class UpdateStatusResponse(dict):
    """
    The status for an operation or group of operations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedTime":
            suggest = "completed_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_time: _builtins.str,
                 error: 'outputs.ErrorDetailResponse',
                 start_time: _builtins.str,
                 state: _builtins.str):
        """
        The status for an operation or group of operations.
        :param _builtins.str completed_time: The time the operation or group was completed.
        :param 'ErrorDetailResponse' error: The error details when a failure is encountered.
        :param _builtins.str start_time: The time the operation or group was started.
        :param _builtins.str state: The State of the operation or group.
        """
        pulumi.set(__self__, "completed_time", completed_time)
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="completedTime")
    def completed_time(self) -> _builtins.str:
        """
        The time the operation or group was completed.
        """
        return pulumi.get(self, "completed_time")

    @_builtins.property
    @pulumi.getter
    def error(self) -> 'outputs.ErrorDetailResponse':
        """
        The error details when a failure is encountered.
        """
        return pulumi.get(self, "error")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The time the operation or group was started.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The State of the operation or group.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class UpgradeOverrideSettingsResponse(dict):
    """
    Settings for overrides when upgrading a cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forceUpgrade":
            suggest = "force_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpgradeOverrideSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpgradeOverrideSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpgradeOverrideSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 force_upgrade: Optional[_builtins.bool] = None,
                 until: Optional[_builtins.str] = None):
        """
        Settings for overrides when upgrading a cluster.
        :param _builtins.bool force_upgrade: Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade protections such as checking for deprecated API usage. Enable this option only with caution.
        :param _builtins.str until: Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the effectiveness won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set by default. It must be set for the overrides to take effect.
        """
        if force_upgrade is not None:
            pulumi.set(__self__, "force_upgrade", force_upgrade)
        if until is not None:
            pulumi.set(__self__, "until", until)

    @_builtins.property
    @pulumi.getter(name="forceUpgrade")
    def force_upgrade(self) -> Optional[_builtins.bool]:
        """
        Whether to force upgrade the cluster. Note that this option instructs upgrade operation to bypass upgrade protections such as checking for deprecated API usage. Enable this option only with caution.
        """
        return pulumi.get(self, "force_upgrade")

    @_builtins.property
    @pulumi.getter
    def until(self) -> Optional[_builtins.str]:
        """
        Until when the overrides are effective. Note that this only matches the start time of an upgrade, and the effectiveness won't change once an upgrade starts even if the `until` expires as upgrade proceeds. This field is not set by default. It must be set for the overrides to take effect.
        """
        return pulumi.get(self, "until")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str,
                 object_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        :param _builtins.str object_id: The object ID of the user assigned identity.
        :param _builtins.str resource_id: The resource ID of the user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The object ID of the user assigned identity.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        The resource ID of the user assigned identity.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class VirtualMachineNodesResponse(dict):
    """
    Current status on a group of nodes of the same vm size.
    """
    def __init__(__self__, *,
                 count: Optional[_builtins.int] = None,
                 size: Optional[_builtins.str] = None):
        """
        Current status on a group of nodes of the same vm size.
        :param _builtins.int count: Number of nodes.
        :param _builtins.str size: The VM size of the agents used to host this group of nodes.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Number of nodes.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The VM size of the agents used to host this group of nodes.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class VirtualMachinesProfileResponse(dict):
    """
    Specifications on VirtualMachines agent pool.
    """
    def __init__(__self__, *,
                 scale: Optional['outputs.ScaleProfileResponse'] = None):
        """
        Specifications on VirtualMachines agent pool.
        :param 'ScaleProfileResponse' scale: Specifications on how to scale a VirtualMachines agent pool.
        """
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional['outputs.ScaleProfileResponse']:
        """
        Specifications on how to scale a VirtualMachines agent pool.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class WaitStatusResponse(dict):
    """
    The status of the wait duration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitDurationInSeconds":
            suggest = "wait_duration_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WaitStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WaitStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WaitStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: 'outputs.UpdateStatusResponse',
                 wait_duration_in_seconds: _builtins.int):
        """
        The status of the wait duration.
        :param 'UpdateStatusResponse' status: The status of the wait duration.
        :param _builtins.int wait_duration_in_seconds: The wait duration configured in seconds.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "wait_duration_in_seconds", wait_duration_in_seconds)

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.UpdateStatusResponse':
        """
        The status of the wait duration.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="waitDurationInSeconds")
    def wait_duration_in_seconds(self) -> _builtins.int:
        """
        The wait duration configured in seconds.
        """
        return pulumi.get(self, "wait_duration_in_seconds")


@pulumi.output_type
class WeeklyScheduleResponse(dict):
    """
    For schedules like: 'recur every Monday' or 'recur every 3 weeks on Wednesday'.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "intervalWeeks":
            suggest = "interval_weeks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WeeklyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: _builtins.str,
                 interval_weeks: _builtins.int):
        """
        For schedules like: 'recur every Monday' or 'recur every 3 weeks on Wednesday'.
        :param _builtins.str day_of_week: Specifies on which day of the week the maintenance occurs.
        :param _builtins.int interval_weeks: Specifies the number of weeks between each set of occurrences.
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "interval_weeks", interval_weeks)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> _builtins.str:
        """
        Specifies on which day of the week the maintenance occurs.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="intervalWeeks")
    def interval_weeks(self) -> _builtins.int:
        """
        Specifies the number of weeks between each set of occurrences.
        """
        return pulumi.get(self, "interval_weeks")


@pulumi.output_type
class WindowsGmsaProfileResponse(dict):
    """
    Windows gMSA Profile in the managed cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServer":
            suggest = "dns_server"
        elif key == "rootDomainName":
            suggest = "root_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WindowsGmsaProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WindowsGmsaProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WindowsGmsaProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_server: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 root_domain_name: Optional[_builtins.str] = None):
        """
        Windows gMSA Profile in the managed cluster.
        :param _builtins.str dns_server: Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
        :param _builtins.bool enabled: Whether to enable Windows gMSA. Specifies whether to enable Windows gMSA in the managed cluster.
        :param _builtins.str root_domain_name: Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
        """
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if root_domain_name is not None:
            pulumi.set(__self__, "root_domain_name", root_domain_name)

    @_builtins.property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[_builtins.str]:
        """
        Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
        """
        return pulumi.get(self, "dns_server")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Windows gMSA. Specifies whether to enable Windows gMSA in the managed cluster.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="rootDomainName")
    def root_domain_name(self) -> Optional[_builtins.str]:
        """
        Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
        """
        return pulumi.get(self, "root_domain_name")


