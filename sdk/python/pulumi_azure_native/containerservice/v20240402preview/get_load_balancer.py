# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs

__all__ = [
    'GetLoadBalancerResult',
    'AwaitableGetLoadBalancerResult',
    'get_load_balancer',
    'get_load_balancer_output',
]

@pulumi.output_type
class GetLoadBalancerResult:
    """
    The configurations regarding multiple standard load balancers. If not supplied, single load balancer mode will be used. Multiple standard load balancers mode will be used if at lease one configuration is supplied. There has to be a configuration named `kubernetes`.
    """
    def __init__(__self__, allow_service_placement=None, id=None, name=None, node_selector=None, primary_agent_pool_name=None, provisioning_state=None, service_label_selector=None, service_namespace_selector=None, system_data=None, type=None):
        if allow_service_placement and not isinstance(allow_service_placement, bool):
            raise TypeError("Expected argument 'allow_service_placement' to be a bool")
        pulumi.set(__self__, "allow_service_placement", allow_service_placement)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if node_selector and not isinstance(node_selector, dict):
            raise TypeError("Expected argument 'node_selector' to be a dict")
        pulumi.set(__self__, "node_selector", node_selector)
        if primary_agent_pool_name and not isinstance(primary_agent_pool_name, str):
            raise TypeError("Expected argument 'primary_agent_pool_name' to be a str")
        pulumi.set(__self__, "primary_agent_pool_name", primary_agent_pool_name)
        if provisioning_state and not isinstance(provisioning_state, str):
            raise TypeError("Expected argument 'provisioning_state' to be a str")
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if service_label_selector and not isinstance(service_label_selector, dict):
            raise TypeError("Expected argument 'service_label_selector' to be a dict")
        pulumi.set(__self__, "service_label_selector", service_label_selector)
        if service_namespace_selector and not isinstance(service_namespace_selector, dict):
            raise TypeError("Expected argument 'service_namespace_selector' to be a dict")
        pulumi.set(__self__, "service_namespace_selector", service_namespace_selector)
        if system_data and not isinstance(system_data, dict):
            raise TypeError("Expected argument 'system_data' to be a dict")
        pulumi.set(__self__, "system_data", system_data)
        if type and not isinstance(type, str):
            raise TypeError("Expected argument 'type' to be a str")
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowServicePlacement")
    def allow_service_placement(self) -> Optional[bool]:
        """
        Whether to automatically place services on the load balancer. If not supplied, the default value is true. If set to false manually, both of the external and the internal load balancer will not be selected for services unless they explicitly target it.
        """
        return pulumi.get(self, "allow_service_placement")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional['outputs.LabelSelectorResponse']:
        """
        Nodes that match this selector will be possible members of this load balancer.
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter(name="primaryAgentPoolName")
    def primary_agent_pool_name(self) -> str:
        """
        Required field. A string value that must specify the ID of an existing agent pool. All nodes in the given pool will always be added to this load balancer. This agent pool must have at least one node and minCount>=1 for autoscaling operations. An agent pool can only be the primary pool for a single load balancer.
        """
        return pulumi.get(self, "primary_agent_pool_name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The current provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="serviceLabelSelector")
    def service_label_selector(self) -> Optional['outputs.LabelSelectorResponse']:
        """
        Only services that must match this selector can be placed on this load balancer.
        """
        return pulumi.get(self, "service_label_selector")

    @property
    @pulumi.getter(name="serviceNamespaceSelector")
    def service_namespace_selector(self) -> Optional['outputs.LabelSelectorResponse']:
        """
        Services created in namespaces that match the selector can be placed on this load balancer.
        """
        return pulumi.get(self, "service_namespace_selector")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")


class AwaitableGetLoadBalancerResult(GetLoadBalancerResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetLoadBalancerResult(
            allow_service_placement=self.allow_service_placement,
            id=self.id,
            name=self.name,
            node_selector=self.node_selector,
            primary_agent_pool_name=self.primary_agent_pool_name,
            provisioning_state=self.provisioning_state,
            service_label_selector=self.service_label_selector,
            service_namespace_selector=self.service_namespace_selector,
            system_data=self.system_data,
            type=self.type)


def get_load_balancer(load_balancer_name: Optional[str] = None,
                      resource_group_name: Optional[str] = None,
                      resource_name: Optional[str] = None,
                      opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetLoadBalancerResult:
    """
    The configurations regarding multiple standard load balancers. If not supplied, single load balancer mode will be used. Multiple standard load balancers mode will be used if at lease one configuration is supplied. There has to be a configuration named `kubernetes`.


    :param str load_balancer_name: The name of the load balancer.
    :param str resource_group_name: The name of the resource group. The name is case insensitive.
    :param str resource_name: The name of the managed cluster resource.
    """
    __args__ = dict()
    __args__['loadBalancerName'] = load_balancer_name
    __args__['resourceGroupName'] = resource_group_name
    __args__['resourceName'] = resource_name
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('azure-native:containerservice/v20240402preview:getLoadBalancer', __args__, opts=opts, typ=GetLoadBalancerResult).value

    return AwaitableGetLoadBalancerResult(
        allow_service_placement=pulumi.get(__ret__, 'allow_service_placement'),
        id=pulumi.get(__ret__, 'id'),
        name=pulumi.get(__ret__, 'name'),
        node_selector=pulumi.get(__ret__, 'node_selector'),
        primary_agent_pool_name=pulumi.get(__ret__, 'primary_agent_pool_name'),
        provisioning_state=pulumi.get(__ret__, 'provisioning_state'),
        service_label_selector=pulumi.get(__ret__, 'service_label_selector'),
        service_namespace_selector=pulumi.get(__ret__, 'service_namespace_selector'),
        system_data=pulumi.get(__ret__, 'system_data'),
        type=pulumi.get(__ret__, 'type'))


@_utilities.lift_output_func(get_load_balancer)
def get_load_balancer_output(load_balancer_name: Optional[pulumi.Input[str]] = None,
                             resource_group_name: Optional[pulumi.Input[str]] = None,
                             resource_name: Optional[pulumi.Input[str]] = None,
                             opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetLoadBalancerResult]:
    """
    The configurations regarding multiple standard load balancers. If not supplied, single load balancer mode will be used. Multiple standard load balancers mode will be used if at lease one configuration is supplied. There has to be a configuration named `kubernetes`.


    :param str load_balancer_name: The name of the load balancer.
    :param str resource_group_name: The name of the resource group. The name is case insensitive.
    :param str resource_name: The name of the managed cluster resource.
    """
    ...
