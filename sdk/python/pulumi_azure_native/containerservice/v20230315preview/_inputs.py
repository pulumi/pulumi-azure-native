# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'FleetHubProfileArgs',
    'FleetHubProfileArgsDict',
    'ManagedClusterUpdateArgs',
    'ManagedClusterUpdateArgsDict',
    'ManagedClusterUpgradeSpecArgs',
    'ManagedClusterUpgradeSpecArgsDict',
    'UpdateGroupArgs',
    'UpdateGroupArgsDict',
    'UpdateRunStrategyArgs',
    'UpdateRunStrategyArgsDict',
    'UpdateStageArgs',
    'UpdateStageArgsDict',
]

MYPY = False

if not MYPY:
    class FleetHubProfileArgsDict(TypedDict):
        """
        The FleetHubProfile configures the fleet hub.
        """
        dns_prefix: NotRequired[pulumi.Input[str]]
        """
        DNS prefix used to create the FQDN for the Fleet hub.
        """
elif False:
    FleetHubProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetHubProfileArgs:
    def __init__(__self__, *,
                 dns_prefix: Optional[pulumi.Input[str]] = None):
        """
        The FleetHubProfile configures the fleet hub.
        :param pulumi.Input[str] dns_prefix: DNS prefix used to create the FQDN for the Fleet hub.
        """
        if dns_prefix is not None:
            pulumi.set(__self__, "dns_prefix", dns_prefix)

    @property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        DNS prefix used to create the FQDN for the Fleet hub.
        """
        return pulumi.get(self, "dns_prefix")

    @dns_prefix.setter
    def dns_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_prefix", value)


if not MYPY:
    class ManagedClusterUpdateArgsDict(TypedDict):
        """
        The update to be applied to the ManagedClusters.
        """
        upgrade: pulumi.Input['ManagedClusterUpgradeSpecArgsDict']
        """
        The upgrade to apply to the ManagedClusters.
        """
elif False:
    ManagedClusterUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedClusterUpdateArgs:
    def __init__(__self__, *,
                 upgrade: pulumi.Input['ManagedClusterUpgradeSpecArgs']):
        """
        The update to be applied to the ManagedClusters.
        :param pulumi.Input['ManagedClusterUpgradeSpecArgs'] upgrade: The upgrade to apply to the ManagedClusters.
        """
        pulumi.set(__self__, "upgrade", upgrade)

    @property
    @pulumi.getter
    def upgrade(self) -> pulumi.Input['ManagedClusterUpgradeSpecArgs']:
        """
        The upgrade to apply to the ManagedClusters.
        """
        return pulumi.get(self, "upgrade")

    @upgrade.setter
    def upgrade(self, value: pulumi.Input['ManagedClusterUpgradeSpecArgs']):
        pulumi.set(self, "upgrade", value)


if not MYPY:
    class ManagedClusterUpgradeSpecArgsDict(TypedDict):
        """
        The upgrade to apply to a ManagedCluster.
        """
        type: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]
        """
        ManagedClusterUpgradeType is the type of upgrade to be applied.
        """
        kubernetes_version: NotRequired[pulumi.Input[str]]
        """
        The Kubernetes version to upgrade the member clusters to.
        """
elif False:
    ManagedClusterUpgradeSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedClusterUpgradeSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']],
                 kubernetes_version: Optional[pulumi.Input[str]] = None):
        """
        The upgrade to apply to a ManagedCluster.
        :param pulumi.Input[Union[str, 'ManagedClusterUpgradeType']] type: ManagedClusterUpgradeType is the type of upgrade to be applied.
        :param pulumi.Input[str] kubernetes_version: The Kubernetes version to upgrade the member clusters to.
        """
        pulumi.set(__self__, "type", type)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]:
        """
        ManagedClusterUpgradeType is the type of upgrade to be applied.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes version to upgrade the member clusters to.
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)


if not MYPY:
    class UpdateGroupArgsDict(TypedDict):
        """
        A group to be updated.
        """
        name: pulumi.Input[str]
        """
        Name of the group.
        It must match a group name of an existing fleet member. 
        """
elif False:
    UpdateGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        A group to be updated.
        :param pulumi.Input[str] name: Name of the group.
               It must match a group name of an existing fleet member. 
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the group.
        It must match a group name of an existing fleet member. 
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UpdateRunStrategyArgsDict(TypedDict):
        """
        Defines the update sequence of the clusters via stages and groups.

        Stages within a run are executed sequentially one after another.
        Groups within a stage are executed in parallel.
        Member clusters within a group are updated sequentially one after another.

        A valid strategy contains no duplicate groups within or across stages.
        """
        stages: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgsDict']]]
        """
        The list of stages that compose this update run. Min size: 1.
        """
elif False:
    UpdateRunStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateRunStrategyArgs:
    def __init__(__self__, *,
                 stages: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]):
        """
        Defines the update sequence of the clusters via stages and groups.

        Stages within a run are executed sequentially one after another.
        Groups within a stage are executed in parallel.
        Member clusters within a group are updated sequentially one after another.

        A valid strategy contains no duplicate groups within or across stages.
        :param pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]] stages: The list of stages that compose this update run. Min size: 1.
        """
        pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]:
        """
        The list of stages that compose this update run. Min size: 1.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]):
        pulumi.set(self, "stages", value)


if not MYPY:
    class UpdateStageArgsDict(TypedDict):
        """
        Defines a stage which contains the groups to update and the steps to take (e.g., wait for a time period) before starting the next stage.
        """
        name: pulumi.Input[str]
        """
        The name of the stage. Must be unique within the UpdateRun.
        """
        after_stage_wait_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgsDict']]]]
        """
        Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
elif False:
    UpdateStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateStageArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 after_stage_wait_in_seconds: Optional[pulumi.Input[int]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]] = None):
        """
        Defines a stage which contains the groups to update and the steps to take (e.g., wait for a time period) before starting the next stage.
        :param pulumi.Input[str] name: The name of the stage. Must be unique within the UpdateRun.
        :param pulumi.Input[int] after_stage_wait_in_seconds: The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        :param pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]] groups: Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
        pulumi.set(__self__, "name", name)
        if after_stage_wait_in_seconds is not None:
            pulumi.set(__self__, "after_stage_wait_in_seconds", after_stage_wait_in_seconds)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stage. Must be unique within the UpdateRun.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="afterStageWaitInSeconds")
    def after_stage_wait_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        """
        return pulumi.get(self, "after_stage_wait_in_seconds")

    @after_stage_wait_in_seconds.setter
    def after_stage_wait_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "after_stage_wait_in_seconds", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]]:
        """
        Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]]):
        pulumi.set(self, "groups", value)


