# coding=utf-8
# *** WARNING: this file was generated by pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'FleetHubProfileArgs',
    'ManagedClusterUpdateArgs',
    'ManagedClusterUpgradeSpecArgs',
    'UpdateGroupArgs',
    'UpdateRunStrategyArgs',
    'UpdateStageArgs',
]

@pulumi.input_type
class FleetHubProfileArgs:
    def __init__(__self__, *,
                 dns_prefix: Optional[pulumi.Input[str]] = None):
        """
        The FleetHubProfile configures the fleet hub.
        :param pulumi.Input[str] dns_prefix: DNS prefix used to create the FQDN for the Fleet hub.
        """
        if dns_prefix is not None:
            pulumi.set(__self__, "dns_prefix", dns_prefix)

    @property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        DNS prefix used to create the FQDN for the Fleet hub.
        """
        return pulumi.get(self, "dns_prefix")

    @dns_prefix.setter
    def dns_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_prefix", value)


@pulumi.input_type
class ManagedClusterUpdateArgs:
    def __init__(__self__, *,
                 upgrade: pulumi.Input['ManagedClusterUpgradeSpecArgs']):
        """
        The update to be applied to the ManagedClusters.
        :param pulumi.Input['ManagedClusterUpgradeSpecArgs'] upgrade: The upgrade to apply to the ManagedClusters.
        """
        pulumi.set(__self__, "upgrade", upgrade)

    @property
    @pulumi.getter
    def upgrade(self) -> pulumi.Input['ManagedClusterUpgradeSpecArgs']:
        """
        The upgrade to apply to the ManagedClusters.
        """
        return pulumi.get(self, "upgrade")

    @upgrade.setter
    def upgrade(self, value: pulumi.Input['ManagedClusterUpgradeSpecArgs']):
        pulumi.set(self, "upgrade", value)


@pulumi.input_type
class ManagedClusterUpgradeSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']],
                 kubernetes_version: Optional[pulumi.Input[str]] = None):
        """
        The upgrade to apply to a ManagedCluster.
        :param pulumi.Input[Union[str, 'ManagedClusterUpgradeType']] type: The upgrade type.
               Full requires the KubernetesVersion property to be set.
               NodeImageOnly requires the KubernetesVersion property not to be set.
        :param pulumi.Input[str] kubernetes_version: The Kubernetes version to upgrade the member clusters to.
        """
        pulumi.set(__self__, "type", type)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]:
        """
        The upgrade type.
        Full requires the KubernetesVersion property to be set.
        NodeImageOnly requires the KubernetesVersion property not to be set.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes version to upgrade the member clusters to.
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)


@pulumi.input_type
class UpdateGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        A group to be updated.
        :param pulumi.Input[str] name: The name of the Fleet member group to update. 
               It should match the name of an existing FleetMember group.
               A group can only appear once across all UpdateStages in the UpdateRun.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Fleet member group to update. 
        It should match the name of an existing FleetMember group.
        A group can only appear once across all UpdateStages in the UpdateRun.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class UpdateRunStrategyArgs:
    def __init__(__self__, *,
                 stages: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]):
        """
        The UpdateRunStrategy configures the sequence of Stages and Groups in which the clusters will be updated.
        :param pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]] stages: The list of stages that compose this update run.
        """
        pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]:
        """
        The list of stages that compose this update run.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]):
        pulumi.set(self, "stages", value)


@pulumi.input_type
class UpdateStageArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 after_stage_wait_in_seconds: Optional[pulumi.Input[int]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]] = None):
        """
        Contains the groups to be updated by an UpdateRun.
        Update order:
        - Sequential between stages: Stages run sequentially. The previous stage must complete before the next one starts.
        - Parallel within a stage: Groups within a stage run in parallel.
        - Sequential within a group: Clusters within a group are updated sequentially.
        :param pulumi.Input[str] name: The name of the stage. Must be unique within the UpdateRun.
        :param pulumi.Input[int] after_stage_wait_in_seconds: The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        :param pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]] groups: A list of group names that compose the stage.
               The groups will be updated in parallel. Each group name can only appear once in the UpdateRun.
        """
        pulumi.set(__self__, "name", name)
        if after_stage_wait_in_seconds is not None:
            pulumi.set(__self__, "after_stage_wait_in_seconds", after_stage_wait_in_seconds)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stage. Must be unique within the UpdateRun.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="afterStageWaitInSeconds")
    def after_stage_wait_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        """
        return pulumi.get(self, "after_stage_wait_in_seconds")

    @after_stage_wait_in_seconds.setter
    def after_stage_wait_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "after_stage_wait_in_seconds", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]]:
        """
        A list of group names that compose the stage.
        The groups will be updated in parallel. Each group name can only appear once in the UpdateRun.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]]):
        pulumi.set(self, "groups", value)


