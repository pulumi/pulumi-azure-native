# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'ManagedClusterUpdateArgs',
    'ManagedClusterUpgradeSpecArgs',
    'ManagedServiceIdentityArgs',
    'NodeImageSelectionArgs',
    'UpdateGroupArgs',
    'UpdateRunStrategyArgs',
    'UpdateStageArgs',
]

@pulumi.input_type
class ManagedClusterUpdateArgs:
    def __init__(__self__, *,
                 upgrade: pulumi.Input['ManagedClusterUpgradeSpecArgs'],
                 node_image_selection: Optional[pulumi.Input['NodeImageSelectionArgs']] = None):
        """
        The update to be applied to the ManagedClusters.
        :param pulumi.Input['ManagedClusterUpgradeSpecArgs'] upgrade: The upgrade to apply to the ManagedClusters.
        :param pulumi.Input['NodeImageSelectionArgs'] node_image_selection: The node image upgrade to be applied to the target nodes in update run.
        """
        pulumi.set(__self__, "upgrade", upgrade)
        if node_image_selection is not None:
            pulumi.set(__self__, "node_image_selection", node_image_selection)

    @property
    @pulumi.getter
    def upgrade(self) -> pulumi.Input['ManagedClusterUpgradeSpecArgs']:
        """
        The upgrade to apply to the ManagedClusters.
        """
        return pulumi.get(self, "upgrade")

    @upgrade.setter
    def upgrade(self, value: pulumi.Input['ManagedClusterUpgradeSpecArgs']):
        pulumi.set(self, "upgrade", value)

    @property
    @pulumi.getter(name="nodeImageSelection")
    def node_image_selection(self) -> Optional[pulumi.Input['NodeImageSelectionArgs']]:
        """
        The node image upgrade to be applied to the target nodes in update run.
        """
        return pulumi.get(self, "node_image_selection")

    @node_image_selection.setter
    def node_image_selection(self, value: Optional[pulumi.Input['NodeImageSelectionArgs']]):
        pulumi.set(self, "node_image_selection", value)


@pulumi.input_type
class ManagedClusterUpgradeSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']],
                 kubernetes_version: Optional[pulumi.Input[str]] = None):
        """
        The upgrade to apply to a ManagedCluster.
        :param pulumi.Input[Union[str, 'ManagedClusterUpgradeType']] type: The upgrade type.
               Full requires the KubernetesVersion property to be set.
               NodeImageOnly requires the KubernetesVersion property not to be set.
        :param pulumi.Input[str] kubernetes_version: The Kubernetes version to upgrade the member clusters to.
        """
        pulumi.set(__self__, "type", type)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]:
        """
        The upgrade type.
        Full requires the KubernetesVersion property to be set.
        NodeImageOnly requires the KubernetesVersion property not to be set.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes version to upgrade the member clusters to.
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)


@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


@pulumi.input_type
class NodeImageSelectionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'NodeImageSelectionType']]):
        """
        The node image upgrade to be applied to the target nodes in update run.
        :param pulumi.Input[Union[str, 'NodeImageSelectionType']] type: The node image upgrade type.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'NodeImageSelectionType']]:
        """
        The node image upgrade type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'NodeImageSelectionType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class UpdateGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        A group to be updated.
        :param pulumi.Input[str] name: Name of the group.
               It must match a group name of an existing fleet member. 
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the group.
        It must match a group name of an existing fleet member. 
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class UpdateRunStrategyArgs:
    def __init__(__self__, *,
                 stages: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]):
        """
        Defines the update sequence of the clusters via stages and groups.

        Stages within a run are executed sequentially one after another.
        Groups within a stage are executed in parallel.
        Member clusters within a group are updated sequentially one after another.

        A valid strategy contains no duplicate groups within or across stages.
        :param pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]] stages: The list of stages that compose this update run. Min size: 1.
        """
        pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]:
        """
        The list of stages that compose this update run. Min size: 1.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]):
        pulumi.set(self, "stages", value)


@pulumi.input_type
class UpdateStageArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 after_stage_wait_in_seconds: Optional[pulumi.Input[int]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]] = None):
        """
        Defines a stage which contains the groups to update and the steps to take (e.g., wait for a time period) before starting the next stage.
        :param pulumi.Input[str] name: The name of the stage. Must be unique within the UpdateRun.
        :param pulumi.Input[int] after_stage_wait_in_seconds: The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        :param pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]] groups: Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
        pulumi.set(__self__, "name", name)
        if after_stage_wait_in_seconds is not None:
            pulumi.set(__self__, "after_stage_wait_in_seconds", after_stage_wait_in_seconds)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stage. Must be unique within the UpdateRun.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="afterStageWaitInSeconds")
    def after_stage_wait_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        """
        return pulumi.get(self, "after_stage_wait_in_seconds")

    @after_stage_wait_in_seconds.setter
    def after_stage_wait_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "after_stage_wait_in_seconds", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]]:
        """
        Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]]):
        pulumi.set(self, "groups", value)


