# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'APIServerAccessProfileArgs',
    'APIServerAccessProfileArgsDict',
    'AgentProfileArgs',
    'AgentProfileArgsDict',
    'FleetHubProfileArgs',
    'FleetHubProfileArgsDict',
    'ManagedClusterUpdateArgs',
    'ManagedClusterUpdateArgsDict',
    'ManagedClusterUpgradeSpecArgs',
    'ManagedClusterUpgradeSpecArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'NodeImageSelectionArgs',
    'NodeImageSelectionArgsDict',
    'UpdateGroupArgs',
    'UpdateGroupArgsDict',
    'UpdateRunStrategyArgs',
    'UpdateRunStrategyArgsDict',
    'UpdateStageArgs',
    'UpdateStageArgsDict',
]

MYPY = False

if not MYPY:
    class APIServerAccessProfileArgsDict(TypedDict):
        """
        Access profile for the Fleet hub API server.
        """
        enable_private_cluster: NotRequired[pulumi.Input[bool]]
        """
        Whether to create the Fleet hub as a private cluster or not.
        """
elif False:
    APIServerAccessProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class APIServerAccessProfileArgs:
    def __init__(__self__, *,
                 enable_private_cluster: Optional[pulumi.Input[bool]] = None):
        """
        Access profile for the Fleet hub API server.
        :param pulumi.Input[bool] enable_private_cluster: Whether to create the Fleet hub as a private cluster or not.
        """
        if enable_private_cluster is not None:
            pulumi.set(__self__, "enable_private_cluster", enable_private_cluster)

    @property
    @pulumi.getter(name="enablePrivateCluster")
    def enable_private_cluster(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to create the Fleet hub as a private cluster or not.
        """
        return pulumi.get(self, "enable_private_cluster")

    @enable_private_cluster.setter
    def enable_private_cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_private_cluster", value)


if not MYPY:
    class AgentProfileArgsDict(TypedDict):
        """
        Agent profile for the Fleet hub.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the subnet which the Fleet hub node will join on startup. If this is not specified, a vnet and subnet will be generated and used.
        """
        vm_size: NotRequired[pulumi.Input[str]]
        """
        The virtual machine size of the Fleet hub.
        """
elif False:
    AgentProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentProfileArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vm_size: Optional[pulumi.Input[str]] = None):
        """
        Agent profile for the Fleet hub.
        :param pulumi.Input[str] subnet_id: The ID of the subnet which the Fleet hub node will join on startup. If this is not specified, a vnet and subnet will be generated and used.
        :param pulumi.Input[str] vm_size: The virtual machine size of the Fleet hub.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subnet which the Fleet hub node will join on startup. If this is not specified, a vnet and subnet will be generated and used.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[str]]:
        """
        The virtual machine size of the Fleet hub.
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class FleetHubProfileArgsDict(TypedDict):
        """
        The FleetHubProfile configures the fleet hub.
        """
        agent_profile: NotRequired[pulumi.Input['AgentProfileArgsDict']]
        """
        The agent profile for the Fleet hub.
        """
        api_server_access_profile: NotRequired[pulumi.Input['APIServerAccessProfileArgsDict']]
        """
        The access profile for the Fleet hub API server.
        """
        dns_prefix: NotRequired[pulumi.Input[str]]
        """
        DNS prefix used to create the FQDN for the Fleet hub.
        """
elif False:
    FleetHubProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetHubProfileArgs:
    def __init__(__self__, *,
                 agent_profile: Optional[pulumi.Input['AgentProfileArgs']] = None,
                 api_server_access_profile: Optional[pulumi.Input['APIServerAccessProfileArgs']] = None,
                 dns_prefix: Optional[pulumi.Input[str]] = None):
        """
        The FleetHubProfile configures the fleet hub.
        :param pulumi.Input['AgentProfileArgs'] agent_profile: The agent profile for the Fleet hub.
        :param pulumi.Input['APIServerAccessProfileArgs'] api_server_access_profile: The access profile for the Fleet hub API server.
        :param pulumi.Input[str] dns_prefix: DNS prefix used to create the FQDN for the Fleet hub.
        """
        if agent_profile is not None:
            pulumi.set(__self__, "agent_profile", agent_profile)
        if api_server_access_profile is not None:
            pulumi.set(__self__, "api_server_access_profile", api_server_access_profile)
        if dns_prefix is not None:
            pulumi.set(__self__, "dns_prefix", dns_prefix)

    @property
    @pulumi.getter(name="agentProfile")
    def agent_profile(self) -> Optional[pulumi.Input['AgentProfileArgs']]:
        """
        The agent profile for the Fleet hub.
        """
        return pulumi.get(self, "agent_profile")

    @agent_profile.setter
    def agent_profile(self, value: Optional[pulumi.Input['AgentProfileArgs']]):
        pulumi.set(self, "agent_profile", value)

    @property
    @pulumi.getter(name="apiServerAccessProfile")
    def api_server_access_profile(self) -> Optional[pulumi.Input['APIServerAccessProfileArgs']]:
        """
        The access profile for the Fleet hub API server.
        """
        return pulumi.get(self, "api_server_access_profile")

    @api_server_access_profile.setter
    def api_server_access_profile(self, value: Optional[pulumi.Input['APIServerAccessProfileArgs']]):
        pulumi.set(self, "api_server_access_profile", value)

    @property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        DNS prefix used to create the FQDN for the Fleet hub.
        """
        return pulumi.get(self, "dns_prefix")

    @dns_prefix.setter
    def dns_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_prefix", value)


if not MYPY:
    class ManagedClusterUpdateArgsDict(TypedDict):
        """
        The update to be applied to the ManagedClusters.
        """
        upgrade: pulumi.Input['ManagedClusterUpgradeSpecArgsDict']
        """
        The upgrade to apply to the ManagedClusters.
        """
        node_image_selection: NotRequired[pulumi.Input['NodeImageSelectionArgsDict']]
        """
        The node image upgrade to be applied to the target nodes in update run.
        """
elif False:
    ManagedClusterUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedClusterUpdateArgs:
    def __init__(__self__, *,
                 upgrade: pulumi.Input['ManagedClusterUpgradeSpecArgs'],
                 node_image_selection: Optional[pulumi.Input['NodeImageSelectionArgs']] = None):
        """
        The update to be applied to the ManagedClusters.
        :param pulumi.Input['ManagedClusterUpgradeSpecArgs'] upgrade: The upgrade to apply to the ManagedClusters.
        :param pulumi.Input['NodeImageSelectionArgs'] node_image_selection: The node image upgrade to be applied to the target nodes in update run.
        """
        pulumi.set(__self__, "upgrade", upgrade)
        if node_image_selection is not None:
            pulumi.set(__self__, "node_image_selection", node_image_selection)

    @property
    @pulumi.getter
    def upgrade(self) -> pulumi.Input['ManagedClusterUpgradeSpecArgs']:
        """
        The upgrade to apply to the ManagedClusters.
        """
        return pulumi.get(self, "upgrade")

    @upgrade.setter
    def upgrade(self, value: pulumi.Input['ManagedClusterUpgradeSpecArgs']):
        pulumi.set(self, "upgrade", value)

    @property
    @pulumi.getter(name="nodeImageSelection")
    def node_image_selection(self) -> Optional[pulumi.Input['NodeImageSelectionArgs']]:
        """
        The node image upgrade to be applied to the target nodes in update run.
        """
        return pulumi.get(self, "node_image_selection")

    @node_image_selection.setter
    def node_image_selection(self, value: Optional[pulumi.Input['NodeImageSelectionArgs']]):
        pulumi.set(self, "node_image_selection", value)


if not MYPY:
    class ManagedClusterUpgradeSpecArgsDict(TypedDict):
        """
        The upgrade to apply to a ManagedCluster.
        """
        type: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]
        """
        ManagedClusterUpgradeType is the type of upgrade to be applied.
        """
        kubernetes_version: NotRequired[pulumi.Input[str]]
        """
        The Kubernetes version to upgrade the member clusters to.
        """
elif False:
    ManagedClusterUpgradeSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedClusterUpgradeSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']],
                 kubernetes_version: Optional[pulumi.Input[str]] = None):
        """
        The upgrade to apply to a ManagedCluster.
        :param pulumi.Input[Union[str, 'ManagedClusterUpgradeType']] type: ManagedClusterUpgradeType is the type of upgrade to be applied.
        :param pulumi.Input[str] kubernetes_version: The Kubernetes version to upgrade the member clusters to.
        """
        pulumi.set(__self__, "type", type)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]:
        """
        ManagedClusterUpgradeType is the type of upgrade to be applied.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedClusterUpgradeType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes version to upgrade the member clusters to.
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class NodeImageSelectionArgsDict(TypedDict):
        """
        The node image upgrade to be applied to the target nodes in update run.
        """
        type: pulumi.Input[Union[str, 'NodeImageSelectionType']]
        """
        The node image upgrade type.
        """
elif False:
    NodeImageSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeImageSelectionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'NodeImageSelectionType']]):
        """
        The node image upgrade to be applied to the target nodes in update run.
        :param pulumi.Input[Union[str, 'NodeImageSelectionType']] type: The node image upgrade type.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'NodeImageSelectionType']]:
        """
        The node image upgrade type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'NodeImageSelectionType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class UpdateGroupArgsDict(TypedDict):
        """
        A group to be updated.
        """
        name: pulumi.Input[str]
        """
        Name of the group.
        It must match a group name of an existing fleet member. 
        """
elif False:
    UpdateGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        A group to be updated.
        :param pulumi.Input[str] name: Name of the group.
               It must match a group name of an existing fleet member. 
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the group.
        It must match a group name of an existing fleet member. 
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UpdateRunStrategyArgsDict(TypedDict):
        """
        Defines the update sequence of the clusters via stages and groups.

        Stages within a run are executed sequentially one after another.
        Groups within a stage are executed in parallel.
        Member clusters within a group are updated sequentially one after another.

        A valid strategy contains no duplicate groups within or across stages.
        """
        stages: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgsDict']]]
        """
        The list of stages that compose this update run. Min size: 1.
        """
elif False:
    UpdateRunStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateRunStrategyArgs:
    def __init__(__self__, *,
                 stages: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]):
        """
        Defines the update sequence of the clusters via stages and groups.

        Stages within a run are executed sequentially one after another.
        Groups within a stage are executed in parallel.
        Member clusters within a group are updated sequentially one after another.

        A valid strategy contains no duplicate groups within or across stages.
        :param pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]] stages: The list of stages that compose this update run. Min size: 1.
        """
        pulumi.set(__self__, "stages", stages)

    @property
    @pulumi.getter
    def stages(self) -> pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]:
        """
        The list of stages that compose this update run. Min size: 1.
        """
        return pulumi.get(self, "stages")

    @stages.setter
    def stages(self, value: pulumi.Input[Sequence[pulumi.Input['UpdateStageArgs']]]):
        pulumi.set(self, "stages", value)


if not MYPY:
    class UpdateStageArgsDict(TypedDict):
        """
        Defines a stage which contains the groups to update and the steps to take (e.g., wait for a time period) before starting the next stage.
        """
        name: pulumi.Input[str]
        """
        The name of the stage. Must be unique within the UpdateRun.
        """
        after_stage_wait_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgsDict']]]]
        """
        Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
elif False:
    UpdateStageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpdateStageArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 after_stage_wait_in_seconds: Optional[pulumi.Input[int]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]] = None):
        """
        Defines a stage which contains the groups to update and the steps to take (e.g., wait for a time period) before starting the next stage.
        :param pulumi.Input[str] name: The name of the stage. Must be unique within the UpdateRun.
        :param pulumi.Input[int] after_stage_wait_in_seconds: The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        :param pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]] groups: Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
        pulumi.set(__self__, "name", name)
        if after_stage_wait_in_seconds is not None:
            pulumi.set(__self__, "after_stage_wait_in_seconds", after_stage_wait_in_seconds)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stage. Must be unique within the UpdateRun.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="afterStageWaitInSeconds")
    def after_stage_wait_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds to wait at the end of this stage before starting the next one. Defaults to 0 seconds if unspecified.
        """
        return pulumi.get(self, "after_stage_wait_in_seconds")

    @after_stage_wait_in_seconds.setter
    def after_stage_wait_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "after_stage_wait_in_seconds", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]]:
        """
        Defines the groups to be executed in parallel in this stage. Duplicate groups are not allowed. Min size: 1.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UpdateGroupArgs']]]]):
        pulumi.set(self, "groups", value)


