# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AzureActiveDirectoryAppResponse',
    'BackupFileInfoResponse',
    'BackupSetInfoResponse',
    'BlobShareResponse',
    'ConnectToMongoDbTaskPropertiesResponse',
    'ConnectToSourceMySqlTaskInputResponse',
    'ConnectToSourceMySqlTaskPropertiesResponse',
    'ConnectToSourceNonSqlTaskOutputResponse',
    'ConnectToSourceOracleSyncTaskInputResponse',
    'ConnectToSourceOracleSyncTaskOutputResponse',
    'ConnectToSourceOracleSyncTaskPropertiesResponse',
    'ConnectToSourcePostgreSqlSyncTaskInputResponse',
    'ConnectToSourcePostgreSqlSyncTaskOutputResponse',
    'ConnectToSourcePostgreSqlSyncTaskPropertiesResponse',
    'ConnectToSourceSqlServerSyncTaskPropertiesResponse',
    'ConnectToSourceSqlServerTaskInputResponse',
    'ConnectToSourceSqlServerTaskOutputAgentJobLevelResponse',
    'ConnectToSourceSqlServerTaskOutputDatabaseLevelResponse',
    'ConnectToSourceSqlServerTaskOutputLoginLevelResponse',
    'ConnectToSourceSqlServerTaskOutputTaskLevelResponse',
    'ConnectToSourceSqlServerTaskPropertiesResponse',
    'ConnectToTargetAzureDbForMySqlTaskInputResponse',
    'ConnectToTargetAzureDbForMySqlTaskOutputResponse',
    'ConnectToTargetAzureDbForMySqlTaskPropertiesResponse',
    'ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse',
    'ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse',
    'ConnectToTargetAzureDbForPostgreSqlSyncTaskPropertiesResponse',
    'ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse',
    'ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse',
    'ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponseDatabaseSchemaMap',
    'ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse',
    'ConnectToTargetSqlDbTaskInputResponse',
    'ConnectToTargetSqlDbTaskOutputResponse',
    'ConnectToTargetSqlDbTaskPropertiesResponse',
    'ConnectToTargetSqlMISyncTaskInputResponse',
    'ConnectToTargetSqlMISyncTaskOutputResponse',
    'ConnectToTargetSqlMISyncTaskPropertiesResponse',
    'ConnectToTargetSqlMITaskInputResponse',
    'ConnectToTargetSqlMITaskOutputResponse',
    'ConnectToTargetSqlMITaskPropertiesResponse',
    'ConnectToTargetSqlSqlDbSyncTaskInputResponse',
    'ConnectToTargetSqlSqlDbSyncTaskPropertiesResponse',
    'CopyProgressDetailsResponse',
    'DataIntegrityValidationResultResponse',
    'DataItemMigrationSummaryResultResponse',
    'DatabaseBackupInfoResponse',
    'DatabaseFileInfoResponse',
    'DatabaseInfoResponse',
    'DatabaseMigrationPropertiesSqlDbResponse',
    'DatabaseSummaryResultResponse',
    'DatabaseTableResponse',
    'ErrorInfoResponse',
    'ExecutionStatisticsResponse',
    'FileShareResponse',
    'GetTdeCertificatesSqlTaskInputResponse',
    'GetTdeCertificatesSqlTaskOutputResponse',
    'GetTdeCertificatesSqlTaskPropertiesResponse',
    'GetUserTablesMySqlTaskInputResponse',
    'GetUserTablesMySqlTaskOutputResponse',
    'GetUserTablesMySqlTaskPropertiesResponse',
    'GetUserTablesOracleTaskInputResponse',
    'GetUserTablesOracleTaskOutputResponse',
    'GetUserTablesOracleTaskPropertiesResponse',
    'GetUserTablesPostgreSqlTaskInputResponse',
    'GetUserTablesPostgreSqlTaskOutputResponse',
    'GetUserTablesPostgreSqlTaskPropertiesResponse',
    'GetUserTablesSqlSyncTaskInputResponse',
    'GetUserTablesSqlSyncTaskOutputResponse',
    'GetUserTablesSqlSyncTaskPropertiesResponse',
    'GetUserTablesSqlTaskInputResponse',
    'GetUserTablesSqlTaskOutputResponse',
    'GetUserTablesSqlTaskPropertiesResponse',
    'MiSqlConnectionInfoResponse',
    'MigrateMISyncCompleteCommandInputResponse',
    'MigrateMISyncCompleteCommandOutputResponse',
    'MigrateMISyncCompleteCommandPropertiesResponse',
    'MigrateMongoDbTaskPropertiesResponse',
    'MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse',
    'MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse',
    'MigrateMySqlAzureDbForMySqlOfflineTaskOutputDatabaseLevelResponse',
    'MigrateMySqlAzureDbForMySqlOfflineTaskOutputErrorResponse',
    'MigrateMySqlAzureDbForMySqlOfflineTaskOutputMigrationLevelResponse',
    'MigrateMySqlAzureDbForMySqlOfflineTaskOutputTableLevelResponse',
    'MigrateMySqlAzureDbForMySqlOfflineTaskPropertiesResponse',
    'MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse',
    'MigrateMySqlAzureDbForMySqlSyncTaskInputResponse',
    'MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseErrorResponse',
    'MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseLevelResponse',
    'MigrateMySqlAzureDbForMySqlSyncTaskOutputErrorResponse',
    'MigrateMySqlAzureDbForMySqlSyncTaskOutputMigrationLevelResponse',
    'MigrateMySqlAzureDbForMySqlSyncTaskOutputTableLevelResponse',
    'MigrateMySqlAzureDbForMySqlSyncTaskPropertiesResponse',
    'MigrateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse',
    'MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse',
    'MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse',
    'MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseErrorResponse',
    'MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseLevelResponse',
    'MigrateOracleAzureDbPostgreSqlSyncTaskOutputErrorResponse',
    'MigrateOracleAzureDbPostgreSqlSyncTaskOutputMigrationLevelResponse',
    'MigrateOracleAzureDbPostgreSqlSyncTaskOutputTableLevelResponse',
    'MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse',
    'MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseTableInputResponse',
    'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse',
    'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseErrorResponse',
    'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseLevelResponse',
    'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputErrorResponse',
    'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputMigrationLevelResponse',
    'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputTableLevelResponse',
    'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskPropertiesResponse',
    'MigrateSqlServerSqlDbDatabaseInputResponse',
    'MigrateSqlServerSqlDbSyncDatabaseInputResponse',
    'MigrateSqlServerSqlDbSyncTaskInputResponse',
    'MigrateSqlServerSqlDbSyncTaskOutputDatabaseErrorResponse',
    'MigrateSqlServerSqlDbSyncTaskOutputDatabaseLevelResponse',
    'MigrateSqlServerSqlDbSyncTaskOutputErrorResponse',
    'MigrateSqlServerSqlDbSyncTaskOutputMigrationLevelResponse',
    'MigrateSqlServerSqlDbSyncTaskOutputTableLevelResponse',
    'MigrateSqlServerSqlDbSyncTaskPropertiesResponse',
    'MigrateSqlServerSqlDbTaskInputResponse',
    'MigrateSqlServerSqlDbTaskOutputDatabaseLevelResponse',
    'MigrateSqlServerSqlDbTaskOutputDatabaseLevelValidationResultResponse',
    'MigrateSqlServerSqlDbTaskOutputErrorResponse',
    'MigrateSqlServerSqlDbTaskOutputMigrationLevelResponse',
    'MigrateSqlServerSqlDbTaskOutputTableLevelResponse',
    'MigrateSqlServerSqlDbTaskOutputValidationResultResponse',
    'MigrateSqlServerSqlDbTaskPropertiesResponse',
    'MigrateSqlServerSqlMIDatabaseInputResponse',
    'MigrateSqlServerSqlMISyncTaskInputResponse',
    'MigrateSqlServerSqlMISyncTaskOutputDatabaseLevelResponse',
    'MigrateSqlServerSqlMISyncTaskOutputErrorResponse',
    'MigrateSqlServerSqlMISyncTaskOutputMigrationLevelResponse',
    'MigrateSqlServerSqlMISyncTaskPropertiesResponse',
    'MigrateSqlServerSqlMITaskInputResponse',
    'MigrateSqlServerSqlMITaskOutputAgentJobLevelResponse',
    'MigrateSqlServerSqlMITaskOutputDatabaseLevelResponse',
    'MigrateSqlServerSqlMITaskOutputErrorResponse',
    'MigrateSqlServerSqlMITaskOutputLoginLevelResponse',
    'MigrateSqlServerSqlMITaskOutputMigrationLevelResponse',
    'MigrateSqlServerSqlMITaskPropertiesResponse',
    'MigrateSsisTaskInputResponse',
    'MigrateSsisTaskOutputMigrationLevelResponse',
    'MigrateSsisTaskOutputProjectLevelResponse',
    'MigrateSsisTaskPropertiesResponse',
    'MigrateSyncCompleteCommandInputResponse',
    'MigrateSyncCompleteCommandOutputResponse',
    'MigrateSyncCompleteCommandPropertiesResponse',
    'MigrationEligibilityInfoResponse',
    'MigrationReportResultResponse',
    'MigrationValidationDatabaseSummaryResultResponse',
    'MigrationValidationOptionsResponse',
    'MigrationValidationResultResponse',
    'MongoDbClusterInfoResponse',
    'MongoDbCollectionInfoResponse',
    'MongoDbCollectionProgressResponse',
    'MongoDbCollectionSettingsResponse',
    'MongoDbConnectionInfoResponse',
    'MongoDbDatabaseInfoResponse',
    'MongoDbDatabaseProgressResponse',
    'MongoDbDatabaseSettingsResponse',
    'MongoDbErrorResponse',
    'MongoDbMigrationProgressResponse',
    'MongoDbMigrationSettingsResponse',
    'MongoDbShardKeyFieldResponse',
    'MongoDbShardKeyInfoResponse',
    'MongoDbShardKeySettingResponse',
    'MongoDbThrottlingSettingsResponse',
    'MySqlConnectionInfoResponse',
    'NodeMonitoringDataResponse',
    'ODataErrorResponse',
    'OracleConnectionInfoResponse',
    'OrphanedUserInfoResponse',
    'PostgreSqlConnectionInfoResponse',
    'ProjectFilePropertiesResponse',
    'QueryAnalysisValidationResultResponse',
    'QueryExecutionResultResponse',
    'ReportableExceptionResponse',
    'SchemaComparisonValidationResultResponse',
    'SchemaComparisonValidationResultTypeResponse',
    'SelectedCertificateInputResponse',
    'ServerPropertiesResponse',
    'ServiceSkuResponse',
    'SqlConnectionInfoResponse',
    'SqlConnectionInformationResponse',
    'SqlDbMigrationStatusDetailsResponse',
    'SqlDbOfflineConfigurationResponse',
    'SsisMigrationInfoResponse',
    'StartMigrationScenarioServerRoleResultResponse',
    'SyncMigrationDatabaseErrorEventResponse',
    'SystemDataResponse',
    'ValidateMigrationInputSqlServerSqlDbSyncTaskPropertiesResponse',
    'ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse',
    'ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse',
    'ValidateMigrationInputSqlServerSqlMISyncTaskPropertiesResponse',
    'ValidateMigrationInputSqlServerSqlMITaskInputResponse',
    'ValidateMigrationInputSqlServerSqlMITaskOutputResponse',
    'ValidateMigrationInputSqlServerSqlMITaskPropertiesResponse',
    'ValidateMongoDbTaskPropertiesResponse',
    'ValidateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse',
    'ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse',
    'ValidateSyncMigrationInputSqlServerTaskInputResponse',
    'ValidateSyncMigrationInputSqlServerTaskOutputResponse',
    'ValidationErrorResponse',
    'WaitStatisticsResponse',
]

@pulumi.output_type
class AzureActiveDirectoryAppResponse(dict):
    """
    Azure Active Directory Application
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appKey":
            suggest = "app_key"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "ignoreAzurePermissions":
            suggest = "ignore_azure_permissions"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryAppResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryAppResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryAppResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_key: Optional[str] = None,
                 application_id: Optional[str] = None,
                 ignore_azure_permissions: Optional[bool] = None,
                 tenant_id: Optional[str] = None):
        """
        Azure Active Directory Application
        :param str app_key: Key used to authenticate to the Azure Active Directory Application
        :param str application_id: Application ID of the Azure Active Directory Application
        :param bool ignore_azure_permissions: Ignore checking azure permissions on the AAD app
        :param str tenant_id: Tenant id of the customer
        """
        AzureActiveDirectoryAppResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_key=app_key,
            application_id=application_id,
            ignore_azure_permissions=ignore_azure_permissions,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_key: Optional[str] = None,
             application_id: Optional[str] = None,
             ignore_azure_permissions: Optional[bool] = None,
             tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_key is None and 'appKey' in kwargs:
            app_key = kwargs['appKey']
        if application_id is None and 'applicationId' in kwargs:
            application_id = kwargs['applicationId']
        if ignore_azure_permissions is None and 'ignoreAzurePermissions' in kwargs:
            ignore_azure_permissions = kwargs['ignoreAzurePermissions']
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']

        if app_key is not None:
            _setter("app_key", app_key)
        if application_id is not None:
            _setter("application_id", application_id)
        if ignore_azure_permissions is not None:
            _setter("ignore_azure_permissions", ignore_azure_permissions)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="appKey")
    def app_key(self) -> Optional[str]:
        """
        Key used to authenticate to the Azure Active Directory Application
        """
        return pulumi.get(self, "app_key")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        Application ID of the Azure Active Directory Application
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="ignoreAzurePermissions")
    def ignore_azure_permissions(self) -> Optional[bool]:
        """
        Ignore checking azure permissions on the AAD app
        """
        return pulumi.get(self, "ignore_azure_permissions")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Tenant id of the customer
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class BackupFileInfoResponse(dict):
    """
    Information of the backup file
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "familySequenceNumber":
            suggest = "family_sequence_number"
        elif key == "fileLocation":
            suggest = "file_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupFileInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupFileInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupFileInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 family_sequence_number: Optional[int] = None,
                 file_location: Optional[str] = None,
                 status: Optional[str] = None):
        """
        Information of the backup file
        :param int family_sequence_number: Sequence number of the backup file in the backup set
        :param str file_location: Location of the backup file in shared folder
        :param str status: Status of the backup file during migration
        """
        BackupFileInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            family_sequence_number=family_sequence_number,
            file_location=file_location,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             family_sequence_number: Optional[int] = None,
             file_location: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if family_sequence_number is None and 'familySequenceNumber' in kwargs:
            family_sequence_number = kwargs['familySequenceNumber']
        if file_location is None and 'fileLocation' in kwargs:
            file_location = kwargs['fileLocation']

        if family_sequence_number is not None:
            _setter("family_sequence_number", family_sequence_number)
        if file_location is not None:
            _setter("file_location", file_location)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="familySequenceNumber")
    def family_sequence_number(self) -> Optional[int]:
        """
        Sequence number of the backup file in the backup set
        """
        return pulumi.get(self, "family_sequence_number")

    @property
    @pulumi.getter(name="fileLocation")
    def file_location(self) -> Optional[str]:
        """
        Location of the backup file in shared folder
        """
        return pulumi.get(self, "file_location")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the backup file during migration
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class BackupSetInfoResponse(dict):
    """
    Information of backup set
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupFinishedDate":
            suggest = "backup_finished_date"
        elif key == "backupSetId":
            suggest = "backup_set_id"
        elif key == "backupStartDate":
            suggest = "backup_start_date"
        elif key == "backupType":
            suggest = "backup_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "firstLsn":
            suggest = "first_lsn"
        elif key == "isBackupRestored":
            suggest = "is_backup_restored"
        elif key == "lastLsn":
            suggest = "last_lsn"
        elif key == "lastModifiedTime":
            suggest = "last_modified_time"
        elif key == "listOfBackupFiles":
            suggest = "list_of_backup_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupSetInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupSetInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupSetInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_finished_date: Optional[str] = None,
                 backup_set_id: Optional[str] = None,
                 backup_start_date: Optional[str] = None,
                 backup_type: Optional[str] = None,
                 database_name: Optional[str] = None,
                 first_lsn: Optional[str] = None,
                 is_backup_restored: Optional[bool] = None,
                 last_lsn: Optional[str] = None,
                 last_modified_time: Optional[str] = None,
                 list_of_backup_files: Optional[Sequence['outputs.BackupFileInfoResponse']] = None):
        """
        Information of backup set
        :param str backup_finished_date: Date and time that the backup operation finished
        :param str backup_set_id: Id for the set of backup files
        :param str backup_start_date: Date and time that the backup operation began
        :param str backup_type: Enum of the different backup types
        :param str database_name: Name of the database to which the backup set belongs
        :param str first_lsn: First log sequence number of the backup file
        :param bool is_backup_restored: Whether the backup set is restored or not
        :param str last_lsn: Last log sequence number of the backup file
        :param str last_modified_time: Last modified time of the backup file in share location
        :param Sequence['BackupFileInfoResponse'] list_of_backup_files: List of files in the backup set
        """
        BackupSetInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_finished_date=backup_finished_date,
            backup_set_id=backup_set_id,
            backup_start_date=backup_start_date,
            backup_type=backup_type,
            database_name=database_name,
            first_lsn=first_lsn,
            is_backup_restored=is_backup_restored,
            last_lsn=last_lsn,
            last_modified_time=last_modified_time,
            list_of_backup_files=list_of_backup_files,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_finished_date: Optional[str] = None,
             backup_set_id: Optional[str] = None,
             backup_start_date: Optional[str] = None,
             backup_type: Optional[str] = None,
             database_name: Optional[str] = None,
             first_lsn: Optional[str] = None,
             is_backup_restored: Optional[bool] = None,
             last_lsn: Optional[str] = None,
             last_modified_time: Optional[str] = None,
             list_of_backup_files: Optional[Sequence['outputs.BackupFileInfoResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_finished_date is None and 'backupFinishedDate' in kwargs:
            backup_finished_date = kwargs['backupFinishedDate']
        if backup_set_id is None and 'backupSetId' in kwargs:
            backup_set_id = kwargs['backupSetId']
        if backup_start_date is None and 'backupStartDate' in kwargs:
            backup_start_date = kwargs['backupStartDate']
        if backup_type is None and 'backupType' in kwargs:
            backup_type = kwargs['backupType']
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if first_lsn is None and 'firstLsn' in kwargs:
            first_lsn = kwargs['firstLsn']
        if is_backup_restored is None and 'isBackupRestored' in kwargs:
            is_backup_restored = kwargs['isBackupRestored']
        if last_lsn is None and 'lastLsn' in kwargs:
            last_lsn = kwargs['lastLsn']
        if last_modified_time is None and 'lastModifiedTime' in kwargs:
            last_modified_time = kwargs['lastModifiedTime']
        if list_of_backup_files is None and 'listOfBackupFiles' in kwargs:
            list_of_backup_files = kwargs['listOfBackupFiles']

        if backup_finished_date is not None:
            _setter("backup_finished_date", backup_finished_date)
        if backup_set_id is not None:
            _setter("backup_set_id", backup_set_id)
        if backup_start_date is not None:
            _setter("backup_start_date", backup_start_date)
        if backup_type is not None:
            _setter("backup_type", backup_type)
        if database_name is not None:
            _setter("database_name", database_name)
        if first_lsn is not None:
            _setter("first_lsn", first_lsn)
        if is_backup_restored is not None:
            _setter("is_backup_restored", is_backup_restored)
        if last_lsn is not None:
            _setter("last_lsn", last_lsn)
        if last_modified_time is not None:
            _setter("last_modified_time", last_modified_time)
        if list_of_backup_files is not None:
            _setter("list_of_backup_files", list_of_backup_files)

    @property
    @pulumi.getter(name="backupFinishedDate")
    def backup_finished_date(self) -> Optional[str]:
        """
        Date and time that the backup operation finished
        """
        return pulumi.get(self, "backup_finished_date")

    @property
    @pulumi.getter(name="backupSetId")
    def backup_set_id(self) -> Optional[str]:
        """
        Id for the set of backup files
        """
        return pulumi.get(self, "backup_set_id")

    @property
    @pulumi.getter(name="backupStartDate")
    def backup_start_date(self) -> Optional[str]:
        """
        Date and time that the backup operation began
        """
        return pulumi.get(self, "backup_start_date")

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> Optional[str]:
        """
        Enum of the different backup types
        """
        return pulumi.get(self, "backup_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Name of the database to which the backup set belongs
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="firstLsn")
    def first_lsn(self) -> Optional[str]:
        """
        First log sequence number of the backup file
        """
        return pulumi.get(self, "first_lsn")

    @property
    @pulumi.getter(name="isBackupRestored")
    def is_backup_restored(self) -> Optional[bool]:
        """
        Whether the backup set is restored or not
        """
        return pulumi.get(self, "is_backup_restored")

    @property
    @pulumi.getter(name="lastLsn")
    def last_lsn(self) -> Optional[str]:
        """
        Last log sequence number of the backup file
        """
        return pulumi.get(self, "last_lsn")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> Optional[str]:
        """
        Last modified time of the backup file in share location
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="listOfBackupFiles")
    def list_of_backup_files(self) -> Optional[Sequence['outputs.BackupFileInfoResponse']]:
        """
        List of files in the backup set
        """
        return pulumi.get(self, "list_of_backup_files")


@pulumi.output_type
class BlobShareResponse(dict):
    """
    Blob container storage information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUri":
            suggest = "sas_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlobShareResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlobShareResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlobShareResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_uri: Optional[str] = None):
        """
        Blob container storage information.
        :param str sas_uri: SAS URI of Azure Storage Account Container.
        """
        BlobShareResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sas_uri=sas_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sas_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sas_uri is None and 'sasUri' in kwargs:
            sas_uri = kwargs['sasUri']

        if sas_uri is not None:
            _setter("sas_uri", sas_uri)

    @property
    @pulumi.getter(name="sasUri")
    def sas_uri(self) -> Optional[str]:
        """
        SAS URI of Azure Storage Account Container.
        """
        return pulumi.get(self, "sas_uri")


@pulumi.output_type
class ConnectToMongoDbTaskPropertiesResponse(dict):
    """
    Properties for the task that validates the connection to and provides information about a MongoDB server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToMongoDbTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToMongoDbTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToMongoDbTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.MongoDbClusterInfoResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.MongoDbConnectionInfoResponse'] = None):
        """
        Properties for the task that validates the connection to and provides information about a MongoDB server
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['MongoDbClusterInfoResponse'] output: An array containing a single MongoDbClusterInfo object
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Connect.MongoDb'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'MongoDbConnectionInfoResponse' input: Describes a connection to a MongoDB data source
        """
        ConnectToMongoDbTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.MongoDbClusterInfoResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.MongoDbConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Connect.MongoDb')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.MongoDbClusterInfoResponse']:
        """
        An array containing a single MongoDbClusterInfo object
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Connect.MongoDb'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MongoDbConnectionInfoResponse']:
        """
        Describes a connection to a MongoDB data source
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToSourceMySqlTaskInputResponse(dict):
    """
    Input for the task that validates MySQL database connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "checkPermissionsGroup":
            suggest = "check_permissions_group"
        elif key == "isOfflineMigration":
            suggest = "is_offline_migration"
        elif key == "targetPlatform":
            suggest = "target_platform"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceMySqlTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceMySqlTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceMySqlTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_connection_info: 'outputs.MySqlConnectionInfoResponse',
                 check_permissions_group: Optional[str] = None,
                 is_offline_migration: Optional[bool] = None,
                 target_platform: Optional[str] = None):
        """
        Input for the task that validates MySQL database connection
        :param 'MySqlConnectionInfoResponse' source_connection_info: Information for connecting to MySQL source
        :param str check_permissions_group: Permission group for validations
        :param bool is_offline_migration: Flag for whether or not the migration is offline
        :param str target_platform: Target Platform for the migration
        """
        ConnectToSourceMySqlTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_connection_info=source_connection_info,
            check_permissions_group=check_permissions_group,
            is_offline_migration=is_offline_migration,
            target_platform=target_platform,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_connection_info: Optional['outputs.MySqlConnectionInfoResponse'] = None,
             check_permissions_group: Optional[str] = None,
             is_offline_migration: Optional[bool] = None,
             target_platform: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if check_permissions_group is None and 'checkPermissionsGroup' in kwargs:
            check_permissions_group = kwargs['checkPermissionsGroup']
        if is_offline_migration is None and 'isOfflineMigration' in kwargs:
            is_offline_migration = kwargs['isOfflineMigration']
        if target_platform is None and 'targetPlatform' in kwargs:
            target_platform = kwargs['targetPlatform']

        _setter("source_connection_info", source_connection_info)
        if check_permissions_group is not None:
            _setter("check_permissions_group", check_permissions_group)
        if is_offline_migration is None:
            is_offline_migration = False
        if is_offline_migration is not None:
            _setter("is_offline_migration", is_offline_migration)
        if target_platform is not None:
            _setter("target_platform", target_platform)

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.MySqlConnectionInfoResponse':
        """
        Information for connecting to MySQL source
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="checkPermissionsGroup")
    def check_permissions_group(self) -> Optional[str]:
        """
        Permission group for validations
        """
        return pulumi.get(self, "check_permissions_group")

    @property
    @pulumi.getter(name="isOfflineMigration")
    def is_offline_migration(self) -> Optional[bool]:
        """
        Flag for whether or not the migration is offline
        """
        return pulumi.get(self, "is_offline_migration")

    @property
    @pulumi.getter(name="targetPlatform")
    def target_platform(self) -> Optional[str]:
        """
        Target Platform for the migration
        """
        return pulumi.get(self, "target_platform")


@pulumi.output_type
class ConnectToSourceMySqlTaskPropertiesResponse(dict):
    """
    Properties for the task that validates MySQL database connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceMySqlTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceMySqlTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceMySqlTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToSourceNonSqlTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToSourceMySqlTaskInputResponse'] = None):
        """
        Properties for the task that validates MySQL database connection
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToSourceNonSqlTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToSource.MySql'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToSourceMySqlTaskInputResponse' input: Task input
        """
        ConnectToSourceMySqlTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToSourceNonSqlTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToSourceMySqlTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToSource.MySql')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToSourceNonSqlTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToSource.MySql'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToSourceMySqlTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToSourceNonSqlTaskOutputResponse(dict):
    """
    Output for connect to MySQL type source
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverProperties":
            suggest = "server_properties"
        elif key == "sourceServerBrandVersion":
            suggest = "source_server_brand_version"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceNonSqlTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceNonSqlTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceNonSqlTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Sequence[str],
                 id: str,
                 server_properties: 'outputs.ServerPropertiesResponse',
                 source_server_brand_version: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for connect to MySQL type source
        :param Sequence[str] databases: List of databases on the server
        :param str id: Result identifier
        :param 'ServerPropertiesResponse' server_properties: Server properties
        :param str source_server_brand_version: Server brand version
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors associated with the task
        """
        ConnectToSourceNonSqlTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases=databases,
            id=id,
            server_properties=server_properties,
            source_server_brand_version=source_server_brand_version,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases: Optional[Sequence[str]] = None,
             id: Optional[str] = None,
             server_properties: Optional['outputs.ServerPropertiesResponse'] = None,
             source_server_brand_version: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if server_properties is None and 'serverProperties' in kwargs:
            server_properties = kwargs['serverProperties']
        if server_properties is None:
            raise TypeError("Missing 'server_properties' argument")
        if source_server_brand_version is None and 'sourceServerBrandVersion' in kwargs:
            source_server_brand_version = kwargs['sourceServerBrandVersion']
        if source_server_brand_version is None:
            raise TypeError("Missing 'source_server_brand_version' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("databases", databases)
        _setter("id", id)
        _setter("server_properties", server_properties)
        _setter("source_server_brand_version", source_server_brand_version)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter
    def databases(self) -> Sequence[str]:
        """
        List of databases on the server
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serverProperties")
    def server_properties(self) -> 'outputs.ServerPropertiesResponse':
        """
        Server properties
        """
        return pulumi.get(self, "server_properties")

    @property
    @pulumi.getter(name="sourceServerBrandVersion")
    def source_server_brand_version(self) -> str:
        """
        Server brand version
        """
        return pulumi.get(self, "source_server_brand_version")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors associated with the task
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ConnectToSourceOracleSyncTaskInputResponse(dict):
    """
    Input for the task that validates Oracle database connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConnectionInfo":
            suggest = "source_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceOracleSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceOracleSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceOracleSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_connection_info: 'outputs.OracleConnectionInfoResponse'):
        """
        Input for the task that validates Oracle database connection
        :param 'OracleConnectionInfoResponse' source_connection_info: Information for connecting to Oracle source
        """
        ConnectToSourceOracleSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_connection_info=source_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_connection_info: Optional['outputs.OracleConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")

        _setter("source_connection_info", source_connection_info)

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.OracleConnectionInfoResponse':
        """
        Information for connecting to Oracle source
        """
        return pulumi.get(self, "source_connection_info")


@pulumi.output_type
class ConnectToSourceOracleSyncTaskOutputResponse(dict):
    """
    Output for the task that validates Oracle database connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceServerBrandVersion":
            suggest = "source_server_brand_version"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceOracleSyncTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceOracleSyncTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceOracleSyncTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Sequence[str],
                 source_server_brand_version: str,
                 source_server_version: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for the task that validates Oracle database connection
        :param Sequence[str] databases: List of schemas on source server
        :param str source_server_brand_version: Source server brand version
        :param str source_server_version: Version of the source server
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors associated with the task
        """
        ConnectToSourceOracleSyncTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases=databases,
            source_server_brand_version=source_server_brand_version,
            source_server_version=source_server_version,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases: Optional[Sequence[str]] = None,
             source_server_brand_version: Optional[str] = None,
             source_server_version: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if source_server_brand_version is None and 'sourceServerBrandVersion' in kwargs:
            source_server_brand_version = kwargs['sourceServerBrandVersion']
        if source_server_brand_version is None:
            raise TypeError("Missing 'source_server_brand_version' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("databases", databases)
        _setter("source_server_brand_version", source_server_brand_version)
        _setter("source_server_version", source_server_version)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter
    def databases(self) -> Sequence[str]:
        """
        List of schemas on source server
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="sourceServerBrandVersion")
    def source_server_brand_version(self) -> str:
        """
        Source server brand version
        """
        return pulumi.get(self, "source_server_brand_version")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Version of the source server
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors associated with the task
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ConnectToSourceOracleSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that validates Oracle database connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceOracleSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceOracleSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceOracleSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToSourceOracleSyncTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToSourceOracleSyncTaskInputResponse'] = None):
        """
        Properties for the task that validates Oracle database connection
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToSourceOracleSyncTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToSource.Oracle.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToSourceOracleSyncTaskInputResponse' input: Task input
        """
        ConnectToSourceOracleSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToSourceOracleSyncTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToSourceOracleSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToSource.Oracle.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToSourceOracleSyncTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToSource.Oracle.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToSourceOracleSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToSourcePostgreSqlSyncTaskInputResponse(dict):
    """
    Input for the task that validates connection to PostgreSQL and source server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConnectionInfo":
            suggest = "source_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourcePostgreSqlSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourcePostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourcePostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_connection_info: 'outputs.PostgreSqlConnectionInfoResponse'):
        """
        Input for the task that validates connection to PostgreSQL and source server requirements
        :param 'PostgreSqlConnectionInfoResponse' source_connection_info: Connection information for source PostgreSQL server
        """
        ConnectToSourcePostgreSqlSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_connection_info=source_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_connection_info: Optional['outputs.PostgreSqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")

        _setter("source_connection_info", source_connection_info)

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.PostgreSqlConnectionInfoResponse':
        """
        Connection information for source PostgreSQL server
        """
        return pulumi.get(self, "source_connection_info")


@pulumi.output_type
class ConnectToSourcePostgreSqlSyncTaskOutputResponse(dict):
    """
    Output for the task that validates connection to PostgreSQL and source server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceServerBrandVersion":
            suggest = "source_server_brand_version"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourcePostgreSqlSyncTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourcePostgreSqlSyncTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourcePostgreSqlSyncTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Sequence[str],
                 id: str,
                 source_server_brand_version: str,
                 source_server_version: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for the task that validates connection to PostgreSQL and source server requirements
        :param Sequence[str] databases: List of databases on source server
        :param str id: Result identifier
        :param str source_server_brand_version: Source server brand version
        :param str source_server_version: Version of the source server
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors associated with the task
        """
        ConnectToSourcePostgreSqlSyncTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases=databases,
            id=id,
            source_server_brand_version=source_server_brand_version,
            source_server_version=source_server_version,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases: Optional[Sequence[str]] = None,
             id: Optional[str] = None,
             source_server_brand_version: Optional[str] = None,
             source_server_version: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if source_server_brand_version is None and 'sourceServerBrandVersion' in kwargs:
            source_server_brand_version = kwargs['sourceServerBrandVersion']
        if source_server_brand_version is None:
            raise TypeError("Missing 'source_server_brand_version' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("databases", databases)
        _setter("id", id)
        _setter("source_server_brand_version", source_server_brand_version)
        _setter("source_server_version", source_server_version)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter
    def databases(self) -> Sequence[str]:
        """
        List of databases on source server
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="sourceServerBrandVersion")
    def source_server_brand_version(self) -> str:
        """
        Source server brand version
        """
        return pulumi.get(self, "source_server_brand_version")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Version of the source server
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors associated with the task
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ConnectToSourcePostgreSqlSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to PostgreSQL server and source server requirements for online migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourcePostgreSqlSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourcePostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourcePostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToSourcePostgreSqlSyncTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToSourcePostgreSqlSyncTaskInputResponse'] = None):
        """
        Properties for the task that validates connection to PostgreSQL server and source server requirements for online migration
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToSourcePostgreSqlSyncTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToSource.PostgreSql.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToSourcePostgreSqlSyncTaskInputResponse' input: Task input
        """
        ConnectToSourcePostgreSqlSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToSourcePostgreSqlSyncTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToSourcePostgreSqlSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToSource.PostgreSql.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToSourcePostgreSqlSyncTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToSource.PostgreSql.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToSourcePostgreSqlSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToSourceSqlServerSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to SQL Server and source server requirements for online migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceSqlServerSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceSqlServerSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceSqlServerSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToSourceSqlServerTaskInputResponse'] = None):
        """
        Properties for the task that validates connection to SQL Server and source server requirements for online migration
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['ConnectToSourceSqlServerTaskOutputAgentJobLevelResponse', 'ConnectToSourceSqlServerTaskOutputDatabaseLevelResponse', 'ConnectToSourceSqlServerTaskOutputLoginLevelResponse', 'ConnectToSourceSqlServerTaskOutputTaskLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToSource.SqlServer.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToSourceSqlServerTaskInputResponse' input: Task input
        """
        ConnectToSourceSqlServerSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToSourceSqlServerTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToSource.SqlServer.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToSource.SqlServer.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToSourceSqlServerTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToSourceSqlServerTaskInputResponse(dict):
    """
    Input for the task that validates connection to SQL Server and also validates source server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "checkPermissionsGroup":
            suggest = "check_permissions_group"
        elif key == "collectAgentJobs":
            suggest = "collect_agent_jobs"
        elif key == "collectDatabases":
            suggest = "collect_databases"
        elif key == "collectLogins":
            suggest = "collect_logins"
        elif key == "collectTdeCertificateInfo":
            suggest = "collect_tde_certificate_info"
        elif key == "encryptedKeyForSecureFields":
            suggest = "encrypted_key_for_secure_fields"
        elif key == "validateSsisCatalogOnly":
            suggest = "validate_ssis_catalog_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceSqlServerTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceSqlServerTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceSqlServerTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 check_permissions_group: Optional[str] = None,
                 collect_agent_jobs: Optional[bool] = None,
                 collect_databases: Optional[bool] = None,
                 collect_logins: Optional[bool] = None,
                 collect_tde_certificate_info: Optional[bool] = None,
                 encrypted_key_for_secure_fields: Optional[str] = None,
                 validate_ssis_catalog_only: Optional[bool] = None):
        """
        Input for the task that validates connection to SQL Server and also validates source server requirements
        :param 'SqlConnectionInfoResponse' source_connection_info: Connection information for Source SQL Server
        :param str check_permissions_group: Permission group for validations
        :param bool collect_agent_jobs: Flag for whether to collect agent jobs from source server.
        :param bool collect_databases: Flag for whether to collect databases from source server.
        :param bool collect_logins: Flag for whether to collect logins from source server.
        :param bool collect_tde_certificate_info: Flag for whether to collect TDE Certificate names from source server.
        :param str encrypted_key_for_secure_fields: encrypted key for secure fields
        :param bool validate_ssis_catalog_only: Flag for whether to validate SSIS catalog is reachable on the source server.
        """
        ConnectToSourceSqlServerTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_connection_info=source_connection_info,
            check_permissions_group=check_permissions_group,
            collect_agent_jobs=collect_agent_jobs,
            collect_databases=collect_databases,
            collect_logins=collect_logins,
            collect_tde_certificate_info=collect_tde_certificate_info,
            encrypted_key_for_secure_fields=encrypted_key_for_secure_fields,
            validate_ssis_catalog_only=validate_ssis_catalog_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             check_permissions_group: Optional[str] = None,
             collect_agent_jobs: Optional[bool] = None,
             collect_databases: Optional[bool] = None,
             collect_logins: Optional[bool] = None,
             collect_tde_certificate_info: Optional[bool] = None,
             encrypted_key_for_secure_fields: Optional[str] = None,
             validate_ssis_catalog_only: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if check_permissions_group is None and 'checkPermissionsGroup' in kwargs:
            check_permissions_group = kwargs['checkPermissionsGroup']
        if collect_agent_jobs is None and 'collectAgentJobs' in kwargs:
            collect_agent_jobs = kwargs['collectAgentJobs']
        if collect_databases is None and 'collectDatabases' in kwargs:
            collect_databases = kwargs['collectDatabases']
        if collect_logins is None and 'collectLogins' in kwargs:
            collect_logins = kwargs['collectLogins']
        if collect_tde_certificate_info is None and 'collectTdeCertificateInfo' in kwargs:
            collect_tde_certificate_info = kwargs['collectTdeCertificateInfo']
        if encrypted_key_for_secure_fields is None and 'encryptedKeyForSecureFields' in kwargs:
            encrypted_key_for_secure_fields = kwargs['encryptedKeyForSecureFields']
        if validate_ssis_catalog_only is None and 'validateSsisCatalogOnly' in kwargs:
            validate_ssis_catalog_only = kwargs['validateSsisCatalogOnly']

        _setter("source_connection_info", source_connection_info)
        if check_permissions_group is not None:
            _setter("check_permissions_group", check_permissions_group)
        if collect_agent_jobs is None:
            collect_agent_jobs = False
        if collect_agent_jobs is not None:
            _setter("collect_agent_jobs", collect_agent_jobs)
        if collect_databases is None:
            collect_databases = True
        if collect_databases is not None:
            _setter("collect_databases", collect_databases)
        if collect_logins is None:
            collect_logins = False
        if collect_logins is not None:
            _setter("collect_logins", collect_logins)
        if collect_tde_certificate_info is None:
            collect_tde_certificate_info = False
        if collect_tde_certificate_info is not None:
            _setter("collect_tde_certificate_info", collect_tde_certificate_info)
        if encrypted_key_for_secure_fields is not None:
            _setter("encrypted_key_for_secure_fields", encrypted_key_for_secure_fields)
        if validate_ssis_catalog_only is None:
            validate_ssis_catalog_only = False
        if validate_ssis_catalog_only is not None:
            _setter("validate_ssis_catalog_only", validate_ssis_catalog_only)

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for Source SQL Server
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="checkPermissionsGroup")
    def check_permissions_group(self) -> Optional[str]:
        """
        Permission group for validations
        """
        return pulumi.get(self, "check_permissions_group")

    @property
    @pulumi.getter(name="collectAgentJobs")
    def collect_agent_jobs(self) -> Optional[bool]:
        """
        Flag for whether to collect agent jobs from source server.
        """
        return pulumi.get(self, "collect_agent_jobs")

    @property
    @pulumi.getter(name="collectDatabases")
    def collect_databases(self) -> Optional[bool]:
        """
        Flag for whether to collect databases from source server.
        """
        return pulumi.get(self, "collect_databases")

    @property
    @pulumi.getter(name="collectLogins")
    def collect_logins(self) -> Optional[bool]:
        """
        Flag for whether to collect logins from source server.
        """
        return pulumi.get(self, "collect_logins")

    @property
    @pulumi.getter(name="collectTdeCertificateInfo")
    def collect_tde_certificate_info(self) -> Optional[bool]:
        """
        Flag for whether to collect TDE Certificate names from source server.
        """
        return pulumi.get(self, "collect_tde_certificate_info")

    @property
    @pulumi.getter(name="encryptedKeyForSecureFields")
    def encrypted_key_for_secure_fields(self) -> Optional[str]:
        """
        encrypted key for secure fields
        """
        return pulumi.get(self, "encrypted_key_for_secure_fields")

    @property
    @pulumi.getter(name="validateSsisCatalogOnly")
    def validate_ssis_catalog_only(self) -> Optional[bool]:
        """
        Flag for whether to validate SSIS catalog is reachable on the source server.
        """
        return pulumi.get(self, "validate_ssis_catalog_only")


@pulumi.output_type
class ConnectToSourceSqlServerTaskOutputAgentJobLevelResponse(dict):
    """
    Agent Job level output for the task that validates connection to SQL Server and also validates source server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "jobCategory":
            suggest = "job_category"
        elif key == "jobOwner":
            suggest = "job_owner"
        elif key == "lastExecutedOn":
            suggest = "last_executed_on"
        elif key == "migrationEligibility":
            suggest = "migration_eligibility"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceSqlServerTaskOutputAgentJobLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceSqlServerTaskOutputAgentJobLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceSqlServerTaskOutputAgentJobLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 is_enabled: bool,
                 job_category: str,
                 job_owner: str,
                 last_executed_on: str,
                 migration_eligibility: 'outputs.MigrationEligibilityInfoResponse',
                 name: str,
                 result_type: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Agent Job level output for the task that validates connection to SQL Server and also validates source server requirements
        :param str id: Result identifier
        :param bool is_enabled: The state of the original Agent Job.
        :param str job_category: The type of Agent Job.
        :param str job_owner: The owner of the Agent Job
        :param str last_executed_on: UTC Date and time when the Agent Job was last executed.
        :param 'MigrationEligibilityInfoResponse' migration_eligibility: Information about eligibility of agent job for migration.
        :param str name: Agent Job name
        :param str result_type: Type of result - database level or task level
               Expected value is 'AgentJobLevelOutput'.
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors
        """
        ConnectToSourceSqlServerTaskOutputAgentJobLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            is_enabled=is_enabled,
            job_category=job_category,
            job_owner=job_owner,
            last_executed_on=last_executed_on,
            migration_eligibility=migration_eligibility,
            name=name,
            result_type=result_type,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             job_category: Optional[str] = None,
             job_owner: Optional[str] = None,
             last_executed_on: Optional[str] = None,
             migration_eligibility: Optional['outputs.MigrationEligibilityInfoResponse'] = None,
             name: Optional[str] = None,
             result_type: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if job_category is None and 'jobCategory' in kwargs:
            job_category = kwargs['jobCategory']
        if job_category is None:
            raise TypeError("Missing 'job_category' argument")
        if job_owner is None and 'jobOwner' in kwargs:
            job_owner = kwargs['jobOwner']
        if job_owner is None:
            raise TypeError("Missing 'job_owner' argument")
        if last_executed_on is None and 'lastExecutedOn' in kwargs:
            last_executed_on = kwargs['lastExecutedOn']
        if last_executed_on is None:
            raise TypeError("Missing 'last_executed_on' argument")
        if migration_eligibility is None and 'migrationEligibility' in kwargs:
            migration_eligibility = kwargs['migrationEligibility']
        if migration_eligibility is None:
            raise TypeError("Missing 'migration_eligibility' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("id", id)
        _setter("is_enabled", is_enabled)
        _setter("job_category", job_category)
        _setter("job_owner", job_owner)
        _setter("last_executed_on", last_executed_on)
        _setter("migration_eligibility", migration_eligibility)
        _setter("name", name)
        _setter("result_type", 'AgentJobLevelOutput')
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        The state of the original Agent Job.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="jobCategory")
    def job_category(self) -> str:
        """
        The type of Agent Job.
        """
        return pulumi.get(self, "job_category")

    @property
    @pulumi.getter(name="jobOwner")
    def job_owner(self) -> str:
        """
        The owner of the Agent Job
        """
        return pulumi.get(self, "job_owner")

    @property
    @pulumi.getter(name="lastExecutedOn")
    def last_executed_on(self) -> str:
        """
        UTC Date and time when the Agent Job was last executed.
        """
        return pulumi.get(self, "last_executed_on")

    @property
    @pulumi.getter(name="migrationEligibility")
    def migration_eligibility(self) -> 'outputs.MigrationEligibilityInfoResponse':
        """
        Information about eligibility of agent job for migration.
        """
        return pulumi.get(self, "migration_eligibility")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Agent Job name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Type of result - database level or task level
        Expected value is 'AgentJobLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ConnectToSourceSqlServerTaskOutputDatabaseLevelResponse(dict):
    """
    Database level output for the task that validates connection to SQL Server and also validates source server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compatibilityLevel":
            suggest = "compatibility_level"
        elif key == "databaseFiles":
            suggest = "database_files"
        elif key == "databaseState":
            suggest = "database_state"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sizeMB":
            suggest = "size_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceSqlServerTaskOutputDatabaseLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceSqlServerTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceSqlServerTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compatibility_level: str,
                 database_files: Sequence['outputs.DatabaseFileInfoResponse'],
                 database_state: str,
                 id: str,
                 name: str,
                 result_type: str,
                 size_mb: float):
        """
        Database level output for the task that validates connection to SQL Server and also validates source server requirements
        :param str compatibility_level: SQL Server compatibility level of database
        :param Sequence['DatabaseFileInfoResponse'] database_files: The list of database files
        :param str database_state: State of the database
        :param str id: Result identifier
        :param str name: Database name
        :param str result_type: Type of result - database level or task level
               Expected value is 'DatabaseLevelOutput'.
        :param float size_mb: Size of the file in megabytes
        """
        ConnectToSourceSqlServerTaskOutputDatabaseLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compatibility_level=compatibility_level,
            database_files=database_files,
            database_state=database_state,
            id=id,
            name=name,
            result_type=result_type,
            size_mb=size_mb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compatibility_level: Optional[str] = None,
             database_files: Optional[Sequence['outputs.DatabaseFileInfoResponse']] = None,
             database_state: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             result_type: Optional[str] = None,
             size_mb: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compatibility_level is None and 'compatibilityLevel' in kwargs:
            compatibility_level = kwargs['compatibilityLevel']
        if compatibility_level is None:
            raise TypeError("Missing 'compatibility_level' argument")
        if database_files is None and 'databaseFiles' in kwargs:
            database_files = kwargs['databaseFiles']
        if database_files is None:
            raise TypeError("Missing 'database_files' argument")
        if database_state is None and 'databaseState' in kwargs:
            database_state = kwargs['databaseState']
        if database_state is None:
            raise TypeError("Missing 'database_state' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if size_mb is None and 'sizeMB' in kwargs:
            size_mb = kwargs['sizeMB']
        if size_mb is None:
            raise TypeError("Missing 'size_mb' argument")

        _setter("compatibility_level", compatibility_level)
        _setter("database_files", database_files)
        _setter("database_state", database_state)
        _setter("id", id)
        _setter("name", name)
        _setter("result_type", 'DatabaseLevelOutput')
        _setter("size_mb", size_mb)

    @property
    @pulumi.getter(name="compatibilityLevel")
    def compatibility_level(self) -> str:
        """
        SQL Server compatibility level of database
        """
        return pulumi.get(self, "compatibility_level")

    @property
    @pulumi.getter(name="databaseFiles")
    def database_files(self) -> Sequence['outputs.DatabaseFileInfoResponse']:
        """
        The list of database files
        """
        return pulumi.get(self, "database_files")

    @property
    @pulumi.getter(name="databaseState")
    def database_state(self) -> str:
        """
        State of the database
        """
        return pulumi.get(self, "database_state")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Database name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Type of result - database level or task level
        Expected value is 'DatabaseLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sizeMB")
    def size_mb(self) -> float:
        """
        Size of the file in megabytes
        """
        return pulumi.get(self, "size_mb")


@pulumi.output_type
class ConnectToSourceSqlServerTaskOutputLoginLevelResponse(dict):
    """
    Login level output for the task that validates connection to SQL Server and also validates source server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDatabase":
            suggest = "default_database"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "loginType":
            suggest = "login_type"
        elif key == "migrationEligibility":
            suggest = "migration_eligibility"
        elif key == "resultType":
            suggest = "result_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceSqlServerTaskOutputLoginLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceSqlServerTaskOutputLoginLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceSqlServerTaskOutputLoginLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_database: str,
                 id: str,
                 is_enabled: bool,
                 login_type: str,
                 migration_eligibility: 'outputs.MigrationEligibilityInfoResponse',
                 name: str,
                 result_type: str):
        """
        Login level output for the task that validates connection to SQL Server and also validates source server requirements
        :param str default_database: The default database for the login.
        :param str id: Result identifier
        :param bool is_enabled: The state of the login.
        :param str login_type: The type of login.
        :param 'MigrationEligibilityInfoResponse' migration_eligibility: Information about eligibility of login for migration.
        :param str name: Login name.
        :param str result_type: Type of result - database level or task level
               Expected value is 'LoginLevelOutput'.
        """
        ConnectToSourceSqlServerTaskOutputLoginLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_database=default_database,
            id=id,
            is_enabled=is_enabled,
            login_type=login_type,
            migration_eligibility=migration_eligibility,
            name=name,
            result_type=result_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_database: Optional[str] = None,
             id: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             login_type: Optional[str] = None,
             migration_eligibility: Optional['outputs.MigrationEligibilityInfoResponse'] = None,
             name: Optional[str] = None,
             result_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_database is None and 'defaultDatabase' in kwargs:
            default_database = kwargs['defaultDatabase']
        if default_database is None:
            raise TypeError("Missing 'default_database' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if login_type is None and 'loginType' in kwargs:
            login_type = kwargs['loginType']
        if login_type is None:
            raise TypeError("Missing 'login_type' argument")
        if migration_eligibility is None and 'migrationEligibility' in kwargs:
            migration_eligibility = kwargs['migrationEligibility']
        if migration_eligibility is None:
            raise TypeError("Missing 'migration_eligibility' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")

        _setter("default_database", default_database)
        _setter("id", id)
        _setter("is_enabled", is_enabled)
        _setter("login_type", login_type)
        _setter("migration_eligibility", migration_eligibility)
        _setter("name", name)
        _setter("result_type", 'LoginLevelOutput')

    @property
    @pulumi.getter(name="defaultDatabase")
    def default_database(self) -> str:
        """
        The default database for the login.
        """
        return pulumi.get(self, "default_database")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        The state of the login.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="loginType")
    def login_type(self) -> str:
        """
        The type of login.
        """
        return pulumi.get(self, "login_type")

    @property
    @pulumi.getter(name="migrationEligibility")
    def migration_eligibility(self) -> 'outputs.MigrationEligibilityInfoResponse':
        """
        Information about eligibility of login for migration.
        """
        return pulumi.get(self, "migration_eligibility")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Login name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Type of result - database level or task level
        Expected value is 'LoginLevelOutput'.
        """
        return pulumi.get(self, "result_type")


@pulumi.output_type
class ConnectToSourceSqlServerTaskOutputTaskLevelResponse(dict):
    """
    Task level output for the task that validates connection to SQL Server and also validates source server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentJobs":
            suggest = "agent_jobs"
        elif key == "databaseTdeCertificateMapping":
            suggest = "database_tde_certificate_mapping"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceServerBrandVersion":
            suggest = "source_server_brand_version"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceSqlServerTaskOutputTaskLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceSqlServerTaskOutputTaskLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceSqlServerTaskOutputTaskLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_jobs: Mapping[str, str],
                 database_tde_certificate_mapping: Mapping[str, str],
                 databases: Mapping[str, str],
                 id: str,
                 logins: Mapping[str, str],
                 result_type: str,
                 source_server_brand_version: str,
                 source_server_version: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Task level output for the task that validates connection to SQL Server and also validates source server requirements
        :param Mapping[str, str] agent_jobs: Source agent jobs as a map from agent job name to id.
        :param Mapping[str, str] database_tde_certificate_mapping: Mapping from database name to TDE certificate name, if applicable
        :param Mapping[str, str] databases: Source databases as a map from database name to database id
        :param str id: Result identifier
        :param Mapping[str, str] logins: Source logins as a map from login name to login id.
        :param str result_type: Type of result - database level or task level
               Expected value is 'TaskLevelOutput'.
        :param str source_server_brand_version: Source server brand version
        :param str source_server_version: Source server version
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors
        """
        ConnectToSourceSqlServerTaskOutputTaskLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_jobs=agent_jobs,
            database_tde_certificate_mapping=database_tde_certificate_mapping,
            databases=databases,
            id=id,
            logins=logins,
            result_type=result_type,
            source_server_brand_version=source_server_brand_version,
            source_server_version=source_server_version,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_jobs: Optional[Mapping[str, str]] = None,
             database_tde_certificate_mapping: Optional[Mapping[str, str]] = None,
             databases: Optional[Mapping[str, str]] = None,
             id: Optional[str] = None,
             logins: Optional[Mapping[str, str]] = None,
             result_type: Optional[str] = None,
             source_server_brand_version: Optional[str] = None,
             source_server_version: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if agent_jobs is None and 'agentJobs' in kwargs:
            agent_jobs = kwargs['agentJobs']
        if agent_jobs is None:
            raise TypeError("Missing 'agent_jobs' argument")
        if database_tde_certificate_mapping is None and 'databaseTdeCertificateMapping' in kwargs:
            database_tde_certificate_mapping = kwargs['databaseTdeCertificateMapping']
        if database_tde_certificate_mapping is None:
            raise TypeError("Missing 'database_tde_certificate_mapping' argument")
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if logins is None:
            raise TypeError("Missing 'logins' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_server_brand_version is None and 'sourceServerBrandVersion' in kwargs:
            source_server_brand_version = kwargs['sourceServerBrandVersion']
        if source_server_brand_version is None:
            raise TypeError("Missing 'source_server_brand_version' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("agent_jobs", agent_jobs)
        _setter("database_tde_certificate_mapping", database_tde_certificate_mapping)
        _setter("databases", databases)
        _setter("id", id)
        _setter("logins", logins)
        _setter("result_type", 'TaskLevelOutput')
        _setter("source_server_brand_version", source_server_brand_version)
        _setter("source_server_version", source_server_version)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="agentJobs")
    def agent_jobs(self) -> Mapping[str, str]:
        """
        Source agent jobs as a map from agent job name to id.
        """
        return pulumi.get(self, "agent_jobs")

    @property
    @pulumi.getter(name="databaseTdeCertificateMapping")
    def database_tde_certificate_mapping(self) -> Mapping[str, str]:
        """
        Mapping from database name to TDE certificate name, if applicable
        """
        return pulumi.get(self, "database_tde_certificate_mapping")

    @property
    @pulumi.getter
    def databases(self) -> Mapping[str, str]:
        """
        Source databases as a map from database name to database id
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logins(self) -> Mapping[str, str]:
        """
        Source logins as a map from login name to login id.
        """
        return pulumi.get(self, "logins")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Type of result - database level or task level
        Expected value is 'TaskLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceServerBrandVersion")
    def source_server_brand_version(self) -> str:
        """
        Source server brand version
        """
        return pulumi.get(self, "source_server_brand_version")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ConnectToSourceSqlServerTaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to SQL Server and also validates source server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"
        elif key == "taskId":
            suggest = "task_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToSourceSqlServerTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToSourceSqlServerTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToSourceSqlServerTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToSourceSqlServerTaskInputResponse'] = None,
                 task_id: Optional[str] = None):
        """
        Properties for the task that validates connection to SQL Server and also validates source server requirements
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['ConnectToSourceSqlServerTaskOutputAgentJobLevelResponse', 'ConnectToSourceSqlServerTaskOutputDatabaseLevelResponse', 'ConnectToSourceSqlServerTaskOutputLoginLevelResponse', 'ConnectToSourceSqlServerTaskOutputTaskLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToSource.SqlServer'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToSourceSqlServerTaskInputResponse' input: Task input
        :param str task_id: Task id 
        """
        ConnectToSourceSqlServerTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
            task_id=task_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToSourceSqlServerTaskInputResponse'] = None,
             task_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']
        if task_id is None and 'taskId' in kwargs:
            task_id = kwargs['taskId']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToSource.SqlServer')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)
        if task_id is not None:
            _setter("task_id", task_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToSource.SqlServer'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToSourceSqlServerTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[str]:
        """
        Task id 
        """
        return pulumi.get(self, "task_id")


@pulumi.output_type
class ConnectToTargetAzureDbForMySqlTaskInputResponse(dict):
    """
    Input for the task that validates connection to Azure Database for MySQL and target server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "isOfflineMigration":
            suggest = "is_offline_migration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetAzureDbForMySqlTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetAzureDbForMySqlTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetAzureDbForMySqlTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_connection_info: 'outputs.MySqlConnectionInfoResponse',
                 target_connection_info: 'outputs.MySqlConnectionInfoResponse',
                 is_offline_migration: Optional[bool] = None):
        """
        Input for the task that validates connection to Azure Database for MySQL and target server requirements
        :param 'MySqlConnectionInfoResponse' source_connection_info: Connection information for source MySQL server
        :param 'MySqlConnectionInfoResponse' target_connection_info: Connection information for target Azure Database for MySQL server
        :param bool is_offline_migration: Flag for whether or not the migration is offline
        """
        ConnectToTargetAzureDbForMySqlTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
            is_offline_migration=is_offline_migration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_connection_info: Optional['outputs.MySqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.MySqlConnectionInfoResponse'] = None,
             is_offline_migration: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if is_offline_migration is None and 'isOfflineMigration' in kwargs:
            is_offline_migration = kwargs['isOfflineMigration']

        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)
        if is_offline_migration is None:
            is_offline_migration = False
        if is_offline_migration is not None:
            _setter("is_offline_migration", is_offline_migration)

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.MySqlConnectionInfoResponse':
        """
        Connection information for source MySQL server
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.MySqlConnectionInfoResponse':
        """
        Connection information for target Azure Database for MySQL server
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="isOfflineMigration")
    def is_offline_migration(self) -> Optional[bool]:
        """
        Flag for whether or not the migration is offline
        """
        return pulumi.get(self, "is_offline_migration")


@pulumi.output_type
class ConnectToTargetAzureDbForMySqlTaskOutputResponse(dict):
    """
    Output for the task that validates connection to Azure Database for MySQL and target server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverVersion":
            suggest = "server_version"
        elif key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetAzureDbForMySqlTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetAzureDbForMySqlTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetAzureDbForMySqlTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Sequence[str],
                 id: str,
                 server_version: str,
                 target_server_brand_version: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for the task that validates connection to Azure Database for MySQL and target server requirements
        :param Sequence[str] databases: List of databases on target server
        :param str id: Result identifier
        :param str server_version: Version of the target server
        :param str target_server_brand_version: Target server brand version
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors associated with the task
        """
        ConnectToTargetAzureDbForMySqlTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases=databases,
            id=id,
            server_version=server_version,
            target_server_brand_version=target_server_brand_version,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases: Optional[Sequence[str]] = None,
             id: Optional[str] = None,
             server_version: Optional[str] = None,
             target_server_brand_version: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if server_version is None and 'serverVersion' in kwargs:
            server_version = kwargs['serverVersion']
        if server_version is None:
            raise TypeError("Missing 'server_version' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("databases", databases)
        _setter("id", id)
        _setter("server_version", server_version)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter
    def databases(self) -> Sequence[str]:
        """
        List of databases on target server
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> str:
        """
        Version of the target server
        """
        return pulumi.get(self, "server_version")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors associated with the task
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ConnectToTargetAzureDbForMySqlTaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to Azure Database for MySQL and target server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetAzureDbForMySqlTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetAzureDbForMySqlTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetAzureDbForMySqlTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToTargetAzureDbForMySqlTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToTargetAzureDbForMySqlTaskInputResponse'] = None):
        """
        Properties for the task that validates connection to Azure Database for MySQL and target server requirements
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToTargetAzureDbForMySqlTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToTarget.AzureDbForMySql'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToTargetAzureDbForMySqlTaskInputResponse' input: Task input
        """
        ConnectToTargetAzureDbForMySqlTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToTargetAzureDbForMySqlTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToTargetAzureDbForMySqlTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToTarget.AzureDbForMySql')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToTargetAzureDbForMySqlTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToTarget.AzureDbForMySql'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToTargetAzureDbForMySqlTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse(dict):
    """
    Input for the task that validates connection to Azure Database for PostgreSQL and target server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_connection_info: 'outputs.PostgreSqlConnectionInfoResponse',
                 target_connection_info: 'outputs.PostgreSqlConnectionInfoResponse'):
        """
        Input for the task that validates connection to Azure Database for PostgreSQL and target server requirements
        :param 'PostgreSqlConnectionInfoResponse' source_connection_info: Connection information for source PostgreSQL server
        :param 'PostgreSqlConnectionInfoResponse' target_connection_info: Connection information for target Azure Database for PostgreSQL server
        """
        ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_connection_info: Optional['outputs.PostgreSqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.PostgreSqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")

        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.PostgreSqlConnectionInfoResponse':
        """
        Connection information for source PostgreSQL server
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.PostgreSqlConnectionInfoResponse':
        """
        Connection information for target Azure Database for PostgreSQL server
        """
        return pulumi.get(self, "target_connection_info")


@pulumi.output_type
class ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse(dict):
    """
    Output for the task that validates connection to Azure Database for PostgreSQL and target server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerVersion":
            suggest = "target_server_version"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Sequence[str],
                 id: str,
                 target_server_brand_version: str,
                 target_server_version: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for the task that validates connection to Azure Database for PostgreSQL and target server requirements
        :param Sequence[str] databases: List of databases on target server
        :param str id: Result identifier
        :param str target_server_brand_version: Target server brand version
        :param str target_server_version: Version of the target server
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors associated with the task
        """
        ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases=databases,
            id=id,
            target_server_brand_version=target_server_brand_version,
            target_server_version=target_server_version,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases: Optional[Sequence[str]] = None,
             id: Optional[str] = None,
             target_server_brand_version: Optional[str] = None,
             target_server_version: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("databases", databases)
        _setter("id", id)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_version", target_server_version)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter
    def databases(self) -> Sequence[str]:
        """
        List of databases on target server
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Version of the target server
        """
        return pulumi.get(self, "target_server_version")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors associated with the task
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ConnectToTargetAzureDbForPostgreSqlSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to Azure Database For PostgreSQL server and target server requirements for online migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetAzureDbForPostgreSqlSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse'] = None):
        """
        Properties for the task that validates connection to Azure Database For PostgreSQL server and target server requirements for online migration
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToTarget.AzureDbForPostgreSql.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse' input: Task input
        """
        ConnectToTargetAzureDbForPostgreSqlSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToTarget.AzureDbForPostgreSql.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToTargetAzureDbForPostgreSqlSyncTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToTarget.AzureDbForPostgreSql.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToTargetAzureDbForPostgreSqlSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse(dict):
    """
    Input for the task that validates connection to Azure Database for PostgreSQL and target server requirements for Oracle source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetConnectionInfo":
            suggest = "target_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_connection_info: 'outputs.PostgreSqlConnectionInfoResponse'):
        """
        Input for the task that validates connection to Azure Database for PostgreSQL and target server requirements for Oracle source.
        :param 'PostgreSqlConnectionInfoResponse' target_connection_info: Connection information for target Azure Database for PostgreSQL server
        """
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_connection_info=target_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_connection_info: Optional['outputs.PostgreSqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")

        _setter("target_connection_info", target_connection_info)

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.PostgreSqlConnectionInfoResponse':
        """
        Connection information for target Azure Database for PostgreSQL server
        """
        return pulumi.get(self, "target_connection_info")


@pulumi.output_type
class ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse(dict):
    """
    Output for the task that validates connection to Azure Database for PostgreSQL and target server requirements for Oracle source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerVersion":
            suggest = "target_server_version"
        elif key == "validationErrors":
            suggest = "validation_errors"
        elif key == "databaseSchemaMap":
            suggest = "database_schema_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Sequence[str],
                 target_server_brand_version: str,
                 target_server_version: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse'],
                 database_schema_map: Optional[Sequence['outputs.ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponseDatabaseSchemaMap']] = None):
        """
        Output for the task that validates connection to Azure Database for PostgreSQL and target server requirements for Oracle source.
        :param Sequence[str] databases: List of databases on target server
        :param str target_server_brand_version: Target server brand version
        :param str target_server_version: Version of the target server
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors associated with the task
        :param Sequence['ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponseDatabaseSchemaMap'] database_schema_map: Mapping of schemas per database
        """
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases=databases,
            target_server_brand_version=target_server_brand_version,
            target_server_version=target_server_version,
            validation_errors=validation_errors,
            database_schema_map=database_schema_map,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases: Optional[Sequence[str]] = None,
             target_server_brand_version: Optional[str] = None,
             target_server_version: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             database_schema_map: Optional[Sequence['outputs.ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponseDatabaseSchemaMap']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")
        if database_schema_map is None and 'databaseSchemaMap' in kwargs:
            database_schema_map = kwargs['databaseSchemaMap']

        _setter("databases", databases)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_version", target_server_version)
        _setter("validation_errors", validation_errors)
        if database_schema_map is not None:
            _setter("database_schema_map", database_schema_map)

    @property
    @pulumi.getter
    def databases(self) -> Sequence[str]:
        """
        List of databases on target server
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Version of the target server
        """
        return pulumi.get(self, "target_server_version")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors associated with the task
        """
        return pulumi.get(self, "validation_errors")

    @property
    @pulumi.getter(name="databaseSchemaMap")
    def database_schema_map(self) -> Optional[Sequence['outputs.ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponseDatabaseSchemaMap']]:
        """
        Mapping of schemas per database
        """
        return pulumi.get(self, "database_schema_map")


@pulumi.output_type
class ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponseDatabaseSchemaMap(dict):
    def __init__(__self__, *,
                 database: Optional[str] = None,
                 schemas: Optional[Sequence[str]] = None):
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponseDatabaseSchemaMap._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database=database,
            schemas=schemas,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database: Optional[str] = None,
             schemas: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if database is not None:
            _setter("database", database)
        if schemas is not None:
            _setter("schemas", schemas)

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "schemas")


@pulumi.output_type
class ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to Azure Database For PostgreSQL server and target server requirements for online migration for Oracle source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse'] = None):
        """
        Properties for the task that validates connection to Azure Database For PostgreSQL server and target server requirements for online migration for Oracle source.
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToTarget.Oracle.AzureDbForPostgreSql.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse' input: Task input
        """
        ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToTarget.Oracle.AzureDbForPostgreSql.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToTarget.Oracle.AzureDbForPostgreSql.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToTargetSqlDbTaskInputResponse(dict):
    """
    Input for the task that validates connection to SQL DB and target server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "queryObjectCounts":
            suggest = "query_object_counts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlDbTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlDbTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlDbTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_connection_info: 'outputs.SqlConnectionInfoResponse',
                 query_object_counts: Optional[bool] = None):
        """
        Input for the task that validates connection to SQL DB and target server requirements
        :param 'SqlConnectionInfoResponse' target_connection_info: Connection information for target SQL DB
        :param bool query_object_counts: Boolean flag indicating whether to query object counts for each database on the target server
        """
        ConnectToTargetSqlDbTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_connection_info=target_connection_info,
            query_object_counts=query_object_counts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             query_object_counts: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if query_object_counts is None and 'queryObjectCounts' in kwargs:
            query_object_counts = kwargs['queryObjectCounts']

        _setter("target_connection_info", target_connection_info)
        if query_object_counts is not None:
            _setter("query_object_counts", query_object_counts)

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for target SQL DB
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="queryObjectCounts")
    def query_object_counts(self) -> Optional[bool]:
        """
        Boolean flag indicating whether to query object counts for each database on the target server
        """
        return pulumi.get(self, "query_object_counts")


@pulumi.output_type
class ConnectToTargetSqlDbTaskOutputResponse(dict):
    """
    Output for the task that validates connection to SQL DB and target server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerVersion":
            suggest = "target_server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlDbTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlDbTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlDbTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Mapping[str, str],
                 id: str,
                 target_server_brand_version: str,
                 target_server_version: str):
        """
        Output for the task that validates connection to SQL DB and target server requirements
        :param Mapping[str, str] databases: Source databases as a map from database name to database id
        :param str id: Result identifier
        :param str target_server_brand_version: Target server brand version
        :param str target_server_version: Version of the target server
        """
        ConnectToTargetSqlDbTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases=databases,
            id=id,
            target_server_brand_version=target_server_brand_version,
            target_server_version=target_server_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases: Optional[Mapping[str, str]] = None,
             id: Optional[str] = None,
             target_server_brand_version: Optional[str] = None,
             target_server_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")

        _setter("databases", databases)
        _setter("id", id)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_version", target_server_version)

    @property
    @pulumi.getter
    def databases(self) -> Mapping[str, str]:
        """
        Source databases as a map from database name to database id
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Version of the target server
        """
        return pulumi.get(self, "target_server_version")


@pulumi.output_type
class ConnectToTargetSqlDbTaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to SQL DB and target server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"
        elif key == "createdOn":
            suggest = "created_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlDbTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlDbTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlDbTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToTargetSqlDbTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 created_on: Optional[str] = None,
                 input: Optional['outputs.ConnectToTargetSqlDbTaskInputResponse'] = None):
        """
        Properties for the task that validates connection to SQL DB and target server requirements
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToTargetSqlDbTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToTarget.SqlDb'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param str created_on: DateTime in UTC when the task was created
        :param 'ConnectToTargetSqlDbTaskInputResponse' input: Task input
        """
        ConnectToTargetSqlDbTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            created_on=created_on,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToTargetSqlDbTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             created_on: Optional[str] = None,
             input: Optional['outputs.ConnectToTargetSqlDbTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']
        if created_on is None and 'createdOn' in kwargs:
            created_on = kwargs['createdOn']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToTarget.SqlDb')
        if client_data is not None:
            _setter("client_data", client_data)
        if created_on is not None:
            _setter("created_on", created_on)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToTargetSqlDbTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToTarget.SqlDb'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        DateTime in UTC when the task was created
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToTargetSqlDbTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToTargetSqlMISyncTaskInputResponse(dict):
    """
    Input for the task that validates connection to Azure SQL Database Managed Instance online scenario.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureApp":
            suggest = "azure_app"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlMISyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlMISyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlMISyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_app: 'outputs.AzureActiveDirectoryAppResponse',
                 target_connection_info: 'outputs.MiSqlConnectionInfoResponse'):
        """
        Input for the task that validates connection to Azure SQL Database Managed Instance online scenario.
        :param 'AzureActiveDirectoryAppResponse' azure_app: Azure Active Directory Application the DMS (classic) instance will use to connect to the target instance of Azure SQL Database Managed Instance and the Azure Storage Account
        :param 'MiSqlConnectionInfoResponse' target_connection_info: Connection information for Azure SQL Database Managed Instance
        """
        ConnectToTargetSqlMISyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_app=azure_app,
            target_connection_info=target_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_app: Optional['outputs.AzureActiveDirectoryAppResponse'] = None,
             target_connection_info: Optional['outputs.MiSqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_app is None and 'azureApp' in kwargs:
            azure_app = kwargs['azureApp']
        if azure_app is None:
            raise TypeError("Missing 'azure_app' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")

        _setter("azure_app", azure_app)
        _setter("target_connection_info", target_connection_info)

    @property
    @pulumi.getter(name="azureApp")
    def azure_app(self) -> 'outputs.AzureActiveDirectoryAppResponse':
        """
        Azure Active Directory Application the DMS (classic) instance will use to connect to the target instance of Azure SQL Database Managed Instance and the Azure Storage Account
        """
        return pulumi.get(self, "azure_app")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.MiSqlConnectionInfoResponse':
        """
        Connection information for Azure SQL Database Managed Instance
        """
        return pulumi.get(self, "target_connection_info")


@pulumi.output_type
class ConnectToTargetSqlMISyncTaskOutputResponse(dict):
    """
    Output for the task that validates connection to Azure SQL Database Managed Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerVersion":
            suggest = "target_server_version"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlMISyncTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlMISyncTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlMISyncTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_server_brand_version: str,
                 target_server_version: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for the task that validates connection to Azure SQL Database Managed Instance.
        :param str target_server_brand_version: Target server brand version
        :param str target_server_version: Target server version
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors
        """
        ConnectToTargetSqlMISyncTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_server_brand_version=target_server_brand_version,
            target_server_version=target_server_version,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_server_brand_version: Optional[str] = None,
             target_server_version: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_version", target_server_version)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ConnectToTargetSqlMISyncTaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to Azure SQL Database Managed Instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlMISyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlMISyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlMISyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToTargetSqlMISyncTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToTargetSqlMISyncTaskInputResponse'] = None):
        """
        Properties for the task that validates connection to Azure SQL Database Managed Instance
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToTargetSqlMISyncTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToTarget.AzureSqlDbMI.Sync.LRS'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToTargetSqlMISyncTaskInputResponse' input: Task input
        """
        ConnectToTargetSqlMISyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToTargetSqlMISyncTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToTargetSqlMISyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToTarget.AzureSqlDbMI.Sync.LRS')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToTargetSqlMISyncTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToTarget.AzureSqlDbMI.Sync.LRS'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToTargetSqlMISyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToTargetSqlMITaskInputResponse(dict):
    """
    Input for the task that validates connection to Azure SQL Database Managed Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "collectAgentJobs":
            suggest = "collect_agent_jobs"
        elif key == "collectLogins":
            suggest = "collect_logins"
        elif key == "validateSsisCatalogOnly":
            suggest = "validate_ssis_catalog_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlMITaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlMITaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlMITaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_connection_info: 'outputs.SqlConnectionInfoResponse',
                 collect_agent_jobs: Optional[bool] = None,
                 collect_logins: Optional[bool] = None,
                 validate_ssis_catalog_only: Optional[bool] = None):
        """
        Input for the task that validates connection to Azure SQL Database Managed Instance.
        :param 'SqlConnectionInfoResponse' target_connection_info: Connection information for target SQL Server
        :param bool collect_agent_jobs: Flag for whether to collect agent jobs from target SQL MI server.
        :param bool collect_logins: Flag for whether to collect logins from target SQL MI server.
        :param bool validate_ssis_catalog_only: Flag for whether to validate SSIS catalog is reachable on the target SQL MI server.
        """
        ConnectToTargetSqlMITaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_connection_info=target_connection_info,
            collect_agent_jobs=collect_agent_jobs,
            collect_logins=collect_logins,
            validate_ssis_catalog_only=validate_ssis_catalog_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             collect_agent_jobs: Optional[bool] = None,
             collect_logins: Optional[bool] = None,
             validate_ssis_catalog_only: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if collect_agent_jobs is None and 'collectAgentJobs' in kwargs:
            collect_agent_jobs = kwargs['collectAgentJobs']
        if collect_logins is None and 'collectLogins' in kwargs:
            collect_logins = kwargs['collectLogins']
        if validate_ssis_catalog_only is None and 'validateSsisCatalogOnly' in kwargs:
            validate_ssis_catalog_only = kwargs['validateSsisCatalogOnly']

        _setter("target_connection_info", target_connection_info)
        if collect_agent_jobs is None:
            collect_agent_jobs = True
        if collect_agent_jobs is not None:
            _setter("collect_agent_jobs", collect_agent_jobs)
        if collect_logins is None:
            collect_logins = True
        if collect_logins is not None:
            _setter("collect_logins", collect_logins)
        if validate_ssis_catalog_only is None:
            validate_ssis_catalog_only = False
        if validate_ssis_catalog_only is not None:
            _setter("validate_ssis_catalog_only", validate_ssis_catalog_only)

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for target SQL Server
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="collectAgentJobs")
    def collect_agent_jobs(self) -> Optional[bool]:
        """
        Flag for whether to collect agent jobs from target SQL MI server.
        """
        return pulumi.get(self, "collect_agent_jobs")

    @property
    @pulumi.getter(name="collectLogins")
    def collect_logins(self) -> Optional[bool]:
        """
        Flag for whether to collect logins from target SQL MI server.
        """
        return pulumi.get(self, "collect_logins")

    @property
    @pulumi.getter(name="validateSsisCatalogOnly")
    def validate_ssis_catalog_only(self) -> Optional[bool]:
        """
        Flag for whether to validate SSIS catalog is reachable on the target SQL MI server.
        """
        return pulumi.get(self, "validate_ssis_catalog_only")


@pulumi.output_type
class ConnectToTargetSqlMITaskOutputResponse(dict):
    """
    Output for the task that validates connection to Azure SQL Database Managed Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentJobs":
            suggest = "agent_jobs"
        elif key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerVersion":
            suggest = "target_server_version"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlMITaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlMITaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlMITaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_jobs: Sequence[str],
                 id: str,
                 logins: Sequence[str],
                 target_server_brand_version: str,
                 target_server_version: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for the task that validates connection to Azure SQL Database Managed Instance.
        :param Sequence[str] agent_jobs: List of agent jobs on the target server.
        :param str id: Result identifier
        :param Sequence[str] logins: List of logins on the target server.
        :param str target_server_brand_version: Target server brand version
        :param str target_server_version: Target server version
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors
        """
        ConnectToTargetSqlMITaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_jobs=agent_jobs,
            id=id,
            logins=logins,
            target_server_brand_version=target_server_brand_version,
            target_server_version=target_server_version,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_jobs: Optional[Sequence[str]] = None,
             id: Optional[str] = None,
             logins: Optional[Sequence[str]] = None,
             target_server_brand_version: Optional[str] = None,
             target_server_version: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if agent_jobs is None and 'agentJobs' in kwargs:
            agent_jobs = kwargs['agentJobs']
        if agent_jobs is None:
            raise TypeError("Missing 'agent_jobs' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if logins is None:
            raise TypeError("Missing 'logins' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("agent_jobs", agent_jobs)
        _setter("id", id)
        _setter("logins", logins)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_version", target_server_version)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="agentJobs")
    def agent_jobs(self) -> Sequence[str]:
        """
        List of agent jobs on the target server.
        """
        return pulumi.get(self, "agent_jobs")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logins(self) -> Sequence[str]:
        """
        List of logins on the target server.
        """
        return pulumi.get(self, "logins")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ConnectToTargetSqlMITaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to Azure SQL Database Managed Instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlMITaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlMITaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlMITaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToTargetSqlMITaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToTargetSqlMITaskInputResponse'] = None):
        """
        Properties for the task that validates connection to Azure SQL Database Managed Instance
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToTargetSqlMITaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToTarget.AzureSqlDbMI'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToTargetSqlMITaskInputResponse' input: Task input
        """
        ConnectToTargetSqlMITaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToTargetSqlMITaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToTargetSqlMITaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToTarget.AzureSqlDbMI')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToTargetSqlMITaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToTarget.AzureSqlDbMI'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToTargetSqlMITaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ConnectToTargetSqlSqlDbSyncTaskInputResponse(dict):
    """
    Input for the task that validates connection to Azure SQL DB and target server requirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlSqlDbSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlSqlDbSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlSqlDbSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 target_connection_info: 'outputs.SqlConnectionInfoResponse'):
        """
        Input for the task that validates connection to Azure SQL DB and target server requirements
        :param 'SqlConnectionInfoResponse' source_connection_info: Connection information for source SQL Server
        :param 'SqlConnectionInfoResponse' target_connection_info: Connection information for target SQL DB
        """
        ConnectToTargetSqlSqlDbSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")

        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for source SQL Server
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for target SQL DB
        """
        return pulumi.get(self, "target_connection_info")


@pulumi.output_type
class ConnectToTargetSqlSqlDbSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that validates connection to SQL DB and target server requirements for online migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectToTargetSqlSqlDbSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectToTargetSqlSqlDbSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectToTargetSqlSqlDbSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ConnectToTargetSqlDbTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ConnectToTargetSqlSqlDbSyncTaskInputResponse'] = None):
        """
        Properties for the task that validates connection to SQL DB and target server requirements for online migration
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ConnectToTargetSqlDbTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ConnectToTarget.SqlDb.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ConnectToTargetSqlSqlDbSyncTaskInputResponse' input: Task input
        """
        ConnectToTargetSqlSqlDbSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ConnectToTargetSqlDbTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ConnectToTargetSqlSqlDbSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ConnectToTarget.SqlDb.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ConnectToTargetSqlDbTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ConnectToTarget.SqlDb.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ConnectToTargetSqlSqlDbSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class CopyProgressDetailsResponse(dict):
    """
    Details on progress of ADF copy activity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyDuration":
            suggest = "copy_duration"
        elif key == "copyStart":
            suggest = "copy_start"
        elif key == "copyThroughput":
            suggest = "copy_throughput"
        elif key == "dataRead":
            suggest = "data_read"
        elif key == "dataWritten":
            suggest = "data_written"
        elif key == "parallelCopyType":
            suggest = "parallel_copy_type"
        elif key == "rowsCopied":
            suggest = "rows_copied"
        elif key == "rowsRead":
            suggest = "rows_read"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "usedParallelCopies":
            suggest = "used_parallel_copies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CopyProgressDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CopyProgressDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CopyProgressDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_duration: int,
                 copy_start: str,
                 copy_throughput: float,
                 data_read: float,
                 data_written: float,
                 parallel_copy_type: str,
                 rows_copied: float,
                 rows_read: float,
                 status: str,
                 table_name: str,
                 used_parallel_copies: int):
        """
        Details on progress of ADF copy activity
        :param int copy_duration: Copy Duration in seconds
        :param str copy_start: Copy Start
        :param float copy_throughput: Copy throughput in KBps
        :param float data_read: Bytes read
        :param float data_written: Bytes written
        :param str parallel_copy_type: Type of parallel copy (Dynamic range, Physical partition, none).
        :param float rows_copied: Rows Copied
        :param float rows_read: Rows read
        :param str status: Status of the Copy activity (InProgress, Succeeded, Failed, Canceled).
        :param str table_name: Table Name
        :param int used_parallel_copies: The degree of parallelization.
        """
        CopyProgressDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copy_duration=copy_duration,
            copy_start=copy_start,
            copy_throughput=copy_throughput,
            data_read=data_read,
            data_written=data_written,
            parallel_copy_type=parallel_copy_type,
            rows_copied=rows_copied,
            rows_read=rows_read,
            status=status,
            table_name=table_name,
            used_parallel_copies=used_parallel_copies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copy_duration: Optional[int] = None,
             copy_start: Optional[str] = None,
             copy_throughput: Optional[float] = None,
             data_read: Optional[float] = None,
             data_written: Optional[float] = None,
             parallel_copy_type: Optional[str] = None,
             rows_copied: Optional[float] = None,
             rows_read: Optional[float] = None,
             status: Optional[str] = None,
             table_name: Optional[str] = None,
             used_parallel_copies: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if copy_duration is None and 'copyDuration' in kwargs:
            copy_duration = kwargs['copyDuration']
        if copy_duration is None:
            raise TypeError("Missing 'copy_duration' argument")
        if copy_start is None and 'copyStart' in kwargs:
            copy_start = kwargs['copyStart']
        if copy_start is None:
            raise TypeError("Missing 'copy_start' argument")
        if copy_throughput is None and 'copyThroughput' in kwargs:
            copy_throughput = kwargs['copyThroughput']
        if copy_throughput is None:
            raise TypeError("Missing 'copy_throughput' argument")
        if data_read is None and 'dataRead' in kwargs:
            data_read = kwargs['dataRead']
        if data_read is None:
            raise TypeError("Missing 'data_read' argument")
        if data_written is None and 'dataWritten' in kwargs:
            data_written = kwargs['dataWritten']
        if data_written is None:
            raise TypeError("Missing 'data_written' argument")
        if parallel_copy_type is None and 'parallelCopyType' in kwargs:
            parallel_copy_type = kwargs['parallelCopyType']
        if parallel_copy_type is None:
            raise TypeError("Missing 'parallel_copy_type' argument")
        if rows_copied is None and 'rowsCopied' in kwargs:
            rows_copied = kwargs['rowsCopied']
        if rows_copied is None:
            raise TypeError("Missing 'rows_copied' argument")
        if rows_read is None and 'rowsRead' in kwargs:
            rows_read = kwargs['rowsRead']
        if rows_read is None:
            raise TypeError("Missing 'rows_read' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if used_parallel_copies is None and 'usedParallelCopies' in kwargs:
            used_parallel_copies = kwargs['usedParallelCopies']
        if used_parallel_copies is None:
            raise TypeError("Missing 'used_parallel_copies' argument")

        _setter("copy_duration", copy_duration)
        _setter("copy_start", copy_start)
        _setter("copy_throughput", copy_throughput)
        _setter("data_read", data_read)
        _setter("data_written", data_written)
        _setter("parallel_copy_type", parallel_copy_type)
        _setter("rows_copied", rows_copied)
        _setter("rows_read", rows_read)
        _setter("status", status)
        _setter("table_name", table_name)
        _setter("used_parallel_copies", used_parallel_copies)

    @property
    @pulumi.getter(name="copyDuration")
    def copy_duration(self) -> int:
        """
        Copy Duration in seconds
        """
        return pulumi.get(self, "copy_duration")

    @property
    @pulumi.getter(name="copyStart")
    def copy_start(self) -> str:
        """
        Copy Start
        """
        return pulumi.get(self, "copy_start")

    @property
    @pulumi.getter(name="copyThroughput")
    def copy_throughput(self) -> float:
        """
        Copy throughput in KBps
        """
        return pulumi.get(self, "copy_throughput")

    @property
    @pulumi.getter(name="dataRead")
    def data_read(self) -> float:
        """
        Bytes read
        """
        return pulumi.get(self, "data_read")

    @property
    @pulumi.getter(name="dataWritten")
    def data_written(self) -> float:
        """
        Bytes written
        """
        return pulumi.get(self, "data_written")

    @property
    @pulumi.getter(name="parallelCopyType")
    def parallel_copy_type(self) -> str:
        """
        Type of parallel copy (Dynamic range, Physical partition, none).
        """
        return pulumi.get(self, "parallel_copy_type")

    @property
    @pulumi.getter(name="rowsCopied")
    def rows_copied(self) -> float:
        """
        Rows Copied
        """
        return pulumi.get(self, "rows_copied")

    @property
    @pulumi.getter(name="rowsRead")
    def rows_read(self) -> float:
        """
        Rows read
        """
        return pulumi.get(self, "rows_read")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Copy activity (InProgress, Succeeded, Failed, Canceled).
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        Table Name
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="usedParallelCopies")
    def used_parallel_copies(self) -> int:
        """
        The degree of parallelization.
        """
        return pulumi.get(self, "used_parallel_copies")


@pulumi.output_type
class DataIntegrityValidationResultResponse(dict):
    """
    Results for checksum based Data Integrity validation results
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failedObjects":
            suggest = "failed_objects"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataIntegrityValidationResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataIntegrityValidationResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataIntegrityValidationResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failed_objects: Optional[Mapping[str, str]] = None,
                 validation_errors: Optional['outputs.ValidationErrorResponse'] = None):
        """
        Results for checksum based Data Integrity validation results
        :param Mapping[str, str] failed_objects: List of failed table names of source and target pair
        :param 'ValidationErrorResponse' validation_errors: List of errors that happened while performing data integrity validation
        """
        DataIntegrityValidationResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failed_objects=failed_objects,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failed_objects: Optional[Mapping[str, str]] = None,
             validation_errors: Optional['outputs.ValidationErrorResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failed_objects is None and 'failedObjects' in kwargs:
            failed_objects = kwargs['failedObjects']
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']

        if failed_objects is not None:
            _setter("failed_objects", failed_objects)
        if validation_errors is not None:
            _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="failedObjects")
    def failed_objects(self) -> Optional[Mapping[str, str]]:
        """
        List of failed table names of source and target pair
        """
        return pulumi.get(self, "failed_objects")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional['outputs.ValidationErrorResponse']:
        """
        List of errors that happened while performing data integrity validation
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class DataItemMigrationSummaryResultResponse(dict):
    """
    Basic summary of a data item migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "errorPrefix":
            suggest = "error_prefix"
        elif key == "itemsCompletedCount":
            suggest = "items_completed_count"
        elif key == "itemsCount":
            suggest = "items_count"
        elif key == "resultPrefix":
            suggest = "result_prefix"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataItemMigrationSummaryResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataItemMigrationSummaryResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataItemMigrationSummaryResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 error_prefix: str,
                 items_completed_count: float,
                 items_count: float,
                 name: str,
                 result_prefix: str,
                 started_on: str,
                 state: str,
                 status_message: str):
        """
        Basic summary of a data item migration
        :param str ended_on: Migration end time
        :param str error_prefix: Wildcard string prefix to use for querying all errors of the item
        :param float items_completed_count: Number of successfully completed items
        :param float items_count: Number of items
        :param str name: Name of the item
        :param str result_prefix: Wildcard string prefix to use for querying all sub-tem results of the item
        :param str started_on: Migration start time
        :param str state: Current state of migration
        :param str status_message: Status message
        """
        DataItemMigrationSummaryResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            error_prefix=error_prefix,
            items_completed_count=items_completed_count,
            items_count=items_count,
            name=name,
            result_prefix=result_prefix,
            started_on=started_on,
            state=state,
            status_message=status_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             error_prefix: Optional[str] = None,
             items_completed_count: Optional[float] = None,
             items_count: Optional[float] = None,
             name: Optional[str] = None,
             result_prefix: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             status_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if error_prefix is None and 'errorPrefix' in kwargs:
            error_prefix = kwargs['errorPrefix']
        if error_prefix is None:
            raise TypeError("Missing 'error_prefix' argument")
        if items_completed_count is None and 'itemsCompletedCount' in kwargs:
            items_completed_count = kwargs['itemsCompletedCount']
        if items_completed_count is None:
            raise TypeError("Missing 'items_completed_count' argument")
        if items_count is None and 'itemsCount' in kwargs:
            items_count = kwargs['itemsCount']
        if items_count is None:
            raise TypeError("Missing 'items_count' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if result_prefix is None and 'resultPrefix' in kwargs:
            result_prefix = kwargs['resultPrefix']
        if result_prefix is None:
            raise TypeError("Missing 'result_prefix' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status_message is None and 'statusMessage' in kwargs:
            status_message = kwargs['statusMessage']
        if status_message is None:
            raise TypeError("Missing 'status_message' argument")

        _setter("ended_on", ended_on)
        _setter("error_prefix", error_prefix)
        _setter("items_completed_count", items_completed_count)
        _setter("items_count", items_count)
        _setter("name", name)
        _setter("result_prefix", result_prefix)
        _setter("started_on", started_on)
        _setter("state", state)
        _setter("status_message", status_message)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="errorPrefix")
    def error_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all errors of the item
        """
        return pulumi.get(self, "error_prefix")

    @property
    @pulumi.getter(name="itemsCompletedCount")
    def items_completed_count(self) -> float:
        """
        Number of successfully completed items
        """
        return pulumi.get(self, "items_completed_count")

    @property
    @pulumi.getter(name="itemsCount")
    def items_count(self) -> float:
        """
        Number of items
        """
        return pulumi.get(self, "items_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the item
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resultPrefix")
    def result_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all sub-tem results of the item
        """
        return pulumi.get(self, "result_prefix")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        Status message
        """
        return pulumi.get(self, "status_message")


@pulumi.output_type
class DatabaseBackupInfoResponse(dict):
    """
    Information about backup files when existing backup mode is used.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupFiles":
            suggest = "backup_files"
        elif key == "backupFinishDate":
            suggest = "backup_finish_date"
        elif key == "backupType":
            suggest = "backup_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "familyCount":
            suggest = "family_count"
        elif key == "isCompressed":
            suggest = "is_compressed"
        elif key == "isDamaged":
            suggest = "is_damaged"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseBackupInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseBackupInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseBackupInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_files: Sequence[str],
                 backup_finish_date: str,
                 backup_type: str,
                 database_name: str,
                 family_count: int,
                 is_compressed: bool,
                 is_damaged: bool,
                 position: int):
        """
        Information about backup files when existing backup mode is used.
        :param Sequence[str] backup_files: The list of backup files for the current database.
        :param str backup_finish_date: Date and time when the backup operation finished.
        :param str backup_type: Backup Type.
        :param str database_name: Database name.
        :param int family_count: Number of files in the backup set.
        :param bool is_compressed: Whether the backup set is compressed
        :param bool is_damaged: Database was damaged when backed up, but the backup operation was requested to continue despite errors.
        :param int position: Position of current database backup in the file.
        """
        DatabaseBackupInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_files=backup_files,
            backup_finish_date=backup_finish_date,
            backup_type=backup_type,
            database_name=database_name,
            family_count=family_count,
            is_compressed=is_compressed,
            is_damaged=is_damaged,
            position=position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_files: Optional[Sequence[str]] = None,
             backup_finish_date: Optional[str] = None,
             backup_type: Optional[str] = None,
             database_name: Optional[str] = None,
             family_count: Optional[int] = None,
             is_compressed: Optional[bool] = None,
             is_damaged: Optional[bool] = None,
             position: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_files is None and 'backupFiles' in kwargs:
            backup_files = kwargs['backupFiles']
        if backup_files is None:
            raise TypeError("Missing 'backup_files' argument")
        if backup_finish_date is None and 'backupFinishDate' in kwargs:
            backup_finish_date = kwargs['backupFinishDate']
        if backup_finish_date is None:
            raise TypeError("Missing 'backup_finish_date' argument")
        if backup_type is None and 'backupType' in kwargs:
            backup_type = kwargs['backupType']
        if backup_type is None:
            raise TypeError("Missing 'backup_type' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if family_count is None and 'familyCount' in kwargs:
            family_count = kwargs['familyCount']
        if family_count is None:
            raise TypeError("Missing 'family_count' argument")
        if is_compressed is None and 'isCompressed' in kwargs:
            is_compressed = kwargs['isCompressed']
        if is_compressed is None:
            raise TypeError("Missing 'is_compressed' argument")
        if is_damaged is None and 'isDamaged' in kwargs:
            is_damaged = kwargs['isDamaged']
        if is_damaged is None:
            raise TypeError("Missing 'is_damaged' argument")
        if position is None:
            raise TypeError("Missing 'position' argument")

        _setter("backup_files", backup_files)
        _setter("backup_finish_date", backup_finish_date)
        _setter("backup_type", backup_type)
        _setter("database_name", database_name)
        _setter("family_count", family_count)
        _setter("is_compressed", is_compressed)
        _setter("is_damaged", is_damaged)
        _setter("position", position)

    @property
    @pulumi.getter(name="backupFiles")
    def backup_files(self) -> Sequence[str]:
        """
        The list of backup files for the current database.
        """
        return pulumi.get(self, "backup_files")

    @property
    @pulumi.getter(name="backupFinishDate")
    def backup_finish_date(self) -> str:
        """
        Date and time when the backup operation finished.
        """
        return pulumi.get(self, "backup_finish_date")

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> str:
        """
        Backup Type.
        """
        return pulumi.get(self, "backup_type")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="familyCount")
    def family_count(self) -> int:
        """
        Number of files in the backup set.
        """
        return pulumi.get(self, "family_count")

    @property
    @pulumi.getter(name="isCompressed")
    def is_compressed(self) -> bool:
        """
        Whether the backup set is compressed
        """
        return pulumi.get(self, "is_compressed")

    @property
    @pulumi.getter(name="isDamaged")
    def is_damaged(self) -> bool:
        """
        Database was damaged when backed up, but the backup operation was requested to continue despite errors.
        """
        return pulumi.get(self, "is_damaged")

    @property
    @pulumi.getter
    def position(self) -> int:
        """
        Position of current database backup in the file.
        """
        return pulumi.get(self, "position")


@pulumi.output_type
class DatabaseFileInfoResponse(dict):
    """
    Database file specific information
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "fileType":
            suggest = "file_type"
        elif key == "logicalName":
            suggest = "logical_name"
        elif key == "physicalFullName":
            suggest = "physical_full_name"
        elif key == "restoreFullName":
            suggest = "restore_full_name"
        elif key == "sizeMB":
            suggest = "size_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseFileInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseFileInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseFileInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: Optional[str] = None,
                 file_type: Optional[str] = None,
                 id: Optional[str] = None,
                 logical_name: Optional[str] = None,
                 physical_full_name: Optional[str] = None,
                 restore_full_name: Optional[str] = None,
                 size_mb: Optional[float] = None):
        """
        Database file specific information
        :param str database_name: Name of the database
        :param str file_type: Database file type
        :param str id: Unique identifier for database file
        :param str logical_name: Logical name of the file
        :param str physical_full_name: Operating-system full path of the file
        :param str restore_full_name: Suggested full path of the file for restoring
        :param float size_mb: Size of the file in megabytes
        """
        DatabaseFileInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            file_type=file_type,
            id=id,
            logical_name=logical_name,
            physical_full_name=physical_full_name,
            restore_full_name=restore_full_name,
            size_mb=size_mb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             file_type: Optional[str] = None,
             id: Optional[str] = None,
             logical_name: Optional[str] = None,
             physical_full_name: Optional[str] = None,
             restore_full_name: Optional[str] = None,
             size_mb: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if file_type is None and 'fileType' in kwargs:
            file_type = kwargs['fileType']
        if logical_name is None and 'logicalName' in kwargs:
            logical_name = kwargs['logicalName']
        if physical_full_name is None and 'physicalFullName' in kwargs:
            physical_full_name = kwargs['physicalFullName']
        if restore_full_name is None and 'restoreFullName' in kwargs:
            restore_full_name = kwargs['restoreFullName']
        if size_mb is None and 'sizeMB' in kwargs:
            size_mb = kwargs['sizeMB']

        if database_name is not None:
            _setter("database_name", database_name)
        if file_type is not None:
            _setter("file_type", file_type)
        if id is not None:
            _setter("id", id)
        if logical_name is not None:
            _setter("logical_name", logical_name)
        if physical_full_name is not None:
            _setter("physical_full_name", physical_full_name)
        if restore_full_name is not None:
            _setter("restore_full_name", restore_full_name)
        if size_mb is not None:
            _setter("size_mb", size_mb)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[str]:
        """
        Database file type
        """
        return pulumi.get(self, "file_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier for database file
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="logicalName")
    def logical_name(self) -> Optional[str]:
        """
        Logical name of the file
        """
        return pulumi.get(self, "logical_name")

    @property
    @pulumi.getter(name="physicalFullName")
    def physical_full_name(self) -> Optional[str]:
        """
        Operating-system full path of the file
        """
        return pulumi.get(self, "physical_full_name")

    @property
    @pulumi.getter(name="restoreFullName")
    def restore_full_name(self) -> Optional[str]:
        """
        Suggested full path of the file for restoring
        """
        return pulumi.get(self, "restore_full_name")

    @property
    @pulumi.getter(name="sizeMB")
    def size_mb(self) -> Optional[float]:
        """
        Size of the file in megabytes
        """
        return pulumi.get(self, "size_mb")


@pulumi.output_type
class DatabaseInfoResponse(dict):
    """
    Project Database Details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceDatabaseName":
            suggest = "source_database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_database_name: str):
        """
        Project Database Details
        :param str source_database_name: Name of the database
        """
        DatabaseInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_database_name=source_database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_database_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_database_name is None and 'sourceDatabaseName' in kwargs:
            source_database_name = kwargs['sourceDatabaseName']
        if source_database_name is None:
            raise TypeError("Missing 'source_database_name' argument")

        _setter("source_database_name", source_database_name)

    @property
    @pulumi.getter(name="sourceDatabaseName")
    def source_database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "source_database_name")


@pulumi.output_type
class DatabaseMigrationPropertiesSqlDbResponse(dict):
    """
    Database Migration Resource properties for SQL database.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "migrationFailureError":
            suggest = "migration_failure_error"
        elif key == "migrationStatus":
            suggest = "migration_status"
        elif key == "migrationStatusDetails":
            suggest = "migration_status_details"
        elif key == "offlineConfiguration":
            suggest = "offline_configuration"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "sourceServerName":
            suggest = "source_server_name"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "migrationOperationId":
            suggest = "migration_operation_id"
        elif key == "migrationService":
            suggest = "migration_service"
        elif key == "provisioningError":
            suggest = "provisioning_error"
        elif key == "sourceDatabaseName":
            suggest = "source_database_name"
        elif key == "sourceSqlConnection":
            suggest = "source_sql_connection"
        elif key == "tableList":
            suggest = "table_list"
        elif key == "targetDatabaseCollation":
            suggest = "target_database_collation"
        elif key == "targetSqlConnection":
            suggest = "target_sql_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseMigrationPropertiesSqlDbResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseMigrationPropertiesSqlDbResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseMigrationPropertiesSqlDbResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 kind: str,
                 migration_failure_error: 'outputs.ErrorInfoResponse',
                 migration_status: str,
                 migration_status_details: 'outputs.SqlDbMigrationStatusDetailsResponse',
                 offline_configuration: 'outputs.SqlDbOfflineConfigurationResponse',
                 provisioning_state: str,
                 source_server_name: str,
                 started_on: str,
                 migration_operation_id: Optional[str] = None,
                 migration_service: Optional[str] = None,
                 provisioning_error: Optional[str] = None,
                 scope: Optional[str] = None,
                 source_database_name: Optional[str] = None,
                 source_sql_connection: Optional['outputs.SqlConnectionInformationResponse'] = None,
                 table_list: Optional[Sequence[str]] = None,
                 target_database_collation: Optional[str] = None,
                 target_sql_connection: Optional['outputs.SqlConnectionInformationResponse'] = None):
        """
        Database Migration Resource properties for SQL database.
        :param str ended_on: Database migration end time.
        :param str kind: 
               Expected value is 'SqlDb'.
        :param 'ErrorInfoResponse' migration_failure_error: Error details in case of migration failure.
        :param str migration_status: Migration status.
        :param 'SqlDbMigrationStatusDetailsResponse' migration_status_details: Detailed migration status. Not included by default.
        :param 'SqlDbOfflineConfigurationResponse' offline_configuration: Offline configuration.
        :param str provisioning_state: Provisioning State of migration. ProvisioningState as Succeeded implies that validations have been performed and migration has started.
        :param str source_server_name: Name of the source sql server.
        :param str started_on: Database migration start time.
        :param str migration_operation_id: ID tracking current migration operation.
        :param str migration_service: Resource Id of the Migration Service.
        :param str provisioning_error: Error message for migration provisioning failure, if any.
        :param str scope: Resource Id of the target resource (SQL VM or SQL Managed Instance).
        :param str source_database_name: Name of the source database.
        :param 'SqlConnectionInformationResponse' source_sql_connection: Source SQL Server connection details.
        :param Sequence[str] table_list: List of tables to copy.
        :param str target_database_collation: Database collation to be used for the target database.
        :param 'SqlConnectionInformationResponse' target_sql_connection: Target SQL DB connection details.
        """
        DatabaseMigrationPropertiesSqlDbResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            kind=kind,
            migration_failure_error=migration_failure_error,
            migration_status=migration_status,
            migration_status_details=migration_status_details,
            offline_configuration=offline_configuration,
            provisioning_state=provisioning_state,
            source_server_name=source_server_name,
            started_on=started_on,
            migration_operation_id=migration_operation_id,
            migration_service=migration_service,
            provisioning_error=provisioning_error,
            scope=scope,
            source_database_name=source_database_name,
            source_sql_connection=source_sql_connection,
            table_list=table_list,
            target_database_collation=target_database_collation,
            target_sql_connection=target_sql_connection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             kind: Optional[str] = None,
             migration_failure_error: Optional['outputs.ErrorInfoResponse'] = None,
             migration_status: Optional[str] = None,
             migration_status_details: Optional['outputs.SqlDbMigrationStatusDetailsResponse'] = None,
             offline_configuration: Optional['outputs.SqlDbOfflineConfigurationResponse'] = None,
             provisioning_state: Optional[str] = None,
             source_server_name: Optional[str] = None,
             started_on: Optional[str] = None,
             migration_operation_id: Optional[str] = None,
             migration_service: Optional[str] = None,
             provisioning_error: Optional[str] = None,
             scope: Optional[str] = None,
             source_database_name: Optional[str] = None,
             source_sql_connection: Optional['outputs.SqlConnectionInformationResponse'] = None,
             table_list: Optional[Sequence[str]] = None,
             target_database_collation: Optional[str] = None,
             target_sql_connection: Optional['outputs.SqlConnectionInformationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if migration_failure_error is None and 'migrationFailureError' in kwargs:
            migration_failure_error = kwargs['migrationFailureError']
        if migration_failure_error is None:
            raise TypeError("Missing 'migration_failure_error' argument")
        if migration_status is None and 'migrationStatus' in kwargs:
            migration_status = kwargs['migrationStatus']
        if migration_status is None:
            raise TypeError("Missing 'migration_status' argument")
        if migration_status_details is None and 'migrationStatusDetails' in kwargs:
            migration_status_details = kwargs['migrationStatusDetails']
        if migration_status_details is None:
            raise TypeError("Missing 'migration_status_details' argument")
        if offline_configuration is None and 'offlineConfiguration' in kwargs:
            offline_configuration = kwargs['offlineConfiguration']
        if offline_configuration is None:
            raise TypeError("Missing 'offline_configuration' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if source_server_name is None and 'sourceServerName' in kwargs:
            source_server_name = kwargs['sourceServerName']
        if source_server_name is None:
            raise TypeError("Missing 'source_server_name' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if migration_operation_id is None and 'migrationOperationId' in kwargs:
            migration_operation_id = kwargs['migrationOperationId']
        if migration_service is None and 'migrationService' in kwargs:
            migration_service = kwargs['migrationService']
        if provisioning_error is None and 'provisioningError' in kwargs:
            provisioning_error = kwargs['provisioningError']
        if source_database_name is None and 'sourceDatabaseName' in kwargs:
            source_database_name = kwargs['sourceDatabaseName']
        if source_sql_connection is None and 'sourceSqlConnection' in kwargs:
            source_sql_connection = kwargs['sourceSqlConnection']
        if table_list is None and 'tableList' in kwargs:
            table_list = kwargs['tableList']
        if target_database_collation is None and 'targetDatabaseCollation' in kwargs:
            target_database_collation = kwargs['targetDatabaseCollation']
        if target_sql_connection is None and 'targetSqlConnection' in kwargs:
            target_sql_connection = kwargs['targetSqlConnection']

        _setter("ended_on", ended_on)
        _setter("kind", 'SqlDb')
        _setter("migration_failure_error", migration_failure_error)
        _setter("migration_status", migration_status)
        _setter("migration_status_details", migration_status_details)
        _setter("offline_configuration", offline_configuration)
        _setter("provisioning_state", provisioning_state)
        _setter("source_server_name", source_server_name)
        _setter("started_on", started_on)
        if migration_operation_id is not None:
            _setter("migration_operation_id", migration_operation_id)
        if migration_service is not None:
            _setter("migration_service", migration_service)
        if provisioning_error is not None:
            _setter("provisioning_error", provisioning_error)
        if scope is not None:
            _setter("scope", scope)
        if source_database_name is not None:
            _setter("source_database_name", source_database_name)
        if source_sql_connection is not None:
            _setter("source_sql_connection", source_sql_connection)
        if table_list is not None:
            _setter("table_list", table_list)
        if target_database_collation is not None:
            _setter("target_database_collation", target_database_collation)
        if target_sql_connection is not None:
            _setter("target_sql_connection", target_sql_connection)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Database migration end time.
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """

        Expected value is 'SqlDb'.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="migrationFailureError")
    def migration_failure_error(self) -> 'outputs.ErrorInfoResponse':
        """
        Error details in case of migration failure.
        """
        return pulumi.get(self, "migration_failure_error")

    @property
    @pulumi.getter(name="migrationStatus")
    def migration_status(self) -> str:
        """
        Migration status.
        """
        return pulumi.get(self, "migration_status")

    @property
    @pulumi.getter(name="migrationStatusDetails")
    def migration_status_details(self) -> 'outputs.SqlDbMigrationStatusDetailsResponse':
        """
        Detailed migration status. Not included by default.
        """
        return pulumi.get(self, "migration_status_details")

    @property
    @pulumi.getter(name="offlineConfiguration")
    def offline_configuration(self) -> 'outputs.SqlDbOfflineConfigurationResponse':
        """
        Offline configuration.
        """
        return pulumi.get(self, "offline_configuration")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning State of migration. ProvisioningState as Succeeded implies that validations have been performed and migration has started.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="sourceServerName")
    def source_server_name(self) -> str:
        """
        Name of the source sql server.
        """
        return pulumi.get(self, "source_server_name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Database migration start time.
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter(name="migrationOperationId")
    def migration_operation_id(self) -> Optional[str]:
        """
        ID tracking current migration operation.
        """
        return pulumi.get(self, "migration_operation_id")

    @property
    @pulumi.getter(name="migrationService")
    def migration_service(self) -> Optional[str]:
        """
        Resource Id of the Migration Service.
        """
        return pulumi.get(self, "migration_service")

    @property
    @pulumi.getter(name="provisioningError")
    def provisioning_error(self) -> Optional[str]:
        """
        Error message for migration provisioning failure, if any.
        """
        return pulumi.get(self, "provisioning_error")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Resource Id of the target resource (SQL VM or SQL Managed Instance).
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sourceDatabaseName")
    def source_database_name(self) -> Optional[str]:
        """
        Name of the source database.
        """
        return pulumi.get(self, "source_database_name")

    @property
    @pulumi.getter(name="sourceSqlConnection")
    def source_sql_connection(self) -> Optional['outputs.SqlConnectionInformationResponse']:
        """
        Source SQL Server connection details.
        """
        return pulumi.get(self, "source_sql_connection")

    @property
    @pulumi.getter(name="tableList")
    def table_list(self) -> Optional[Sequence[str]]:
        """
        List of tables to copy.
        """
        return pulumi.get(self, "table_list")

    @property
    @pulumi.getter(name="targetDatabaseCollation")
    def target_database_collation(self) -> Optional[str]:
        """
        Database collation to be used for the target database.
        """
        return pulumi.get(self, "target_database_collation")

    @property
    @pulumi.getter(name="targetSqlConnection")
    def target_sql_connection(self) -> Optional['outputs.SqlConnectionInformationResponse']:
        """
        Target SQL DB connection details.
        """
        return pulumi.get(self, "target_sql_connection")


@pulumi.output_type
class DatabaseSummaryResultResponse(dict):
    """
    Summary of database results in the migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "errorPrefix":
            suggest = "error_prefix"
        elif key == "itemsCompletedCount":
            suggest = "items_completed_count"
        elif key == "itemsCount":
            suggest = "items_count"
        elif key == "resultPrefix":
            suggest = "result_prefix"
        elif key == "sizeMB":
            suggest = "size_mb"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSummaryResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSummaryResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSummaryResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 error_prefix: str,
                 items_completed_count: float,
                 items_count: float,
                 name: str,
                 result_prefix: str,
                 size_mb: float,
                 started_on: str,
                 state: str,
                 status_message: str):
        """
        Summary of database results in the migration
        :param str ended_on: Migration end time
        :param str error_prefix: Wildcard string prefix to use for querying all errors of the item
        :param float items_completed_count: Number of successfully completed items
        :param float items_count: Number of items
        :param str name: Name of the item
        :param str result_prefix: Wildcard string prefix to use for querying all sub-tem results of the item
        :param float size_mb: Size of the database in megabytes
        :param str started_on: Migration start time
        :param str state: Current state of migration
        :param str status_message: Status message
        """
        DatabaseSummaryResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            error_prefix=error_prefix,
            items_completed_count=items_completed_count,
            items_count=items_count,
            name=name,
            result_prefix=result_prefix,
            size_mb=size_mb,
            started_on=started_on,
            state=state,
            status_message=status_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             error_prefix: Optional[str] = None,
             items_completed_count: Optional[float] = None,
             items_count: Optional[float] = None,
             name: Optional[str] = None,
             result_prefix: Optional[str] = None,
             size_mb: Optional[float] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             status_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if error_prefix is None and 'errorPrefix' in kwargs:
            error_prefix = kwargs['errorPrefix']
        if error_prefix is None:
            raise TypeError("Missing 'error_prefix' argument")
        if items_completed_count is None and 'itemsCompletedCount' in kwargs:
            items_completed_count = kwargs['itemsCompletedCount']
        if items_completed_count is None:
            raise TypeError("Missing 'items_completed_count' argument")
        if items_count is None and 'itemsCount' in kwargs:
            items_count = kwargs['itemsCount']
        if items_count is None:
            raise TypeError("Missing 'items_count' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if result_prefix is None and 'resultPrefix' in kwargs:
            result_prefix = kwargs['resultPrefix']
        if result_prefix is None:
            raise TypeError("Missing 'result_prefix' argument")
        if size_mb is None and 'sizeMB' in kwargs:
            size_mb = kwargs['sizeMB']
        if size_mb is None:
            raise TypeError("Missing 'size_mb' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status_message is None and 'statusMessage' in kwargs:
            status_message = kwargs['statusMessage']
        if status_message is None:
            raise TypeError("Missing 'status_message' argument")

        _setter("ended_on", ended_on)
        _setter("error_prefix", error_prefix)
        _setter("items_completed_count", items_completed_count)
        _setter("items_count", items_count)
        _setter("name", name)
        _setter("result_prefix", result_prefix)
        _setter("size_mb", size_mb)
        _setter("started_on", started_on)
        _setter("state", state)
        _setter("status_message", status_message)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="errorPrefix")
    def error_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all errors of the item
        """
        return pulumi.get(self, "error_prefix")

    @property
    @pulumi.getter(name="itemsCompletedCount")
    def items_completed_count(self) -> float:
        """
        Number of successfully completed items
        """
        return pulumi.get(self, "items_completed_count")

    @property
    @pulumi.getter(name="itemsCount")
    def items_count(self) -> float:
        """
        Number of items
        """
        return pulumi.get(self, "items_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the item
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resultPrefix")
    def result_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all sub-tem results of the item
        """
        return pulumi.get(self, "result_prefix")

    @property
    @pulumi.getter(name="sizeMB")
    def size_mb(self) -> float:
        """
        Size of the database in megabytes
        """
        return pulumi.get(self, "size_mb")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        Status message
        """
        return pulumi.get(self, "status_message")


@pulumi.output_type
class DatabaseTableResponse(dict):
    """
    Table properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasRows":
            suggest = "has_rows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseTableResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseTableResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseTableResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 has_rows: bool,
                 name: str):
        """
        Table properties
        :param bool has_rows: Indicates whether table is empty or not
        :param str name: Schema-qualified name of the table
        """
        DatabaseTableResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            has_rows=has_rows,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             has_rows: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if has_rows is None and 'hasRows' in kwargs:
            has_rows = kwargs['hasRows']
        if has_rows is None:
            raise TypeError("Missing 'has_rows' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("has_rows", has_rows)
        _setter("name", name)

    @property
    @pulumi.getter(name="hasRows")
    def has_rows(self) -> bool:
        """
        Indicates whether table is empty or not
        """
        return pulumi.get(self, "has_rows")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Schema-qualified name of the table
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ErrorInfoResponse(dict):
    """
    Error details
    """
    def __init__(__self__, *,
                 code: str,
                 message: str):
        """
        Error details
        :param str code: Error code.
        :param str message: Error message.
        """
        ErrorInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            message=message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if code is None:
            raise TypeError("Missing 'code' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")

        _setter("code", code)
        _setter("message", message)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Error message.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ExecutionStatisticsResponse(dict):
    """
    Description about the errors happen while performing migration validation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuTimeMs":
            suggest = "cpu_time_ms"
        elif key == "elapsedTimeMs":
            suggest = "elapsed_time_ms"
        elif key == "executionCount":
            suggest = "execution_count"
        elif key == "hasErrors":
            suggest = "has_errors"
        elif key == "sqlErrors":
            suggest = "sql_errors"
        elif key == "waitStats":
            suggest = "wait_stats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExecutionStatisticsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExecutionStatisticsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExecutionStatisticsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_time_ms: Optional[float] = None,
                 elapsed_time_ms: Optional[float] = None,
                 execution_count: Optional[float] = None,
                 has_errors: Optional[bool] = None,
                 sql_errors: Optional[Sequence[str]] = None,
                 wait_stats: Optional[Mapping[str, 'outputs.WaitStatisticsResponse']] = None):
        """
        Description about the errors happen while performing migration validation
        :param float cpu_time_ms: CPU Time in millisecond(s) for the query execution
        :param float elapsed_time_ms: Time taken in millisecond(s) for executing the query
        :param float execution_count: No. of query executions
        :param bool has_errors: Indicates whether the query resulted in an error
        :param Sequence[str] sql_errors: List of sql Errors
        :param Mapping[str, 'WaitStatisticsResponse'] wait_stats: Dictionary of sql query execution wait types and the respective statistics
        """
        ExecutionStatisticsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_time_ms=cpu_time_ms,
            elapsed_time_ms=elapsed_time_ms,
            execution_count=execution_count,
            has_errors=has_errors,
            sql_errors=sql_errors,
            wait_stats=wait_stats,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_time_ms: Optional[float] = None,
             elapsed_time_ms: Optional[float] = None,
             execution_count: Optional[float] = None,
             has_errors: Optional[bool] = None,
             sql_errors: Optional[Sequence[str]] = None,
             wait_stats: Optional[Mapping[str, 'outputs.WaitStatisticsResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cpu_time_ms is None and 'cpuTimeMs' in kwargs:
            cpu_time_ms = kwargs['cpuTimeMs']
        if elapsed_time_ms is None and 'elapsedTimeMs' in kwargs:
            elapsed_time_ms = kwargs['elapsedTimeMs']
        if execution_count is None and 'executionCount' in kwargs:
            execution_count = kwargs['executionCount']
        if has_errors is None and 'hasErrors' in kwargs:
            has_errors = kwargs['hasErrors']
        if sql_errors is None and 'sqlErrors' in kwargs:
            sql_errors = kwargs['sqlErrors']
        if wait_stats is None and 'waitStats' in kwargs:
            wait_stats = kwargs['waitStats']

        if cpu_time_ms is not None:
            _setter("cpu_time_ms", cpu_time_ms)
        if elapsed_time_ms is not None:
            _setter("elapsed_time_ms", elapsed_time_ms)
        if execution_count is not None:
            _setter("execution_count", execution_count)
        if has_errors is not None:
            _setter("has_errors", has_errors)
        if sql_errors is not None:
            _setter("sql_errors", sql_errors)
        if wait_stats is not None:
            _setter("wait_stats", wait_stats)

    @property
    @pulumi.getter(name="cpuTimeMs")
    def cpu_time_ms(self) -> Optional[float]:
        """
        CPU Time in millisecond(s) for the query execution
        """
        return pulumi.get(self, "cpu_time_ms")

    @property
    @pulumi.getter(name="elapsedTimeMs")
    def elapsed_time_ms(self) -> Optional[float]:
        """
        Time taken in millisecond(s) for executing the query
        """
        return pulumi.get(self, "elapsed_time_ms")

    @property
    @pulumi.getter(name="executionCount")
    def execution_count(self) -> Optional[float]:
        """
        No. of query executions
        """
        return pulumi.get(self, "execution_count")

    @property
    @pulumi.getter(name="hasErrors")
    def has_errors(self) -> Optional[bool]:
        """
        Indicates whether the query resulted in an error
        """
        return pulumi.get(self, "has_errors")

    @property
    @pulumi.getter(name="sqlErrors")
    def sql_errors(self) -> Optional[Sequence[str]]:
        """
        List of sql Errors
        """
        return pulumi.get(self, "sql_errors")

    @property
    @pulumi.getter(name="waitStats")
    def wait_stats(self) -> Optional[Mapping[str, 'outputs.WaitStatisticsResponse']]:
        """
        Dictionary of sql query execution wait types and the respective statistics
        """
        return pulumi.get(self, "wait_stats")


@pulumi.output_type
class FileShareResponse(dict):
    """
    File share information with Path, Username, and Password.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileShareResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileShareResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileShareResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 password: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        File share information with Path, Username, and Password.
        :param str path: The folder path for this share.
        :param str password: Password credential used to connect to the share location.
        :param str user_name: User name credential to connect to the share location
        """
        FileShareResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            password=password,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             password: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        _setter("path", path)
        if password is not None:
            _setter("password", password)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The folder path for this share.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password credential used to connect to the share location.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        User name credential to connect to the share location
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetTdeCertificatesSqlTaskInputResponse(dict):
    """
    Input for the task that gets TDE certificates in Base64 encoded format.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupFileShare":
            suggest = "backup_file_share"
        elif key == "connectionInfo":
            suggest = "connection_info"
        elif key == "selectedCertificates":
            suggest = "selected_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetTdeCertificatesSqlTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetTdeCertificatesSqlTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetTdeCertificatesSqlTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_file_share: 'outputs.FileShareResponse',
                 connection_info: 'outputs.SqlConnectionInfoResponse',
                 selected_certificates: Sequence['outputs.SelectedCertificateInputResponse']):
        """
        Input for the task that gets TDE certificates in Base64 encoded format.
        :param 'FileShareResponse' backup_file_share: Backup file share information for file share to be used for temporarily storing files.
        :param 'SqlConnectionInfoResponse' connection_info: Connection information for SQL Server
        :param Sequence['SelectedCertificateInputResponse'] selected_certificates: List containing certificate names and corresponding password to use for encrypting the exported certificate.
        """
        GetTdeCertificatesSqlTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_file_share=backup_file_share,
            connection_info=connection_info,
            selected_certificates=selected_certificates,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_file_share: Optional['outputs.FileShareResponse'] = None,
             connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             selected_certificates: Optional[Sequence['outputs.SelectedCertificateInputResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_file_share is None and 'backupFileShare' in kwargs:
            backup_file_share = kwargs['backupFileShare']
        if backup_file_share is None:
            raise TypeError("Missing 'backup_file_share' argument")
        if connection_info is None and 'connectionInfo' in kwargs:
            connection_info = kwargs['connectionInfo']
        if connection_info is None:
            raise TypeError("Missing 'connection_info' argument")
        if selected_certificates is None and 'selectedCertificates' in kwargs:
            selected_certificates = kwargs['selectedCertificates']
        if selected_certificates is None:
            raise TypeError("Missing 'selected_certificates' argument")

        _setter("backup_file_share", backup_file_share)
        _setter("connection_info", connection_info)
        _setter("selected_certificates", selected_certificates)

    @property
    @pulumi.getter(name="backupFileShare")
    def backup_file_share(self) -> 'outputs.FileShareResponse':
        """
        Backup file share information for file share to be used for temporarily storing files.
        """
        return pulumi.get(self, "backup_file_share")

    @property
    @pulumi.getter(name="connectionInfo")
    def connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for SQL Server
        """
        return pulumi.get(self, "connection_info")

    @property
    @pulumi.getter(name="selectedCertificates")
    def selected_certificates(self) -> Sequence['outputs.SelectedCertificateInputResponse']:
        """
        List containing certificate names and corresponding password to use for encrypting the exported certificate.
        """
        return pulumi.get(self, "selected_certificates")


@pulumi.output_type
class GetTdeCertificatesSqlTaskOutputResponse(dict):
    """
    Output of the task that gets TDE certificates in Base64 encoded format.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "base64EncodedCertificates":
            suggest = "base64_encoded_certificates"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetTdeCertificatesSqlTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetTdeCertificatesSqlTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetTdeCertificatesSqlTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base64_encoded_certificates: Mapping[str, Sequence[str]],
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output of the task that gets TDE certificates in Base64 encoded format.
        :param Mapping[str, Sequence[str]] base64_encoded_certificates: Mapping from certificate name to base 64 encoded format.
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors
        """
        GetTdeCertificatesSqlTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base64_encoded_certificates=base64_encoded_certificates,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base64_encoded_certificates: Optional[Mapping[str, Sequence[str]]] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if base64_encoded_certificates is None and 'base64EncodedCertificates' in kwargs:
            base64_encoded_certificates = kwargs['base64EncodedCertificates']
        if base64_encoded_certificates is None:
            raise TypeError("Missing 'base64_encoded_certificates' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("base64_encoded_certificates", base64_encoded_certificates)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="base64EncodedCertificates")
    def base64_encoded_certificates(self) -> Mapping[str, Sequence[str]]:
        """
        Mapping from certificate name to base 64 encoded format.
        """
        return pulumi.get(self, "base64_encoded_certificates")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class GetTdeCertificatesSqlTaskPropertiesResponse(dict):
    """
    Properties for the task that gets TDE certificates in Base64 encoded format.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetTdeCertificatesSqlTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetTdeCertificatesSqlTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetTdeCertificatesSqlTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.GetTdeCertificatesSqlTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.GetTdeCertificatesSqlTaskInputResponse'] = None):
        """
        Properties for the task that gets TDE certificates in Base64 encoded format.
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['GetTdeCertificatesSqlTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'GetTDECertificates.Sql'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'GetTdeCertificatesSqlTaskInputResponse' input: Task input
        """
        GetTdeCertificatesSqlTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.GetTdeCertificatesSqlTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.GetTdeCertificatesSqlTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'GetTDECertificates.Sql')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.GetTdeCertificatesSqlTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'GetTDECertificates.Sql'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.GetTdeCertificatesSqlTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class GetUserTablesMySqlTaskInputResponse(dict):
    """
    Input for the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionInfo":
            suggest = "connection_info"
        elif key == "selectedDatabases":
            suggest = "selected_databases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesMySqlTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesMySqlTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesMySqlTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_info: 'outputs.MySqlConnectionInfoResponse',
                 selected_databases: Sequence[str]):
        """
        Input for the task that collects user tables for the given list of databases
        :param 'MySqlConnectionInfoResponse' connection_info: Connection information for SQL Server
        :param Sequence[str] selected_databases: List of database names to collect tables for
        """
        GetUserTablesMySqlTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_info=connection_info,
            selected_databases=selected_databases,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_info: Optional['outputs.MySqlConnectionInfoResponse'] = None,
             selected_databases: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_info is None and 'connectionInfo' in kwargs:
            connection_info = kwargs['connectionInfo']
        if connection_info is None:
            raise TypeError("Missing 'connection_info' argument")
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")

        _setter("connection_info", connection_info)
        _setter("selected_databases", selected_databases)

    @property
    @pulumi.getter(name="connectionInfo")
    def connection_info(self) -> 'outputs.MySqlConnectionInfoResponse':
        """
        Connection information for SQL Server
        """
        return pulumi.get(self, "connection_info")

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence[str]:
        """
        List of database names to collect tables for
        """
        return pulumi.get(self, "selected_databases")


@pulumi.output_type
class GetUserTablesMySqlTaskOutputResponse(dict):
    """
    Output of the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databasesToTables":
            suggest = "databases_to_tables"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesMySqlTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesMySqlTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesMySqlTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases_to_tables: Mapping[str, Sequence['outputs.DatabaseTableResponse']],
                 id: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output of the task that collects user tables for the given list of databases
        :param Mapping[str, Sequence['DatabaseTableResponse']] databases_to_tables: Mapping from database name to list of tables
        :param str id: Result identifier
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors
        """
        GetUserTablesMySqlTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases_to_tables=databases_to_tables,
            id=id,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases_to_tables: Optional[Mapping[str, Sequence['outputs.DatabaseTableResponse']]] = None,
             id: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases_to_tables is None and 'databasesToTables' in kwargs:
            databases_to_tables = kwargs['databasesToTables']
        if databases_to_tables is None:
            raise TypeError("Missing 'databases_to_tables' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("databases_to_tables", databases_to_tables)
        _setter("id", id)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="databasesToTables")
    def databases_to_tables(self) -> Mapping[str, Sequence['outputs.DatabaseTableResponse']]:
        """
        Mapping from database name to list of tables
        """
        return pulumi.get(self, "databases_to_tables")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class GetUserTablesMySqlTaskPropertiesResponse(dict):
    """
    Properties for the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesMySqlTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesMySqlTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesMySqlTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.GetUserTablesMySqlTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.GetUserTablesMySqlTaskInputResponse'] = None):
        """
        Properties for the task that collects user tables for the given list of databases
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['GetUserTablesMySqlTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'GetUserTablesMySql'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'GetUserTablesMySqlTaskInputResponse' input: Task input
        """
        GetUserTablesMySqlTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.GetUserTablesMySqlTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.GetUserTablesMySqlTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'GetUserTablesMySql')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.GetUserTablesMySqlTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'GetUserTablesMySql'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.GetUserTablesMySqlTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class GetUserTablesOracleTaskInputResponse(dict):
    """
    Input for the task that gets the list of tables contained within a provided list of Oracle schemas.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionInfo":
            suggest = "connection_info"
        elif key == "selectedSchemas":
            suggest = "selected_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesOracleTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesOracleTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesOracleTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_info: 'outputs.OracleConnectionInfoResponse',
                 selected_schemas: Sequence[str]):
        """
        Input for the task that gets the list of tables contained within a provided list of Oracle schemas.
        :param 'OracleConnectionInfoResponse' connection_info: Information for connecting to Oracle source
        :param Sequence[str] selected_schemas: List of Oracle schemas for which to collect tables
        """
        GetUserTablesOracleTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_info=connection_info,
            selected_schemas=selected_schemas,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_info: Optional['outputs.OracleConnectionInfoResponse'] = None,
             selected_schemas: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_info is None and 'connectionInfo' in kwargs:
            connection_info = kwargs['connectionInfo']
        if connection_info is None:
            raise TypeError("Missing 'connection_info' argument")
        if selected_schemas is None and 'selectedSchemas' in kwargs:
            selected_schemas = kwargs['selectedSchemas']
        if selected_schemas is None:
            raise TypeError("Missing 'selected_schemas' argument")

        _setter("connection_info", connection_info)
        _setter("selected_schemas", selected_schemas)

    @property
    @pulumi.getter(name="connectionInfo")
    def connection_info(self) -> 'outputs.OracleConnectionInfoResponse':
        """
        Information for connecting to Oracle source
        """
        return pulumi.get(self, "connection_info")

    @property
    @pulumi.getter(name="selectedSchemas")
    def selected_schemas(self) -> Sequence[str]:
        """
        List of Oracle schemas for which to collect tables
        """
        return pulumi.get(self, "selected_schemas")


@pulumi.output_type
class GetUserTablesOracleTaskOutputResponse(dict):
    """
    Output for the task that gets the list of tables contained within a provided list of Oracle schemas.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaName":
            suggest = "schema_name"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesOracleTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesOracleTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesOracleTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_name: str,
                 tables: Sequence['outputs.DatabaseTableResponse'],
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for the task that gets the list of tables contained within a provided list of Oracle schemas.
        :param str schema_name: The schema this result is for
        :param Sequence['DatabaseTableResponse'] tables: List of valid tables found for this schema
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors associated with the task
        """
        GetUserTablesOracleTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schema_name=schema_name,
            tables=tables,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schema_name: Optional[str] = None,
             tables: Optional[Sequence['outputs.DatabaseTableResponse']] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if schema_name is None:
            raise TypeError("Missing 'schema_name' argument")
        if tables is None:
            raise TypeError("Missing 'tables' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("schema_name", schema_name)
        _setter("tables", tables)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        The schema this result is for
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter
    def tables(self) -> Sequence['outputs.DatabaseTableResponse']:
        """
        List of valid tables found for this schema
        """
        return pulumi.get(self, "tables")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors associated with the task
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class GetUserTablesOracleTaskPropertiesResponse(dict):
    """
    Properties for the task that collects user tables for the given list of Oracle schemas
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesOracleTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesOracleTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesOracleTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.GetUserTablesOracleTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.GetUserTablesOracleTaskInputResponse'] = None):
        """
        Properties for the task that collects user tables for the given list of Oracle schemas
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['GetUserTablesOracleTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'GetUserTablesOracle'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'GetUserTablesOracleTaskInputResponse' input: Task input
        """
        GetUserTablesOracleTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.GetUserTablesOracleTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.GetUserTablesOracleTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'GetUserTablesOracle')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.GetUserTablesOracleTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'GetUserTablesOracle'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.GetUserTablesOracleTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class GetUserTablesPostgreSqlTaskInputResponse(dict):
    """
    Input for the task that gets the list of tables for a provided list of PostgreSQL databases.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionInfo":
            suggest = "connection_info"
        elif key == "selectedDatabases":
            suggest = "selected_databases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesPostgreSqlTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesPostgreSqlTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesPostgreSqlTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_info: 'outputs.PostgreSqlConnectionInfoResponse',
                 selected_databases: Sequence[str]):
        """
        Input for the task that gets the list of tables for a provided list of PostgreSQL databases.
        :param 'PostgreSqlConnectionInfoResponse' connection_info: Information for connecting to PostgreSQL source
        :param Sequence[str] selected_databases: List of PostgreSQL databases for which to collect tables
        """
        GetUserTablesPostgreSqlTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_info=connection_info,
            selected_databases=selected_databases,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_info: Optional['outputs.PostgreSqlConnectionInfoResponse'] = None,
             selected_databases: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_info is None and 'connectionInfo' in kwargs:
            connection_info = kwargs['connectionInfo']
        if connection_info is None:
            raise TypeError("Missing 'connection_info' argument")
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")

        _setter("connection_info", connection_info)
        _setter("selected_databases", selected_databases)

    @property
    @pulumi.getter(name="connectionInfo")
    def connection_info(self) -> 'outputs.PostgreSqlConnectionInfoResponse':
        """
        Information for connecting to PostgreSQL source
        """
        return pulumi.get(self, "connection_info")

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence[str]:
        """
        List of PostgreSQL databases for which to collect tables
        """
        return pulumi.get(self, "selected_databases")


@pulumi.output_type
class GetUserTablesPostgreSqlTaskOutputResponse(dict):
    """
    Output for the task that gets the list of tables for a provided list of PostgreSQL databases.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesPostgreSqlTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesPostgreSqlTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesPostgreSqlTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 tables: Sequence['outputs.DatabaseTableResponse'],
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for the task that gets the list of tables for a provided list of PostgreSQL databases.
        :param str database_name: The database this result is for
        :param Sequence['DatabaseTableResponse'] tables: List of valid tables found for this database
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors associated with the task
        """
        GetUserTablesPostgreSqlTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            tables=tables,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             tables: Optional[Sequence['outputs.DatabaseTableResponse']] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if tables is None:
            raise TypeError("Missing 'tables' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("database_name", database_name)
        _setter("tables", tables)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The database this result is for
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def tables(self) -> Sequence['outputs.DatabaseTableResponse']:
        """
        List of valid tables found for this database
        """
        return pulumi.get(self, "tables")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors associated with the task
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class GetUserTablesPostgreSqlTaskPropertiesResponse(dict):
    """
    Properties for the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesPostgreSqlTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesPostgreSqlTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesPostgreSqlTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.GetUserTablesPostgreSqlTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.GetUserTablesPostgreSqlTaskInputResponse'] = None):
        """
        Properties for the task that collects user tables for the given list of databases
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['GetUserTablesPostgreSqlTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'GetUserTablesPostgreSql'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'GetUserTablesPostgreSqlTaskInputResponse' input: Task input
        """
        GetUserTablesPostgreSqlTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.GetUserTablesPostgreSqlTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.GetUserTablesPostgreSqlTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'GetUserTablesPostgreSql')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.GetUserTablesPostgreSqlTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'GetUserTablesPostgreSql'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.GetUserTablesPostgreSqlTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class GetUserTablesSqlSyncTaskInputResponse(dict):
    """
    Input for the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedSourceDatabases":
            suggest = "selected_source_databases"
        elif key == "selectedTargetDatabases":
            suggest = "selected_target_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesSqlSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesSqlSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesSqlSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_source_databases: Sequence[str],
                 selected_target_databases: Sequence[str],
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 target_connection_info: 'outputs.SqlConnectionInfoResponse'):
        """
        Input for the task that collects user tables for the given list of databases
        :param Sequence[str] selected_source_databases: List of source database names to collect tables for
        :param Sequence[str] selected_target_databases: List of target database names to collect tables for
        :param 'SqlConnectionInfoResponse' source_connection_info: Connection information for SQL Server
        :param 'SqlConnectionInfoResponse' target_connection_info: Connection information for SQL DB
        """
        GetUserTablesSqlSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_source_databases=selected_source_databases,
            selected_target_databases=selected_target_databases,
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_source_databases: Optional[Sequence[str]] = None,
             selected_target_databases: Optional[Sequence[str]] = None,
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if selected_source_databases is None and 'selectedSourceDatabases' in kwargs:
            selected_source_databases = kwargs['selectedSourceDatabases']
        if selected_source_databases is None:
            raise TypeError("Missing 'selected_source_databases' argument")
        if selected_target_databases is None and 'selectedTargetDatabases' in kwargs:
            selected_target_databases = kwargs['selectedTargetDatabases']
        if selected_target_databases is None:
            raise TypeError("Missing 'selected_target_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")

        _setter("selected_source_databases", selected_source_databases)
        _setter("selected_target_databases", selected_target_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)

    @property
    @pulumi.getter(name="selectedSourceDatabases")
    def selected_source_databases(self) -> Sequence[str]:
        """
        List of source database names to collect tables for
        """
        return pulumi.get(self, "selected_source_databases")

    @property
    @pulumi.getter(name="selectedTargetDatabases")
    def selected_target_databases(self) -> Sequence[str]:
        """
        List of target database names to collect tables for
        """
        return pulumi.get(self, "selected_target_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for SQL Server
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for SQL DB
        """
        return pulumi.get(self, "target_connection_info")


@pulumi.output_type
class GetUserTablesSqlSyncTaskOutputResponse(dict):
    """
    Output of the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databasesToSourceTables":
            suggest = "databases_to_source_tables"
        elif key == "databasesToTargetTables":
            suggest = "databases_to_target_tables"
        elif key == "tableValidationErrors":
            suggest = "table_validation_errors"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesSqlSyncTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesSqlSyncTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesSqlSyncTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases_to_source_tables: Mapping[str, Sequence['outputs.DatabaseTableResponse']],
                 databases_to_target_tables: Mapping[str, Sequence['outputs.DatabaseTableResponse']],
                 table_validation_errors: Mapping[str, Sequence[str]],
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output of the task that collects user tables for the given list of databases
        :param Mapping[str, Sequence['DatabaseTableResponse']] databases_to_source_tables: Mapping from database name to list of source tables
        :param Mapping[str, Sequence['DatabaseTableResponse']] databases_to_target_tables: Mapping from database name to list of target tables
        :param Mapping[str, Sequence[str]] table_validation_errors: Mapping from database name to list of validation errors
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors
        """
        GetUserTablesSqlSyncTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases_to_source_tables=databases_to_source_tables,
            databases_to_target_tables=databases_to_target_tables,
            table_validation_errors=table_validation_errors,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases_to_source_tables: Optional[Mapping[str, Sequence['outputs.DatabaseTableResponse']]] = None,
             databases_to_target_tables: Optional[Mapping[str, Sequence['outputs.DatabaseTableResponse']]] = None,
             table_validation_errors: Optional[Mapping[str, Sequence[str]]] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases_to_source_tables is None and 'databasesToSourceTables' in kwargs:
            databases_to_source_tables = kwargs['databasesToSourceTables']
        if databases_to_source_tables is None:
            raise TypeError("Missing 'databases_to_source_tables' argument")
        if databases_to_target_tables is None and 'databasesToTargetTables' in kwargs:
            databases_to_target_tables = kwargs['databasesToTargetTables']
        if databases_to_target_tables is None:
            raise TypeError("Missing 'databases_to_target_tables' argument")
        if table_validation_errors is None and 'tableValidationErrors' in kwargs:
            table_validation_errors = kwargs['tableValidationErrors']
        if table_validation_errors is None:
            raise TypeError("Missing 'table_validation_errors' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("databases_to_source_tables", databases_to_source_tables)
        _setter("databases_to_target_tables", databases_to_target_tables)
        _setter("table_validation_errors", table_validation_errors)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="databasesToSourceTables")
    def databases_to_source_tables(self) -> Mapping[str, Sequence['outputs.DatabaseTableResponse']]:
        """
        Mapping from database name to list of source tables
        """
        return pulumi.get(self, "databases_to_source_tables")

    @property
    @pulumi.getter(name="databasesToTargetTables")
    def databases_to_target_tables(self) -> Mapping[str, Sequence['outputs.DatabaseTableResponse']]:
        """
        Mapping from database name to list of target tables
        """
        return pulumi.get(self, "databases_to_target_tables")

    @property
    @pulumi.getter(name="tableValidationErrors")
    def table_validation_errors(self) -> Mapping[str, Sequence[str]]:
        """
        Mapping from database name to list of validation errors
        """
        return pulumi.get(self, "table_validation_errors")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class GetUserTablesSqlSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesSqlSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.GetUserTablesSqlSyncTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.GetUserTablesSqlSyncTaskInputResponse'] = None):
        """
        Properties for the task that collects user tables for the given list of databases
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['GetUserTablesSqlSyncTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'GetUserTables.AzureSqlDb.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'GetUserTablesSqlSyncTaskInputResponse' input: Task input
        """
        GetUserTablesSqlSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.GetUserTablesSqlSyncTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.GetUserTablesSqlSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'GetUserTables.AzureSqlDb.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.GetUserTablesSqlSyncTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'GetUserTables.AzureSqlDb.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.GetUserTablesSqlSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class GetUserTablesSqlTaskInputResponse(dict):
    """
    Input for the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionInfo":
            suggest = "connection_info"
        elif key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "encryptedKeyForSecureFields":
            suggest = "encrypted_key_for_secure_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesSqlTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesSqlTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesSqlTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_info: 'outputs.SqlConnectionInfoResponse',
                 selected_databases: Sequence[str],
                 encrypted_key_for_secure_fields: Optional[str] = None):
        """
        Input for the task that collects user tables for the given list of databases
        :param 'SqlConnectionInfoResponse' connection_info: Connection information for SQL Server
        :param Sequence[str] selected_databases: List of database names to collect tables for
        :param str encrypted_key_for_secure_fields: encrypted key for secure fields
        """
        GetUserTablesSqlTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_info=connection_info,
            selected_databases=selected_databases,
            encrypted_key_for_secure_fields=encrypted_key_for_secure_fields,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             selected_databases: Optional[Sequence[str]] = None,
             encrypted_key_for_secure_fields: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_info is None and 'connectionInfo' in kwargs:
            connection_info = kwargs['connectionInfo']
        if connection_info is None:
            raise TypeError("Missing 'connection_info' argument")
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if encrypted_key_for_secure_fields is None and 'encryptedKeyForSecureFields' in kwargs:
            encrypted_key_for_secure_fields = kwargs['encryptedKeyForSecureFields']

        _setter("connection_info", connection_info)
        _setter("selected_databases", selected_databases)
        if encrypted_key_for_secure_fields is not None:
            _setter("encrypted_key_for_secure_fields", encrypted_key_for_secure_fields)

    @property
    @pulumi.getter(name="connectionInfo")
    def connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for SQL Server
        """
        return pulumi.get(self, "connection_info")

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence[str]:
        """
        List of database names to collect tables for
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="encryptedKeyForSecureFields")
    def encrypted_key_for_secure_fields(self) -> Optional[str]:
        """
        encrypted key for secure fields
        """
        return pulumi.get(self, "encrypted_key_for_secure_fields")


@pulumi.output_type
class GetUserTablesSqlTaskOutputResponse(dict):
    """
    Output of the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databasesToTables":
            suggest = "databases_to_tables"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesSqlTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesSqlTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesSqlTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases_to_tables: Mapping[str, Sequence['outputs.DatabaseTableResponse']],
                 id: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output of the task that collects user tables for the given list of databases
        :param Mapping[str, Sequence['DatabaseTableResponse']] databases_to_tables: Mapping from database name to list of tables
        :param str id: Result identifier
        :param Sequence['ReportableExceptionResponse'] validation_errors: Validation errors
        """
        GetUserTablesSqlTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases_to_tables=databases_to_tables,
            id=id,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases_to_tables: Optional[Mapping[str, Sequence['outputs.DatabaseTableResponse']]] = None,
             id: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases_to_tables is None and 'databasesToTables' in kwargs:
            databases_to_tables = kwargs['databasesToTables']
        if databases_to_tables is None:
            raise TypeError("Missing 'databases_to_tables' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("databases_to_tables", databases_to_tables)
        _setter("id", id)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="databasesToTables")
    def databases_to_tables(self) -> Mapping[str, Sequence['outputs.DatabaseTableResponse']]:
        """
        Mapping from database name to list of tables
        """
        return pulumi.get(self, "databases_to_tables")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Validation errors
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class GetUserTablesSqlTaskPropertiesResponse(dict):
    """
    Properties for the task that collects user tables for the given list of databases
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"
        elif key == "taskId":
            suggest = "task_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GetUserTablesSqlTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GetUserTablesSqlTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GetUserTablesSqlTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.GetUserTablesSqlTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.GetUserTablesSqlTaskInputResponse'] = None,
                 task_id: Optional[str] = None):
        """
        Properties for the task that collects user tables for the given list of databases
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['GetUserTablesSqlTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'GetUserTables.Sql'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'GetUserTablesSqlTaskInputResponse' input: Task input
        :param str task_id: Task id 
        """
        GetUserTablesSqlTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
            task_id=task_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.GetUserTablesSqlTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.GetUserTablesSqlTaskInputResponse'] = None,
             task_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']
        if task_id is None and 'taskId' in kwargs:
            task_id = kwargs['taskId']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'GetUserTables.Sql')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)
        if task_id is not None:
            _setter("task_id", task_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.GetUserTablesSqlTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'GetUserTables.Sql'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.GetUserTablesSqlTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[str]:
        """
        Task id 
        """
        return pulumi.get(self, "task_id")


@pulumi.output_type
class MiSqlConnectionInfoResponse(dict):
    """
    Properties required to create a connection to Azure SQL database Managed instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedInstanceResourceId":
            suggest = "managed_instance_resource_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MiSqlConnectionInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MiSqlConnectionInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MiSqlConnectionInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_instance_resource_id: str,
                 type: str,
                 password: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        Properties required to create a connection to Azure SQL database Managed instance
        :param str managed_instance_resource_id: Resource id for Azure SQL database Managed instance
        :param str type: Type of connection info
               Expected value is 'MiSqlConnectionInfo'.
        :param str password: Password credential.
        :param str user_name: User name
        """
        MiSqlConnectionInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            managed_instance_resource_id=managed_instance_resource_id,
            type=type,
            password=password,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             managed_instance_resource_id: Optional[str] = None,
             type: Optional[str] = None,
             password: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if managed_instance_resource_id is None and 'managedInstanceResourceId' in kwargs:
            managed_instance_resource_id = kwargs['managedInstanceResourceId']
        if managed_instance_resource_id is None:
            raise TypeError("Missing 'managed_instance_resource_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        _setter("managed_instance_resource_id", managed_instance_resource_id)
        _setter("type", 'MiSqlConnectionInfo')
        if password is not None:
            _setter("password", password)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="managedInstanceResourceId")
    def managed_instance_resource_id(self) -> str:
        """
        Resource id for Azure SQL database Managed instance
        """
        return pulumi.get(self, "managed_instance_resource_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of connection info
        Expected value is 'MiSqlConnectionInfo'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password credential.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class MigrateMISyncCompleteCommandInputResponse(dict):
    """
    Input for command that completes online migration for an Azure SQL Database Managed Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceDatabaseName":
            suggest = "source_database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMISyncCompleteCommandInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMISyncCompleteCommandInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMISyncCompleteCommandInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_database_name: str):
        """
        Input for command that completes online migration for an Azure SQL Database Managed Instance.
        :param str source_database_name: Name of managed instance database
        """
        MigrateMISyncCompleteCommandInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_database_name=source_database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_database_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_database_name is None and 'sourceDatabaseName' in kwargs:
            source_database_name = kwargs['sourceDatabaseName']
        if source_database_name is None:
            raise TypeError("Missing 'source_database_name' argument")

        _setter("source_database_name", source_database_name)

    @property
    @pulumi.getter(name="sourceDatabaseName")
    def source_database_name(self) -> str:
        """
        Name of managed instance database
        """
        return pulumi.get(self, "source_database_name")


@pulumi.output_type
class MigrateMISyncCompleteCommandOutputResponse(dict):
    """
    Output for command that completes online migration for an Azure SQL Database Managed Instance.
    """
    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None):
        """
        Output for command that completes online migration for an Azure SQL Database Managed Instance.
        :param Sequence['ReportableExceptionResponse'] errors: List of errors that happened during the command execution
        """
        MigrateMISyncCompleteCommandOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            errors=errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if errors is not None:
            _setter("errors", errors)

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ReportableExceptionResponse']]:
        """
        List of errors that happened during the command execution
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class MigrateMISyncCompleteCommandPropertiesResponse(dict):
    """
    Properties for the command that completes online migration for an Azure SQL Database Managed Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandType":
            suggest = "command_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMISyncCompleteCommandPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMISyncCompleteCommandPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMISyncCompleteCommandPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_type: str,
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: 'outputs.MigrateMISyncCompleteCommandOutputResponse',
                 state: str,
                 input: Optional['outputs.MigrateMISyncCompleteCommandInputResponse'] = None):
        """
        Properties for the command that completes online migration for an Azure SQL Database Managed Instance.
        :param str command_type: Command type.
               Expected value is 'Migrate.SqlServer.AzureDbSqlMi.Complete'.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param 'MigrateMISyncCompleteCommandOutputResponse' output: Command output. This is ignored if submitted.
        :param str state: The state of the command. This is ignored if submitted.
        :param 'MigrateMISyncCompleteCommandInputResponse' input: Command input
        """
        MigrateMISyncCompleteCommandPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command_type=command_type,
            errors=errors,
            output=output,
            state=state,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command_type: Optional[str] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional['outputs.MigrateMISyncCompleteCommandOutputResponse'] = None,
             state: Optional[str] = None,
             input: Optional['outputs.MigrateMISyncCompleteCommandInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if command_type is None and 'commandType' in kwargs:
            command_type = kwargs['commandType']
        if command_type is None:
            raise TypeError("Missing 'command_type' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("command_type", 'Migrate.SqlServer.AzureDbSqlMi.Complete')
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter(name="commandType")
    def command_type(self) -> str:
        """
        Command type.
        Expected value is 'Migrate.SqlServer.AzureDbSqlMi.Complete'.
        """
        return pulumi.get(self, "command_type")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> 'outputs.MigrateMISyncCompleteCommandOutputResponse':
        """
        Command output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the command. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateMISyncCompleteCommandInputResponse']:
        """
        Command input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class MigrateMongoDbTaskPropertiesResponse(dict):
    """
    Properties for the task that migrates data between MongoDB data sources
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMongoDbTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMongoDbTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMongoDbTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.MongoDbMigrationSettingsResponse'] = None):
        """
        Properties for the task that migrates data between MongoDB data sources
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.MongoDb'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'MongoDbMigrationSettingsResponse' input: Describes how a MongoDB data migration should be performed
        """
        MigrateMongoDbTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.MongoDbMigrationSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.MongoDb')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.MongoDb'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MongoDbMigrationSettingsResponse']:
        """
        Describes how a MongoDB data migration should be performed
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse(dict):
    """
    Database specific information for offline MySQL to Azure Database for MySQL migration task inputs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableMap":
            suggest = "table_map"
        elif key == "targetDatabaseName":
            suggest = "target_database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 table_map: Optional[Mapping[str, str]] = None,
                 target_database_name: Optional[str] = None):
        """
        Database specific information for offline MySQL to Azure Database for MySQL migration task inputs
        :param str name: Name of the database
        :param Mapping[str, str] table_map: Mapping of source to target tables
        :param str target_database_name: Name of target database. Note: Target database will be truncated before starting migration.
        """
        MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            table_map=table_map,
            target_database_name=target_database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             table_map: Optional[Mapping[str, str]] = None,
             target_database_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if table_map is None and 'tableMap' in kwargs:
            table_map = kwargs['tableMap']
        if target_database_name is None and 'targetDatabaseName' in kwargs:
            target_database_name = kwargs['targetDatabaseName']

        if name is not None:
            _setter("name", name)
        if table_map is not None:
            _setter("table_map", table_map)
        if target_database_name is not None:
            _setter("target_database_name", target_database_name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tableMap")
    def table_map(self) -> Optional[Mapping[str, str]]:
        """
        Mapping of source to target tables
        """
        return pulumi.get(self, "table_map")

    @property
    @pulumi.getter(name="targetDatabaseName")
    def target_database_name(self) -> Optional[str]:
        """
        Name of target database. Note: Target database will be truncated before starting migration.
        """
        return pulumi.get(self, "target_database_name")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse(dict):
    """
    Input for the task that migrates MySQL databases to Azure Database for MySQL for offline migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "encryptedKeyForSecureFields":
            suggest = "encrypted_key_for_secure_fields"
        elif key == "makeSourceServerReadOnly":
            suggest = "make_source_server_read_only"
        elif key == "optionalAgentSettings":
            suggest = "optional_agent_settings"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_databases: Sequence['outputs.MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse'],
                 source_connection_info: 'outputs.MySqlConnectionInfoResponse',
                 target_connection_info: 'outputs.MySqlConnectionInfoResponse',
                 encrypted_key_for_secure_fields: Optional[str] = None,
                 make_source_server_read_only: Optional[bool] = None,
                 optional_agent_settings: Optional[Mapping[str, str]] = None,
                 started_on: Optional[str] = None):
        """
        Input for the task that migrates MySQL databases to Azure Database for MySQL for offline migrations
        :param Sequence['MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'MySqlConnectionInfoResponse' source_connection_info: Connection information for source MySQL
        :param 'MySqlConnectionInfoResponse' target_connection_info: Connection information for target Azure Database for MySQL
        :param str encrypted_key_for_secure_fields: encrypted key for secure fields
        :param bool make_source_server_read_only: Setting to set the source server read only
        :param Mapping[str, str] optional_agent_settings: Optional parameters for fine tuning the data transfer rate during migration
        :param str started_on: Parameter to specify when the migration started
        """
        MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
            encrypted_key_for_secure_fields=encrypted_key_for_secure_fields,
            make_source_server_read_only=make_source_server_read_only,
            optional_agent_settings=optional_agent_settings,
            started_on=started_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_databases: Optional[Sequence['outputs.MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.MySqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.MySqlConnectionInfoResponse'] = None,
             encrypted_key_for_secure_fields: Optional[str] = None,
             make_source_server_read_only: Optional[bool] = None,
             optional_agent_settings: Optional[Mapping[str, str]] = None,
             started_on: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if encrypted_key_for_secure_fields is None and 'encryptedKeyForSecureFields' in kwargs:
            encrypted_key_for_secure_fields = kwargs['encryptedKeyForSecureFields']
        if make_source_server_read_only is None and 'makeSourceServerReadOnly' in kwargs:
            make_source_server_read_only = kwargs['makeSourceServerReadOnly']
        if optional_agent_settings is None and 'optionalAgentSettings' in kwargs:
            optional_agent_settings = kwargs['optionalAgentSettings']
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']

        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)
        if encrypted_key_for_secure_fields is not None:
            _setter("encrypted_key_for_secure_fields", encrypted_key_for_secure_fields)
        if make_source_server_read_only is None:
            make_source_server_read_only = False
        if make_source_server_read_only is not None:
            _setter("make_source_server_read_only", make_source_server_read_only)
        if optional_agent_settings is not None:
            _setter("optional_agent_settings", optional_agent_settings)
        if started_on is not None:
            _setter("started_on", started_on)

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateMySqlAzureDbForMySqlOfflineDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.MySqlConnectionInfoResponse':
        """
        Connection information for source MySQL
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.MySqlConnectionInfoResponse':
        """
        Connection information for target Azure Database for MySQL
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="encryptedKeyForSecureFields")
    def encrypted_key_for_secure_fields(self) -> Optional[str]:
        """
        encrypted key for secure fields
        """
        return pulumi.get(self, "encrypted_key_for_secure_fields")

    @property
    @pulumi.getter(name="makeSourceServerReadOnly")
    def make_source_server_read_only(self) -> Optional[bool]:
        """
        Setting to set the source server read only
        """
        return pulumi.get(self, "make_source_server_read_only")

    @property
    @pulumi.getter(name="optionalAgentSettings")
    def optional_agent_settings(self) -> Optional[Mapping[str, str]]:
        """
        Optional parameters for fine tuning the data transfer rate during migration
        """
        return pulumi.get(self, "optional_agent_settings")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[str]:
        """
        Parameter to specify when the migration started
        """
        return pulumi.get(self, "started_on")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlOfflineTaskOutputDatabaseLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "errorCount":
            suggest = "error_count"
        elif key == "errorPrefix":
            suggest = "error_prefix"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "lastStorageUpdate":
            suggest = "last_storage_update"
        elif key == "numberOfObjects":
            suggest = "number_of_objects"
        elif key == "numberOfObjectsCompleted":
            suggest = "number_of_objects_completed"
        elif key == "objectSummary":
            suggest = "object_summary"
        elif key == "resultPrefix":
            suggest = "result_prefix"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlOfflineTaskOutputDatabaseLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 ended_on: str,
                 error_count: float,
                 error_prefix: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 last_storage_update: str,
                 message: str,
                 number_of_objects: float,
                 number_of_objects_completed: float,
                 object_summary: Mapping[str, 'outputs.DataItemMigrationSummaryResultResponse'],
                 result_prefix: str,
                 result_type: str,
                 stage: str,
                 started_on: str,
                 state: str,
                 status_message: str):
        """
        :param str database_name: Name of the database
        :param str ended_on: Migration end time
        :param float error_count: Number of database/object errors.
        :param str error_prefix: Wildcard string prefix to use for querying all errors of the item
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings.
        :param str id: Result identifier
        :param str last_storage_update: Last time the storage was updated
        :param str message: Migration progress message
        :param float number_of_objects: Number of objects
        :param float number_of_objects_completed: Number of successfully completed objects
        :param Mapping[str, 'DataItemMigrationSummaryResultResponse'] object_summary: Summary of object results in the migration
        :param str result_prefix: Wildcard string prefix to use for querying all sub-tem results of the item
        :param str result_type: Result type
               Expected value is 'DatabaseLevelOutput'.
        :param str stage: Migration stage that this database is in
        :param str started_on: Migration start time
        :param str state: Current state of migration
        :param str status_message: Status message
        """
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputDatabaseLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            ended_on=ended_on,
            error_count=error_count,
            error_prefix=error_prefix,
            exceptions_and_warnings=exceptions_and_warnings,
            id=id,
            last_storage_update=last_storage_update,
            message=message,
            number_of_objects=number_of_objects,
            number_of_objects_completed=number_of_objects_completed,
            object_summary=object_summary,
            result_prefix=result_prefix,
            result_type=result_type,
            stage=stage,
            started_on=started_on,
            state=state,
            status_message=status_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             ended_on: Optional[str] = None,
             error_count: Optional[float] = None,
             error_prefix: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             last_storage_update: Optional[str] = None,
             message: Optional[str] = None,
             number_of_objects: Optional[float] = None,
             number_of_objects_completed: Optional[float] = None,
             object_summary: Optional[Mapping[str, 'outputs.DataItemMigrationSummaryResultResponse']] = None,
             result_prefix: Optional[str] = None,
             result_type: Optional[str] = None,
             stage: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             status_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if error_count is None and 'errorCount' in kwargs:
            error_count = kwargs['errorCount']
        if error_count is None:
            raise TypeError("Missing 'error_count' argument")
        if error_prefix is None and 'errorPrefix' in kwargs:
            error_prefix = kwargs['errorPrefix']
        if error_prefix is None:
            raise TypeError("Missing 'error_prefix' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if last_storage_update is None and 'lastStorageUpdate' in kwargs:
            last_storage_update = kwargs['lastStorageUpdate']
        if last_storage_update is None:
            raise TypeError("Missing 'last_storage_update' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if number_of_objects is None and 'numberOfObjects' in kwargs:
            number_of_objects = kwargs['numberOfObjects']
        if number_of_objects is None:
            raise TypeError("Missing 'number_of_objects' argument")
        if number_of_objects_completed is None and 'numberOfObjectsCompleted' in kwargs:
            number_of_objects_completed = kwargs['numberOfObjectsCompleted']
        if number_of_objects_completed is None:
            raise TypeError("Missing 'number_of_objects_completed' argument")
        if object_summary is None and 'objectSummary' in kwargs:
            object_summary = kwargs['objectSummary']
        if object_summary is None:
            raise TypeError("Missing 'object_summary' argument")
        if result_prefix is None and 'resultPrefix' in kwargs:
            result_prefix = kwargs['resultPrefix']
        if result_prefix is None:
            raise TypeError("Missing 'result_prefix' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if stage is None:
            raise TypeError("Missing 'stage' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status_message is None and 'statusMessage' in kwargs:
            status_message = kwargs['statusMessage']
        if status_message is None:
            raise TypeError("Missing 'status_message' argument")

        _setter("database_name", database_name)
        _setter("ended_on", ended_on)
        _setter("error_count", error_count)
        _setter("error_prefix", error_prefix)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("id", id)
        _setter("last_storage_update", last_storage_update)
        _setter("message", message)
        _setter("number_of_objects", number_of_objects)
        _setter("number_of_objects_completed", number_of_objects_completed)
        _setter("object_summary", object_summary)
        _setter("result_prefix", result_prefix)
        _setter("result_type", 'DatabaseLevelOutput')
        _setter("stage", stage)
        _setter("started_on", started_on)
        _setter("state", state)
        _setter("status_message", status_message)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="errorCount")
    def error_count(self) -> float:
        """
        Number of database/object errors.
        """
        return pulumi.get(self, "error_count")

    @property
    @pulumi.getter(name="errorPrefix")
    def error_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all errors of the item
        """
        return pulumi.get(self, "error_prefix")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings.
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastStorageUpdate")
    def last_storage_update(self) -> str:
        """
        Last time the storage was updated
        """
        return pulumi.get(self, "last_storage_update")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="numberOfObjects")
    def number_of_objects(self) -> float:
        """
        Number of objects
        """
        return pulumi.get(self, "number_of_objects")

    @property
    @pulumi.getter(name="numberOfObjectsCompleted")
    def number_of_objects_completed(self) -> float:
        """
        Number of successfully completed objects
        """
        return pulumi.get(self, "number_of_objects_completed")

    @property
    @pulumi.getter(name="objectSummary")
    def object_summary(self) -> Mapping[str, 'outputs.DataItemMigrationSummaryResultResponse']:
        """
        Summary of object results in the migration
        """
        return pulumi.get(self, "object_summary")

    @property
    @pulumi.getter(name="resultPrefix")
    def result_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all sub-tem results of the item
        """
        return pulumi.get(self, "result_prefix")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def stage(self) -> str:
        """
        Migration stage that this database is in
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        Status message
        """
        return pulumi.get(self, "status_message")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlOfflineTaskOutputErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlOfflineTaskOutputErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.ReportableExceptionResponse',
                 id: str,
                 result_type: str):
        """
        :param 'ReportableExceptionResponse' error: Migration error
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'ErrorOutput'.
        """
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            id=id,
            result_type=result_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional['outputs.ReportableExceptionResponse'] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error is None:
            raise TypeError("Missing 'error' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")

        _setter("error", error)
        _setter("id", id)
        _setter("result_type", 'ErrorOutput')

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ReportableExceptionResponse':
        """
        Migration error
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'ErrorOutput'.
        """
        return pulumi.get(self, "result_type")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlOfflineTaskOutputMigrationLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseSummary":
            suggest = "database_summary"
        elif key == "durationInSeconds":
            suggest = "duration_in_seconds"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "lastStorageUpdate":
            suggest = "last_storage_update"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceServerBrandVersion":
            suggest = "source_server_brand_version"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "statusMessage":
            suggest = "status_message"
        elif key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerVersion":
            suggest = "target_server_version"
        elif key == "migrationReportResult":
            suggest = "migration_report_result"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlOfflineTaskOutputMigrationLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_summary: Mapping[str, 'outputs.DatabaseSummaryResultResponse'],
                 duration_in_seconds: float,
                 ended_on: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 last_storage_update: str,
                 message: str,
                 result_type: str,
                 source_server_brand_version: str,
                 source_server_version: str,
                 started_on: str,
                 status: str,
                 status_message: str,
                 target_server_brand_version: str,
                 target_server_version: str,
                 databases: Optional[Mapping[str, str]] = None,
                 migration_report_result: Optional['outputs.MigrationReportResultResponse'] = None):
        """
        :param Mapping[str, 'DatabaseSummaryResultResponse'] database_summary: Summary of database results in the migration
        :param float duration_in_seconds: Duration of task execution in seconds.
        :param str ended_on: Migration end time
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings.
        :param str id: Result identifier
        :param str last_storage_update: Last time the storage was updated
        :param str message: Migration progress message
        :param str result_type: Result type
               Expected value is 'MigrationLevelOutput'.
        :param str source_server_brand_version: Source server brand version
        :param str source_server_version: Source server version
        :param str started_on: Migration start time
        :param str status: Current status of migration
        :param str status_message: Migration status message
        :param str target_server_brand_version: Target server brand version
        :param str target_server_version: Target server version
        :param Mapping[str, str] databases: Selected databases as a map from database name to database id
        :param 'MigrationReportResultResponse' migration_report_result: Migration Report Result, provides unique url for downloading your migration report.
        """
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputMigrationLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_summary=database_summary,
            duration_in_seconds=duration_in_seconds,
            ended_on=ended_on,
            exceptions_and_warnings=exceptions_and_warnings,
            id=id,
            last_storage_update=last_storage_update,
            message=message,
            result_type=result_type,
            source_server_brand_version=source_server_brand_version,
            source_server_version=source_server_version,
            started_on=started_on,
            status=status,
            status_message=status_message,
            target_server_brand_version=target_server_brand_version,
            target_server_version=target_server_version,
            databases=databases,
            migration_report_result=migration_report_result,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_summary: Optional[Mapping[str, 'outputs.DatabaseSummaryResultResponse']] = None,
             duration_in_seconds: Optional[float] = None,
             ended_on: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             last_storage_update: Optional[str] = None,
             message: Optional[str] = None,
             result_type: Optional[str] = None,
             source_server_brand_version: Optional[str] = None,
             source_server_version: Optional[str] = None,
             started_on: Optional[str] = None,
             status: Optional[str] = None,
             status_message: Optional[str] = None,
             target_server_brand_version: Optional[str] = None,
             target_server_version: Optional[str] = None,
             databases: Optional[Mapping[str, str]] = None,
             migration_report_result: Optional['outputs.MigrationReportResultResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_summary is None and 'databaseSummary' in kwargs:
            database_summary = kwargs['databaseSummary']
        if database_summary is None:
            raise TypeError("Missing 'database_summary' argument")
        if duration_in_seconds is None and 'durationInSeconds' in kwargs:
            duration_in_seconds = kwargs['durationInSeconds']
        if duration_in_seconds is None:
            raise TypeError("Missing 'duration_in_seconds' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if last_storage_update is None and 'lastStorageUpdate' in kwargs:
            last_storage_update = kwargs['lastStorageUpdate']
        if last_storage_update is None:
            raise TypeError("Missing 'last_storage_update' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_server_brand_version is None and 'sourceServerBrandVersion' in kwargs:
            source_server_brand_version = kwargs['sourceServerBrandVersion']
        if source_server_brand_version is None:
            raise TypeError("Missing 'source_server_brand_version' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if status_message is None and 'statusMessage' in kwargs:
            status_message = kwargs['statusMessage']
        if status_message is None:
            raise TypeError("Missing 'status_message' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")
        if migration_report_result is None and 'migrationReportResult' in kwargs:
            migration_report_result = kwargs['migrationReportResult']

        _setter("database_summary", database_summary)
        _setter("duration_in_seconds", duration_in_seconds)
        _setter("ended_on", ended_on)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("id", id)
        _setter("last_storage_update", last_storage_update)
        _setter("message", message)
        _setter("result_type", 'MigrationLevelOutput')
        _setter("source_server_brand_version", source_server_brand_version)
        _setter("source_server_version", source_server_version)
        _setter("started_on", started_on)
        _setter("status", status)
        _setter("status_message", status_message)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_version", target_server_version)
        if databases is not None:
            _setter("databases", databases)
        if migration_report_result is not None:
            _setter("migration_report_result", migration_report_result)

    @property
    @pulumi.getter(name="databaseSummary")
    def database_summary(self) -> Mapping[str, 'outputs.DatabaseSummaryResultResponse']:
        """
        Summary of database results in the migration
        """
        return pulumi.get(self, "database_summary")

    @property
    @pulumi.getter(name="durationInSeconds")
    def duration_in_seconds(self) -> float:
        """
        Duration of task execution in seconds.
        """
        return pulumi.get(self, "duration_in_seconds")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings.
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastStorageUpdate")
    def last_storage_update(self) -> str:
        """
        Last time the storage was updated
        """
        return pulumi.get(self, "last_storage_update")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceServerBrandVersion")
    def source_server_brand_version(self) -> str:
        """
        Source server brand version
        """
        return pulumi.get(self, "source_server_brand_version")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of migration
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        Migration status message
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")

    @property
    @pulumi.getter
    def databases(self) -> Optional[Mapping[str, str]]:
        """
        Selected databases as a map from database name to database id
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="migrationReportResult")
    def migration_report_result(self) -> Optional['outputs.MigrationReportResultResponse']:
        """
        Migration Report Result, provides unique url for downloading your migration report.
        """
        return pulumi.get(self, "migration_report_result")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlOfflineTaskOutputTableLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "errorPrefix":
            suggest = "error_prefix"
        elif key == "itemsCompletedCount":
            suggest = "items_completed_count"
        elif key == "itemsCount":
            suggest = "items_count"
        elif key == "lastStorageUpdate":
            suggest = "last_storage_update"
        elif key == "objectName":
            suggest = "object_name"
        elif key == "resultPrefix":
            suggest = "result_prefix"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlOfflineTaskOutputTableLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputTableLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputTableLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 error_prefix: str,
                 id: str,
                 items_completed_count: float,
                 items_count: float,
                 last_storage_update: str,
                 object_name: str,
                 result_prefix: str,
                 result_type: str,
                 started_on: str,
                 state: str,
                 status_message: str):
        """
        :param str ended_on: Migration end time
        :param str error_prefix: Wildcard string prefix to use for querying all errors of the item
        :param str id: Result identifier
        :param float items_completed_count: Number of successfully completed items
        :param float items_count: Number of items
        :param str last_storage_update: Last time the storage was updated
        :param str object_name: Name of the item
        :param str result_prefix: Wildcard string prefix to use for querying all sub-tem results of the item
        :param str result_type: Result type
               Expected value is 'TableLevelOutput'.
        :param str started_on: Migration start time
        :param str state: Current state of migration
        :param str status_message: Status message
        """
        MigrateMySqlAzureDbForMySqlOfflineTaskOutputTableLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            error_prefix=error_prefix,
            id=id,
            items_completed_count=items_completed_count,
            items_count=items_count,
            last_storage_update=last_storage_update,
            object_name=object_name,
            result_prefix=result_prefix,
            result_type=result_type,
            started_on=started_on,
            state=state,
            status_message=status_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             error_prefix: Optional[str] = None,
             id: Optional[str] = None,
             items_completed_count: Optional[float] = None,
             items_count: Optional[float] = None,
             last_storage_update: Optional[str] = None,
             object_name: Optional[str] = None,
             result_prefix: Optional[str] = None,
             result_type: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             status_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if error_prefix is None and 'errorPrefix' in kwargs:
            error_prefix = kwargs['errorPrefix']
        if error_prefix is None:
            raise TypeError("Missing 'error_prefix' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if items_completed_count is None and 'itemsCompletedCount' in kwargs:
            items_completed_count = kwargs['itemsCompletedCount']
        if items_completed_count is None:
            raise TypeError("Missing 'items_completed_count' argument")
        if items_count is None and 'itemsCount' in kwargs:
            items_count = kwargs['itemsCount']
        if items_count is None:
            raise TypeError("Missing 'items_count' argument")
        if last_storage_update is None and 'lastStorageUpdate' in kwargs:
            last_storage_update = kwargs['lastStorageUpdate']
        if last_storage_update is None:
            raise TypeError("Missing 'last_storage_update' argument")
        if object_name is None and 'objectName' in kwargs:
            object_name = kwargs['objectName']
        if object_name is None:
            raise TypeError("Missing 'object_name' argument")
        if result_prefix is None and 'resultPrefix' in kwargs:
            result_prefix = kwargs['resultPrefix']
        if result_prefix is None:
            raise TypeError("Missing 'result_prefix' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status_message is None and 'statusMessage' in kwargs:
            status_message = kwargs['statusMessage']
        if status_message is None:
            raise TypeError("Missing 'status_message' argument")

        _setter("ended_on", ended_on)
        _setter("error_prefix", error_prefix)
        _setter("id", id)
        _setter("items_completed_count", items_completed_count)
        _setter("items_count", items_count)
        _setter("last_storage_update", last_storage_update)
        _setter("object_name", object_name)
        _setter("result_prefix", result_prefix)
        _setter("result_type", 'TableLevelOutput')
        _setter("started_on", started_on)
        _setter("state", state)
        _setter("status_message", status_message)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="errorPrefix")
    def error_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all errors of the item
        """
        return pulumi.get(self, "error_prefix")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="itemsCompletedCount")
    def items_completed_count(self) -> float:
        """
        Number of successfully completed items
        """
        return pulumi.get(self, "items_completed_count")

    @property
    @pulumi.getter(name="itemsCount")
    def items_count(self) -> float:
        """
        Number of items
        """
        return pulumi.get(self, "items_count")

    @property
    @pulumi.getter(name="lastStorageUpdate")
    def last_storage_update(self) -> str:
        """
        Last time the storage was updated
        """
        return pulumi.get(self, "last_storage_update")

    @property
    @pulumi.getter(name="objectName")
    def object_name(self) -> str:
        """
        Name of the item
        """
        return pulumi.get(self, "object_name")

    @property
    @pulumi.getter(name="resultPrefix")
    def result_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all sub-tem results of the item
        """
        return pulumi.get(self, "result_prefix")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'TableLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        Status message
        """
        return pulumi.get(self, "status_message")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlOfflineTaskPropertiesResponse(dict):
    """
    Properties for the task that migrates MySQL databases to Azure Database for MySQL for offline migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"
        elif key == "isCloneable":
            suggest = "is_cloneable"
        elif key == "taskId":
            suggest = "task_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlOfflineTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlOfflineTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse'] = None,
                 is_cloneable: Optional[bool] = None,
                 task_id: Optional[str] = None):
        """
        Properties for the task that migrates MySQL databases to Azure Database for MySQL for offline migrations
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['MigrateMySqlAzureDbForMySqlOfflineTaskOutputDatabaseLevelResponse', 'MigrateMySqlAzureDbForMySqlOfflineTaskOutputErrorResponse', 'MigrateMySqlAzureDbForMySqlOfflineTaskOutputMigrationLevelResponse', 'MigrateMySqlAzureDbForMySqlOfflineTaskOutputTableLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.MySql.AzureDbForMySql'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse' input: Task input
        :param bool is_cloneable: whether the task can be cloned or not
        :param str task_id: Task id 
        """
        MigrateMySqlAzureDbForMySqlOfflineTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
            is_cloneable=is_cloneable,
            task_id=task_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse'] = None,
             is_cloneable: Optional[bool] = None,
             task_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']
        if is_cloneable is None and 'isCloneable' in kwargs:
            is_cloneable = kwargs['isCloneable']
        if task_id is None and 'taskId' in kwargs:
            task_id = kwargs['taskId']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.MySql.AzureDbForMySql')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)
        if is_cloneable is not None:
            _setter("is_cloneable", is_cloneable)
        if task_id is not None:
            _setter("task_id", task_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.MySql.AzureDbForMySql'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateMySqlAzureDbForMySqlOfflineTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="isCloneable")
    def is_cloneable(self) -> Optional[bool]:
        """
        whether the task can be cloned or not
        """
        return pulumi.get(self, "is_cloneable")

    @property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[str]:
        """
        Task id 
        """
        return pulumi.get(self, "task_id")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse(dict):
    """
    Database specific information for MySQL to Azure Database for MySQL migration task inputs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "migrationSetting":
            suggest = "migration_setting"
        elif key == "sourceSetting":
            suggest = "source_setting"
        elif key == "tableMap":
            suggest = "table_map"
        elif key == "targetDatabaseName":
            suggest = "target_database_name"
        elif key == "targetSetting":
            suggest = "target_setting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 migration_setting: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 source_setting: Optional[Mapping[str, str]] = None,
                 table_map: Optional[Mapping[str, str]] = None,
                 target_database_name: Optional[str] = None,
                 target_setting: Optional[Mapping[str, str]] = None):
        """
        Database specific information for MySQL to Azure Database for MySQL migration task inputs
        :param Mapping[str, str] migration_setting: Migration settings which tune the migration behavior
        :param str name: Name of the database
        :param Mapping[str, str] source_setting: Source settings to tune source endpoint migration behavior
        :param Mapping[str, str] table_map: Mapping of source to target tables
        :param str target_database_name: Name of target database. Note: Target database will be truncated before starting migration.
        :param Mapping[str, str] target_setting: Target settings to tune target endpoint migration behavior
        """
        MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            migration_setting=migration_setting,
            name=name,
            source_setting=source_setting,
            table_map=table_map,
            target_database_name=target_database_name,
            target_setting=target_setting,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             migration_setting: Optional[Mapping[str, str]] = None,
             name: Optional[str] = None,
             source_setting: Optional[Mapping[str, str]] = None,
             table_map: Optional[Mapping[str, str]] = None,
             target_database_name: Optional[str] = None,
             target_setting: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if migration_setting is None and 'migrationSetting' in kwargs:
            migration_setting = kwargs['migrationSetting']
        if source_setting is None and 'sourceSetting' in kwargs:
            source_setting = kwargs['sourceSetting']
        if table_map is None and 'tableMap' in kwargs:
            table_map = kwargs['tableMap']
        if target_database_name is None and 'targetDatabaseName' in kwargs:
            target_database_name = kwargs['targetDatabaseName']
        if target_setting is None and 'targetSetting' in kwargs:
            target_setting = kwargs['targetSetting']

        if migration_setting is not None:
            _setter("migration_setting", migration_setting)
        if name is not None:
            _setter("name", name)
        if source_setting is not None:
            _setter("source_setting", source_setting)
        if table_map is not None:
            _setter("table_map", table_map)
        if target_database_name is not None:
            _setter("target_database_name", target_database_name)
        if target_setting is not None:
            _setter("target_setting", target_setting)

    @property
    @pulumi.getter(name="migrationSetting")
    def migration_setting(self) -> Optional[Mapping[str, str]]:
        """
        Migration settings which tune the migration behavior
        """
        return pulumi.get(self, "migration_setting")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceSetting")
    def source_setting(self) -> Optional[Mapping[str, str]]:
        """
        Source settings to tune source endpoint migration behavior
        """
        return pulumi.get(self, "source_setting")

    @property
    @pulumi.getter(name="tableMap")
    def table_map(self) -> Optional[Mapping[str, str]]:
        """
        Mapping of source to target tables
        """
        return pulumi.get(self, "table_map")

    @property
    @pulumi.getter(name="targetDatabaseName")
    def target_database_name(self) -> Optional[str]:
        """
        Name of target database. Note: Target database will be truncated before starting migration.
        """
        return pulumi.get(self, "target_database_name")

    @property
    @pulumi.getter(name="targetSetting")
    def target_setting(self) -> Optional[Mapping[str, str]]:
        """
        Target settings to tune target endpoint migration behavior
        """
        return pulumi.get(self, "target_setting")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlSyncTaskInputResponse(dict):
    """
    Input for the task that migrates MySQL databases to Azure Database for MySQL for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_databases: Sequence['outputs.MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse'],
                 source_connection_info: 'outputs.MySqlConnectionInfoResponse',
                 target_connection_info: 'outputs.MySqlConnectionInfoResponse'):
        """
        Input for the task that migrates MySQL databases to Azure Database for MySQL for online migrations
        :param Sequence['MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'MySqlConnectionInfoResponse' source_connection_info: Connection information for source MySQL
        :param 'MySqlConnectionInfoResponse' target_connection_info: Connection information for target Azure Database for MySQL
        """
        MigrateMySqlAzureDbForMySqlSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_databases: Optional[Sequence['outputs.MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.MySqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.MySqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")

        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateMySqlAzureDbForMySqlSyncDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.MySqlConnectionInfoResponse':
        """
        Connection information for source MySQL
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.MySqlConnectionInfoResponse':
        """
        Connection information for target Azure Database for MySQL
        """
        return pulumi.get(self, "target_connection_info")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"
        elif key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 result_type: str,
                 error_message: Optional[str] = None,
                 events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None):
        """
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'DatabaseLevelErrorOutput'.
        :param str error_message: Error message
        :param Sequence['SyncMigrationDatabaseErrorEventResponse'] events: List of error events.
        """
        MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            result_type=result_type,
            error_message=error_message,
            events=events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             error_message: Optional[str] = None,
             events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']

        _setter("id", id)
        _setter("result_type", 'DatabaseLevelErrorOutput')
        if error_message is not None:
            _setter("error_message", error_message)
        if events is not None:
            _setter("events", events)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelErrorOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        Error message
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']]:
        """
        List of error events.
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedChanges":
            suggest = "applied_changes"
        elif key == "cdcDeleteCounter":
            suggest = "cdc_delete_counter"
        elif key == "cdcInsertCounter":
            suggest = "cdc_insert_counter"
        elif key == "cdcUpdateCounter":
            suggest = "cdc_update_counter"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "fullLoadCompletedTables":
            suggest = "full_load_completed_tables"
        elif key == "fullLoadErroredTables":
            suggest = "full_load_errored_tables"
        elif key == "fullLoadLoadingTables":
            suggest = "full_load_loading_tables"
        elif key == "fullLoadQueuedTables":
            suggest = "full_load_queued_tables"
        elif key == "incomingChanges":
            suggest = "incoming_changes"
        elif key == "initializationCompleted":
            suggest = "initialization_completed"
        elif key == "migrationState":
            suggest = "migration_state"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applied_changes: float,
                 cdc_delete_counter: float,
                 cdc_insert_counter: float,
                 cdc_update_counter: float,
                 database_name: str,
                 ended_on: str,
                 full_load_completed_tables: float,
                 full_load_errored_tables: float,
                 full_load_loading_tables: float,
                 full_load_queued_tables: float,
                 id: str,
                 incoming_changes: float,
                 initialization_completed: bool,
                 latency: float,
                 migration_state: str,
                 result_type: str,
                 started_on: str):
        """
        :param float applied_changes: Number of applied changes
        :param float cdc_delete_counter: Number of cdc deletes
        :param float cdc_insert_counter: Number of cdc inserts
        :param float cdc_update_counter: Number of cdc updates
        :param str database_name: Name of the database
        :param str ended_on: Migration end time
        :param float full_load_completed_tables: Number of tables completed in full load
        :param float full_load_errored_tables: Number of tables errored in full load
        :param float full_load_loading_tables: Number of tables loading in full load
        :param float full_load_queued_tables: Number of tables queued in full load
        :param str id: Result identifier
        :param float incoming_changes: Number of incoming changes
        :param bool initialization_completed: Indicates if initial load (full load) has been completed
        :param float latency: CDC apply latency
        :param str migration_state: Migration state that this database is in
        :param str result_type: Result type
               Expected value is 'DatabaseLevelOutput'.
        :param str started_on: Migration start time
        """
        MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            applied_changes=applied_changes,
            cdc_delete_counter=cdc_delete_counter,
            cdc_insert_counter=cdc_insert_counter,
            cdc_update_counter=cdc_update_counter,
            database_name=database_name,
            ended_on=ended_on,
            full_load_completed_tables=full_load_completed_tables,
            full_load_errored_tables=full_load_errored_tables,
            full_load_loading_tables=full_load_loading_tables,
            full_load_queued_tables=full_load_queued_tables,
            id=id,
            incoming_changes=incoming_changes,
            initialization_completed=initialization_completed,
            latency=latency,
            migration_state=migration_state,
            result_type=result_type,
            started_on=started_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             applied_changes: Optional[float] = None,
             cdc_delete_counter: Optional[float] = None,
             cdc_insert_counter: Optional[float] = None,
             cdc_update_counter: Optional[float] = None,
             database_name: Optional[str] = None,
             ended_on: Optional[str] = None,
             full_load_completed_tables: Optional[float] = None,
             full_load_errored_tables: Optional[float] = None,
             full_load_loading_tables: Optional[float] = None,
             full_load_queued_tables: Optional[float] = None,
             id: Optional[str] = None,
             incoming_changes: Optional[float] = None,
             initialization_completed: Optional[bool] = None,
             latency: Optional[float] = None,
             migration_state: Optional[str] = None,
             result_type: Optional[str] = None,
             started_on: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if applied_changes is None and 'appliedChanges' in kwargs:
            applied_changes = kwargs['appliedChanges']
        if applied_changes is None:
            raise TypeError("Missing 'applied_changes' argument")
        if cdc_delete_counter is None and 'cdcDeleteCounter' in kwargs:
            cdc_delete_counter = kwargs['cdcDeleteCounter']
        if cdc_delete_counter is None:
            raise TypeError("Missing 'cdc_delete_counter' argument")
        if cdc_insert_counter is None and 'cdcInsertCounter' in kwargs:
            cdc_insert_counter = kwargs['cdcInsertCounter']
        if cdc_insert_counter is None:
            raise TypeError("Missing 'cdc_insert_counter' argument")
        if cdc_update_counter is None and 'cdcUpdateCounter' in kwargs:
            cdc_update_counter = kwargs['cdcUpdateCounter']
        if cdc_update_counter is None:
            raise TypeError("Missing 'cdc_update_counter' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if full_load_completed_tables is None and 'fullLoadCompletedTables' in kwargs:
            full_load_completed_tables = kwargs['fullLoadCompletedTables']
        if full_load_completed_tables is None:
            raise TypeError("Missing 'full_load_completed_tables' argument")
        if full_load_errored_tables is None and 'fullLoadErroredTables' in kwargs:
            full_load_errored_tables = kwargs['fullLoadErroredTables']
        if full_load_errored_tables is None:
            raise TypeError("Missing 'full_load_errored_tables' argument")
        if full_load_loading_tables is None and 'fullLoadLoadingTables' in kwargs:
            full_load_loading_tables = kwargs['fullLoadLoadingTables']
        if full_load_loading_tables is None:
            raise TypeError("Missing 'full_load_loading_tables' argument")
        if full_load_queued_tables is None and 'fullLoadQueuedTables' in kwargs:
            full_load_queued_tables = kwargs['fullLoadQueuedTables']
        if full_load_queued_tables is None:
            raise TypeError("Missing 'full_load_queued_tables' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if incoming_changes is None and 'incomingChanges' in kwargs:
            incoming_changes = kwargs['incomingChanges']
        if incoming_changes is None:
            raise TypeError("Missing 'incoming_changes' argument")
        if initialization_completed is None and 'initializationCompleted' in kwargs:
            initialization_completed = kwargs['initializationCompleted']
        if initialization_completed is None:
            raise TypeError("Missing 'initialization_completed' argument")
        if latency is None:
            raise TypeError("Missing 'latency' argument")
        if migration_state is None and 'migrationState' in kwargs:
            migration_state = kwargs['migrationState']
        if migration_state is None:
            raise TypeError("Missing 'migration_state' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")

        _setter("applied_changes", applied_changes)
        _setter("cdc_delete_counter", cdc_delete_counter)
        _setter("cdc_insert_counter", cdc_insert_counter)
        _setter("cdc_update_counter", cdc_update_counter)
        _setter("database_name", database_name)
        _setter("ended_on", ended_on)
        _setter("full_load_completed_tables", full_load_completed_tables)
        _setter("full_load_errored_tables", full_load_errored_tables)
        _setter("full_load_loading_tables", full_load_loading_tables)
        _setter("full_load_queued_tables", full_load_queued_tables)
        _setter("id", id)
        _setter("incoming_changes", incoming_changes)
        _setter("initialization_completed", initialization_completed)
        _setter("latency", latency)
        _setter("migration_state", migration_state)
        _setter("result_type", 'DatabaseLevelOutput')
        _setter("started_on", started_on)

    @property
    @pulumi.getter(name="appliedChanges")
    def applied_changes(self) -> float:
        """
        Number of applied changes
        """
        return pulumi.get(self, "applied_changes")

    @property
    @pulumi.getter(name="cdcDeleteCounter")
    def cdc_delete_counter(self) -> float:
        """
        Number of cdc deletes
        """
        return pulumi.get(self, "cdc_delete_counter")

    @property
    @pulumi.getter(name="cdcInsertCounter")
    def cdc_insert_counter(self) -> float:
        """
        Number of cdc inserts
        """
        return pulumi.get(self, "cdc_insert_counter")

    @property
    @pulumi.getter(name="cdcUpdateCounter")
    def cdc_update_counter(self) -> float:
        """
        Number of cdc updates
        """
        return pulumi.get(self, "cdc_update_counter")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="fullLoadCompletedTables")
    def full_load_completed_tables(self) -> float:
        """
        Number of tables completed in full load
        """
        return pulumi.get(self, "full_load_completed_tables")

    @property
    @pulumi.getter(name="fullLoadErroredTables")
    def full_load_errored_tables(self) -> float:
        """
        Number of tables errored in full load
        """
        return pulumi.get(self, "full_load_errored_tables")

    @property
    @pulumi.getter(name="fullLoadLoadingTables")
    def full_load_loading_tables(self) -> float:
        """
        Number of tables loading in full load
        """
        return pulumi.get(self, "full_load_loading_tables")

    @property
    @pulumi.getter(name="fullLoadQueuedTables")
    def full_load_queued_tables(self) -> float:
        """
        Number of tables queued in full load
        """
        return pulumi.get(self, "full_load_queued_tables")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="incomingChanges")
    def incoming_changes(self) -> float:
        """
        Number of incoming changes
        """
        return pulumi.get(self, "incoming_changes")

    @property
    @pulumi.getter(name="initializationCompleted")
    def initialization_completed(self) -> bool:
        """
        Indicates if initial load (full load) has been completed
        """
        return pulumi.get(self, "initialization_completed")

    @property
    @pulumi.getter
    def latency(self) -> float:
        """
        CDC apply latency
        """
        return pulumi.get(self, "latency")

    @property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> str:
        """
        Migration state that this database is in
        """
        return pulumi.get(self, "migration_state")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlSyncTaskOutputErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlSyncTaskOutputErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.ReportableExceptionResponse',
                 id: str,
                 result_type: str):
        """
        :param 'ReportableExceptionResponse' error: Migration error
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'ErrorOutput'.
        """
        MigrateMySqlAzureDbForMySqlSyncTaskOutputErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            id=id,
            result_type=result_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional['outputs.ReportableExceptionResponse'] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error is None:
            raise TypeError("Missing 'error' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")

        _setter("error", error)
        _setter("id", id)
        _setter("result_type", 'ErrorOutput')

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ReportableExceptionResponse':
        """
        Migration error
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'ErrorOutput'.
        """
        return pulumi.get(self, "result_type")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlSyncTaskOutputMigrationLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceServer":
            suggest = "source_server"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetServer":
            suggest = "target_server"
        elif key == "targetServerVersion":
            suggest = "target_server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlSyncTaskOutputMigrationLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 id: str,
                 result_type: str,
                 source_server: str,
                 source_server_version: str,
                 started_on: str,
                 target_server: str,
                 target_server_version: str):
        """
        :param str ended_on: Migration end time
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'MigrationLevelOutput'.
        :param str source_server: Source server name
        :param str source_server_version: Source server version
        :param str started_on: Migration start time
        :param str target_server: Target server name
        :param str target_server_version: Target server version
        """
        MigrateMySqlAzureDbForMySqlSyncTaskOutputMigrationLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            id=id,
            result_type=result_type,
            source_server=source_server,
            source_server_version=source_server_version,
            started_on=started_on,
            target_server=target_server,
            target_server_version=target_server_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             source_server: Optional[str] = None,
             source_server_version: Optional[str] = None,
             started_on: Optional[str] = None,
             target_server: Optional[str] = None,
             target_server_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_server is None and 'sourceServer' in kwargs:
            source_server = kwargs['sourceServer']
        if source_server is None:
            raise TypeError("Missing 'source_server' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if target_server is None and 'targetServer' in kwargs:
            target_server = kwargs['targetServer']
        if target_server is None:
            raise TypeError("Missing 'target_server' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")

        _setter("ended_on", ended_on)
        _setter("id", id)
        _setter("result_type", 'MigrationLevelOutput')
        _setter("source_server", source_server)
        _setter("source_server_version", source_server_version)
        _setter("started_on", started_on)
        _setter("target_server", target_server)
        _setter("target_server_version", target_server_version)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceServer")
    def source_server(self) -> str:
        """
        Source server name
        """
        return pulumi.get(self, "source_server")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter(name="targetServer")
    def target_server(self) -> str:
        """
        Target server name
        """
        return pulumi.get(self, "target_server")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlSyncTaskOutputTableLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdcDeleteCounter":
            suggest = "cdc_delete_counter"
        elif key == "cdcInsertCounter":
            suggest = "cdc_insert_counter"
        elif key == "cdcUpdateCounter":
            suggest = "cdc_update_counter"
        elif key == "dataErrorsCounter":
            suggest = "data_errors_counter"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "fullLoadEndedOn":
            suggest = "full_load_ended_on"
        elif key == "fullLoadEstFinishTime":
            suggest = "full_load_est_finish_time"
        elif key == "fullLoadStartedOn":
            suggest = "full_load_started_on"
        elif key == "fullLoadTotalRows":
            suggest = "full_load_total_rows"
        elif key == "lastModifiedTime":
            suggest = "last_modified_time"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "totalChangesApplied":
            suggest = "total_changes_applied"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlSyncTaskOutputTableLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputTableLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskOutputTableLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdc_delete_counter: str,
                 cdc_insert_counter: str,
                 cdc_update_counter: str,
                 data_errors_counter: float,
                 database_name: str,
                 full_load_ended_on: str,
                 full_load_est_finish_time: str,
                 full_load_started_on: str,
                 full_load_total_rows: float,
                 id: str,
                 last_modified_time: str,
                 result_type: str,
                 state: str,
                 table_name: str,
                 total_changes_applied: float):
        """
        :param str cdc_delete_counter: Number of applied deletes
        :param str cdc_insert_counter: Number of applied inserts
        :param str cdc_update_counter: Number of applied updates
        :param float data_errors_counter: Number of data errors occurred
        :param str database_name: Name of the database
        :param str full_load_ended_on: Full load end time
        :param str full_load_est_finish_time: Estimate to finish full load
        :param str full_load_started_on: Full load start time
        :param float full_load_total_rows: Number of rows applied in full load
        :param str id: Result identifier
        :param str last_modified_time: Last modified time on target
        :param str result_type: Result type
               Expected value is 'TableLevelOutput'.
        :param str state: Current state of the table migration
        :param str table_name: Name of the table
        :param float total_changes_applied: Total number of applied changes
        """
        MigrateMySqlAzureDbForMySqlSyncTaskOutputTableLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cdc_delete_counter=cdc_delete_counter,
            cdc_insert_counter=cdc_insert_counter,
            cdc_update_counter=cdc_update_counter,
            data_errors_counter=data_errors_counter,
            database_name=database_name,
            full_load_ended_on=full_load_ended_on,
            full_load_est_finish_time=full_load_est_finish_time,
            full_load_started_on=full_load_started_on,
            full_load_total_rows=full_load_total_rows,
            id=id,
            last_modified_time=last_modified_time,
            result_type=result_type,
            state=state,
            table_name=table_name,
            total_changes_applied=total_changes_applied,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cdc_delete_counter: Optional[str] = None,
             cdc_insert_counter: Optional[str] = None,
             cdc_update_counter: Optional[str] = None,
             data_errors_counter: Optional[float] = None,
             database_name: Optional[str] = None,
             full_load_ended_on: Optional[str] = None,
             full_load_est_finish_time: Optional[str] = None,
             full_load_started_on: Optional[str] = None,
             full_load_total_rows: Optional[float] = None,
             id: Optional[str] = None,
             last_modified_time: Optional[str] = None,
             result_type: Optional[str] = None,
             state: Optional[str] = None,
             table_name: Optional[str] = None,
             total_changes_applied: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cdc_delete_counter is None and 'cdcDeleteCounter' in kwargs:
            cdc_delete_counter = kwargs['cdcDeleteCounter']
        if cdc_delete_counter is None:
            raise TypeError("Missing 'cdc_delete_counter' argument")
        if cdc_insert_counter is None and 'cdcInsertCounter' in kwargs:
            cdc_insert_counter = kwargs['cdcInsertCounter']
        if cdc_insert_counter is None:
            raise TypeError("Missing 'cdc_insert_counter' argument")
        if cdc_update_counter is None and 'cdcUpdateCounter' in kwargs:
            cdc_update_counter = kwargs['cdcUpdateCounter']
        if cdc_update_counter is None:
            raise TypeError("Missing 'cdc_update_counter' argument")
        if data_errors_counter is None and 'dataErrorsCounter' in kwargs:
            data_errors_counter = kwargs['dataErrorsCounter']
        if data_errors_counter is None:
            raise TypeError("Missing 'data_errors_counter' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if full_load_ended_on is None and 'fullLoadEndedOn' in kwargs:
            full_load_ended_on = kwargs['fullLoadEndedOn']
        if full_load_ended_on is None:
            raise TypeError("Missing 'full_load_ended_on' argument")
        if full_load_est_finish_time is None and 'fullLoadEstFinishTime' in kwargs:
            full_load_est_finish_time = kwargs['fullLoadEstFinishTime']
        if full_load_est_finish_time is None:
            raise TypeError("Missing 'full_load_est_finish_time' argument")
        if full_load_started_on is None and 'fullLoadStartedOn' in kwargs:
            full_load_started_on = kwargs['fullLoadStartedOn']
        if full_load_started_on is None:
            raise TypeError("Missing 'full_load_started_on' argument")
        if full_load_total_rows is None and 'fullLoadTotalRows' in kwargs:
            full_load_total_rows = kwargs['fullLoadTotalRows']
        if full_load_total_rows is None:
            raise TypeError("Missing 'full_load_total_rows' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if last_modified_time is None and 'lastModifiedTime' in kwargs:
            last_modified_time = kwargs['lastModifiedTime']
        if last_modified_time is None:
            raise TypeError("Missing 'last_modified_time' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if total_changes_applied is None and 'totalChangesApplied' in kwargs:
            total_changes_applied = kwargs['totalChangesApplied']
        if total_changes_applied is None:
            raise TypeError("Missing 'total_changes_applied' argument")

        _setter("cdc_delete_counter", cdc_delete_counter)
        _setter("cdc_insert_counter", cdc_insert_counter)
        _setter("cdc_update_counter", cdc_update_counter)
        _setter("data_errors_counter", data_errors_counter)
        _setter("database_name", database_name)
        _setter("full_load_ended_on", full_load_ended_on)
        _setter("full_load_est_finish_time", full_load_est_finish_time)
        _setter("full_load_started_on", full_load_started_on)
        _setter("full_load_total_rows", full_load_total_rows)
        _setter("id", id)
        _setter("last_modified_time", last_modified_time)
        _setter("result_type", 'TableLevelOutput')
        _setter("state", state)
        _setter("table_name", table_name)
        _setter("total_changes_applied", total_changes_applied)

    @property
    @pulumi.getter(name="cdcDeleteCounter")
    def cdc_delete_counter(self) -> str:
        """
        Number of applied deletes
        """
        return pulumi.get(self, "cdc_delete_counter")

    @property
    @pulumi.getter(name="cdcInsertCounter")
    def cdc_insert_counter(self) -> str:
        """
        Number of applied inserts
        """
        return pulumi.get(self, "cdc_insert_counter")

    @property
    @pulumi.getter(name="cdcUpdateCounter")
    def cdc_update_counter(self) -> str:
        """
        Number of applied updates
        """
        return pulumi.get(self, "cdc_update_counter")

    @property
    @pulumi.getter(name="dataErrorsCounter")
    def data_errors_counter(self) -> float:
        """
        Number of data errors occurred
        """
        return pulumi.get(self, "data_errors_counter")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="fullLoadEndedOn")
    def full_load_ended_on(self) -> str:
        """
        Full load end time
        """
        return pulumi.get(self, "full_load_ended_on")

    @property
    @pulumi.getter(name="fullLoadEstFinishTime")
    def full_load_est_finish_time(self) -> str:
        """
        Estimate to finish full load
        """
        return pulumi.get(self, "full_load_est_finish_time")

    @property
    @pulumi.getter(name="fullLoadStartedOn")
    def full_load_started_on(self) -> str:
        """
        Full load start time
        """
        return pulumi.get(self, "full_load_started_on")

    @property
    @pulumi.getter(name="fullLoadTotalRows")
    def full_load_total_rows(self) -> float:
        """
        Number of rows applied in full load
        """
        return pulumi.get(self, "full_load_total_rows")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> str:
        """
        Last modified time on target
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'TableLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the table migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        Name of the table
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="totalChangesApplied")
    def total_changes_applied(self) -> float:
        """
        Total number of applied changes
        """
        return pulumi.get(self, "total_changes_applied")


@pulumi.output_type
class MigrateMySqlAzureDbForMySqlSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that migrates MySQL databases to Azure Database for MySQL for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateMySqlAzureDbForMySqlSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateMySqlAzureDbForMySqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.MigrateMySqlAzureDbForMySqlSyncTaskInputResponse'] = None):
        """
        Properties for the task that migrates MySQL databases to Azure Database for MySQL for online migrations
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseErrorResponse', 'MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseLevelResponse', 'MigrateMySqlAzureDbForMySqlSyncTaskOutputErrorResponse', 'MigrateMySqlAzureDbForMySqlSyncTaskOutputMigrationLevelResponse', 'MigrateMySqlAzureDbForMySqlSyncTaskOutputTableLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.MySql.AzureDbForMySql.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'MigrateMySqlAzureDbForMySqlSyncTaskInputResponse' input: Task input
        """
        MigrateMySqlAzureDbForMySqlSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.MigrateMySqlAzureDbForMySqlSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.MySql.AzureDbForMySql.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.MySql.AzureDbForMySql.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateMySqlAzureDbForMySqlSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class MigrateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that migrates Oracle to Azure Database for PostgreSQL for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse'] = None):
        """
        Properties for the task that migrates Oracle to Azure Database for PostgreSQL for online migrations
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseErrorResponse', 'MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseLevelResponse', 'MigrateOracleAzureDbPostgreSqlSyncTaskOutputErrorResponse', 'MigrateOracleAzureDbPostgreSqlSyncTaskOutputMigrationLevelResponse', 'MigrateOracleAzureDbPostgreSqlSyncTaskOutputTableLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.Oracle.AzureDbForPostgreSql.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse' input: Task input
        """
        MigrateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.Oracle.AzureDbForPostgreSql.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.Oracle.AzureDbForPostgreSql.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse(dict):
    """
    Database specific information for Oracle to Azure Database for PostgreSQL migration task inputs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseManipulation":
            suggest = "case_manipulation"
        elif key == "migrationSetting":
            suggest = "migration_setting"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "sourceSetting":
            suggest = "source_setting"
        elif key == "tableMap":
            suggest = "table_map"
        elif key == "targetDatabaseName":
            suggest = "target_database_name"
        elif key == "targetSetting":
            suggest = "target_setting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_manipulation: Optional[str] = None,
                 migration_setting: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 schema_name: Optional[str] = None,
                 source_setting: Optional[Mapping[str, str]] = None,
                 table_map: Optional[Mapping[str, str]] = None,
                 target_database_name: Optional[str] = None,
                 target_setting: Optional[Mapping[str, str]] = None):
        """
        Database specific information for Oracle to Azure Database for PostgreSQL migration task inputs
        :param str case_manipulation: How to handle object name casing: either Preserve or ToLower
        :param Mapping[str, str] migration_setting: Migration settings which tune the migration behavior
        :param str name: Name of the migration pipeline
        :param str schema_name: Name of the source schema
        :param Mapping[str, str] source_setting: Source settings to tune source endpoint migration behavior
        :param Mapping[str, str] table_map: Mapping of source to target tables
        :param str target_database_name: Name of target database. Note: Target database will be truncated before starting migration.
        :param Mapping[str, str] target_setting: Target settings to tune target endpoint migration behavior
        """
        MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            case_manipulation=case_manipulation,
            migration_setting=migration_setting,
            name=name,
            schema_name=schema_name,
            source_setting=source_setting,
            table_map=table_map,
            target_database_name=target_database_name,
            target_setting=target_setting,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             case_manipulation: Optional[str] = None,
             migration_setting: Optional[Mapping[str, str]] = None,
             name: Optional[str] = None,
             schema_name: Optional[str] = None,
             source_setting: Optional[Mapping[str, str]] = None,
             table_map: Optional[Mapping[str, str]] = None,
             target_database_name: Optional[str] = None,
             target_setting: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if case_manipulation is None and 'caseManipulation' in kwargs:
            case_manipulation = kwargs['caseManipulation']
        if migration_setting is None and 'migrationSetting' in kwargs:
            migration_setting = kwargs['migrationSetting']
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if source_setting is None and 'sourceSetting' in kwargs:
            source_setting = kwargs['sourceSetting']
        if table_map is None and 'tableMap' in kwargs:
            table_map = kwargs['tableMap']
        if target_database_name is None and 'targetDatabaseName' in kwargs:
            target_database_name = kwargs['targetDatabaseName']
        if target_setting is None and 'targetSetting' in kwargs:
            target_setting = kwargs['targetSetting']

        if case_manipulation is not None:
            _setter("case_manipulation", case_manipulation)
        if migration_setting is not None:
            _setter("migration_setting", migration_setting)
        if name is not None:
            _setter("name", name)
        if schema_name is not None:
            _setter("schema_name", schema_name)
        if source_setting is not None:
            _setter("source_setting", source_setting)
        if table_map is not None:
            _setter("table_map", table_map)
        if target_database_name is not None:
            _setter("target_database_name", target_database_name)
        if target_setting is not None:
            _setter("target_setting", target_setting)

    @property
    @pulumi.getter(name="caseManipulation")
    def case_manipulation(self) -> Optional[str]:
        """
        How to handle object name casing: either Preserve or ToLower
        """
        return pulumi.get(self, "case_manipulation")

    @property
    @pulumi.getter(name="migrationSetting")
    def migration_setting(self) -> Optional[Mapping[str, str]]:
        """
        Migration settings which tune the migration behavior
        """
        return pulumi.get(self, "migration_setting")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the migration pipeline
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        Name of the source schema
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sourceSetting")
    def source_setting(self) -> Optional[Mapping[str, str]]:
        """
        Source settings to tune source endpoint migration behavior
        """
        return pulumi.get(self, "source_setting")

    @property
    @pulumi.getter(name="tableMap")
    def table_map(self) -> Optional[Mapping[str, str]]:
        """
        Mapping of source to target tables
        """
        return pulumi.get(self, "table_map")

    @property
    @pulumi.getter(name="targetDatabaseName")
    def target_database_name(self) -> Optional[str]:
        """
        Name of target database. Note: Target database will be truncated before starting migration.
        """
        return pulumi.get(self, "target_database_name")

    @property
    @pulumi.getter(name="targetSetting")
    def target_setting(self) -> Optional[Mapping[str, str]]:
        """
        Target settings to tune target endpoint migration behavior
        """
        return pulumi.get(self, "target_setting")


@pulumi.output_type
class MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse(dict):
    """
    Input for the task that migrates Oracle databases to Azure Database for PostgreSQL for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_databases: Sequence['outputs.MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse'],
                 source_connection_info: 'outputs.OracleConnectionInfoResponse',
                 target_connection_info: 'outputs.PostgreSqlConnectionInfoResponse'):
        """
        Input for the task that migrates Oracle databases to Azure Database for PostgreSQL for online migrations
        :param Sequence['MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'OracleConnectionInfoResponse' source_connection_info: Connection information for source Oracle
        :param 'PostgreSqlConnectionInfoResponse' target_connection_info: Connection information for target Azure Database for PostgreSQL
        """
        MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_databases: Optional[Sequence['outputs.MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.OracleConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.PostgreSqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")

        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateOracleAzureDbPostgreSqlSyncDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.OracleConnectionInfoResponse':
        """
        Connection information for source Oracle
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.PostgreSqlConnectionInfoResponse':
        """
        Connection information for target Azure Database for PostgreSQL
        """
        return pulumi.get(self, "target_connection_info")


@pulumi.output_type
class MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"
        elif key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 result_type: str,
                 error_message: Optional[str] = None,
                 events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None):
        """
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'DatabaseLevelErrorOutput'.
        :param str error_message: Error message
        :param Sequence['SyncMigrationDatabaseErrorEventResponse'] events: List of error events.
        """
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            result_type=result_type,
            error_message=error_message,
            events=events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             error_message: Optional[str] = None,
             events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']

        _setter("id", id)
        _setter("result_type", 'DatabaseLevelErrorOutput')
        if error_message is not None:
            _setter("error_message", error_message)
        if events is not None:
            _setter("events", events)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelErrorOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        Error message
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']]:
        """
        List of error events.
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedChanges":
            suggest = "applied_changes"
        elif key == "cdcDeleteCounter":
            suggest = "cdc_delete_counter"
        elif key == "cdcInsertCounter":
            suggest = "cdc_insert_counter"
        elif key == "cdcUpdateCounter":
            suggest = "cdc_update_counter"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "fullLoadCompletedTables":
            suggest = "full_load_completed_tables"
        elif key == "fullLoadErroredTables":
            suggest = "full_load_errored_tables"
        elif key == "fullLoadLoadingTables":
            suggest = "full_load_loading_tables"
        elif key == "fullLoadQueuedTables":
            suggest = "full_load_queued_tables"
        elif key == "incomingChanges":
            suggest = "incoming_changes"
        elif key == "initializationCompleted":
            suggest = "initialization_completed"
        elif key == "migrationState":
            suggest = "migration_state"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applied_changes: float,
                 cdc_delete_counter: float,
                 cdc_insert_counter: float,
                 cdc_update_counter: float,
                 database_name: str,
                 ended_on: str,
                 full_load_completed_tables: float,
                 full_load_errored_tables: float,
                 full_load_loading_tables: float,
                 full_load_queued_tables: float,
                 id: str,
                 incoming_changes: float,
                 initialization_completed: bool,
                 latency: float,
                 migration_state: str,
                 result_type: str,
                 started_on: str):
        """
        :param float applied_changes: Number of applied changes
        :param float cdc_delete_counter: Number of cdc deletes
        :param float cdc_insert_counter: Number of cdc inserts
        :param float cdc_update_counter: Number of cdc updates
        :param str database_name: Name of the database
        :param str ended_on: Migration end time
        :param float full_load_completed_tables: Number of tables completed in full load
        :param float full_load_errored_tables: Number of tables errored in full load
        :param float full_load_loading_tables: Number of tables loading in full load
        :param float full_load_queued_tables: Number of tables queued in full load
        :param str id: Result identifier
        :param float incoming_changes: Number of incoming changes
        :param bool initialization_completed: Indicates if initial load (full load) has been completed
        :param float latency: CDC apply latency
        :param str migration_state: Migration state that this database is in
        :param str result_type: Result type
               Expected value is 'DatabaseLevelOutput'.
        :param str started_on: Migration start time
        """
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            applied_changes=applied_changes,
            cdc_delete_counter=cdc_delete_counter,
            cdc_insert_counter=cdc_insert_counter,
            cdc_update_counter=cdc_update_counter,
            database_name=database_name,
            ended_on=ended_on,
            full_load_completed_tables=full_load_completed_tables,
            full_load_errored_tables=full_load_errored_tables,
            full_load_loading_tables=full_load_loading_tables,
            full_load_queued_tables=full_load_queued_tables,
            id=id,
            incoming_changes=incoming_changes,
            initialization_completed=initialization_completed,
            latency=latency,
            migration_state=migration_state,
            result_type=result_type,
            started_on=started_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             applied_changes: Optional[float] = None,
             cdc_delete_counter: Optional[float] = None,
             cdc_insert_counter: Optional[float] = None,
             cdc_update_counter: Optional[float] = None,
             database_name: Optional[str] = None,
             ended_on: Optional[str] = None,
             full_load_completed_tables: Optional[float] = None,
             full_load_errored_tables: Optional[float] = None,
             full_load_loading_tables: Optional[float] = None,
             full_load_queued_tables: Optional[float] = None,
             id: Optional[str] = None,
             incoming_changes: Optional[float] = None,
             initialization_completed: Optional[bool] = None,
             latency: Optional[float] = None,
             migration_state: Optional[str] = None,
             result_type: Optional[str] = None,
             started_on: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if applied_changes is None and 'appliedChanges' in kwargs:
            applied_changes = kwargs['appliedChanges']
        if applied_changes is None:
            raise TypeError("Missing 'applied_changes' argument")
        if cdc_delete_counter is None and 'cdcDeleteCounter' in kwargs:
            cdc_delete_counter = kwargs['cdcDeleteCounter']
        if cdc_delete_counter is None:
            raise TypeError("Missing 'cdc_delete_counter' argument")
        if cdc_insert_counter is None and 'cdcInsertCounter' in kwargs:
            cdc_insert_counter = kwargs['cdcInsertCounter']
        if cdc_insert_counter is None:
            raise TypeError("Missing 'cdc_insert_counter' argument")
        if cdc_update_counter is None and 'cdcUpdateCounter' in kwargs:
            cdc_update_counter = kwargs['cdcUpdateCounter']
        if cdc_update_counter is None:
            raise TypeError("Missing 'cdc_update_counter' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if full_load_completed_tables is None and 'fullLoadCompletedTables' in kwargs:
            full_load_completed_tables = kwargs['fullLoadCompletedTables']
        if full_load_completed_tables is None:
            raise TypeError("Missing 'full_load_completed_tables' argument")
        if full_load_errored_tables is None and 'fullLoadErroredTables' in kwargs:
            full_load_errored_tables = kwargs['fullLoadErroredTables']
        if full_load_errored_tables is None:
            raise TypeError("Missing 'full_load_errored_tables' argument")
        if full_load_loading_tables is None and 'fullLoadLoadingTables' in kwargs:
            full_load_loading_tables = kwargs['fullLoadLoadingTables']
        if full_load_loading_tables is None:
            raise TypeError("Missing 'full_load_loading_tables' argument")
        if full_load_queued_tables is None and 'fullLoadQueuedTables' in kwargs:
            full_load_queued_tables = kwargs['fullLoadQueuedTables']
        if full_load_queued_tables is None:
            raise TypeError("Missing 'full_load_queued_tables' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if incoming_changes is None and 'incomingChanges' in kwargs:
            incoming_changes = kwargs['incomingChanges']
        if incoming_changes is None:
            raise TypeError("Missing 'incoming_changes' argument")
        if initialization_completed is None and 'initializationCompleted' in kwargs:
            initialization_completed = kwargs['initializationCompleted']
        if initialization_completed is None:
            raise TypeError("Missing 'initialization_completed' argument")
        if latency is None:
            raise TypeError("Missing 'latency' argument")
        if migration_state is None and 'migrationState' in kwargs:
            migration_state = kwargs['migrationState']
        if migration_state is None:
            raise TypeError("Missing 'migration_state' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")

        _setter("applied_changes", applied_changes)
        _setter("cdc_delete_counter", cdc_delete_counter)
        _setter("cdc_insert_counter", cdc_insert_counter)
        _setter("cdc_update_counter", cdc_update_counter)
        _setter("database_name", database_name)
        _setter("ended_on", ended_on)
        _setter("full_load_completed_tables", full_load_completed_tables)
        _setter("full_load_errored_tables", full_load_errored_tables)
        _setter("full_load_loading_tables", full_load_loading_tables)
        _setter("full_load_queued_tables", full_load_queued_tables)
        _setter("id", id)
        _setter("incoming_changes", incoming_changes)
        _setter("initialization_completed", initialization_completed)
        _setter("latency", latency)
        _setter("migration_state", migration_state)
        _setter("result_type", 'DatabaseLevelOutput')
        _setter("started_on", started_on)

    @property
    @pulumi.getter(name="appliedChanges")
    def applied_changes(self) -> float:
        """
        Number of applied changes
        """
        return pulumi.get(self, "applied_changes")

    @property
    @pulumi.getter(name="cdcDeleteCounter")
    def cdc_delete_counter(self) -> float:
        """
        Number of cdc deletes
        """
        return pulumi.get(self, "cdc_delete_counter")

    @property
    @pulumi.getter(name="cdcInsertCounter")
    def cdc_insert_counter(self) -> float:
        """
        Number of cdc inserts
        """
        return pulumi.get(self, "cdc_insert_counter")

    @property
    @pulumi.getter(name="cdcUpdateCounter")
    def cdc_update_counter(self) -> float:
        """
        Number of cdc updates
        """
        return pulumi.get(self, "cdc_update_counter")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="fullLoadCompletedTables")
    def full_load_completed_tables(self) -> float:
        """
        Number of tables completed in full load
        """
        return pulumi.get(self, "full_load_completed_tables")

    @property
    @pulumi.getter(name="fullLoadErroredTables")
    def full_load_errored_tables(self) -> float:
        """
        Number of tables errored in full load
        """
        return pulumi.get(self, "full_load_errored_tables")

    @property
    @pulumi.getter(name="fullLoadLoadingTables")
    def full_load_loading_tables(self) -> float:
        """
        Number of tables loading in full load
        """
        return pulumi.get(self, "full_load_loading_tables")

    @property
    @pulumi.getter(name="fullLoadQueuedTables")
    def full_load_queued_tables(self) -> float:
        """
        Number of tables queued in full load
        """
        return pulumi.get(self, "full_load_queued_tables")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="incomingChanges")
    def incoming_changes(self) -> float:
        """
        Number of incoming changes
        """
        return pulumi.get(self, "incoming_changes")

    @property
    @pulumi.getter(name="initializationCompleted")
    def initialization_completed(self) -> bool:
        """
        Indicates if initial load (full load) has been completed
        """
        return pulumi.get(self, "initialization_completed")

    @property
    @pulumi.getter
    def latency(self) -> float:
        """
        CDC apply latency
        """
        return pulumi.get(self, "latency")

    @property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> str:
        """
        Migration state that this database is in
        """
        return pulumi.get(self, "migration_state")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")


@pulumi.output_type
class MigrateOracleAzureDbPostgreSqlSyncTaskOutputErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateOracleAzureDbPostgreSqlSyncTaskOutputErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.ReportableExceptionResponse',
                 id: str,
                 result_type: str):
        """
        :param 'ReportableExceptionResponse' error: Migration error
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'ErrorOutput'.
        """
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            id=id,
            result_type=result_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional['outputs.ReportableExceptionResponse'] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error is None:
            raise TypeError("Missing 'error' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")

        _setter("error", error)
        _setter("id", id)
        _setter("result_type", 'ErrorOutput')

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ReportableExceptionResponse':
        """
        Migration error
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'ErrorOutput'.
        """
        return pulumi.get(self, "result_type")


@pulumi.output_type
class MigrateOracleAzureDbPostgreSqlSyncTaskOutputMigrationLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceServer":
            suggest = "source_server"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetServer":
            suggest = "target_server"
        elif key == "targetServerVersion":
            suggest = "target_server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateOracleAzureDbPostgreSqlSyncTaskOutputMigrationLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 id: str,
                 result_type: str,
                 source_server: str,
                 source_server_version: str,
                 started_on: str,
                 target_server: str,
                 target_server_version: str):
        """
        :param str ended_on: Migration end time
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'MigrationLevelOutput'.
        :param str source_server: Source server name
        :param str source_server_version: Source server version
        :param str started_on: Migration start time
        :param str target_server: Target server name
        :param str target_server_version: Target server version
        """
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputMigrationLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            id=id,
            result_type=result_type,
            source_server=source_server,
            source_server_version=source_server_version,
            started_on=started_on,
            target_server=target_server,
            target_server_version=target_server_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             source_server: Optional[str] = None,
             source_server_version: Optional[str] = None,
             started_on: Optional[str] = None,
             target_server: Optional[str] = None,
             target_server_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_server is None and 'sourceServer' in kwargs:
            source_server = kwargs['sourceServer']
        if source_server is None:
            raise TypeError("Missing 'source_server' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if target_server is None and 'targetServer' in kwargs:
            target_server = kwargs['targetServer']
        if target_server is None:
            raise TypeError("Missing 'target_server' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")

        _setter("ended_on", ended_on)
        _setter("id", id)
        _setter("result_type", 'MigrationLevelOutput')
        _setter("source_server", source_server)
        _setter("source_server_version", source_server_version)
        _setter("started_on", started_on)
        _setter("target_server", target_server)
        _setter("target_server_version", target_server_version)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceServer")
    def source_server(self) -> str:
        """
        Source server name
        """
        return pulumi.get(self, "source_server")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter(name="targetServer")
    def target_server(self) -> str:
        """
        Target server name
        """
        return pulumi.get(self, "target_server")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")


@pulumi.output_type
class MigrateOracleAzureDbPostgreSqlSyncTaskOutputTableLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdcDeleteCounter":
            suggest = "cdc_delete_counter"
        elif key == "cdcInsertCounter":
            suggest = "cdc_insert_counter"
        elif key == "cdcUpdateCounter":
            suggest = "cdc_update_counter"
        elif key == "dataErrorsCounter":
            suggest = "data_errors_counter"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "fullLoadEndedOn":
            suggest = "full_load_ended_on"
        elif key == "fullLoadEstFinishTime":
            suggest = "full_load_est_finish_time"
        elif key == "fullLoadStartedOn":
            suggest = "full_load_started_on"
        elif key == "fullLoadTotalRows":
            suggest = "full_load_total_rows"
        elif key == "lastModifiedTime":
            suggest = "last_modified_time"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "totalChangesApplied":
            suggest = "total_changes_applied"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateOracleAzureDbPostgreSqlSyncTaskOutputTableLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputTableLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputTableLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdc_delete_counter: float,
                 cdc_insert_counter: float,
                 cdc_update_counter: float,
                 data_errors_counter: float,
                 database_name: str,
                 full_load_ended_on: str,
                 full_load_est_finish_time: str,
                 full_load_started_on: str,
                 full_load_total_rows: float,
                 id: str,
                 last_modified_time: str,
                 result_type: str,
                 state: str,
                 table_name: str,
                 total_changes_applied: float):
        """
        :param float cdc_delete_counter: Number of applied deletes
        :param float cdc_insert_counter: Number of applied inserts
        :param float cdc_update_counter: Number of applied updates
        :param float data_errors_counter: Number of data errors occurred
        :param str database_name: Name of the database
        :param str full_load_ended_on: Full load end time
        :param str full_load_est_finish_time: Estimate to finish full load
        :param str full_load_started_on: Full load start time
        :param float full_load_total_rows: Number of rows applied in full load
        :param str id: Result identifier
        :param str last_modified_time: Last modified time on target
        :param str result_type: Result type
               Expected value is 'TableLevelOutput'.
        :param str state: Current state of the table migration
        :param str table_name: Name of the table
        :param float total_changes_applied: Total number of applied changes
        """
        MigrateOracleAzureDbPostgreSqlSyncTaskOutputTableLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cdc_delete_counter=cdc_delete_counter,
            cdc_insert_counter=cdc_insert_counter,
            cdc_update_counter=cdc_update_counter,
            data_errors_counter=data_errors_counter,
            database_name=database_name,
            full_load_ended_on=full_load_ended_on,
            full_load_est_finish_time=full_load_est_finish_time,
            full_load_started_on=full_load_started_on,
            full_load_total_rows=full_load_total_rows,
            id=id,
            last_modified_time=last_modified_time,
            result_type=result_type,
            state=state,
            table_name=table_name,
            total_changes_applied=total_changes_applied,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cdc_delete_counter: Optional[float] = None,
             cdc_insert_counter: Optional[float] = None,
             cdc_update_counter: Optional[float] = None,
             data_errors_counter: Optional[float] = None,
             database_name: Optional[str] = None,
             full_load_ended_on: Optional[str] = None,
             full_load_est_finish_time: Optional[str] = None,
             full_load_started_on: Optional[str] = None,
             full_load_total_rows: Optional[float] = None,
             id: Optional[str] = None,
             last_modified_time: Optional[str] = None,
             result_type: Optional[str] = None,
             state: Optional[str] = None,
             table_name: Optional[str] = None,
             total_changes_applied: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cdc_delete_counter is None and 'cdcDeleteCounter' in kwargs:
            cdc_delete_counter = kwargs['cdcDeleteCounter']
        if cdc_delete_counter is None:
            raise TypeError("Missing 'cdc_delete_counter' argument")
        if cdc_insert_counter is None and 'cdcInsertCounter' in kwargs:
            cdc_insert_counter = kwargs['cdcInsertCounter']
        if cdc_insert_counter is None:
            raise TypeError("Missing 'cdc_insert_counter' argument")
        if cdc_update_counter is None and 'cdcUpdateCounter' in kwargs:
            cdc_update_counter = kwargs['cdcUpdateCounter']
        if cdc_update_counter is None:
            raise TypeError("Missing 'cdc_update_counter' argument")
        if data_errors_counter is None and 'dataErrorsCounter' in kwargs:
            data_errors_counter = kwargs['dataErrorsCounter']
        if data_errors_counter is None:
            raise TypeError("Missing 'data_errors_counter' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if full_load_ended_on is None and 'fullLoadEndedOn' in kwargs:
            full_load_ended_on = kwargs['fullLoadEndedOn']
        if full_load_ended_on is None:
            raise TypeError("Missing 'full_load_ended_on' argument")
        if full_load_est_finish_time is None and 'fullLoadEstFinishTime' in kwargs:
            full_load_est_finish_time = kwargs['fullLoadEstFinishTime']
        if full_load_est_finish_time is None:
            raise TypeError("Missing 'full_load_est_finish_time' argument")
        if full_load_started_on is None and 'fullLoadStartedOn' in kwargs:
            full_load_started_on = kwargs['fullLoadStartedOn']
        if full_load_started_on is None:
            raise TypeError("Missing 'full_load_started_on' argument")
        if full_load_total_rows is None and 'fullLoadTotalRows' in kwargs:
            full_load_total_rows = kwargs['fullLoadTotalRows']
        if full_load_total_rows is None:
            raise TypeError("Missing 'full_load_total_rows' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if last_modified_time is None and 'lastModifiedTime' in kwargs:
            last_modified_time = kwargs['lastModifiedTime']
        if last_modified_time is None:
            raise TypeError("Missing 'last_modified_time' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if total_changes_applied is None and 'totalChangesApplied' in kwargs:
            total_changes_applied = kwargs['totalChangesApplied']
        if total_changes_applied is None:
            raise TypeError("Missing 'total_changes_applied' argument")

        _setter("cdc_delete_counter", cdc_delete_counter)
        _setter("cdc_insert_counter", cdc_insert_counter)
        _setter("cdc_update_counter", cdc_update_counter)
        _setter("data_errors_counter", data_errors_counter)
        _setter("database_name", database_name)
        _setter("full_load_ended_on", full_load_ended_on)
        _setter("full_load_est_finish_time", full_load_est_finish_time)
        _setter("full_load_started_on", full_load_started_on)
        _setter("full_load_total_rows", full_load_total_rows)
        _setter("id", id)
        _setter("last_modified_time", last_modified_time)
        _setter("result_type", 'TableLevelOutput')
        _setter("state", state)
        _setter("table_name", table_name)
        _setter("total_changes_applied", total_changes_applied)

    @property
    @pulumi.getter(name="cdcDeleteCounter")
    def cdc_delete_counter(self) -> float:
        """
        Number of applied deletes
        """
        return pulumi.get(self, "cdc_delete_counter")

    @property
    @pulumi.getter(name="cdcInsertCounter")
    def cdc_insert_counter(self) -> float:
        """
        Number of applied inserts
        """
        return pulumi.get(self, "cdc_insert_counter")

    @property
    @pulumi.getter(name="cdcUpdateCounter")
    def cdc_update_counter(self) -> float:
        """
        Number of applied updates
        """
        return pulumi.get(self, "cdc_update_counter")

    @property
    @pulumi.getter(name="dataErrorsCounter")
    def data_errors_counter(self) -> float:
        """
        Number of data errors occurred
        """
        return pulumi.get(self, "data_errors_counter")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="fullLoadEndedOn")
    def full_load_ended_on(self) -> str:
        """
        Full load end time
        """
        return pulumi.get(self, "full_load_ended_on")

    @property
    @pulumi.getter(name="fullLoadEstFinishTime")
    def full_load_est_finish_time(self) -> str:
        """
        Estimate to finish full load
        """
        return pulumi.get(self, "full_load_est_finish_time")

    @property
    @pulumi.getter(name="fullLoadStartedOn")
    def full_load_started_on(self) -> str:
        """
        Full load start time
        """
        return pulumi.get(self, "full_load_started_on")

    @property
    @pulumi.getter(name="fullLoadTotalRows")
    def full_load_total_rows(self) -> float:
        """
        Number of rows applied in full load
        """
        return pulumi.get(self, "full_load_total_rows")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> str:
        """
        Last modified time on target
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'TableLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the table migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        Name of the table
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="totalChangesApplied")
    def total_changes_applied(self) -> float:
        """
        Total number of applied changes
        """
        return pulumi.get(self, "total_changes_applied")


@pulumi.output_type
class MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse(dict):
    """
    Database specific information for PostgreSQL to Azure Database for PostgreSQL migration task inputs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "migrationSetting":
            suggest = "migration_setting"
        elif key == "selectedTables":
            suggest = "selected_tables"
        elif key == "sourceSetting":
            suggest = "source_setting"
        elif key == "targetDatabaseName":
            suggest = "target_database_name"
        elif key == "targetSetting":
            suggest = "target_setting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 migration_setting: Optional[Any] = None,
                 name: Optional[str] = None,
                 selected_tables: Optional[Sequence['outputs.MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseTableInputResponse']] = None,
                 source_setting: Optional[Mapping[str, str]] = None,
                 target_database_name: Optional[str] = None,
                 target_setting: Optional[Mapping[str, str]] = None):
        """
        Database specific information for PostgreSQL to Azure Database for PostgreSQL migration task inputs
        :param str id: Result identifier
        :param Any migration_setting: Migration settings which tune the migration behavior
        :param str name: Name of the database
        :param Sequence['MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseTableInputResponse'] selected_tables: Tables selected for migration
        :param Mapping[str, str] source_setting: Source settings to tune source endpoint migration behavior
        :param str target_database_name: Name of target database. Note: Target database will be truncated before starting migration.
        :param Mapping[str, str] target_setting: Target settings to tune target endpoint migration behavior
        """
        MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            migration_setting=migration_setting,
            name=name,
            selected_tables=selected_tables,
            source_setting=source_setting,
            target_database_name=target_database_name,
            target_setting=target_setting,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             migration_setting: Optional[Any] = None,
             name: Optional[str] = None,
             selected_tables: Optional[Sequence['outputs.MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseTableInputResponse']] = None,
             source_setting: Optional[Mapping[str, str]] = None,
             target_database_name: Optional[str] = None,
             target_setting: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if migration_setting is None and 'migrationSetting' in kwargs:
            migration_setting = kwargs['migrationSetting']
        if selected_tables is None and 'selectedTables' in kwargs:
            selected_tables = kwargs['selectedTables']
        if source_setting is None and 'sourceSetting' in kwargs:
            source_setting = kwargs['sourceSetting']
        if target_database_name is None and 'targetDatabaseName' in kwargs:
            target_database_name = kwargs['targetDatabaseName']
        if target_setting is None and 'targetSetting' in kwargs:
            target_setting = kwargs['targetSetting']

        _setter("id", id)
        if migration_setting is not None:
            _setter("migration_setting", migration_setting)
        if name is not None:
            _setter("name", name)
        if selected_tables is not None:
            _setter("selected_tables", selected_tables)
        if source_setting is not None:
            _setter("source_setting", source_setting)
        if target_database_name is not None:
            _setter("target_database_name", target_database_name)
        if target_setting is not None:
            _setter("target_setting", target_setting)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="migrationSetting")
    def migration_setting(self) -> Optional[Any]:
        """
        Migration settings which tune the migration behavior
        """
        return pulumi.get(self, "migration_setting")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="selectedTables")
    def selected_tables(self) -> Optional[Sequence['outputs.MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseTableInputResponse']]:
        """
        Tables selected for migration
        """
        return pulumi.get(self, "selected_tables")

    @property
    @pulumi.getter(name="sourceSetting")
    def source_setting(self) -> Optional[Mapping[str, str]]:
        """
        Source settings to tune source endpoint migration behavior
        """
        return pulumi.get(self, "source_setting")

    @property
    @pulumi.getter(name="targetDatabaseName")
    def target_database_name(self) -> Optional[str]:
        """
        Name of target database. Note: Target database will be truncated before starting migration.
        """
        return pulumi.get(self, "target_database_name")

    @property
    @pulumi.getter(name="targetSetting")
    def target_setting(self) -> Optional[Mapping[str, str]]:
        """
        Target settings to tune target endpoint migration behavior
        """
        return pulumi.get(self, "target_setting")


@pulumi.output_type
class MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseTableInputResponse(dict):
    """
    Selected tables for the migration
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        Selected tables for the migration
        :param str name: Name of the table to migrate
        """
        MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseTableInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the table to migrate
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse(dict):
    """
    Input for the task that migrates PostgreSQL databases to Azure Database for PostgreSQL for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "encryptedKeyForSecureFields":
            suggest = "encrypted_key_for_secure_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_databases: Sequence['outputs.MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse'],
                 source_connection_info: 'outputs.PostgreSqlConnectionInfoResponse',
                 started_on: str,
                 target_connection_info: 'outputs.PostgreSqlConnectionInfoResponse',
                 encrypted_key_for_secure_fields: Optional[str] = None):
        """
        Input for the task that migrates PostgreSQL databases to Azure Database for PostgreSQL for online migrations
        :param Sequence['MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'PostgreSqlConnectionInfoResponse' source_connection_info: Connection information for source PostgreSQL
        :param str started_on: Migration start time
        :param 'PostgreSqlConnectionInfoResponse' target_connection_info: Connection information for target Azure Database for PostgreSQL
        :param str encrypted_key_for_secure_fields: encrypted key for secure fields
        """
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            started_on=started_on,
            target_connection_info=target_connection_info,
            encrypted_key_for_secure_fields=encrypted_key_for_secure_fields,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_databases: Optional[Sequence['outputs.MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.PostgreSqlConnectionInfoResponse'] = None,
             started_on: Optional[str] = None,
             target_connection_info: Optional['outputs.PostgreSqlConnectionInfoResponse'] = None,
             encrypted_key_for_secure_fields: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if encrypted_key_for_secure_fields is None and 'encryptedKeyForSecureFields' in kwargs:
            encrypted_key_for_secure_fields = kwargs['encryptedKeyForSecureFields']

        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("started_on", started_on)
        _setter("target_connection_info", target_connection_info)
        if encrypted_key_for_secure_fields is not None:
            _setter("encrypted_key_for_secure_fields", encrypted_key_for_secure_fields)

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigratePostgreSqlAzureDbForPostgreSqlSyncDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.PostgreSqlConnectionInfoResponse':
        """
        Connection information for source PostgreSQL
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.PostgreSqlConnectionInfoResponse':
        """
        Connection information for target Azure Database for PostgreSQL
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="encryptedKeyForSecureFields")
    def encrypted_key_for_secure_fields(self) -> Optional[str]:
        """
        encrypted key for secure fields
        """
        return pulumi.get(self, "encrypted_key_for_secure_fields")


@pulumi.output_type
class MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"
        elif key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 result_type: str,
                 error_message: Optional[str] = None,
                 events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None):
        """
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'DatabaseLevelErrorOutput'.
        :param str error_message: Error message
        :param Sequence['SyncMigrationDatabaseErrorEventResponse'] events: List of error events.
        """
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            result_type=result_type,
            error_message=error_message,
            events=events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             error_message: Optional[str] = None,
             events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']

        _setter("id", id)
        _setter("result_type", 'DatabaseLevelErrorOutput')
        if error_message is not None:
            _setter("error_message", error_message)
        if events is not None:
            _setter("events", events)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelErrorOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        Error message
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']]:
        """
        List of error events.
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedChanges":
            suggest = "applied_changes"
        elif key == "cdcDeleteCounter":
            suggest = "cdc_delete_counter"
        elif key == "cdcInsertCounter":
            suggest = "cdc_insert_counter"
        elif key == "cdcUpdateCounter":
            suggest = "cdc_update_counter"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "fullLoadCompletedTables":
            suggest = "full_load_completed_tables"
        elif key == "fullLoadErroredTables":
            suggest = "full_load_errored_tables"
        elif key == "fullLoadLoadingTables":
            suggest = "full_load_loading_tables"
        elif key == "fullLoadQueuedTables":
            suggest = "full_load_queued_tables"
        elif key == "incomingChanges":
            suggest = "incoming_changes"
        elif key == "initializationCompleted":
            suggest = "initialization_completed"
        elif key == "migrationState":
            suggest = "migration_state"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applied_changes: float,
                 cdc_delete_counter: float,
                 cdc_insert_counter: float,
                 cdc_update_counter: float,
                 database_name: str,
                 ended_on: str,
                 full_load_completed_tables: float,
                 full_load_errored_tables: float,
                 full_load_loading_tables: float,
                 full_load_queued_tables: float,
                 id: str,
                 incoming_changes: float,
                 initialization_completed: bool,
                 latency: float,
                 migration_state: str,
                 result_type: str,
                 started_on: str):
        """
        :param float applied_changes: Number of applied changes
        :param float cdc_delete_counter: Number of cdc deletes
        :param float cdc_insert_counter: Number of cdc inserts
        :param float cdc_update_counter: Number of cdc updates
        :param str database_name: Name of the database
        :param str ended_on: Migration end time
        :param float full_load_completed_tables: Number of tables completed in full load
        :param float full_load_errored_tables: Number of tables errored in full load
        :param float full_load_loading_tables: Number of tables loading in full load
        :param float full_load_queued_tables: Number of tables queued in full load
        :param str id: Result identifier
        :param float incoming_changes: Number of incoming changes
        :param bool initialization_completed: Indicates if initial load (full load) has been completed
        :param float latency: CDC apply latency
        :param str migration_state: Migration state that this database is in
        :param str result_type: Result type
               Expected value is 'DatabaseLevelOutput'.
        :param str started_on: Migration start time
        """
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            applied_changes=applied_changes,
            cdc_delete_counter=cdc_delete_counter,
            cdc_insert_counter=cdc_insert_counter,
            cdc_update_counter=cdc_update_counter,
            database_name=database_name,
            ended_on=ended_on,
            full_load_completed_tables=full_load_completed_tables,
            full_load_errored_tables=full_load_errored_tables,
            full_load_loading_tables=full_load_loading_tables,
            full_load_queued_tables=full_load_queued_tables,
            id=id,
            incoming_changes=incoming_changes,
            initialization_completed=initialization_completed,
            latency=latency,
            migration_state=migration_state,
            result_type=result_type,
            started_on=started_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             applied_changes: Optional[float] = None,
             cdc_delete_counter: Optional[float] = None,
             cdc_insert_counter: Optional[float] = None,
             cdc_update_counter: Optional[float] = None,
             database_name: Optional[str] = None,
             ended_on: Optional[str] = None,
             full_load_completed_tables: Optional[float] = None,
             full_load_errored_tables: Optional[float] = None,
             full_load_loading_tables: Optional[float] = None,
             full_load_queued_tables: Optional[float] = None,
             id: Optional[str] = None,
             incoming_changes: Optional[float] = None,
             initialization_completed: Optional[bool] = None,
             latency: Optional[float] = None,
             migration_state: Optional[str] = None,
             result_type: Optional[str] = None,
             started_on: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if applied_changes is None and 'appliedChanges' in kwargs:
            applied_changes = kwargs['appliedChanges']
        if applied_changes is None:
            raise TypeError("Missing 'applied_changes' argument")
        if cdc_delete_counter is None and 'cdcDeleteCounter' in kwargs:
            cdc_delete_counter = kwargs['cdcDeleteCounter']
        if cdc_delete_counter is None:
            raise TypeError("Missing 'cdc_delete_counter' argument")
        if cdc_insert_counter is None and 'cdcInsertCounter' in kwargs:
            cdc_insert_counter = kwargs['cdcInsertCounter']
        if cdc_insert_counter is None:
            raise TypeError("Missing 'cdc_insert_counter' argument")
        if cdc_update_counter is None and 'cdcUpdateCounter' in kwargs:
            cdc_update_counter = kwargs['cdcUpdateCounter']
        if cdc_update_counter is None:
            raise TypeError("Missing 'cdc_update_counter' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if full_load_completed_tables is None and 'fullLoadCompletedTables' in kwargs:
            full_load_completed_tables = kwargs['fullLoadCompletedTables']
        if full_load_completed_tables is None:
            raise TypeError("Missing 'full_load_completed_tables' argument")
        if full_load_errored_tables is None and 'fullLoadErroredTables' in kwargs:
            full_load_errored_tables = kwargs['fullLoadErroredTables']
        if full_load_errored_tables is None:
            raise TypeError("Missing 'full_load_errored_tables' argument")
        if full_load_loading_tables is None and 'fullLoadLoadingTables' in kwargs:
            full_load_loading_tables = kwargs['fullLoadLoadingTables']
        if full_load_loading_tables is None:
            raise TypeError("Missing 'full_load_loading_tables' argument")
        if full_load_queued_tables is None and 'fullLoadQueuedTables' in kwargs:
            full_load_queued_tables = kwargs['fullLoadQueuedTables']
        if full_load_queued_tables is None:
            raise TypeError("Missing 'full_load_queued_tables' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if incoming_changes is None and 'incomingChanges' in kwargs:
            incoming_changes = kwargs['incomingChanges']
        if incoming_changes is None:
            raise TypeError("Missing 'incoming_changes' argument")
        if initialization_completed is None and 'initializationCompleted' in kwargs:
            initialization_completed = kwargs['initializationCompleted']
        if initialization_completed is None:
            raise TypeError("Missing 'initialization_completed' argument")
        if latency is None:
            raise TypeError("Missing 'latency' argument")
        if migration_state is None and 'migrationState' in kwargs:
            migration_state = kwargs['migrationState']
        if migration_state is None:
            raise TypeError("Missing 'migration_state' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")

        _setter("applied_changes", applied_changes)
        _setter("cdc_delete_counter", cdc_delete_counter)
        _setter("cdc_insert_counter", cdc_insert_counter)
        _setter("cdc_update_counter", cdc_update_counter)
        _setter("database_name", database_name)
        _setter("ended_on", ended_on)
        _setter("full_load_completed_tables", full_load_completed_tables)
        _setter("full_load_errored_tables", full_load_errored_tables)
        _setter("full_load_loading_tables", full_load_loading_tables)
        _setter("full_load_queued_tables", full_load_queued_tables)
        _setter("id", id)
        _setter("incoming_changes", incoming_changes)
        _setter("initialization_completed", initialization_completed)
        _setter("latency", latency)
        _setter("migration_state", migration_state)
        _setter("result_type", 'DatabaseLevelOutput')
        _setter("started_on", started_on)

    @property
    @pulumi.getter(name="appliedChanges")
    def applied_changes(self) -> float:
        """
        Number of applied changes
        """
        return pulumi.get(self, "applied_changes")

    @property
    @pulumi.getter(name="cdcDeleteCounter")
    def cdc_delete_counter(self) -> float:
        """
        Number of cdc deletes
        """
        return pulumi.get(self, "cdc_delete_counter")

    @property
    @pulumi.getter(name="cdcInsertCounter")
    def cdc_insert_counter(self) -> float:
        """
        Number of cdc inserts
        """
        return pulumi.get(self, "cdc_insert_counter")

    @property
    @pulumi.getter(name="cdcUpdateCounter")
    def cdc_update_counter(self) -> float:
        """
        Number of cdc updates
        """
        return pulumi.get(self, "cdc_update_counter")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="fullLoadCompletedTables")
    def full_load_completed_tables(self) -> float:
        """
        Number of tables completed in full load
        """
        return pulumi.get(self, "full_load_completed_tables")

    @property
    @pulumi.getter(name="fullLoadErroredTables")
    def full_load_errored_tables(self) -> float:
        """
        Number of tables errored in full load
        """
        return pulumi.get(self, "full_load_errored_tables")

    @property
    @pulumi.getter(name="fullLoadLoadingTables")
    def full_load_loading_tables(self) -> float:
        """
        Number of tables loading in full load
        """
        return pulumi.get(self, "full_load_loading_tables")

    @property
    @pulumi.getter(name="fullLoadQueuedTables")
    def full_load_queued_tables(self) -> float:
        """
        Number of tables queued in full load
        """
        return pulumi.get(self, "full_load_queued_tables")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="incomingChanges")
    def incoming_changes(self) -> float:
        """
        Number of incoming changes
        """
        return pulumi.get(self, "incoming_changes")

    @property
    @pulumi.getter(name="initializationCompleted")
    def initialization_completed(self) -> bool:
        """
        Indicates if initial load (full load) has been completed
        """
        return pulumi.get(self, "initialization_completed")

    @property
    @pulumi.getter
    def latency(self) -> float:
        """
        CDC apply latency
        """
        return pulumi.get(self, "latency")

    @property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> str:
        """
        Migration state that this database is in
        """
        return pulumi.get(self, "migration_state")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")


@pulumi.output_type
class MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.ReportableExceptionResponse',
                 id: str,
                 result_type: str,
                 events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None):
        """
        :param 'ReportableExceptionResponse' error: Migration error
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'ErrorOutput'.
        :param Sequence['SyncMigrationDatabaseErrorEventResponse'] events: List of error events
        """
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            id=id,
            result_type=result_type,
            events=events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional['outputs.ReportableExceptionResponse'] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error is None:
            raise TypeError("Missing 'error' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")

        _setter("error", error)
        _setter("id", id)
        _setter("result_type", 'ErrorOutput')
        if events is not None:
            _setter("events", events)

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ReportableExceptionResponse':
        """
        Migration error
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'ErrorOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']]:
        """
        List of error events
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputMigrationLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceServer":
            suggest = "source_server"
        elif key == "sourceServerType":
            suggest = "source_server_type"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetServer":
            suggest = "target_server"
        elif key == "targetServerType":
            suggest = "target_server_type"
        elif key == "targetServerVersion":
            suggest = "target_server_version"
        elif key == "databaseCount":
            suggest = "database_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputMigrationLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 id: str,
                 result_type: str,
                 source_server: str,
                 source_server_type: str,
                 source_server_version: str,
                 started_on: str,
                 state: str,
                 target_server: str,
                 target_server_type: str,
                 target_server_version: str,
                 database_count: Optional[float] = None):
        """
        :param str ended_on: Migration end time
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'MigrationLevelOutput'.
        :param str source_server: Source server name
        :param str source_server_type: Source server type.
        :param str source_server_version: Source server version
        :param str started_on: Migration start time
        :param str state: Migration status
        :param str target_server: Target server name
        :param str target_server_type: Target server type.
        :param str target_server_version: Target server version
        :param float database_count: Number of databases to include
        """
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputMigrationLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            id=id,
            result_type=result_type,
            source_server=source_server,
            source_server_type=source_server_type,
            source_server_version=source_server_version,
            started_on=started_on,
            state=state,
            target_server=target_server,
            target_server_type=target_server_type,
            target_server_version=target_server_version,
            database_count=database_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             source_server: Optional[str] = None,
             source_server_type: Optional[str] = None,
             source_server_version: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             target_server: Optional[str] = None,
             target_server_type: Optional[str] = None,
             target_server_version: Optional[str] = None,
             database_count: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_server is None and 'sourceServer' in kwargs:
            source_server = kwargs['sourceServer']
        if source_server is None:
            raise TypeError("Missing 'source_server' argument")
        if source_server_type is None and 'sourceServerType' in kwargs:
            source_server_type = kwargs['sourceServerType']
        if source_server_type is None:
            raise TypeError("Missing 'source_server_type' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if target_server is None and 'targetServer' in kwargs:
            target_server = kwargs['targetServer']
        if target_server is None:
            raise TypeError("Missing 'target_server' argument")
        if target_server_type is None and 'targetServerType' in kwargs:
            target_server_type = kwargs['targetServerType']
        if target_server_type is None:
            raise TypeError("Missing 'target_server_type' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")
        if database_count is None and 'databaseCount' in kwargs:
            database_count = kwargs['databaseCount']

        _setter("ended_on", ended_on)
        _setter("id", id)
        _setter("result_type", 'MigrationLevelOutput')
        _setter("source_server", source_server)
        _setter("source_server_type", source_server_type)
        _setter("source_server_version", source_server_version)
        _setter("started_on", started_on)
        _setter("state", state)
        _setter("target_server", target_server)
        _setter("target_server_type", target_server_type)
        _setter("target_server_version", target_server_version)
        if database_count is not None:
            _setter("database_count", database_count)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceServer")
    def source_server(self) -> str:
        """
        Source server name
        """
        return pulumi.get(self, "source_server")

    @property
    @pulumi.getter(name="sourceServerType")
    def source_server_type(self) -> str:
        """
        Source server type.
        """
        return pulumi.get(self, "source_server_type")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Migration status
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetServer")
    def target_server(self) -> str:
        """
        Target server name
        """
        return pulumi.get(self, "target_server")

    @property
    @pulumi.getter(name="targetServerType")
    def target_server_type(self) -> str:
        """
        Target server type.
        """
        return pulumi.get(self, "target_server_type")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")

    @property
    @pulumi.getter(name="databaseCount")
    def database_count(self) -> Optional[float]:
        """
        Number of databases to include
        """
        return pulumi.get(self, "database_count")


@pulumi.output_type
class MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputTableLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdcDeleteCounter":
            suggest = "cdc_delete_counter"
        elif key == "cdcInsertCounter":
            suggest = "cdc_insert_counter"
        elif key == "cdcUpdateCounter":
            suggest = "cdc_update_counter"
        elif key == "dataErrorsCounter":
            suggest = "data_errors_counter"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "fullLoadEndedOn":
            suggest = "full_load_ended_on"
        elif key == "fullLoadEstFinishTime":
            suggest = "full_load_est_finish_time"
        elif key == "fullLoadStartedOn":
            suggest = "full_load_started_on"
        elif key == "fullLoadTotalRows":
            suggest = "full_load_total_rows"
        elif key == "lastModifiedTime":
            suggest = "last_modified_time"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "totalChangesApplied":
            suggest = "total_changes_applied"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputTableLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputTableLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputTableLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdc_delete_counter: float,
                 cdc_insert_counter: float,
                 cdc_update_counter: float,
                 data_errors_counter: float,
                 database_name: str,
                 full_load_ended_on: str,
                 full_load_est_finish_time: str,
                 full_load_started_on: str,
                 full_load_total_rows: float,
                 id: str,
                 last_modified_time: str,
                 result_type: str,
                 state: str,
                 table_name: str,
                 total_changes_applied: float):
        """
        :param float cdc_delete_counter: Number of applied deletes
        :param float cdc_insert_counter: Number of applied inserts
        :param float cdc_update_counter: Number of applied updates
        :param float data_errors_counter: Number of data errors occurred
        :param str database_name: Name of the database
        :param str full_load_ended_on: Full load end time
        :param str full_load_est_finish_time: Estimate to finish full load
        :param str full_load_started_on: Full load start time
        :param float full_load_total_rows: Number of rows applied in full load
        :param str id: Result identifier
        :param str last_modified_time: Last modified time on target
        :param str result_type: Result type
               Expected value is 'TableLevelOutput'.
        :param str state: Current state of the table migration
        :param str table_name: Name of the table
        :param float total_changes_applied: Total number of applied changes
        """
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputTableLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cdc_delete_counter=cdc_delete_counter,
            cdc_insert_counter=cdc_insert_counter,
            cdc_update_counter=cdc_update_counter,
            data_errors_counter=data_errors_counter,
            database_name=database_name,
            full_load_ended_on=full_load_ended_on,
            full_load_est_finish_time=full_load_est_finish_time,
            full_load_started_on=full_load_started_on,
            full_load_total_rows=full_load_total_rows,
            id=id,
            last_modified_time=last_modified_time,
            result_type=result_type,
            state=state,
            table_name=table_name,
            total_changes_applied=total_changes_applied,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cdc_delete_counter: Optional[float] = None,
             cdc_insert_counter: Optional[float] = None,
             cdc_update_counter: Optional[float] = None,
             data_errors_counter: Optional[float] = None,
             database_name: Optional[str] = None,
             full_load_ended_on: Optional[str] = None,
             full_load_est_finish_time: Optional[str] = None,
             full_load_started_on: Optional[str] = None,
             full_load_total_rows: Optional[float] = None,
             id: Optional[str] = None,
             last_modified_time: Optional[str] = None,
             result_type: Optional[str] = None,
             state: Optional[str] = None,
             table_name: Optional[str] = None,
             total_changes_applied: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cdc_delete_counter is None and 'cdcDeleteCounter' in kwargs:
            cdc_delete_counter = kwargs['cdcDeleteCounter']
        if cdc_delete_counter is None:
            raise TypeError("Missing 'cdc_delete_counter' argument")
        if cdc_insert_counter is None and 'cdcInsertCounter' in kwargs:
            cdc_insert_counter = kwargs['cdcInsertCounter']
        if cdc_insert_counter is None:
            raise TypeError("Missing 'cdc_insert_counter' argument")
        if cdc_update_counter is None and 'cdcUpdateCounter' in kwargs:
            cdc_update_counter = kwargs['cdcUpdateCounter']
        if cdc_update_counter is None:
            raise TypeError("Missing 'cdc_update_counter' argument")
        if data_errors_counter is None and 'dataErrorsCounter' in kwargs:
            data_errors_counter = kwargs['dataErrorsCounter']
        if data_errors_counter is None:
            raise TypeError("Missing 'data_errors_counter' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if full_load_ended_on is None and 'fullLoadEndedOn' in kwargs:
            full_load_ended_on = kwargs['fullLoadEndedOn']
        if full_load_ended_on is None:
            raise TypeError("Missing 'full_load_ended_on' argument")
        if full_load_est_finish_time is None and 'fullLoadEstFinishTime' in kwargs:
            full_load_est_finish_time = kwargs['fullLoadEstFinishTime']
        if full_load_est_finish_time is None:
            raise TypeError("Missing 'full_load_est_finish_time' argument")
        if full_load_started_on is None and 'fullLoadStartedOn' in kwargs:
            full_load_started_on = kwargs['fullLoadStartedOn']
        if full_load_started_on is None:
            raise TypeError("Missing 'full_load_started_on' argument")
        if full_load_total_rows is None and 'fullLoadTotalRows' in kwargs:
            full_load_total_rows = kwargs['fullLoadTotalRows']
        if full_load_total_rows is None:
            raise TypeError("Missing 'full_load_total_rows' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if last_modified_time is None and 'lastModifiedTime' in kwargs:
            last_modified_time = kwargs['lastModifiedTime']
        if last_modified_time is None:
            raise TypeError("Missing 'last_modified_time' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if total_changes_applied is None and 'totalChangesApplied' in kwargs:
            total_changes_applied = kwargs['totalChangesApplied']
        if total_changes_applied is None:
            raise TypeError("Missing 'total_changes_applied' argument")

        _setter("cdc_delete_counter", cdc_delete_counter)
        _setter("cdc_insert_counter", cdc_insert_counter)
        _setter("cdc_update_counter", cdc_update_counter)
        _setter("data_errors_counter", data_errors_counter)
        _setter("database_name", database_name)
        _setter("full_load_ended_on", full_load_ended_on)
        _setter("full_load_est_finish_time", full_load_est_finish_time)
        _setter("full_load_started_on", full_load_started_on)
        _setter("full_load_total_rows", full_load_total_rows)
        _setter("id", id)
        _setter("last_modified_time", last_modified_time)
        _setter("result_type", 'TableLevelOutput')
        _setter("state", state)
        _setter("table_name", table_name)
        _setter("total_changes_applied", total_changes_applied)

    @property
    @pulumi.getter(name="cdcDeleteCounter")
    def cdc_delete_counter(self) -> float:
        """
        Number of applied deletes
        """
        return pulumi.get(self, "cdc_delete_counter")

    @property
    @pulumi.getter(name="cdcInsertCounter")
    def cdc_insert_counter(self) -> float:
        """
        Number of applied inserts
        """
        return pulumi.get(self, "cdc_insert_counter")

    @property
    @pulumi.getter(name="cdcUpdateCounter")
    def cdc_update_counter(self) -> float:
        """
        Number of applied updates
        """
        return pulumi.get(self, "cdc_update_counter")

    @property
    @pulumi.getter(name="dataErrorsCounter")
    def data_errors_counter(self) -> float:
        """
        Number of data errors occurred
        """
        return pulumi.get(self, "data_errors_counter")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="fullLoadEndedOn")
    def full_load_ended_on(self) -> str:
        """
        Full load end time
        """
        return pulumi.get(self, "full_load_ended_on")

    @property
    @pulumi.getter(name="fullLoadEstFinishTime")
    def full_load_est_finish_time(self) -> str:
        """
        Estimate to finish full load
        """
        return pulumi.get(self, "full_load_est_finish_time")

    @property
    @pulumi.getter(name="fullLoadStartedOn")
    def full_load_started_on(self) -> str:
        """
        Full load start time
        """
        return pulumi.get(self, "full_load_started_on")

    @property
    @pulumi.getter(name="fullLoadTotalRows")
    def full_load_total_rows(self) -> float:
        """
        Number of rows applied in full load
        """
        return pulumi.get(self, "full_load_total_rows")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> str:
        """
        Last modified time on target
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'TableLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the table migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        Name of the table
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="totalChangesApplied")
    def total_changes_applied(self) -> float:
        """
        Total number of applied changes
        """
        return pulumi.get(self, "total_changes_applied")


@pulumi.output_type
class MigratePostgreSqlAzureDbForPostgreSqlSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that migrates PostgreSQL databases to Azure Database for PostgreSQL for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isCloneable":
            suggest = "is_cloneable"
        elif key == "taskId":
            suggest = "task_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigratePostgreSqlAzureDbForPostgreSqlSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 created_on: Optional[str] = None,
                 input: Optional['outputs.MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse'] = None,
                 is_cloneable: Optional[bool] = None,
                 task_id: Optional[str] = None):
        """
        Properties for the task that migrates PostgreSQL databases to Azure Database for PostgreSQL for online migrations
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseErrorResponse', 'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseLevelResponse', 'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputErrorResponse', 'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputMigrationLevelResponse', 'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputTableLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.PostgreSql.AzureDbForPostgreSql.SyncV2'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param str created_on: DateTime in UTC when the task was created
        :param 'MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse' input: Task input
        :param bool is_cloneable: whether the task can be cloned or not
        :param str task_id: task id
        """
        MigratePostgreSqlAzureDbForPostgreSqlSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            created_on=created_on,
            input=input,
            is_cloneable=is_cloneable,
            task_id=task_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             created_on: Optional[str] = None,
             input: Optional['outputs.MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse'] = None,
             is_cloneable: Optional[bool] = None,
             task_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']
        if created_on is None and 'createdOn' in kwargs:
            created_on = kwargs['createdOn']
        if is_cloneable is None and 'isCloneable' in kwargs:
            is_cloneable = kwargs['isCloneable']
        if task_id is None and 'taskId' in kwargs:
            task_id = kwargs['taskId']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.PostgreSql.AzureDbForPostgreSql.SyncV2')
        if client_data is not None:
            _setter("client_data", client_data)
        if created_on is not None:
            _setter("created_on", created_on)
        if input is not None:
            _setter("input", input)
        if is_cloneable is not None:
            _setter("is_cloneable", is_cloneable)
        if task_id is not None:
            _setter("task_id", task_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.PostgreSql.AzureDbForPostgreSql.SyncV2'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        DateTime in UTC when the task was created
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigratePostgreSqlAzureDbForPostgreSqlSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="isCloneable")
    def is_cloneable(self) -> Optional[bool]:
        """
        whether the task can be cloned or not
        """
        return pulumi.get(self, "is_cloneable")

    @property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[str]:
        """
        task id
        """
        return pulumi.get(self, "task_id")


@pulumi.output_type
class MigrateSqlServerSqlDbDatabaseInputResponse(dict):
    """
    Database specific information for SQL to Azure SQL DB migration task inputs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "makeSourceDbReadOnly":
            suggest = "make_source_db_read_only"
        elif key == "schemaSetting":
            suggest = "schema_setting"
        elif key == "tableMap":
            suggest = "table_map"
        elif key == "targetDatabaseName":
            suggest = "target_database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbDatabaseInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbDatabaseInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbDatabaseInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 make_source_db_read_only: Optional[bool] = None,
                 name: Optional[str] = None,
                 schema_setting: Optional[Any] = None,
                 table_map: Optional[Mapping[str, str]] = None,
                 target_database_name: Optional[str] = None):
        """
        Database specific information for SQL to Azure SQL DB migration task inputs
        :param str id: id of the database
        :param bool make_source_db_read_only: Whether to set database read only before migration
        :param str name: Name of the database
        :param Any schema_setting: Settings selected for DB schema migration.
        :param Mapping[str, str] table_map: Mapping of source to target tables
        :param str target_database_name: Name of target database. Note: Target database will be truncated before starting migration.
        """
        MigrateSqlServerSqlDbDatabaseInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            make_source_db_read_only=make_source_db_read_only,
            name=name,
            schema_setting=schema_setting,
            table_map=table_map,
            target_database_name=target_database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             make_source_db_read_only: Optional[bool] = None,
             name: Optional[str] = None,
             schema_setting: Optional[Any] = None,
             table_map: Optional[Mapping[str, str]] = None,
             target_database_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if make_source_db_read_only is None and 'makeSourceDbReadOnly' in kwargs:
            make_source_db_read_only = kwargs['makeSourceDbReadOnly']
        if schema_setting is None and 'schemaSetting' in kwargs:
            schema_setting = kwargs['schemaSetting']
        if table_map is None and 'tableMap' in kwargs:
            table_map = kwargs['tableMap']
        if target_database_name is None and 'targetDatabaseName' in kwargs:
            target_database_name = kwargs['targetDatabaseName']

        if id is not None:
            _setter("id", id)
        if make_source_db_read_only is not None:
            _setter("make_source_db_read_only", make_source_db_read_only)
        if name is not None:
            _setter("name", name)
        if schema_setting is not None:
            _setter("schema_setting", schema_setting)
        if table_map is not None:
            _setter("table_map", table_map)
        if target_database_name is not None:
            _setter("target_database_name", target_database_name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        id of the database
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="makeSourceDbReadOnly")
    def make_source_db_read_only(self) -> Optional[bool]:
        """
        Whether to set database read only before migration
        """
        return pulumi.get(self, "make_source_db_read_only")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaSetting")
    def schema_setting(self) -> Optional[Any]:
        """
        Settings selected for DB schema migration.
        """
        return pulumi.get(self, "schema_setting")

    @property
    @pulumi.getter(name="tableMap")
    def table_map(self) -> Optional[Mapping[str, str]]:
        """
        Mapping of source to target tables
        """
        return pulumi.get(self, "table_map")

    @property
    @pulumi.getter(name="targetDatabaseName")
    def target_database_name(self) -> Optional[str]:
        """
        Name of target database. Note: Target database will be truncated before starting migration.
        """
        return pulumi.get(self, "target_database_name")


@pulumi.output_type
class MigrateSqlServerSqlDbSyncDatabaseInputResponse(dict):
    """
    Database specific information for SQL to Azure SQL DB sync migration task inputs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "migrationSetting":
            suggest = "migration_setting"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "sourceSetting":
            suggest = "source_setting"
        elif key == "tableMap":
            suggest = "table_map"
        elif key == "targetDatabaseName":
            suggest = "target_database_name"
        elif key == "targetSetting":
            suggest = "target_setting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbSyncDatabaseInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbSyncDatabaseInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbSyncDatabaseInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 migration_setting: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 schema_name: Optional[str] = None,
                 source_setting: Optional[Mapping[str, str]] = None,
                 table_map: Optional[Mapping[str, str]] = None,
                 target_database_name: Optional[str] = None,
                 target_setting: Optional[Mapping[str, str]] = None):
        """
        Database specific information for SQL to Azure SQL DB sync migration task inputs
        :param str id: Unique identifier for database
        :param Mapping[str, str] migration_setting: Migration settings which tune the migration behavior
        :param str name: Name of database
        :param str schema_name: Schema name to be migrated
        :param Mapping[str, str] source_setting: Source settings to tune source endpoint migration behavior
        :param Mapping[str, str] table_map: Mapping of source to target tables
        :param str target_database_name: Target database name
        :param Mapping[str, str] target_setting: Target settings to tune target endpoint migration behavior
        """
        MigrateSqlServerSqlDbSyncDatabaseInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            migration_setting=migration_setting,
            name=name,
            schema_name=schema_name,
            source_setting=source_setting,
            table_map=table_map,
            target_database_name=target_database_name,
            target_setting=target_setting,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             migration_setting: Optional[Mapping[str, str]] = None,
             name: Optional[str] = None,
             schema_name: Optional[str] = None,
             source_setting: Optional[Mapping[str, str]] = None,
             table_map: Optional[Mapping[str, str]] = None,
             target_database_name: Optional[str] = None,
             target_setting: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if migration_setting is None and 'migrationSetting' in kwargs:
            migration_setting = kwargs['migrationSetting']
        if schema_name is None and 'schemaName' in kwargs:
            schema_name = kwargs['schemaName']
        if source_setting is None and 'sourceSetting' in kwargs:
            source_setting = kwargs['sourceSetting']
        if table_map is None and 'tableMap' in kwargs:
            table_map = kwargs['tableMap']
        if target_database_name is None and 'targetDatabaseName' in kwargs:
            target_database_name = kwargs['targetDatabaseName']
        if target_setting is None and 'targetSetting' in kwargs:
            target_setting = kwargs['targetSetting']

        if id is not None:
            _setter("id", id)
        if migration_setting is not None:
            _setter("migration_setting", migration_setting)
        if name is not None:
            _setter("name", name)
        if schema_name is not None:
            _setter("schema_name", schema_name)
        if source_setting is not None:
            _setter("source_setting", source_setting)
        if table_map is not None:
            _setter("table_map", table_map)
        if target_database_name is not None:
            _setter("target_database_name", target_database_name)
        if target_setting is not None:
            _setter("target_setting", target_setting)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier for database
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="migrationSetting")
    def migration_setting(self) -> Optional[Mapping[str, str]]:
        """
        Migration settings which tune the migration behavior
        """
        return pulumi.get(self, "migration_setting")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        Schema name to be migrated
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="sourceSetting")
    def source_setting(self) -> Optional[Mapping[str, str]]:
        """
        Source settings to tune source endpoint migration behavior
        """
        return pulumi.get(self, "source_setting")

    @property
    @pulumi.getter(name="tableMap")
    def table_map(self) -> Optional[Mapping[str, str]]:
        """
        Mapping of source to target tables
        """
        return pulumi.get(self, "table_map")

    @property
    @pulumi.getter(name="targetDatabaseName")
    def target_database_name(self) -> Optional[str]:
        """
        Target database name
        """
        return pulumi.get(self, "target_database_name")

    @property
    @pulumi.getter(name="targetSetting")
    def target_setting(self) -> Optional[Mapping[str, str]]:
        """
        Target settings to tune target endpoint migration behavior
        """
        return pulumi.get(self, "target_setting")


@pulumi.output_type
class MigrateSqlServerSqlDbSyncTaskInputResponse(dict):
    """
    Input for the task that migrates on-prem SQL Server databases to Azure SQL Database for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "validationOptions":
            suggest = "validation_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbSyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbSyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbSyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_databases: Sequence['outputs.MigrateSqlServerSqlDbSyncDatabaseInputResponse'],
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 target_connection_info: 'outputs.SqlConnectionInfoResponse',
                 validation_options: Optional['outputs.MigrationValidationOptionsResponse'] = None):
        """
        Input for the task that migrates on-prem SQL Server databases to Azure SQL Database for online migrations
        :param Sequence['MigrateSqlServerSqlDbSyncDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'SqlConnectionInfoResponse' source_connection_info: Information for connecting to source
        :param 'SqlConnectionInfoResponse' target_connection_info: Information for connecting to target
        :param 'MigrationValidationOptionsResponse' validation_options: Validation options
        """
        MigrateSqlServerSqlDbSyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
            validation_options=validation_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_databases: Optional[Sequence['outputs.MigrateSqlServerSqlDbSyncDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             validation_options: Optional['outputs.MigrationValidationOptionsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if validation_options is None and 'validationOptions' in kwargs:
            validation_options = kwargs['validationOptions']

        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)
        if validation_options is not None:
            _setter("validation_options", validation_options)

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateSqlServerSqlDbSyncDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to source
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to target
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="validationOptions")
    def validation_options(self) -> Optional['outputs.MigrationValidationOptionsResponse']:
        """
        Validation options
        """
        return pulumi.get(self, "validation_options")


@pulumi.output_type
class MigrateSqlServerSqlDbSyncTaskOutputDatabaseErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"
        elif key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbSyncTaskOutputDatabaseErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputDatabaseErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputDatabaseErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 result_type: str,
                 error_message: Optional[str] = None,
                 events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None):
        """
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'DatabaseLevelErrorOutput'.
        :param str error_message: Error message
        :param Sequence['SyncMigrationDatabaseErrorEventResponse'] events: List of error events.
        """
        MigrateSqlServerSqlDbSyncTaskOutputDatabaseErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            result_type=result_type,
            error_message=error_message,
            events=events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             error_message: Optional[str] = None,
             events: Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']

        _setter("id", id)
        _setter("result_type", 'DatabaseLevelErrorOutput')
        if error_message is not None:
            _setter("error_message", error_message)
        if events is not None:
            _setter("events", events)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelErrorOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        Error message
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.SyncMigrationDatabaseErrorEventResponse']]:
        """
        List of error events.
        """
        return pulumi.get(self, "events")


@pulumi.output_type
class MigrateSqlServerSqlDbSyncTaskOutputDatabaseLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedChanges":
            suggest = "applied_changes"
        elif key == "cdcDeleteCounter":
            suggest = "cdc_delete_counter"
        elif key == "cdcInsertCounter":
            suggest = "cdc_insert_counter"
        elif key == "cdcUpdateCounter":
            suggest = "cdc_update_counter"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "fullLoadCompletedTables":
            suggest = "full_load_completed_tables"
        elif key == "fullLoadErroredTables":
            suggest = "full_load_errored_tables"
        elif key == "fullLoadLoadingTables":
            suggest = "full_load_loading_tables"
        elif key == "fullLoadQueuedTables":
            suggest = "full_load_queued_tables"
        elif key == "incomingChanges":
            suggest = "incoming_changes"
        elif key == "initializationCompleted":
            suggest = "initialization_completed"
        elif key == "migrationState":
            suggest = "migration_state"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbSyncTaskOutputDatabaseLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applied_changes: float,
                 cdc_delete_counter: float,
                 cdc_insert_counter: float,
                 cdc_update_counter: float,
                 database_name: str,
                 ended_on: str,
                 full_load_completed_tables: float,
                 full_load_errored_tables: float,
                 full_load_loading_tables: float,
                 full_load_queued_tables: float,
                 id: str,
                 incoming_changes: float,
                 initialization_completed: bool,
                 latency: float,
                 migration_state: str,
                 result_type: str,
                 started_on: str):
        """
        :param float applied_changes: Number of applied changes
        :param float cdc_delete_counter: Number of cdc deletes
        :param float cdc_insert_counter: Number of cdc inserts
        :param float cdc_update_counter: Number of cdc updates
        :param str database_name: Name of the database
        :param str ended_on: Migration end time
        :param float full_load_completed_tables: Number of tables completed in full load
        :param float full_load_errored_tables: Number of tables errored in full load
        :param float full_load_loading_tables: Number of tables loading in full load
        :param float full_load_queued_tables: Number of tables queued in full load
        :param str id: Result identifier
        :param float incoming_changes: Number of incoming changes
        :param bool initialization_completed: Indicates if initial load (full load) has been completed
        :param float latency: CDC apply latency
        :param str migration_state: Migration state that this database is in
        :param str result_type: Result type
               Expected value is 'DatabaseLevelOutput'.
        :param str started_on: Migration start time
        """
        MigrateSqlServerSqlDbSyncTaskOutputDatabaseLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            applied_changes=applied_changes,
            cdc_delete_counter=cdc_delete_counter,
            cdc_insert_counter=cdc_insert_counter,
            cdc_update_counter=cdc_update_counter,
            database_name=database_name,
            ended_on=ended_on,
            full_load_completed_tables=full_load_completed_tables,
            full_load_errored_tables=full_load_errored_tables,
            full_load_loading_tables=full_load_loading_tables,
            full_load_queued_tables=full_load_queued_tables,
            id=id,
            incoming_changes=incoming_changes,
            initialization_completed=initialization_completed,
            latency=latency,
            migration_state=migration_state,
            result_type=result_type,
            started_on=started_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             applied_changes: Optional[float] = None,
             cdc_delete_counter: Optional[float] = None,
             cdc_insert_counter: Optional[float] = None,
             cdc_update_counter: Optional[float] = None,
             database_name: Optional[str] = None,
             ended_on: Optional[str] = None,
             full_load_completed_tables: Optional[float] = None,
             full_load_errored_tables: Optional[float] = None,
             full_load_loading_tables: Optional[float] = None,
             full_load_queued_tables: Optional[float] = None,
             id: Optional[str] = None,
             incoming_changes: Optional[float] = None,
             initialization_completed: Optional[bool] = None,
             latency: Optional[float] = None,
             migration_state: Optional[str] = None,
             result_type: Optional[str] = None,
             started_on: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if applied_changes is None and 'appliedChanges' in kwargs:
            applied_changes = kwargs['appliedChanges']
        if applied_changes is None:
            raise TypeError("Missing 'applied_changes' argument")
        if cdc_delete_counter is None and 'cdcDeleteCounter' in kwargs:
            cdc_delete_counter = kwargs['cdcDeleteCounter']
        if cdc_delete_counter is None:
            raise TypeError("Missing 'cdc_delete_counter' argument")
        if cdc_insert_counter is None and 'cdcInsertCounter' in kwargs:
            cdc_insert_counter = kwargs['cdcInsertCounter']
        if cdc_insert_counter is None:
            raise TypeError("Missing 'cdc_insert_counter' argument")
        if cdc_update_counter is None and 'cdcUpdateCounter' in kwargs:
            cdc_update_counter = kwargs['cdcUpdateCounter']
        if cdc_update_counter is None:
            raise TypeError("Missing 'cdc_update_counter' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if full_load_completed_tables is None and 'fullLoadCompletedTables' in kwargs:
            full_load_completed_tables = kwargs['fullLoadCompletedTables']
        if full_load_completed_tables is None:
            raise TypeError("Missing 'full_load_completed_tables' argument")
        if full_load_errored_tables is None and 'fullLoadErroredTables' in kwargs:
            full_load_errored_tables = kwargs['fullLoadErroredTables']
        if full_load_errored_tables is None:
            raise TypeError("Missing 'full_load_errored_tables' argument")
        if full_load_loading_tables is None and 'fullLoadLoadingTables' in kwargs:
            full_load_loading_tables = kwargs['fullLoadLoadingTables']
        if full_load_loading_tables is None:
            raise TypeError("Missing 'full_load_loading_tables' argument")
        if full_load_queued_tables is None and 'fullLoadQueuedTables' in kwargs:
            full_load_queued_tables = kwargs['fullLoadQueuedTables']
        if full_load_queued_tables is None:
            raise TypeError("Missing 'full_load_queued_tables' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if incoming_changes is None and 'incomingChanges' in kwargs:
            incoming_changes = kwargs['incomingChanges']
        if incoming_changes is None:
            raise TypeError("Missing 'incoming_changes' argument")
        if initialization_completed is None and 'initializationCompleted' in kwargs:
            initialization_completed = kwargs['initializationCompleted']
        if initialization_completed is None:
            raise TypeError("Missing 'initialization_completed' argument")
        if latency is None:
            raise TypeError("Missing 'latency' argument")
        if migration_state is None and 'migrationState' in kwargs:
            migration_state = kwargs['migrationState']
        if migration_state is None:
            raise TypeError("Missing 'migration_state' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")

        _setter("applied_changes", applied_changes)
        _setter("cdc_delete_counter", cdc_delete_counter)
        _setter("cdc_insert_counter", cdc_insert_counter)
        _setter("cdc_update_counter", cdc_update_counter)
        _setter("database_name", database_name)
        _setter("ended_on", ended_on)
        _setter("full_load_completed_tables", full_load_completed_tables)
        _setter("full_load_errored_tables", full_load_errored_tables)
        _setter("full_load_loading_tables", full_load_loading_tables)
        _setter("full_load_queued_tables", full_load_queued_tables)
        _setter("id", id)
        _setter("incoming_changes", incoming_changes)
        _setter("initialization_completed", initialization_completed)
        _setter("latency", latency)
        _setter("migration_state", migration_state)
        _setter("result_type", 'DatabaseLevelOutput')
        _setter("started_on", started_on)

    @property
    @pulumi.getter(name="appliedChanges")
    def applied_changes(self) -> float:
        """
        Number of applied changes
        """
        return pulumi.get(self, "applied_changes")

    @property
    @pulumi.getter(name="cdcDeleteCounter")
    def cdc_delete_counter(self) -> float:
        """
        Number of cdc deletes
        """
        return pulumi.get(self, "cdc_delete_counter")

    @property
    @pulumi.getter(name="cdcInsertCounter")
    def cdc_insert_counter(self) -> float:
        """
        Number of cdc inserts
        """
        return pulumi.get(self, "cdc_insert_counter")

    @property
    @pulumi.getter(name="cdcUpdateCounter")
    def cdc_update_counter(self) -> float:
        """
        Number of cdc updates
        """
        return pulumi.get(self, "cdc_update_counter")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="fullLoadCompletedTables")
    def full_load_completed_tables(self) -> float:
        """
        Number of tables completed in full load
        """
        return pulumi.get(self, "full_load_completed_tables")

    @property
    @pulumi.getter(name="fullLoadErroredTables")
    def full_load_errored_tables(self) -> float:
        """
        Number of tables errored in full load
        """
        return pulumi.get(self, "full_load_errored_tables")

    @property
    @pulumi.getter(name="fullLoadLoadingTables")
    def full_load_loading_tables(self) -> float:
        """
        Number of tables loading in full load
        """
        return pulumi.get(self, "full_load_loading_tables")

    @property
    @pulumi.getter(name="fullLoadQueuedTables")
    def full_load_queued_tables(self) -> float:
        """
        Number of tables queued in full load
        """
        return pulumi.get(self, "full_load_queued_tables")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="incomingChanges")
    def incoming_changes(self) -> float:
        """
        Number of incoming changes
        """
        return pulumi.get(self, "incoming_changes")

    @property
    @pulumi.getter(name="initializationCompleted")
    def initialization_completed(self) -> bool:
        """
        Indicates if initial load (full load) has been completed
        """
        return pulumi.get(self, "initialization_completed")

    @property
    @pulumi.getter
    def latency(self) -> float:
        """
        CDC apply latency
        """
        return pulumi.get(self, "latency")

    @property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> str:
        """
        Migration state that this database is in
        """
        return pulumi.get(self, "migration_state")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")


@pulumi.output_type
class MigrateSqlServerSqlDbSyncTaskOutputErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbSyncTaskOutputErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.ReportableExceptionResponse',
                 id: str,
                 result_type: str):
        """
        :param 'ReportableExceptionResponse' error: Migration error
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'ErrorOutput'.
        """
        MigrateSqlServerSqlDbSyncTaskOutputErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            id=id,
            result_type=result_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional['outputs.ReportableExceptionResponse'] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error is None:
            raise TypeError("Missing 'error' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")

        _setter("error", error)
        _setter("id", id)
        _setter("result_type", 'ErrorOutput')

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ReportableExceptionResponse':
        """
        Migration error
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'ErrorOutput'.
        """
        return pulumi.get(self, "result_type")


@pulumi.output_type
class MigrateSqlServerSqlDbSyncTaskOutputMigrationLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseCount":
            suggest = "database_count"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceServer":
            suggest = "source_server"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetServer":
            suggest = "target_server"
        elif key == "targetServerVersion":
            suggest = "target_server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbSyncTaskOutputMigrationLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_count: int,
                 ended_on: str,
                 id: str,
                 result_type: str,
                 source_server: str,
                 source_server_version: str,
                 started_on: str,
                 target_server: str,
                 target_server_version: str):
        """
        :param int database_count: Count of databases
        :param str ended_on: Migration end time
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'MigrationLevelOutput'.
        :param str source_server: Source server name
        :param str source_server_version: Source server version
        :param str started_on: Migration start time
        :param str target_server: Target server name
        :param str target_server_version: Target server version
        """
        MigrateSqlServerSqlDbSyncTaskOutputMigrationLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_count=database_count,
            ended_on=ended_on,
            id=id,
            result_type=result_type,
            source_server=source_server,
            source_server_version=source_server_version,
            started_on=started_on,
            target_server=target_server,
            target_server_version=target_server_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_count: Optional[int] = None,
             ended_on: Optional[str] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             source_server: Optional[str] = None,
             source_server_version: Optional[str] = None,
             started_on: Optional[str] = None,
             target_server: Optional[str] = None,
             target_server_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_count is None and 'databaseCount' in kwargs:
            database_count = kwargs['databaseCount']
        if database_count is None:
            raise TypeError("Missing 'database_count' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_server is None and 'sourceServer' in kwargs:
            source_server = kwargs['sourceServer']
        if source_server is None:
            raise TypeError("Missing 'source_server' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if target_server is None and 'targetServer' in kwargs:
            target_server = kwargs['targetServer']
        if target_server is None:
            raise TypeError("Missing 'target_server' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")

        _setter("database_count", database_count)
        _setter("ended_on", ended_on)
        _setter("id", id)
        _setter("result_type", 'MigrationLevelOutput')
        _setter("source_server", source_server)
        _setter("source_server_version", source_server_version)
        _setter("started_on", started_on)
        _setter("target_server", target_server)
        _setter("target_server_version", target_server_version)

    @property
    @pulumi.getter(name="databaseCount")
    def database_count(self) -> int:
        """
        Count of databases
        """
        return pulumi.get(self, "database_count")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceServer")
    def source_server(self) -> str:
        """
        Source server name
        """
        return pulumi.get(self, "source_server")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter(name="targetServer")
    def target_server(self) -> str:
        """
        Target server name
        """
        return pulumi.get(self, "target_server")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")


@pulumi.output_type
class MigrateSqlServerSqlDbSyncTaskOutputTableLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cdcDeleteCounter":
            suggest = "cdc_delete_counter"
        elif key == "cdcInsertCounter":
            suggest = "cdc_insert_counter"
        elif key == "cdcUpdateCounter":
            suggest = "cdc_update_counter"
        elif key == "dataErrorsCounter":
            suggest = "data_errors_counter"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "fullLoadEndedOn":
            suggest = "full_load_ended_on"
        elif key == "fullLoadEstFinishTime":
            suggest = "full_load_est_finish_time"
        elif key == "fullLoadStartedOn":
            suggest = "full_load_started_on"
        elif key == "fullLoadTotalRows":
            suggest = "full_load_total_rows"
        elif key == "lastModifiedTime":
            suggest = "last_modified_time"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "totalChangesApplied":
            suggest = "total_changes_applied"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbSyncTaskOutputTableLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputTableLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbSyncTaskOutputTableLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cdc_delete_counter: float,
                 cdc_insert_counter: float,
                 cdc_update_counter: float,
                 data_errors_counter: float,
                 database_name: str,
                 full_load_ended_on: str,
                 full_load_est_finish_time: str,
                 full_load_started_on: str,
                 full_load_total_rows: float,
                 id: str,
                 last_modified_time: str,
                 result_type: str,
                 state: str,
                 table_name: str,
                 total_changes_applied: float):
        """
        :param float cdc_delete_counter: Number of applied deletes
        :param float cdc_insert_counter: Number of applied inserts
        :param float cdc_update_counter: Number of applied updates
        :param float data_errors_counter: Number of data errors occurred
        :param str database_name: Name of the database
        :param str full_load_ended_on: Full load end time
        :param str full_load_est_finish_time: Estimate to finish full load
        :param str full_load_started_on: Full load start time
        :param float full_load_total_rows: Number of rows applied in full load
        :param str id: Result identifier
        :param str last_modified_time: Last modified time on target
        :param str result_type: Result type
               Expected value is 'TableLevelOutput'.
        :param str state: Current state of the table migration
        :param str table_name: Name of the table
        :param float total_changes_applied: Total number of applied changes
        """
        MigrateSqlServerSqlDbSyncTaskOutputTableLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cdc_delete_counter=cdc_delete_counter,
            cdc_insert_counter=cdc_insert_counter,
            cdc_update_counter=cdc_update_counter,
            data_errors_counter=data_errors_counter,
            database_name=database_name,
            full_load_ended_on=full_load_ended_on,
            full_load_est_finish_time=full_load_est_finish_time,
            full_load_started_on=full_load_started_on,
            full_load_total_rows=full_load_total_rows,
            id=id,
            last_modified_time=last_modified_time,
            result_type=result_type,
            state=state,
            table_name=table_name,
            total_changes_applied=total_changes_applied,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cdc_delete_counter: Optional[float] = None,
             cdc_insert_counter: Optional[float] = None,
             cdc_update_counter: Optional[float] = None,
             data_errors_counter: Optional[float] = None,
             database_name: Optional[str] = None,
             full_load_ended_on: Optional[str] = None,
             full_load_est_finish_time: Optional[str] = None,
             full_load_started_on: Optional[str] = None,
             full_load_total_rows: Optional[float] = None,
             id: Optional[str] = None,
             last_modified_time: Optional[str] = None,
             result_type: Optional[str] = None,
             state: Optional[str] = None,
             table_name: Optional[str] = None,
             total_changes_applied: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cdc_delete_counter is None and 'cdcDeleteCounter' in kwargs:
            cdc_delete_counter = kwargs['cdcDeleteCounter']
        if cdc_delete_counter is None:
            raise TypeError("Missing 'cdc_delete_counter' argument")
        if cdc_insert_counter is None and 'cdcInsertCounter' in kwargs:
            cdc_insert_counter = kwargs['cdcInsertCounter']
        if cdc_insert_counter is None:
            raise TypeError("Missing 'cdc_insert_counter' argument")
        if cdc_update_counter is None and 'cdcUpdateCounter' in kwargs:
            cdc_update_counter = kwargs['cdcUpdateCounter']
        if cdc_update_counter is None:
            raise TypeError("Missing 'cdc_update_counter' argument")
        if data_errors_counter is None and 'dataErrorsCounter' in kwargs:
            data_errors_counter = kwargs['dataErrorsCounter']
        if data_errors_counter is None:
            raise TypeError("Missing 'data_errors_counter' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if full_load_ended_on is None and 'fullLoadEndedOn' in kwargs:
            full_load_ended_on = kwargs['fullLoadEndedOn']
        if full_load_ended_on is None:
            raise TypeError("Missing 'full_load_ended_on' argument")
        if full_load_est_finish_time is None and 'fullLoadEstFinishTime' in kwargs:
            full_load_est_finish_time = kwargs['fullLoadEstFinishTime']
        if full_load_est_finish_time is None:
            raise TypeError("Missing 'full_load_est_finish_time' argument")
        if full_load_started_on is None and 'fullLoadStartedOn' in kwargs:
            full_load_started_on = kwargs['fullLoadStartedOn']
        if full_load_started_on is None:
            raise TypeError("Missing 'full_load_started_on' argument")
        if full_load_total_rows is None and 'fullLoadTotalRows' in kwargs:
            full_load_total_rows = kwargs['fullLoadTotalRows']
        if full_load_total_rows is None:
            raise TypeError("Missing 'full_load_total_rows' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if last_modified_time is None and 'lastModifiedTime' in kwargs:
            last_modified_time = kwargs['lastModifiedTime']
        if last_modified_time is None:
            raise TypeError("Missing 'last_modified_time' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")
        if total_changes_applied is None and 'totalChangesApplied' in kwargs:
            total_changes_applied = kwargs['totalChangesApplied']
        if total_changes_applied is None:
            raise TypeError("Missing 'total_changes_applied' argument")

        _setter("cdc_delete_counter", cdc_delete_counter)
        _setter("cdc_insert_counter", cdc_insert_counter)
        _setter("cdc_update_counter", cdc_update_counter)
        _setter("data_errors_counter", data_errors_counter)
        _setter("database_name", database_name)
        _setter("full_load_ended_on", full_load_ended_on)
        _setter("full_load_est_finish_time", full_load_est_finish_time)
        _setter("full_load_started_on", full_load_started_on)
        _setter("full_load_total_rows", full_load_total_rows)
        _setter("id", id)
        _setter("last_modified_time", last_modified_time)
        _setter("result_type", 'TableLevelOutput')
        _setter("state", state)
        _setter("table_name", table_name)
        _setter("total_changes_applied", total_changes_applied)

    @property
    @pulumi.getter(name="cdcDeleteCounter")
    def cdc_delete_counter(self) -> float:
        """
        Number of applied deletes
        """
        return pulumi.get(self, "cdc_delete_counter")

    @property
    @pulumi.getter(name="cdcInsertCounter")
    def cdc_insert_counter(self) -> float:
        """
        Number of applied inserts
        """
        return pulumi.get(self, "cdc_insert_counter")

    @property
    @pulumi.getter(name="cdcUpdateCounter")
    def cdc_update_counter(self) -> float:
        """
        Number of applied updates
        """
        return pulumi.get(self, "cdc_update_counter")

    @property
    @pulumi.getter(name="dataErrorsCounter")
    def data_errors_counter(self) -> float:
        """
        Number of data errors occurred
        """
        return pulumi.get(self, "data_errors_counter")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="fullLoadEndedOn")
    def full_load_ended_on(self) -> str:
        """
        Full load end time
        """
        return pulumi.get(self, "full_load_ended_on")

    @property
    @pulumi.getter(name="fullLoadEstFinishTime")
    def full_load_est_finish_time(self) -> str:
        """
        Estimate to finish full load
        """
        return pulumi.get(self, "full_load_est_finish_time")

    @property
    @pulumi.getter(name="fullLoadStartedOn")
    def full_load_started_on(self) -> str:
        """
        Full load start time
        """
        return pulumi.get(self, "full_load_started_on")

    @property
    @pulumi.getter(name="fullLoadTotalRows")
    def full_load_total_rows(self) -> float:
        """
        Number of rows applied in full load
        """
        return pulumi.get(self, "full_load_total_rows")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> str:
        """
        Last modified time on target
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'TableLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the table migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        Name of the table
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="totalChangesApplied")
    def total_changes_applied(self) -> float:
        """
        Total number of applied changes
        """
        return pulumi.get(self, "total_changes_applied")


@pulumi.output_type
class MigrateSqlServerSqlDbSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that migrates on-prem SQL Server databases to Azure SQL Database for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.MigrateSqlServerSqlDbSyncTaskInputResponse'] = None):
        """
        Properties for the task that migrates on-prem SQL Server databases to Azure SQL Database for online migrations
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['MigrateSqlServerSqlDbSyncTaskOutputDatabaseErrorResponse', 'MigrateSqlServerSqlDbSyncTaskOutputDatabaseLevelResponse', 'MigrateSqlServerSqlDbSyncTaskOutputErrorResponse', 'MigrateSqlServerSqlDbSyncTaskOutputMigrationLevelResponse', 'MigrateSqlServerSqlDbSyncTaskOutputTableLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.SqlServer.AzureSqlDb.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'MigrateSqlServerSqlDbSyncTaskInputResponse' input: Task input
        """
        MigrateSqlServerSqlDbSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.MigrateSqlServerSqlDbSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.SqlServer.AzureSqlDb.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.SqlServer.AzureSqlDb.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateSqlServerSqlDbSyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class MigrateSqlServerSqlDbTaskInputResponse(dict):
    """
    Input for the task that migrates on-prem SQL Server databases to Azure SQL Database
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "encryptedKeyForSecureFields":
            suggest = "encrypted_key_for_secure_fields"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "validationOptions":
            suggest = "validation_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_databases: Sequence['outputs.MigrateSqlServerSqlDbDatabaseInputResponse'],
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 target_connection_info: 'outputs.SqlConnectionInfoResponse',
                 encrypted_key_for_secure_fields: Optional[str] = None,
                 started_on: Optional[str] = None,
                 validation_options: Optional['outputs.MigrationValidationOptionsResponse'] = None):
        """
        Input for the task that migrates on-prem SQL Server databases to Azure SQL Database
        :param Sequence['MigrateSqlServerSqlDbDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'SqlConnectionInfoResponse' source_connection_info: Information for connecting to source
        :param 'SqlConnectionInfoResponse' target_connection_info: Information for connecting to target
        :param str encrypted_key_for_secure_fields: encrypted key for secure fields
        :param str started_on: Date and time relative to UTC when the migration was started on
        :param 'MigrationValidationOptionsResponse' validation_options: Options for enabling various post migration validations. Available options, 
                1.) Data Integrity Check: Performs a checksum based comparison on source and target tables after the migration to ensure the correctness of the data. 
                2.) Schema Validation: Performs a thorough schema comparison between the source and target tables and provides a list of differences between the source and target database, 3.) Query Analysis: Executes a set of queries picked up automatically either from the Query Plan Cache or Query Store and execute them and compares the execution time between the source and target database.
        """
        MigrateSqlServerSqlDbTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
            encrypted_key_for_secure_fields=encrypted_key_for_secure_fields,
            started_on=started_on,
            validation_options=validation_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_databases: Optional[Sequence['outputs.MigrateSqlServerSqlDbDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             encrypted_key_for_secure_fields: Optional[str] = None,
             started_on: Optional[str] = None,
             validation_options: Optional['outputs.MigrationValidationOptionsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if encrypted_key_for_secure_fields is None and 'encryptedKeyForSecureFields' in kwargs:
            encrypted_key_for_secure_fields = kwargs['encryptedKeyForSecureFields']
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if validation_options is None and 'validationOptions' in kwargs:
            validation_options = kwargs['validationOptions']

        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)
        if encrypted_key_for_secure_fields is not None:
            _setter("encrypted_key_for_secure_fields", encrypted_key_for_secure_fields)
        if started_on is not None:
            _setter("started_on", started_on)
        if validation_options is not None:
            _setter("validation_options", validation_options)

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateSqlServerSqlDbDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to source
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to target
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="encryptedKeyForSecureFields")
    def encrypted_key_for_secure_fields(self) -> Optional[str]:
        """
        encrypted key for secure fields
        """
        return pulumi.get(self, "encrypted_key_for_secure_fields")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[str]:
        """
        Date and time relative to UTC when the migration was started on
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter(name="validationOptions")
    def validation_options(self) -> Optional['outputs.MigrationValidationOptionsResponse']:
        """
        Options for enabling various post migration validations. Available options, 
         1.) Data Integrity Check: Performs a checksum based comparison on source and target tables after the migration to ensure the correctness of the data. 
         2.) Schema Validation: Performs a thorough schema comparison between the source and target tables and provides a list of differences between the source and target database, 3.) Query Analysis: Executes a set of queries picked up automatically either from the Query Plan Cache or Query Store and execute them and compares the execution time between the source and target database.
        """
        return pulumi.get(self, "validation_options")


@pulumi.output_type
class MigrateSqlServerSqlDbTaskOutputDatabaseLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "errorCount":
            suggest = "error_count"
        elif key == "errorPrefix":
            suggest = "error_prefix"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "numberOfObjects":
            suggest = "number_of_objects"
        elif key == "numberOfObjectsCompleted":
            suggest = "number_of_objects_completed"
        elif key == "objectSummary":
            suggest = "object_summary"
        elif key == "resultPrefix":
            suggest = "result_prefix"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbTaskOutputDatabaseLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 ended_on: str,
                 error_count: float,
                 error_prefix: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 message: str,
                 number_of_objects: float,
                 number_of_objects_completed: float,
                 object_summary: Mapping[str, 'outputs.DataItemMigrationSummaryResultResponse'],
                 result_prefix: str,
                 result_type: str,
                 stage: str,
                 started_on: str,
                 state: str,
                 status_message: str):
        """
        :param str database_name: Name of the item
        :param str ended_on: Migration end time
        :param float error_count: Number of database/object errors.
        :param str error_prefix: Wildcard string prefix to use for querying all errors of the item
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings.
        :param str id: Result identifier
        :param str message: Migration progress message
        :param float number_of_objects: Number of objects
        :param float number_of_objects_completed: Number of successfully completed objects
        :param Mapping[str, 'DataItemMigrationSummaryResultResponse'] object_summary: Summary of object results in the migration
        :param str result_prefix: Wildcard string prefix to use for querying all sub-tem results of the item
        :param str result_type: Result type
               Expected value is 'DatabaseLevelOutput'.
        :param str stage: Migration stage that this database is in
        :param str started_on: Migration start time
        :param str state: Current state of migration
        :param str status_message: Status message
        """
        MigrateSqlServerSqlDbTaskOutputDatabaseLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            ended_on=ended_on,
            error_count=error_count,
            error_prefix=error_prefix,
            exceptions_and_warnings=exceptions_and_warnings,
            id=id,
            message=message,
            number_of_objects=number_of_objects,
            number_of_objects_completed=number_of_objects_completed,
            object_summary=object_summary,
            result_prefix=result_prefix,
            result_type=result_type,
            stage=stage,
            started_on=started_on,
            state=state,
            status_message=status_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             ended_on: Optional[str] = None,
             error_count: Optional[float] = None,
             error_prefix: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             message: Optional[str] = None,
             number_of_objects: Optional[float] = None,
             number_of_objects_completed: Optional[float] = None,
             object_summary: Optional[Mapping[str, 'outputs.DataItemMigrationSummaryResultResponse']] = None,
             result_prefix: Optional[str] = None,
             result_type: Optional[str] = None,
             stage: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             status_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if error_count is None and 'errorCount' in kwargs:
            error_count = kwargs['errorCount']
        if error_count is None:
            raise TypeError("Missing 'error_count' argument")
        if error_prefix is None and 'errorPrefix' in kwargs:
            error_prefix = kwargs['errorPrefix']
        if error_prefix is None:
            raise TypeError("Missing 'error_prefix' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if number_of_objects is None and 'numberOfObjects' in kwargs:
            number_of_objects = kwargs['numberOfObjects']
        if number_of_objects is None:
            raise TypeError("Missing 'number_of_objects' argument")
        if number_of_objects_completed is None and 'numberOfObjectsCompleted' in kwargs:
            number_of_objects_completed = kwargs['numberOfObjectsCompleted']
        if number_of_objects_completed is None:
            raise TypeError("Missing 'number_of_objects_completed' argument")
        if object_summary is None and 'objectSummary' in kwargs:
            object_summary = kwargs['objectSummary']
        if object_summary is None:
            raise TypeError("Missing 'object_summary' argument")
        if result_prefix is None and 'resultPrefix' in kwargs:
            result_prefix = kwargs['resultPrefix']
        if result_prefix is None:
            raise TypeError("Missing 'result_prefix' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if stage is None:
            raise TypeError("Missing 'stage' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status_message is None and 'statusMessage' in kwargs:
            status_message = kwargs['statusMessage']
        if status_message is None:
            raise TypeError("Missing 'status_message' argument")

        _setter("database_name", database_name)
        _setter("ended_on", ended_on)
        _setter("error_count", error_count)
        _setter("error_prefix", error_prefix)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("id", id)
        _setter("message", message)
        _setter("number_of_objects", number_of_objects)
        _setter("number_of_objects_completed", number_of_objects_completed)
        _setter("object_summary", object_summary)
        _setter("result_prefix", result_prefix)
        _setter("result_type", 'DatabaseLevelOutput')
        _setter("stage", stage)
        _setter("started_on", started_on)
        _setter("state", state)
        _setter("status_message", status_message)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the item
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="errorCount")
    def error_count(self) -> float:
        """
        Number of database/object errors.
        """
        return pulumi.get(self, "error_count")

    @property
    @pulumi.getter(name="errorPrefix")
    def error_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all errors of the item
        """
        return pulumi.get(self, "error_prefix")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings.
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="numberOfObjects")
    def number_of_objects(self) -> float:
        """
        Number of objects
        """
        return pulumi.get(self, "number_of_objects")

    @property
    @pulumi.getter(name="numberOfObjectsCompleted")
    def number_of_objects_completed(self) -> float:
        """
        Number of successfully completed objects
        """
        return pulumi.get(self, "number_of_objects_completed")

    @property
    @pulumi.getter(name="objectSummary")
    def object_summary(self) -> Mapping[str, 'outputs.DataItemMigrationSummaryResultResponse']:
        """
        Summary of object results in the migration
        """
        return pulumi.get(self, "object_summary")

    @property
    @pulumi.getter(name="resultPrefix")
    def result_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all sub-tem results of the item
        """
        return pulumi.get(self, "result_prefix")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def stage(self) -> str:
        """
        Migration stage that this database is in
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        Status message
        """
        return pulumi.get(self, "status_message")


@pulumi.output_type
class MigrateSqlServerSqlDbTaskOutputDatabaseLevelValidationResultResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataIntegrityValidationResult":
            suggest = "data_integrity_validation_result"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "migrationId":
            suggest = "migration_id"
        elif key == "queryAnalysisValidationResult":
            suggest = "query_analysis_validation_result"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "schemaValidationResult":
            suggest = "schema_validation_result"
        elif key == "sourceDatabaseName":
            suggest = "source_database_name"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetDatabaseName":
            suggest = "target_database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbTaskOutputDatabaseLevelValidationResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbTaskOutputDatabaseLevelValidationResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbTaskOutputDatabaseLevelValidationResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_integrity_validation_result: 'outputs.DataIntegrityValidationResultResponse',
                 ended_on: str,
                 id: str,
                 migration_id: str,
                 query_analysis_validation_result: 'outputs.QueryAnalysisValidationResultResponse',
                 result_type: str,
                 schema_validation_result: 'outputs.SchemaComparisonValidationResultResponse',
                 source_database_name: str,
                 started_on: str,
                 status: str,
                 target_database_name: str):
        """
        :param 'DataIntegrityValidationResultResponse' data_integrity_validation_result: Provides data integrity validation result between the source and target tables that are migrated.
        :param str ended_on: Validation end time
        :param str id: Result identifier
        :param str migration_id: Migration Identifier
        :param 'QueryAnalysisValidationResultResponse' query_analysis_validation_result: Results of some of the query execution result between source and target database
        :param str result_type: Result type
               Expected value is 'MigrationDatabaseLevelValidationOutput'.
        :param 'SchemaComparisonValidationResultResponse' schema_validation_result: Provides schema comparison result between source and target database
        :param str source_database_name: Name of the source database
        :param str started_on: Validation start time
        :param str status: Current status of validation at the database level
        :param str target_database_name: Name of the target database
        """
        MigrateSqlServerSqlDbTaskOutputDatabaseLevelValidationResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_integrity_validation_result=data_integrity_validation_result,
            ended_on=ended_on,
            id=id,
            migration_id=migration_id,
            query_analysis_validation_result=query_analysis_validation_result,
            result_type=result_type,
            schema_validation_result=schema_validation_result,
            source_database_name=source_database_name,
            started_on=started_on,
            status=status,
            target_database_name=target_database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_integrity_validation_result: Optional['outputs.DataIntegrityValidationResultResponse'] = None,
             ended_on: Optional[str] = None,
             id: Optional[str] = None,
             migration_id: Optional[str] = None,
             query_analysis_validation_result: Optional['outputs.QueryAnalysisValidationResultResponse'] = None,
             result_type: Optional[str] = None,
             schema_validation_result: Optional['outputs.SchemaComparisonValidationResultResponse'] = None,
             source_database_name: Optional[str] = None,
             started_on: Optional[str] = None,
             status: Optional[str] = None,
             target_database_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_integrity_validation_result is None and 'dataIntegrityValidationResult' in kwargs:
            data_integrity_validation_result = kwargs['dataIntegrityValidationResult']
        if data_integrity_validation_result is None:
            raise TypeError("Missing 'data_integrity_validation_result' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if migration_id is None and 'migrationId' in kwargs:
            migration_id = kwargs['migrationId']
        if migration_id is None:
            raise TypeError("Missing 'migration_id' argument")
        if query_analysis_validation_result is None and 'queryAnalysisValidationResult' in kwargs:
            query_analysis_validation_result = kwargs['queryAnalysisValidationResult']
        if query_analysis_validation_result is None:
            raise TypeError("Missing 'query_analysis_validation_result' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if schema_validation_result is None and 'schemaValidationResult' in kwargs:
            schema_validation_result = kwargs['schemaValidationResult']
        if schema_validation_result is None:
            raise TypeError("Missing 'schema_validation_result' argument")
        if source_database_name is None and 'sourceDatabaseName' in kwargs:
            source_database_name = kwargs['sourceDatabaseName']
        if source_database_name is None:
            raise TypeError("Missing 'source_database_name' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if target_database_name is None and 'targetDatabaseName' in kwargs:
            target_database_name = kwargs['targetDatabaseName']
        if target_database_name is None:
            raise TypeError("Missing 'target_database_name' argument")

        _setter("data_integrity_validation_result", data_integrity_validation_result)
        _setter("ended_on", ended_on)
        _setter("id", id)
        _setter("migration_id", migration_id)
        _setter("query_analysis_validation_result", query_analysis_validation_result)
        _setter("result_type", 'MigrationDatabaseLevelValidationOutput')
        _setter("schema_validation_result", schema_validation_result)
        _setter("source_database_name", source_database_name)
        _setter("started_on", started_on)
        _setter("status", status)
        _setter("target_database_name", target_database_name)

    @property
    @pulumi.getter(name="dataIntegrityValidationResult")
    def data_integrity_validation_result(self) -> 'outputs.DataIntegrityValidationResultResponse':
        """
        Provides data integrity validation result between the source and target tables that are migrated.
        """
        return pulumi.get(self, "data_integrity_validation_result")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Validation end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="migrationId")
    def migration_id(self) -> str:
        """
        Migration Identifier
        """
        return pulumi.get(self, "migration_id")

    @property
    @pulumi.getter(name="queryAnalysisValidationResult")
    def query_analysis_validation_result(self) -> 'outputs.QueryAnalysisValidationResultResponse':
        """
        Results of some of the query execution result between source and target database
        """
        return pulumi.get(self, "query_analysis_validation_result")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationDatabaseLevelValidationOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="schemaValidationResult")
    def schema_validation_result(self) -> 'outputs.SchemaComparisonValidationResultResponse':
        """
        Provides schema comparison result between source and target database
        """
        return pulumi.get(self, "schema_validation_result")

    @property
    @pulumi.getter(name="sourceDatabaseName")
    def source_database_name(self) -> str:
        """
        Name of the source database
        """
        return pulumi.get(self, "source_database_name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Validation start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of validation at the database level
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="targetDatabaseName")
    def target_database_name(self) -> str:
        """
        Name of the target database
        """
        return pulumi.get(self, "target_database_name")


@pulumi.output_type
class MigrateSqlServerSqlDbTaskOutputErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbTaskOutputErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbTaskOutputErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbTaskOutputErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.ReportableExceptionResponse',
                 id: str,
                 result_type: str):
        """
        :param 'ReportableExceptionResponse' error: Migration error
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'ErrorOutput'.
        """
        MigrateSqlServerSqlDbTaskOutputErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            id=id,
            result_type=result_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional['outputs.ReportableExceptionResponse'] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error is None:
            raise TypeError("Missing 'error' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")

        _setter("error", error)
        _setter("id", id)
        _setter("result_type", 'ErrorOutput')

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ReportableExceptionResponse':
        """
        Migration error
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'ErrorOutput'.
        """
        return pulumi.get(self, "result_type")


@pulumi.output_type
class MigrateSqlServerSqlDbTaskOutputMigrationLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseSummary":
            suggest = "database_summary"
        elif key == "durationInSeconds":
            suggest = "duration_in_seconds"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceServerBrandVersion":
            suggest = "source_server_brand_version"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "statusMessage":
            suggest = "status_message"
        elif key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerVersion":
            suggest = "target_server_version"
        elif key == "migrationReportResult":
            suggest = "migration_report_result"
        elif key == "migrationValidationResult":
            suggest = "migration_validation_result"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbTaskOutputMigrationLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_summary: Mapping[str, 'outputs.DatabaseSummaryResultResponse'],
                 databases: Mapping[str, str],
                 duration_in_seconds: float,
                 ended_on: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 message: str,
                 result_type: str,
                 source_server_brand_version: str,
                 source_server_version: str,
                 started_on: str,
                 status: str,
                 status_message: str,
                 target_server_brand_version: str,
                 target_server_version: str,
                 migration_report_result: Optional['outputs.MigrationReportResultResponse'] = None,
                 migration_validation_result: Optional['outputs.MigrationValidationResultResponse'] = None):
        """
        :param Mapping[str, 'DatabaseSummaryResultResponse'] database_summary: Summary of database results in the migration
        :param Mapping[str, str] databases: Selected databases as a map from database name to database id
        :param float duration_in_seconds: Duration of task execution in seconds.
        :param str ended_on: Migration end time
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings.
        :param str id: Result identifier
        :param str message: Migration progress message
        :param str result_type: Result type
               Expected value is 'MigrationLevelOutput'.
        :param str source_server_brand_version: Source server brand version
        :param str source_server_version: Source server version
        :param str started_on: Migration start time
        :param str status: Current status of migration
        :param str status_message: Migration status message
        :param str target_server_brand_version: Target server brand version
        :param str target_server_version: Target server version
        :param 'MigrationReportResultResponse' migration_report_result: Migration Report Result, provides unique url for downloading your migration report.
        :param 'MigrationValidationResultResponse' migration_validation_result: Migration Validation Results
        """
        MigrateSqlServerSqlDbTaskOutputMigrationLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_summary=database_summary,
            databases=databases,
            duration_in_seconds=duration_in_seconds,
            ended_on=ended_on,
            exceptions_and_warnings=exceptions_and_warnings,
            id=id,
            message=message,
            result_type=result_type,
            source_server_brand_version=source_server_brand_version,
            source_server_version=source_server_version,
            started_on=started_on,
            status=status,
            status_message=status_message,
            target_server_brand_version=target_server_brand_version,
            target_server_version=target_server_version,
            migration_report_result=migration_report_result,
            migration_validation_result=migration_validation_result,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_summary: Optional[Mapping[str, 'outputs.DatabaseSummaryResultResponse']] = None,
             databases: Optional[Mapping[str, str]] = None,
             duration_in_seconds: Optional[float] = None,
             ended_on: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             message: Optional[str] = None,
             result_type: Optional[str] = None,
             source_server_brand_version: Optional[str] = None,
             source_server_version: Optional[str] = None,
             started_on: Optional[str] = None,
             status: Optional[str] = None,
             status_message: Optional[str] = None,
             target_server_brand_version: Optional[str] = None,
             target_server_version: Optional[str] = None,
             migration_report_result: Optional['outputs.MigrationReportResultResponse'] = None,
             migration_validation_result: Optional['outputs.MigrationValidationResultResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_summary is None and 'databaseSummary' in kwargs:
            database_summary = kwargs['databaseSummary']
        if database_summary is None:
            raise TypeError("Missing 'database_summary' argument")
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if duration_in_seconds is None and 'durationInSeconds' in kwargs:
            duration_in_seconds = kwargs['durationInSeconds']
        if duration_in_seconds is None:
            raise TypeError("Missing 'duration_in_seconds' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_server_brand_version is None and 'sourceServerBrandVersion' in kwargs:
            source_server_brand_version = kwargs['sourceServerBrandVersion']
        if source_server_brand_version is None:
            raise TypeError("Missing 'source_server_brand_version' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if status_message is None and 'statusMessage' in kwargs:
            status_message = kwargs['statusMessage']
        if status_message is None:
            raise TypeError("Missing 'status_message' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")
        if migration_report_result is None and 'migrationReportResult' in kwargs:
            migration_report_result = kwargs['migrationReportResult']
        if migration_validation_result is None and 'migrationValidationResult' in kwargs:
            migration_validation_result = kwargs['migrationValidationResult']

        _setter("database_summary", database_summary)
        _setter("databases", databases)
        _setter("duration_in_seconds", duration_in_seconds)
        _setter("ended_on", ended_on)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("id", id)
        _setter("message", message)
        _setter("result_type", 'MigrationLevelOutput')
        _setter("source_server_brand_version", source_server_brand_version)
        _setter("source_server_version", source_server_version)
        _setter("started_on", started_on)
        _setter("status", status)
        _setter("status_message", status_message)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_version", target_server_version)
        if migration_report_result is not None:
            _setter("migration_report_result", migration_report_result)
        if migration_validation_result is not None:
            _setter("migration_validation_result", migration_validation_result)

    @property
    @pulumi.getter(name="databaseSummary")
    def database_summary(self) -> Mapping[str, 'outputs.DatabaseSummaryResultResponse']:
        """
        Summary of database results in the migration
        """
        return pulumi.get(self, "database_summary")

    @property
    @pulumi.getter
    def databases(self) -> Mapping[str, str]:
        """
        Selected databases as a map from database name to database id
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="durationInSeconds")
    def duration_in_seconds(self) -> float:
        """
        Duration of task execution in seconds.
        """
        return pulumi.get(self, "duration_in_seconds")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings.
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceServerBrandVersion")
    def source_server_brand_version(self) -> str:
        """
        Source server brand version
        """
        return pulumi.get(self, "source_server_brand_version")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of migration
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        Migration status message
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")

    @property
    @pulumi.getter(name="migrationReportResult")
    def migration_report_result(self) -> Optional['outputs.MigrationReportResultResponse']:
        """
        Migration Report Result, provides unique url for downloading your migration report.
        """
        return pulumi.get(self, "migration_report_result")

    @property
    @pulumi.getter(name="migrationValidationResult")
    def migration_validation_result(self) -> Optional['outputs.MigrationValidationResultResponse']:
        """
        Migration Validation Results
        """
        return pulumi.get(self, "migration_validation_result")


@pulumi.output_type
class MigrateSqlServerSqlDbTaskOutputTableLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "errorPrefix":
            suggest = "error_prefix"
        elif key == "itemsCompletedCount":
            suggest = "items_completed_count"
        elif key == "itemsCount":
            suggest = "items_count"
        elif key == "objectName":
            suggest = "object_name"
        elif key == "resultPrefix":
            suggest = "result_prefix"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "statusMessage":
            suggest = "status_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbTaskOutputTableLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbTaskOutputTableLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbTaskOutputTableLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 error_prefix: str,
                 id: str,
                 items_completed_count: float,
                 items_count: float,
                 object_name: str,
                 result_prefix: str,
                 result_type: str,
                 started_on: str,
                 state: str,
                 status_message: str):
        """
        :param str ended_on: Migration end time
        :param str error_prefix: Wildcard string prefix to use for querying all errors of the item
        :param str id: Result identifier
        :param float items_completed_count: Number of successfully completed items
        :param float items_count: Number of items
        :param str object_name: Name of the item
        :param str result_prefix: Wildcard string prefix to use for querying all sub-tem results of the item
        :param str result_type: Result type
               Expected value is 'TableLevelOutput'.
        :param str started_on: Migration start time
        :param str state: Current state of migration
        :param str status_message: Status message
        """
        MigrateSqlServerSqlDbTaskOutputTableLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            error_prefix=error_prefix,
            id=id,
            items_completed_count=items_completed_count,
            items_count=items_count,
            object_name=object_name,
            result_prefix=result_prefix,
            result_type=result_type,
            started_on=started_on,
            state=state,
            status_message=status_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             error_prefix: Optional[str] = None,
             id: Optional[str] = None,
             items_completed_count: Optional[float] = None,
             items_count: Optional[float] = None,
             object_name: Optional[str] = None,
             result_prefix: Optional[str] = None,
             result_type: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             status_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if error_prefix is None and 'errorPrefix' in kwargs:
            error_prefix = kwargs['errorPrefix']
        if error_prefix is None:
            raise TypeError("Missing 'error_prefix' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if items_completed_count is None and 'itemsCompletedCount' in kwargs:
            items_completed_count = kwargs['itemsCompletedCount']
        if items_completed_count is None:
            raise TypeError("Missing 'items_completed_count' argument")
        if items_count is None and 'itemsCount' in kwargs:
            items_count = kwargs['itemsCount']
        if items_count is None:
            raise TypeError("Missing 'items_count' argument")
        if object_name is None and 'objectName' in kwargs:
            object_name = kwargs['objectName']
        if object_name is None:
            raise TypeError("Missing 'object_name' argument")
        if result_prefix is None and 'resultPrefix' in kwargs:
            result_prefix = kwargs['resultPrefix']
        if result_prefix is None:
            raise TypeError("Missing 'result_prefix' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status_message is None and 'statusMessage' in kwargs:
            status_message = kwargs['statusMessage']
        if status_message is None:
            raise TypeError("Missing 'status_message' argument")

        _setter("ended_on", ended_on)
        _setter("error_prefix", error_prefix)
        _setter("id", id)
        _setter("items_completed_count", items_completed_count)
        _setter("items_count", items_count)
        _setter("object_name", object_name)
        _setter("result_prefix", result_prefix)
        _setter("result_type", 'TableLevelOutput')
        _setter("started_on", started_on)
        _setter("state", state)
        _setter("status_message", status_message)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="errorPrefix")
    def error_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all errors of the item
        """
        return pulumi.get(self, "error_prefix")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="itemsCompletedCount")
    def items_completed_count(self) -> float:
        """
        Number of successfully completed items
        """
        return pulumi.get(self, "items_completed_count")

    @property
    @pulumi.getter(name="itemsCount")
    def items_count(self) -> float:
        """
        Number of items
        """
        return pulumi.get(self, "items_count")

    @property
    @pulumi.getter(name="objectName")
    def object_name(self) -> str:
        """
        Name of the item
        """
        return pulumi.get(self, "object_name")

    @property
    @pulumi.getter(name="resultPrefix")
    def result_prefix(self) -> str:
        """
        Wildcard string prefix to use for querying all sub-tem results of the item
        """
        return pulumi.get(self, "result_prefix")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'TableLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        """
        Status message
        """
        return pulumi.get(self, "status_message")


@pulumi.output_type
class MigrateSqlServerSqlDbTaskOutputValidationResultResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "migrationId":
            suggest = "migration_id"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "summaryResults":
            suggest = "summary_results"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbTaskOutputValidationResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbTaskOutputValidationResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbTaskOutputValidationResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 migration_id: str,
                 result_type: str,
                 status: str,
                 summary_results: Optional[Mapping[str, 'outputs.MigrationValidationDatabaseSummaryResultResponse']] = None):
        """
        :param str id: Migration validation result identifier
        :param str migration_id: Migration Identifier
        :param str result_type: Result type
               Expected value is 'MigrationValidationOutput'.
        :param str status: Current status of validation at the migration level. Status from the database validation result status will be aggregated here.
        :param Mapping[str, 'MigrationValidationDatabaseSummaryResultResponse'] summary_results: Validation summary results for each database
        """
        MigrateSqlServerSqlDbTaskOutputValidationResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            migration_id=migration_id,
            result_type=result_type,
            status=status,
            summary_results=summary_results,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             migration_id: Optional[str] = None,
             result_type: Optional[str] = None,
             status: Optional[str] = None,
             summary_results: Optional[Mapping[str, 'outputs.MigrationValidationDatabaseSummaryResultResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if migration_id is None and 'migrationId' in kwargs:
            migration_id = kwargs['migrationId']
        if migration_id is None:
            raise TypeError("Missing 'migration_id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if summary_results is None and 'summaryResults' in kwargs:
            summary_results = kwargs['summaryResults']

        _setter("id", id)
        _setter("migration_id", migration_id)
        _setter("result_type", 'MigrationValidationOutput')
        _setter("status", status)
        if summary_results is not None:
            _setter("summary_results", summary_results)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Migration validation result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="migrationId")
    def migration_id(self) -> str:
        """
        Migration Identifier
        """
        return pulumi.get(self, "migration_id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationValidationOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of validation at the migration level. Status from the database validation result status will be aggregated here.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="summaryResults")
    def summary_results(self) -> Optional[Mapping[str, 'outputs.MigrationValidationDatabaseSummaryResultResponse']]:
        """
        Validation summary results for each database
        """
        return pulumi.get(self, "summary_results")


@pulumi.output_type
class MigrateSqlServerSqlDbTaskPropertiesResponse(dict):
    """
    Properties for the task that migrates on-prem SQL Server databases to Azure SQL Database
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isCloneable":
            suggest = "is_cloneable"
        elif key == "taskId":
            suggest = "task_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlDbTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlDbTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlDbTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 created_on: Optional[str] = None,
                 input: Optional['outputs.MigrateSqlServerSqlDbTaskInputResponse'] = None,
                 is_cloneable: Optional[bool] = None,
                 task_id: Optional[str] = None):
        """
        Properties for the task that migrates on-prem SQL Server databases to Azure SQL Database
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['MigrateSqlServerSqlDbTaskOutputDatabaseLevelResponse', 'MigrateSqlServerSqlDbTaskOutputDatabaseLevelValidationResultResponse', 'MigrateSqlServerSqlDbTaskOutputErrorResponse', 'MigrateSqlServerSqlDbTaskOutputMigrationLevelResponse', 'MigrateSqlServerSqlDbTaskOutputTableLevelResponse', 'MigrateSqlServerSqlDbTaskOutputValidationResultResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.SqlServer.SqlDb'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param str created_on: DateTime in UTC when the task was created
        :param 'MigrateSqlServerSqlDbTaskInputResponse' input: Task input
        :param bool is_cloneable: whether the task can be cloned or not
        :param str task_id: task id
        """
        MigrateSqlServerSqlDbTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            created_on=created_on,
            input=input,
            is_cloneable=is_cloneable,
            task_id=task_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             created_on: Optional[str] = None,
             input: Optional['outputs.MigrateSqlServerSqlDbTaskInputResponse'] = None,
             is_cloneable: Optional[bool] = None,
             task_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']
        if created_on is None and 'createdOn' in kwargs:
            created_on = kwargs['createdOn']
        if is_cloneable is None and 'isCloneable' in kwargs:
            is_cloneable = kwargs['isCloneable']
        if task_id is None and 'taskId' in kwargs:
            task_id = kwargs['taskId']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.SqlServer.SqlDb')
        if client_data is not None:
            _setter("client_data", client_data)
        if created_on is not None:
            _setter("created_on", created_on)
        if input is not None:
            _setter("input", input)
        if is_cloneable is not None:
            _setter("is_cloneable", is_cloneable)
        if task_id is not None:
            _setter("task_id", task_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.SqlServer.SqlDb'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        DateTime in UTC when the task was created
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateSqlServerSqlDbTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="isCloneable")
    def is_cloneable(self) -> Optional[bool]:
        """
        whether the task can be cloned or not
        """
        return pulumi.get(self, "is_cloneable")

    @property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[str]:
        """
        task id
        """
        return pulumi.get(self, "task_id")


@pulumi.output_type
class MigrateSqlServerSqlMIDatabaseInputResponse(dict):
    """
    Database specific information for SQL to Azure SQL DB Managed Instance migration task inputs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restoreDatabaseName":
            suggest = "restore_database_name"
        elif key == "backupFilePaths":
            suggest = "backup_file_paths"
        elif key == "backupFileShare":
            suggest = "backup_file_share"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMIDatabaseInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMIDatabaseInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMIDatabaseInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 restore_database_name: str,
                 backup_file_paths: Optional[Sequence[str]] = None,
                 backup_file_share: Optional['outputs.FileShareResponse'] = None,
                 id: Optional[str] = None):
        """
        Database specific information for SQL to Azure SQL DB Managed Instance migration task inputs
        :param str name: Name of the database
        :param str restore_database_name: Name of the database at destination
        :param Sequence[str] backup_file_paths: The list of backup files to be used in case of existing backups.
        :param 'FileShareResponse' backup_file_share: Backup file share information for backing up this database.
        :param str id: id of the database
        """
        MigrateSqlServerSqlMIDatabaseInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            restore_database_name=restore_database_name,
            backup_file_paths=backup_file_paths,
            backup_file_share=backup_file_share,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             restore_database_name: Optional[str] = None,
             backup_file_paths: Optional[Sequence[str]] = None,
             backup_file_share: Optional['outputs.FileShareResponse'] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if restore_database_name is None and 'restoreDatabaseName' in kwargs:
            restore_database_name = kwargs['restoreDatabaseName']
        if restore_database_name is None:
            raise TypeError("Missing 'restore_database_name' argument")
        if backup_file_paths is None and 'backupFilePaths' in kwargs:
            backup_file_paths = kwargs['backupFilePaths']
        if backup_file_share is None and 'backupFileShare' in kwargs:
            backup_file_share = kwargs['backupFileShare']

        _setter("name", name)
        _setter("restore_database_name", restore_database_name)
        if backup_file_paths is not None:
            _setter("backup_file_paths", backup_file_paths)
        if backup_file_share is not None:
            _setter("backup_file_share", backup_file_share)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="restoreDatabaseName")
    def restore_database_name(self) -> str:
        """
        Name of the database at destination
        """
        return pulumi.get(self, "restore_database_name")

    @property
    @pulumi.getter(name="backupFilePaths")
    def backup_file_paths(self) -> Optional[Sequence[str]]:
        """
        The list of backup files to be used in case of existing backups.
        """
        return pulumi.get(self, "backup_file_paths")

    @property
    @pulumi.getter(name="backupFileShare")
    def backup_file_share(self) -> Optional['outputs.FileShareResponse']:
        """
        Backup file share information for backing up this database.
        """
        return pulumi.get(self, "backup_file_share")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        id of the database
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class MigrateSqlServerSqlMISyncTaskInputResponse(dict):
    """
    Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance online scenario.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureApp":
            suggest = "azure_app"
        elif key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "backupFileShare":
            suggest = "backup_file_share"
        elif key == "numberOfParallelDatabaseMigrations":
            suggest = "number_of_parallel_database_migrations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMISyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMISyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMISyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_app: 'outputs.AzureActiveDirectoryAppResponse',
                 selected_databases: Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse'],
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 storage_resource_id: str,
                 target_connection_info: 'outputs.MiSqlConnectionInfoResponse',
                 backup_file_share: Optional['outputs.FileShareResponse'] = None,
                 number_of_parallel_database_migrations: Optional[float] = None):
        """
        Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance online scenario.
        :param 'AzureActiveDirectoryAppResponse' azure_app: Azure Active Directory Application the DMS (classic) instance will use to connect to the target instance of Azure SQL Database Managed Instance and the Azure Storage Account
        :param Sequence['MigrateSqlServerSqlMIDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'SqlConnectionInfoResponse' source_connection_info: Connection information for source SQL Server
        :param str storage_resource_id: Fully qualified resourceId of storage
        :param 'MiSqlConnectionInfoResponse' target_connection_info: Connection information for Azure SQL Database Managed Instance
        :param 'FileShareResponse' backup_file_share: Backup file share information for all selected databases.
        :param float number_of_parallel_database_migrations: Number of database migrations to start in parallel
        """
        MigrateSqlServerSqlMISyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_app=azure_app,
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            storage_resource_id=storage_resource_id,
            target_connection_info=target_connection_info,
            backup_file_share=backup_file_share,
            number_of_parallel_database_migrations=number_of_parallel_database_migrations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_app: Optional['outputs.AzureActiveDirectoryAppResponse'] = None,
             selected_databases: Optional[Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             storage_resource_id: Optional[str] = None,
             target_connection_info: Optional['outputs.MiSqlConnectionInfoResponse'] = None,
             backup_file_share: Optional['outputs.FileShareResponse'] = None,
             number_of_parallel_database_migrations: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_app is None and 'azureApp' in kwargs:
            azure_app = kwargs['azureApp']
        if azure_app is None:
            raise TypeError("Missing 'azure_app' argument")
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if storage_resource_id is None and 'storageResourceId' in kwargs:
            storage_resource_id = kwargs['storageResourceId']
        if storage_resource_id is None:
            raise TypeError("Missing 'storage_resource_id' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if backup_file_share is None and 'backupFileShare' in kwargs:
            backup_file_share = kwargs['backupFileShare']
        if number_of_parallel_database_migrations is None and 'numberOfParallelDatabaseMigrations' in kwargs:
            number_of_parallel_database_migrations = kwargs['numberOfParallelDatabaseMigrations']

        _setter("azure_app", azure_app)
        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("storage_resource_id", storage_resource_id)
        _setter("target_connection_info", target_connection_info)
        if backup_file_share is not None:
            _setter("backup_file_share", backup_file_share)
        if number_of_parallel_database_migrations is not None:
            _setter("number_of_parallel_database_migrations", number_of_parallel_database_migrations)

    @property
    @pulumi.getter(name="azureApp")
    def azure_app(self) -> 'outputs.AzureActiveDirectoryAppResponse':
        """
        Azure Active Directory Application the DMS (classic) instance will use to connect to the target instance of Azure SQL Database Managed Instance and the Azure Storage Account
        """
        return pulumi.get(self, "azure_app")

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for source SQL Server
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> str:
        """
        Fully qualified resourceId of storage
        """
        return pulumi.get(self, "storage_resource_id")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.MiSqlConnectionInfoResponse':
        """
        Connection information for Azure SQL Database Managed Instance
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="backupFileShare")
    def backup_file_share(self) -> Optional['outputs.FileShareResponse']:
        """
        Backup file share information for all selected databases.
        """
        return pulumi.get(self, "backup_file_share")

    @property
    @pulumi.getter(name="numberOfParallelDatabaseMigrations")
    def number_of_parallel_database_migrations(self) -> Optional[float]:
        """
        Number of database migrations to start in parallel
        """
        return pulumi.get(self, "number_of_parallel_database_migrations")


@pulumi.output_type
class MigrateSqlServerSqlMISyncTaskOutputDatabaseLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeBackupSets":
            suggest = "active_backup_sets"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "errorPrefix":
            suggest = "error_prefix"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "fullBackupSetInfo":
            suggest = "full_backup_set_info"
        elif key == "isFullBackupRestored":
            suggest = "is_full_backup_restored"
        elif key == "lastRestoredBackupSetInfo":
            suggest = "last_restored_backup_set_info"
        elif key == "migrationState":
            suggest = "migration_state"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceDatabaseName":
            suggest = "source_database_name"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMISyncTaskOutputDatabaseLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMISyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMISyncTaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_backup_sets: Sequence['outputs.BackupSetInfoResponse'],
                 container_name: str,
                 ended_on: str,
                 error_prefix: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 full_backup_set_info: 'outputs.BackupSetInfoResponse',
                 id: str,
                 is_full_backup_restored: bool,
                 last_restored_backup_set_info: 'outputs.BackupSetInfoResponse',
                 migration_state: str,
                 result_type: str,
                 source_database_name: str,
                 started_on: str):
        """
        :param Sequence['BackupSetInfoResponse'] active_backup_sets: Backup sets that are currently active (Either being uploaded or getting restored)
        :param str container_name: Name of container created in the Azure Storage account where backups are copied to
        :param str ended_on: Database migration end time
        :param str error_prefix: prefix string to use for querying errors for this database
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings
        :param 'BackupSetInfoResponse' full_backup_set_info: Details of full backup set
        :param str id: Result identifier
        :param bool is_full_backup_restored: Whether full backup has been applied to the target database or not
        :param 'BackupSetInfoResponse' last_restored_backup_set_info: Last applied backup set information
        :param str migration_state: Current state of database
        :param str result_type: Result type
               Expected value is 'DatabaseLevelOutput'.
        :param str source_database_name: Name of the database
        :param str started_on: Database migration start time
        """
        MigrateSqlServerSqlMISyncTaskOutputDatabaseLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active_backup_sets=active_backup_sets,
            container_name=container_name,
            ended_on=ended_on,
            error_prefix=error_prefix,
            exceptions_and_warnings=exceptions_and_warnings,
            full_backup_set_info=full_backup_set_info,
            id=id,
            is_full_backup_restored=is_full_backup_restored,
            last_restored_backup_set_info=last_restored_backup_set_info,
            migration_state=migration_state,
            result_type=result_type,
            source_database_name=source_database_name,
            started_on=started_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active_backup_sets: Optional[Sequence['outputs.BackupSetInfoResponse']] = None,
             container_name: Optional[str] = None,
             ended_on: Optional[str] = None,
             error_prefix: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             full_backup_set_info: Optional['outputs.BackupSetInfoResponse'] = None,
             id: Optional[str] = None,
             is_full_backup_restored: Optional[bool] = None,
             last_restored_backup_set_info: Optional['outputs.BackupSetInfoResponse'] = None,
             migration_state: Optional[str] = None,
             result_type: Optional[str] = None,
             source_database_name: Optional[str] = None,
             started_on: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if active_backup_sets is None and 'activeBackupSets' in kwargs:
            active_backup_sets = kwargs['activeBackupSets']
        if active_backup_sets is None:
            raise TypeError("Missing 'active_backup_sets' argument")
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if container_name is None:
            raise TypeError("Missing 'container_name' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if error_prefix is None and 'errorPrefix' in kwargs:
            error_prefix = kwargs['errorPrefix']
        if error_prefix is None:
            raise TypeError("Missing 'error_prefix' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if full_backup_set_info is None and 'fullBackupSetInfo' in kwargs:
            full_backup_set_info = kwargs['fullBackupSetInfo']
        if full_backup_set_info is None:
            raise TypeError("Missing 'full_backup_set_info' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_full_backup_restored is None and 'isFullBackupRestored' in kwargs:
            is_full_backup_restored = kwargs['isFullBackupRestored']
        if is_full_backup_restored is None:
            raise TypeError("Missing 'is_full_backup_restored' argument")
        if last_restored_backup_set_info is None and 'lastRestoredBackupSetInfo' in kwargs:
            last_restored_backup_set_info = kwargs['lastRestoredBackupSetInfo']
        if last_restored_backup_set_info is None:
            raise TypeError("Missing 'last_restored_backup_set_info' argument")
        if migration_state is None and 'migrationState' in kwargs:
            migration_state = kwargs['migrationState']
        if migration_state is None:
            raise TypeError("Missing 'migration_state' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_database_name is None and 'sourceDatabaseName' in kwargs:
            source_database_name = kwargs['sourceDatabaseName']
        if source_database_name is None:
            raise TypeError("Missing 'source_database_name' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")

        _setter("active_backup_sets", active_backup_sets)
        _setter("container_name", container_name)
        _setter("ended_on", ended_on)
        _setter("error_prefix", error_prefix)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("full_backup_set_info", full_backup_set_info)
        _setter("id", id)
        _setter("is_full_backup_restored", is_full_backup_restored)
        _setter("last_restored_backup_set_info", last_restored_backup_set_info)
        _setter("migration_state", migration_state)
        _setter("result_type", 'DatabaseLevelOutput')
        _setter("source_database_name", source_database_name)
        _setter("started_on", started_on)

    @property
    @pulumi.getter(name="activeBackupSets")
    def active_backup_sets(self) -> Sequence['outputs.BackupSetInfoResponse']:
        """
        Backup sets that are currently active (Either being uploaded or getting restored)
        """
        return pulumi.get(self, "active_backup_sets")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        Name of container created in the Azure Storage account where backups are copied to
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Database migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="errorPrefix")
    def error_prefix(self) -> str:
        """
        prefix string to use for querying errors for this database
        """
        return pulumi.get(self, "error_prefix")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter(name="fullBackupSetInfo")
    def full_backup_set_info(self) -> 'outputs.BackupSetInfoResponse':
        """
        Details of full backup set
        """
        return pulumi.get(self, "full_backup_set_info")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isFullBackupRestored")
    def is_full_backup_restored(self) -> bool:
        """
        Whether full backup has been applied to the target database or not
        """
        return pulumi.get(self, "is_full_backup_restored")

    @property
    @pulumi.getter(name="lastRestoredBackupSetInfo")
    def last_restored_backup_set_info(self) -> 'outputs.BackupSetInfoResponse':
        """
        Last applied backup set information
        """
        return pulumi.get(self, "last_restored_backup_set_info")

    @property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> str:
        """
        Current state of database
        """
        return pulumi.get(self, "migration_state")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceDatabaseName")
    def source_database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "source_database_name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Database migration start time
        """
        return pulumi.get(self, "started_on")


@pulumi.output_type
class MigrateSqlServerSqlMISyncTaskOutputErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMISyncTaskOutputErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMISyncTaskOutputErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMISyncTaskOutputErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.ReportableExceptionResponse',
                 id: str,
                 result_type: str):
        """
        :param 'ReportableExceptionResponse' error: Migration error
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'ErrorOutput'.
        """
        MigrateSqlServerSqlMISyncTaskOutputErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            id=id,
            result_type=result_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional['outputs.ReportableExceptionResponse'] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error is None:
            raise TypeError("Missing 'error' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")

        _setter("error", error)
        _setter("id", id)
        _setter("result_type", 'ErrorOutput')

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ReportableExceptionResponse':
        """
        Migration error
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'ErrorOutput'.
        """
        return pulumi.get(self, "result_type")


@pulumi.output_type
class MigrateSqlServerSqlMISyncTaskOutputMigrationLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseCount":
            suggest = "database_count"
        elif key == "databaseErrorCount":
            suggest = "database_error_count"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceServerBrandVersion":
            suggest = "source_server_brand_version"
        elif key == "sourceServerName":
            suggest = "source_server_name"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerName":
            suggest = "target_server_name"
        elif key == "targetServerVersion":
            suggest = "target_server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMISyncTaskOutputMigrationLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMISyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMISyncTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_count: int,
                 database_error_count: int,
                 ended_on: str,
                 id: str,
                 result_type: str,
                 source_server_brand_version: str,
                 source_server_name: str,
                 source_server_version: str,
                 started_on: str,
                 state: str,
                 target_server_brand_version: str,
                 target_server_name: str,
                 target_server_version: str):
        """
        :param int database_count: Count of databases
        :param int database_error_count: Number of database level errors
        :param str ended_on: Migration end time
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'MigrationLevelOutput'.
        :param str source_server_brand_version: Source server brand version
        :param str source_server_name: Source server name
        :param str source_server_version: Source server version
        :param str started_on: Migration start time
        :param str state: Current state of migration
        :param str target_server_brand_version: Target server brand version
        :param str target_server_name: Target server name
        :param str target_server_version: Target server version
        """
        MigrateSqlServerSqlMISyncTaskOutputMigrationLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_count=database_count,
            database_error_count=database_error_count,
            ended_on=ended_on,
            id=id,
            result_type=result_type,
            source_server_brand_version=source_server_brand_version,
            source_server_name=source_server_name,
            source_server_version=source_server_version,
            started_on=started_on,
            state=state,
            target_server_brand_version=target_server_brand_version,
            target_server_name=target_server_name,
            target_server_version=target_server_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_count: Optional[int] = None,
             database_error_count: Optional[int] = None,
             ended_on: Optional[str] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             source_server_brand_version: Optional[str] = None,
             source_server_name: Optional[str] = None,
             source_server_version: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             target_server_brand_version: Optional[str] = None,
             target_server_name: Optional[str] = None,
             target_server_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_count is None and 'databaseCount' in kwargs:
            database_count = kwargs['databaseCount']
        if database_count is None:
            raise TypeError("Missing 'database_count' argument")
        if database_error_count is None and 'databaseErrorCount' in kwargs:
            database_error_count = kwargs['databaseErrorCount']
        if database_error_count is None:
            raise TypeError("Missing 'database_error_count' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_server_brand_version is None and 'sourceServerBrandVersion' in kwargs:
            source_server_brand_version = kwargs['sourceServerBrandVersion']
        if source_server_brand_version is None:
            raise TypeError("Missing 'source_server_brand_version' argument")
        if source_server_name is None and 'sourceServerName' in kwargs:
            source_server_name = kwargs['sourceServerName']
        if source_server_name is None:
            raise TypeError("Missing 'source_server_name' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_name is None and 'targetServerName' in kwargs:
            target_server_name = kwargs['targetServerName']
        if target_server_name is None:
            raise TypeError("Missing 'target_server_name' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")

        _setter("database_count", database_count)
        _setter("database_error_count", database_error_count)
        _setter("ended_on", ended_on)
        _setter("id", id)
        _setter("result_type", 'MigrationLevelOutput')
        _setter("source_server_brand_version", source_server_brand_version)
        _setter("source_server_name", source_server_name)
        _setter("source_server_version", source_server_version)
        _setter("started_on", started_on)
        _setter("state", state)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_name", target_server_name)
        _setter("target_server_version", target_server_version)

    @property
    @pulumi.getter(name="databaseCount")
    def database_count(self) -> int:
        """
        Count of databases
        """
        return pulumi.get(self, "database_count")

    @property
    @pulumi.getter(name="databaseErrorCount")
    def database_error_count(self) -> int:
        """
        Number of database level errors
        """
        return pulumi.get(self, "database_error_count")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceServerBrandVersion")
    def source_server_brand_version(self) -> str:
        """
        Source server brand version
        """
        return pulumi.get(self, "source_server_brand_version")

    @property
    @pulumi.getter(name="sourceServerName")
    def source_server_name(self) -> str:
        """
        Source server name
        """
        return pulumi.get(self, "source_server_name")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerName")
    def target_server_name(self) -> str:
        """
        Target server name
        """
        return pulumi.get(self, "target_server_name")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")


@pulumi.output_type
class MigrateSqlServerSqlMISyncTaskPropertiesResponse(dict):
    """
    Properties for task that migrates SQL Server databases to Azure SQL Database Managed Instance sync scenario
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"
        elif key == "createdOn":
            suggest = "created_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMISyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMISyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMISyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 created_on: Optional[str] = None,
                 input: Optional['outputs.MigrateSqlServerSqlMISyncTaskInputResponse'] = None):
        """
        Properties for task that migrates SQL Server databases to Azure SQL Database Managed Instance sync scenario
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['MigrateSqlServerSqlMISyncTaskOutputDatabaseLevelResponse', 'MigrateSqlServerSqlMISyncTaskOutputErrorResponse', 'MigrateSqlServerSqlMISyncTaskOutputMigrationLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.SqlServer.AzureSqlDbMI.Sync.LRS'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param str created_on: DateTime in UTC when the task was created
        :param 'MigrateSqlServerSqlMISyncTaskInputResponse' input: Task input
        """
        MigrateSqlServerSqlMISyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            created_on=created_on,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             created_on: Optional[str] = None,
             input: Optional['outputs.MigrateSqlServerSqlMISyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']
        if created_on is None and 'createdOn' in kwargs:
            created_on = kwargs['createdOn']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.SqlServer.AzureSqlDbMI.Sync.LRS')
        if client_data is not None:
            _setter("client_data", client_data)
        if created_on is not None:
            _setter("created_on", created_on)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.SqlServer.AzureSqlDbMI.Sync.LRS'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        DateTime in UTC when the task was created
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateSqlServerSqlMISyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class MigrateSqlServerSqlMITaskInputResponse(dict):
    """
    Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupBlobShare":
            suggest = "backup_blob_share"
        elif key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "aadDomainName":
            suggest = "aad_domain_name"
        elif key == "backupFileShare":
            suggest = "backup_file_share"
        elif key == "backupMode":
            suggest = "backup_mode"
        elif key == "encryptedKeyForSecureFields":
            suggest = "encrypted_key_for_secure_fields"
        elif key == "selectedAgentJobs":
            suggest = "selected_agent_jobs"
        elif key == "selectedLogins":
            suggest = "selected_logins"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMITaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMITaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMITaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_blob_share: 'outputs.BlobShareResponse',
                 selected_databases: Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse'],
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 target_connection_info: 'outputs.SqlConnectionInfoResponse',
                 aad_domain_name: Optional[str] = None,
                 backup_file_share: Optional['outputs.FileShareResponse'] = None,
                 backup_mode: Optional[str] = None,
                 encrypted_key_for_secure_fields: Optional[str] = None,
                 selected_agent_jobs: Optional[Sequence[str]] = None,
                 selected_logins: Optional[Sequence[str]] = None,
                 started_on: Optional[str] = None):
        """
        Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance.
        :param 'BlobShareResponse' backup_blob_share: SAS URI of Azure Storage Account Container to be used for storing backup files.
        :param Sequence['MigrateSqlServerSqlMIDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'SqlConnectionInfoResponse' source_connection_info: Information for connecting to source
        :param 'SqlConnectionInfoResponse' target_connection_info: Information for connecting to target
        :param str aad_domain_name: Azure Active Directory domain name in the format of 'contoso.com' for federated Azure AD or 'contoso.onmicrosoft.com' for managed domain, required if and only if Windows logins are selected
        :param 'FileShareResponse' backup_file_share: Backup file share information for all selected databases.
        :param str backup_mode: Backup Mode to specify whether to use existing backup or create new backup. If using existing backups, backup file paths are required to be provided in selectedDatabases.
        :param str encrypted_key_for_secure_fields: encrypted key for secure fields
        :param Sequence[str] selected_agent_jobs: Agent Jobs to migrate.
        :param Sequence[str] selected_logins: Logins to migrate.
        :param str started_on: Date and time relative to UTC when the migration was started on
        """
        MigrateSqlServerSqlMITaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_blob_share=backup_blob_share,
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
            aad_domain_name=aad_domain_name,
            backup_file_share=backup_file_share,
            backup_mode=backup_mode,
            encrypted_key_for_secure_fields=encrypted_key_for_secure_fields,
            selected_agent_jobs=selected_agent_jobs,
            selected_logins=selected_logins,
            started_on=started_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_blob_share: Optional['outputs.BlobShareResponse'] = None,
             selected_databases: Optional[Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             aad_domain_name: Optional[str] = None,
             backup_file_share: Optional['outputs.FileShareResponse'] = None,
             backup_mode: Optional[str] = None,
             encrypted_key_for_secure_fields: Optional[str] = None,
             selected_agent_jobs: Optional[Sequence[str]] = None,
             selected_logins: Optional[Sequence[str]] = None,
             started_on: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_blob_share is None and 'backupBlobShare' in kwargs:
            backup_blob_share = kwargs['backupBlobShare']
        if backup_blob_share is None:
            raise TypeError("Missing 'backup_blob_share' argument")
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if aad_domain_name is None and 'aadDomainName' in kwargs:
            aad_domain_name = kwargs['aadDomainName']
        if backup_file_share is None and 'backupFileShare' in kwargs:
            backup_file_share = kwargs['backupFileShare']
        if backup_mode is None and 'backupMode' in kwargs:
            backup_mode = kwargs['backupMode']
        if encrypted_key_for_secure_fields is None and 'encryptedKeyForSecureFields' in kwargs:
            encrypted_key_for_secure_fields = kwargs['encryptedKeyForSecureFields']
        if selected_agent_jobs is None and 'selectedAgentJobs' in kwargs:
            selected_agent_jobs = kwargs['selectedAgentJobs']
        if selected_logins is None and 'selectedLogins' in kwargs:
            selected_logins = kwargs['selectedLogins']
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']

        _setter("backup_blob_share", backup_blob_share)
        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)
        if aad_domain_name is not None:
            _setter("aad_domain_name", aad_domain_name)
        if backup_file_share is not None:
            _setter("backup_file_share", backup_file_share)
        if backup_mode is not None:
            _setter("backup_mode", backup_mode)
        if encrypted_key_for_secure_fields is not None:
            _setter("encrypted_key_for_secure_fields", encrypted_key_for_secure_fields)
        if selected_agent_jobs is not None:
            _setter("selected_agent_jobs", selected_agent_jobs)
        if selected_logins is not None:
            _setter("selected_logins", selected_logins)
        if started_on is not None:
            _setter("started_on", started_on)

    @property
    @pulumi.getter(name="backupBlobShare")
    def backup_blob_share(self) -> 'outputs.BlobShareResponse':
        """
        SAS URI of Azure Storage Account Container to be used for storing backup files.
        """
        return pulumi.get(self, "backup_blob_share")

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to source
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to target
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="aadDomainName")
    def aad_domain_name(self) -> Optional[str]:
        """
        Azure Active Directory domain name in the format of 'contoso.com' for federated Azure AD or 'contoso.onmicrosoft.com' for managed domain, required if and only if Windows logins are selected
        """
        return pulumi.get(self, "aad_domain_name")

    @property
    @pulumi.getter(name="backupFileShare")
    def backup_file_share(self) -> Optional['outputs.FileShareResponse']:
        """
        Backup file share information for all selected databases.
        """
        return pulumi.get(self, "backup_file_share")

    @property
    @pulumi.getter(name="backupMode")
    def backup_mode(self) -> Optional[str]:
        """
        Backup Mode to specify whether to use existing backup or create new backup. If using existing backups, backup file paths are required to be provided in selectedDatabases.
        """
        return pulumi.get(self, "backup_mode")

    @property
    @pulumi.getter(name="encryptedKeyForSecureFields")
    def encrypted_key_for_secure_fields(self) -> Optional[str]:
        """
        encrypted key for secure fields
        """
        return pulumi.get(self, "encrypted_key_for_secure_fields")

    @property
    @pulumi.getter(name="selectedAgentJobs")
    def selected_agent_jobs(self) -> Optional[Sequence[str]]:
        """
        Agent Jobs to migrate.
        """
        return pulumi.get(self, "selected_agent_jobs")

    @property
    @pulumi.getter(name="selectedLogins")
    def selected_logins(self) -> Optional[Sequence[str]]:
        """
        Logins to migrate.
        """
        return pulumi.get(self, "selected_logins")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[str]:
        """
        Date and time relative to UTC when the migration was started on
        """
        return pulumi.get(self, "started_on")


@pulumi.output_type
class MigrateSqlServerSqlMITaskOutputAgentJobLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMITaskOutputAgentJobLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMITaskOutputAgentJobLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMITaskOutputAgentJobLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 is_enabled: bool,
                 message: str,
                 name: str,
                 result_type: str,
                 started_on: str,
                 state: str):
        """
        :param str ended_on: Migration end time
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration errors and warnings per job
        :param str id: Result identifier
        :param bool is_enabled: The state of the original Agent Job.
        :param str message: Migration progress message
        :param str name: Agent Job name.
        :param str result_type: Result type
               Expected value is 'AgentJobLevelOutput'.
        :param str started_on: Migration start time
        :param str state: Current state of migration
        """
        MigrateSqlServerSqlMITaskOutputAgentJobLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            exceptions_and_warnings=exceptions_and_warnings,
            id=id,
            is_enabled=is_enabled,
            message=message,
            name=name,
            result_type=result_type,
            started_on=started_on,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             message: Optional[str] = None,
             name: Optional[str] = None,
             result_type: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("ended_on", ended_on)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("id", id)
        _setter("is_enabled", is_enabled)
        _setter("message", message)
        _setter("name", name)
        _setter("result_type", 'AgentJobLevelOutput')
        _setter("started_on", started_on)
        _setter("state", state)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration errors and warnings per job
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        The state of the original Agent Job.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Agent Job name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'AgentJobLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MigrateSqlServerSqlMITaskOutputDatabaseLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sizeMB":
            suggest = "size_mb"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMITaskOutputDatabaseLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMITaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMITaskOutputDatabaseLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 ended_on: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 message: str,
                 result_type: str,
                 size_mb: float,
                 stage: str,
                 started_on: str,
                 state: str):
        """
        :param str database_name: Name of the database
        :param str ended_on: Migration end time
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings
        :param str id: Result identifier
        :param str message: Migration progress message
        :param str result_type: Result type
               Expected value is 'DatabaseLevelOutput'.
        :param float size_mb: Size of the database in megabytes
        :param str stage: Current stage of migration
        :param str started_on: Migration start time
        :param str state: Current state of migration
        """
        MigrateSqlServerSqlMITaskOutputDatabaseLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            ended_on=ended_on,
            exceptions_and_warnings=exceptions_and_warnings,
            id=id,
            message=message,
            result_type=result_type,
            size_mb=size_mb,
            stage=stage,
            started_on=started_on,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             ended_on: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             message: Optional[str] = None,
             result_type: Optional[str] = None,
             size_mb: Optional[float] = None,
             stage: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if size_mb is None and 'sizeMB' in kwargs:
            size_mb = kwargs['sizeMB']
        if size_mb is None:
            raise TypeError("Missing 'size_mb' argument")
        if stage is None:
            raise TypeError("Missing 'stage' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("database_name", database_name)
        _setter("ended_on", ended_on)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("id", id)
        _setter("message", message)
        _setter("result_type", 'DatabaseLevelOutput')
        _setter("size_mb", size_mb)
        _setter("stage", stage)
        _setter("started_on", started_on)
        _setter("state", state)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'DatabaseLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sizeMB")
    def size_mb(self) -> float:
        """
        Size of the database in megabytes
        """
        return pulumi.get(self, "size_mb")

    @property
    @pulumi.getter
    def stage(self) -> str:
        """
        Current stage of migration
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MigrateSqlServerSqlMITaskOutputErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultType":
            suggest = "result_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMITaskOutputErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMITaskOutputErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMITaskOutputErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.ReportableExceptionResponse',
                 id: str,
                 result_type: str):
        """
        :param 'ReportableExceptionResponse' error: Migration error
        :param str id: Result identifier
        :param str result_type: Result type
               Expected value is 'ErrorOutput'.
        """
        MigrateSqlServerSqlMITaskOutputErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            id=id,
            result_type=result_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional['outputs.ReportableExceptionResponse'] = None,
             id: Optional[str] = None,
             result_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error is None:
            raise TypeError("Missing 'error' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")

        _setter("error", error)
        _setter("id", id)
        _setter("result_type", 'ErrorOutput')

    @property
    @pulumi.getter
    def error(self) -> 'outputs.ReportableExceptionResponse':
        """
        Migration error
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'ErrorOutput'.
        """
        return pulumi.get(self, "result_type")


@pulumi.output_type
class MigrateSqlServerSqlMITaskOutputLoginLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "loginName":
            suggest = "login_name"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMITaskOutputLoginLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMITaskOutputLoginLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMITaskOutputLoginLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 login_name: str,
                 message: str,
                 result_type: str,
                 stage: str,
                 started_on: str,
                 state: str):
        """
        :param str ended_on: Login migration end time
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Login migration errors and warnings per login
        :param str id: Result identifier
        :param str login_name: Login name.
        :param str message: Login migration progress message
        :param str result_type: Result type
               Expected value is 'LoginLevelOutput'.
        :param str stage: Current stage of login
        :param str started_on: Login migration start time
        :param str state: Current state of login
        """
        MigrateSqlServerSqlMITaskOutputLoginLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            exceptions_and_warnings=exceptions_and_warnings,
            id=id,
            login_name=login_name,
            message=message,
            result_type=result_type,
            stage=stage,
            started_on=started_on,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             login_name: Optional[str] = None,
             message: Optional[str] = None,
             result_type: Optional[str] = None,
             stage: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if login_name is None and 'loginName' in kwargs:
            login_name = kwargs['loginName']
        if login_name is None:
            raise TypeError("Missing 'login_name' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if stage is None:
            raise TypeError("Missing 'stage' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("ended_on", ended_on)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("id", id)
        _setter("login_name", login_name)
        _setter("message", message)
        _setter("result_type", 'LoginLevelOutput')
        _setter("stage", stage)
        _setter("started_on", started_on)
        _setter("state", state)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Login migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Login migration errors and warnings per login
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="loginName")
    def login_name(self) -> str:
        """
        Login name.
        """
        return pulumi.get(self, "login_name")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Login migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'LoginLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def stage(self) -> str:
        """
        Current stage of login
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Login migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of login
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MigrateSqlServerSqlMITaskOutputMigrationLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentJobs":
            suggest = "agent_jobs"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "orphanedUsersInfo":
            suggest = "orphaned_users_info"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "serverRoleResults":
            suggest = "server_role_results"
        elif key == "sourceServerBrandVersion":
            suggest = "source_server_brand_version"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerVersion":
            suggest = "target_server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMITaskOutputMigrationLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMITaskOutputMigrationLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMITaskOutputMigrationLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_jobs: Mapping[str, str],
                 databases: Mapping[str, str],
                 ended_on: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 logins: Mapping[str, str],
                 message: str,
                 orphaned_users_info: Sequence['outputs.OrphanedUserInfoResponse'],
                 result_type: str,
                 server_role_results: Mapping[str, 'outputs.StartMigrationScenarioServerRoleResultResponse'],
                 source_server_brand_version: str,
                 source_server_version: str,
                 started_on: str,
                 state: str,
                 status: str,
                 target_server_brand_version: str,
                 target_server_version: str):
        """
        :param Mapping[str, str] agent_jobs: Selected agent jobs as a map from name to id
        :param Mapping[str, str] databases: Selected databases as a map from database name to database id
        :param str ended_on: Migration end time
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings.
        :param str id: Result identifier
        :param Mapping[str, str] logins: Selected logins as a map from name to id
        :param str message: Migration progress message
        :param Sequence['OrphanedUserInfoResponse'] orphaned_users_info: List of orphaned users.
        :param str result_type: Result type
               Expected value is 'MigrationLevelOutput'.
        :param Mapping[str, 'StartMigrationScenarioServerRoleResultResponse'] server_role_results: Map of server role migration results.
        :param str source_server_brand_version: Source server brand version
        :param str source_server_version: Source server version
        :param str started_on: Migration start time
        :param str state: Current state of migration
        :param str status: Current status of migration
        :param str target_server_brand_version: Target server brand version
        :param str target_server_version: Target server version
        """
        MigrateSqlServerSqlMITaskOutputMigrationLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_jobs=agent_jobs,
            databases=databases,
            ended_on=ended_on,
            exceptions_and_warnings=exceptions_and_warnings,
            id=id,
            logins=logins,
            message=message,
            orphaned_users_info=orphaned_users_info,
            result_type=result_type,
            server_role_results=server_role_results,
            source_server_brand_version=source_server_brand_version,
            source_server_version=source_server_version,
            started_on=started_on,
            state=state,
            status=status,
            target_server_brand_version=target_server_brand_version,
            target_server_version=target_server_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_jobs: Optional[Mapping[str, str]] = None,
             databases: Optional[Mapping[str, str]] = None,
             ended_on: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             logins: Optional[Mapping[str, str]] = None,
             message: Optional[str] = None,
             orphaned_users_info: Optional[Sequence['outputs.OrphanedUserInfoResponse']] = None,
             result_type: Optional[str] = None,
             server_role_results: Optional[Mapping[str, 'outputs.StartMigrationScenarioServerRoleResultResponse']] = None,
             source_server_brand_version: Optional[str] = None,
             source_server_version: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             status: Optional[str] = None,
             target_server_brand_version: Optional[str] = None,
             target_server_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if agent_jobs is None and 'agentJobs' in kwargs:
            agent_jobs = kwargs['agentJobs']
        if agent_jobs is None:
            raise TypeError("Missing 'agent_jobs' argument")
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if logins is None:
            raise TypeError("Missing 'logins' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if orphaned_users_info is None and 'orphanedUsersInfo' in kwargs:
            orphaned_users_info = kwargs['orphanedUsersInfo']
        if orphaned_users_info is None:
            raise TypeError("Missing 'orphaned_users_info' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if server_role_results is None and 'serverRoleResults' in kwargs:
            server_role_results = kwargs['serverRoleResults']
        if server_role_results is None:
            raise TypeError("Missing 'server_role_results' argument")
        if source_server_brand_version is None and 'sourceServerBrandVersion' in kwargs:
            source_server_brand_version = kwargs['sourceServerBrandVersion']
        if source_server_brand_version is None:
            raise TypeError("Missing 'source_server_brand_version' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")

        _setter("agent_jobs", agent_jobs)
        _setter("databases", databases)
        _setter("ended_on", ended_on)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("id", id)
        _setter("logins", logins)
        _setter("message", message)
        _setter("orphaned_users_info", orphaned_users_info)
        _setter("result_type", 'MigrationLevelOutput')
        _setter("server_role_results", server_role_results)
        _setter("source_server_brand_version", source_server_brand_version)
        _setter("source_server_version", source_server_version)
        _setter("started_on", started_on)
        _setter("state", state)
        _setter("status", status)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_version", target_server_version)

    @property
    @pulumi.getter(name="agentJobs")
    def agent_jobs(self) -> Mapping[str, str]:
        """
        Selected agent jobs as a map from name to id
        """
        return pulumi.get(self, "agent_jobs")

    @property
    @pulumi.getter
    def databases(self) -> Mapping[str, str]:
        """
        Selected databases as a map from database name to database id
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings.
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logins(self) -> Mapping[str, str]:
        """
        Selected logins as a map from name to id
        """
        return pulumi.get(self, "logins")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="orphanedUsersInfo")
    def orphaned_users_info(self) -> Sequence['outputs.OrphanedUserInfoResponse']:
        """
        List of orphaned users.
        """
        return pulumi.get(self, "orphaned_users_info")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="serverRoleResults")
    def server_role_results(self) -> Mapping[str, 'outputs.StartMigrationScenarioServerRoleResultResponse']:
        """
        Map of server role migration results.
        """
        return pulumi.get(self, "server_role_results")

    @property
    @pulumi.getter(name="sourceServerBrandVersion")
    def source_server_brand_version(self) -> str:
        """
        Source server brand version
        """
        return pulumi.get(self, "source_server_brand_version")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of migration
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")


@pulumi.output_type
class MigrateSqlServerSqlMITaskPropertiesResponse(dict):
    """
    Properties for task that migrates SQL Server databases to Azure SQL Database Managed Instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"
        elif key == "createdOn":
            suggest = "created_on"
        elif key == "isCloneable":
            suggest = "is_cloneable"
        elif key == "parentTaskId":
            suggest = "parent_task_id"
        elif key == "taskId":
            suggest = "task_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSqlServerSqlMITaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSqlServerSqlMITaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSqlServerSqlMITaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 created_on: Optional[str] = None,
                 input: Optional['outputs.MigrateSqlServerSqlMITaskInputResponse'] = None,
                 is_cloneable: Optional[bool] = None,
                 parent_task_id: Optional[str] = None,
                 task_id: Optional[str] = None):
        """
        Properties for task that migrates SQL Server databases to Azure SQL Database Managed Instance
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['MigrateSqlServerSqlMITaskOutputAgentJobLevelResponse', 'MigrateSqlServerSqlMITaskOutputDatabaseLevelResponse', 'MigrateSqlServerSqlMITaskOutputErrorResponse', 'MigrateSqlServerSqlMITaskOutputLoginLevelResponse', 'MigrateSqlServerSqlMITaskOutputMigrationLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.SqlServer.AzureSqlDbMI'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param str created_on: DateTime in UTC when the task was created
        :param 'MigrateSqlServerSqlMITaskInputResponse' input: Task input
        :param bool is_cloneable: whether the task can be cloned or not
        :param str parent_task_id: parent task id
        :param str task_id: task id
        """
        MigrateSqlServerSqlMITaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            created_on=created_on,
            input=input,
            is_cloneable=is_cloneable,
            parent_task_id=parent_task_id,
            task_id=task_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             created_on: Optional[str] = None,
             input: Optional['outputs.MigrateSqlServerSqlMITaskInputResponse'] = None,
             is_cloneable: Optional[bool] = None,
             parent_task_id: Optional[str] = None,
             task_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']
        if created_on is None and 'createdOn' in kwargs:
            created_on = kwargs['createdOn']
        if is_cloneable is None and 'isCloneable' in kwargs:
            is_cloneable = kwargs['isCloneable']
        if parent_task_id is None and 'parentTaskId' in kwargs:
            parent_task_id = kwargs['parentTaskId']
        if task_id is None and 'taskId' in kwargs:
            task_id = kwargs['taskId']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.SqlServer.AzureSqlDbMI')
        if client_data is not None:
            _setter("client_data", client_data)
        if created_on is not None:
            _setter("created_on", created_on)
        if input is not None:
            _setter("input", input)
        if is_cloneable is not None:
            _setter("is_cloneable", is_cloneable)
        if parent_task_id is not None:
            _setter("parent_task_id", parent_task_id)
        if task_id is not None:
            _setter("task_id", task_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.SqlServer.AzureSqlDbMI'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> Optional[str]:
        """
        DateTime in UTC when the task was created
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateSqlServerSqlMITaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")

    @property
    @pulumi.getter(name="isCloneable")
    def is_cloneable(self) -> Optional[bool]:
        """
        whether the task can be cloned or not
        """
        return pulumi.get(self, "is_cloneable")

    @property
    @pulumi.getter(name="parentTaskId")
    def parent_task_id(self) -> Optional[str]:
        """
        parent task id
        """
        return pulumi.get(self, "parent_task_id")

    @property
    @pulumi.getter(name="taskId")
    def task_id(self) -> Optional[str]:
        """
        task id
        """
        return pulumi.get(self, "task_id")


@pulumi.output_type
class MigrateSsisTaskInputResponse(dict):
    """
    Input for task that migrates SSIS packages from SQL Server to Azure SQL Database Managed Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "ssisMigrationInfo":
            suggest = "ssis_migration_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSsisTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSsisTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSsisTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 ssis_migration_info: 'outputs.SsisMigrationInfoResponse',
                 target_connection_info: 'outputs.SqlConnectionInfoResponse'):
        """
        Input for task that migrates SSIS packages from SQL Server to Azure SQL Database Managed Instance.
        :param 'SqlConnectionInfoResponse' source_connection_info: Information for connecting to source
        :param 'SsisMigrationInfoResponse' ssis_migration_info: SSIS package migration information.
        :param 'SqlConnectionInfoResponse' target_connection_info: Information for connecting to target
        """
        MigrateSsisTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_connection_info=source_connection_info,
            ssis_migration_info=ssis_migration_info,
            target_connection_info=target_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             ssis_migration_info: Optional['outputs.SsisMigrationInfoResponse'] = None,
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if ssis_migration_info is None and 'ssisMigrationInfo' in kwargs:
            ssis_migration_info = kwargs['ssisMigrationInfo']
        if ssis_migration_info is None:
            raise TypeError("Missing 'ssis_migration_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")

        _setter("source_connection_info", source_connection_info)
        _setter("ssis_migration_info", ssis_migration_info)
        _setter("target_connection_info", target_connection_info)

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to source
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="ssisMigrationInfo")
    def ssis_migration_info(self) -> 'outputs.SsisMigrationInfoResponse':
        """
        SSIS package migration information.
        """
        return pulumi.get(self, "ssis_migration_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to target
        """
        return pulumi.get(self, "target_connection_info")


@pulumi.output_type
class MigrateSsisTaskOutputMigrationLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "sourceServerBrandVersion":
            suggest = "source_server_brand_version"
        elif key == "sourceServerVersion":
            suggest = "source_server_version"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetServerBrandVersion":
            suggest = "target_server_brand_version"
        elif key == "targetServerVersion":
            suggest = "target_server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSsisTaskOutputMigrationLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSsisTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSsisTaskOutputMigrationLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 message: str,
                 result_type: str,
                 source_server_brand_version: str,
                 source_server_version: str,
                 stage: str,
                 started_on: str,
                 status: str,
                 target_server_brand_version: str,
                 target_server_version: str):
        """
        :param str ended_on: Migration end time
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings.
        :param str id: Result identifier
        :param str message: Migration progress message
        :param str result_type: Result type
               Expected value is 'MigrationLevelOutput'.
        :param str source_server_brand_version: Source server brand version
        :param str source_server_version: Source server version
        :param str stage: Stage of SSIS migration.
        :param str started_on: Migration start time
        :param str status: Current status of migration
        :param str target_server_brand_version: Target server brand version
        :param str target_server_version: Target server version
        """
        MigrateSsisTaskOutputMigrationLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            exceptions_and_warnings=exceptions_and_warnings,
            id=id,
            message=message,
            result_type=result_type,
            source_server_brand_version=source_server_brand_version,
            source_server_version=source_server_version,
            stage=stage,
            started_on=started_on,
            status=status,
            target_server_brand_version=target_server_brand_version,
            target_server_version=target_server_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             message: Optional[str] = None,
             result_type: Optional[str] = None,
             source_server_brand_version: Optional[str] = None,
             source_server_version: Optional[str] = None,
             stage: Optional[str] = None,
             started_on: Optional[str] = None,
             status: Optional[str] = None,
             target_server_brand_version: Optional[str] = None,
             target_server_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if source_server_brand_version is None and 'sourceServerBrandVersion' in kwargs:
            source_server_brand_version = kwargs['sourceServerBrandVersion']
        if source_server_brand_version is None:
            raise TypeError("Missing 'source_server_brand_version' argument")
        if source_server_version is None and 'sourceServerVersion' in kwargs:
            source_server_version = kwargs['sourceServerVersion']
        if source_server_version is None:
            raise TypeError("Missing 'source_server_version' argument")
        if stage is None:
            raise TypeError("Missing 'stage' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if target_server_brand_version is None and 'targetServerBrandVersion' in kwargs:
            target_server_brand_version = kwargs['targetServerBrandVersion']
        if target_server_brand_version is None:
            raise TypeError("Missing 'target_server_brand_version' argument")
        if target_server_version is None and 'targetServerVersion' in kwargs:
            target_server_version = kwargs['targetServerVersion']
        if target_server_version is None:
            raise TypeError("Missing 'target_server_version' argument")

        _setter("ended_on", ended_on)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("id", id)
        _setter("message", message)
        _setter("result_type", 'MigrationLevelOutput')
        _setter("source_server_brand_version", source_server_brand_version)
        _setter("source_server_version", source_server_version)
        _setter("stage", stage)
        _setter("started_on", started_on)
        _setter("status", status)
        _setter("target_server_brand_version", target_server_brand_version)
        _setter("target_server_version", target_server_version)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings.
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'MigrationLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter(name="sourceServerBrandVersion")
    def source_server_brand_version(self) -> str:
        """
        Source server brand version
        """
        return pulumi.get(self, "source_server_brand_version")

    @property
    @pulumi.getter(name="sourceServerVersion")
    def source_server_version(self) -> str:
        """
        Source server version
        """
        return pulumi.get(self, "source_server_version")

    @property
    @pulumi.getter
    def stage(self) -> str:
        """
        Stage of SSIS migration.
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of migration
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="targetServerBrandVersion")
    def target_server_brand_version(self) -> str:
        """
        Target server brand version
        """
        return pulumi.get(self, "target_server_brand_version")

    @property
    @pulumi.getter(name="targetServerVersion")
    def target_server_version(self) -> str:
        """
        Target server version
        """
        return pulumi.get(self, "target_server_version")


@pulumi.output_type
class MigrateSsisTaskOutputProjectLevelResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"
        elif key == "folderName":
            suggest = "folder_name"
        elif key == "projectName":
            suggest = "project_name"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSsisTaskOutputProjectLevelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSsisTaskOutputProjectLevelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSsisTaskOutputProjectLevelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 folder_name: str,
                 id: str,
                 message: str,
                 project_name: str,
                 result_type: str,
                 stage: str,
                 started_on: str,
                 state: str):
        """
        :param str ended_on: Migration end time
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings
        :param str folder_name: Name of the folder
        :param str id: Result identifier
        :param str message: Migration progress message
        :param str project_name: Name of the project
        :param str result_type: Result type
               Expected value is 'SsisProjectLevelOutput'.
        :param str stage: Stage of SSIS migration.
        :param str started_on: Migration start time
        :param str state: Current state of migration
        """
        MigrateSsisTaskOutputProjectLevelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            exceptions_and_warnings=exceptions_and_warnings,
            folder_name=folder_name,
            id=id,
            message=message,
            project_name=project_name,
            result_type=result_type,
            stage=stage,
            started_on=started_on,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             folder_name: Optional[str] = None,
             id: Optional[str] = None,
             message: Optional[str] = None,
             project_name: Optional[str] = None,
             result_type: Optional[str] = None,
             stage: Optional[str] = None,
             started_on: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if folder_name is None and 'folderName' in kwargs:
            folder_name = kwargs['folderName']
        if folder_name is None:
            raise TypeError("Missing 'folder_name' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if project_name is None and 'projectName' in kwargs:
            project_name = kwargs['projectName']
        if project_name is None:
            raise TypeError("Missing 'project_name' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if stage is None:
            raise TypeError("Missing 'stage' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("ended_on", ended_on)
        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("folder_name", folder_name)
        _setter("id", id)
        _setter("message", message)
        _setter("project_name", project_name)
        _setter("result_type", 'SsisProjectLevelOutput')
        _setter("stage", stage)
        _setter("started_on", started_on)
        _setter("state", state)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Migration end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter(name="folderName")
    def folder_name(self) -> str:
        """
        Name of the folder
        """
        return pulumi.get(self, "folder_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Migration progress message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        Name of the project
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        Result type
        Expected value is 'SsisProjectLevelOutput'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def stage(self) -> str:
        """
        Stage of SSIS migration.
        """
        return pulumi.get(self, "stage")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Migration start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MigrateSsisTaskPropertiesResponse(dict):
    """
    Properties for task that migrates SSIS packages from SQL Server databases to Azure SQL Database Managed Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSsisTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSsisTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSsisTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence[Any],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.MigrateSsisTaskInputResponse'] = None):
        """
        Properties for task that migrates SSIS packages from SQL Server databases to Azure SQL Database Managed Instance.
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence[Union['MigrateSsisTaskOutputMigrationLevelResponse', 'MigrateSsisTaskOutputProjectLevelResponse']] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Migrate.Ssis'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'MigrateSsisTaskInputResponse' input: Task input
        """
        MigrateSsisTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence[Any]] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.MigrateSsisTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Migrate.Ssis')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence[Any]:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Migrate.Ssis'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateSsisTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class MigrateSyncCompleteCommandInputResponse(dict):
    """
    Input for command that completes sync migration for a database.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "commitTimeStamp":
            suggest = "commit_time_stamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSyncCompleteCommandInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSyncCompleteCommandInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSyncCompleteCommandInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 commit_time_stamp: Optional[str] = None):
        """
        Input for command that completes sync migration for a database.
        :param str database_name: Name of database
        :param str commit_time_stamp: Time stamp to complete
        """
        MigrateSyncCompleteCommandInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            commit_time_stamp=commit_time_stamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             commit_time_stamp: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if commit_time_stamp is None and 'commitTimeStamp' in kwargs:
            commit_time_stamp = kwargs['commitTimeStamp']

        _setter("database_name", database_name)
        if commit_time_stamp is not None:
            _setter("commit_time_stamp", commit_time_stamp)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Name of database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="commitTimeStamp")
    def commit_time_stamp(self) -> Optional[str]:
        """
        Time stamp to complete
        """
        return pulumi.get(self, "commit_time_stamp")


@pulumi.output_type
class MigrateSyncCompleteCommandOutputResponse(dict):
    """
    Output for command that completes sync migration for a database.
    """
    def __init__(__self__, *,
                 errors: Sequence['outputs.ReportableExceptionResponse'],
                 id: str):
        """
        Output for command that completes sync migration for a database.
        :param Sequence['ReportableExceptionResponse'] errors: List of errors that happened during the command execution
        :param str id: Result identifier
        """
        MigrateSyncCompleteCommandOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            errors=errors,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("errors", errors)
        _setter("id", id)

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        List of errors that happened during the command execution
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class MigrateSyncCompleteCommandPropertiesResponse(dict):
    """
    Properties for the command that completes sync migration for a database.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandType":
            suggest = "command_type"
        elif key == "commandId":
            suggest = "command_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrateSyncCompleteCommandPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrateSyncCompleteCommandPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrateSyncCompleteCommandPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_type: str,
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: 'outputs.MigrateSyncCompleteCommandOutputResponse',
                 state: str,
                 command_id: Optional[str] = None,
                 input: Optional['outputs.MigrateSyncCompleteCommandInputResponse'] = None):
        """
        Properties for the command that completes sync migration for a database.
        :param str command_type: Command type.
               Expected value is 'Migrate.Sync.Complete.Database'.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param 'MigrateSyncCompleteCommandOutputResponse' output: Command output. This is ignored if submitted.
        :param str state: The state of the command. This is ignored if submitted.
        :param str command_id: Command id
        :param 'MigrateSyncCompleteCommandInputResponse' input: Command input
        """
        MigrateSyncCompleteCommandPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            command_type=command_type,
            errors=errors,
            output=output,
            state=state,
            command_id=command_id,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             command_type: Optional[str] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional['outputs.MigrateSyncCompleteCommandOutputResponse'] = None,
             state: Optional[str] = None,
             command_id: Optional[str] = None,
             input: Optional['outputs.MigrateSyncCompleteCommandInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if command_type is None and 'commandType' in kwargs:
            command_type = kwargs['commandType']
        if command_type is None:
            raise TypeError("Missing 'command_type' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if command_id is None and 'commandId' in kwargs:
            command_id = kwargs['commandId']

        _setter("command_type", 'Migrate.Sync.Complete.Database')
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        if command_id is not None:
            _setter("command_id", command_id)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter(name="commandType")
    def command_type(self) -> str:
        """
        Command type.
        Expected value is 'Migrate.Sync.Complete.Database'.
        """
        return pulumi.get(self, "command_type")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> 'outputs.MigrateSyncCompleteCommandOutputResponse':
        """
        Command output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the command. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="commandId")
    def command_id(self) -> Optional[str]:
        """
        Command id
        """
        return pulumi.get(self, "command_id")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateSyncCompleteCommandInputResponse']:
        """
        Command input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class MigrationEligibilityInfoResponse(dict):
    """
    Information about migration eligibility of a server object
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEligibleForMigration":
            suggest = "is_eligible_for_migration"
        elif key == "validationMessages":
            suggest = "validation_messages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationEligibilityInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationEligibilityInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationEligibilityInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_eligible_for_migration: bool,
                 validation_messages: Sequence[str]):
        """
        Information about migration eligibility of a server object
        :param bool is_eligible_for_migration: Whether object is eligible for migration or not.
        :param Sequence[str] validation_messages: Information about eligibility failure for the server object.
        """
        MigrationEligibilityInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_eligible_for_migration=is_eligible_for_migration,
            validation_messages=validation_messages,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_eligible_for_migration: Optional[bool] = None,
             validation_messages: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_eligible_for_migration is None and 'isEligibleForMigration' in kwargs:
            is_eligible_for_migration = kwargs['isEligibleForMigration']
        if is_eligible_for_migration is None:
            raise TypeError("Missing 'is_eligible_for_migration' argument")
        if validation_messages is None and 'validationMessages' in kwargs:
            validation_messages = kwargs['validationMessages']
        if validation_messages is None:
            raise TypeError("Missing 'validation_messages' argument")

        _setter("is_eligible_for_migration", is_eligible_for_migration)
        _setter("validation_messages", validation_messages)

    @property
    @pulumi.getter(name="isEligibleForMigration")
    def is_eligible_for_migration(self) -> bool:
        """
        Whether object is eligible for migration or not.
        """
        return pulumi.get(self, "is_eligible_for_migration")

    @property
    @pulumi.getter(name="validationMessages")
    def validation_messages(self) -> Sequence[str]:
        """
        Information about eligibility failure for the server object.
        """
        return pulumi.get(self, "validation_messages")


@pulumi.output_type
class MigrationReportResultResponse(dict):
    """
    Migration validation report result, contains the url for downloading the generated report.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reportUrl":
            suggest = "report_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationReportResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationReportResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationReportResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 report_url: Optional[str] = None):
        """
        Migration validation report result, contains the url for downloading the generated report.
        :param str id: Migration validation result identifier
        :param str report_url: The url of the report.
        """
        MigrationReportResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            report_url=report_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             report_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if report_url is None and 'reportUrl' in kwargs:
            report_url = kwargs['reportUrl']

        if id is not None:
            _setter("id", id)
        if report_url is not None:
            _setter("report_url", report_url)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Migration validation result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="reportUrl")
    def report_url(self) -> Optional[str]:
        """
        The url of the report.
        """
        return pulumi.get(self, "report_url")


@pulumi.output_type
class MigrationValidationDatabaseSummaryResultResponse(dict):
    """
    Migration Validation Database level summary result
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endedOn":
            suggest = "ended_on"
        elif key == "migrationId":
            suggest = "migration_id"
        elif key == "sourceDatabaseName":
            suggest = "source_database_name"
        elif key == "startedOn":
            suggest = "started_on"
        elif key == "targetDatabaseName":
            suggest = "target_database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationValidationDatabaseSummaryResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationValidationDatabaseSummaryResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationValidationDatabaseSummaryResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ended_on: str,
                 id: str,
                 migration_id: str,
                 source_database_name: str,
                 started_on: str,
                 status: str,
                 target_database_name: str):
        """
        Migration Validation Database level summary result
        :param str ended_on: Validation end time
        :param str id: Result identifier
        :param str migration_id: Migration Identifier
        :param str source_database_name: Name of the source database
        :param str started_on: Validation start time
        :param str status: Current status of validation at the database level
        :param str target_database_name: Name of the target database
        """
        MigrationValidationDatabaseSummaryResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ended_on=ended_on,
            id=id,
            migration_id=migration_id,
            source_database_name=source_database_name,
            started_on=started_on,
            status=status,
            target_database_name=target_database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ended_on: Optional[str] = None,
             id: Optional[str] = None,
             migration_id: Optional[str] = None,
             source_database_name: Optional[str] = None,
             started_on: Optional[str] = None,
             status: Optional[str] = None,
             target_database_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ended_on is None and 'endedOn' in kwargs:
            ended_on = kwargs['endedOn']
        if ended_on is None:
            raise TypeError("Missing 'ended_on' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if migration_id is None and 'migrationId' in kwargs:
            migration_id = kwargs['migrationId']
        if migration_id is None:
            raise TypeError("Missing 'migration_id' argument")
        if source_database_name is None and 'sourceDatabaseName' in kwargs:
            source_database_name = kwargs['sourceDatabaseName']
        if source_database_name is None:
            raise TypeError("Missing 'source_database_name' argument")
        if started_on is None and 'startedOn' in kwargs:
            started_on = kwargs['startedOn']
        if started_on is None:
            raise TypeError("Missing 'started_on' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if target_database_name is None and 'targetDatabaseName' in kwargs:
            target_database_name = kwargs['targetDatabaseName']
        if target_database_name is None:
            raise TypeError("Missing 'target_database_name' argument")

        _setter("ended_on", ended_on)
        _setter("id", id)
        _setter("migration_id", migration_id)
        _setter("source_database_name", source_database_name)
        _setter("started_on", started_on)
        _setter("status", status)
        _setter("target_database_name", target_database_name)

    @property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> str:
        """
        Validation end time
        """
        return pulumi.get(self, "ended_on")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="migrationId")
    def migration_id(self) -> str:
        """
        Migration Identifier
        """
        return pulumi.get(self, "migration_id")

    @property
    @pulumi.getter(name="sourceDatabaseName")
    def source_database_name(self) -> str:
        """
        Name of the source database
        """
        return pulumi.get(self, "source_database_name")

    @property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> str:
        """
        Validation start time
        """
        return pulumi.get(self, "started_on")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of validation at the database level
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="targetDatabaseName")
    def target_database_name(self) -> str:
        """
        Name of the target database
        """
        return pulumi.get(self, "target_database_name")


@pulumi.output_type
class MigrationValidationOptionsResponse(dict):
    """
    Types of validations to run after the migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableDataIntegrityValidation":
            suggest = "enable_data_integrity_validation"
        elif key == "enableQueryAnalysisValidation":
            suggest = "enable_query_analysis_validation"
        elif key == "enableSchemaValidation":
            suggest = "enable_schema_validation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationValidationOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationValidationOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationValidationOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_data_integrity_validation: Optional[bool] = None,
                 enable_query_analysis_validation: Optional[bool] = None,
                 enable_schema_validation: Optional[bool] = None):
        """
        Types of validations to run after the migration
        :param bool enable_data_integrity_validation: Allows to perform a checksum based data integrity validation between source and target for the selected database / tables .
        :param bool enable_query_analysis_validation: Allows to perform a quick and intelligent query analysis by retrieving queries from the source database and executes them in the target. The result will have execution statistics for executions in source and target databases for the extracted queries.
        :param bool enable_schema_validation: Allows to compare the schema information between source and target.
        """
        MigrationValidationOptionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_data_integrity_validation=enable_data_integrity_validation,
            enable_query_analysis_validation=enable_query_analysis_validation,
            enable_schema_validation=enable_schema_validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_data_integrity_validation: Optional[bool] = None,
             enable_query_analysis_validation: Optional[bool] = None,
             enable_schema_validation: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enable_data_integrity_validation is None and 'enableDataIntegrityValidation' in kwargs:
            enable_data_integrity_validation = kwargs['enableDataIntegrityValidation']
        if enable_query_analysis_validation is None and 'enableQueryAnalysisValidation' in kwargs:
            enable_query_analysis_validation = kwargs['enableQueryAnalysisValidation']
        if enable_schema_validation is None and 'enableSchemaValidation' in kwargs:
            enable_schema_validation = kwargs['enableSchemaValidation']

        if enable_data_integrity_validation is not None:
            _setter("enable_data_integrity_validation", enable_data_integrity_validation)
        if enable_query_analysis_validation is not None:
            _setter("enable_query_analysis_validation", enable_query_analysis_validation)
        if enable_schema_validation is not None:
            _setter("enable_schema_validation", enable_schema_validation)

    @property
    @pulumi.getter(name="enableDataIntegrityValidation")
    def enable_data_integrity_validation(self) -> Optional[bool]:
        """
        Allows to perform a checksum based data integrity validation between source and target for the selected database / tables .
        """
        return pulumi.get(self, "enable_data_integrity_validation")

    @property
    @pulumi.getter(name="enableQueryAnalysisValidation")
    def enable_query_analysis_validation(self) -> Optional[bool]:
        """
        Allows to perform a quick and intelligent query analysis by retrieving queries from the source database and executes them in the target. The result will have execution statistics for executions in source and target databases for the extracted queries.
        """
        return pulumi.get(self, "enable_query_analysis_validation")

    @property
    @pulumi.getter(name="enableSchemaValidation")
    def enable_schema_validation(self) -> Optional[bool]:
        """
        Allows to compare the schema information between source and target.
        """
        return pulumi.get(self, "enable_schema_validation")


@pulumi.output_type
class MigrationValidationResultResponse(dict):
    """
    Migration Validation Result
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "migrationId":
            suggest = "migration_id"
        elif key == "summaryResults":
            suggest = "summary_results"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationValidationResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationValidationResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationValidationResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 migration_id: str,
                 status: str,
                 summary_results: Optional[Mapping[str, 'outputs.MigrationValidationDatabaseSummaryResultResponse']] = None):
        """
        Migration Validation Result
        :param str id: Migration validation result identifier
        :param str migration_id: Migration Identifier
        :param str status: Current status of validation at the migration level. Status from the database validation result status will be aggregated here.
        :param Mapping[str, 'MigrationValidationDatabaseSummaryResultResponse'] summary_results: Validation summary results for each database
        """
        MigrationValidationResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            migration_id=migration_id,
            status=status,
            summary_results=summary_results,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             migration_id: Optional[str] = None,
             status: Optional[str] = None,
             summary_results: Optional[Mapping[str, 'outputs.MigrationValidationDatabaseSummaryResultResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if migration_id is None and 'migrationId' in kwargs:
            migration_id = kwargs['migrationId']
        if migration_id is None:
            raise TypeError("Missing 'migration_id' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if summary_results is None and 'summaryResults' in kwargs:
            summary_results = kwargs['summaryResults']

        _setter("id", id)
        _setter("migration_id", migration_id)
        _setter("status", status)
        if summary_results is not None:
            _setter("summary_results", summary_results)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Migration validation result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="migrationId")
    def migration_id(self) -> str:
        """
        Migration Identifier
        """
        return pulumi.get(self, "migration_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of validation at the migration level. Status from the database validation result status will be aggregated here.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="summaryResults")
    def summary_results(self) -> Optional[Mapping[str, 'outputs.MigrationValidationDatabaseSummaryResultResponse']]:
        """
        Validation summary results for each database
        """
        return pulumi.get(self, "summary_results")


@pulumi.output_type
class MongoDbClusterInfoResponse(dict):
    """
    Describes a MongoDB data source
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supportsSharding":
            suggest = "supports_sharding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbClusterInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbClusterInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbClusterInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Sequence['outputs.MongoDbDatabaseInfoResponse'],
                 supports_sharding: bool,
                 type: str,
                 version: str):
        """
        Describes a MongoDB data source
        :param Sequence['MongoDbDatabaseInfoResponse'] databases: A list of non-system databases in the cluster
        :param bool supports_sharding: Whether the cluster supports sharded collections
        :param str type: The type of data source
        :param str version: The version of the data source in the form x.y.z (e.g. 3.6.7). Not used if Type is BlobContainer.
        """
        MongoDbClusterInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases=databases,
            supports_sharding=supports_sharding,
            type=type,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases: Optional[Sequence['outputs.MongoDbDatabaseInfoResponse']] = None,
             supports_sharding: Optional[bool] = None,
             type: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if supports_sharding is None and 'supportsSharding' in kwargs:
            supports_sharding = kwargs['supportsSharding']
        if supports_sharding is None:
            raise TypeError("Missing 'supports_sharding' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if version is None:
            raise TypeError("Missing 'version' argument")

        _setter("databases", databases)
        _setter("supports_sharding", supports_sharding)
        _setter("type", type)
        _setter("version", version)

    @property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.MongoDbDatabaseInfoResponse']:
        """
        A list of non-system databases in the cluster
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="supportsSharding")
    def supports_sharding(self) -> bool:
        """
        Whether the cluster supports sharded collections
        """
        return pulumi.get(self, "supports_sharding")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of data source
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version of the data source in the form x.y.z (e.g. 3.6.7). Not used if Type is BlobContainer.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MongoDbCollectionInfoResponse(dict):
    """
    Describes a supported collection within a MongoDB database
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "averageDocumentSize":
            suggest = "average_document_size"
        elif key == "dataSize":
            suggest = "data_size"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "documentCount":
            suggest = "document_count"
        elif key == "isCapped":
            suggest = "is_capped"
        elif key == "isSystemCollection":
            suggest = "is_system_collection"
        elif key == "isView":
            suggest = "is_view"
        elif key == "qualifiedName":
            suggest = "qualified_name"
        elif key == "supportsSharding":
            suggest = "supports_sharding"
        elif key == "shardKey":
            suggest = "shard_key"
        elif key == "viewOf":
            suggest = "view_of"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbCollectionInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbCollectionInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbCollectionInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 average_document_size: float,
                 data_size: float,
                 database_name: str,
                 document_count: float,
                 is_capped: bool,
                 is_system_collection: bool,
                 is_view: bool,
                 name: str,
                 qualified_name: str,
                 supports_sharding: bool,
                 shard_key: Optional['outputs.MongoDbShardKeyInfoResponse'] = None,
                 view_of: Optional[str] = None):
        """
        Describes a supported collection within a MongoDB database
        :param float average_document_size: The average document size, or -1 if the average size is unknown
        :param float data_size: The estimated total data size, in bytes, or -1 if the size is unknown.
        :param str database_name: The name of the database containing the collection
        :param float document_count: The estimated total number of documents, or -1 if the document count is unknown
        :param bool is_capped: Whether the collection is a capped collection (i.e. whether it has a fixed size and acts like a circular buffer)
        :param bool is_system_collection: Whether the collection is system collection
        :param bool is_view: Whether the collection is a view of another collection
        :param str name: The unqualified name of the database or collection
        :param str qualified_name: The qualified name of the database or collection. For a collection, this is the database-qualified name.
        :param bool supports_sharding: Whether the database has sharding enabled. Note that the migration task will enable sharding on the target if necessary.
        :param 'MongoDbShardKeyInfoResponse' shard_key: The shard key on the collection, or null if the collection is not sharded
        :param str view_of: The name of the collection that this is a view of, if IsView is true
        """
        MongoDbCollectionInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            average_document_size=average_document_size,
            data_size=data_size,
            database_name=database_name,
            document_count=document_count,
            is_capped=is_capped,
            is_system_collection=is_system_collection,
            is_view=is_view,
            name=name,
            qualified_name=qualified_name,
            supports_sharding=supports_sharding,
            shard_key=shard_key,
            view_of=view_of,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             average_document_size: Optional[float] = None,
             data_size: Optional[float] = None,
             database_name: Optional[str] = None,
             document_count: Optional[float] = None,
             is_capped: Optional[bool] = None,
             is_system_collection: Optional[bool] = None,
             is_view: Optional[bool] = None,
             name: Optional[str] = None,
             qualified_name: Optional[str] = None,
             supports_sharding: Optional[bool] = None,
             shard_key: Optional['outputs.MongoDbShardKeyInfoResponse'] = None,
             view_of: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if average_document_size is None and 'averageDocumentSize' in kwargs:
            average_document_size = kwargs['averageDocumentSize']
        if average_document_size is None:
            raise TypeError("Missing 'average_document_size' argument")
        if data_size is None and 'dataSize' in kwargs:
            data_size = kwargs['dataSize']
        if data_size is None:
            raise TypeError("Missing 'data_size' argument")
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if document_count is None and 'documentCount' in kwargs:
            document_count = kwargs['documentCount']
        if document_count is None:
            raise TypeError("Missing 'document_count' argument")
        if is_capped is None and 'isCapped' in kwargs:
            is_capped = kwargs['isCapped']
        if is_capped is None:
            raise TypeError("Missing 'is_capped' argument")
        if is_system_collection is None and 'isSystemCollection' in kwargs:
            is_system_collection = kwargs['isSystemCollection']
        if is_system_collection is None:
            raise TypeError("Missing 'is_system_collection' argument")
        if is_view is None and 'isView' in kwargs:
            is_view = kwargs['isView']
        if is_view is None:
            raise TypeError("Missing 'is_view' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if qualified_name is None and 'qualifiedName' in kwargs:
            qualified_name = kwargs['qualifiedName']
        if qualified_name is None:
            raise TypeError("Missing 'qualified_name' argument")
        if supports_sharding is None and 'supportsSharding' in kwargs:
            supports_sharding = kwargs['supportsSharding']
        if supports_sharding is None:
            raise TypeError("Missing 'supports_sharding' argument")
        if shard_key is None and 'shardKey' in kwargs:
            shard_key = kwargs['shardKey']
        if view_of is None and 'viewOf' in kwargs:
            view_of = kwargs['viewOf']

        _setter("average_document_size", average_document_size)
        _setter("data_size", data_size)
        _setter("database_name", database_name)
        _setter("document_count", document_count)
        _setter("is_capped", is_capped)
        _setter("is_system_collection", is_system_collection)
        _setter("is_view", is_view)
        _setter("name", name)
        _setter("qualified_name", qualified_name)
        _setter("supports_sharding", supports_sharding)
        if shard_key is not None:
            _setter("shard_key", shard_key)
        if view_of is not None:
            _setter("view_of", view_of)

    @property
    @pulumi.getter(name="averageDocumentSize")
    def average_document_size(self) -> float:
        """
        The average document size, or -1 if the average size is unknown
        """
        return pulumi.get(self, "average_document_size")

    @property
    @pulumi.getter(name="dataSize")
    def data_size(self) -> float:
        """
        The estimated total data size, in bytes, or -1 if the size is unknown.
        """
        return pulumi.get(self, "data_size")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of the database containing the collection
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="documentCount")
    def document_count(self) -> float:
        """
        The estimated total number of documents, or -1 if the document count is unknown
        """
        return pulumi.get(self, "document_count")

    @property
    @pulumi.getter(name="isCapped")
    def is_capped(self) -> bool:
        """
        Whether the collection is a capped collection (i.e. whether it has a fixed size and acts like a circular buffer)
        """
        return pulumi.get(self, "is_capped")

    @property
    @pulumi.getter(name="isSystemCollection")
    def is_system_collection(self) -> bool:
        """
        Whether the collection is system collection
        """
        return pulumi.get(self, "is_system_collection")

    @property
    @pulumi.getter(name="isView")
    def is_view(self) -> bool:
        """
        Whether the collection is a view of another collection
        """
        return pulumi.get(self, "is_view")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unqualified name of the database or collection
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="qualifiedName")
    def qualified_name(self) -> str:
        """
        The qualified name of the database or collection. For a collection, this is the database-qualified name.
        """
        return pulumi.get(self, "qualified_name")

    @property
    @pulumi.getter(name="supportsSharding")
    def supports_sharding(self) -> bool:
        """
        Whether the database has sharding enabled. Note that the migration task will enable sharding on the target if necessary.
        """
        return pulumi.get(self, "supports_sharding")

    @property
    @pulumi.getter(name="shardKey")
    def shard_key(self) -> Optional['outputs.MongoDbShardKeyInfoResponse']:
        """
        The shard key on the collection, or null if the collection is not sharded
        """
        return pulumi.get(self, "shard_key")

    @property
    @pulumi.getter(name="viewOf")
    def view_of(self) -> Optional[str]:
        """
        The name of the collection that this is a view of, if IsView is true
        """
        return pulumi.get(self, "view_of")


@pulumi.output_type
class MongoDbCollectionProgressResponse(dict):
    """
    Describes the progress of a collection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bytesCopied":
            suggest = "bytes_copied"
        elif key == "documentsCopied":
            suggest = "documents_copied"
        elif key == "elapsedTime":
            suggest = "elapsed_time"
        elif key == "eventsPending":
            suggest = "events_pending"
        elif key == "eventsReplayed":
            suggest = "events_replayed"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "totalBytes":
            suggest = "total_bytes"
        elif key == "totalDocuments":
            suggest = "total_documents"
        elif key == "lastEventTime":
            suggest = "last_event_time"
        elif key == "lastReplayTime":
            suggest = "last_replay_time"
        elif key == "qualifiedName":
            suggest = "qualified_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbCollectionProgressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbCollectionProgressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbCollectionProgressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bytes_copied: float,
                 documents_copied: float,
                 elapsed_time: str,
                 errors: Mapping[str, 'outputs.MongoDbErrorResponse'],
                 events_pending: float,
                 events_replayed: float,
                 result_type: str,
                 state: str,
                 total_bytes: float,
                 total_documents: float,
                 last_event_time: Optional[str] = None,
                 last_replay_time: Optional[str] = None,
                 name: Optional[str] = None,
                 qualified_name: Optional[str] = None):
        """
        Describes the progress of a collection
        :param float bytes_copied: The number of document bytes copied during the Copying stage
        :param float documents_copied: The number of documents copied during the Copying stage
        :param str elapsed_time: The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
        :param Mapping[str, 'MongoDbErrorResponse'] errors: The errors and warnings that have occurred for the current object. The keys are the error codes.
        :param float events_pending: The number of oplog events awaiting replay
        :param float events_replayed: The number of oplog events replayed so far
        :param str result_type: The type of progress object
               Expected value is 'Collection'.
        :param float total_bytes: The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size was unknown
        :param float total_documents: The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was unknown
        :param str last_event_time: The timestamp of the last oplog event received, or null if no oplog event has been received yet
        :param str last_replay_time: The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
        :param str name: The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the database name. For the overall migration, this is null.
        :param str qualified_name: The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this is the database name. For the overall migration, this is null.
        """
        MongoDbCollectionProgressResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bytes_copied=bytes_copied,
            documents_copied=documents_copied,
            elapsed_time=elapsed_time,
            errors=errors,
            events_pending=events_pending,
            events_replayed=events_replayed,
            result_type=result_type,
            state=state,
            total_bytes=total_bytes,
            total_documents=total_documents,
            last_event_time=last_event_time,
            last_replay_time=last_replay_time,
            name=name,
            qualified_name=qualified_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bytes_copied: Optional[float] = None,
             documents_copied: Optional[float] = None,
             elapsed_time: Optional[str] = None,
             errors: Optional[Mapping[str, 'outputs.MongoDbErrorResponse']] = None,
             events_pending: Optional[float] = None,
             events_replayed: Optional[float] = None,
             result_type: Optional[str] = None,
             state: Optional[str] = None,
             total_bytes: Optional[float] = None,
             total_documents: Optional[float] = None,
             last_event_time: Optional[str] = None,
             last_replay_time: Optional[str] = None,
             name: Optional[str] = None,
             qualified_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bytes_copied is None and 'bytesCopied' in kwargs:
            bytes_copied = kwargs['bytesCopied']
        if bytes_copied is None:
            raise TypeError("Missing 'bytes_copied' argument")
        if documents_copied is None and 'documentsCopied' in kwargs:
            documents_copied = kwargs['documentsCopied']
        if documents_copied is None:
            raise TypeError("Missing 'documents_copied' argument")
        if elapsed_time is None and 'elapsedTime' in kwargs:
            elapsed_time = kwargs['elapsedTime']
        if elapsed_time is None:
            raise TypeError("Missing 'elapsed_time' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if events_pending is None and 'eventsPending' in kwargs:
            events_pending = kwargs['eventsPending']
        if events_pending is None:
            raise TypeError("Missing 'events_pending' argument")
        if events_replayed is None and 'eventsReplayed' in kwargs:
            events_replayed = kwargs['eventsReplayed']
        if events_replayed is None:
            raise TypeError("Missing 'events_replayed' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if total_bytes is None and 'totalBytes' in kwargs:
            total_bytes = kwargs['totalBytes']
        if total_bytes is None:
            raise TypeError("Missing 'total_bytes' argument")
        if total_documents is None and 'totalDocuments' in kwargs:
            total_documents = kwargs['totalDocuments']
        if total_documents is None:
            raise TypeError("Missing 'total_documents' argument")
        if last_event_time is None and 'lastEventTime' in kwargs:
            last_event_time = kwargs['lastEventTime']
        if last_replay_time is None and 'lastReplayTime' in kwargs:
            last_replay_time = kwargs['lastReplayTime']
        if qualified_name is None and 'qualifiedName' in kwargs:
            qualified_name = kwargs['qualifiedName']

        _setter("bytes_copied", bytes_copied)
        _setter("documents_copied", documents_copied)
        _setter("elapsed_time", elapsed_time)
        _setter("errors", errors)
        _setter("events_pending", events_pending)
        _setter("events_replayed", events_replayed)
        _setter("result_type", 'Collection')
        _setter("state", state)
        _setter("total_bytes", total_bytes)
        _setter("total_documents", total_documents)
        if last_event_time is not None:
            _setter("last_event_time", last_event_time)
        if last_replay_time is not None:
            _setter("last_replay_time", last_replay_time)
        if name is not None:
            _setter("name", name)
        if qualified_name is not None:
            _setter("qualified_name", qualified_name)

    @property
    @pulumi.getter(name="bytesCopied")
    def bytes_copied(self) -> float:
        """
        The number of document bytes copied during the Copying stage
        """
        return pulumi.get(self, "bytes_copied")

    @property
    @pulumi.getter(name="documentsCopied")
    def documents_copied(self) -> float:
        """
        The number of documents copied during the Copying stage
        """
        return pulumi.get(self, "documents_copied")

    @property
    @pulumi.getter(name="elapsedTime")
    def elapsed_time(self) -> str:
        """
        The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
        """
        return pulumi.get(self, "elapsed_time")

    @property
    @pulumi.getter
    def errors(self) -> Mapping[str, 'outputs.MongoDbErrorResponse']:
        """
        The errors and warnings that have occurred for the current object. The keys are the error codes.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="eventsPending")
    def events_pending(self) -> float:
        """
        The number of oplog events awaiting replay
        """
        return pulumi.get(self, "events_pending")

    @property
    @pulumi.getter(name="eventsReplayed")
    def events_replayed(self) -> float:
        """
        The number of oplog events replayed so far
        """
        return pulumi.get(self, "events_replayed")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        The type of progress object
        Expected value is 'Collection'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="totalBytes")
    def total_bytes(self) -> float:
        """
        The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size was unknown
        """
        return pulumi.get(self, "total_bytes")

    @property
    @pulumi.getter(name="totalDocuments")
    def total_documents(self) -> float:
        """
        The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was unknown
        """
        return pulumi.get(self, "total_documents")

    @property
    @pulumi.getter(name="lastEventTime")
    def last_event_time(self) -> Optional[str]:
        """
        The timestamp of the last oplog event received, or null if no oplog event has been received yet
        """
        return pulumi.get(self, "last_event_time")

    @property
    @pulumi.getter(name="lastReplayTime")
    def last_replay_time(self) -> Optional[str]:
        """
        The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
        """
        return pulumi.get(self, "last_replay_time")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the database name. For the overall migration, this is null.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="qualifiedName")
    def qualified_name(self) -> Optional[str]:
        """
        The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this is the database name. For the overall migration, this is null.
        """
        return pulumi.get(self, "qualified_name")


@pulumi.output_type
class MongoDbCollectionSettingsResponse(dict):
    """
    Describes how an individual MongoDB collection should be migrated
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canDelete":
            suggest = "can_delete"
        elif key == "shardKey":
            suggest = "shard_key"
        elif key == "targetRUs":
            suggest = "target_rus"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbCollectionSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbCollectionSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbCollectionSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_delete: Optional[bool] = None,
                 shard_key: Optional['outputs.MongoDbShardKeySettingResponse'] = None,
                 target_rus: Optional[int] = None):
        """
        Describes how an individual MongoDB collection should be migrated
        :param bool can_delete: Whether the migrator is allowed to drop the target collection in the course of performing a migration. The default is true.
        :param 'MongoDbShardKeySettingResponse' shard_key: Describes a MongoDB shard key
        :param int target_rus: The RUs that should be configured on a CosmosDB target, or null to use the default. This has no effect on non-CosmosDB targets.
        """
        MongoDbCollectionSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            can_delete=can_delete,
            shard_key=shard_key,
            target_rus=target_rus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             can_delete: Optional[bool] = None,
             shard_key: Optional['outputs.MongoDbShardKeySettingResponse'] = None,
             target_rus: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if can_delete is None and 'canDelete' in kwargs:
            can_delete = kwargs['canDelete']
        if shard_key is None and 'shardKey' in kwargs:
            shard_key = kwargs['shardKey']
        if target_rus is None and 'targetRUs' in kwargs:
            target_rus = kwargs['targetRUs']

        if can_delete is not None:
            _setter("can_delete", can_delete)
        if shard_key is not None:
            _setter("shard_key", shard_key)
        if target_rus is not None:
            _setter("target_rus", target_rus)

    @property
    @pulumi.getter(name="canDelete")
    def can_delete(self) -> Optional[bool]:
        """
        Whether the migrator is allowed to drop the target collection in the course of performing a migration. The default is true.
        """
        return pulumi.get(self, "can_delete")

    @property
    @pulumi.getter(name="shardKey")
    def shard_key(self) -> Optional['outputs.MongoDbShardKeySettingResponse']:
        """
        Describes a MongoDB shard key
        """
        return pulumi.get(self, "shard_key")

    @property
    @pulumi.getter(name="targetRUs")
    def target_rus(self) -> Optional[int]:
        """
        The RUs that should be configured on a CosmosDB target, or null to use the default. This has no effect on non-CosmosDB targets.
        """
        return pulumi.get(self, "target_rus")


@pulumi.output_type
class MongoDbConnectionInfoResponse(dict):
    """
    Describes a connection to a MongoDB data source
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "additionalSettings":
            suggest = "additional_settings"
        elif key == "dataSource":
            suggest = "data_source"
        elif key == "encryptConnection":
            suggest = "encrypt_connection"
        elif key == "enforceSSL":
            suggest = "enforce_ssl"
        elif key == "serverBrandVersion":
            suggest = "server_brand_version"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serverVersion":
            suggest = "server_version"
        elif key == "trustServerCertificate":
            suggest = "trust_server_certificate"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbConnectionInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbConnectionInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbConnectionInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: str,
                 type: str,
                 additional_settings: Optional[str] = None,
                 authentication: Optional[str] = None,
                 data_source: Optional[str] = None,
                 encrypt_connection: Optional[bool] = None,
                 enforce_ssl: Optional[bool] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 server_brand_version: Optional[str] = None,
                 server_name: Optional[str] = None,
                 server_version: Optional[str] = None,
                 trust_server_certificate: Optional[bool] = None,
                 user_name: Optional[str] = None):
        """
        Describes a connection to a MongoDB data source
        :param str connection_string: A MongoDB connection string or blob container URL. The user name and password can be specified here or in the userName and password properties
        :param str type: Type of connection info
               Expected value is 'MongoDbConnectionInfo'.
        :param str additional_settings: Additional connection settings
        :param str authentication: Authentication type to use for connection
        :param str data_source: Data source 
        :param bool encrypt_connection: Whether to encrypt the connection
        :param str password: Password credential.
        :param int port: port for server
        :param str server_brand_version: server brand version
        :param str server_name: name of the server
        :param str server_version: server version
        :param bool trust_server_certificate: Whether to trust the server certificate
        :param str user_name: User name
        """
        MongoDbConnectionInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
            type=type,
            additional_settings=additional_settings,
            authentication=authentication,
            data_source=data_source,
            encrypt_connection=encrypt_connection,
            enforce_ssl=enforce_ssl,
            password=password,
            port=port,
            server_brand_version=server_brand_version,
            server_name=server_name,
            server_version=server_version,
            trust_server_certificate=trust_server_certificate,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: Optional[str] = None,
             type: Optional[str] = None,
             additional_settings: Optional[str] = None,
             authentication: Optional[str] = None,
             data_source: Optional[str] = None,
             encrypt_connection: Optional[bool] = None,
             enforce_ssl: Optional[bool] = None,
             password: Optional[str] = None,
             port: Optional[int] = None,
             server_brand_version: Optional[str] = None,
             server_name: Optional[str] = None,
             server_version: Optional[str] = None,
             trust_server_certificate: Optional[bool] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_string is None and 'connectionString' in kwargs:
            connection_string = kwargs['connectionString']
        if connection_string is None:
            raise TypeError("Missing 'connection_string' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if additional_settings is None and 'additionalSettings' in kwargs:
            additional_settings = kwargs['additionalSettings']
        if data_source is None and 'dataSource' in kwargs:
            data_source = kwargs['dataSource']
        if encrypt_connection is None and 'encryptConnection' in kwargs:
            encrypt_connection = kwargs['encryptConnection']
        if enforce_ssl is None and 'enforceSSL' in kwargs:
            enforce_ssl = kwargs['enforceSSL']
        if server_brand_version is None and 'serverBrandVersion' in kwargs:
            server_brand_version = kwargs['serverBrandVersion']
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_version is None and 'serverVersion' in kwargs:
            server_version = kwargs['serverVersion']
        if trust_server_certificate is None and 'trustServerCertificate' in kwargs:
            trust_server_certificate = kwargs['trustServerCertificate']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        _setter("connection_string", connection_string)
        _setter("type", 'MongoDbConnectionInfo')
        if additional_settings is not None:
            _setter("additional_settings", additional_settings)
        if authentication is not None:
            _setter("authentication", authentication)
        if data_source is not None:
            _setter("data_source", data_source)
        if encrypt_connection is not None:
            _setter("encrypt_connection", encrypt_connection)
        if enforce_ssl is not None:
            _setter("enforce_ssl", enforce_ssl)
        if password is not None:
            _setter("password", password)
        if port is not None:
            _setter("port", port)
        if server_brand_version is not None:
            _setter("server_brand_version", server_brand_version)
        if server_name is not None:
            _setter("server_name", server_name)
        if server_version is not None:
            _setter("server_version", server_version)
        if trust_server_certificate is None:
            trust_server_certificate = False
        if trust_server_certificate is not None:
            _setter("trust_server_certificate", trust_server_certificate)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        """
        A MongoDB connection string or blob container URL. The user name and password can be specified here or in the userName and password properties
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of connection info
        Expected value is 'MongoDbConnectionInfo'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="additionalSettings")
    def additional_settings(self) -> Optional[str]:
        """
        Additional connection settings
        """
        return pulumi.get(self, "additional_settings")

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        """
        Authentication type to use for connection
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        Data source 
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="encryptConnection")
    def encrypt_connection(self) -> Optional[bool]:
        """
        Whether to encrypt the connection
        """
        return pulumi.get(self, "encrypt_connection")

    @property
    @pulumi.getter(name="enforceSSL")
    def enforce_ssl(self) -> Optional[bool]:
        return pulumi.get(self, "enforce_ssl")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password credential.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        port for server
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverBrandVersion")
    def server_brand_version(self) -> Optional[str]:
        """
        server brand version
        """
        return pulumi.get(self, "server_brand_version")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        name of the server
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[str]:
        """
        server version
        """
        return pulumi.get(self, "server_version")

    @property
    @pulumi.getter(name="trustServerCertificate")
    def trust_server_certificate(self) -> Optional[bool]:
        """
        Whether to trust the server certificate
        """
        return pulumi.get(self, "trust_server_certificate")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class MongoDbDatabaseInfoResponse(dict):
    """
    Describes a database within a MongoDB data source
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "averageDocumentSize":
            suggest = "average_document_size"
        elif key == "dataSize":
            suggest = "data_size"
        elif key == "documentCount":
            suggest = "document_count"
        elif key == "qualifiedName":
            suggest = "qualified_name"
        elif key == "supportsSharding":
            suggest = "supports_sharding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbDatabaseInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbDatabaseInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbDatabaseInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 average_document_size: float,
                 collections: Sequence['outputs.MongoDbCollectionInfoResponse'],
                 data_size: float,
                 document_count: float,
                 name: str,
                 qualified_name: str,
                 supports_sharding: bool):
        """
        Describes a database within a MongoDB data source
        :param float average_document_size: The average document size, or -1 if the average size is unknown
        :param Sequence['MongoDbCollectionInfoResponse'] collections: A list of supported collections in a MongoDB database
        :param float data_size: The estimated total data size, in bytes, or -1 if the size is unknown.
        :param float document_count: The estimated total number of documents, or -1 if the document count is unknown
        :param str name: The unqualified name of the database or collection
        :param str qualified_name: The qualified name of the database or collection. For a collection, this is the database-qualified name.
        :param bool supports_sharding: Whether the database has sharding enabled. Note that the migration task will enable sharding on the target if necessary.
        """
        MongoDbDatabaseInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            average_document_size=average_document_size,
            collections=collections,
            data_size=data_size,
            document_count=document_count,
            name=name,
            qualified_name=qualified_name,
            supports_sharding=supports_sharding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             average_document_size: Optional[float] = None,
             collections: Optional[Sequence['outputs.MongoDbCollectionInfoResponse']] = None,
             data_size: Optional[float] = None,
             document_count: Optional[float] = None,
             name: Optional[str] = None,
             qualified_name: Optional[str] = None,
             supports_sharding: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if average_document_size is None and 'averageDocumentSize' in kwargs:
            average_document_size = kwargs['averageDocumentSize']
        if average_document_size is None:
            raise TypeError("Missing 'average_document_size' argument")
        if collections is None:
            raise TypeError("Missing 'collections' argument")
        if data_size is None and 'dataSize' in kwargs:
            data_size = kwargs['dataSize']
        if data_size is None:
            raise TypeError("Missing 'data_size' argument")
        if document_count is None and 'documentCount' in kwargs:
            document_count = kwargs['documentCount']
        if document_count is None:
            raise TypeError("Missing 'document_count' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if qualified_name is None and 'qualifiedName' in kwargs:
            qualified_name = kwargs['qualifiedName']
        if qualified_name is None:
            raise TypeError("Missing 'qualified_name' argument")
        if supports_sharding is None and 'supportsSharding' in kwargs:
            supports_sharding = kwargs['supportsSharding']
        if supports_sharding is None:
            raise TypeError("Missing 'supports_sharding' argument")

        _setter("average_document_size", average_document_size)
        _setter("collections", collections)
        _setter("data_size", data_size)
        _setter("document_count", document_count)
        _setter("name", name)
        _setter("qualified_name", qualified_name)
        _setter("supports_sharding", supports_sharding)

    @property
    @pulumi.getter(name="averageDocumentSize")
    def average_document_size(self) -> float:
        """
        The average document size, or -1 if the average size is unknown
        """
        return pulumi.get(self, "average_document_size")

    @property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.MongoDbCollectionInfoResponse']:
        """
        A list of supported collections in a MongoDB database
        """
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="dataSize")
    def data_size(self) -> float:
        """
        The estimated total data size, in bytes, or -1 if the size is unknown.
        """
        return pulumi.get(self, "data_size")

    @property
    @pulumi.getter(name="documentCount")
    def document_count(self) -> float:
        """
        The estimated total number of documents, or -1 if the document count is unknown
        """
        return pulumi.get(self, "document_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unqualified name of the database or collection
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="qualifiedName")
    def qualified_name(self) -> str:
        """
        The qualified name of the database or collection. For a collection, this is the database-qualified name.
        """
        return pulumi.get(self, "qualified_name")

    @property
    @pulumi.getter(name="supportsSharding")
    def supports_sharding(self) -> bool:
        """
        Whether the database has sharding enabled. Note that the migration task will enable sharding on the target if necessary.
        """
        return pulumi.get(self, "supports_sharding")


@pulumi.output_type
class MongoDbDatabaseProgressResponse(dict):
    """
    Describes the progress of a database
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bytesCopied":
            suggest = "bytes_copied"
        elif key == "documentsCopied":
            suggest = "documents_copied"
        elif key == "elapsedTime":
            suggest = "elapsed_time"
        elif key == "eventsPending":
            suggest = "events_pending"
        elif key == "eventsReplayed":
            suggest = "events_replayed"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "totalBytes":
            suggest = "total_bytes"
        elif key == "totalDocuments":
            suggest = "total_documents"
        elif key == "lastEventTime":
            suggest = "last_event_time"
        elif key == "lastReplayTime":
            suggest = "last_replay_time"
        elif key == "qualifiedName":
            suggest = "qualified_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbDatabaseProgressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbDatabaseProgressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbDatabaseProgressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bytes_copied: float,
                 documents_copied: float,
                 elapsed_time: str,
                 errors: Mapping[str, 'outputs.MongoDbErrorResponse'],
                 events_pending: float,
                 events_replayed: float,
                 result_type: str,
                 state: str,
                 total_bytes: float,
                 total_documents: float,
                 collections: Optional[Mapping[str, 'outputs.MongoDbCollectionProgressResponse']] = None,
                 last_event_time: Optional[str] = None,
                 last_replay_time: Optional[str] = None,
                 name: Optional[str] = None,
                 qualified_name: Optional[str] = None):
        """
        Describes the progress of a database
        :param float bytes_copied: The number of document bytes copied during the Copying stage
        :param float documents_copied: The number of documents copied during the Copying stage
        :param str elapsed_time: The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
        :param Mapping[str, 'MongoDbErrorResponse'] errors: The errors and warnings that have occurred for the current object. The keys are the error codes.
        :param float events_pending: The number of oplog events awaiting replay
        :param float events_replayed: The number of oplog events replayed so far
        :param str result_type: The type of progress object
               Expected value is 'Database'.
        :param float total_bytes: The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size was unknown
        :param float total_documents: The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was unknown
        :param Mapping[str, 'MongoDbCollectionProgressResponse'] collections: The progress of the collections in the database. The keys are the unqualified names of the collections
        :param str last_event_time: The timestamp of the last oplog event received, or null if no oplog event has been received yet
        :param str last_replay_time: The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
        :param str name: The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the database name. For the overall migration, this is null.
        :param str qualified_name: The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this is the database name. For the overall migration, this is null.
        """
        MongoDbDatabaseProgressResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bytes_copied=bytes_copied,
            documents_copied=documents_copied,
            elapsed_time=elapsed_time,
            errors=errors,
            events_pending=events_pending,
            events_replayed=events_replayed,
            result_type=result_type,
            state=state,
            total_bytes=total_bytes,
            total_documents=total_documents,
            collections=collections,
            last_event_time=last_event_time,
            last_replay_time=last_replay_time,
            name=name,
            qualified_name=qualified_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bytes_copied: Optional[float] = None,
             documents_copied: Optional[float] = None,
             elapsed_time: Optional[str] = None,
             errors: Optional[Mapping[str, 'outputs.MongoDbErrorResponse']] = None,
             events_pending: Optional[float] = None,
             events_replayed: Optional[float] = None,
             result_type: Optional[str] = None,
             state: Optional[str] = None,
             total_bytes: Optional[float] = None,
             total_documents: Optional[float] = None,
             collections: Optional[Mapping[str, 'outputs.MongoDbCollectionProgressResponse']] = None,
             last_event_time: Optional[str] = None,
             last_replay_time: Optional[str] = None,
             name: Optional[str] = None,
             qualified_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bytes_copied is None and 'bytesCopied' in kwargs:
            bytes_copied = kwargs['bytesCopied']
        if bytes_copied is None:
            raise TypeError("Missing 'bytes_copied' argument")
        if documents_copied is None and 'documentsCopied' in kwargs:
            documents_copied = kwargs['documentsCopied']
        if documents_copied is None:
            raise TypeError("Missing 'documents_copied' argument")
        if elapsed_time is None and 'elapsedTime' in kwargs:
            elapsed_time = kwargs['elapsedTime']
        if elapsed_time is None:
            raise TypeError("Missing 'elapsed_time' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if events_pending is None and 'eventsPending' in kwargs:
            events_pending = kwargs['eventsPending']
        if events_pending is None:
            raise TypeError("Missing 'events_pending' argument")
        if events_replayed is None and 'eventsReplayed' in kwargs:
            events_replayed = kwargs['eventsReplayed']
        if events_replayed is None:
            raise TypeError("Missing 'events_replayed' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if total_bytes is None and 'totalBytes' in kwargs:
            total_bytes = kwargs['totalBytes']
        if total_bytes is None:
            raise TypeError("Missing 'total_bytes' argument")
        if total_documents is None and 'totalDocuments' in kwargs:
            total_documents = kwargs['totalDocuments']
        if total_documents is None:
            raise TypeError("Missing 'total_documents' argument")
        if last_event_time is None and 'lastEventTime' in kwargs:
            last_event_time = kwargs['lastEventTime']
        if last_replay_time is None and 'lastReplayTime' in kwargs:
            last_replay_time = kwargs['lastReplayTime']
        if qualified_name is None and 'qualifiedName' in kwargs:
            qualified_name = kwargs['qualifiedName']

        _setter("bytes_copied", bytes_copied)
        _setter("documents_copied", documents_copied)
        _setter("elapsed_time", elapsed_time)
        _setter("errors", errors)
        _setter("events_pending", events_pending)
        _setter("events_replayed", events_replayed)
        _setter("result_type", 'Database')
        _setter("state", state)
        _setter("total_bytes", total_bytes)
        _setter("total_documents", total_documents)
        if collections is not None:
            _setter("collections", collections)
        if last_event_time is not None:
            _setter("last_event_time", last_event_time)
        if last_replay_time is not None:
            _setter("last_replay_time", last_replay_time)
        if name is not None:
            _setter("name", name)
        if qualified_name is not None:
            _setter("qualified_name", qualified_name)

    @property
    @pulumi.getter(name="bytesCopied")
    def bytes_copied(self) -> float:
        """
        The number of document bytes copied during the Copying stage
        """
        return pulumi.get(self, "bytes_copied")

    @property
    @pulumi.getter(name="documentsCopied")
    def documents_copied(self) -> float:
        """
        The number of documents copied during the Copying stage
        """
        return pulumi.get(self, "documents_copied")

    @property
    @pulumi.getter(name="elapsedTime")
    def elapsed_time(self) -> str:
        """
        The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
        """
        return pulumi.get(self, "elapsed_time")

    @property
    @pulumi.getter
    def errors(self) -> Mapping[str, 'outputs.MongoDbErrorResponse']:
        """
        The errors and warnings that have occurred for the current object. The keys are the error codes.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="eventsPending")
    def events_pending(self) -> float:
        """
        The number of oplog events awaiting replay
        """
        return pulumi.get(self, "events_pending")

    @property
    @pulumi.getter(name="eventsReplayed")
    def events_replayed(self) -> float:
        """
        The number of oplog events replayed so far
        """
        return pulumi.get(self, "events_replayed")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        The type of progress object
        Expected value is 'Database'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="totalBytes")
    def total_bytes(self) -> float:
        """
        The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size was unknown
        """
        return pulumi.get(self, "total_bytes")

    @property
    @pulumi.getter(name="totalDocuments")
    def total_documents(self) -> float:
        """
        The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was unknown
        """
        return pulumi.get(self, "total_documents")

    @property
    @pulumi.getter
    def collections(self) -> Optional[Mapping[str, 'outputs.MongoDbCollectionProgressResponse']]:
        """
        The progress of the collections in the database. The keys are the unqualified names of the collections
        """
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="lastEventTime")
    def last_event_time(self) -> Optional[str]:
        """
        The timestamp of the last oplog event received, or null if no oplog event has been received yet
        """
        return pulumi.get(self, "last_event_time")

    @property
    @pulumi.getter(name="lastReplayTime")
    def last_replay_time(self) -> Optional[str]:
        """
        The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
        """
        return pulumi.get(self, "last_replay_time")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the database name. For the overall migration, this is null.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="qualifiedName")
    def qualified_name(self) -> Optional[str]:
        """
        The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this is the database name. For the overall migration, this is null.
        """
        return pulumi.get(self, "qualified_name")


@pulumi.output_type
class MongoDbDatabaseSettingsResponse(dict):
    """
    Describes how an individual MongoDB database should be migrated
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetRUs":
            suggest = "target_rus"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbDatabaseSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbDatabaseSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbDatabaseSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections: Mapping[str, 'outputs.MongoDbCollectionSettingsResponse'],
                 target_rus: Optional[int] = None):
        """
        Describes how an individual MongoDB database should be migrated
        :param Mapping[str, 'MongoDbCollectionSettingsResponse'] collections: The collections on the source database to migrate to the target. The keys are the unqualified names of the collections.
        :param int target_rus: The RUs that should be configured on a CosmosDB target, or null to use the default, or 0 if throughput should not be provisioned for the database. This has no effect on non-CosmosDB targets.
        """
        MongoDbDatabaseSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collections=collections,
            target_rus=target_rus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collections: Optional[Mapping[str, 'outputs.MongoDbCollectionSettingsResponse']] = None,
             target_rus: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if collections is None:
            raise TypeError("Missing 'collections' argument")
        if target_rus is None and 'targetRUs' in kwargs:
            target_rus = kwargs['targetRUs']

        _setter("collections", collections)
        if target_rus is not None:
            _setter("target_rus", target_rus)

    @property
    @pulumi.getter
    def collections(self) -> Mapping[str, 'outputs.MongoDbCollectionSettingsResponse']:
        """
        The collections on the source database to migrate to the target. The keys are the unqualified names of the collections.
        """
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="targetRUs")
    def target_rus(self) -> Optional[int]:
        """
        The RUs that should be configured on a CosmosDB target, or null to use the default, or 0 if throughput should not be provisioned for the database. This has no effect on non-CosmosDB targets.
        """
        return pulumi.get(self, "target_rus")


@pulumi.output_type
class MongoDbErrorResponse(dict):
    """
    Describes an error or warning that occurred during a MongoDB migration
    """
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 count: Optional[int] = None,
                 message: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Describes an error or warning that occurred during a MongoDB migration
        :param str code: The non-localized, machine-readable code that describes the error or warning
        :param int count: The number of times the error or warning has occurred
        :param str message: The localized, human-readable message that describes the error or warning
        :param str type: The type of error or warning
        """
        MongoDbErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            count=count,
            message=message,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             count: Optional[int] = None,
             message: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if code is not None:
            _setter("code", code)
        if count is not None:
            _setter("count", count)
        if message is not None:
            _setter("message", message)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The non-localized, machine-readable code that describes the error or warning
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of times the error or warning has occurred
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The localized, human-readable message that describes the error or warning
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of error or warning
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MongoDbMigrationProgressResponse(dict):
    """
    Describes the progress of the overall migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bytesCopied":
            suggest = "bytes_copied"
        elif key == "documentsCopied":
            suggest = "documents_copied"
        elif key == "elapsedTime":
            suggest = "elapsed_time"
        elif key == "eventsPending":
            suggest = "events_pending"
        elif key == "eventsReplayed":
            suggest = "events_replayed"
        elif key == "resultType":
            suggest = "result_type"
        elif key == "totalBytes":
            suggest = "total_bytes"
        elif key == "totalDocuments":
            suggest = "total_documents"
        elif key == "lastEventTime":
            suggest = "last_event_time"
        elif key == "lastReplayTime":
            suggest = "last_replay_time"
        elif key == "qualifiedName":
            suggest = "qualified_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbMigrationProgressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbMigrationProgressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbMigrationProgressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bytes_copied: float,
                 documents_copied: float,
                 elapsed_time: str,
                 errors: Mapping[str, 'outputs.MongoDbErrorResponse'],
                 events_pending: float,
                 events_replayed: float,
                 result_type: str,
                 state: str,
                 total_bytes: float,
                 total_documents: float,
                 databases: Optional[Mapping[str, 'outputs.MongoDbDatabaseProgressResponse']] = None,
                 last_event_time: Optional[str] = None,
                 last_replay_time: Optional[str] = None,
                 name: Optional[str] = None,
                 qualified_name: Optional[str] = None):
        """
        Describes the progress of the overall migration
        :param float bytes_copied: The number of document bytes copied during the Copying stage
        :param float documents_copied: The number of documents copied during the Copying stage
        :param str elapsed_time: The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
        :param Mapping[str, 'MongoDbErrorResponse'] errors: The errors and warnings that have occurred for the current object. The keys are the error codes.
        :param float events_pending: The number of oplog events awaiting replay
        :param float events_replayed: The number of oplog events replayed so far
        :param str result_type: The type of progress object
               Expected value is 'Migration'.
        :param float total_bytes: The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size was unknown
        :param float total_documents: The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was unknown
        :param Mapping[str, 'MongoDbDatabaseProgressResponse'] databases: The progress of the databases in the migration. The keys are the names of the databases
        :param str last_event_time: The timestamp of the last oplog event received, or null if no oplog event has been received yet
        :param str last_replay_time: The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
        :param str name: The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the database name. For the overall migration, this is null.
        :param str qualified_name: The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this is the database name. For the overall migration, this is null.
        """
        MongoDbMigrationProgressResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bytes_copied=bytes_copied,
            documents_copied=documents_copied,
            elapsed_time=elapsed_time,
            errors=errors,
            events_pending=events_pending,
            events_replayed=events_replayed,
            result_type=result_type,
            state=state,
            total_bytes=total_bytes,
            total_documents=total_documents,
            databases=databases,
            last_event_time=last_event_time,
            last_replay_time=last_replay_time,
            name=name,
            qualified_name=qualified_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bytes_copied: Optional[float] = None,
             documents_copied: Optional[float] = None,
             elapsed_time: Optional[str] = None,
             errors: Optional[Mapping[str, 'outputs.MongoDbErrorResponse']] = None,
             events_pending: Optional[float] = None,
             events_replayed: Optional[float] = None,
             result_type: Optional[str] = None,
             state: Optional[str] = None,
             total_bytes: Optional[float] = None,
             total_documents: Optional[float] = None,
             databases: Optional[Mapping[str, 'outputs.MongoDbDatabaseProgressResponse']] = None,
             last_event_time: Optional[str] = None,
             last_replay_time: Optional[str] = None,
             name: Optional[str] = None,
             qualified_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bytes_copied is None and 'bytesCopied' in kwargs:
            bytes_copied = kwargs['bytesCopied']
        if bytes_copied is None:
            raise TypeError("Missing 'bytes_copied' argument")
        if documents_copied is None and 'documentsCopied' in kwargs:
            documents_copied = kwargs['documentsCopied']
        if documents_copied is None:
            raise TypeError("Missing 'documents_copied' argument")
        if elapsed_time is None and 'elapsedTime' in kwargs:
            elapsed_time = kwargs['elapsedTime']
        if elapsed_time is None:
            raise TypeError("Missing 'elapsed_time' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if events_pending is None and 'eventsPending' in kwargs:
            events_pending = kwargs['eventsPending']
        if events_pending is None:
            raise TypeError("Missing 'events_pending' argument")
        if events_replayed is None and 'eventsReplayed' in kwargs:
            events_replayed = kwargs['eventsReplayed']
        if events_replayed is None:
            raise TypeError("Missing 'events_replayed' argument")
        if result_type is None and 'resultType' in kwargs:
            result_type = kwargs['resultType']
        if result_type is None:
            raise TypeError("Missing 'result_type' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if total_bytes is None and 'totalBytes' in kwargs:
            total_bytes = kwargs['totalBytes']
        if total_bytes is None:
            raise TypeError("Missing 'total_bytes' argument")
        if total_documents is None and 'totalDocuments' in kwargs:
            total_documents = kwargs['totalDocuments']
        if total_documents is None:
            raise TypeError("Missing 'total_documents' argument")
        if last_event_time is None and 'lastEventTime' in kwargs:
            last_event_time = kwargs['lastEventTime']
        if last_replay_time is None and 'lastReplayTime' in kwargs:
            last_replay_time = kwargs['lastReplayTime']
        if qualified_name is None and 'qualifiedName' in kwargs:
            qualified_name = kwargs['qualifiedName']

        _setter("bytes_copied", bytes_copied)
        _setter("documents_copied", documents_copied)
        _setter("elapsed_time", elapsed_time)
        _setter("errors", errors)
        _setter("events_pending", events_pending)
        _setter("events_replayed", events_replayed)
        _setter("result_type", 'Migration')
        _setter("state", state)
        _setter("total_bytes", total_bytes)
        _setter("total_documents", total_documents)
        if databases is not None:
            _setter("databases", databases)
        if last_event_time is not None:
            _setter("last_event_time", last_event_time)
        if last_replay_time is not None:
            _setter("last_replay_time", last_replay_time)
        if name is not None:
            _setter("name", name)
        if qualified_name is not None:
            _setter("qualified_name", qualified_name)

    @property
    @pulumi.getter(name="bytesCopied")
    def bytes_copied(self) -> float:
        """
        The number of document bytes copied during the Copying stage
        """
        return pulumi.get(self, "bytes_copied")

    @property
    @pulumi.getter(name="documentsCopied")
    def documents_copied(self) -> float:
        """
        The number of documents copied during the Copying stage
        """
        return pulumi.get(self, "documents_copied")

    @property
    @pulumi.getter(name="elapsedTime")
    def elapsed_time(self) -> str:
        """
        The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
        """
        return pulumi.get(self, "elapsed_time")

    @property
    @pulumi.getter
    def errors(self) -> Mapping[str, 'outputs.MongoDbErrorResponse']:
        """
        The errors and warnings that have occurred for the current object. The keys are the error codes.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="eventsPending")
    def events_pending(self) -> float:
        """
        The number of oplog events awaiting replay
        """
        return pulumi.get(self, "events_pending")

    @property
    @pulumi.getter(name="eventsReplayed")
    def events_replayed(self) -> float:
        """
        The number of oplog events replayed so far
        """
        return pulumi.get(self, "events_replayed")

    @property
    @pulumi.getter(name="resultType")
    def result_type(self) -> str:
        """
        The type of progress object
        Expected value is 'Migration'.
        """
        return pulumi.get(self, "result_type")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="totalBytes")
    def total_bytes(self) -> float:
        """
        The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size was unknown
        """
        return pulumi.get(self, "total_bytes")

    @property
    @pulumi.getter(name="totalDocuments")
    def total_documents(self) -> float:
        """
        The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was unknown
        """
        return pulumi.get(self, "total_documents")

    @property
    @pulumi.getter
    def databases(self) -> Optional[Mapping[str, 'outputs.MongoDbDatabaseProgressResponse']]:
        """
        The progress of the databases in the migration. The keys are the names of the databases
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="lastEventTime")
    def last_event_time(self) -> Optional[str]:
        """
        The timestamp of the last oplog event received, or null if no oplog event has been received yet
        """
        return pulumi.get(self, "last_event_time")

    @property
    @pulumi.getter(name="lastReplayTime")
    def last_replay_time(self) -> Optional[str]:
        """
        The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
        """
        return pulumi.get(self, "last_replay_time")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the database name. For the overall migration, this is null.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="qualifiedName")
    def qualified_name(self) -> Optional[str]:
        """
        The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this is the database name. For the overall migration, this is null.
        """
        return pulumi.get(self, "qualified_name")


@pulumi.output_type
class MongoDbMigrationSettingsResponse(dict):
    """
    Describes how a MongoDB data migration should be performed
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boostRUs":
            suggest = "boost_rus"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbMigrationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbMigrationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbMigrationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Mapping[str, 'outputs.MongoDbDatabaseSettingsResponse'],
                 source: 'outputs.MongoDbConnectionInfoResponse',
                 target: 'outputs.MongoDbConnectionInfoResponse',
                 boost_rus: Optional[int] = None,
                 replication: Optional[str] = None,
                 throttling: Optional['outputs.MongoDbThrottlingSettingsResponse'] = None):
        """
        Describes how a MongoDB data migration should be performed
        :param Mapping[str, 'MongoDbDatabaseSettingsResponse'] databases: The databases on the source cluster to migrate to the target. The keys are the names of the databases.
        :param 'MongoDbConnectionInfoResponse' source: Settings used to connect to the source cluster
        :param 'MongoDbConnectionInfoResponse' target: Settings used to connect to the target cluster
        :param int boost_rus: The RU limit on a CosmosDB target that collections will be temporarily increased to (if lower) during the initial copy of a migration, from 10,000 to 1,000,000, or 0 to use the default boost (which is generally the maximum), or null to not boost the RUs. This setting has no effect on non-CosmosDB targets.
        :param str replication: Describes how changes will be replicated from the source to the target. The default is OneTime.
        :param 'MongoDbThrottlingSettingsResponse' throttling: Settings used to limit the resource usage of the migration
        """
        MongoDbMigrationSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases=databases,
            source=source,
            target=target,
            boost_rus=boost_rus,
            replication=replication,
            throttling=throttling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases: Optional[Mapping[str, 'outputs.MongoDbDatabaseSettingsResponse']] = None,
             source: Optional['outputs.MongoDbConnectionInfoResponse'] = None,
             target: Optional['outputs.MongoDbConnectionInfoResponse'] = None,
             boost_rus: Optional[int] = None,
             replication: Optional[str] = None,
             throttling: Optional['outputs.MongoDbThrottlingSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if databases is None:
            raise TypeError("Missing 'databases' argument")
        if source is None:
            raise TypeError("Missing 'source' argument")
        if target is None:
            raise TypeError("Missing 'target' argument")
        if boost_rus is None and 'boostRUs' in kwargs:
            boost_rus = kwargs['boostRUs']

        _setter("databases", databases)
        _setter("source", source)
        _setter("target", target)
        if boost_rus is not None:
            _setter("boost_rus", boost_rus)
        if replication is not None:
            _setter("replication", replication)
        if throttling is not None:
            _setter("throttling", throttling)

    @property
    @pulumi.getter
    def databases(self) -> Mapping[str, 'outputs.MongoDbDatabaseSettingsResponse']:
        """
        The databases on the source cluster to migrate to the target. The keys are the names of the databases.
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter
    def source(self) -> 'outputs.MongoDbConnectionInfoResponse':
        """
        Settings used to connect to the source cluster
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> 'outputs.MongoDbConnectionInfoResponse':
        """
        Settings used to connect to the target cluster
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="boostRUs")
    def boost_rus(self) -> Optional[int]:
        """
        The RU limit on a CosmosDB target that collections will be temporarily increased to (if lower) during the initial copy of a migration, from 10,000 to 1,000,000, or 0 to use the default boost (which is generally the maximum), or null to not boost the RUs. This setting has no effect on non-CosmosDB targets.
        """
        return pulumi.get(self, "boost_rus")

    @property
    @pulumi.getter
    def replication(self) -> Optional[str]:
        """
        Describes how changes will be replicated from the source to the target. The default is OneTime.
        """
        return pulumi.get(self, "replication")

    @property
    @pulumi.getter
    def throttling(self) -> Optional['outputs.MongoDbThrottlingSettingsResponse']:
        """
        Settings used to limit the resource usage of the migration
        """
        return pulumi.get(self, "throttling")


@pulumi.output_type
class MongoDbShardKeyFieldResponse(dict):
    """
    Describes a field reference within a MongoDB shard key
    """
    def __init__(__self__, *,
                 name: str,
                 order: str):
        """
        Describes a field reference within a MongoDB shard key
        :param str name: The name of the field
        :param str order: The field ordering
        """
        MongoDbShardKeyFieldResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if order is None:
            raise TypeError("Missing 'order' argument")

        _setter("name", name)
        _setter("order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        The field ordering
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class MongoDbShardKeyInfoResponse(dict):
    """
    Describes a MongoDB shard key
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isUnique":
            suggest = "is_unique"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbShardKeyInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbShardKeyInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbShardKeyInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields: Sequence['outputs.MongoDbShardKeyFieldResponse'],
                 is_unique: bool):
        """
        Describes a MongoDB shard key
        :param Sequence['MongoDbShardKeyFieldResponse'] fields: The fields within the shard key
        :param bool is_unique: Whether the shard key is unique
        """
        MongoDbShardKeyInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fields=fields,
            is_unique=is_unique,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fields: Optional[Sequence['outputs.MongoDbShardKeyFieldResponse']] = None,
             is_unique: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fields is None:
            raise TypeError("Missing 'fields' argument")
        if is_unique is None and 'isUnique' in kwargs:
            is_unique = kwargs['isUnique']
        if is_unique is None:
            raise TypeError("Missing 'is_unique' argument")

        _setter("fields", fields)
        _setter("is_unique", is_unique)

    @property
    @pulumi.getter
    def fields(self) -> Sequence['outputs.MongoDbShardKeyFieldResponse']:
        """
        The fields within the shard key
        """
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter(name="isUnique")
    def is_unique(self) -> bool:
        """
        Whether the shard key is unique
        """
        return pulumi.get(self, "is_unique")


@pulumi.output_type
class MongoDbShardKeySettingResponse(dict):
    """
    Describes a MongoDB shard key
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isUnique":
            suggest = "is_unique"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbShardKeySettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbShardKeySettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbShardKeySettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields: Sequence['outputs.MongoDbShardKeyFieldResponse'],
                 is_unique: Optional[bool] = None):
        """
        Describes a MongoDB shard key
        :param Sequence['MongoDbShardKeyFieldResponse'] fields: The fields within the shard key
        :param bool is_unique: Whether the shard key is unique
        """
        MongoDbShardKeySettingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fields=fields,
            is_unique=is_unique,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fields: Optional[Sequence['outputs.MongoDbShardKeyFieldResponse']] = None,
             is_unique: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fields is None:
            raise TypeError("Missing 'fields' argument")
        if is_unique is None and 'isUnique' in kwargs:
            is_unique = kwargs['isUnique']

        _setter("fields", fields)
        if is_unique is not None:
            _setter("is_unique", is_unique)

    @property
    @pulumi.getter
    def fields(self) -> Sequence['outputs.MongoDbShardKeyFieldResponse']:
        """
        The fields within the shard key
        """
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter(name="isUnique")
    def is_unique(self) -> Optional[bool]:
        """
        Whether the shard key is unique
        """
        return pulumi.get(self, "is_unique")


@pulumi.output_type
class MongoDbThrottlingSettingsResponse(dict):
    """
    Specifies resource limits for the migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxParallelism":
            suggest = "max_parallelism"
        elif key == "minFreeCpu":
            suggest = "min_free_cpu"
        elif key == "minFreeMemoryMb":
            suggest = "min_free_memory_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MongoDbThrottlingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MongoDbThrottlingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MongoDbThrottlingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_parallelism: Optional[int] = None,
                 min_free_cpu: Optional[int] = None,
                 min_free_memory_mb: Optional[int] = None):
        """
        Specifies resource limits for the migration
        :param int max_parallelism: The maximum number of work items (e.g. collection copies) that will be processed in parallel
        :param int min_free_cpu: The percentage of CPU time that the migrator will try to avoid using, from 0 to 100
        :param int min_free_memory_mb: The number of megabytes of RAM that the migrator will try to avoid using
        """
        MongoDbThrottlingSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_parallelism=max_parallelism,
            min_free_cpu=min_free_cpu,
            min_free_memory_mb=min_free_memory_mb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_parallelism: Optional[int] = None,
             min_free_cpu: Optional[int] = None,
             min_free_memory_mb: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_parallelism is None and 'maxParallelism' in kwargs:
            max_parallelism = kwargs['maxParallelism']
        if min_free_cpu is None and 'minFreeCpu' in kwargs:
            min_free_cpu = kwargs['minFreeCpu']
        if min_free_memory_mb is None and 'minFreeMemoryMb' in kwargs:
            min_free_memory_mb = kwargs['minFreeMemoryMb']

        if max_parallelism is not None:
            _setter("max_parallelism", max_parallelism)
        if min_free_cpu is not None:
            _setter("min_free_cpu", min_free_cpu)
        if min_free_memory_mb is not None:
            _setter("min_free_memory_mb", min_free_memory_mb)

    @property
    @pulumi.getter(name="maxParallelism")
    def max_parallelism(self) -> Optional[int]:
        """
        The maximum number of work items (e.g. collection copies) that will be processed in parallel
        """
        return pulumi.get(self, "max_parallelism")

    @property
    @pulumi.getter(name="minFreeCpu")
    def min_free_cpu(self) -> Optional[int]:
        """
        The percentage of CPU time that the migrator will try to avoid using, from 0 to 100
        """
        return pulumi.get(self, "min_free_cpu")

    @property
    @pulumi.getter(name="minFreeMemoryMb")
    def min_free_memory_mb(self) -> Optional[int]:
        """
        The number of megabytes of RAM that the migrator will try to avoid using
        """
        return pulumi.get(self, "min_free_memory_mb")


@pulumi.output_type
class MySqlConnectionInfoResponse(dict):
    """
    Information for connecting to MySQL server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverName":
            suggest = "server_name"
        elif key == "additionalSettings":
            suggest = "additional_settings"
        elif key == "dataSource":
            suggest = "data_source"
        elif key == "encryptConnection":
            suggest = "encrypt_connection"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MySqlConnectionInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MySqlConnectionInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MySqlConnectionInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 server_name: str,
                 type: str,
                 additional_settings: Optional[str] = None,
                 authentication: Optional[str] = None,
                 data_source: Optional[str] = None,
                 encrypt_connection: Optional[bool] = None,
                 password: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        Information for connecting to MySQL server
        :param int port: Port for Server
        :param str server_name: Name of the server
        :param str type: Type of connection info
               Expected value is 'MySqlConnectionInfo'.
        :param str additional_settings: Additional connection settings
        :param str authentication: Authentication type to use for connection
        :param str data_source: Data source 
        :param bool encrypt_connection: Whether to encrypt the connection
        :param str password: Password credential.
        :param str user_name: User name
        """
        MySqlConnectionInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            server_name=server_name,
            type=type,
            additional_settings=additional_settings,
            authentication=authentication,
            data_source=data_source,
            encrypt_connection=encrypt_connection,
            password=password,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             server_name: Optional[str] = None,
             type: Optional[str] = None,
             additional_settings: Optional[str] = None,
             authentication: Optional[str] = None,
             data_source: Optional[str] = None,
             encrypt_connection: Optional[bool] = None,
             password: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_name is None:
            raise TypeError("Missing 'server_name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if additional_settings is None and 'additionalSettings' in kwargs:
            additional_settings = kwargs['additionalSettings']
        if data_source is None and 'dataSource' in kwargs:
            data_source = kwargs['dataSource']
        if encrypt_connection is None and 'encryptConnection' in kwargs:
            encrypt_connection = kwargs['encryptConnection']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        _setter("port", port)
        _setter("server_name", server_name)
        _setter("type", 'MySqlConnectionInfo')
        if additional_settings is not None:
            _setter("additional_settings", additional_settings)
        if authentication is not None:
            _setter("authentication", authentication)
        if data_source is not None:
            _setter("data_source", data_source)
        if encrypt_connection is None:
            encrypt_connection = True
        if encrypt_connection is not None:
            _setter("encrypt_connection", encrypt_connection)
        if password is not None:
            _setter("password", password)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for Server
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        """
        Name of the server
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of connection info
        Expected value is 'MySqlConnectionInfo'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="additionalSettings")
    def additional_settings(self) -> Optional[str]:
        """
        Additional connection settings
        """
        return pulumi.get(self, "additional_settings")

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        """
        Authentication type to use for connection
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        Data source 
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="encryptConnection")
    def encrypt_connection(self) -> Optional[bool]:
        """
        Whether to encrypt the connection
        """
        return pulumi.get(self, "encrypt_connection")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password credential.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class NodeMonitoringDataResponse(dict):
    def __init__(__self__, *,
                 additional_properties: Mapping[str, Any],
                 available_memory_in_mb: int,
                 concurrent_jobs_limit: int,
                 concurrent_jobs_running: int,
                 cpu_utilization: int,
                 max_concurrent_jobs: int,
                 node_name: str,
                 received_bytes: float,
                 sent_bytes: float):
        """
        :param Mapping[str, Any] additional_properties:  Unmatched properties from the message are deserialized in this collection.
        :param int available_memory_in_mb: Available memory (MB) on the integration runtime node.
        :param int concurrent_jobs_limit: Maximum concurrent jobs on the integration runtime node.
        :param int concurrent_jobs_running: The number of jobs currently running on the integration runtime node.
        :param int cpu_utilization: CPU percentage on the integration runtime node.
        :param int max_concurrent_jobs: The maximum concurrent jobs in this integration runtime.
        :param str node_name: Name of the integration runtime node.
        :param float received_bytes: Received bytes on the integration runtime node.
        :param float sent_bytes: Sent bytes on the integration runtime node.
        """
        NodeMonitoringDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_properties=additional_properties,
            available_memory_in_mb=available_memory_in_mb,
            concurrent_jobs_limit=concurrent_jobs_limit,
            concurrent_jobs_running=concurrent_jobs_running,
            cpu_utilization=cpu_utilization,
            max_concurrent_jobs=max_concurrent_jobs,
            node_name=node_name,
            received_bytes=received_bytes,
            sent_bytes=sent_bytes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_properties: Optional[Mapping[str, Any]] = None,
             available_memory_in_mb: Optional[int] = None,
             concurrent_jobs_limit: Optional[int] = None,
             concurrent_jobs_running: Optional[int] = None,
             cpu_utilization: Optional[int] = None,
             max_concurrent_jobs: Optional[int] = None,
             node_name: Optional[str] = None,
             received_bytes: Optional[float] = None,
             sent_bytes: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_properties is None and 'additionalProperties' in kwargs:
            additional_properties = kwargs['additionalProperties']
        if additional_properties is None:
            raise TypeError("Missing 'additional_properties' argument")
        if available_memory_in_mb is None and 'availableMemoryInMB' in kwargs:
            available_memory_in_mb = kwargs['availableMemoryInMB']
        if available_memory_in_mb is None:
            raise TypeError("Missing 'available_memory_in_mb' argument")
        if concurrent_jobs_limit is None and 'concurrentJobsLimit' in kwargs:
            concurrent_jobs_limit = kwargs['concurrentJobsLimit']
        if concurrent_jobs_limit is None:
            raise TypeError("Missing 'concurrent_jobs_limit' argument")
        if concurrent_jobs_running is None and 'concurrentJobsRunning' in kwargs:
            concurrent_jobs_running = kwargs['concurrentJobsRunning']
        if concurrent_jobs_running is None:
            raise TypeError("Missing 'concurrent_jobs_running' argument")
        if cpu_utilization is None and 'cpuUtilization' in kwargs:
            cpu_utilization = kwargs['cpuUtilization']
        if cpu_utilization is None:
            raise TypeError("Missing 'cpu_utilization' argument")
        if max_concurrent_jobs is None and 'maxConcurrentJobs' in kwargs:
            max_concurrent_jobs = kwargs['maxConcurrentJobs']
        if max_concurrent_jobs is None:
            raise TypeError("Missing 'max_concurrent_jobs' argument")
        if node_name is None and 'nodeName' in kwargs:
            node_name = kwargs['nodeName']
        if node_name is None:
            raise TypeError("Missing 'node_name' argument")
        if received_bytes is None and 'receivedBytes' in kwargs:
            received_bytes = kwargs['receivedBytes']
        if received_bytes is None:
            raise TypeError("Missing 'received_bytes' argument")
        if sent_bytes is None and 'sentBytes' in kwargs:
            sent_bytes = kwargs['sentBytes']
        if sent_bytes is None:
            raise TypeError("Missing 'sent_bytes' argument")

        _setter("additional_properties", additional_properties)
        _setter("available_memory_in_mb", available_memory_in_mb)
        _setter("concurrent_jobs_limit", concurrent_jobs_limit)
        _setter("concurrent_jobs_running", concurrent_jobs_running)
        _setter("cpu_utilization", cpu_utilization)
        _setter("max_concurrent_jobs", max_concurrent_jobs)
        _setter("node_name", node_name)
        _setter("received_bytes", received_bytes)
        _setter("sent_bytes", sent_bytes)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Mapping[str, Any]:
        """
         Unmatched properties from the message are deserialized in this collection.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="availableMemoryInMB")
    def available_memory_in_mb(self) -> int:
        """
        Available memory (MB) on the integration runtime node.
        """
        return pulumi.get(self, "available_memory_in_mb")

    @property
    @pulumi.getter(name="concurrentJobsLimit")
    def concurrent_jobs_limit(self) -> int:
        """
        Maximum concurrent jobs on the integration runtime node.
        """
        return pulumi.get(self, "concurrent_jobs_limit")

    @property
    @pulumi.getter(name="concurrentJobsRunning")
    def concurrent_jobs_running(self) -> int:
        """
        The number of jobs currently running on the integration runtime node.
        """
        return pulumi.get(self, "concurrent_jobs_running")

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> int:
        """
        CPU percentage on the integration runtime node.
        """
        return pulumi.get(self, "cpu_utilization")

    @property
    @pulumi.getter(name="maxConcurrentJobs")
    def max_concurrent_jobs(self) -> int:
        """
        The maximum concurrent jobs in this integration runtime.
        """
        return pulumi.get(self, "max_concurrent_jobs")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> str:
        """
        Name of the integration runtime node.
        """
        return pulumi.get(self, "node_name")

    @property
    @pulumi.getter(name="receivedBytes")
    def received_bytes(self) -> float:
        """
        Received bytes on the integration runtime node.
        """
        return pulumi.get(self, "received_bytes")

    @property
    @pulumi.getter(name="sentBytes")
    def sent_bytes(self) -> float:
        """
        Sent bytes on the integration runtime node.
        """
        return pulumi.get(self, "sent_bytes")


@pulumi.output_type
class ODataErrorResponse(dict):
    """
    Error information in OData format.
    """
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 details: Optional[Sequence['outputs.ODataErrorResponse']] = None,
                 message: Optional[str] = None):
        """
        Error information in OData format.
        :param str code: The machine-readable description of the error, such as 'InvalidRequest' or 'InternalServerError'
        :param Sequence['ODataErrorResponse'] details: Inner errors that caused this error
        :param str message: The human-readable description of the error
        """
        ODataErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            details=details,
            message=message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             details: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if code is not None:
            _setter("code", code)
        if details is not None:
            _setter("details", details)
        if message is not None:
            _setter("message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The machine-readable description of the error, such as 'InvalidRequest' or 'InternalServerError'
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.ODataErrorResponse']]:
        """
        Inner errors that caused this error
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The human-readable description of the error
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class OracleConnectionInfoResponse(dict):
    """
    Information for connecting to Oracle server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serverVersion":
            suggest = "server_version"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OracleConnectionInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OracleConnectionInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OracleConnectionInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 type: str,
                 authentication: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 server_name: Optional[str] = None,
                 server_version: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        Information for connecting to Oracle server
        :param str data_source: EZConnect or TNSName connection string.
        :param str type: Type of connection info
               Expected value is 'OracleConnectionInfo'.
        :param str authentication: Authentication type to use for connection
        :param str password: Password credential.
        :param int port: port for server
        :param str server_name: name of the server
        :param str server_version: server version
        :param str user_name: User name
        """
        OracleConnectionInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            type=type,
            authentication=authentication,
            password=password,
            port=port,
            server_name=server_name,
            server_version=server_version,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: Optional[str] = None,
             type: Optional[str] = None,
             authentication: Optional[str] = None,
             password: Optional[str] = None,
             port: Optional[int] = None,
             server_name: Optional[str] = None,
             server_version: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_source is None and 'dataSource' in kwargs:
            data_source = kwargs['dataSource']
        if data_source is None:
            raise TypeError("Missing 'data_source' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_version is None and 'serverVersion' in kwargs:
            server_version = kwargs['serverVersion']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        _setter("data_source", data_source)
        _setter("type", 'OracleConnectionInfo')
        if authentication is not None:
            _setter("authentication", authentication)
        if password is not None:
            _setter("password", password)
        if port is not None:
            _setter("port", port)
        if server_name is not None:
            _setter("server_name", server_name)
        if server_version is not None:
            _setter("server_version", server_version)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        EZConnect or TNSName connection string.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of connection info
        Expected value is 'OracleConnectionInfo'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        """
        Authentication type to use for connection
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password credential.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        port for server
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        name of the server
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[str]:
        """
        server version
        """
        return pulumi.get(self, "server_version")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class OrphanedUserInfoResponse(dict):
    """
    Information of orphaned users on the SQL server database.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrphanedUserInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrphanedUserInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrphanedUserInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Information of orphaned users on the SQL server database.
        :param str database_name: Parent database of the user
        :param str name: Name of the orphaned user
        """
        OrphanedUserInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']

        if database_name is not None:
            _setter("database_name", database_name)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Parent database of the user
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the orphaned user
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PostgreSqlConnectionInfoResponse(dict):
    """
    Information for connecting to PostgreSQL server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverName":
            suggest = "server_name"
        elif key == "additionalSettings":
            suggest = "additional_settings"
        elif key == "dataSource":
            suggest = "data_source"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "encryptConnection":
            suggest = "encrypt_connection"
        elif key == "serverBrandVersion":
            suggest = "server_brand_version"
        elif key == "serverVersion":
            suggest = "server_version"
        elif key == "trustServerCertificate":
            suggest = "trust_server_certificate"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PostgreSqlConnectionInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PostgreSqlConnectionInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PostgreSqlConnectionInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 server_name: str,
                 type: str,
                 additional_settings: Optional[str] = None,
                 authentication: Optional[str] = None,
                 data_source: Optional[str] = None,
                 database_name: Optional[str] = None,
                 encrypt_connection: Optional[bool] = None,
                 password: Optional[str] = None,
                 server_brand_version: Optional[str] = None,
                 server_version: Optional[str] = None,
                 trust_server_certificate: Optional[bool] = None,
                 user_name: Optional[str] = None):
        """
        Information for connecting to PostgreSQL server
        :param int port: Port for Server
        :param str server_name: Name of the server
        :param str type: Type of connection info
               Expected value is 'PostgreSqlConnectionInfo'.
        :param str additional_settings: Additional connection settings
        :param str authentication: Authentication type to use for connection
        :param str data_source: Data source 
        :param str database_name: Name of the database
        :param bool encrypt_connection: Whether to encrypt the connection
        :param str password: Password credential.
        :param str server_brand_version: server brand version
        :param str server_version: server version
        :param bool trust_server_certificate: Whether to trust the server certificate
        :param str user_name: User name
        """
        PostgreSqlConnectionInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            server_name=server_name,
            type=type,
            additional_settings=additional_settings,
            authentication=authentication,
            data_source=data_source,
            database_name=database_name,
            encrypt_connection=encrypt_connection,
            password=password,
            server_brand_version=server_brand_version,
            server_version=server_version,
            trust_server_certificate=trust_server_certificate,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: Optional[int] = None,
             server_name: Optional[str] = None,
             type: Optional[str] = None,
             additional_settings: Optional[str] = None,
             authentication: Optional[str] = None,
             data_source: Optional[str] = None,
             database_name: Optional[str] = None,
             encrypt_connection: Optional[bool] = None,
             password: Optional[str] = None,
             server_brand_version: Optional[str] = None,
             server_version: Optional[str] = None,
             trust_server_certificate: Optional[bool] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if port is None:
            raise TypeError("Missing 'port' argument")
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_name is None:
            raise TypeError("Missing 'server_name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if additional_settings is None and 'additionalSettings' in kwargs:
            additional_settings = kwargs['additionalSettings']
        if data_source is None and 'dataSource' in kwargs:
            data_source = kwargs['dataSource']
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if encrypt_connection is None and 'encryptConnection' in kwargs:
            encrypt_connection = kwargs['encryptConnection']
        if server_brand_version is None and 'serverBrandVersion' in kwargs:
            server_brand_version = kwargs['serverBrandVersion']
        if server_version is None and 'serverVersion' in kwargs:
            server_version = kwargs['serverVersion']
        if trust_server_certificate is None and 'trustServerCertificate' in kwargs:
            trust_server_certificate = kwargs['trustServerCertificate']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        _setter("port", port)
        _setter("server_name", server_name)
        _setter("type", 'PostgreSqlConnectionInfo')
        if additional_settings is not None:
            _setter("additional_settings", additional_settings)
        if authentication is not None:
            _setter("authentication", authentication)
        if data_source is not None:
            _setter("data_source", data_source)
        if database_name is not None:
            _setter("database_name", database_name)
        if encrypt_connection is None:
            encrypt_connection = True
        if encrypt_connection is not None:
            _setter("encrypt_connection", encrypt_connection)
        if password is not None:
            _setter("password", password)
        if server_brand_version is not None:
            _setter("server_brand_version", server_brand_version)
        if server_version is not None:
            _setter("server_version", server_version)
        if trust_server_certificate is None:
            trust_server_certificate = False
        if trust_server_certificate is not None:
            _setter("trust_server_certificate", trust_server_certificate)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port for Server
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        """
        Name of the server
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of connection info
        Expected value is 'PostgreSqlConnectionInfo'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="additionalSettings")
    def additional_settings(self) -> Optional[str]:
        """
        Additional connection settings
        """
        return pulumi.get(self, "additional_settings")

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        """
        Authentication type to use for connection
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        Data source 
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Name of the database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="encryptConnection")
    def encrypt_connection(self) -> Optional[bool]:
        """
        Whether to encrypt the connection
        """
        return pulumi.get(self, "encrypt_connection")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password credential.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="serverBrandVersion")
    def server_brand_version(self) -> Optional[str]:
        """
        server brand version
        """
        return pulumi.get(self, "server_brand_version")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[str]:
        """
        server version
        """
        return pulumi.get(self, "server_version")

    @property
    @pulumi.getter(name="trustServerCertificate")
    def trust_server_certificate(self) -> Optional[bool]:
        """
        Whether to trust the server certificate
        """
        return pulumi.get(self, "trust_server_certificate")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class ProjectFilePropertiesResponse(dict):
    """
    Base class for file properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastModified":
            suggest = "last_modified"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "mediaType":
            suggest = "media_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectFilePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectFilePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectFilePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_modified: str,
                 size: float,
                 extension: Optional[str] = None,
                 file_path: Optional[str] = None,
                 media_type: Optional[str] = None):
        """
        Base class for file properties.
        :param str last_modified: Modification DateTime.
        :param float size: File size.
        :param str extension: Optional File extension. If submitted it should not have a leading period and must match the extension from filePath.
        :param str file_path: Relative path of this file resource. This property can be set when creating or updating the file resource.
        :param str media_type: File content type. This property can be modified to reflect the file content type.
        """
        ProjectFilePropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_modified=last_modified,
            size=size,
            extension=extension,
            file_path=file_path,
            media_type=media_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_modified: Optional[str] = None,
             size: Optional[float] = None,
             extension: Optional[str] = None,
             file_path: Optional[str] = None,
             media_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if last_modified is None and 'lastModified' in kwargs:
            last_modified = kwargs['lastModified']
        if last_modified is None:
            raise TypeError("Missing 'last_modified' argument")
        if size is None:
            raise TypeError("Missing 'size' argument")
        if file_path is None and 'filePath' in kwargs:
            file_path = kwargs['filePath']
        if media_type is None and 'mediaType' in kwargs:
            media_type = kwargs['mediaType']

        _setter("last_modified", last_modified)
        _setter("size", size)
        if extension is not None:
            _setter("extension", extension)
        if file_path is not None:
            _setter("file_path", file_path)
        if media_type is not None:
            _setter("media_type", media_type)

    @property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> str:
        """
        Modification DateTime.
        """
        return pulumi.get(self, "last_modified")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        File size.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def extension(self) -> Optional[str]:
        """
        Optional File extension. If submitted it should not have a leading period and must match the extension from filePath.
        """
        return pulumi.get(self, "extension")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        Relative path of this file resource. This property can be set when creating or updating the file resource.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> Optional[str]:
        """
        File content type. This property can be modified to reflect the file content type.
        """
        return pulumi.get(self, "media_type")


@pulumi.output_type
class QueryAnalysisValidationResultResponse(dict):
    """
    Results for query analysis comparison between the source and target
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryResults":
            suggest = "query_results"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryAnalysisValidationResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryAnalysisValidationResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryAnalysisValidationResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_results: Optional['outputs.QueryExecutionResultResponse'] = None,
                 validation_errors: Optional['outputs.ValidationErrorResponse'] = None):
        """
        Results for query analysis comparison between the source and target
        :param 'QueryExecutionResultResponse' query_results: List of queries executed and it's execution results in source and target
        :param 'ValidationErrorResponse' validation_errors: Errors that are part of the execution
        """
        QueryAnalysisValidationResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_results=query_results,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_results: Optional['outputs.QueryExecutionResultResponse'] = None,
             validation_errors: Optional['outputs.ValidationErrorResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query_results is None and 'queryResults' in kwargs:
            query_results = kwargs['queryResults']
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']

        if query_results is not None:
            _setter("query_results", query_results)
        if validation_errors is not None:
            _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="queryResults")
    def query_results(self) -> Optional['outputs.QueryExecutionResultResponse']:
        """
        List of queries executed and it's execution results in source and target
        """
        return pulumi.get(self, "query_results")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional['outputs.ValidationErrorResponse']:
        """
        Errors that are part of the execution
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class QueryExecutionResultResponse(dict):
    """
    Describes query analysis results for execution in source and target
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryText":
            suggest = "query_text"
        elif key == "sourceResult":
            suggest = "source_result"
        elif key == "statementsInBatch":
            suggest = "statements_in_batch"
        elif key == "targetResult":
            suggest = "target_result"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryExecutionResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryExecutionResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryExecutionResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_text: Optional[str] = None,
                 source_result: Optional['outputs.ExecutionStatisticsResponse'] = None,
                 statements_in_batch: Optional[float] = None,
                 target_result: Optional['outputs.ExecutionStatisticsResponse'] = None):
        """
        Describes query analysis results for execution in source and target
        :param str query_text: Query text retrieved from the source server
        :param 'ExecutionStatisticsResponse' source_result: Query analysis result from the source
        :param float statements_in_batch: Total no. of statements in the batch
        :param 'ExecutionStatisticsResponse' target_result: Query analysis result from the target
        """
        QueryExecutionResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_text=query_text,
            source_result=source_result,
            statements_in_batch=statements_in_batch,
            target_result=target_result,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_text: Optional[str] = None,
             source_result: Optional['outputs.ExecutionStatisticsResponse'] = None,
             statements_in_batch: Optional[float] = None,
             target_result: Optional['outputs.ExecutionStatisticsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query_text is None and 'queryText' in kwargs:
            query_text = kwargs['queryText']
        if source_result is None and 'sourceResult' in kwargs:
            source_result = kwargs['sourceResult']
        if statements_in_batch is None and 'statementsInBatch' in kwargs:
            statements_in_batch = kwargs['statementsInBatch']
        if target_result is None and 'targetResult' in kwargs:
            target_result = kwargs['targetResult']

        if query_text is not None:
            _setter("query_text", query_text)
        if source_result is not None:
            _setter("source_result", source_result)
        if statements_in_batch is not None:
            _setter("statements_in_batch", statements_in_batch)
        if target_result is not None:
            _setter("target_result", target_result)

    @property
    @pulumi.getter(name="queryText")
    def query_text(self) -> Optional[str]:
        """
        Query text retrieved from the source server
        """
        return pulumi.get(self, "query_text")

    @property
    @pulumi.getter(name="sourceResult")
    def source_result(self) -> Optional['outputs.ExecutionStatisticsResponse']:
        """
        Query analysis result from the source
        """
        return pulumi.get(self, "source_result")

    @property
    @pulumi.getter(name="statementsInBatch")
    def statements_in_batch(self) -> Optional[float]:
        """
        Total no. of statements in the batch
        """
        return pulumi.get(self, "statements_in_batch")

    @property
    @pulumi.getter(name="targetResult")
    def target_result(self) -> Optional['outputs.ExecutionStatisticsResponse']:
        """
        Query analysis result from the target
        """
        return pulumi.get(self, "target_result")


@pulumi.output_type
class ReportableExceptionResponse(dict):
    """
    Exception object for all custom exceptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionableMessage":
            suggest = "actionable_message"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "hResult":
            suggest = "h_result"
        elif key == "lineNumber":
            suggest = "line_number"
        elif key == "stackTrace":
            suggest = "stack_trace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReportableExceptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReportableExceptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReportableExceptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actionable_message: Optional[str] = None,
                 file_path: Optional[str] = None,
                 h_result: Optional[int] = None,
                 line_number: Optional[str] = None,
                 message: Optional[str] = None,
                 stack_trace: Optional[str] = None):
        """
        Exception object for all custom exceptions
        :param str actionable_message: Actionable steps for this exception
        :param str file_path: The path to the file where exception occurred
        :param int h_result: Coded numerical value that is assigned to a specific exception
        :param str line_number: The line number where exception occurred
        :param str message: Error message
        :param str stack_trace: Stack trace
        """
        ReportableExceptionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actionable_message=actionable_message,
            file_path=file_path,
            h_result=h_result,
            line_number=line_number,
            message=message,
            stack_trace=stack_trace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actionable_message: Optional[str] = None,
             file_path: Optional[str] = None,
             h_result: Optional[int] = None,
             line_number: Optional[str] = None,
             message: Optional[str] = None,
             stack_trace: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actionable_message is None and 'actionableMessage' in kwargs:
            actionable_message = kwargs['actionableMessage']
        if file_path is None and 'filePath' in kwargs:
            file_path = kwargs['filePath']
        if h_result is None and 'hResult' in kwargs:
            h_result = kwargs['hResult']
        if line_number is None and 'lineNumber' in kwargs:
            line_number = kwargs['lineNumber']
        if stack_trace is None and 'stackTrace' in kwargs:
            stack_trace = kwargs['stackTrace']

        if actionable_message is not None:
            _setter("actionable_message", actionable_message)
        if file_path is not None:
            _setter("file_path", file_path)
        if h_result is not None:
            _setter("h_result", h_result)
        if line_number is not None:
            _setter("line_number", line_number)
        if message is not None:
            _setter("message", message)
        if stack_trace is not None:
            _setter("stack_trace", stack_trace)

    @property
    @pulumi.getter(name="actionableMessage")
    def actionable_message(self) -> Optional[str]:
        """
        Actionable steps for this exception
        """
        return pulumi.get(self, "actionable_message")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        The path to the file where exception occurred
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="hResult")
    def h_result(self) -> Optional[int]:
        """
        Coded numerical value that is assigned to a specific exception
        """
        return pulumi.get(self, "h_result")

    @property
    @pulumi.getter(name="lineNumber")
    def line_number(self) -> Optional[str]:
        """
        The line number where exception occurred
        """
        return pulumi.get(self, "line_number")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Error message
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="stackTrace")
    def stack_trace(self) -> Optional[str]:
        """
        Stack trace
        """
        return pulumi.get(self, "stack_trace")


@pulumi.output_type
class SchemaComparisonValidationResultResponse(dict):
    """
    Results for schema comparison between the source and target
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaDifferences":
            suggest = "schema_differences"
        elif key == "sourceDatabaseObjectCount":
            suggest = "source_database_object_count"
        elif key == "targetDatabaseObjectCount":
            suggest = "target_database_object_count"
        elif key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaComparisonValidationResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaComparisonValidationResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaComparisonValidationResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_differences: Optional['outputs.SchemaComparisonValidationResultTypeResponse'] = None,
                 source_database_object_count: Optional[Mapping[str, float]] = None,
                 target_database_object_count: Optional[Mapping[str, float]] = None,
                 validation_errors: Optional['outputs.ValidationErrorResponse'] = None):
        """
        Results for schema comparison between the source and target
        :param 'SchemaComparisonValidationResultTypeResponse' schema_differences: List of schema differences between the source and target databases
        :param Mapping[str, float] source_database_object_count: Count of source database objects
        :param Mapping[str, float] target_database_object_count: Count of target database objects
        :param 'ValidationErrorResponse' validation_errors: List of errors that happened while performing schema compare validation
        """
        SchemaComparisonValidationResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schema_differences=schema_differences,
            source_database_object_count=source_database_object_count,
            target_database_object_count=target_database_object_count,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schema_differences: Optional['outputs.SchemaComparisonValidationResultTypeResponse'] = None,
             source_database_object_count: Optional[Mapping[str, float]] = None,
             target_database_object_count: Optional[Mapping[str, float]] = None,
             validation_errors: Optional['outputs.ValidationErrorResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if schema_differences is None and 'schemaDifferences' in kwargs:
            schema_differences = kwargs['schemaDifferences']
        if source_database_object_count is None and 'sourceDatabaseObjectCount' in kwargs:
            source_database_object_count = kwargs['sourceDatabaseObjectCount']
        if target_database_object_count is None and 'targetDatabaseObjectCount' in kwargs:
            target_database_object_count = kwargs['targetDatabaseObjectCount']
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']

        if schema_differences is not None:
            _setter("schema_differences", schema_differences)
        if source_database_object_count is not None:
            _setter("source_database_object_count", source_database_object_count)
        if target_database_object_count is not None:
            _setter("target_database_object_count", target_database_object_count)
        if validation_errors is not None:
            _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="schemaDifferences")
    def schema_differences(self) -> Optional['outputs.SchemaComparisonValidationResultTypeResponse']:
        """
        List of schema differences between the source and target databases
        """
        return pulumi.get(self, "schema_differences")

    @property
    @pulumi.getter(name="sourceDatabaseObjectCount")
    def source_database_object_count(self) -> Optional[Mapping[str, float]]:
        """
        Count of source database objects
        """
        return pulumi.get(self, "source_database_object_count")

    @property
    @pulumi.getter(name="targetDatabaseObjectCount")
    def target_database_object_count(self) -> Optional[Mapping[str, float]]:
        """
        Count of target database objects
        """
        return pulumi.get(self, "target_database_object_count")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional['outputs.ValidationErrorResponse']:
        """
        List of errors that happened while performing schema compare validation
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class SchemaComparisonValidationResultTypeResponse(dict):
    """
    Description about the errors happen while performing migration validation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectName":
            suggest = "object_name"
        elif key == "objectType":
            suggest = "object_type"
        elif key == "updateAction":
            suggest = "update_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaComparisonValidationResultTypeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaComparisonValidationResultTypeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaComparisonValidationResultTypeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_name: Optional[str] = None,
                 object_type: Optional[str] = None,
                 update_action: Optional[str] = None):
        """
        Description about the errors happen while performing migration validation
        :param str object_name: Name of the object that has the difference
        :param str object_type: Type of the object that has the difference. e.g (Table/View/StoredProcedure)
        :param str update_action: Update action type with respect to target
        """
        SchemaComparisonValidationResultTypeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object_name=object_name,
            object_type=object_type,
            update_action=update_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object_name: Optional[str] = None,
             object_type: Optional[str] = None,
             update_action: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object_name is None and 'objectName' in kwargs:
            object_name = kwargs['objectName']
        if object_type is None and 'objectType' in kwargs:
            object_type = kwargs['objectType']
        if update_action is None and 'updateAction' in kwargs:
            update_action = kwargs['updateAction']

        if object_name is not None:
            _setter("object_name", object_name)
        if object_type is not None:
            _setter("object_type", object_type)
        if update_action is not None:
            _setter("update_action", update_action)

    @property
    @pulumi.getter(name="objectName")
    def object_name(self) -> Optional[str]:
        """
        Name of the object that has the difference
        """
        return pulumi.get(self, "object_name")

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> Optional[str]:
        """
        Type of the object that has the difference. e.g (Table/View/StoredProcedure)
        """
        return pulumi.get(self, "object_type")

    @property
    @pulumi.getter(name="updateAction")
    def update_action(self) -> Optional[str]:
        """
        Update action type with respect to target
        """
        return pulumi.get(self, "update_action")


@pulumi.output_type
class SelectedCertificateInputResponse(dict):
    """
    Info for certificate to be exported for TDE enabled databases.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateName":
            suggest = "certificate_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelectedCertificateInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelectedCertificateInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelectedCertificateInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_name: str,
                 password: str):
        """
        Info for certificate to be exported for TDE enabled databases.
        :param str certificate_name: Name of certificate to be exported.
        :param str password: Password to use for encrypting the exported certificate.
        """
        SelectedCertificateInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_name=certificate_name,
            password=password,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_name: Optional[str] = None,
             password: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_name is None and 'certificateName' in kwargs:
            certificate_name = kwargs['certificateName']
        if certificate_name is None:
            raise TypeError("Missing 'certificate_name' argument")
        if password is None:
            raise TypeError("Missing 'password' argument")

        _setter("certificate_name", certificate_name)
        _setter("password", password)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> str:
        """
        Name of certificate to be exported.
        """
        return pulumi.get(self, "certificate_name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password to use for encrypting the exported certificate.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class ServerPropertiesResponse(dict):
    """
    Server properties for MySQL type source
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverDatabaseCount":
            suggest = "server_database_count"
        elif key == "serverEdition":
            suggest = "server_edition"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serverOperatingSystemVersion":
            suggest = "server_operating_system_version"
        elif key == "serverPlatform":
            suggest = "server_platform"
        elif key == "serverVersion":
            suggest = "server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_database_count: int,
                 server_edition: str,
                 server_name: str,
                 server_operating_system_version: str,
                 server_platform: str,
                 server_version: str):
        """
        Server properties for MySQL type source
        :param int server_database_count: Number of databases in the server
        :param str server_edition: Edition of the database server
        :param str server_name: Name of the server
        :param str server_operating_system_version: Version of the operating system
        :param str server_platform: Name of the server platform
        :param str server_version: Version of the database server
        """
        ServerPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_database_count=server_database_count,
            server_edition=server_edition,
            server_name=server_name,
            server_operating_system_version=server_operating_system_version,
            server_platform=server_platform,
            server_version=server_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_database_count: Optional[int] = None,
             server_edition: Optional[str] = None,
             server_name: Optional[str] = None,
             server_operating_system_version: Optional[str] = None,
             server_platform: Optional[str] = None,
             server_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if server_database_count is None and 'serverDatabaseCount' in kwargs:
            server_database_count = kwargs['serverDatabaseCount']
        if server_database_count is None:
            raise TypeError("Missing 'server_database_count' argument")
        if server_edition is None and 'serverEdition' in kwargs:
            server_edition = kwargs['serverEdition']
        if server_edition is None:
            raise TypeError("Missing 'server_edition' argument")
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_name is None:
            raise TypeError("Missing 'server_name' argument")
        if server_operating_system_version is None and 'serverOperatingSystemVersion' in kwargs:
            server_operating_system_version = kwargs['serverOperatingSystemVersion']
        if server_operating_system_version is None:
            raise TypeError("Missing 'server_operating_system_version' argument")
        if server_platform is None and 'serverPlatform' in kwargs:
            server_platform = kwargs['serverPlatform']
        if server_platform is None:
            raise TypeError("Missing 'server_platform' argument")
        if server_version is None and 'serverVersion' in kwargs:
            server_version = kwargs['serverVersion']
        if server_version is None:
            raise TypeError("Missing 'server_version' argument")

        _setter("server_database_count", server_database_count)
        _setter("server_edition", server_edition)
        _setter("server_name", server_name)
        _setter("server_operating_system_version", server_operating_system_version)
        _setter("server_platform", server_platform)
        _setter("server_version", server_version)

    @property
    @pulumi.getter(name="serverDatabaseCount")
    def server_database_count(self) -> int:
        """
        Number of databases in the server
        """
        return pulumi.get(self, "server_database_count")

    @property
    @pulumi.getter(name="serverEdition")
    def server_edition(self) -> str:
        """
        Edition of the database server
        """
        return pulumi.get(self, "server_edition")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> str:
        """
        Name of the server
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serverOperatingSystemVersion")
    def server_operating_system_version(self) -> str:
        """
        Version of the operating system
        """
        return pulumi.get(self, "server_operating_system_version")

    @property
    @pulumi.getter(name="serverPlatform")
    def server_platform(self) -> str:
        """
        Name of the server platform
        """
        return pulumi.get(self, "server_platform")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> str:
        """
        Version of the database server
        """
        return pulumi.get(self, "server_version")


@pulumi.output_type
class ServiceSkuResponse(dict):
    """
    An Azure SKU instance
    """
    def __init__(__self__, *,
                 capacity: Optional[int] = None,
                 family: Optional[str] = None,
                 name: Optional[str] = None,
                 size: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        An Azure SKU instance
        :param int capacity: The capacity of the SKU, if it supports scaling
        :param str family: The SKU family, used when the service has multiple performance classes within a tier, such as 'A', 'D', etc. for virtual machines
        :param str name: The unique name of the SKU, such as 'P3'
        :param str size: The size of the SKU, used when the name alone does not denote a service size or when a SKU has multiple performance classes within a family, e.g. 'A1' for virtual machines
        :param str tier: The tier of the SKU, such as 'Basic', 'General Purpose', or 'Business Critical'
        """
        ServiceSkuResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity=capacity,
            family=family,
            name=name,
            size=size,
            tier=tier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity: Optional[int] = None,
             family: Optional[str] = None,
             name: Optional[str] = None,
             size: Optional[str] = None,
             tier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if capacity is not None:
            _setter("capacity", capacity)
        if family is not None:
            _setter("family", family)
        if name is not None:
            _setter("name", name)
        if size is not None:
            _setter("size", size)
        if tier is not None:
            _setter("tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        The capacity of the SKU, if it supports scaling
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        The SKU family, used when the service has multiple performance classes within a tier, such as 'A', 'D', etc. for virtual machines
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The unique name of the SKU, such as 'P3'
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        The size of the SKU, used when the name alone does not denote a service size or when a SKU has multiple performance classes within a family, e.g. 'A1' for virtual machines
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        The tier of the SKU, such as 'Basic', 'General Purpose', or 'Business Critical'
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SqlConnectionInfoResponse(dict):
    """
    Information for connecting to SQL database server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "additionalSettings":
            suggest = "additional_settings"
        elif key == "encryptConnection":
            suggest = "encrypt_connection"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "serverBrandVersion":
            suggest = "server_brand_version"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "serverVersion":
            suggest = "server_version"
        elif key == "trustServerCertificate":
            suggest = "trust_server_certificate"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlConnectionInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlConnectionInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlConnectionInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 type: str,
                 additional_settings: Optional[str] = None,
                 authentication: Optional[str] = None,
                 encrypt_connection: Optional[bool] = None,
                 password: Optional[str] = None,
                 platform: Optional[str] = None,
                 port: Optional[int] = None,
                 resource_id: Optional[str] = None,
                 server_brand_version: Optional[str] = None,
                 server_name: Optional[str] = None,
                 server_version: Optional[str] = None,
                 trust_server_certificate: Optional[bool] = None,
                 user_name: Optional[str] = None):
        """
        Information for connecting to SQL database server
        :param str data_source: Data source in the format Protocol:MachineName\\SQLServerInstanceName,PortNumber
        :param str type: Type of connection info
               Expected value is 'SqlConnectionInfo'.
        :param str additional_settings: Additional connection settings
        :param str authentication: Authentication type to use for connection
        :param bool encrypt_connection: Whether to encrypt the connection
        :param str password: Password credential.
        :param str platform: Server platform type for connection
        :param int port: Port for Server
        :param str resource_id: Represents the ID of an HTTP resource represented by an Azure resource provider.
        :param str server_brand_version: server brand version
        :param str server_name: name of the server
        :param str server_version: server version
        :param bool trust_server_certificate: Whether to trust the server certificate
        :param str user_name: User name
        """
        SqlConnectionInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            type=type,
            additional_settings=additional_settings,
            authentication=authentication,
            encrypt_connection=encrypt_connection,
            password=password,
            platform=platform,
            port=port,
            resource_id=resource_id,
            server_brand_version=server_brand_version,
            server_name=server_name,
            server_version=server_version,
            trust_server_certificate=trust_server_certificate,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: Optional[str] = None,
             type: Optional[str] = None,
             additional_settings: Optional[str] = None,
             authentication: Optional[str] = None,
             encrypt_connection: Optional[bool] = None,
             password: Optional[str] = None,
             platform: Optional[str] = None,
             port: Optional[int] = None,
             resource_id: Optional[str] = None,
             server_brand_version: Optional[str] = None,
             server_name: Optional[str] = None,
             server_version: Optional[str] = None,
             trust_server_certificate: Optional[bool] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_source is None and 'dataSource' in kwargs:
            data_source = kwargs['dataSource']
        if data_source is None:
            raise TypeError("Missing 'data_source' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if additional_settings is None and 'additionalSettings' in kwargs:
            additional_settings = kwargs['additionalSettings']
        if encrypt_connection is None and 'encryptConnection' in kwargs:
            encrypt_connection = kwargs['encryptConnection']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if server_brand_version is None and 'serverBrandVersion' in kwargs:
            server_brand_version = kwargs['serverBrandVersion']
        if server_name is None and 'serverName' in kwargs:
            server_name = kwargs['serverName']
        if server_version is None and 'serverVersion' in kwargs:
            server_version = kwargs['serverVersion']
        if trust_server_certificate is None and 'trustServerCertificate' in kwargs:
            trust_server_certificate = kwargs['trustServerCertificate']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        _setter("data_source", data_source)
        _setter("type", 'SqlConnectionInfo')
        if additional_settings is not None:
            _setter("additional_settings", additional_settings)
        if authentication is not None:
            _setter("authentication", authentication)
        if encrypt_connection is None:
            encrypt_connection = True
        if encrypt_connection is not None:
            _setter("encrypt_connection", encrypt_connection)
        if password is not None:
            _setter("password", password)
        if platform is not None:
            _setter("platform", platform)
        if port is not None:
            _setter("port", port)
        if resource_id is not None:
            _setter("resource_id", resource_id)
        if server_brand_version is not None:
            _setter("server_brand_version", server_brand_version)
        if server_name is not None:
            _setter("server_name", server_name)
        if server_version is not None:
            _setter("server_version", server_version)
        if trust_server_certificate is None:
            trust_server_certificate = False
        if trust_server_certificate is not None:
            _setter("trust_server_certificate", trust_server_certificate)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        Data source in the format Protocol:MachineName\\SQLServerInstanceName,PortNumber
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of connection info
        Expected value is 'SqlConnectionInfo'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="additionalSettings")
    def additional_settings(self) -> Optional[str]:
        """
        Additional connection settings
        """
        return pulumi.get(self, "additional_settings")

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        """
        Authentication type to use for connection
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="encryptConnection")
    def encrypt_connection(self) -> Optional[bool]:
        """
        Whether to encrypt the connection
        """
        return pulumi.get(self, "encrypt_connection")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password credential.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def platform(self) -> Optional[str]:
        """
        Server platform type for connection
        """
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for Server
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        Represents the ID of an HTTP resource represented by an Azure resource provider.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="serverBrandVersion")
    def server_brand_version(self) -> Optional[str]:
        """
        server brand version
        """
        return pulumi.get(self, "server_brand_version")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        name of the server
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[str]:
        """
        server version
        """
        return pulumi.get(self, "server_version")

    @property
    @pulumi.getter(name="trustServerCertificate")
    def trust_server_certificate(self) -> Optional[bool]:
        """
        Whether to trust the server certificate
        """
        return pulumi.get(self, "trust_server_certificate")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class SqlConnectionInformationResponse(dict):
    """
    Source SQL Connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "encryptConnection":
            suggest = "encrypt_connection"
        elif key == "trustServerCertificate":
            suggest = "trust_server_certificate"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlConnectionInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlConnectionInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlConnectionInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: Optional[str] = None,
                 data_source: Optional[str] = None,
                 encrypt_connection: Optional[bool] = None,
                 password: Optional[str] = None,
                 trust_server_certificate: Optional[bool] = None,
                 user_name: Optional[str] = None):
        """
        Source SQL Connection
        :param str authentication: Authentication type.
        :param str data_source: Data source.
        :param bool encrypt_connection: Whether to encrypt connection or not.
        :param str password: Password to connect to source SQL.
        :param bool trust_server_certificate: Whether to trust server certificate or not.
        :param str user_name: User name to connect to source SQL.
        """
        SqlConnectionInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication=authentication,
            data_source=data_source,
            encrypt_connection=encrypt_connection,
            password=password,
            trust_server_certificate=trust_server_certificate,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication: Optional[str] = None,
             data_source: Optional[str] = None,
             encrypt_connection: Optional[bool] = None,
             password: Optional[str] = None,
             trust_server_certificate: Optional[bool] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_source is None and 'dataSource' in kwargs:
            data_source = kwargs['dataSource']
        if encrypt_connection is None and 'encryptConnection' in kwargs:
            encrypt_connection = kwargs['encryptConnection']
        if trust_server_certificate is None and 'trustServerCertificate' in kwargs:
            trust_server_certificate = kwargs['trustServerCertificate']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        if authentication is not None:
            _setter("authentication", authentication)
        if data_source is not None:
            _setter("data_source", data_source)
        if encrypt_connection is not None:
            _setter("encrypt_connection", encrypt_connection)
        if password is not None:
            _setter("password", password)
        if trust_server_certificate is not None:
            _setter("trust_server_certificate", trust_server_certificate)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        """
        Authentication type.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        Data source.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="encryptConnection")
    def encrypt_connection(self) -> Optional[bool]:
        """
        Whether to encrypt connection or not.
        """
        return pulumi.get(self, "encrypt_connection")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password to connect to source SQL.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="trustServerCertificate")
    def trust_server_certificate(self) -> Optional[bool]:
        """
        Whether to trust server certificate or not.
        """
        return pulumi.get(self, "trust_server_certificate")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        User name to connect to source SQL.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class SqlDbMigrationStatusDetailsResponse(dict):
    """
    Detailed status of current Sql Db migration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listOfCopyProgressDetails":
            suggest = "list_of_copy_progress_details"
        elif key == "migrationState":
            suggest = "migration_state"
        elif key == "sqlDataCopyErrors":
            suggest = "sql_data_copy_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlDbMigrationStatusDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlDbMigrationStatusDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlDbMigrationStatusDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 list_of_copy_progress_details: Sequence['outputs.CopyProgressDetailsResponse'],
                 migration_state: str,
                 sql_data_copy_errors: Sequence[str]):
        """
        Detailed status of current Sql Db migration.
        :param Sequence['CopyProgressDetailsResponse'] list_of_copy_progress_details: Details on progress of ADF copy activities.
        :param str migration_state: Current State of Migration.
        :param Sequence[str] sql_data_copy_errors: Sql Data Copy errors, if any.
        """
        SqlDbMigrationStatusDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list_of_copy_progress_details=list_of_copy_progress_details,
            migration_state=migration_state,
            sql_data_copy_errors=sql_data_copy_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list_of_copy_progress_details: Optional[Sequence['outputs.CopyProgressDetailsResponse']] = None,
             migration_state: Optional[str] = None,
             sql_data_copy_errors: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if list_of_copy_progress_details is None and 'listOfCopyProgressDetails' in kwargs:
            list_of_copy_progress_details = kwargs['listOfCopyProgressDetails']
        if list_of_copy_progress_details is None:
            raise TypeError("Missing 'list_of_copy_progress_details' argument")
        if migration_state is None and 'migrationState' in kwargs:
            migration_state = kwargs['migrationState']
        if migration_state is None:
            raise TypeError("Missing 'migration_state' argument")
        if sql_data_copy_errors is None and 'sqlDataCopyErrors' in kwargs:
            sql_data_copy_errors = kwargs['sqlDataCopyErrors']
        if sql_data_copy_errors is None:
            raise TypeError("Missing 'sql_data_copy_errors' argument")

        _setter("list_of_copy_progress_details", list_of_copy_progress_details)
        _setter("migration_state", migration_state)
        _setter("sql_data_copy_errors", sql_data_copy_errors)

    @property
    @pulumi.getter(name="listOfCopyProgressDetails")
    def list_of_copy_progress_details(self) -> Sequence['outputs.CopyProgressDetailsResponse']:
        """
        Details on progress of ADF copy activities.
        """
        return pulumi.get(self, "list_of_copy_progress_details")

    @property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> str:
        """
        Current State of Migration.
        """
        return pulumi.get(self, "migration_state")

    @property
    @pulumi.getter(name="sqlDataCopyErrors")
    def sql_data_copy_errors(self) -> Sequence[str]:
        """
        Sql Data Copy errors, if any.
        """
        return pulumi.get(self, "sql_data_copy_errors")


@pulumi.output_type
class SqlDbOfflineConfigurationResponse(dict):
    """
    Offline configuration
    """
    def __init__(__self__, *,
                 offline: bool):
        """
        Offline configuration
        :param bool offline: Offline migration
        """
        SqlDbOfflineConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            offline=offline,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             offline: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if offline is None:
            raise TypeError("Missing 'offline' argument")

        _setter("offline", offline)

    @property
    @pulumi.getter
    def offline(self) -> bool:
        """
        Offline migration
        """
        return pulumi.get(self, "offline")


@pulumi.output_type
class SsisMigrationInfoResponse(dict):
    """
    SSIS migration info with SSIS store type, overwrite policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentOverwriteOption":
            suggest = "environment_overwrite_option"
        elif key == "projectOverwriteOption":
            suggest = "project_overwrite_option"
        elif key == "ssisStoreType":
            suggest = "ssis_store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsisMigrationInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsisMigrationInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsisMigrationInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_overwrite_option: Optional[str] = None,
                 project_overwrite_option: Optional[str] = None,
                 ssis_store_type: Optional[str] = None):
        """
        SSIS migration info with SSIS store type, overwrite policy.
        :param str environment_overwrite_option: The overwrite option for the SSIS environment migration
        :param str project_overwrite_option: The overwrite option for the SSIS project migration
        :param str ssis_store_type: The SSIS store type of source, only SSIS catalog is supported now in DMS (classic)
        """
        SsisMigrationInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            environment_overwrite_option=environment_overwrite_option,
            project_overwrite_option=project_overwrite_option,
            ssis_store_type=ssis_store_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             environment_overwrite_option: Optional[str] = None,
             project_overwrite_option: Optional[str] = None,
             ssis_store_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if environment_overwrite_option is None and 'environmentOverwriteOption' in kwargs:
            environment_overwrite_option = kwargs['environmentOverwriteOption']
        if project_overwrite_option is None and 'projectOverwriteOption' in kwargs:
            project_overwrite_option = kwargs['projectOverwriteOption']
        if ssis_store_type is None and 'ssisStoreType' in kwargs:
            ssis_store_type = kwargs['ssisStoreType']

        if environment_overwrite_option is not None:
            _setter("environment_overwrite_option", environment_overwrite_option)
        if project_overwrite_option is not None:
            _setter("project_overwrite_option", project_overwrite_option)
        if ssis_store_type is not None:
            _setter("ssis_store_type", ssis_store_type)

    @property
    @pulumi.getter(name="environmentOverwriteOption")
    def environment_overwrite_option(self) -> Optional[str]:
        """
        The overwrite option for the SSIS environment migration
        """
        return pulumi.get(self, "environment_overwrite_option")

    @property
    @pulumi.getter(name="projectOverwriteOption")
    def project_overwrite_option(self) -> Optional[str]:
        """
        The overwrite option for the SSIS project migration
        """
        return pulumi.get(self, "project_overwrite_option")

    @property
    @pulumi.getter(name="ssisStoreType")
    def ssis_store_type(self) -> Optional[str]:
        """
        The SSIS store type of source, only SSIS catalog is supported now in DMS (classic)
        """
        return pulumi.get(self, "ssis_store_type")


@pulumi.output_type
class StartMigrationScenarioServerRoleResultResponse(dict):
    """
    Server role migration result
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exceptionsAndWarnings":
            suggest = "exceptions_and_warnings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StartMigrationScenarioServerRoleResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StartMigrationScenarioServerRoleResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StartMigrationScenarioServerRoleResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exceptions_and_warnings: Sequence['outputs.ReportableExceptionResponse'],
                 name: str,
                 state: str):
        """
        Server role migration result
        :param Sequence['ReportableExceptionResponse'] exceptions_and_warnings: Migration exceptions and warnings.
        :param str name: Name of server role.
        :param str state: Current state of migration
        """
        StartMigrationScenarioServerRoleResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exceptions_and_warnings=exceptions_and_warnings,
            name=name,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exceptions_and_warnings: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             name: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exceptions_and_warnings is None and 'exceptionsAndWarnings' in kwargs:
            exceptions_and_warnings = kwargs['exceptionsAndWarnings']
        if exceptions_and_warnings is None:
            raise TypeError("Missing 'exceptions_and_warnings' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("exceptions_and_warnings", exceptions_and_warnings)
        _setter("name", name)
        _setter("state", state)

    @property
    @pulumi.getter(name="exceptionsAndWarnings")
    def exceptions_and_warnings(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Migration exceptions and warnings.
        """
        return pulumi.get(self, "exceptions_and_warnings")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of server role.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of migration
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class SyncMigrationDatabaseErrorEventResponse(dict):
    """
    Database migration errors for online migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventText":
            suggest = "event_text"
        elif key == "eventTypeString":
            suggest = "event_type_string"
        elif key == "timestampString":
            suggest = "timestamp_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyncMigrationDatabaseErrorEventResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyncMigrationDatabaseErrorEventResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyncMigrationDatabaseErrorEventResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_text: str,
                 event_type_string: str,
                 timestamp_string: str):
        """
        Database migration errors for online migration
        :param str event_text: Event text.
        :param str event_type_string: Event type.
        :param str timestamp_string: String value of timestamp.
        """
        SyncMigrationDatabaseErrorEventResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_text=event_text,
            event_type_string=event_type_string,
            timestamp_string=timestamp_string,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_text: Optional[str] = None,
             event_type_string: Optional[str] = None,
             timestamp_string: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if event_text is None and 'eventText' in kwargs:
            event_text = kwargs['eventText']
        if event_text is None:
            raise TypeError("Missing 'event_text' argument")
        if event_type_string is None and 'eventTypeString' in kwargs:
            event_type_string = kwargs['eventTypeString']
        if event_type_string is None:
            raise TypeError("Missing 'event_type_string' argument")
        if timestamp_string is None and 'timestampString' in kwargs:
            timestamp_string = kwargs['timestampString']
        if timestamp_string is None:
            raise TypeError("Missing 'timestamp_string' argument")

        _setter("event_text", event_text)
        _setter("event_type_string", event_type_string)
        _setter("timestamp_string", timestamp_string)

    @property
    @pulumi.getter(name="eventText")
    def event_text(self) -> str:
        """
        Event text.
        """
        return pulumi.get(self, "event_text")

    @property
    @pulumi.getter(name="eventTypeString")
    def event_type_string(self) -> str:
        """
        Event type.
        """
        return pulumi.get(self, "event_type_string")

    @property
    @pulumi.getter(name="timestampString")
    def timestamp_string(self) -> str:
        """
        String value of timestamp.
        """
        return pulumi.get(self, "timestamp_string")


@pulumi.output_type
class SystemDataResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class ValidateMigrationInputSqlServerSqlDbSyncTaskPropertiesResponse(dict):
    """
    Properties for task that validates migration input for SQL to Azure SQL DB sync migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateMigrationInputSqlServerSqlDbSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateMigrationInputSqlServerSqlDbSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateMigrationInputSqlServerSqlDbSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ValidateSyncMigrationInputSqlServerTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ValidateSyncMigrationInputSqlServerTaskInputResponse'] = None):
        """
        Properties for task that validates migration input for SQL to Azure SQL DB sync migrations
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ValidateSyncMigrationInputSqlServerTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ValidateMigrationInput.SqlServer.SqlDb.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ValidateSyncMigrationInputSqlServerTaskInputResponse' input: Task input
        """
        ValidateMigrationInputSqlServerSqlDbSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ValidateSyncMigrationInputSqlServerTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ValidateSyncMigrationInputSqlServerTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ValidateMigrationInput.SqlServer.SqlDb.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ValidateSyncMigrationInputSqlServerTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ValidateMigrationInput.SqlServer.SqlDb.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ValidateSyncMigrationInputSqlServerTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse(dict):
    """
    Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance online scenario.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureApp":
            suggest = "azure_app"
        elif key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "storageResourceId":
            suggest = "storage_resource_id"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "backupFileShare":
            suggest = "backup_file_share"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_app: 'outputs.AzureActiveDirectoryAppResponse',
                 selected_databases: Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse'],
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 storage_resource_id: str,
                 target_connection_info: 'outputs.MiSqlConnectionInfoResponse',
                 backup_file_share: Optional['outputs.FileShareResponse'] = None):
        """
        Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance online scenario.
        :param 'AzureActiveDirectoryAppResponse' azure_app: Azure Active Directory Application the DMS (classic) instance will use to connect to the target instance of Azure SQL Database Managed Instance and the Azure Storage Account
        :param Sequence['MigrateSqlServerSqlMIDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'SqlConnectionInfoResponse' source_connection_info: Connection information for source SQL Server
        :param str storage_resource_id: Fully qualified resourceId of storage
        :param 'MiSqlConnectionInfoResponse' target_connection_info: Connection information for Azure SQL Database Managed Instance
        :param 'FileShareResponse' backup_file_share: Backup file share information for all selected databases.
        """
        ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_app=azure_app,
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            storage_resource_id=storage_resource_id,
            target_connection_info=target_connection_info,
            backup_file_share=backup_file_share,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_app: Optional['outputs.AzureActiveDirectoryAppResponse'] = None,
             selected_databases: Optional[Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             storage_resource_id: Optional[str] = None,
             target_connection_info: Optional['outputs.MiSqlConnectionInfoResponse'] = None,
             backup_file_share: Optional['outputs.FileShareResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_app is None and 'azureApp' in kwargs:
            azure_app = kwargs['azureApp']
        if azure_app is None:
            raise TypeError("Missing 'azure_app' argument")
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if storage_resource_id is None and 'storageResourceId' in kwargs:
            storage_resource_id = kwargs['storageResourceId']
        if storage_resource_id is None:
            raise TypeError("Missing 'storage_resource_id' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if backup_file_share is None and 'backupFileShare' in kwargs:
            backup_file_share = kwargs['backupFileShare']

        _setter("azure_app", azure_app)
        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("storage_resource_id", storage_resource_id)
        _setter("target_connection_info", target_connection_info)
        if backup_file_share is not None:
            _setter("backup_file_share", backup_file_share)

    @property
    @pulumi.getter(name="azureApp")
    def azure_app(self) -> 'outputs.AzureActiveDirectoryAppResponse':
        """
        Azure Active Directory Application the DMS (classic) instance will use to connect to the target instance of Azure SQL Database Managed Instance and the Azure Storage Account
        """
        return pulumi.get(self, "azure_app")

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Connection information for source SQL Server
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> str:
        """
        Fully qualified resourceId of storage
        """
        return pulumi.get(self, "storage_resource_id")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.MiSqlConnectionInfoResponse':
        """
        Connection information for Azure SQL Database Managed Instance
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="backupFileShare")
    def backup_file_share(self) -> Optional['outputs.FileShareResponse']:
        """
        Backup file share information for all selected databases.
        """
        return pulumi.get(self, "backup_file_share")


@pulumi.output_type
class ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse(dict):
    """
    Output for task that validates migration input for Azure SQL Database Managed Instance online migration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for task that validates migration input for Azure SQL Database Managed Instance online migration
        :param str id: Database identifier
        :param str name: Name of database
        :param Sequence['ReportableExceptionResponse'] validation_errors: Errors associated with a selected database object
        """
        ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Database identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Errors associated with a selected database object
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ValidateMigrationInputSqlServerSqlMISyncTaskPropertiesResponse(dict):
    """
    Properties for task that validates migration input for SQL to Azure SQL Database Managed Instance sync scenario
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateMigrationInputSqlServerSqlMISyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateMigrationInputSqlServerSqlMISyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateMigrationInputSqlServerSqlMISyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse'] = None):
        """
        Properties for task that validates migration input for SQL to Azure SQL Database Managed Instance sync scenario
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ValidateMigrationInput.SqlServer.AzureSqlDbMI.Sync.LRS'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse' input: Task input
        """
        ValidateMigrationInputSqlServerSqlMISyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ValidateMigrationInput.SqlServer.AzureSqlDbMI.Sync.LRS')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ValidateMigrationInputSqlServerSqlMISyncTaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ValidateMigrationInput.SqlServer.AzureSqlDbMI.Sync.LRS'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ValidateMigrationInputSqlServerSqlMISyncTaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ValidateMigrationInputSqlServerSqlMITaskInputResponse(dict):
    """
    Input for task that validates migration input for SQL to Azure SQL Managed Instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupBlobShare":
            suggest = "backup_blob_share"
        elif key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"
        elif key == "backupFileShare":
            suggest = "backup_file_share"
        elif key == "backupMode":
            suggest = "backup_mode"
        elif key == "selectedLogins":
            suggest = "selected_logins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateMigrationInputSqlServerSqlMITaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateMigrationInputSqlServerSqlMITaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateMigrationInputSqlServerSqlMITaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_blob_share: 'outputs.BlobShareResponse',
                 selected_databases: Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse'],
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 target_connection_info: 'outputs.SqlConnectionInfoResponse',
                 backup_file_share: Optional['outputs.FileShareResponse'] = None,
                 backup_mode: Optional[str] = None,
                 selected_logins: Optional[Sequence[str]] = None):
        """
        Input for task that validates migration input for SQL to Azure SQL Managed Instance
        :param 'BlobShareResponse' backup_blob_share: SAS URI of Azure Storage Account Container to be used for storing backup files.
        :param Sequence['MigrateSqlServerSqlMIDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'SqlConnectionInfoResponse' source_connection_info: Information for connecting to source
        :param 'SqlConnectionInfoResponse' target_connection_info: Information for connecting to target
        :param 'FileShareResponse' backup_file_share: Backup file share information for all selected databases.
        :param str backup_mode: Backup Mode to specify whether to use existing backup or create new backup.
        :param Sequence[str] selected_logins: Logins to migrate
        """
        ValidateMigrationInputSqlServerSqlMITaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_blob_share=backup_blob_share,
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
            backup_file_share=backup_file_share,
            backup_mode=backup_mode,
            selected_logins=selected_logins,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_blob_share: Optional['outputs.BlobShareResponse'] = None,
             selected_databases: Optional[Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             backup_file_share: Optional['outputs.FileShareResponse'] = None,
             backup_mode: Optional[str] = None,
             selected_logins: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_blob_share is None and 'backupBlobShare' in kwargs:
            backup_blob_share = kwargs['backupBlobShare']
        if backup_blob_share is None:
            raise TypeError("Missing 'backup_blob_share' argument")
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")
        if backup_file_share is None and 'backupFileShare' in kwargs:
            backup_file_share = kwargs['backupFileShare']
        if backup_mode is None and 'backupMode' in kwargs:
            backup_mode = kwargs['backupMode']
        if selected_logins is None and 'selectedLogins' in kwargs:
            selected_logins = kwargs['selectedLogins']

        _setter("backup_blob_share", backup_blob_share)
        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)
        if backup_file_share is not None:
            _setter("backup_file_share", backup_file_share)
        if backup_mode is not None:
            _setter("backup_mode", backup_mode)
        if selected_logins is not None:
            _setter("selected_logins", selected_logins)

    @property
    @pulumi.getter(name="backupBlobShare")
    def backup_blob_share(self) -> 'outputs.BlobShareResponse':
        """
        SAS URI of Azure Storage Account Container to be used for storing backup files.
        """
        return pulumi.get(self, "backup_blob_share")

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateSqlServerSqlMIDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to source
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to target
        """
        return pulumi.get(self, "target_connection_info")

    @property
    @pulumi.getter(name="backupFileShare")
    def backup_file_share(self) -> Optional['outputs.FileShareResponse']:
        """
        Backup file share information for all selected databases.
        """
        return pulumi.get(self, "backup_file_share")

    @property
    @pulumi.getter(name="backupMode")
    def backup_mode(self) -> Optional[str]:
        """
        Backup Mode to specify whether to use existing backup or create new backup.
        """
        return pulumi.get(self, "backup_mode")

    @property
    @pulumi.getter(name="selectedLogins")
    def selected_logins(self) -> Optional[Sequence[str]]:
        """
        Logins to migrate
        """
        return pulumi.get(self, "selected_logins")


@pulumi.output_type
class ValidateMigrationInputSqlServerSqlMITaskOutputResponse(dict):
    """
    Output for task that validates migration input for SQL to Azure SQL Managed Instance migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupFolderErrors":
            suggest = "backup_folder_errors"
        elif key == "backupShareCredentialsErrors":
            suggest = "backup_share_credentials_errors"
        elif key == "backupStorageAccountErrors":
            suggest = "backup_storage_account_errors"
        elif key == "existingBackupErrors":
            suggest = "existing_backup_errors"
        elif key == "restoreDatabaseNameErrors":
            suggest = "restore_database_name_errors"
        elif key == "databaseBackupInfo":
            suggest = "database_backup_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateMigrationInputSqlServerSqlMITaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateMigrationInputSqlServerSqlMITaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateMigrationInputSqlServerSqlMITaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_folder_errors: Sequence['outputs.ReportableExceptionResponse'],
                 backup_share_credentials_errors: Sequence['outputs.ReportableExceptionResponse'],
                 backup_storage_account_errors: Sequence['outputs.ReportableExceptionResponse'],
                 existing_backup_errors: Sequence['outputs.ReportableExceptionResponse'],
                 id: str,
                 name: str,
                 restore_database_name_errors: Sequence['outputs.ReportableExceptionResponse'],
                 database_backup_info: Optional['outputs.DatabaseBackupInfoResponse'] = None):
        """
        Output for task that validates migration input for SQL to Azure SQL Managed Instance migrations
        :param Sequence['ReportableExceptionResponse'] backup_folder_errors: Errors associated with the BackupFolder path
        :param Sequence['ReportableExceptionResponse'] backup_share_credentials_errors: Errors associated with backup share user name and password credentials
        :param Sequence['ReportableExceptionResponse'] backup_storage_account_errors: Errors associated with the storage account provided.
        :param Sequence['ReportableExceptionResponse'] existing_backup_errors: Errors associated with existing backup files.
        :param str id: Result identifier
        :param str name: Name of database
        :param Sequence['ReportableExceptionResponse'] restore_database_name_errors: Errors associated with the RestoreDatabaseName
        :param 'DatabaseBackupInfoResponse' database_backup_info: Information about backup files when existing backup mode is used.
        """
        ValidateMigrationInputSqlServerSqlMITaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_folder_errors=backup_folder_errors,
            backup_share_credentials_errors=backup_share_credentials_errors,
            backup_storage_account_errors=backup_storage_account_errors,
            existing_backup_errors=existing_backup_errors,
            id=id,
            name=name,
            restore_database_name_errors=restore_database_name_errors,
            database_backup_info=database_backup_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_folder_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             backup_share_credentials_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             backup_storage_account_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             existing_backup_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             restore_database_name_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             database_backup_info: Optional['outputs.DatabaseBackupInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_folder_errors is None and 'backupFolderErrors' in kwargs:
            backup_folder_errors = kwargs['backupFolderErrors']
        if backup_folder_errors is None:
            raise TypeError("Missing 'backup_folder_errors' argument")
        if backup_share_credentials_errors is None and 'backupShareCredentialsErrors' in kwargs:
            backup_share_credentials_errors = kwargs['backupShareCredentialsErrors']
        if backup_share_credentials_errors is None:
            raise TypeError("Missing 'backup_share_credentials_errors' argument")
        if backup_storage_account_errors is None and 'backupStorageAccountErrors' in kwargs:
            backup_storage_account_errors = kwargs['backupStorageAccountErrors']
        if backup_storage_account_errors is None:
            raise TypeError("Missing 'backup_storage_account_errors' argument")
        if existing_backup_errors is None and 'existingBackupErrors' in kwargs:
            existing_backup_errors = kwargs['existingBackupErrors']
        if existing_backup_errors is None:
            raise TypeError("Missing 'existing_backup_errors' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if restore_database_name_errors is None and 'restoreDatabaseNameErrors' in kwargs:
            restore_database_name_errors = kwargs['restoreDatabaseNameErrors']
        if restore_database_name_errors is None:
            raise TypeError("Missing 'restore_database_name_errors' argument")
        if database_backup_info is None and 'databaseBackupInfo' in kwargs:
            database_backup_info = kwargs['databaseBackupInfo']

        _setter("backup_folder_errors", backup_folder_errors)
        _setter("backup_share_credentials_errors", backup_share_credentials_errors)
        _setter("backup_storage_account_errors", backup_storage_account_errors)
        _setter("existing_backup_errors", existing_backup_errors)
        _setter("id", id)
        _setter("name", name)
        _setter("restore_database_name_errors", restore_database_name_errors)
        if database_backup_info is not None:
            _setter("database_backup_info", database_backup_info)

    @property
    @pulumi.getter(name="backupFolderErrors")
    def backup_folder_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Errors associated with the BackupFolder path
        """
        return pulumi.get(self, "backup_folder_errors")

    @property
    @pulumi.getter(name="backupShareCredentialsErrors")
    def backup_share_credentials_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Errors associated with backup share user name and password credentials
        """
        return pulumi.get(self, "backup_share_credentials_errors")

    @property
    @pulumi.getter(name="backupStorageAccountErrors")
    def backup_storage_account_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Errors associated with the storage account provided.
        """
        return pulumi.get(self, "backup_storage_account_errors")

    @property
    @pulumi.getter(name="existingBackupErrors")
    def existing_backup_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Errors associated with existing backup files.
        """
        return pulumi.get(self, "existing_backup_errors")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Result identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="restoreDatabaseNameErrors")
    def restore_database_name_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Errors associated with the RestoreDatabaseName
        """
        return pulumi.get(self, "restore_database_name_errors")

    @property
    @pulumi.getter(name="databaseBackupInfo")
    def database_backup_info(self) -> Optional['outputs.DatabaseBackupInfoResponse']:
        """
        Information about backup files when existing backup mode is used.
        """
        return pulumi.get(self, "database_backup_info")


@pulumi.output_type
class ValidateMigrationInputSqlServerSqlMITaskPropertiesResponse(dict):
    """
    Properties for task that validates migration input for SQL to Azure SQL Database Managed Instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateMigrationInputSqlServerSqlMITaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateMigrationInputSqlServerSqlMITaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateMigrationInputSqlServerSqlMITaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ValidateMigrationInputSqlServerSqlMITaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.ValidateMigrationInputSqlServerSqlMITaskInputResponse'] = None):
        """
        Properties for task that validates migration input for SQL to Azure SQL Database Managed Instance
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ValidateMigrationInputSqlServerSqlMITaskOutputResponse'] output: Task output. This is ignored if submitted.
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'ValidateMigrationInput.SqlServer.AzureSqlDbMI'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'ValidateMigrationInputSqlServerSqlMITaskInputResponse' input: Task input
        """
        ValidateMigrationInputSqlServerSqlMITaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ValidateMigrationInputSqlServerSqlMITaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.ValidateMigrationInputSqlServerSqlMITaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'ValidateMigrationInput.SqlServer.AzureSqlDbMI')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ValidateMigrationInputSqlServerSqlMITaskOutputResponse']:
        """
        Task output. This is ignored if submitted.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'ValidateMigrationInput.SqlServer.AzureSqlDbMI'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.ValidateMigrationInputSqlServerSqlMITaskInputResponse']:
        """
        Task input
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ValidateMongoDbTaskPropertiesResponse(dict):
    """
    Properties for the task that validates a migration between MongoDB data sources
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateMongoDbTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateMongoDbTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateMongoDbTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.MongoDbMigrationProgressResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.MongoDbMigrationSettingsResponse'] = None):
        """
        Properties for the task that validates a migration between MongoDB data sources
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['MongoDbMigrationProgressResponse'] output: An array containing a single MongoDbMigrationProgress object
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Validate.MongoDb'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'MongoDbMigrationSettingsResponse' input: Describes how a MongoDB data migration should be performed
        """
        ValidateMongoDbTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.MongoDbMigrationProgressResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.MongoDbMigrationSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Validate.MongoDb')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.MongoDbMigrationProgressResponse']:
        """
        An array containing a single MongoDbMigrationProgress object
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Validate.MongoDb'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MongoDbMigrationSettingsResponse']:
        """
        Describes how a MongoDB data migration should be performed
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ValidateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse(dict):
    """
    Properties for the task that validates a migration for Oracle to Azure Database for PostgreSQL for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskType":
            suggest = "task_type"
        elif key == "clientData":
            suggest = "client_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[Any],
                 errors: Sequence['outputs.ODataErrorResponse'],
                 output: Sequence['outputs.ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse'],
                 state: str,
                 task_type: str,
                 client_data: Optional[Mapping[str, str]] = None,
                 input: Optional['outputs.MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse'] = None):
        """
        Properties for the task that validates a migration for Oracle to Azure Database for PostgreSQL for online migrations
        :param Sequence[Union['MigrateMISyncCompleteCommandPropertiesResponse', 'MigrateSyncCompleteCommandPropertiesResponse']] commands: Array of command properties.
        :param Sequence['ODataErrorResponse'] errors: Array of errors. This is ignored if submitted.
        :param Sequence['ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse'] output: An array containing a single validation error response object
        :param str state: The state of the task. This is ignored if submitted.
        :param str task_type: Task type.
               Expected value is 'Validate.Oracle.AzureDbPostgreSql.Sync'.
        :param Mapping[str, str] client_data: Key value pairs of client data to attach meta data information to task
        :param 'MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse' input: Input for the task that migrates Oracle databases to Azure Database for PostgreSQL for online migrations
        """
        ValidateOracleAzureDbForPostgreSqlSyncTaskPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            errors=errors,
            output=output,
            state=state,
            task_type=task_type,
            client_data=client_data,
            input=input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[Any]] = None,
             errors: Optional[Sequence['outputs.ODataErrorResponse']] = None,
             output: Optional[Sequence['outputs.ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse']] = None,
             state: Optional[str] = None,
             task_type: Optional[str] = None,
             client_data: Optional[Mapping[str, str]] = None,
             input: Optional['outputs.MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if output is None:
            raise TypeError("Missing 'output' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if task_type is None and 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if task_type is None:
            raise TypeError("Missing 'task_type' argument")
        if client_data is None and 'clientData' in kwargs:
            client_data = kwargs['clientData']

        _setter("commands", commands)
        _setter("errors", errors)
        _setter("output", output)
        _setter("state", state)
        _setter("task_type", 'Validate.Oracle.AzureDbPostgreSql.Sync')
        if client_data is not None:
            _setter("client_data", client_data)
        if input is not None:
            _setter("input", input)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[Any]:
        """
        Array of command properties.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.ODataErrorResponse']:
        """
        Array of errors. This is ignored if submitted.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def output(self) -> Sequence['outputs.ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse']:
        """
        An array containing a single validation error response object
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the task. This is ignored if submitted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        Task type.
        Expected value is 'Validate.Oracle.AzureDbPostgreSql.Sync'.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="clientData")
    def client_data(self) -> Optional[Mapping[str, str]]:
        """
        Key value pairs of client data to attach meta data information to task
        """
        return pulumi.get(self, "client_data")

    @property
    @pulumi.getter
    def input(self) -> Optional['outputs.MigrateOracleAzureDbPostgreSqlSyncTaskInputResponse']:
        """
        Input for the task that migrates Oracle databases to Azure Database for PostgreSQL for online migrations
        """
        return pulumi.get(self, "input")


@pulumi.output_type
class ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse(dict):
    """
    Output for task that validates migration input for Oracle to Azure Database for PostgreSQL for online migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for task that validates migration input for Oracle to Azure Database for PostgreSQL for online migrations
        :param Sequence['ReportableExceptionResponse'] validation_errors: Errors associated with a selected database object
        """
        ValidateOracleAzureDbPostgreSqlSyncTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Errors associated with a selected database object
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ValidateSyncMigrationInputSqlServerTaskInputResponse(dict):
    """
    Input for task that validates migration input for SQL sync migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedDatabases":
            suggest = "selected_databases"
        elif key == "sourceConnectionInfo":
            suggest = "source_connection_info"
        elif key == "targetConnectionInfo":
            suggest = "target_connection_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateSyncMigrationInputSqlServerTaskInputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateSyncMigrationInputSqlServerTaskInputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateSyncMigrationInputSqlServerTaskInputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_databases: Sequence['outputs.MigrateSqlServerSqlDbSyncDatabaseInputResponse'],
                 source_connection_info: 'outputs.SqlConnectionInfoResponse',
                 target_connection_info: 'outputs.SqlConnectionInfoResponse'):
        """
        Input for task that validates migration input for SQL sync migrations
        :param Sequence['MigrateSqlServerSqlDbSyncDatabaseInputResponse'] selected_databases: Databases to migrate
        :param 'SqlConnectionInfoResponse' source_connection_info: Information for connecting to source SQL server
        :param 'SqlConnectionInfoResponse' target_connection_info: Information for connecting to target
        """
        ValidateSyncMigrationInputSqlServerTaskInputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            selected_databases=selected_databases,
            source_connection_info=source_connection_info,
            target_connection_info=target_connection_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             selected_databases: Optional[Sequence['outputs.MigrateSqlServerSqlDbSyncDatabaseInputResponse']] = None,
             source_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             target_connection_info: Optional['outputs.SqlConnectionInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if selected_databases is None and 'selectedDatabases' in kwargs:
            selected_databases = kwargs['selectedDatabases']
        if selected_databases is None:
            raise TypeError("Missing 'selected_databases' argument")
        if source_connection_info is None and 'sourceConnectionInfo' in kwargs:
            source_connection_info = kwargs['sourceConnectionInfo']
        if source_connection_info is None:
            raise TypeError("Missing 'source_connection_info' argument")
        if target_connection_info is None and 'targetConnectionInfo' in kwargs:
            target_connection_info = kwargs['targetConnectionInfo']
        if target_connection_info is None:
            raise TypeError("Missing 'target_connection_info' argument")

        _setter("selected_databases", selected_databases)
        _setter("source_connection_info", source_connection_info)
        _setter("target_connection_info", target_connection_info)

    @property
    @pulumi.getter(name="selectedDatabases")
    def selected_databases(self) -> Sequence['outputs.MigrateSqlServerSqlDbSyncDatabaseInputResponse']:
        """
        Databases to migrate
        """
        return pulumi.get(self, "selected_databases")

    @property
    @pulumi.getter(name="sourceConnectionInfo")
    def source_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to source SQL server
        """
        return pulumi.get(self, "source_connection_info")

    @property
    @pulumi.getter(name="targetConnectionInfo")
    def target_connection_info(self) -> 'outputs.SqlConnectionInfoResponse':
        """
        Information for connecting to target
        """
        return pulumi.get(self, "target_connection_info")


@pulumi.output_type
class ValidateSyncMigrationInputSqlServerTaskOutputResponse(dict):
    """
    Output for task that validates migration input for SQL sync migrations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationErrors":
            suggest = "validation_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidateSyncMigrationInputSqlServerTaskOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidateSyncMigrationInputSqlServerTaskOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidateSyncMigrationInputSqlServerTaskOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 validation_errors: Sequence['outputs.ReportableExceptionResponse']):
        """
        Output for task that validates migration input for SQL sync migrations
        :param str id: Database identifier
        :param str name: Name of database
        :param Sequence['ReportableExceptionResponse'] validation_errors: Errors associated with a selected database object
        """
        ValidateSyncMigrationInputSqlServerTaskOutputResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            validation_errors=validation_errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             validation_errors: Optional[Sequence['outputs.ReportableExceptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if validation_errors is None and 'validationErrors' in kwargs:
            validation_errors = kwargs['validationErrors']
        if validation_errors is None:
            raise TypeError("Missing 'validation_errors' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("validation_errors", validation_errors)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Database identifier
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Sequence['outputs.ReportableExceptionResponse']:
        """
        Errors associated with a selected database object
        """
        return pulumi.get(self, "validation_errors")


@pulumi.output_type
class ValidationErrorResponse(dict):
    """
    Description about the errors happen while performing migration validation
    """
    def __init__(__self__, *,
                 severity: Optional[str] = None,
                 text: Optional[str] = None):
        """
        Description about the errors happen while performing migration validation
        :param str severity: Severity of the error
        :param str text: Error Text
        """
        ValidationErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            severity=severity,
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             severity: Optional[str] = None,
             text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if severity is not None:
            _setter("severity", severity)
        if text is not None:
            _setter("text", text)

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity of the error
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        Error Text
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class WaitStatisticsResponse(dict):
    """
    Wait statistics gathered during query batch execution
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitCount":
            suggest = "wait_count"
        elif key == "waitTimeMs":
            suggest = "wait_time_ms"
        elif key == "waitType":
            suggest = "wait_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WaitStatisticsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WaitStatisticsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WaitStatisticsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wait_count: Optional[float] = None,
                 wait_time_ms: Optional[float] = None,
                 wait_type: Optional[str] = None):
        """
        Wait statistics gathered during query batch execution
        :param float wait_count: Total no. of waits
        :param float wait_time_ms: Total wait time in millisecond(s) 
        :param str wait_type: Type of the Wait
        """
        WaitStatisticsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            wait_count=wait_count,
            wait_time_ms=wait_time_ms,
            wait_type=wait_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             wait_count: Optional[float] = None,
             wait_time_ms: Optional[float] = None,
             wait_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if wait_count is None and 'waitCount' in kwargs:
            wait_count = kwargs['waitCount']
        if wait_time_ms is None and 'waitTimeMs' in kwargs:
            wait_time_ms = kwargs['waitTimeMs']
        if wait_type is None and 'waitType' in kwargs:
            wait_type = kwargs['waitType']

        if wait_count is not None:
            _setter("wait_count", wait_count)
        if wait_time_ms is None:
            wait_time_ms = 0
        if wait_time_ms is not None:
            _setter("wait_time_ms", wait_time_ms)
        if wait_type is not None:
            _setter("wait_type", wait_type)

    @property
    @pulumi.getter(name="waitCount")
    def wait_count(self) -> Optional[float]:
        """
        Total no. of waits
        """
        return pulumi.get(self, "wait_count")

    @property
    @pulumi.getter(name="waitTimeMs")
    def wait_time_ms(self) -> Optional[float]:
        """
        Total wait time in millisecond(s) 
        """
        return pulumi.get(self, "wait_time_ms")

    @property
    @pulumi.getter(name="waitType")
    def wait_type(self) -> Optional[str]:
        """
        Type of the Wait
        """
        return pulumi.get(self, "wait_type")


