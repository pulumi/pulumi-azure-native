# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AuthorizationBasicRuleResponse',
    'AuthorizationConfigResponse',
    'AutomaticCertMethodResponse',
    'BackendChainResponse',
    'BrokerAuthenticatorCustomAuthResponse',
    'BrokerAuthenticatorCustomAuthX509Response',
    'BrokerAuthenticatorMethodCustomResponse',
    'BrokerAuthenticatorMethodSatResponse',
    'BrokerAuthenticatorMethodSvidResponse',
    'BrokerAuthenticatorMethodUsernamePasswordResponse',
    'BrokerAuthenticatorMethodX509AttributesResponse',
    'BrokerAuthenticatorMethodX509Response',
    'BrokerAuthenticatorMethodsResponse',
    'BrokerDiagnosticsResponse',
    'CardinalityResponse',
    'CertManagerCertOptionsResponse',
    'CertManagerIssuerRefResponse',
    'CertManagerPrivateKeyResponse',
    'ContainerImageResponse',
    'DataLakeConnectorMapResponse',
    'DataLakeFabricStorageAuthenticationResponse',
    'DataLakeFabricStorageResponse',
    'DataLakeLocalStorageResponse',
    'DataLakeServiceStorageAuthenticationResponse',
    'DataLakeServiceStorageResponse',
    'DataLakeTargetStorageResponse',
    'DeltaTableResponse',
    'DeltaTableSchemaResponse',
    'DiskBackedMessageBufferSettingsResponse',
    'ExtendedLocationPropertyResponse',
    'FabricGuidsResponse',
    'FabricNamesResponse',
    'FrontendResponse',
    'KafkaRemoteBrokerAuthenticationPropertiesResponse',
    'KafkaRemoteBrokerAuthenticationTypesResponse',
    'KafkaRemoteBrokerConnectionSpecResponse',
    'KafkaRemoteBrokerConnectionTlsResponse',
    'KafkaRoutesResponse',
    'KafkaSharedSubscriptionPropertiesResponse',
    'KafkaToMqttRoutesResponse',
    'KafkaTokenKeyVaultPropertiesResponse',
    'KafkaTopicMapBatchingResponse',
    'KafkaX509AuthenticationResponse',
    'KeyVaultCertificatePropertiesResponse',
    'KeyVaultConnectionPropertiesResponse',
    'KeyVaultCredentialsPropertiesResponse',
    'KeyVaultSecretObjectResponse',
    'KeyVaultSecretPropertiesResponse',
    'LocalBrokerAuthenticationMethodsResponse',
    'LocalBrokerConnectionSpecResponse',
    'LocalBrokerConnectionTlsResponse',
    'LocalBrokerKubernetesAuthenticationResponse',
    'ManagedIdentityAuthenticationResponse',
    'ManualCertMethodResponse',
    'MqttBridgeRemoteBrokerAuthenticationMethodsResponse',
    'MqttBridgeRemoteBrokerConnectionSpecResponse',
    'MqttBridgeRemoteBrokerConnectionTlsResponse',
    'MqttBridgeRemoteBrokerX509AuthenticationResponse',
    'MqttBridgeRouteSharedSubscriptionResponse',
    'MqttBridgeRoutesResponse',
    'MqttToKafkaRoutesResponse',
    'NodeTolerationsResponse',
    'PrincipalDefinitionResponse',
    'ResourceInfoDefinitionResponse',
    'SanForCertResponse',
    'SaslRemoteBrokerBasicAuthenticationResponse',
    'SaslRemoteBrokerBasicAuthenticationTokenResponse',
    'SystemDataResponse',
    'TemporaryResourceLimitsConfigResponse',
    'TlsCertMethodResponse',
    'VolumeClaimDataSourceRefResponse',
    'VolumeClaimDataSourceResponse',
    'VolumeClaimResourceRequirementsResponse',
    'VolumeClaimSpecResponse',
    'VolumeClaimSpecSelectorMatchExpressionsResponse',
    'VolumeClaimSpecSelectorResponse',
]

@pulumi.output_type
class AuthorizationBasicRuleResponse(dict):
    """
    BasicRules of AuthorizationConfig Polar rules are not supported
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brokerResources":
            suggest = "broker_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationBasicRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationBasicRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationBasicRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker_resources: Sequence['outputs.ResourceInfoDefinitionResponse'],
                 principals: 'outputs.PrincipalDefinitionResponse'):
        """
        BasicRules of AuthorizationConfig Polar rules are not supported
        :param Sequence['ResourceInfoDefinitionResponse'] broker_resources: This subfield defines the broker resources that the Basic Rule is applied on.
        :param 'PrincipalDefinitionResponse' principals: This subfield defines the identities that represent the clients.
        """
        pulumi.set(__self__, "broker_resources", broker_resources)
        pulumi.set(__self__, "principals", principals)

    @property
    @pulumi.getter(name="brokerResources")
    def broker_resources(self) -> Sequence['outputs.ResourceInfoDefinitionResponse']:
        """
        This subfield defines the broker resources that the Basic Rule is applied on.
        """
        return pulumi.get(self, "broker_resources")

    @property
    @pulumi.getter
    def principals(self) -> 'outputs.PrincipalDefinitionResponse':
        """
        This subfield defines the identities that represent the clients.
        """
        return pulumi.get(self, "principals")


@pulumi.output_type
class AuthorizationConfigResponse(dict):
    """
    Broker AuthorizationConfig properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCache":
            suggest = "enable_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cache: Optional[bool] = None,
                 rules: Optional[Sequence['outputs.AuthorizationBasicRuleResponse']] = None):
        """
        Broker AuthorizationConfig properties
        :param bool enable_cache: Enable caching of the authorization rules.
        :param Sequence['AuthorizationBasicRuleResponse'] rules: Authorization Rules to be used. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        if enable_cache is None:
            enable_cache = True
        if enable_cache is not None:
            pulumi.set(__self__, "enable_cache", enable_cache)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="enableCache")
    def enable_cache(self) -> Optional[bool]:
        """
        Enable caching of the authorization rules.
        """
        return pulumi.get(self, "enable_cache")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AuthorizationBasicRuleResponse']]:
        """
        Authorization Rules to be used. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AutomaticCertMethodResponse(dict):
    """
    Automatic TLS server certificate management with cert-manager
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuerRef":
            suggest = "issuer_ref"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "renewBefore":
            suggest = "renew_before"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "secretNamespace":
            suggest = "secret_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomaticCertMethodResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomaticCertMethodResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomaticCertMethodResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issuer_ref: 'outputs.CertManagerIssuerRefResponse',
                 duration: Optional[str] = None,
                 private_key: Optional['outputs.CertManagerPrivateKeyResponse'] = None,
                 renew_before: Optional[str] = None,
                 san: Optional['outputs.SanForCertResponse'] = None,
                 secret_name: Optional[str] = None,
                 secret_namespace: Optional[str] = None):
        """
        Automatic TLS server certificate management with cert-manager
        :param 'CertManagerIssuerRefResponse' issuer_ref: cert-manager issuerRef.
        :param str duration: Lifetime of automatically-managed certificate.
        :param 'CertManagerPrivateKeyResponse' private_key: Cert Manager private key.
        :param str renew_before: When to begin renewing automatically-managed certificate.
        :param 'SanForCertResponse' san: Additional SANs to include in the certificate.
        :param str secret_name: Secret for storing server certificate. Any existing data will be overwritten.
        :param str secret_namespace: Certificate K8S namespace. Omit to use default namespace.
        """
        pulumi.set(__self__, "issuer_ref", issuer_ref)
        if duration is None:
            duration = '720h'
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if renew_before is None:
            renew_before = '240h'
        if renew_before is not None:
            pulumi.set(__self__, "renew_before", renew_before)
        if san is not None:
            pulumi.set(__self__, "san", san)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if secret_namespace is not None:
            pulumi.set(__self__, "secret_namespace", secret_namespace)

    @property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> 'outputs.CertManagerIssuerRefResponse':
        """
        cert-manager issuerRef.
        """
        return pulumi.get(self, "issuer_ref")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Lifetime of automatically-managed certificate.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional['outputs.CertManagerPrivateKeyResponse']:
        """
        Cert Manager private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> Optional[str]:
        """
        When to begin renewing automatically-managed certificate.
        """
        return pulumi.get(self, "renew_before")

    @property
    @pulumi.getter
    def san(self) -> Optional['outputs.SanForCertResponse']:
        """
        Additional SANs to include in the certificate.
        """
        return pulumi.get(self, "san")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Secret for storing server certificate. Any existing data will be overwritten.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="secretNamespace")
    def secret_namespace(self) -> Optional[str]:
        """
        Certificate K8S namespace. Omit to use default namespace.
        """
        return pulumi.get(self, "secret_namespace")


@pulumi.output_type
class BackendChainResponse(dict):
    """
    Desired properties of the Frontend Instances of the DMQTT Broker
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redundancyFactor":
            suggest = "redundancy_factor"
        elif key == "temporaryDiskTransferEnabled":
            suggest = "temporary_disk_transfer_enabled"
        elif key == "temporaryDiskTransferHighWatermarkPercent":
            suggest = "temporary_disk_transfer_high_watermark_percent"
        elif key == "temporaryDiskTransferLowWatermarkPercent":
            suggest = "temporary_disk_transfer_low_watermark_percent"
        elif key == "temporaryMaxBackendMemUsagePercent":
            suggest = "temporary_max_backend_mem_usage_percent"
        elif key == "temporaryResourceLimits":
            suggest = "temporary_resource_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendChainResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendChainResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendChainResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partitions: int,
                 redundancy_factor: int,
                 temporary_disk_transfer_enabled: Optional[bool] = None,
                 temporary_disk_transfer_high_watermark_percent: Optional[int] = None,
                 temporary_disk_transfer_low_watermark_percent: Optional[int] = None,
                 temporary_max_backend_mem_usage_percent: Optional[int] = None,
                 temporary_resource_limits: Optional['outputs.TemporaryResourceLimitsConfigResponse'] = None,
                 workers: Optional[int] = None):
        """
        Desired properties of the Frontend Instances of the DMQTT Broker
        :param int partitions: Partitions is desired number of physical backend chains of the given distributed MQTT broker.
        :param int redundancy_factor: Redundancy Factor is desired numbers of broker instances in one chain.
        :param bool temporary_disk_transfer_enabled: Defines whether disk transfer is enabled or not.
        :param int temporary_disk_transfer_high_watermark_percent: Defines the percentage usage of buffer pool above which disk transfer will start.
        :param int temporary_disk_transfer_low_watermark_percent: Defines the percentage usage of buffer pool below which disk transfer will stop.
        :param int temporary_max_backend_mem_usage_percent: Defines the limits for memory usage percent of the backend instances of the MQTT broker.
        :param 'TemporaryResourceLimitsConfigResponse' temporary_resource_limits: Defines the limits for resources of the backend instances of the MQTT broker.
        :param int workers: Number of logical backend workers per pod.
        """
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "redundancy_factor", redundancy_factor)
        if temporary_disk_transfer_enabled is not None:
            pulumi.set(__self__, "temporary_disk_transfer_enabled", temporary_disk_transfer_enabled)
        if temporary_disk_transfer_high_watermark_percent is not None:
            pulumi.set(__self__, "temporary_disk_transfer_high_watermark_percent", temporary_disk_transfer_high_watermark_percent)
        if temporary_disk_transfer_low_watermark_percent is not None:
            pulumi.set(__self__, "temporary_disk_transfer_low_watermark_percent", temporary_disk_transfer_low_watermark_percent)
        if temporary_max_backend_mem_usage_percent is not None:
            pulumi.set(__self__, "temporary_max_backend_mem_usage_percent", temporary_max_backend_mem_usage_percent)
        if temporary_resource_limits is not None:
            pulumi.set(__self__, "temporary_resource_limits", temporary_resource_limits)
        if workers is None:
            workers = 1
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter
    def partitions(self) -> int:
        """
        Partitions is desired number of physical backend chains of the given distributed MQTT broker.
        """
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter(name="redundancyFactor")
    def redundancy_factor(self) -> int:
        """
        Redundancy Factor is desired numbers of broker instances in one chain.
        """
        return pulumi.get(self, "redundancy_factor")

    @property
    @pulumi.getter(name="temporaryDiskTransferEnabled")
    def temporary_disk_transfer_enabled(self) -> Optional[bool]:
        """
        Defines whether disk transfer is enabled or not.
        """
        return pulumi.get(self, "temporary_disk_transfer_enabled")

    @property
    @pulumi.getter(name="temporaryDiskTransferHighWatermarkPercent")
    def temporary_disk_transfer_high_watermark_percent(self) -> Optional[int]:
        """
        Defines the percentage usage of buffer pool above which disk transfer will start.
        """
        return pulumi.get(self, "temporary_disk_transfer_high_watermark_percent")

    @property
    @pulumi.getter(name="temporaryDiskTransferLowWatermarkPercent")
    def temporary_disk_transfer_low_watermark_percent(self) -> Optional[int]:
        """
        Defines the percentage usage of buffer pool below which disk transfer will stop.
        """
        return pulumi.get(self, "temporary_disk_transfer_low_watermark_percent")

    @property
    @pulumi.getter(name="temporaryMaxBackendMemUsagePercent")
    def temporary_max_backend_mem_usage_percent(self) -> Optional[int]:
        """
        Defines the limits for memory usage percent of the backend instances of the MQTT broker.
        """
        return pulumi.get(self, "temporary_max_backend_mem_usage_percent")

    @property
    @pulumi.getter(name="temporaryResourceLimits")
    def temporary_resource_limits(self) -> Optional['outputs.TemporaryResourceLimitsConfigResponse']:
        """
        Defines the limits for resources of the backend instances of the MQTT broker.
        """
        return pulumi.get(self, "temporary_resource_limits")

    @property
    @pulumi.getter
    def workers(self) -> Optional[int]:
        """
        Number of logical backend workers per pod.
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class BrokerAuthenticatorCustomAuthResponse(dict):
    """
    Custom Authentication properties
    """
    def __init__(__self__, *,
                 x509: 'outputs.BrokerAuthenticatorCustomAuthX509Response'):
        """
        Custom Authentication properties
        :param 'BrokerAuthenticatorCustomAuthX509Response' x509: X509 Custom Auth type details.
        """
        pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def x509(self) -> 'outputs.BrokerAuthenticatorCustomAuthX509Response':
        """
        X509 Custom Auth type details.
        """
        return pulumi.get(self, "x509")


@pulumi.output_type
class BrokerAuthenticatorCustomAuthX509Response(dict):
    """
    X509 Custom Authentication properties. NOTE - Enum only authenticator type supported at a time.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVault":
            suggest = "key_vault"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorCustomAuthX509Response. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorCustomAuthX509Response.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorCustomAuthX509Response.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault: Optional['outputs.KeyVaultCertificatePropertiesResponse'] = None,
                 secret_name: Optional[str] = None):
        """
        X509 Custom Authentication properties. NOTE - Enum only authenticator type supported at a time.
        :param 'KeyVaultCertificatePropertiesResponse' key_vault: Keyvault X509 secret properties.
        :param str secret_name: Secret where cert details are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional['outputs.KeyVaultCertificatePropertiesResponse']:
        """
        Keyvault X509 secret properties.
        """
        return pulumi.get(self, "key_vault")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Secret where cert details are stored.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class BrokerAuthenticatorMethodCustomResponse(dict):
    """
    Custom method for BrokerAuthentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertConfigMap":
            suggest = "ca_cert_config_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 auth: Optional['outputs.BrokerAuthenticatorCustomAuthResponse'] = None,
                 ca_cert_config_map: Optional[str] = None,
                 headers: Optional[Mapping[str, str]] = None):
        """
        Custom method for BrokerAuthentication
        :param str endpoint: Endpoint to connect to.
        :param 'BrokerAuthenticatorCustomAuthResponse' auth: Custom Broker Authentication Method.
        :param str ca_cert_config_map: CA cert config map to use.
        :param Mapping[str, str] headers: Configuration Headers to use.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if ca_cert_config_map is not None:
            pulumi.set(__self__, "ca_cert_config_map", ca_cert_config_map)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        Endpoint to connect to.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.BrokerAuthenticatorCustomAuthResponse']:
        """
        Custom Broker Authentication Method.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="caCertConfigMap")
    def ca_cert_config_map(self) -> Optional[str]:
        """
        CA cert config map to use.
        """
        return pulumi.get(self, "ca_cert_config_map")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, str]]:
        """
        Configuration Headers to use.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class BrokerAuthenticatorMethodSatResponse(dict):
    """
    Service Account Token for BrokerAuthentication
    """
    def __init__(__self__, *,
                 audiences: Sequence[str]):
        """
        Service Account Token for BrokerAuthentication
        :param Sequence[str] audiences: List of allowed audience.
        """
        pulumi.set(__self__, "audiences", audiences)

    @property
    @pulumi.getter
    def audiences(self) -> Sequence[str]:
        """
        List of allowed audience.
        """
        return pulumi.get(self, "audiences")


@pulumi.output_type
class BrokerAuthenticatorMethodSvidResponse(dict):
    """
    SVID for BrokerAuthentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentSocketPath":
            suggest = "agent_socket_path"
        elif key == "identityMaxRetry":
            suggest = "identity_max_retry"
        elif key == "identityWaitRetryMs":
            suggest = "identity_wait_retry_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodSvidResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodSvidResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodSvidResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_socket_path: str,
                 identity_max_retry: Optional[float] = None,
                 identity_wait_retry_ms: Optional[float] = None):
        """
        SVID for BrokerAuthentication
        :param str agent_socket_path: Mounted socket path for spiffe agent.
        :param float identity_max_retry: Maximum number of re-tries to fetch identity.
        :param float identity_wait_retry_ms: Maximum time to wait before fetching identity again.
        """
        pulumi.set(__self__, "agent_socket_path", agent_socket_path)
        if identity_max_retry is None:
            identity_max_retry = 3
        if identity_max_retry is not None:
            pulumi.set(__self__, "identity_max_retry", identity_max_retry)
        if identity_wait_retry_ms is None:
            identity_wait_retry_ms = 5000
        if identity_wait_retry_ms is not None:
            pulumi.set(__self__, "identity_wait_retry_ms", identity_wait_retry_ms)

    @property
    @pulumi.getter(name="agentSocketPath")
    def agent_socket_path(self) -> str:
        """
        Mounted socket path for spiffe agent.
        """
        return pulumi.get(self, "agent_socket_path")

    @property
    @pulumi.getter(name="identityMaxRetry")
    def identity_max_retry(self) -> Optional[float]:
        """
        Maximum number of re-tries to fetch identity.
        """
        return pulumi.get(self, "identity_max_retry")

    @property
    @pulumi.getter(name="identityWaitRetryMs")
    def identity_wait_retry_ms(self) -> Optional[float]:
        """
        Maximum time to wait before fetching identity again.
        """
        return pulumi.get(self, "identity_wait_retry_ms")


@pulumi.output_type
class BrokerAuthenticatorMethodUsernamePasswordResponse(dict):
    """
    UsernamePassword for BrokerAuthentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVault":
            suggest = "key_vault"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodUsernamePasswordResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodUsernamePasswordResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodUsernamePasswordResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault: Optional['outputs.KeyVaultSecretPropertiesResponse'] = None,
                 secret_name: Optional[str] = None):
        """
        UsernamePassword for BrokerAuthentication
        :param 'KeyVaultSecretPropertiesResponse' key_vault: Keyvault username password secret properties.
        :param str secret_name: Secret where username and password are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional['outputs.KeyVaultSecretPropertiesResponse']:
        """
        Keyvault username password secret properties.
        """
        return pulumi.get(self, "key_vault")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Secret where username and password are stored.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class BrokerAuthenticatorMethodX509AttributesResponse(dict):
    """
    BrokerAuthenticatorMethodX509Attributes properties. NOTE - Enum only type supported at a time.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVault":
            suggest = "key_vault"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodX509AttributesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodX509AttributesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodX509AttributesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault: Optional['outputs.KeyVaultSecretPropertiesResponse'] = None,
                 secret_name: Optional[str] = None):
        """
        BrokerAuthenticatorMethodX509Attributes properties. NOTE - Enum only type supported at a time.
        :param 'KeyVaultSecretPropertiesResponse' key_vault: Keyvault x509 attributes secret properties.
        :param str secret_name: Secret where x509 attributes are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional['outputs.KeyVaultSecretPropertiesResponse']:
        """
        Keyvault x509 attributes secret properties.
        """
        return pulumi.get(self, "key_vault")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Secret where x509 attributes are stored.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class BrokerAuthenticatorMethodX509Response(dict):
    """
    X509 for BrokerAuthentication.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedClientCaCertConfigMap":
            suggest = "trusted_client_ca_cert_config_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodX509Response. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodX509Response.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodX509Response.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attributes: Optional['outputs.BrokerAuthenticatorMethodX509AttributesResponse'] = None,
                 trusted_client_ca_cert_config_map: Optional[str] = None):
        """
        X509 for BrokerAuthentication.
        :param 'BrokerAuthenticatorMethodX509AttributesResponse' attributes: K8S Secret name to mount for username and password.
        :param str trusted_client_ca_cert_config_map: Trusted client ca cert config map.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if trusted_client_ca_cert_config_map is None:
            trusted_client_ca_cert_config_map = 'client-ca'
        if trusted_client_ca_cert_config_map is not None:
            pulumi.set(__self__, "trusted_client_ca_cert_config_map", trusted_client_ca_cert_config_map)

    @property
    @pulumi.getter
    def attributes(self) -> Optional['outputs.BrokerAuthenticatorMethodX509AttributesResponse']:
        """
        K8S Secret name to mount for username and password.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="trustedClientCaCertConfigMap")
    def trusted_client_ca_cert_config_map(self) -> Optional[str]:
        """
        Trusted client ca cert config map.
        """
        return pulumi.get(self, "trusted_client_ca_cert_config_map")


@pulumi.output_type
class BrokerAuthenticatorMethodsResponse(dict):
    """
    Collection of different CrdAuthenticator methods of Broker Resource. NOTE Enum - Only one method is supported for each entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usernamePassword":
            suggest = "username_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom: Optional['outputs.BrokerAuthenticatorMethodCustomResponse'] = None,
                 sat: Optional['outputs.BrokerAuthenticatorMethodSatResponse'] = None,
                 svid: Optional['outputs.BrokerAuthenticatorMethodSvidResponse'] = None,
                 username_password: Optional['outputs.BrokerAuthenticatorMethodUsernamePasswordResponse'] = None,
                 x509: Optional['outputs.BrokerAuthenticatorMethodX509Response'] = None):
        """
        Collection of different CrdAuthenticator methods of Broker Resource. NOTE Enum - Only one method is supported for each entry.
        :param 'BrokerAuthenticatorMethodCustomResponse' custom: Custom Authentication Method.
        :param 'BrokerAuthenticatorMethodSatResponse' sat: Service Account Token Method.
        :param 'BrokerAuthenticatorMethodSvidResponse' svid: Service Account Token Method.
        :param 'BrokerAuthenticatorMethodUsernamePasswordResponse' username_password: UsernamePassword Method.
        :param 'BrokerAuthenticatorMethodX509Response' x509: X509 Method.
        """
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if svid is not None:
            pulumi.set(__self__, "svid", svid)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)
        if x509 is not None:
            pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def custom(self) -> Optional['outputs.BrokerAuthenticatorMethodCustomResponse']:
        """
        Custom Authentication Method.
        """
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter
    def sat(self) -> Optional['outputs.BrokerAuthenticatorMethodSatResponse']:
        """
        Service Account Token Method.
        """
        return pulumi.get(self, "sat")

    @property
    @pulumi.getter
    def svid(self) -> Optional['outputs.BrokerAuthenticatorMethodSvidResponse']:
        """
        Service Account Token Method.
        """
        return pulumi.get(self, "svid")

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional['outputs.BrokerAuthenticatorMethodUsernamePasswordResponse']:
        """
        UsernamePassword Method.
        """
        return pulumi.get(self, "username_password")

    @property
    @pulumi.getter
    def x509(self) -> Optional['outputs.BrokerAuthenticatorMethodX509Response']:
        """
        X509 Method.
        """
        return pulumi.get(self, "x509")


@pulumi.output_type
class BrokerDiagnosticsResponse(dict):
    """
    Diagnostics setting specific to Broker
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diagnosticServiceEndpoint":
            suggest = "diagnostic_service_endpoint"
        elif key == "enableMetrics":
            suggest = "enable_metrics"
        elif key == "enableSelfCheck":
            suggest = "enable_self_check"
        elif key == "enableSelfTracing":
            suggest = "enable_self_tracing"
        elif key == "enableTracing":
            suggest = "enable_tracing"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "maxCellMapLifetime":
            suggest = "max_cell_map_lifetime"
        elif key == "metricUpdateFrequencySeconds":
            suggest = "metric_update_frequency_seconds"
        elif key == "probeImage":
            suggest = "probe_image"
        elif key == "selfCheckFrequencySeconds":
            suggest = "self_check_frequency_seconds"
        elif key == "selfCheckTimeoutSeconds":
            suggest = "self_check_timeout_seconds"
        elif key == "selfTraceFrequencySeconds":
            suggest = "self_trace_frequency_seconds"
        elif key == "spanChannelCapacity":
            suggest = "span_channel_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerDiagnosticsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerDiagnosticsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerDiagnosticsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 diagnostic_service_endpoint: Optional[str] = None,
                 enable_metrics: Optional[bool] = None,
                 enable_self_check: Optional[bool] = None,
                 enable_self_tracing: Optional[bool] = None,
                 enable_tracing: Optional[bool] = None,
                 log_format: Optional[str] = None,
                 log_level: Optional[str] = None,
                 max_cell_map_lifetime: Optional[float] = None,
                 metric_update_frequency_seconds: Optional[float] = None,
                 probe_image: Optional[str] = None,
                 self_check_frequency_seconds: Optional[float] = None,
                 self_check_timeout_seconds: Optional[float] = None,
                 self_trace_frequency_seconds: Optional[float] = None,
                 span_channel_capacity: Optional[float] = None):
        """
        Diagnostics setting specific to Broker
        :param str diagnostic_service_endpoint: Diagnostic Service endpoint
        :param bool enable_metrics: Knob to enable/disable metrics. Default = true
        :param bool enable_self_check: Enable self check on Broker via Probe.
        :param bool enable_self_tracing: Enable self tracing on the Broker so that every selfCheckFrequencySeconds a random message is traced even if it didn't have trace context.
        :param bool enable_tracing: Knob to enable/disable entire tracing infrastructure.
        :param str log_format: Format for the logs generated.
        :param str log_level: Log level for the Broker.
        :param float max_cell_map_lifetime: Maximum time for the CellMap to live.
        :param float metric_update_frequency_seconds: Metric update frequency in seconds.
        :param str probe_image: Probe Image to run.
        :param float self_check_frequency_seconds: Frequency for the self check to run.
        :param float self_check_timeout_seconds: Time out period of the self check.
        :param float self_trace_frequency_seconds: The frequency at which selfTrace should run.
        :param float span_channel_capacity: The number of the spans generated by the Tracing.
        """
        if diagnostic_service_endpoint is not None:
            pulumi.set(__self__, "diagnostic_service_endpoint", diagnostic_service_endpoint)
        if enable_metrics is None:
            enable_metrics = True
        if enable_metrics is not None:
            pulumi.set(__self__, "enable_metrics", enable_metrics)
        if enable_self_check is None:
            enable_self_check = True
        if enable_self_check is not None:
            pulumi.set(__self__, "enable_self_check", enable_self_check)
        if enable_self_tracing is None:
            enable_self_tracing = True
        if enable_self_tracing is not None:
            pulumi.set(__self__, "enable_self_tracing", enable_self_tracing)
        if enable_tracing is None:
            enable_tracing = True
        if enable_tracing is not None:
            pulumi.set(__self__, "enable_tracing", enable_tracing)
        if log_format is None:
            log_format = 'text'
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_level is None:
            log_level = 'info,hyper=off,kube_client=off,tower=off,conhash=off,h2=off'
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if max_cell_map_lifetime is None:
            max_cell_map_lifetime = 60
        if max_cell_map_lifetime is not None:
            pulumi.set(__self__, "max_cell_map_lifetime", max_cell_map_lifetime)
        if metric_update_frequency_seconds is None:
            metric_update_frequency_seconds = 30
        if metric_update_frequency_seconds is not None:
            pulumi.set(__self__, "metric_update_frequency_seconds", metric_update_frequency_seconds)
        if probe_image is None:
            probe_image = 'sample.azurecr.io/diagnostics-probe:0.5.0'
        if probe_image is not None:
            pulumi.set(__self__, "probe_image", probe_image)
        if self_check_frequency_seconds is None:
            self_check_frequency_seconds = 30
        if self_check_frequency_seconds is not None:
            pulumi.set(__self__, "self_check_frequency_seconds", self_check_frequency_seconds)
        if self_check_timeout_seconds is None:
            self_check_timeout_seconds = 15
        if self_check_timeout_seconds is not None:
            pulumi.set(__self__, "self_check_timeout_seconds", self_check_timeout_seconds)
        if self_trace_frequency_seconds is None:
            self_trace_frequency_seconds = 30
        if self_trace_frequency_seconds is not None:
            pulumi.set(__self__, "self_trace_frequency_seconds", self_trace_frequency_seconds)
        if span_channel_capacity is None:
            span_channel_capacity = 1000
        if span_channel_capacity is not None:
            pulumi.set(__self__, "span_channel_capacity", span_channel_capacity)

    @property
    @pulumi.getter(name="diagnosticServiceEndpoint")
    def diagnostic_service_endpoint(self) -> Optional[str]:
        """
        Diagnostic Service endpoint
        """
        return pulumi.get(self, "diagnostic_service_endpoint")

    @property
    @pulumi.getter(name="enableMetrics")
    def enable_metrics(self) -> Optional[bool]:
        """
        Knob to enable/disable metrics. Default = true
        """
        return pulumi.get(self, "enable_metrics")

    @property
    @pulumi.getter(name="enableSelfCheck")
    def enable_self_check(self) -> Optional[bool]:
        """
        Enable self check on Broker via Probe.
        """
        return pulumi.get(self, "enable_self_check")

    @property
    @pulumi.getter(name="enableSelfTracing")
    def enable_self_tracing(self) -> Optional[bool]:
        """
        Enable self tracing on the Broker so that every selfCheckFrequencySeconds a random message is traced even if it didn't have trace context.
        """
        return pulumi.get(self, "enable_self_tracing")

    @property
    @pulumi.getter(name="enableTracing")
    def enable_tracing(self) -> Optional[bool]:
        """
        Knob to enable/disable entire tracing infrastructure.
        """
        return pulumi.get(self, "enable_tracing")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[str]:
        """
        Format for the logs generated.
        """
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        """
        Log level for the Broker.
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="maxCellMapLifetime")
    def max_cell_map_lifetime(self) -> Optional[float]:
        """
        Maximum time for the CellMap to live.
        """
        return pulumi.get(self, "max_cell_map_lifetime")

    @property
    @pulumi.getter(name="metricUpdateFrequencySeconds")
    def metric_update_frequency_seconds(self) -> Optional[float]:
        """
        Metric update frequency in seconds.
        """
        return pulumi.get(self, "metric_update_frequency_seconds")

    @property
    @pulumi.getter(name="probeImage")
    def probe_image(self) -> Optional[str]:
        """
        Probe Image to run.
        """
        return pulumi.get(self, "probe_image")

    @property
    @pulumi.getter(name="selfCheckFrequencySeconds")
    def self_check_frequency_seconds(self) -> Optional[float]:
        """
        Frequency for the self check to run.
        """
        return pulumi.get(self, "self_check_frequency_seconds")

    @property
    @pulumi.getter(name="selfCheckTimeoutSeconds")
    def self_check_timeout_seconds(self) -> Optional[float]:
        """
        Time out period of the self check.
        """
        return pulumi.get(self, "self_check_timeout_seconds")

    @property
    @pulumi.getter(name="selfTraceFrequencySeconds")
    def self_trace_frequency_seconds(self) -> Optional[float]:
        """
        The frequency at which selfTrace should run.
        """
        return pulumi.get(self, "self_trace_frequency_seconds")

    @property
    @pulumi.getter(name="spanChannelCapacity")
    def span_channel_capacity(self) -> Optional[float]:
        """
        The number of the spans generated by the Tracing.
        """
        return pulumi.get(self, "span_channel_capacity")


@pulumi.output_type
class CardinalityResponse(dict):
    """
    Cardinality properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendChain":
            suggest = "backend_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CardinalityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CardinalityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CardinalityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_chain: 'outputs.BackendChainResponse',
                 frontend: 'outputs.FrontendResponse'):
        """
        Cardinality properties
        :param 'BackendChainResponse' backend_chain: The backend broker desired properties
        :param 'FrontendResponse' frontend: The frontend broker desired properties
        """
        pulumi.set(__self__, "backend_chain", backend_chain)
        pulumi.set(__self__, "frontend", frontend)

    @property
    @pulumi.getter(name="backendChain")
    def backend_chain(self) -> 'outputs.BackendChainResponse':
        """
        The backend broker desired properties
        """
        return pulumi.get(self, "backend_chain")

    @property
    @pulumi.getter
    def frontend(self) -> 'outputs.FrontendResponse':
        """
        The frontend broker desired properties
        """
        return pulumi.get(self, "frontend")


@pulumi.output_type
class CertManagerCertOptionsResponse(dict):
    """
    Cert Manager CA Cert properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "renewBefore":
            suggest = "renew_before"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertManagerCertOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertManagerCertOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertManagerCertOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[str] = None,
                 private_key: 'outputs.CertManagerPrivateKeyResponse',
                 renew_before: Optional[str] = None):
        """
        Cert Manager CA Cert properties
        :param str duration: Duration of CA cert.
        :param 'CertManagerPrivateKeyResponse' private_key: Cert Manager private key.
        :param str renew_before: Renew before time of CA cert.
        """
        if duration is None:
            duration = '720h'
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "private_key", private_key)
        if renew_before is None:
            renew_before = '240h'
        pulumi.set(__self__, "renew_before", renew_before)

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        Duration of CA cert.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> 'outputs.CertManagerPrivateKeyResponse':
        """
        Cert Manager private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> str:
        """
        Renew before time of CA cert.
        """
        return pulumi.get(self, "renew_before")


@pulumi.output_type
class CertManagerIssuerRefResponse(dict):
    """
    Cert-Manager issuerRef properties
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: str,
                 name: str):
        """
        Cert-Manager issuerRef properties
        :param str group: group of issuer.
        :param str kind: kind of issuer (Issuer or ClusterIssuer).
        :param str name: name of issuer.
        """
        if group is None:
            group = 'cert-manager.io'
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> str:
        """
        group of issuer.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        kind of issuer (Issuer or ClusterIssuer).
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name of issuer.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CertManagerPrivateKeyResponse(dict):
    """
    Cert Manager private key properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rotationPolicy":
            suggest = "rotation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertManagerPrivateKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertManagerPrivateKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertManagerPrivateKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 rotation_policy: Optional[str] = None,
                 size: Optional[int] = None):
        """
        Cert Manager private key properties
        :param str algorithm: algorithm for private key.
        :param str rotation_policy: cert-manager rotationPolicy.
        :param int size: size of private key.
        """
        if algorithm is None:
            algorithm = 'ECDSA'
        pulumi.set(__self__, "algorithm", algorithm)
        if rotation_policy is None:
            rotation_policy = 'Always'
        pulumi.set(__self__, "rotation_policy", rotation_policy)
        if size is None:
            size = 256
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        algorithm for private key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="rotationPolicy")
    def rotation_policy(self) -> str:
        """
        cert-manager rotationPolicy.
        """
        return pulumi.get(self, "rotation_policy")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        size of private key.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class ContainerImageResponse(dict):
    """
    Defines the Docker image details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pullPolicy":
            suggest = "pull_policy"
        elif key == "pullSecrets":
            suggest = "pull_secrets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerImageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerImageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerImageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository: str,
                 tag: str,
                 pull_policy: Optional[str] = None,
                 pull_secrets: Optional[str] = None):
        """
        Defines the Docker image details
        :param str repository: The Docker image name.
        :param str tag: The Docker  image tag.
        :param str pull_policy: Image pull policy.
        :param str pull_secrets: Image pull secrets.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "tag", tag)
        if pull_policy is not None:
            pulumi.set(__self__, "pull_policy", pull_policy)
        if pull_secrets is not None:
            pulumi.set(__self__, "pull_secrets", pull_secrets)

    @property
    @pulumi.getter
    def repository(self) -> str:
        """
        The Docker image name.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        The Docker  image tag.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="pullPolicy")
    def pull_policy(self) -> Optional[str]:
        """
        Image pull policy.
        """
        return pulumi.get(self, "pull_policy")

    @property
    @pulumi.getter(name="pullSecrets")
    def pull_secrets(self) -> Optional[str]:
        """
        Image pull secrets.
        """
        return pulumi.get(self, "pull_secrets")


@pulumi.output_type
class DataLakeConnectorMapResponse(dict):
    """
    DataLake connector map route properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedLatencySecs":
            suggest = "allowed_latency_secs"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "maxMessagesPerBatch":
            suggest = "max_messages_per_batch"
        elif key == "messagePayloadType":
            suggest = "message_payload_type"
        elif key == "mqttSourceTopic":
            suggest = "mqtt_source_topic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeConnectorMapResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeConnectorMapResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeConnectorMapResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_latency_secs: int,
                 client_id: str,
                 max_messages_per_batch: float,
                 message_payload_type: str,
                 mqtt_source_topic: str,
                 table: 'outputs.DeltaTableResponse',
                 qos: Optional[int] = None):
        """
        DataLake connector map route properties
        :param int allowed_latency_secs: Allowed latency for transferring data.
        :param str client_id: Client Id to use.
        :param float max_messages_per_batch: Maximum messages to send per Batch.
        :param str message_payload_type: Message payload type.
        :param str mqtt_source_topic: Mqtt source topic.
        :param 'DeltaTableResponse' table: Delta table properties to use.
        :param int qos: Quality of Service.
        """
        pulumi.set(__self__, "allowed_latency_secs", allowed_latency_secs)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "max_messages_per_batch", max_messages_per_batch)
        pulumi.set(__self__, "message_payload_type", message_payload_type)
        pulumi.set(__self__, "mqtt_source_topic", mqtt_source_topic)
        pulumi.set(__self__, "table", table)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @property
    @pulumi.getter(name="allowedLatencySecs")
    def allowed_latency_secs(self) -> int:
        """
        Allowed latency for transferring data.
        """
        return pulumi.get(self, "allowed_latency_secs")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client Id to use.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="maxMessagesPerBatch")
    def max_messages_per_batch(self) -> float:
        """
        Maximum messages to send per Batch.
        """
        return pulumi.get(self, "max_messages_per_batch")

    @property
    @pulumi.getter(name="messagePayloadType")
    def message_payload_type(self) -> str:
        """
        Message payload type.
        """
        return pulumi.get(self, "message_payload_type")

    @property
    @pulumi.getter(name="mqttSourceTopic")
    def mqtt_source_topic(self) -> str:
        """
        Mqtt source topic.
        """
        return pulumi.get(self, "mqtt_source_topic")

    @property
    @pulumi.getter
    def table(self) -> 'outputs.DeltaTableResponse':
        """
        Delta table properties to use.
        """
        return pulumi.get(self, "table")

    @property
    @pulumi.getter
    def qos(self) -> Optional[int]:
        """
        Quality of Service.
        """
        return pulumi.get(self, "qos")


@pulumi.output_type
class DataLakeFabricStorageAuthenticationResponse(dict):
    """
    DataLake Fabric Storage authentication details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemAssignedManagedIdentity":
            suggest = "system_assigned_managed_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeFabricStorageAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeFabricStorageAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeFabricStorageAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 system_assigned_managed_identity: 'outputs.ManagedIdentityAuthenticationResponse'):
        """
        DataLake Fabric Storage authentication details.
        :param 'ManagedIdentityAuthenticationResponse' system_assigned_managed_identity: Configuration for managed identity authentication.
        """
        pulumi.set(__self__, "system_assigned_managed_identity", system_assigned_managed_identity)

    @property
    @pulumi.getter(name="systemAssignedManagedIdentity")
    def system_assigned_managed_identity(self) -> 'outputs.ManagedIdentityAuthenticationResponse':
        """
        Configuration for managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity")


@pulumi.output_type
class DataLakeFabricStorageResponse(dict):
    """
    DataLake Fabric Storage details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fabricPath":
            suggest = "fabric_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeFabricStorageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeFabricStorageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeFabricStorageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: 'outputs.DataLakeFabricStorageAuthenticationResponse',
                 endpoint: str,
                 fabric_path: str,
                 guids: Optional['outputs.FabricGuidsResponse'] = None,
                 names: Optional['outputs.FabricNamesResponse'] = None):
        """
        DataLake Fabric Storage details.
        :param 'DataLakeFabricStorageAuthenticationResponse' authentication: DataLake fabric storage authentication details.
        :param str endpoint: DataLake fabric storage endpoint to use.
        :param str fabric_path: Fabric path type to use.
        :param 'FabricGuidsResponse' guids: Fabric one lake Guids.
        :param 'FabricNamesResponse' names: Fabric one lake Names.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "fabric_path", fabric_path)
        if guids is not None:
            pulumi.set(__self__, "guids", guids)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataLakeFabricStorageAuthenticationResponse':
        """
        DataLake fabric storage authentication details.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        DataLake fabric storage endpoint to use.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="fabricPath")
    def fabric_path(self) -> str:
        """
        Fabric path type to use.
        """
        return pulumi.get(self, "fabric_path")

    @property
    @pulumi.getter
    def guids(self) -> Optional['outputs.FabricGuidsResponse']:
        """
        Fabric one lake Guids.
        """
        return pulumi.get(self, "guids")

    @property
    @pulumi.getter
    def names(self) -> Optional['outputs.FabricNamesResponse']:
        """
        Fabric one lake Names.
        """
        return pulumi.get(self, "names")


@pulumi.output_type
class DataLakeLocalStorageResponse(dict):
    """
    DataLake Local Storage details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeLocalStorageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeLocalStorageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeLocalStorageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_name: str):
        """
        DataLake Local Storage details.
        :param str volume_name: Volume name to write to.
        """
        pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> str:
        """
        Volume name to write to.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class DataLakeServiceStorageAuthenticationResponse(dict):
    """
    DataLake Service Storage authentication details. NOTE - Enum only one method is supported.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenSecretName":
            suggest = "access_token_secret_name"
        elif key == "systemAssignedManagedIdentity":
            suggest = "system_assigned_managed_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeServiceStorageAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeServiceStorageAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeServiceStorageAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token_secret_name: Optional[str] = None,
                 system_assigned_managed_identity: Optional['outputs.ManagedIdentityAuthenticationResponse'] = None):
        """
        DataLake Service Storage authentication details. NOTE - Enum only one method is supported.
        :param str access_token_secret_name: Access token secret name.
        :param 'ManagedIdentityAuthenticationResponse' system_assigned_managed_identity: Configuration for managed identity authentication.
        """
        if access_token_secret_name is not None:
            pulumi.set(__self__, "access_token_secret_name", access_token_secret_name)
        if system_assigned_managed_identity is not None:
            pulumi.set(__self__, "system_assigned_managed_identity", system_assigned_managed_identity)

    @property
    @pulumi.getter(name="accessTokenSecretName")
    def access_token_secret_name(self) -> Optional[str]:
        """
        Access token secret name.
        """
        return pulumi.get(self, "access_token_secret_name")

    @property
    @pulumi.getter(name="systemAssignedManagedIdentity")
    def system_assigned_managed_identity(self) -> Optional['outputs.ManagedIdentityAuthenticationResponse']:
        """
        Configuration for managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity")


@pulumi.output_type
class DataLakeServiceStorageResponse(dict):
    """
    DataLake Service Storage details.
    """
    def __init__(__self__, *,
                 authentication: 'outputs.DataLakeServiceStorageAuthenticationResponse',
                 endpoint: str):
        """
        DataLake Service Storage details.
        :param 'DataLakeServiceStorageAuthenticationResponse' authentication: DataLake service storage authentication details. NOTE - Enum only one method is supported.
        :param str endpoint: DataLake service storage endpoint to use.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataLakeServiceStorageAuthenticationResponse':
        """
        DataLake service storage authentication details. NOTE - Enum only one method is supported.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        DataLake service storage endpoint to use.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class DataLakeTargetStorageResponse(dict):
    """
    Target storage for the DataLake. NOTE - Enum only storage is supported at a time.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datalakeStorage":
            suggest = "datalake_storage"
        elif key == "fabricOneLake":
            suggest = "fabric_one_lake"
        elif key == "localStorage":
            suggest = "local_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeTargetStorageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeTargetStorageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeTargetStorageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datalake_storage: Optional['outputs.DataLakeServiceStorageResponse'] = None,
                 fabric_one_lake: Optional['outputs.DataLakeFabricStorageResponse'] = None,
                 local_storage: Optional['outputs.DataLakeLocalStorageResponse'] = None):
        """
        Target storage for the DataLake. NOTE - Enum only storage is supported at a time.
        :param 'DataLakeServiceStorageResponse' datalake_storage: DataLake service storage details.
        :param 'DataLakeFabricStorageResponse' fabric_one_lake: Fabric one lake storage details.
        :param 'DataLakeLocalStorageResponse' local_storage: Local storage details.
        """
        if datalake_storage is not None:
            pulumi.set(__self__, "datalake_storage", datalake_storage)
        if fabric_one_lake is not None:
            pulumi.set(__self__, "fabric_one_lake", fabric_one_lake)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)

    @property
    @pulumi.getter(name="datalakeStorage")
    def datalake_storage(self) -> Optional['outputs.DataLakeServiceStorageResponse']:
        """
        DataLake service storage details.
        """
        return pulumi.get(self, "datalake_storage")

    @property
    @pulumi.getter(name="fabricOneLake")
    def fabric_one_lake(self) -> Optional['outputs.DataLakeFabricStorageResponse']:
        """
        Fabric one lake storage details.
        """
        return pulumi.get(self, "fabric_one_lake")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional['outputs.DataLakeLocalStorageResponse']:
        """
        Local storage details.
        """
        return pulumi.get(self, "local_storage")


@pulumi.output_type
class DeltaTableResponse(dict):
    """
    Delta table properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableName":
            suggest = "table_name"
        elif key == "tablePath":
            suggest = "table_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeltaTableResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeltaTableResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeltaTableResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: Sequence['outputs.DeltaTableSchemaResponse'],
                 table_name: str,
                 table_path: Optional[str] = None):
        """
        Delta table properties
        :param Sequence['DeltaTableSchemaResponse'] schema: Schema list supported.
        :param str table_name: Delta table name.
        :param str table_path: Delta table path.
        """
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "table_name", table_name)
        if table_path is not None:
            pulumi.set(__self__, "table_path", table_path)

    @property
    @pulumi.getter
    def schema(self) -> Sequence['outputs.DeltaTableSchemaResponse']:
        """
        Schema list supported.
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        Delta table name.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="tablePath")
    def table_path(self) -> Optional[str]:
        """
        Delta table path.
        """
        return pulumi.get(self, "table_path")


@pulumi.output_type
class DeltaTableSchemaResponse(dict):
    """
    Delta table schema properties
    """
    def __init__(__self__, *,
                 format: str,
                 mapping: str,
                 name: str,
                 optional: bool):
        """
        Delta table schema properties
        :param str format: Delta table format supported.
        :param str mapping: Delta table schema mapping.
        :param str name: Delta table schema name.
        :param bool optional: Delta table schema optional.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "mapping", mapping)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Delta table format supported.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def mapping(self) -> str:
        """
        Delta table schema mapping.
        """
        return pulumi.get(self, "mapping")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Delta table schema name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> bool:
        """
        Delta table schema optional.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class DiskBackedMessageBufferSettingsResponse(dict):
    """
    DiskBackedMessageBufferSettings properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "ephemeralVolumeClaimSpec":
            suggest = "ephemeral_volume_claim_spec"
        elif key == "persistentVolumeClaimSpec":
            suggest = "persistent_volume_claim_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskBackedMessageBufferSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskBackedMessageBufferSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskBackedMessageBufferSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: str,
                 ephemeral_volume_claim_spec: Optional['outputs.VolumeClaimSpecResponse'] = None,
                 persistent_volume_claim_spec: Optional['outputs.VolumeClaimSpecResponse'] = None):
        """
        DiskBackedMessageBufferSettings properties
        :param str max_size: The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        :param 'VolumeClaimSpecResponse' ephemeral_volume_claim_spec: Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        :param 'VolumeClaimSpecResponse' persistent_volume_claim_spec: Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        pulumi.set(__self__, "max_size", max_size)
        if ephemeral_volume_claim_spec is not None:
            pulumi.set(__self__, "ephemeral_volume_claim_spec", ephemeral_volume_claim_spec)
        if persistent_volume_claim_spec is not None:
            pulumi.set(__self__, "persistent_volume_claim_spec", persistent_volume_claim_spec)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> str:
        """
        The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="ephemeralVolumeClaimSpec")
    def ephemeral_volume_claim_spec(self) -> Optional['outputs.VolumeClaimSpecResponse']:
        """
        Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        """
        return pulumi.get(self, "ephemeral_volume_claim_spec")

    @property
    @pulumi.getter(name="persistentVolumeClaimSpec")
    def persistent_volume_claim_spec(self) -> Optional['outputs.VolumeClaimSpecResponse']:
        """
        Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        return pulumi.get(self, "persistent_volume_claim_spec")


@pulumi.output_type
class ExtendedLocationPropertyResponse(dict):
    """
    ExtendedLocation properties
    """
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        ExtendedLocation properties
        :param str name: The name of the extended location.
        :param str type: Type of ExtendedLocation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ExtendedLocation.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FabricGuidsResponse(dict):
    """
    Fabric one lake guids.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lakehouseGuid":
            suggest = "lakehouse_guid"
        elif key == "workspaceGuid":
            suggest = "workspace_guid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FabricGuidsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FabricGuidsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FabricGuidsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lakehouse_guid: str,
                 workspace_guid: str):
        """
        Fabric one lake guids.
        :param str lakehouse_guid: Fabric one lake house guid.
        :param str workspace_guid: Fabric one lake workspace guid.
        """
        pulumi.set(__self__, "lakehouse_guid", lakehouse_guid)
        pulumi.set(__self__, "workspace_guid", workspace_guid)

    @property
    @pulumi.getter(name="lakehouseGuid")
    def lakehouse_guid(self) -> str:
        """
        Fabric one lake house guid.
        """
        return pulumi.get(self, "lakehouse_guid")

    @property
    @pulumi.getter(name="workspaceGuid")
    def workspace_guid(self) -> str:
        """
        Fabric one lake workspace guid.
        """
        return pulumi.get(self, "workspace_guid")


@pulumi.output_type
class FabricNamesResponse(dict):
    """
    Fabric one lake names.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lakehouseName":
            suggest = "lakehouse_name"
        elif key == "workspaceName":
            suggest = "workspace_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FabricNamesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FabricNamesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FabricNamesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lakehouse_name: str,
                 workspace_name: str):
        """
        Fabric one lake names.
        :param str lakehouse_name: Fabric one lake house name.
        :param str workspace_name: Fabric one lake workspace name.
        """
        pulumi.set(__self__, "lakehouse_name", lakehouse_name)
        pulumi.set(__self__, "workspace_name", workspace_name)

    @property
    @pulumi.getter(name="lakehouseName")
    def lakehouse_name(self) -> str:
        """
        Fabric one lake house name.
        """
        return pulumi.get(self, "lakehouse_name")

    @property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> str:
        """
        Fabric one lake workspace name.
        """
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class FrontendResponse(dict):
    """
    Desired properties of the Frontend Instances of the DMQTT Broker
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporaryResourceLimits":
            suggest = "temporary_resource_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontendResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontendResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontendResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replicas: int,
                 temporary_resource_limits: Optional['outputs.TemporaryResourceLimitsConfigResponse'] = None,
                 workers: Optional[int] = None):
        """
        Desired properties of the Frontend Instances of the DMQTT Broker
        :param int replicas: Replicas is desired number of frontend replicas of the given distributed MQTT broker.
        :param 'TemporaryResourceLimitsConfigResponse' temporary_resource_limits: Defines the limits for resources of the frontend instances of the MQTT broker.
        :param int workers: Number of logical frontend workers per pod.
        """
        pulumi.set(__self__, "replicas", replicas)
        if temporary_resource_limits is not None:
            pulumi.set(__self__, "temporary_resource_limits", temporary_resource_limits)
        if workers is None:
            workers = 2
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter
    def replicas(self) -> int:
        """
        Replicas is desired number of frontend replicas of the given distributed MQTT broker.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="temporaryResourceLimits")
    def temporary_resource_limits(self) -> Optional['outputs.TemporaryResourceLimitsConfigResponse']:
        """
        Defines the limits for resources of the frontend instances of the MQTT broker.
        """
        return pulumi.get(self, "temporary_resource_limits")

    @property
    @pulumi.getter
    def workers(self) -> Optional[int]:
        """
        Number of logical frontend workers per pod.
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class KafkaRemoteBrokerAuthenticationPropertiesResponse(dict):
    """
    Kafka RemoteBrokerConnection Authentication methods
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaRemoteBrokerAuthenticationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaRemoteBrokerAuthenticationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaRemoteBrokerAuthenticationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auth_type: Optional['outputs.KafkaRemoteBrokerAuthenticationTypesResponse'] = None):
        """
        Kafka RemoteBrokerConnection Authentication methods
        :param bool enabled: If authentication is enabled for Kafka remote broker.
        :param 'KafkaRemoteBrokerAuthenticationTypesResponse' auth_type: The type of authentication to use for Kafka remote broker.
        """
        pulumi.set(__self__, "enabled", enabled)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If authentication is enabled for Kafka remote broker.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional['outputs.KafkaRemoteBrokerAuthenticationTypesResponse']:
        """
        The type of authentication to use for Kafka remote broker.
        """
        return pulumi.get(self, "auth_type")


@pulumi.output_type
class KafkaRemoteBrokerAuthenticationTypesResponse(dict):
    """
    Kafka RemoteBrokerConnection Authentication types. NOTE - Enum only one method is allowed to be passed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemAssignedManagedIdentity":
            suggest = "system_assigned_managed_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaRemoteBrokerAuthenticationTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaRemoteBrokerAuthenticationTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaRemoteBrokerAuthenticationTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sasl: Optional['outputs.SaslRemoteBrokerBasicAuthenticationResponse'] = None,
                 system_assigned_managed_identity: Optional['outputs.ManagedIdentityAuthenticationResponse'] = None,
                 x509: Optional['outputs.KafkaX509AuthenticationResponse'] = None):
        """
        Kafka RemoteBrokerConnection Authentication types. NOTE - Enum only one method is allowed to be passed.
        :param 'SaslRemoteBrokerBasicAuthenticationResponse' sasl: Sasl remote broker authentication method.
        :param 'ManagedIdentityAuthenticationResponse' system_assigned_managed_identity: Managed identity remote broker authentication method.
        :param 'KafkaX509AuthenticationResponse' x509: X509 remote broker authentication method.
        """
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)
        if system_assigned_managed_identity is not None:
            pulumi.set(__self__, "system_assigned_managed_identity", system_assigned_managed_identity)
        if x509 is not None:
            pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def sasl(self) -> Optional['outputs.SaslRemoteBrokerBasicAuthenticationResponse']:
        """
        Sasl remote broker authentication method.
        """
        return pulumi.get(self, "sasl")

    @property
    @pulumi.getter(name="systemAssignedManagedIdentity")
    def system_assigned_managed_identity(self) -> Optional['outputs.ManagedIdentityAuthenticationResponse']:
        """
        Managed identity remote broker authentication method.
        """
        return pulumi.get(self, "system_assigned_managed_identity")

    @property
    @pulumi.getter
    def x509(self) -> Optional['outputs.KafkaX509AuthenticationResponse']:
        """
        X509 remote broker authentication method.
        """
        return pulumi.get(self, "x509")


@pulumi.output_type
class KafkaRemoteBrokerConnectionSpecResponse(dict):
    """
    Kafka RemoteBrokerConnectionSpec details
    """
    def __init__(__self__, *,
                 authentication: 'outputs.KafkaRemoteBrokerAuthenticationPropertiesResponse',
                 endpoint: str,
                 tls: 'outputs.KafkaRemoteBrokerConnectionTlsResponse'):
        """
        Kafka RemoteBrokerConnectionSpec details
        :param 'KafkaRemoteBrokerAuthenticationPropertiesResponse' authentication: The remote broker authentication methods.
        :param str endpoint: The endpoint of remote broker to connect to.
        :param 'KafkaRemoteBrokerConnectionTlsResponse' tls: TLS details for Remote broker Connection.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.KafkaRemoteBrokerAuthenticationPropertiesResponse':
        """
        The remote broker authentication methods.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The endpoint of remote broker to connect to.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def tls(self) -> 'outputs.KafkaRemoteBrokerConnectionTlsResponse':
        """
        TLS details for Remote broker Connection.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class KafkaRemoteBrokerConnectionTlsResponse(dict):
    """
    Kafka RemoteBrokerConnection TLS details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsEnabled":
            suggest = "tls_enabled"
        elif key == "trustedCaCertificateConfigMap":
            suggest = "trusted_ca_certificate_config_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaRemoteBrokerConnectionTlsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaRemoteBrokerConnectionTlsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaRemoteBrokerConnectionTlsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tls_enabled: bool,
                 trusted_ca_certificate_config_map: Optional[str] = None):
        """
        Kafka RemoteBrokerConnection TLS details
        :param bool tls_enabled: Tls Enabled on Remote Broker Connection.
        :param str trusted_ca_certificate_config_map: Trusted CA certificate name for Remote Broker.
        """
        pulumi.set(__self__, "tls_enabled", tls_enabled)
        if trusted_ca_certificate_config_map is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map", trusted_ca_certificate_config_map)

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> bool:
        """
        Tls Enabled on Remote Broker Connection.
        """
        return pulumi.get(self, "tls_enabled")

    @property
    @pulumi.getter(name="trustedCaCertificateConfigMap")
    def trusted_ca_certificate_config_map(self) -> Optional[str]:
        """
        Trusted CA certificate name for Remote Broker.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map")


@pulumi.output_type
class KafkaRoutesResponse(dict):
    """
    Kafka Routes properties. NOTE - Enum only one method is allowed to be passed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaToMqtt":
            suggest = "kafka_to_mqtt"
        elif key == "mqttToKafka":
            suggest = "mqtt_to_kafka"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_to_mqtt: Optional['outputs.KafkaToMqttRoutesResponse'] = None,
                 mqtt_to_kafka: Optional['outputs.MqttToKafkaRoutesResponse'] = None):
        """
        Kafka Routes properties. NOTE - Enum only one method is allowed to be passed.
        :param 'KafkaToMqttRoutesResponse' kafka_to_mqtt: Kafka to Mqtt route.
        :param 'MqttToKafkaRoutesResponse' mqtt_to_kafka: Mqtt to Kafka route.
        """
        if kafka_to_mqtt is not None:
            pulumi.set(__self__, "kafka_to_mqtt", kafka_to_mqtt)
        if mqtt_to_kafka is not None:
            pulumi.set(__self__, "mqtt_to_kafka", mqtt_to_kafka)

    @property
    @pulumi.getter(name="kafkaToMqtt")
    def kafka_to_mqtt(self) -> Optional['outputs.KafkaToMqttRoutesResponse']:
        """
        Kafka to Mqtt route.
        """
        return pulumi.get(self, "kafka_to_mqtt")

    @property
    @pulumi.getter(name="mqttToKafka")
    def mqtt_to_kafka(self) -> Optional['outputs.MqttToKafkaRoutesResponse']:
        """
        Mqtt to Kafka route.
        """
        return pulumi.get(self, "mqtt_to_kafka")


@pulumi.output_type
class KafkaSharedSubscriptionPropertiesResponse(dict):
    """
    Kafka Shared Subscription properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupMinimumShareNumber":
            suggest = "group_minimum_share_number"
        elif key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaSharedSubscriptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaSharedSubscriptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaSharedSubscriptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_minimum_share_number: int,
                 group_name: str):
        """
        Kafka Shared Subscription properties
        :param int group_minimum_share_number: The minimum number to use in a group for subscription.
        :param str group_name: The name of the shared subscription.
        """
        pulumi.set(__self__, "group_minimum_share_number", group_minimum_share_number)
        pulumi.set(__self__, "group_name", group_name)

    @property
    @pulumi.getter(name="groupMinimumShareNumber")
    def group_minimum_share_number(self) -> int:
        """
        The minimum number to use in a group for subscription.
        """
        return pulumi.get(self, "group_minimum_share_number")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> str:
        """
        The name of the shared subscription.
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class KafkaToMqttRoutesResponse(dict):
    """
    Kafka to Mqtt route properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaTopic":
            suggest = "kafka_topic"
        elif key == "mqttTopic":
            suggest = "mqtt_topic"
        elif key == "consumerGroupId":
            suggest = "consumer_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaToMqttRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaToMqttRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaToMqttRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_topic: str,
                 mqtt_topic: str,
                 name: str,
                 consumer_group_id: Optional[str] = None,
                 qos: Optional[int] = None):
        """
        Kafka to Mqtt route properties
        :param str kafka_topic: The kafka topic to pull from.
        :param str mqtt_topic: The mqtt topic to publish to.
        :param str name: The name of the route.
        :param str consumer_group_id: The consumer group id to use.
        :param int qos: The qos to use for mqtt.
        """
        pulumi.set(__self__, "kafka_topic", kafka_topic)
        pulumi.set(__self__, "mqtt_topic", mqtt_topic)
        pulumi.set(__self__, "name", name)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> str:
        """
        The kafka topic to pull from.
        """
        return pulumi.get(self, "kafka_topic")

    @property
    @pulumi.getter(name="mqttTopic")
    def mqtt_topic(self) -> str:
        """
        The mqtt topic to publish to.
        """
        return pulumi.get(self, "mqtt_topic")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[str]:
        """
        The consumer group id to use.
        """
        return pulumi.get(self, "consumer_group_id")

    @property
    @pulumi.getter
    def qos(self) -> Optional[int]:
        """
        The qos to use for mqtt.
        """
        return pulumi.get(self, "qos")


@pulumi.output_type
class KafkaTokenKeyVaultPropertiesResponse(dict):
    """
    Kafka Token KeyVault properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vaultSecret":
            suggest = "vault_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaTokenKeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaTokenKeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaTokenKeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vault: 'outputs.KeyVaultConnectionPropertiesResponse',
                 vault_secret: 'outputs.KeyVaultSecretObjectResponse',
                 username: Optional[str] = None):
        """
        Kafka Token KeyVault properties.
        :param 'KeyVaultConnectionPropertiesResponse' vault: KeyVault properties.
        :param 'KeyVaultSecretObjectResponse' vault_secret: KeyVault secret details.
        :param str username: Username to connect with.
        """
        pulumi.set(__self__, "vault", vault)
        pulumi.set(__self__, "vault_secret", vault_secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def vault(self) -> 'outputs.KeyVaultConnectionPropertiesResponse':
        """
        KeyVault properties.
        """
        return pulumi.get(self, "vault")

    @property
    @pulumi.getter(name="vaultSecret")
    def vault_secret(self) -> 'outputs.KeyVaultSecretObjectResponse':
        """
        KeyVault secret details.
        """
        return pulumi.get(self, "vault_secret")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to connect with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class KafkaTopicMapBatchingResponse(dict):
    """
    Kafka TopicMap Batching properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latencyMs":
            suggest = "latency_ms"
        elif key == "maxBytes":
            suggest = "max_bytes"
        elif key == "maxMessages":
            suggest = "max_messages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaTopicMapBatchingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaTopicMapBatchingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaTopicMapBatchingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 latency_ms: Optional[int] = None,
                 max_bytes: Optional[float] = None,
                 max_messages: Optional[float] = None):
        """
        Kafka TopicMap Batching properties
        :param bool enabled: The setting to enable or disable batching.
        :param int latency_ms: The latency of message batching.
        :param float max_bytes: The maximum bytes to send in a batch.
        :param float max_messages: The maximum messages to send in a batch.
        """
        if enabled is None:
            enabled = False
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if latency_ms is None:
            latency_ms = 5
        if latency_ms is not None:
            pulumi.set(__self__, "latency_ms", latency_ms)
        if max_bytes is None:
            max_bytes = 1000000
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        The setting to enable or disable batching.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="latencyMs")
    def latency_ms(self) -> Optional[int]:
        """
        The latency of message batching.
        """
        return pulumi.get(self, "latency_ms")

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[float]:
        """
        The maximum bytes to send in a batch.
        """
        return pulumi.get(self, "max_bytes")

    @property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[float]:
        """
        The maximum messages to send in a batch.
        """
        return pulumi.get(self, "max_messages")


@pulumi.output_type
class KafkaX509AuthenticationResponse(dict):
    """
    Kafka RemoteBrokerConnection X509 Authentication properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVault":
            suggest = "key_vault"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaX509AuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaX509AuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaX509AuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault: Optional['outputs.KeyVaultCertificatePropertiesResponse'] = None,
                 secret_name: Optional[str] = None):
        """
        Kafka RemoteBrokerConnection X509 Authentication properties.
        :param 'KeyVaultCertificatePropertiesResponse' key_vault: Keyvault X509 secret properties.
        :param str secret_name: Secret where cert details are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional['outputs.KeyVaultCertificatePropertiesResponse']:
        """
        Keyvault X509 secret properties.
        """
        return pulumi.get(self, "key_vault")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Secret where cert details are stored.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class KeyVaultCertificatePropertiesResponse(dict):
    """
    KeyVault certificate properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vaultCert":
            suggest = "vault_cert"
        elif key == "vaultCaChainSecret":
            suggest = "vault_ca_chain_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultCertificatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultCertificatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultCertificatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vault: 'outputs.KeyVaultConnectionPropertiesResponse',
                 vault_cert: 'outputs.KeyVaultSecretObjectResponse',
                 vault_ca_chain_secret: Optional['outputs.KeyVaultSecretObjectResponse'] = None):
        """
        KeyVault certificate properties
        :param 'KeyVaultConnectionPropertiesResponse' vault: KeyVault properties.
        :param 'KeyVaultSecretObjectResponse' vault_cert: KeyVault Cert secret details.
        :param 'KeyVaultSecretObjectResponse' vault_ca_chain_secret: KeyVault CA chain secret details.
        """
        pulumi.set(__self__, "vault", vault)
        pulumi.set(__self__, "vault_cert", vault_cert)
        if vault_ca_chain_secret is not None:
            pulumi.set(__self__, "vault_ca_chain_secret", vault_ca_chain_secret)

    @property
    @pulumi.getter
    def vault(self) -> 'outputs.KeyVaultConnectionPropertiesResponse':
        """
        KeyVault properties.
        """
        return pulumi.get(self, "vault")

    @property
    @pulumi.getter(name="vaultCert")
    def vault_cert(self) -> 'outputs.KeyVaultSecretObjectResponse':
        """
        KeyVault Cert secret details.
        """
        return pulumi.get(self, "vault_cert")

    @property
    @pulumi.getter(name="vaultCaChainSecret")
    def vault_ca_chain_secret(self) -> Optional['outputs.KeyVaultSecretObjectResponse']:
        """
        KeyVault CA chain secret details.
        """
        return pulumi.get(self, "vault_ca_chain_secret")


@pulumi.output_type
class KeyVaultConnectionPropertiesResponse(dict):
    """
    KeyVault properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "directoryId":
            suggest = "directory_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.KeyVaultCredentialsPropertiesResponse',
                 directory_id: str,
                 name: str):
        """
        KeyVault properties
        :param 'KeyVaultCredentialsPropertiesResponse' credentials: KeyVault credentials.
        :param str directory_id: KeyVault directoryId.
        :param str name: KeyVault name.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "directory_id", directory_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.KeyVaultCredentialsPropertiesResponse':
        """
        KeyVault credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> str:
        """
        KeyVault directoryId.
        """
        return pulumi.get(self, "directory_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        KeyVault name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class KeyVaultCredentialsPropertiesResponse(dict):
    """
    KeyVault credentials properties. NOTE - Future this will be ENUM.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "servicePrincipalLocalSecretName":
            suggest = "service_principal_local_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultCredentialsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultCredentialsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultCredentialsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_principal_local_secret_name: str):
        """
        KeyVault credentials properties. NOTE - Future this will be ENUM.
        :param str service_principal_local_secret_name: KeyVault service principal local secret name.
        """
        pulumi.set(__self__, "service_principal_local_secret_name", service_principal_local_secret_name)

    @property
    @pulumi.getter(name="servicePrincipalLocalSecretName")
    def service_principal_local_secret_name(self) -> str:
        """
        KeyVault service principal local secret name.
        """
        return pulumi.get(self, "service_principal_local_secret_name")


@pulumi.output_type
class KeyVaultSecretObjectResponse(dict):
    """
    KeyVault secret object properties
    """
    def __init__(__self__, *,
                 name: str,
                 version: Optional[str] = None):
        """
        KeyVault secret object properties
        :param str name: KeyVault secret name.
        :param str version: KeyVault secret version.
        """
        pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        KeyVault secret name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        KeyVault secret version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class KeyVaultSecretPropertiesResponse(dict):
    """
    KeyVault secret properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vaultSecret":
            suggest = "vault_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultSecretPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultSecretPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultSecretPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vault: 'outputs.KeyVaultConnectionPropertiesResponse',
                 vault_secret: 'outputs.KeyVaultSecretObjectResponse'):
        """
        KeyVault secret properties
        :param 'KeyVaultConnectionPropertiesResponse' vault: KeyVault properties.
        :param 'KeyVaultSecretObjectResponse' vault_secret: KeyVault secret details.
        """
        pulumi.set(__self__, "vault", vault)
        pulumi.set(__self__, "vault_secret", vault_secret)

    @property
    @pulumi.getter
    def vault(self) -> 'outputs.KeyVaultConnectionPropertiesResponse':
        """
        KeyVault properties.
        """
        return pulumi.get(self, "vault")

    @property
    @pulumi.getter(name="vaultSecret")
    def vault_secret(self) -> 'outputs.KeyVaultSecretObjectResponse':
        """
        KeyVault secret details.
        """
        return pulumi.get(self, "vault_secret")


@pulumi.output_type
class LocalBrokerAuthenticationMethodsResponse(dict):
    """
    Mqtt Local Broker Authentication details. Only one method at a time is supported. Default - kubernetes authentication
    """
    def __init__(__self__, *,
                 kubernetes: 'outputs.LocalBrokerKubernetesAuthenticationResponse'):
        """
        Mqtt Local Broker Authentication details. Only one method at a time is supported. Default - kubernetes authentication
        :param 'LocalBrokerKubernetesAuthenticationResponse' kubernetes: Kubernetes local broker authentication method.
        """
        pulumi.set(__self__, "kubernetes", kubernetes)

    @property
    @pulumi.getter
    def kubernetes(self) -> 'outputs.LocalBrokerKubernetesAuthenticationResponse':
        """
        Kubernetes local broker authentication method.
        """
        return pulumi.get(self, "kubernetes")


@pulumi.output_type
class LocalBrokerConnectionSpecResponse(dict):
    """
    Mqtt Local Broker ConnectionSpec details
    """
    def __init__(__self__, *,
                 authentication: Optional['outputs.LocalBrokerAuthenticationMethodsResponse'] = None,
                 endpoint: Optional[str] = None,
                 tls: Optional['outputs.LocalBrokerConnectionTlsResponse'] = None):
        """
        Mqtt Local Broker ConnectionSpec details
        :param 'LocalBrokerAuthenticationMethodsResponse' authentication: The authentication methods for LocalBroker connection. NOTE - Enum only one method at a time is supported.
        :param str endpoint: The endpoint of local broker to connect to.
        :param 'LocalBrokerConnectionTlsResponse' tls: TLS details for Local broker Connection.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if endpoint is None:
            endpoint = 'aio-mq-dmqtt-frontend:1883'
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.LocalBrokerAuthenticationMethodsResponse']:
        """
        The authentication methods for LocalBroker connection. NOTE - Enum only one method at a time is supported.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The endpoint of local broker to connect to.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.LocalBrokerConnectionTlsResponse']:
        """
        TLS details for Local broker Connection.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class LocalBrokerConnectionTlsResponse(dict):
    """
    Mqtt Local Broker Connection TLS details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsEnabled":
            suggest = "tls_enabled"
        elif key == "trustedCaCertificateConfigMap":
            suggest = "trusted_ca_certificate_config_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalBrokerConnectionTlsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalBrokerConnectionTlsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalBrokerConnectionTlsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tls_enabled: Optional[bool] = None,
                 trusted_ca_certificate_config_map: Optional[str] = None):
        """
        Mqtt Local Broker Connection TLS details
        :param bool tls_enabled: Tls Enabled on Local Broker Connection.
        :param str trusted_ca_certificate_config_map: Trusted CA certificate config map name for Local Broker.
        """
        if tls_enabled is None:
            tls_enabled = False
        if tls_enabled is not None:
            pulumi.set(__self__, "tls_enabled", tls_enabled)
        if trusted_ca_certificate_config_map is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map", trusted_ca_certificate_config_map)

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> Optional[bool]:
        """
        Tls Enabled on Local Broker Connection.
        """
        return pulumi.get(self, "tls_enabled")

    @property
    @pulumi.getter(name="trustedCaCertificateConfigMap")
    def trusted_ca_certificate_config_map(self) -> Optional[str]:
        """
        Trusted CA certificate config map name for Local Broker.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map")


@pulumi.output_type
class LocalBrokerKubernetesAuthenticationResponse(dict):
    """
    Local Broker Kubernetes Authentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretPath":
            suggest = "secret_path"
        elif key == "serviceAccountTokenName":
            suggest = "service_account_token_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalBrokerKubernetesAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalBrokerKubernetesAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalBrokerKubernetesAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_path: Optional[str] = None,
                 service_account_token_name: Optional[str] = None):
        """
        Local Broker Kubernetes Authentication
        :param str secret_path: Secret Path where SAT is mounted.
        :param str service_account_token_name: Token name where SAT is mounted on secret path.
        """
        if secret_path is None:
            secret_path = '/var/run/serviceaccount/localbroker'
        if secret_path is not None:
            pulumi.set(__self__, "secret_path", secret_path)
        if service_account_token_name is None:
            service_account_token_name = 'sat'
        if service_account_token_name is not None:
            pulumi.set(__self__, "service_account_token_name", service_account_token_name)

    @property
    @pulumi.getter(name="secretPath")
    def secret_path(self) -> Optional[str]:
        """
        Secret Path where SAT is mounted.
        """
        return pulumi.get(self, "secret_path")

    @property
    @pulumi.getter(name="serviceAccountTokenName")
    def service_account_token_name(self) -> Optional[str]:
        """
        Token name where SAT is mounted on secret path.
        """
        return pulumi.get(self, "service_account_token_name")


@pulumi.output_type
class ManagedIdentityAuthenticationResponse(dict):
    """
    Managed identity authentication details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionName":
            suggest = "extension_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audience: str,
                 extension_name: Optional[str] = None):
        """
        Managed identity authentication details.
        :param str audience: Token audience.
        :param str extension_name: Arc Extension name.
        """
        pulumi.set(__self__, "audience", audience)
        if extension_name is not None:
            pulumi.set(__self__, "extension_name", extension_name)

    @property
    @pulumi.getter
    def audience(self) -> str:
        """
        Token audience.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="extensionName")
    def extension_name(self) -> Optional[str]:
        """
        Arc Extension name.
        """
        return pulumi.get(self, "extension_name")


@pulumi.output_type
class ManualCertMethodResponse(dict):
    """
    Manual TLS server certificate management through a defined secret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"
        elif key == "secretNamespace":
            suggest = "secret_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManualCertMethodResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManualCertMethodResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManualCertMethodResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str,
                 secret_namespace: Optional[str] = None):
        """
        Manual TLS server certificate management through a defined secret
        :param str secret_name: secret containing TLS cert.
        :param str secret_namespace: namespace of secret; omit to use default namespace.
        """
        pulumi.set(__self__, "secret_name", secret_name)
        if secret_namespace is not None:
            pulumi.set(__self__, "secret_namespace", secret_namespace)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        secret containing TLS cert.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="secretNamespace")
    def secret_namespace(self) -> Optional[str]:
        """
        namespace of secret; omit to use default namespace.
        """
        return pulumi.get(self, "secret_namespace")


@pulumi.output_type
class MqttBridgeRemoteBrokerAuthenticationMethodsResponse(dict):
    """
    MqttBridge RemoteBrokerConnection Authentication methods. NOTE - Enum only one is allowed to be passed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemAssignedManagedIdentity":
            suggest = "system_assigned_managed_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MqttBridgeRemoteBrokerAuthenticationMethodsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MqttBridgeRemoteBrokerAuthenticationMethodsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MqttBridgeRemoteBrokerAuthenticationMethodsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 system_assigned_managed_identity: Optional['outputs.ManagedIdentityAuthenticationResponse'] = None,
                 x509: Optional['outputs.MqttBridgeRemoteBrokerX509AuthenticationResponse'] = None):
        """
        MqttBridge RemoteBrokerConnection Authentication methods. NOTE - Enum only one is allowed to be passed.
        :param 'ManagedIdentityAuthenticationResponse' system_assigned_managed_identity: Managed identity remote broker authentication method.
        :param 'MqttBridgeRemoteBrokerX509AuthenticationResponse' x509: X509 remote broker authentication method.
        """
        if system_assigned_managed_identity is not None:
            pulumi.set(__self__, "system_assigned_managed_identity", system_assigned_managed_identity)
        if x509 is not None:
            pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter(name="systemAssignedManagedIdentity")
    def system_assigned_managed_identity(self) -> Optional['outputs.ManagedIdentityAuthenticationResponse']:
        """
        Managed identity remote broker authentication method.
        """
        return pulumi.get(self, "system_assigned_managed_identity")

    @property
    @pulumi.getter
    def x509(self) -> Optional['outputs.MqttBridgeRemoteBrokerX509AuthenticationResponse']:
        """
        X509 remote broker authentication method.
        """
        return pulumi.get(self, "x509")


@pulumi.output_type
class MqttBridgeRemoteBrokerConnectionSpecResponse(dict):
    """
    MqttBridge RemoteBrokerConnectionSpec details
    """
    def __init__(__self__, *,
                 authentication: 'outputs.MqttBridgeRemoteBrokerAuthenticationMethodsResponse',
                 endpoint: str,
                 tls: 'outputs.MqttBridgeRemoteBrokerConnectionTlsResponse',
                 protocol: Optional[str] = None):
        """
        MqttBridge RemoteBrokerConnectionSpec details
        :param 'MqttBridgeRemoteBrokerAuthenticationMethodsResponse' authentication: The remote broker authentication methods. NOTE - Enum only one method is allowed to be passed.
        :param str endpoint: The endpoint of remote broker to connect to.
        :param 'MqttBridgeRemoteBrokerConnectionTlsResponse' tls: TLS details for Remote broker Connection.
        :param str protocol: Protocol for remote connection.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "tls", tls)
        if protocol is None:
            protocol = 'mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.MqttBridgeRemoteBrokerAuthenticationMethodsResponse':
        """
        The remote broker authentication methods. NOTE - Enum only one method is allowed to be passed.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The endpoint of remote broker to connect to.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def tls(self) -> 'outputs.MqttBridgeRemoteBrokerConnectionTlsResponse':
        """
        TLS details for Remote broker Connection.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for remote connection.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class MqttBridgeRemoteBrokerConnectionTlsResponse(dict):
    """
    MqttBridge RemoteBrokerConnection TLS details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsEnabled":
            suggest = "tls_enabled"
        elif key == "trustedCaCertificateConfigMap":
            suggest = "trusted_ca_certificate_config_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MqttBridgeRemoteBrokerConnectionTlsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MqttBridgeRemoteBrokerConnectionTlsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MqttBridgeRemoteBrokerConnectionTlsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tls_enabled: bool,
                 trusted_ca_certificate_config_map: Optional[str] = None):
        """
        MqttBridge RemoteBrokerConnection TLS details
        :param bool tls_enabled: Tls Enabled on Remote Broker Connection.
        :param str trusted_ca_certificate_config_map: Trusted CA certificate name for Remote Broker.
        """
        pulumi.set(__self__, "tls_enabled", tls_enabled)
        if trusted_ca_certificate_config_map is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map", trusted_ca_certificate_config_map)

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> bool:
        """
        Tls Enabled on Remote Broker Connection.
        """
        return pulumi.get(self, "tls_enabled")

    @property
    @pulumi.getter(name="trustedCaCertificateConfigMap")
    def trusted_ca_certificate_config_map(self) -> Optional[str]:
        """
        Trusted CA certificate name for Remote Broker.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map")


@pulumi.output_type
class MqttBridgeRemoteBrokerX509AuthenticationResponse(dict):
    """
    MqttBridge RemoteBroker X509 Authentication properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVault":
            suggest = "key_vault"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MqttBridgeRemoteBrokerX509AuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MqttBridgeRemoteBrokerX509AuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MqttBridgeRemoteBrokerX509AuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault: Optional['outputs.KeyVaultCertificatePropertiesResponse'] = None,
                 secret_name: Optional[str] = None):
        """
        MqttBridge RemoteBroker X509 Authentication properties.
        :param 'KeyVaultCertificatePropertiesResponse' key_vault: Keyvault X509 secret properties.
        :param str secret_name: Secret where cert details are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional['outputs.KeyVaultCertificatePropertiesResponse']:
        """
        Keyvault X509 secret properties.
        """
        return pulumi.get(self, "key_vault")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Secret where cert details are stored.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class MqttBridgeRouteSharedSubscriptionResponse(dict):
    """
    MqttBridgeRoute Shared subscription properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupMinimumShareNumber":
            suggest = "group_minimum_share_number"
        elif key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MqttBridgeRouteSharedSubscriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MqttBridgeRouteSharedSubscriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MqttBridgeRouteSharedSubscriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_minimum_share_number: int,
                 group_name: str):
        """
        MqttBridgeRoute Shared subscription properties
        :param int group_minimum_share_number: The group shared subscription minimum share number.
        :param str group_name: The group name for Shared subscription.
        """
        pulumi.set(__self__, "group_minimum_share_number", group_minimum_share_number)
        pulumi.set(__self__, "group_name", group_name)

    @property
    @pulumi.getter(name="groupMinimumShareNumber")
    def group_minimum_share_number(self) -> int:
        """
        The group shared subscription minimum share number.
        """
        return pulumi.get(self, "group_minimum_share_number")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> str:
        """
        The group name for Shared subscription.
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class MqttBridgeRoutesResponse(dict):
    """
    MqttBridgeTopicMap route properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sharedSubscription":
            suggest = "shared_subscription"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MqttBridgeRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MqttBridgeRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MqttBridgeRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direction: str,
                 name: str,
                 source: str,
                 qos: Optional[int] = None,
                 shared_subscription: Optional['outputs.MqttBridgeRouteSharedSubscriptionResponse'] = None,
                 target: Optional[str] = None):
        """
        MqttBridgeTopicMap route properties
        :param str direction: Direction of the route.
        :param str name: Name of the route.
        :param str source: Source topic of the route.
        :param int qos: Qos for MQTT connection.
        :param 'MqttBridgeRouteSharedSubscriptionResponse' shared_subscription: Shared subscription topic details.
        :param str target: Target topic of the route. Ignore if same as source
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if shared_subscription is not None:
            pulumi.set(__self__, "shared_subscription", shared_subscription)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction of the route.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Source topic of the route.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def qos(self) -> Optional[int]:
        """
        Qos for MQTT connection.
        """
        return pulumi.get(self, "qos")

    @property
    @pulumi.getter(name="sharedSubscription")
    def shared_subscription(self) -> Optional['outputs.MqttBridgeRouteSharedSubscriptionResponse']:
        """
        Shared subscription topic details.
        """
        return pulumi.get(self, "shared_subscription")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Target topic of the route. Ignore if same as source
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class MqttToKafkaRoutesResponse(dict):
    """
    Mqtt to Kafka route properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kafkaAcks":
            suggest = "kafka_acks"
        elif key == "kafkaTopic":
            suggest = "kafka_topic"
        elif key == "mqttTopic":
            suggest = "mqtt_topic"
        elif key == "sharedSubscription":
            suggest = "shared_subscription"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MqttToKafkaRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MqttToKafkaRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MqttToKafkaRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kafka_acks: str,
                 kafka_topic: str,
                 mqtt_topic: str,
                 name: str,
                 qos: Optional[int] = None,
                 shared_subscription: Optional['outputs.KafkaSharedSubscriptionPropertiesResponse'] = None):
        """
        Mqtt to Kafka route properties
        :param str kafka_acks: The kafka acks to use.
        :param str kafka_topic: The kafka topic to publish to.
        :param str mqtt_topic: The mqtt topic to pull from.
        :param str name: The name of the route.
        :param int qos: The qos to use for mqtt.
        :param 'KafkaSharedSubscriptionPropertiesResponse' shared_subscription: The properties for shared subscription.
        """
        pulumi.set(__self__, "kafka_acks", kafka_acks)
        pulumi.set(__self__, "kafka_topic", kafka_topic)
        pulumi.set(__self__, "mqtt_topic", mqtt_topic)
        pulumi.set(__self__, "name", name)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if shared_subscription is not None:
            pulumi.set(__self__, "shared_subscription", shared_subscription)

    @property
    @pulumi.getter(name="kafkaAcks")
    def kafka_acks(self) -> str:
        """
        The kafka acks to use.
        """
        return pulumi.get(self, "kafka_acks")

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> str:
        """
        The kafka topic to publish to.
        """
        return pulumi.get(self, "kafka_topic")

    @property
    @pulumi.getter(name="mqttTopic")
    def mqtt_topic(self) -> str:
        """
        The mqtt topic to pull from.
        """
        return pulumi.get(self, "mqtt_topic")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def qos(self) -> Optional[int]:
        """
        The qos to use for mqtt.
        """
        return pulumi.get(self, "qos")

    @property
    @pulumi.getter(name="sharedSubscription")
    def shared_subscription(self) -> Optional['outputs.KafkaSharedSubscriptionPropertiesResponse']:
        """
        The properties for shared subscription.
        """
        return pulumi.get(self, "shared_subscription")


@pulumi.output_type
class NodeTolerationsResponse(dict):
    """
    Defines the Node Tolerations details
    """
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 operator: str,
                 value: str):
        """
        Defines the Node Tolerations details
        :param str effect: Toleration effect.
        :param str key: Toleration key.
        :param str operator: Toleration operator like 'Exists', 'Equal' etc.
        :param str value: Toleration Value.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Toleration effect.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Toleration key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Toleration operator like 'Exists', 'Equal' etc.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Toleration Value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PrincipalDefinitionResponse(dict):
    """
    PrincipalDefinition properties of Basic Rule
    """
    def __init__(__self__, *,
                 attributes: Optional[Sequence[Mapping[str, str]]] = None,
                 clientids: Optional[Sequence[str]] = None,
                 usernames: Optional[Sequence[str]] = None):
        """
        PrincipalDefinition properties of Basic Rule
        :param Sequence[Mapping[str, str]] attributes: A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        :param Sequence[str] clientids: A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        :param Sequence[str] usernames: A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if clientids is not None:
            pulumi.set(__self__, "clientids", clientids)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence[Mapping[str, str]]]:
        """
        A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter
    def clientids(self) -> Optional[Sequence[str]]:
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        """
        return pulumi.get(self, "clientids")

    @property
    @pulumi.getter
    def usernames(self) -> Optional[Sequence[str]]:
        """
        A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class ResourceInfoDefinitionResponse(dict):
    """
    ResourceInfoDefinition properties of Basic Rule. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
    """
    def __init__(__self__, *,
                 method: str,
                 topics: Optional[Sequence[str]] = None):
        """
        ResourceInfoDefinition properties of Basic Rule. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
        :param str method: The type of action that the clients can perform on the broker: Connect, Publish or Subscribe.
        :param Sequence[str] topics: A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        pulumi.set(__self__, "method", method)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The type of action that the clients can perform on the broker: Connect, Publish or Subscribe.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[str]]:
        """
        A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class SanForCertResponse(dict):
    """
    SANs for certificate.
    """
    def __init__(__self__, *,
                 dns: Sequence[str],
                 ip: Sequence[str]):
        """
        SANs for certificate.
        :param Sequence[str] dns: DNS SANs.
        :param Sequence[str] ip: IP address SANs.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def dns(self) -> Sequence[str]:
        """
        DNS SANs.
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def ip(self) -> Sequence[str]:
        """
        IP address SANs.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class SaslRemoteBrokerBasicAuthenticationResponse(dict):
    """
    Kafka RemoteBrokerConnection Sasl Authentication properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "saslType":
            suggest = "sasl_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SaslRemoteBrokerBasicAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SaslRemoteBrokerBasicAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SaslRemoteBrokerBasicAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sasl_type: str,
                 token: 'outputs.SaslRemoteBrokerBasicAuthenticationTokenResponse'):
        """
        Kafka RemoteBrokerConnection Sasl Authentication properties.
        :param str sasl_type: Sasl Mechanism for remote broker authentication.
        :param 'SaslRemoteBrokerBasicAuthenticationTokenResponse' token: Sasl token for remote broker authentication.
        """
        pulumi.set(__self__, "sasl_type", sasl_type)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="saslType")
    def sasl_type(self) -> str:
        """
        Sasl Mechanism for remote broker authentication.
        """
        return pulumi.get(self, "sasl_type")

    @property
    @pulumi.getter
    def token(self) -> 'outputs.SaslRemoteBrokerBasicAuthenticationTokenResponse':
        """
        Sasl token for remote broker authentication.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class SaslRemoteBrokerBasicAuthenticationTokenResponse(dict):
    """
    Kafka RemoteBrokerConnection Sasl Authentication token properties. NOTE - Enum only one method is allowed to be passed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVault":
            suggest = "key_vault"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SaslRemoteBrokerBasicAuthenticationTokenResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SaslRemoteBrokerBasicAuthenticationTokenResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SaslRemoteBrokerBasicAuthenticationTokenResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault: Optional['outputs.KafkaTokenKeyVaultPropertiesResponse'] = None,
                 secret_name: Optional[str] = None):
        """
        Kafka RemoteBrokerConnection Sasl Authentication token properties. NOTE - Enum only one method is allowed to be passed.
        :param 'KafkaTokenKeyVaultPropertiesResponse' key_vault: Keyvault token keyvault secret properties.
        :param str secret_name: Secret where cert details are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional['outputs.KafkaTokenKeyVaultPropertiesResponse']:
        """
        Keyvault token keyvault secret properties.
        """
        return pulumi.get(self, "key_vault")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Secret where cert details are stored.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TemporaryResourceLimitsConfigResponse(dict):
    """
    Internal knobs of Resource Limits for FE and BE
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInflightMessages":
            suggest = "max_inflight_messages"
        elif key == "maxInflightPatches":
            suggest = "max_inflight_patches"
        elif key == "maxInflightPatchesPerClient":
            suggest = "max_inflight_patches_per_client"
        elif key == "maxQueuedMessages":
            suggest = "max_queued_messages"
        elif key == "maxQueuedQos0Messages":
            suggest = "max_queued_qos0_messages"
        elif key == "maxSessionExpirySecs":
            suggest = "max_session_expiry_secs"
        elif key == "maxMessageExpirySecs":
            suggest = "max_message_expiry_secs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemporaryResourceLimitsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemporaryResourceLimitsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemporaryResourceLimitsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_inflight_messages: int,
                 max_inflight_patches: int,
                 max_inflight_patches_per_client: int,
                 max_queued_messages: float,
                 max_queued_qos0_messages: float,
                 max_session_expiry_secs: float,
                 max_message_expiry_secs: Optional[float] = None):
        """
        Internal knobs of Resource Limits for FE and BE
        :param int max_inflight_messages: Maximum number of messages a client can have inflight.
        :param int max_inflight_patches: Maximum number of patch inflight per node.
        :param int max_inflight_patches_per_client: Maximum number of patch a client can have in flight.
        :param float max_queued_messages: Maximum receive for external clients.
        :param float max_queued_qos0_messages: Maximum receive QoS0 for external clients.
        :param float max_session_expiry_secs: Maximum session expiry interval, in seconds.
        :param float max_message_expiry_secs: Maximum message expiry interval, in seconds.
        """
        pulumi.set(__self__, "max_inflight_messages", max_inflight_messages)
        pulumi.set(__self__, "max_inflight_patches", max_inflight_patches)
        pulumi.set(__self__, "max_inflight_patches_per_client", max_inflight_patches_per_client)
        pulumi.set(__self__, "max_queued_messages", max_queued_messages)
        pulumi.set(__self__, "max_queued_qos0_messages", max_queued_qos0_messages)
        pulumi.set(__self__, "max_session_expiry_secs", max_session_expiry_secs)
        if max_message_expiry_secs is not None:
            pulumi.set(__self__, "max_message_expiry_secs", max_message_expiry_secs)

    @property
    @pulumi.getter(name="maxInflightMessages")
    def max_inflight_messages(self) -> int:
        """
        Maximum number of messages a client can have inflight.
        """
        return pulumi.get(self, "max_inflight_messages")

    @property
    @pulumi.getter(name="maxInflightPatches")
    def max_inflight_patches(self) -> int:
        """
        Maximum number of patch inflight per node.
        """
        return pulumi.get(self, "max_inflight_patches")

    @property
    @pulumi.getter(name="maxInflightPatchesPerClient")
    def max_inflight_patches_per_client(self) -> int:
        """
        Maximum number of patch a client can have in flight.
        """
        return pulumi.get(self, "max_inflight_patches_per_client")

    @property
    @pulumi.getter(name="maxQueuedMessages")
    def max_queued_messages(self) -> float:
        """
        Maximum receive for external clients.
        """
        return pulumi.get(self, "max_queued_messages")

    @property
    @pulumi.getter(name="maxQueuedQos0Messages")
    def max_queued_qos0_messages(self) -> float:
        """
        Maximum receive QoS0 for external clients.
        """
        return pulumi.get(self, "max_queued_qos0_messages")

    @property
    @pulumi.getter(name="maxSessionExpirySecs")
    def max_session_expiry_secs(self) -> float:
        """
        Maximum session expiry interval, in seconds.
        """
        return pulumi.get(self, "max_session_expiry_secs")

    @property
    @pulumi.getter(name="maxMessageExpirySecs")
    def max_message_expiry_secs(self) -> Optional[float]:
        """
        Maximum message expiry interval, in seconds.
        """
        return pulumi.get(self, "max_message_expiry_secs")


@pulumi.output_type
class TlsCertMethodResponse(dict):
    """
    Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVault":
            suggest = "key_vault"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TlsCertMethodResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TlsCertMethodResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TlsCertMethodResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic: Optional['outputs.AutomaticCertMethodResponse'] = None,
                 key_vault: Optional['outputs.KeyVaultCertificatePropertiesResponse'] = None,
                 manual: Optional['outputs.ManualCertMethodResponse'] = None):
        """
        Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
        :param 'AutomaticCertMethodResponse' automatic: Option 1 - Automatic TLS server certificate management with cert-manager.
        :param 'KeyVaultCertificatePropertiesResponse' key_vault: Option 3 - TLS server certificate retrieved from Key Vault..
        :param 'ManualCertMethodResponse' manual: Option 2 - Manual TLS server certificate management through a defined secret.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @property
    @pulumi.getter
    def automatic(self) -> Optional['outputs.AutomaticCertMethodResponse']:
        """
        Option 1 - Automatic TLS server certificate management with cert-manager.
        """
        return pulumi.get(self, "automatic")

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional['outputs.KeyVaultCertificatePropertiesResponse']:
        """
        Option 3 - TLS server certificate retrieved from Key Vault..
        """
        return pulumi.get(self, "key_vault")

    @property
    @pulumi.getter
    def manual(self) -> Optional['outputs.ManualCertMethodResponse']:
        """
        Option 2 - Manual TLS server certificate management through a defined secret.
        """
        return pulumi.get(self, "manual")


@pulumi.output_type
class VolumeClaimDataSourceRefResponse(dict):
    """
    VolumeClaimDataSourceRef properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGroup":
            suggest = "api_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeClaimDataSourceRefResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeClaimDataSourceRefResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeClaimDataSourceRefResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: str,
                 name: str,
                 api_group: Optional[str] = None):
        """
        VolumeClaimDataSourceRef properties
        :param str kind: Kind is the type of resource being referenced
        :param str name: Name is the name of resource being referenced
        :param str api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[str]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")


@pulumi.output_type
class VolumeClaimDataSourceResponse(dict):
    """
    VolumeClaimDataSource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGroup":
            suggest = "api_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeClaimDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeClaimDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeClaimDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: str,
                 name: str,
                 api_group: Optional[str] = None):
        """
        VolumeClaimDataSource properties
        :param str kind: Kind is the type of resource being referenced
        :param str name: Name is the name of resource being referenced
        :param str api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[str]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")


@pulumi.output_type
class VolumeClaimResourceRequirementsResponse(dict):
    """
    VolumeClaimResourceRequirements properties
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        VolumeClaimResourceRequirements properties
        :param Mapping[str, str] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class VolumeClaimSpecResponse(dict):
    """
    VolumeClaimSpec properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessModes":
            suggest = "access_modes"
        elif key == "dataSource":
            suggest = "data_source"
        elif key == "dataSourceRef":
            suggest = "data_source_ref"
        elif key == "storageClassName":
            suggest = "storage_class_name"
        elif key == "volumeMode":
            suggest = "volume_mode"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeClaimSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeClaimSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeClaimSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_modes: Optional[Sequence[str]] = None,
                 data_source: Optional['outputs.VolumeClaimDataSourceResponse'] = None,
                 data_source_ref: Optional['outputs.VolumeClaimDataSourceRefResponse'] = None,
                 resources: Optional['outputs.VolumeClaimResourceRequirementsResponse'] = None,
                 selector: Optional['outputs.VolumeClaimSpecSelectorResponse'] = None,
                 storage_class_name: Optional[str] = None,
                 volume_mode: Optional[str] = None,
                 volume_name: Optional[str] = None):
        """
        VolumeClaimSpec properties
        :param Sequence[str] access_modes: AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        :param 'VolumeClaimDataSourceResponse' data_source: This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        :param 'VolumeClaimDataSourceRefResponse' data_source_ref: Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        :param 'VolumeClaimResourceRequirementsResponse' resources: Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param 'VolumeClaimSpecSelectorResponse' selector: A label query over volumes to consider for binding.
        :param str storage_class_name: Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        :param str volume_mode: volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        :param str volume_name: VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        if access_modes is not None:
            pulumi.set(__self__, "access_modes", access_modes)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if data_source_ref is not None:
            pulumi.set(__self__, "data_source_ref", data_source_ref)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)
        if volume_mode is not None:
            pulumi.set(__self__, "volume_mode", volume_mode)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Optional[Sequence[str]]:
        """
        AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional['outputs.VolumeClaimDataSourceResponse']:
        """
        This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="dataSourceRef")
    def data_source_ref(self) -> Optional['outputs.VolumeClaimDataSourceRefResponse']:
        """
        Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        """
        return pulumi.get(self, "data_source_ref")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.VolumeClaimResourceRequirementsResponse']:
        """
        Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.VolumeClaimSpecSelectorResponse']:
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[str]:
        """
        Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        """
        return pulumi.get(self, "storage_class_name")

    @property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> Optional[str]:
        """
        volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        """
        return pulumi.get(self, "volume_mode")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[str]:
        """
        VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class VolumeClaimSpecSelectorMatchExpressionsResponse(dict):
    """
    VolumeClaimSpecSelectorMatchExpressions properties
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        VolumeClaimSpecSelectorMatchExpressions properties
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class VolumeClaimSpecSelectorResponse(dict):
    """
    VolumeClaimSpecSelector properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeClaimSpecSelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeClaimSpecSelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeClaimSpecSelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.VolumeClaimSpecSelectorMatchExpressionsResponse']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        VolumeClaimSpecSelector properties
        :param Sequence['VolumeClaimSpecSelectorMatchExpressionsResponse'] match_expressions: MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.VolumeClaimSpecSelectorMatchExpressionsResponse']]:
        """
        MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


