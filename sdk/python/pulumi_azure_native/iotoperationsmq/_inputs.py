# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'AuthorizationBasicRuleArgs',
    'AuthorizationConfigArgs',
    'AutomaticCertMethodArgs',
    'BackendChainArgs',
    'BrokerAuthenticatorCustomAuthX509Args',
    'BrokerAuthenticatorCustomAuthArgs',
    'BrokerAuthenticatorMethodCustomArgs',
    'BrokerAuthenticatorMethodSatArgs',
    'BrokerAuthenticatorMethodSvidArgs',
    'BrokerAuthenticatorMethodUsernamePasswordArgs',
    'BrokerAuthenticatorMethodX509AttributesArgs',
    'BrokerAuthenticatorMethodX509Args',
    'BrokerAuthenticatorMethodsArgs',
    'BrokerDiagnosticsArgs',
    'CardinalityArgs',
    'CertManagerCertOptionsArgs',
    'CertManagerIssuerRefArgs',
    'CertManagerPrivateKeyArgs',
    'ContainerImageArgs',
    'DataLakeConnectorMapArgs',
    'DataLakeFabricStorageAuthenticationArgs',
    'DataLakeFabricStorageArgs',
    'DataLakeLocalStorageArgs',
    'DataLakeServiceStorageAuthenticationArgs',
    'DataLakeServiceStorageArgs',
    'DataLakeTargetStorageArgs',
    'DeltaTableSchemaArgs',
    'DeltaTableArgs',
    'DiskBackedMessageBufferSettingsArgs',
    'ExtendedLocationPropertyArgs',
    'FabricGuidsArgs',
    'FabricNamesArgs',
    'FrontendArgs',
    'KafkaRemoteBrokerAuthenticationPropertiesArgs',
    'KafkaRemoteBrokerAuthenticationTypesArgs',
    'KafkaRemoteBrokerConnectionSpecArgs',
    'KafkaRemoteBrokerConnectionTlsArgs',
    'KafkaRoutesArgs',
    'KafkaSharedSubscriptionPropertiesArgs',
    'KafkaToMqttRoutesArgs',
    'KafkaTokenKeyVaultPropertiesArgs',
    'KafkaTopicMapBatchingArgs',
    'KafkaX509AuthenticationArgs',
    'KeyVaultCertificatePropertiesArgs',
    'KeyVaultConnectionPropertiesArgs',
    'KeyVaultCredentialsPropertiesArgs',
    'KeyVaultSecretObjectArgs',
    'KeyVaultSecretPropertiesArgs',
    'LocalBrokerAuthenticationMethodsArgs',
    'LocalBrokerConnectionSpecArgs',
    'LocalBrokerConnectionTlsArgs',
    'LocalBrokerKubernetesAuthenticationArgs',
    'ManagedIdentityAuthenticationArgs',
    'ManualCertMethodArgs',
    'MqttBridgeRemoteBrokerAuthenticationMethodsArgs',
    'MqttBridgeRemoteBrokerConnectionSpecArgs',
    'MqttBridgeRemoteBrokerConnectionTlsArgs',
    'MqttBridgeRemoteBrokerX509AuthenticationArgs',
    'MqttBridgeRouteSharedSubscriptionArgs',
    'MqttBridgeRoutesArgs',
    'MqttToKafkaRoutesArgs',
    'NodeTolerationsArgs',
    'PrincipalDefinitionArgs',
    'ResourceInfoDefinitionArgs',
    'SanForCertArgs',
    'SaslRemoteBrokerBasicAuthenticationTokenArgs',
    'SaslRemoteBrokerBasicAuthenticationArgs',
    'TemporaryResourceLimitsConfigArgs',
    'TlsCertMethodArgs',
    'VolumeClaimDataSourceRefArgs',
    'VolumeClaimDataSourceArgs',
    'VolumeClaimResourceRequirementsArgs',
    'VolumeClaimSpecSelectorMatchExpressionsArgs',
    'VolumeClaimSpecSelectorArgs',
    'VolumeClaimSpecArgs',
]

@pulumi.input_type
class AuthorizationBasicRuleArgs:
    def __init__(__self__, *,
                 broker_resources: pulumi.Input[Sequence[pulumi.Input['ResourceInfoDefinitionArgs']]],
                 principals: pulumi.Input['PrincipalDefinitionArgs']):
        """
        BasicRules of AuthorizationConfig Polar rules are not supported
        :param pulumi.Input[Sequence[pulumi.Input['ResourceInfoDefinitionArgs']]] broker_resources: This subfield defines the broker resources that the Basic Rule is applied on.
        :param pulumi.Input['PrincipalDefinitionArgs'] principals: This subfield defines the identities that represent the clients.
        """
        pulumi.set(__self__, "broker_resources", broker_resources)
        pulumi.set(__self__, "principals", principals)

    @property
    @pulumi.getter(name="brokerResources")
    def broker_resources(self) -> pulumi.Input[Sequence[pulumi.Input['ResourceInfoDefinitionArgs']]]:
        """
        This subfield defines the broker resources that the Basic Rule is applied on.
        """
        return pulumi.get(self, "broker_resources")

    @broker_resources.setter
    def broker_resources(self, value: pulumi.Input[Sequence[pulumi.Input['ResourceInfoDefinitionArgs']]]):
        pulumi.set(self, "broker_resources", value)

    @property
    @pulumi.getter
    def principals(self) -> pulumi.Input['PrincipalDefinitionArgs']:
        """
        This subfield defines the identities that represent the clients.
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: pulumi.Input['PrincipalDefinitionArgs']):
        pulumi.set(self, "principals", value)


@pulumi.input_type
class AuthorizationConfigArgs:
    def __init__(__self__, *,
                 enable_cache: Optional[pulumi.Input[bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationBasicRuleArgs']]]] = None):
        """
        Broker AuthorizationConfig properties
        :param pulumi.Input[bool] enable_cache: Enable caching of the authorization rules.
        :param pulumi.Input[Sequence[pulumi.Input['AuthorizationBasicRuleArgs']]] rules: Authorization Rules to be used. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        if enable_cache is None:
            enable_cache = True
        if enable_cache is not None:
            pulumi.set(__self__, "enable_cache", enable_cache)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="enableCache")
    def enable_cache(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable caching of the authorization rules.
        """
        return pulumi.get(self, "enable_cache")

    @enable_cache.setter
    def enable_cache(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cache", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationBasicRuleArgs']]]]:
        """
        Authorization Rules to be used. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationBasicRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class AutomaticCertMethodArgs:
    def __init__(__self__, *,
                 issuer_ref: pulumi.Input['CertManagerIssuerRefArgs'],
                 duration: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input['CertManagerPrivateKeyArgs']] = None,
                 renew_before: Optional[pulumi.Input[str]] = None,
                 san: Optional[pulumi.Input['SanForCertArgs']] = None,
                 secret_name: Optional[pulumi.Input[str]] = None,
                 secret_namespace: Optional[pulumi.Input[str]] = None):
        """
        Automatic TLS server certificate management with cert-manager
        :param pulumi.Input['CertManagerIssuerRefArgs'] issuer_ref: cert-manager issuerRef.
        :param pulumi.Input[str] duration: Lifetime of automatically-managed certificate.
        :param pulumi.Input['CertManagerPrivateKeyArgs'] private_key: Cert Manager private key.
        :param pulumi.Input[str] renew_before: When to begin renewing automatically-managed certificate.
        :param pulumi.Input['SanForCertArgs'] san: Additional SANs to include in the certificate.
        :param pulumi.Input[str] secret_name: Secret for storing server certificate. Any existing data will be overwritten.
        :param pulumi.Input[str] secret_namespace: Certificate K8S namespace. Omit to use default namespace.
        """
        pulumi.set(__self__, "issuer_ref", issuer_ref)
        if duration is None:
            duration = '720h'
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if renew_before is None:
            renew_before = '240h'
        if renew_before is not None:
            pulumi.set(__self__, "renew_before", renew_before)
        if san is not None:
            pulumi.set(__self__, "san", san)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if secret_namespace is not None:
            pulumi.set(__self__, "secret_namespace", secret_namespace)

    @property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> pulumi.Input['CertManagerIssuerRefArgs']:
        """
        cert-manager issuerRef.
        """
        return pulumi.get(self, "issuer_ref")

    @issuer_ref.setter
    def issuer_ref(self, value: pulumi.Input['CertManagerIssuerRefArgs']):
        pulumi.set(self, "issuer_ref", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        Lifetime of automatically-managed certificate.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input['CertManagerPrivateKeyArgs']]:
        """
        Cert Manager private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input['CertManagerPrivateKeyArgs']]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> Optional[pulumi.Input[str]]:
        """
        When to begin renewing automatically-managed certificate.
        """
        return pulumi.get(self, "renew_before")

    @renew_before.setter
    def renew_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "renew_before", value)

    @property
    @pulumi.getter
    def san(self) -> Optional[pulumi.Input['SanForCertArgs']]:
        """
        Additional SANs to include in the certificate.
        """
        return pulumi.get(self, "san")

    @san.setter
    def san(self, value: Optional[pulumi.Input['SanForCertArgs']]):
        pulumi.set(self, "san", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret for storing server certificate. Any existing data will be overwritten.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter(name="secretNamespace")
    def secret_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate K8S namespace. Omit to use default namespace.
        """
        return pulumi.get(self, "secret_namespace")

    @secret_namespace.setter
    def secret_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_namespace", value)


@pulumi.input_type
class BackendChainArgs:
    def __init__(__self__, *,
                 partitions: pulumi.Input[int],
                 redundancy_factor: pulumi.Input[int],
                 temporary_disk_transfer_enabled: Optional[pulumi.Input[bool]] = None,
                 temporary_disk_transfer_high_watermark_percent: Optional[pulumi.Input[int]] = None,
                 temporary_disk_transfer_low_watermark_percent: Optional[pulumi.Input[int]] = None,
                 temporary_max_backend_mem_usage_percent: Optional[pulumi.Input[int]] = None,
                 temporary_resource_limits: Optional[pulumi.Input['TemporaryResourceLimitsConfigArgs']] = None,
                 workers: Optional[pulumi.Input[int]] = None):
        """
        Desired properties of the Frontend Instances of the DMQTT Broker
        :param pulumi.Input[int] partitions: Partitions is desired number of physical backend chains of the given distributed MQTT broker.
        :param pulumi.Input[int] redundancy_factor: Redundancy Factor is desired numbers of broker instances in one chain.
        :param pulumi.Input[bool] temporary_disk_transfer_enabled: Defines whether disk transfer is enabled or not.
        :param pulumi.Input[int] temporary_disk_transfer_high_watermark_percent: Defines the percentage usage of buffer pool above which disk transfer will start.
        :param pulumi.Input[int] temporary_disk_transfer_low_watermark_percent: Defines the percentage usage of buffer pool below which disk transfer will stop.
        :param pulumi.Input[int] temporary_max_backend_mem_usage_percent: Defines the limits for memory usage percent of the backend instances of the MQTT broker.
        :param pulumi.Input['TemporaryResourceLimitsConfigArgs'] temporary_resource_limits: Defines the limits for resources of the backend instances of the MQTT broker.
        :param pulumi.Input[int] workers: Number of logical backend workers per pod.
        """
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "redundancy_factor", redundancy_factor)
        if temporary_disk_transfer_enabled is not None:
            pulumi.set(__self__, "temporary_disk_transfer_enabled", temporary_disk_transfer_enabled)
        if temporary_disk_transfer_high_watermark_percent is not None:
            pulumi.set(__self__, "temporary_disk_transfer_high_watermark_percent", temporary_disk_transfer_high_watermark_percent)
        if temporary_disk_transfer_low_watermark_percent is not None:
            pulumi.set(__self__, "temporary_disk_transfer_low_watermark_percent", temporary_disk_transfer_low_watermark_percent)
        if temporary_max_backend_mem_usage_percent is not None:
            pulumi.set(__self__, "temporary_max_backend_mem_usage_percent", temporary_max_backend_mem_usage_percent)
        if temporary_resource_limits is not None:
            pulumi.set(__self__, "temporary_resource_limits", temporary_resource_limits)
        if workers is None:
            workers = 1
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter
    def partitions(self) -> pulumi.Input[int]:
        """
        Partitions is desired number of physical backend chains of the given distributed MQTT broker.
        """
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: pulumi.Input[int]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter(name="redundancyFactor")
    def redundancy_factor(self) -> pulumi.Input[int]:
        """
        Redundancy Factor is desired numbers of broker instances in one chain.
        """
        return pulumi.get(self, "redundancy_factor")

    @redundancy_factor.setter
    def redundancy_factor(self, value: pulumi.Input[int]):
        pulumi.set(self, "redundancy_factor", value)

    @property
    @pulumi.getter(name="temporaryDiskTransferEnabled")
    def temporary_disk_transfer_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether disk transfer is enabled or not.
        """
        return pulumi.get(self, "temporary_disk_transfer_enabled")

    @temporary_disk_transfer_enabled.setter
    def temporary_disk_transfer_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "temporary_disk_transfer_enabled", value)

    @property
    @pulumi.getter(name="temporaryDiskTransferHighWatermarkPercent")
    def temporary_disk_transfer_high_watermark_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the percentage usage of buffer pool above which disk transfer will start.
        """
        return pulumi.get(self, "temporary_disk_transfer_high_watermark_percent")

    @temporary_disk_transfer_high_watermark_percent.setter
    def temporary_disk_transfer_high_watermark_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "temporary_disk_transfer_high_watermark_percent", value)

    @property
    @pulumi.getter(name="temporaryDiskTransferLowWatermarkPercent")
    def temporary_disk_transfer_low_watermark_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the percentage usage of buffer pool below which disk transfer will stop.
        """
        return pulumi.get(self, "temporary_disk_transfer_low_watermark_percent")

    @temporary_disk_transfer_low_watermark_percent.setter
    def temporary_disk_transfer_low_watermark_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "temporary_disk_transfer_low_watermark_percent", value)

    @property
    @pulumi.getter(name="temporaryMaxBackendMemUsagePercent")
    def temporary_max_backend_mem_usage_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the limits for memory usage percent of the backend instances of the MQTT broker.
        """
        return pulumi.get(self, "temporary_max_backend_mem_usage_percent")

    @temporary_max_backend_mem_usage_percent.setter
    def temporary_max_backend_mem_usage_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "temporary_max_backend_mem_usage_percent", value)

    @property
    @pulumi.getter(name="temporaryResourceLimits")
    def temporary_resource_limits(self) -> Optional[pulumi.Input['TemporaryResourceLimitsConfigArgs']]:
        """
        Defines the limits for resources of the backend instances of the MQTT broker.
        """
        return pulumi.get(self, "temporary_resource_limits")

    @temporary_resource_limits.setter
    def temporary_resource_limits(self, value: Optional[pulumi.Input['TemporaryResourceLimitsConfigArgs']]):
        pulumi.set(self, "temporary_resource_limits", value)

    @property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input[int]]:
        """
        Number of logical backend workers per pod.
        """
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "workers", value)


@pulumi.input_type
class BrokerAuthenticatorCustomAuthX509Args:
    def __init__(__self__, *,
                 key_vault: Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        X509 Custom Authentication properties. NOTE - Enum only authenticator type supported at a time.
        :param pulumi.Input['KeyVaultCertificatePropertiesArgs'] key_vault: Keyvault X509 secret properties.
        :param pulumi.Input[str] secret_name: Secret where cert details are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']]:
        """
        Keyvault X509 secret properties.
        """
        return pulumi.get(self, "key_vault")

    @key_vault.setter
    def key_vault(self, value: Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']]):
        pulumi.set(self, "key_vault", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret where cert details are stored.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class BrokerAuthenticatorCustomAuthArgs:
    def __init__(__self__, *,
                 x509: pulumi.Input['BrokerAuthenticatorCustomAuthX509Args']):
        """
        Custom Authentication properties
        :param pulumi.Input['BrokerAuthenticatorCustomAuthX509Args'] x509: X509 Custom Auth type details.
        """
        pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def x509(self) -> pulumi.Input['BrokerAuthenticatorCustomAuthX509Args']:
        """
        X509 Custom Auth type details.
        """
        return pulumi.get(self, "x509")

    @x509.setter
    def x509(self, value: pulumi.Input['BrokerAuthenticatorCustomAuthX509Args']):
        pulumi.set(self, "x509", value)


@pulumi.input_type
class BrokerAuthenticatorMethodCustomArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 auth: Optional[pulumi.Input['BrokerAuthenticatorCustomAuthArgs']] = None,
                 ca_cert_config_map: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Custom method for BrokerAuthentication
        :param pulumi.Input[str] endpoint: Endpoint to connect to.
        :param pulumi.Input['BrokerAuthenticatorCustomAuthArgs'] auth: Custom Broker Authentication Method.
        :param pulumi.Input[str] ca_cert_config_map: CA cert config map to use.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: Configuration Headers to use.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if ca_cert_config_map is not None:
            pulumi.set(__self__, "ca_cert_config_map", ca_cert_config_map)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Endpoint to connect to.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['BrokerAuthenticatorCustomAuthArgs']]:
        """
        Custom Broker Authentication Method.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['BrokerAuthenticatorCustomAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="caCertConfigMap")
    def ca_cert_config_map(self) -> Optional[pulumi.Input[str]]:
        """
        CA cert config map to use.
        """
        return pulumi.get(self, "ca_cert_config_map")

    @ca_cert_config_map.setter
    def ca_cert_config_map(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert_config_map", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Configuration Headers to use.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)


@pulumi.input_type
class BrokerAuthenticatorMethodSatArgs:
    def __init__(__self__, *,
                 audiences: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Service Account Token for BrokerAuthentication
        :param pulumi.Input[Sequence[pulumi.Input[str]]] audiences: List of allowed audience.
        """
        pulumi.set(__self__, "audiences", audiences)

    @property
    @pulumi.getter
    def audiences(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of allowed audience.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "audiences", value)


@pulumi.input_type
class BrokerAuthenticatorMethodSvidArgs:
    def __init__(__self__, *,
                 agent_socket_path: pulumi.Input[str],
                 identity_max_retry: Optional[pulumi.Input[float]] = None,
                 identity_wait_retry_ms: Optional[pulumi.Input[float]] = None):
        """
        SVID for BrokerAuthentication
        :param pulumi.Input[str] agent_socket_path: Mounted socket path for spiffe agent.
        :param pulumi.Input[float] identity_max_retry: Maximum number of re-tries to fetch identity.
        :param pulumi.Input[float] identity_wait_retry_ms: Maximum time to wait before fetching identity again.
        """
        pulumi.set(__self__, "agent_socket_path", agent_socket_path)
        if identity_max_retry is None:
            identity_max_retry = 3
        if identity_max_retry is not None:
            pulumi.set(__self__, "identity_max_retry", identity_max_retry)
        if identity_wait_retry_ms is None:
            identity_wait_retry_ms = 5000
        if identity_wait_retry_ms is not None:
            pulumi.set(__self__, "identity_wait_retry_ms", identity_wait_retry_ms)

    @property
    @pulumi.getter(name="agentSocketPath")
    def agent_socket_path(self) -> pulumi.Input[str]:
        """
        Mounted socket path for spiffe agent.
        """
        return pulumi.get(self, "agent_socket_path")

    @agent_socket_path.setter
    def agent_socket_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "agent_socket_path", value)

    @property
    @pulumi.getter(name="identityMaxRetry")
    def identity_max_retry(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of re-tries to fetch identity.
        """
        return pulumi.get(self, "identity_max_retry")

    @identity_max_retry.setter
    def identity_max_retry(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "identity_max_retry", value)

    @property
    @pulumi.getter(name="identityWaitRetryMs")
    def identity_wait_retry_ms(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum time to wait before fetching identity again.
        """
        return pulumi.get(self, "identity_wait_retry_ms")

    @identity_wait_retry_ms.setter
    def identity_wait_retry_ms(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "identity_wait_retry_ms", value)


@pulumi.input_type
class BrokerAuthenticatorMethodUsernamePasswordArgs:
    def __init__(__self__, *,
                 key_vault: Optional[pulumi.Input['KeyVaultSecretPropertiesArgs']] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        UsernamePassword for BrokerAuthentication
        :param pulumi.Input['KeyVaultSecretPropertiesArgs'] key_vault: Keyvault username password secret properties.
        :param pulumi.Input[str] secret_name: Secret where username and password are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional[pulumi.Input['KeyVaultSecretPropertiesArgs']]:
        """
        Keyvault username password secret properties.
        """
        return pulumi.get(self, "key_vault")

    @key_vault.setter
    def key_vault(self, value: Optional[pulumi.Input['KeyVaultSecretPropertiesArgs']]):
        pulumi.set(self, "key_vault", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret where username and password are stored.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class BrokerAuthenticatorMethodX509AttributesArgs:
    def __init__(__self__, *,
                 key_vault: Optional[pulumi.Input['KeyVaultSecretPropertiesArgs']] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        BrokerAuthenticatorMethodX509Attributes properties. NOTE - Enum only type supported at a time.
        :param pulumi.Input['KeyVaultSecretPropertiesArgs'] key_vault: Keyvault x509 attributes secret properties.
        :param pulumi.Input[str] secret_name: Secret where x509 attributes are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional[pulumi.Input['KeyVaultSecretPropertiesArgs']]:
        """
        Keyvault x509 attributes secret properties.
        """
        return pulumi.get(self, "key_vault")

    @key_vault.setter
    def key_vault(self, value: Optional[pulumi.Input['KeyVaultSecretPropertiesArgs']]):
        pulumi.set(self, "key_vault", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret where x509 attributes are stored.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class BrokerAuthenticatorMethodX509Args:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']] = None,
                 trusted_client_ca_cert_config_map: Optional[pulumi.Input[str]] = None):
        """
        X509 for BrokerAuthentication.
        :param pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs'] attributes: K8S Secret name to mount for username and password.
        :param pulumi.Input[str] trusted_client_ca_cert_config_map: Trusted client ca cert config map.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if trusted_client_ca_cert_config_map is None:
            trusted_client_ca_cert_config_map = 'client-ca'
        if trusted_client_ca_cert_config_map is not None:
            pulumi.set(__self__, "trusted_client_ca_cert_config_map", trusted_client_ca_cert_config_map)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]:
        """
        K8S Secret name to mount for username and password.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="trustedClientCaCertConfigMap")
    def trusted_client_ca_cert_config_map(self) -> Optional[pulumi.Input[str]]:
        """
        Trusted client ca cert config map.
        """
        return pulumi.get(self, "trusted_client_ca_cert_config_map")

    @trusted_client_ca_cert_config_map.setter
    def trusted_client_ca_cert_config_map(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_client_ca_cert_config_map", value)


@pulumi.input_type
class BrokerAuthenticatorMethodsArgs:
    def __init__(__self__, *,
                 custom: Optional[pulumi.Input['BrokerAuthenticatorMethodCustomArgs']] = None,
                 sat: Optional[pulumi.Input['BrokerAuthenticatorMethodSatArgs']] = None,
                 svid: Optional[pulumi.Input['BrokerAuthenticatorMethodSvidArgs']] = None,
                 username_password: Optional[pulumi.Input['BrokerAuthenticatorMethodUsernamePasswordArgs']] = None,
                 x509: Optional[pulumi.Input['BrokerAuthenticatorMethodX509Args']] = None):
        """
        Collection of different CrdAuthenticator methods of Broker Resource. NOTE Enum - Only one method is supported for each entry.
        :param pulumi.Input['BrokerAuthenticatorMethodCustomArgs'] custom: Custom Authentication Method.
        :param pulumi.Input['BrokerAuthenticatorMethodSatArgs'] sat: Service Account Token Method.
        :param pulumi.Input['BrokerAuthenticatorMethodSvidArgs'] svid: Service Account Token Method.
        :param pulumi.Input['BrokerAuthenticatorMethodUsernamePasswordArgs'] username_password: UsernamePassword Method.
        :param pulumi.Input['BrokerAuthenticatorMethodX509Args'] x509: X509 Method.
        """
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if sat is not None:
            pulumi.set(__self__, "sat", sat)
        if svid is not None:
            pulumi.set(__self__, "svid", svid)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)
        if x509 is not None:
            pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodCustomArgs']]:
        """
        Custom Authentication Method.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodCustomArgs']]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter
    def sat(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodSatArgs']]:
        """
        Service Account Token Method.
        """
        return pulumi.get(self, "sat")

    @sat.setter
    def sat(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodSatArgs']]):
        pulumi.set(self, "sat", value)

    @property
    @pulumi.getter
    def svid(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodSvidArgs']]:
        """
        Service Account Token Method.
        """
        return pulumi.get(self, "svid")

    @svid.setter
    def svid(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodSvidArgs']]):
        pulumi.set(self, "svid", value)

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodUsernamePasswordArgs']]:
        """
        UsernamePassword Method.
        """
        return pulumi.get(self, "username_password")

    @username_password.setter
    def username_password(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodUsernamePasswordArgs']]):
        pulumi.set(self, "username_password", value)

    @property
    @pulumi.getter
    def x509(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodX509Args']]:
        """
        X509 Method.
        """
        return pulumi.get(self, "x509")

    @x509.setter
    def x509(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodX509Args']]):
        pulumi.set(self, "x509", value)


@pulumi.input_type
class BrokerDiagnosticsArgs:
    def __init__(__self__, *,
                 diagnostic_service_endpoint: Optional[pulumi.Input[str]] = None,
                 enable_metrics: Optional[pulumi.Input[bool]] = None,
                 enable_self_check: Optional[pulumi.Input[bool]] = None,
                 enable_self_tracing: Optional[pulumi.Input[bool]] = None,
                 enable_tracing: Optional[pulumi.Input[bool]] = None,
                 log_format: Optional[pulumi.Input[str]] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 max_cell_map_lifetime: Optional[pulumi.Input[float]] = None,
                 metric_update_frequency_seconds: Optional[pulumi.Input[float]] = None,
                 probe_image: Optional[pulumi.Input[str]] = None,
                 self_check_frequency_seconds: Optional[pulumi.Input[float]] = None,
                 self_check_timeout_seconds: Optional[pulumi.Input[float]] = None,
                 self_trace_frequency_seconds: Optional[pulumi.Input[float]] = None,
                 span_channel_capacity: Optional[pulumi.Input[float]] = None):
        """
        Diagnostics setting specific to Broker
        :param pulumi.Input[str] diagnostic_service_endpoint: Diagnostic Service endpoint
        :param pulumi.Input[bool] enable_metrics: Knob to enable/disable metrics. Default = true
        :param pulumi.Input[bool] enable_self_check: Enable self check on Broker via Probe.
        :param pulumi.Input[bool] enable_self_tracing: Enable self tracing on the Broker so that every selfCheckFrequencySeconds a random message is traced even if it didn't have trace context.
        :param pulumi.Input[bool] enable_tracing: Knob to enable/disable entire tracing infrastructure.
        :param pulumi.Input[str] log_format: Format for the logs generated.
        :param pulumi.Input[str] log_level: Log level for the Broker.
        :param pulumi.Input[float] max_cell_map_lifetime: Maximum time for the CellMap to live.
        :param pulumi.Input[float] metric_update_frequency_seconds: Metric update frequency in seconds.
        :param pulumi.Input[str] probe_image: Probe Image to run.
        :param pulumi.Input[float] self_check_frequency_seconds: Frequency for the self check to run.
        :param pulumi.Input[float] self_check_timeout_seconds: Time out period of the self check.
        :param pulumi.Input[float] self_trace_frequency_seconds: The frequency at which selfTrace should run.
        :param pulumi.Input[float] span_channel_capacity: The number of the spans generated by the Tracing.
        """
        if diagnostic_service_endpoint is not None:
            pulumi.set(__self__, "diagnostic_service_endpoint", diagnostic_service_endpoint)
        if enable_metrics is None:
            enable_metrics = True
        if enable_metrics is not None:
            pulumi.set(__self__, "enable_metrics", enable_metrics)
        if enable_self_check is None:
            enable_self_check = True
        if enable_self_check is not None:
            pulumi.set(__self__, "enable_self_check", enable_self_check)
        if enable_self_tracing is None:
            enable_self_tracing = True
        if enable_self_tracing is not None:
            pulumi.set(__self__, "enable_self_tracing", enable_self_tracing)
        if enable_tracing is None:
            enable_tracing = True
        if enable_tracing is not None:
            pulumi.set(__self__, "enable_tracing", enable_tracing)
        if log_format is None:
            log_format = 'text'
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_level is None:
            log_level = 'info,hyper=off,kube_client=off,tower=off,conhash=off,h2=off'
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if max_cell_map_lifetime is None:
            max_cell_map_lifetime = 60
        if max_cell_map_lifetime is not None:
            pulumi.set(__self__, "max_cell_map_lifetime", max_cell_map_lifetime)
        if metric_update_frequency_seconds is None:
            metric_update_frequency_seconds = 30
        if metric_update_frequency_seconds is not None:
            pulumi.set(__self__, "metric_update_frequency_seconds", metric_update_frequency_seconds)
        if probe_image is None:
            probe_image = 'sample.azurecr.io/diagnostics-probe:0.5.0'
        if probe_image is not None:
            pulumi.set(__self__, "probe_image", probe_image)
        if self_check_frequency_seconds is None:
            self_check_frequency_seconds = 30
        if self_check_frequency_seconds is not None:
            pulumi.set(__self__, "self_check_frequency_seconds", self_check_frequency_seconds)
        if self_check_timeout_seconds is None:
            self_check_timeout_seconds = 15
        if self_check_timeout_seconds is not None:
            pulumi.set(__self__, "self_check_timeout_seconds", self_check_timeout_seconds)
        if self_trace_frequency_seconds is None:
            self_trace_frequency_seconds = 30
        if self_trace_frequency_seconds is not None:
            pulumi.set(__self__, "self_trace_frequency_seconds", self_trace_frequency_seconds)
        if span_channel_capacity is None:
            span_channel_capacity = 1000
        if span_channel_capacity is not None:
            pulumi.set(__self__, "span_channel_capacity", span_channel_capacity)

    @property
    @pulumi.getter(name="diagnosticServiceEndpoint")
    def diagnostic_service_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Diagnostic Service endpoint
        """
        return pulumi.get(self, "diagnostic_service_endpoint")

    @diagnostic_service_endpoint.setter
    def diagnostic_service_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "diagnostic_service_endpoint", value)

    @property
    @pulumi.getter(name="enableMetrics")
    def enable_metrics(self) -> Optional[pulumi.Input[bool]]:
        """
        Knob to enable/disable metrics. Default = true
        """
        return pulumi.get(self, "enable_metrics")

    @enable_metrics.setter
    def enable_metrics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_metrics", value)

    @property
    @pulumi.getter(name="enableSelfCheck")
    def enable_self_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable self check on Broker via Probe.
        """
        return pulumi.get(self, "enable_self_check")

    @enable_self_check.setter
    def enable_self_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_self_check", value)

    @property
    @pulumi.getter(name="enableSelfTracing")
    def enable_self_tracing(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable self tracing on the Broker so that every selfCheckFrequencySeconds a random message is traced even if it didn't have trace context.
        """
        return pulumi.get(self, "enable_self_tracing")

    @enable_self_tracing.setter
    def enable_self_tracing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_self_tracing", value)

    @property
    @pulumi.getter(name="enableTracing")
    def enable_tracing(self) -> Optional[pulumi.Input[bool]]:
        """
        Knob to enable/disable entire tracing infrastructure.
        """
        return pulumi.get(self, "enable_tracing")

    @enable_tracing.setter
    def enable_tracing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_tracing", value)

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[pulumi.Input[str]]:
        """
        Format for the logs generated.
        """
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_format", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        Log level for the Broker.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="maxCellMapLifetime")
    def max_cell_map_lifetime(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum time for the CellMap to live.
        """
        return pulumi.get(self, "max_cell_map_lifetime")

    @max_cell_map_lifetime.setter
    def max_cell_map_lifetime(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_cell_map_lifetime", value)

    @property
    @pulumi.getter(name="metricUpdateFrequencySeconds")
    def metric_update_frequency_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Metric update frequency in seconds.
        """
        return pulumi.get(self, "metric_update_frequency_seconds")

    @metric_update_frequency_seconds.setter
    def metric_update_frequency_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "metric_update_frequency_seconds", value)

    @property
    @pulumi.getter(name="probeImage")
    def probe_image(self) -> Optional[pulumi.Input[str]]:
        """
        Probe Image to run.
        """
        return pulumi.get(self, "probe_image")

    @probe_image.setter
    def probe_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probe_image", value)

    @property
    @pulumi.getter(name="selfCheckFrequencySeconds")
    def self_check_frequency_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Frequency for the self check to run.
        """
        return pulumi.get(self, "self_check_frequency_seconds")

    @self_check_frequency_seconds.setter
    def self_check_frequency_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "self_check_frequency_seconds", value)

    @property
    @pulumi.getter(name="selfCheckTimeoutSeconds")
    def self_check_timeout_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Time out period of the self check.
        """
        return pulumi.get(self, "self_check_timeout_seconds")

    @self_check_timeout_seconds.setter
    def self_check_timeout_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "self_check_timeout_seconds", value)

    @property
    @pulumi.getter(name="selfTraceFrequencySeconds")
    def self_trace_frequency_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        The frequency at which selfTrace should run.
        """
        return pulumi.get(self, "self_trace_frequency_seconds")

    @self_trace_frequency_seconds.setter
    def self_trace_frequency_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "self_trace_frequency_seconds", value)

    @property
    @pulumi.getter(name="spanChannelCapacity")
    def span_channel_capacity(self) -> Optional[pulumi.Input[float]]:
        """
        The number of the spans generated by the Tracing.
        """
        return pulumi.get(self, "span_channel_capacity")

    @span_channel_capacity.setter
    def span_channel_capacity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "span_channel_capacity", value)


@pulumi.input_type
class CardinalityArgs:
    def __init__(__self__, *,
                 backend_chain: pulumi.Input['BackendChainArgs'],
                 frontend: pulumi.Input['FrontendArgs']):
        """
        Cardinality properties
        :param pulumi.Input['BackendChainArgs'] backend_chain: The backend broker desired properties
        :param pulumi.Input['FrontendArgs'] frontend: The frontend broker desired properties
        """
        pulumi.set(__self__, "backend_chain", backend_chain)
        pulumi.set(__self__, "frontend", frontend)

    @property
    @pulumi.getter(name="backendChain")
    def backend_chain(self) -> pulumi.Input['BackendChainArgs']:
        """
        The backend broker desired properties
        """
        return pulumi.get(self, "backend_chain")

    @backend_chain.setter
    def backend_chain(self, value: pulumi.Input['BackendChainArgs']):
        pulumi.set(self, "backend_chain", value)

    @property
    @pulumi.getter
    def frontend(self) -> pulumi.Input['FrontendArgs']:
        """
        The frontend broker desired properties
        """
        return pulumi.get(self, "frontend")

    @frontend.setter
    def frontend(self, value: pulumi.Input['FrontendArgs']):
        pulumi.set(self, "frontend", value)


@pulumi.input_type
class CertManagerCertOptionsArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[str]] = None,
                 private_key: pulumi.Input['CertManagerPrivateKeyArgs'],
                 renew_before: Optional[pulumi.Input[str]] = None):
        """
        Cert Manager CA Cert properties
        :param pulumi.Input[str] duration: Duration of CA cert.
        :param pulumi.Input['CertManagerPrivateKeyArgs'] private_key: Cert Manager private key.
        :param pulumi.Input[str] renew_before: Renew before time of CA cert.
        """
        if duration is None:
            duration = '720h'
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "private_key", private_key)
        if renew_before is None:
            renew_before = '240h'
        pulumi.set(__self__, "renew_before", renew_before)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        Duration of CA cert.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input['CertManagerPrivateKeyArgs']:
        """
        Cert Manager private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input['CertManagerPrivateKeyArgs']):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> pulumi.Input[str]:
        """
        Renew before time of CA cert.
        """
        return pulumi.get(self, "renew_before")

    @renew_before.setter
    def renew_before(self, value: pulumi.Input[str]):
        pulumi.set(self, "renew_before", value)


@pulumi.input_type
class CertManagerIssuerRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 kind: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        Cert-Manager issuerRef properties
        :param pulumi.Input[str] group: group of issuer.
        :param pulumi.Input[str] kind: kind of issuer (Issuer or ClusterIssuer).
        :param pulumi.Input[str] name: name of issuer.
        """
        if group is None:
            group = 'cert-manager.io'
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> pulumi.Input[str]:
        """
        group of issuer.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: pulumi.Input[str]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        kind of issuer (Issuer or ClusterIssuer).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        name of issuer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CertManagerPrivateKeyArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 rotation_policy: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None):
        """
        Cert Manager private key properties
        :param pulumi.Input[str] algorithm: algorithm for private key.
        :param pulumi.Input[str] rotation_policy: cert-manager rotationPolicy.
        :param pulumi.Input[int] size: size of private key.
        """
        if algorithm is None:
            algorithm = 'ECDSA'
        pulumi.set(__self__, "algorithm", algorithm)
        if rotation_policy is None:
            rotation_policy = 'Always'
        pulumi.set(__self__, "rotation_policy", rotation_policy)
        if size is None:
            size = 256
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[str]:
        """
        algorithm for private key.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="rotationPolicy")
    def rotation_policy(self) -> pulumi.Input[str]:
        """
        cert-manager rotationPolicy.
        """
        return pulumi.get(self, "rotation_policy")

    @rotation_policy.setter
    def rotation_policy(self, value: pulumi.Input[str]):
        pulumi.set(self, "rotation_policy", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        size of private key.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)


@pulumi.input_type
class ContainerImageArgs:
    def __init__(__self__, *,
                 repository: pulumi.Input[str],
                 tag: pulumi.Input[str],
                 pull_policy: Optional[pulumi.Input[str]] = None,
                 pull_secrets: Optional[pulumi.Input[str]] = None):
        """
        Defines the Docker image details
        :param pulumi.Input[str] repository: The Docker image name.
        :param pulumi.Input[str] tag: The Docker  image tag.
        :param pulumi.Input[str] pull_policy: Image pull policy.
        :param pulumi.Input[str] pull_secrets: Image pull secrets.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "tag", tag)
        if pull_policy is not None:
            pulumi.set(__self__, "pull_policy", pull_policy)
        if pull_secrets is not None:
            pulumi.set(__self__, "pull_secrets", pull_secrets)

    @property
    @pulumi.getter
    def repository(self) -> pulumi.Input[str]:
        """
        The Docker image name.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        """
        The Docker  image tag.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter(name="pullPolicy")
    def pull_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Image pull policy.
        """
        return pulumi.get(self, "pull_policy")

    @pull_policy.setter
    def pull_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pull_policy", value)

    @property
    @pulumi.getter(name="pullSecrets")
    def pull_secrets(self) -> Optional[pulumi.Input[str]]:
        """
        Image pull secrets.
        """
        return pulumi.get(self, "pull_secrets")

    @pull_secrets.setter
    def pull_secrets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pull_secrets", value)


@pulumi.input_type
class DataLakeConnectorMapArgs:
    def __init__(__self__, *,
                 allowed_latency_secs: pulumi.Input[int],
                 client_id: pulumi.Input[str],
                 max_messages_per_batch: pulumi.Input[float],
                 message_payload_type: pulumi.Input[str],
                 mqtt_source_topic: pulumi.Input[str],
                 table: pulumi.Input['DeltaTableArgs'],
                 qos: Optional[pulumi.Input[int]] = None):
        """
        DataLake connector map route properties
        :param pulumi.Input[int] allowed_latency_secs: Allowed latency for transferring data.
        :param pulumi.Input[str] client_id: Client Id to use.
        :param pulumi.Input[float] max_messages_per_batch: Maximum messages to send per Batch.
        :param pulumi.Input[str] message_payload_type: Message payload type.
        :param pulumi.Input[str] mqtt_source_topic: Mqtt source topic.
        :param pulumi.Input['DeltaTableArgs'] table: Delta table properties to use.
        :param pulumi.Input[int] qos: Quality of Service.
        """
        pulumi.set(__self__, "allowed_latency_secs", allowed_latency_secs)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "max_messages_per_batch", max_messages_per_batch)
        pulumi.set(__self__, "message_payload_type", message_payload_type)
        pulumi.set(__self__, "mqtt_source_topic", mqtt_source_topic)
        pulumi.set(__self__, "table", table)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @property
    @pulumi.getter(name="allowedLatencySecs")
    def allowed_latency_secs(self) -> pulumi.Input[int]:
        """
        Allowed latency for transferring data.
        """
        return pulumi.get(self, "allowed_latency_secs")

    @allowed_latency_secs.setter
    def allowed_latency_secs(self, value: pulumi.Input[int]):
        pulumi.set(self, "allowed_latency_secs", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client Id to use.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="maxMessagesPerBatch")
    def max_messages_per_batch(self) -> pulumi.Input[float]:
        """
        Maximum messages to send per Batch.
        """
        return pulumi.get(self, "max_messages_per_batch")

    @max_messages_per_batch.setter
    def max_messages_per_batch(self, value: pulumi.Input[float]):
        pulumi.set(self, "max_messages_per_batch", value)

    @property
    @pulumi.getter(name="messagePayloadType")
    def message_payload_type(self) -> pulumi.Input[str]:
        """
        Message payload type.
        """
        return pulumi.get(self, "message_payload_type")

    @message_payload_type.setter
    def message_payload_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "message_payload_type", value)

    @property
    @pulumi.getter(name="mqttSourceTopic")
    def mqtt_source_topic(self) -> pulumi.Input[str]:
        """
        Mqtt source topic.
        """
        return pulumi.get(self, "mqtt_source_topic")

    @mqtt_source_topic.setter
    def mqtt_source_topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "mqtt_source_topic", value)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input['DeltaTableArgs']:
        """
        Delta table properties to use.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input['DeltaTableArgs']):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[int]]:
        """
        Quality of Service.
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qos", value)


@pulumi.input_type
class DataLakeFabricStorageAuthenticationArgs:
    def __init__(__self__, *,
                 system_assigned_managed_identity: pulumi.Input['ManagedIdentityAuthenticationArgs']):
        """
        DataLake Fabric Storage authentication details.
        :param pulumi.Input['ManagedIdentityAuthenticationArgs'] system_assigned_managed_identity: Configuration for managed identity authentication.
        """
        pulumi.set(__self__, "system_assigned_managed_identity", system_assigned_managed_identity)

    @property
    @pulumi.getter(name="systemAssignedManagedIdentity")
    def system_assigned_managed_identity(self) -> pulumi.Input['ManagedIdentityAuthenticationArgs']:
        """
        Configuration for managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity")

    @system_assigned_managed_identity.setter
    def system_assigned_managed_identity(self, value: pulumi.Input['ManagedIdentityAuthenticationArgs']):
        pulumi.set(self, "system_assigned_managed_identity", value)


@pulumi.input_type
class DataLakeFabricStorageArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['DataLakeFabricStorageAuthenticationArgs'],
                 endpoint: pulumi.Input[str],
                 fabric_path: pulumi.Input[Union[str, 'FabricPathType']],
                 guids: Optional[pulumi.Input['FabricGuidsArgs']] = None,
                 names: Optional[pulumi.Input['FabricNamesArgs']] = None):
        """
        DataLake Fabric Storage details.
        :param pulumi.Input['DataLakeFabricStorageAuthenticationArgs'] authentication: DataLake fabric storage authentication details.
        :param pulumi.Input[str] endpoint: DataLake fabric storage endpoint to use.
        :param pulumi.Input[Union[str, 'FabricPathType']] fabric_path: Fabric path type to use.
        :param pulumi.Input['FabricGuidsArgs'] guids: Fabric one lake Guids.
        :param pulumi.Input['FabricNamesArgs'] names: Fabric one lake Names.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "fabric_path", fabric_path)
        if guids is not None:
            pulumi.set(__self__, "guids", guids)
        if names is not None:
            pulumi.set(__self__, "names", names)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['DataLakeFabricStorageAuthenticationArgs']:
        """
        DataLake fabric storage authentication details.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['DataLakeFabricStorageAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        DataLake fabric storage endpoint to use.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="fabricPath")
    def fabric_path(self) -> pulumi.Input[Union[str, 'FabricPathType']]:
        """
        Fabric path type to use.
        """
        return pulumi.get(self, "fabric_path")

    @fabric_path.setter
    def fabric_path(self, value: pulumi.Input[Union[str, 'FabricPathType']]):
        pulumi.set(self, "fabric_path", value)

    @property
    @pulumi.getter
    def guids(self) -> Optional[pulumi.Input['FabricGuidsArgs']]:
        """
        Fabric one lake Guids.
        """
        return pulumi.get(self, "guids")

    @guids.setter
    def guids(self, value: Optional[pulumi.Input['FabricGuidsArgs']]):
        pulumi.set(self, "guids", value)

    @property
    @pulumi.getter
    def names(self) -> Optional[pulumi.Input['FabricNamesArgs']]:
        """
        Fabric one lake Names.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: Optional[pulumi.Input['FabricNamesArgs']]):
        pulumi.set(self, "names", value)


@pulumi.input_type
class DataLakeLocalStorageArgs:
    def __init__(__self__, *,
                 volume_name: pulumi.Input[str]):
        """
        DataLake Local Storage details.
        :param pulumi.Input[str] volume_name: Volume name to write to.
        """
        pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> pulumi.Input[str]:
        """
        Volume name to write to.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_name", value)


@pulumi.input_type
class DataLakeServiceStorageAuthenticationArgs:
    def __init__(__self__, *,
                 access_token_secret_name: Optional[pulumi.Input[str]] = None,
                 system_assigned_managed_identity: Optional[pulumi.Input['ManagedIdentityAuthenticationArgs']] = None):
        """
        DataLake Service Storage authentication details. NOTE - Enum only one method is supported.
        :param pulumi.Input[str] access_token_secret_name: Access token secret name.
        :param pulumi.Input['ManagedIdentityAuthenticationArgs'] system_assigned_managed_identity: Configuration for managed identity authentication.
        """
        if access_token_secret_name is not None:
            pulumi.set(__self__, "access_token_secret_name", access_token_secret_name)
        if system_assigned_managed_identity is not None:
            pulumi.set(__self__, "system_assigned_managed_identity", system_assigned_managed_identity)

    @property
    @pulumi.getter(name="accessTokenSecretName")
    def access_token_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Access token secret name.
        """
        return pulumi.get(self, "access_token_secret_name")

    @access_token_secret_name.setter
    def access_token_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_secret_name", value)

    @property
    @pulumi.getter(name="systemAssignedManagedIdentity")
    def system_assigned_managed_identity(self) -> Optional[pulumi.Input['ManagedIdentityAuthenticationArgs']]:
        """
        Configuration for managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity")

    @system_assigned_managed_identity.setter
    def system_assigned_managed_identity(self, value: Optional[pulumi.Input['ManagedIdentityAuthenticationArgs']]):
        pulumi.set(self, "system_assigned_managed_identity", value)


@pulumi.input_type
class DataLakeServiceStorageArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['DataLakeServiceStorageAuthenticationArgs'],
                 endpoint: pulumi.Input[str]):
        """
        DataLake Service Storage details.
        :param pulumi.Input['DataLakeServiceStorageAuthenticationArgs'] authentication: DataLake service storage authentication details. NOTE - Enum only one method is supported.
        :param pulumi.Input[str] endpoint: DataLake service storage endpoint to use.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['DataLakeServiceStorageAuthenticationArgs']:
        """
        DataLake service storage authentication details. NOTE - Enum only one method is supported.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['DataLakeServiceStorageAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        DataLake service storage endpoint to use.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)


@pulumi.input_type
class DataLakeTargetStorageArgs:
    def __init__(__self__, *,
                 datalake_storage: Optional[pulumi.Input['DataLakeServiceStorageArgs']] = None,
                 fabric_one_lake: Optional[pulumi.Input['DataLakeFabricStorageArgs']] = None,
                 local_storage: Optional[pulumi.Input['DataLakeLocalStorageArgs']] = None):
        """
        Target storage for the DataLake. NOTE - Enum only storage is supported at a time.
        :param pulumi.Input['DataLakeServiceStorageArgs'] datalake_storage: DataLake service storage details.
        :param pulumi.Input['DataLakeFabricStorageArgs'] fabric_one_lake: Fabric one lake storage details.
        :param pulumi.Input['DataLakeLocalStorageArgs'] local_storage: Local storage details.
        """
        if datalake_storage is not None:
            pulumi.set(__self__, "datalake_storage", datalake_storage)
        if fabric_one_lake is not None:
            pulumi.set(__self__, "fabric_one_lake", fabric_one_lake)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)

    @property
    @pulumi.getter(name="datalakeStorage")
    def datalake_storage(self) -> Optional[pulumi.Input['DataLakeServiceStorageArgs']]:
        """
        DataLake service storage details.
        """
        return pulumi.get(self, "datalake_storage")

    @datalake_storage.setter
    def datalake_storage(self, value: Optional[pulumi.Input['DataLakeServiceStorageArgs']]):
        pulumi.set(self, "datalake_storage", value)

    @property
    @pulumi.getter(name="fabricOneLake")
    def fabric_one_lake(self) -> Optional[pulumi.Input['DataLakeFabricStorageArgs']]:
        """
        Fabric one lake storage details.
        """
        return pulumi.get(self, "fabric_one_lake")

    @fabric_one_lake.setter
    def fabric_one_lake(self, value: Optional[pulumi.Input['DataLakeFabricStorageArgs']]):
        pulumi.set(self, "fabric_one_lake", value)

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[pulumi.Input['DataLakeLocalStorageArgs']]:
        """
        Local storage details.
        """
        return pulumi.get(self, "local_storage")

    @local_storage.setter
    def local_storage(self, value: Optional[pulumi.Input['DataLakeLocalStorageArgs']]):
        pulumi.set(self, "local_storage", value)


@pulumi.input_type
class DeltaTableSchemaArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[Union[str, 'DeltaTableFormatEnum']],
                 mapping: pulumi.Input[str],
                 name: pulumi.Input[str],
                 optional: pulumi.Input[bool]):
        """
        Delta table schema properties
        :param pulumi.Input[Union[str, 'DeltaTableFormatEnum']] format: Delta table format supported.
        :param pulumi.Input[str] mapping: Delta table schema mapping.
        :param pulumi.Input[str] name: Delta table schema name.
        :param pulumi.Input[bool] optional: Delta table schema optional.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "mapping", mapping)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[Union[str, 'DeltaTableFormatEnum']]:
        """
        Delta table format supported.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[Union[str, 'DeltaTableFormatEnum']]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def mapping(self) -> pulumi.Input[str]:
        """
        Delta table schema mapping.
        """
        return pulumi.get(self, "mapping")

    @mapping.setter
    def mapping(self, value: pulumi.Input[str]):
        pulumi.set(self, "mapping", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Delta table schema name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> pulumi.Input[bool]:
        """
        Delta table schema optional.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: pulumi.Input[bool]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class DeltaTableArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[Sequence[pulumi.Input['DeltaTableSchemaArgs']]],
                 table_name: pulumi.Input[str],
                 table_path: Optional[pulumi.Input[str]] = None):
        """
        Delta table properties
        :param pulumi.Input[Sequence[pulumi.Input['DeltaTableSchemaArgs']]] schema: Schema list supported.
        :param pulumi.Input[str] table_name: Delta table name.
        :param pulumi.Input[str] table_path: Delta table path.
        """
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "table_name", table_name)
        if table_path is not None:
            pulumi.set(__self__, "table_path", table_path)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[Sequence[pulumi.Input['DeltaTableSchemaArgs']]]:
        """
        Schema list supported.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[Sequence[pulumi.Input['DeltaTableSchemaArgs']]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        Delta table name.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="tablePath")
    def table_path(self) -> Optional[pulumi.Input[str]]:
        """
        Delta table path.
        """
        return pulumi.get(self, "table_path")

    @table_path.setter
    def table_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_path", value)


@pulumi.input_type
class DiskBackedMessageBufferSettingsArgs:
    def __init__(__self__, *,
                 max_size: pulumi.Input[str],
                 ephemeral_volume_claim_spec: Optional[pulumi.Input['VolumeClaimSpecArgs']] = None,
                 persistent_volume_claim_spec: Optional[pulumi.Input['VolumeClaimSpecArgs']] = None):
        """
        DiskBackedMessageBufferSettings properties
        :param pulumi.Input[str] max_size: The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        :param pulumi.Input['VolumeClaimSpecArgs'] ephemeral_volume_claim_spec: Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        :param pulumi.Input['VolumeClaimSpecArgs'] persistent_volume_claim_spec: Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        pulumi.set(__self__, "max_size", max_size)
        if ephemeral_volume_claim_spec is not None:
            pulumi.set(__self__, "ephemeral_volume_claim_spec", ephemeral_volume_claim_spec)
        if persistent_volume_claim_spec is not None:
            pulumi.set(__self__, "persistent_volume_claim_spec", persistent_volume_claim_spec)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> pulumi.Input[str]:
        """
        The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter(name="ephemeralVolumeClaimSpec")
    def ephemeral_volume_claim_spec(self) -> Optional[pulumi.Input['VolumeClaimSpecArgs']]:
        """
        Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        """
        return pulumi.get(self, "ephemeral_volume_claim_spec")

    @ephemeral_volume_claim_spec.setter
    def ephemeral_volume_claim_spec(self, value: Optional[pulumi.Input['VolumeClaimSpecArgs']]):
        pulumi.set(self, "ephemeral_volume_claim_spec", value)

    @property
    @pulumi.getter(name="persistentVolumeClaimSpec")
    def persistent_volume_claim_spec(self) -> Optional[pulumi.Input['VolumeClaimSpecArgs']]:
        """
        Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        return pulumi.get(self, "persistent_volume_claim_spec")

    @persistent_volume_claim_spec.setter
    def persistent_volume_claim_spec(self, value: Optional[pulumi.Input['VolumeClaimSpecArgs']]):
        pulumi.set(self, "persistent_volume_claim_spec", value)


@pulumi.input_type
class ExtendedLocationPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[Union[str, 'ExtendedLocationType']]):
        """
        ExtendedLocation properties
        :param pulumi.Input[str] name: The name of the extended location.
        :param pulumi.Input[Union[str, 'ExtendedLocationType']] type: Type of ExtendedLocation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ExtendedLocationType']]:
        """
        Type of ExtendedLocation.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ExtendedLocationType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FabricGuidsArgs:
    def __init__(__self__, *,
                 lakehouse_guid: pulumi.Input[str],
                 workspace_guid: pulumi.Input[str]):
        """
        Fabric one lake guids.
        :param pulumi.Input[str] lakehouse_guid: Fabric one lake house guid.
        :param pulumi.Input[str] workspace_guid: Fabric one lake workspace guid.
        """
        pulumi.set(__self__, "lakehouse_guid", lakehouse_guid)
        pulumi.set(__self__, "workspace_guid", workspace_guid)

    @property
    @pulumi.getter(name="lakehouseGuid")
    def lakehouse_guid(self) -> pulumi.Input[str]:
        """
        Fabric one lake house guid.
        """
        return pulumi.get(self, "lakehouse_guid")

    @lakehouse_guid.setter
    def lakehouse_guid(self, value: pulumi.Input[str]):
        pulumi.set(self, "lakehouse_guid", value)

    @property
    @pulumi.getter(name="workspaceGuid")
    def workspace_guid(self) -> pulumi.Input[str]:
        """
        Fabric one lake workspace guid.
        """
        return pulumi.get(self, "workspace_guid")

    @workspace_guid.setter
    def workspace_guid(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_guid", value)


@pulumi.input_type
class FabricNamesArgs:
    def __init__(__self__, *,
                 lakehouse_name: pulumi.Input[str],
                 workspace_name: pulumi.Input[str]):
        """
        Fabric one lake names.
        :param pulumi.Input[str] lakehouse_name: Fabric one lake house name.
        :param pulumi.Input[str] workspace_name: Fabric one lake workspace name.
        """
        pulumi.set(__self__, "lakehouse_name", lakehouse_name)
        pulumi.set(__self__, "workspace_name", workspace_name)

    @property
    @pulumi.getter(name="lakehouseName")
    def lakehouse_name(self) -> pulumi.Input[str]:
        """
        Fabric one lake house name.
        """
        return pulumi.get(self, "lakehouse_name")

    @lakehouse_name.setter
    def lakehouse_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "lakehouse_name", value)

    @property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> pulumi.Input[str]:
        """
        Fabric one lake workspace name.
        """
        return pulumi.get(self, "workspace_name")

    @workspace_name.setter
    def workspace_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_name", value)


@pulumi.input_type
class FrontendArgs:
    def __init__(__self__, *,
                 replicas: pulumi.Input[int],
                 temporary_resource_limits: Optional[pulumi.Input['TemporaryResourceLimitsConfigArgs']] = None,
                 workers: Optional[pulumi.Input[int]] = None):
        """
        Desired properties of the Frontend Instances of the DMQTT Broker
        :param pulumi.Input[int] replicas: Replicas is desired number of frontend replicas of the given distributed MQTT broker.
        :param pulumi.Input['TemporaryResourceLimitsConfigArgs'] temporary_resource_limits: Defines the limits for resources of the frontend instances of the MQTT broker.
        :param pulumi.Input[int] workers: Number of logical frontend workers per pod.
        """
        pulumi.set(__self__, "replicas", replicas)
        if temporary_resource_limits is not None:
            pulumi.set(__self__, "temporary_resource_limits", temporary_resource_limits)
        if workers is None:
            workers = 2
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter
    def replicas(self) -> pulumi.Input[int]:
        """
        Replicas is desired number of frontend replicas of the given distributed MQTT broker.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: pulumi.Input[int]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="temporaryResourceLimits")
    def temporary_resource_limits(self) -> Optional[pulumi.Input['TemporaryResourceLimitsConfigArgs']]:
        """
        Defines the limits for resources of the frontend instances of the MQTT broker.
        """
        return pulumi.get(self, "temporary_resource_limits")

    @temporary_resource_limits.setter
    def temporary_resource_limits(self, value: Optional[pulumi.Input['TemporaryResourceLimitsConfigArgs']]):
        pulumi.set(self, "temporary_resource_limits", value)

    @property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input[int]]:
        """
        Number of logical frontend workers per pod.
        """
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "workers", value)


@pulumi.input_type
class KafkaRemoteBrokerAuthenticationPropertiesArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 auth_type: Optional[pulumi.Input['KafkaRemoteBrokerAuthenticationTypesArgs']] = None):
        """
        Kafka RemoteBrokerConnection Authentication methods
        :param pulumi.Input[bool] enabled: If authentication is enabled for Kafka remote broker.
        :param pulumi.Input['KafkaRemoteBrokerAuthenticationTypesArgs'] auth_type: The type of authentication to use for Kafka remote broker.
        """
        pulumi.set(__self__, "enabled", enabled)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If authentication is enabled for Kafka remote broker.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input['KafkaRemoteBrokerAuthenticationTypesArgs']]:
        """
        The type of authentication to use for Kafka remote broker.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input['KafkaRemoteBrokerAuthenticationTypesArgs']]):
        pulumi.set(self, "auth_type", value)


@pulumi.input_type
class KafkaRemoteBrokerAuthenticationTypesArgs:
    def __init__(__self__, *,
                 sasl: Optional[pulumi.Input['SaslRemoteBrokerBasicAuthenticationArgs']] = None,
                 system_assigned_managed_identity: Optional[pulumi.Input['ManagedIdentityAuthenticationArgs']] = None,
                 x509: Optional[pulumi.Input['KafkaX509AuthenticationArgs']] = None):
        """
        Kafka RemoteBrokerConnection Authentication types. NOTE - Enum only one method is allowed to be passed.
        :param pulumi.Input['SaslRemoteBrokerBasicAuthenticationArgs'] sasl: Sasl remote broker authentication method.
        :param pulumi.Input['ManagedIdentityAuthenticationArgs'] system_assigned_managed_identity: Managed identity remote broker authentication method.
        :param pulumi.Input['KafkaX509AuthenticationArgs'] x509: X509 remote broker authentication method.
        """
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)
        if system_assigned_managed_identity is not None:
            pulumi.set(__self__, "system_assigned_managed_identity", system_assigned_managed_identity)
        if x509 is not None:
            pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def sasl(self) -> Optional[pulumi.Input['SaslRemoteBrokerBasicAuthenticationArgs']]:
        """
        Sasl remote broker authentication method.
        """
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: Optional[pulumi.Input['SaslRemoteBrokerBasicAuthenticationArgs']]):
        pulumi.set(self, "sasl", value)

    @property
    @pulumi.getter(name="systemAssignedManagedIdentity")
    def system_assigned_managed_identity(self) -> Optional[pulumi.Input['ManagedIdentityAuthenticationArgs']]:
        """
        Managed identity remote broker authentication method.
        """
        return pulumi.get(self, "system_assigned_managed_identity")

    @system_assigned_managed_identity.setter
    def system_assigned_managed_identity(self, value: Optional[pulumi.Input['ManagedIdentityAuthenticationArgs']]):
        pulumi.set(self, "system_assigned_managed_identity", value)

    @property
    @pulumi.getter
    def x509(self) -> Optional[pulumi.Input['KafkaX509AuthenticationArgs']]:
        """
        X509 remote broker authentication method.
        """
        return pulumi.get(self, "x509")

    @x509.setter
    def x509(self, value: Optional[pulumi.Input['KafkaX509AuthenticationArgs']]):
        pulumi.set(self, "x509", value)


@pulumi.input_type
class KafkaRemoteBrokerConnectionSpecArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['KafkaRemoteBrokerAuthenticationPropertiesArgs'],
                 endpoint: pulumi.Input[str],
                 tls: pulumi.Input['KafkaRemoteBrokerConnectionTlsArgs']):
        """
        Kafka RemoteBrokerConnectionSpec details
        :param pulumi.Input['KafkaRemoteBrokerAuthenticationPropertiesArgs'] authentication: The remote broker authentication methods.
        :param pulumi.Input[str] endpoint: The endpoint of remote broker to connect to.
        :param pulumi.Input['KafkaRemoteBrokerConnectionTlsArgs'] tls: TLS details for Remote broker Connection.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['KafkaRemoteBrokerAuthenticationPropertiesArgs']:
        """
        The remote broker authentication methods.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['KafkaRemoteBrokerAuthenticationPropertiesArgs']):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        The endpoint of remote broker to connect to.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def tls(self) -> pulumi.Input['KafkaRemoteBrokerConnectionTlsArgs']:
        """
        TLS details for Remote broker Connection.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: pulumi.Input['KafkaRemoteBrokerConnectionTlsArgs']):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class KafkaRemoteBrokerConnectionTlsArgs:
    def __init__(__self__, *,
                 tls_enabled: pulumi.Input[bool],
                 trusted_ca_certificate_config_map: Optional[pulumi.Input[str]] = None):
        """
        Kafka RemoteBrokerConnection TLS details
        :param pulumi.Input[bool] tls_enabled: Tls Enabled on Remote Broker Connection.
        :param pulumi.Input[str] trusted_ca_certificate_config_map: Trusted CA certificate name for Remote Broker.
        """
        pulumi.set(__self__, "tls_enabled", tls_enabled)
        if trusted_ca_certificate_config_map is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map", trusted_ca_certificate_config_map)

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> pulumi.Input[bool]:
        """
        Tls Enabled on Remote Broker Connection.
        """
        return pulumi.get(self, "tls_enabled")

    @tls_enabled.setter
    def tls_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "tls_enabled", value)

    @property
    @pulumi.getter(name="trustedCaCertificateConfigMap")
    def trusted_ca_certificate_config_map(self) -> Optional[pulumi.Input[str]]:
        """
        Trusted CA certificate name for Remote Broker.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map")

    @trusted_ca_certificate_config_map.setter
    def trusted_ca_certificate_config_map(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_certificate_config_map", value)


@pulumi.input_type
class KafkaRoutesArgs:
    def __init__(__self__, *,
                 kafka_to_mqtt: Optional[pulumi.Input['KafkaToMqttRoutesArgs']] = None,
                 mqtt_to_kafka: Optional[pulumi.Input['MqttToKafkaRoutesArgs']] = None):
        """
        Kafka Routes properties. NOTE - Enum only one method is allowed to be passed.
        :param pulumi.Input['KafkaToMqttRoutesArgs'] kafka_to_mqtt: Kafka to Mqtt route.
        :param pulumi.Input['MqttToKafkaRoutesArgs'] mqtt_to_kafka: Mqtt to Kafka route.
        """
        if kafka_to_mqtt is not None:
            pulumi.set(__self__, "kafka_to_mqtt", kafka_to_mqtt)
        if mqtt_to_kafka is not None:
            pulumi.set(__self__, "mqtt_to_kafka", mqtt_to_kafka)

    @property
    @pulumi.getter(name="kafkaToMqtt")
    def kafka_to_mqtt(self) -> Optional[pulumi.Input['KafkaToMqttRoutesArgs']]:
        """
        Kafka to Mqtt route.
        """
        return pulumi.get(self, "kafka_to_mqtt")

    @kafka_to_mqtt.setter
    def kafka_to_mqtt(self, value: Optional[pulumi.Input['KafkaToMqttRoutesArgs']]):
        pulumi.set(self, "kafka_to_mqtt", value)

    @property
    @pulumi.getter(name="mqttToKafka")
    def mqtt_to_kafka(self) -> Optional[pulumi.Input['MqttToKafkaRoutesArgs']]:
        """
        Mqtt to Kafka route.
        """
        return pulumi.get(self, "mqtt_to_kafka")

    @mqtt_to_kafka.setter
    def mqtt_to_kafka(self, value: Optional[pulumi.Input['MqttToKafkaRoutesArgs']]):
        pulumi.set(self, "mqtt_to_kafka", value)


@pulumi.input_type
class KafkaSharedSubscriptionPropertiesArgs:
    def __init__(__self__, *,
                 group_minimum_share_number: pulumi.Input[int],
                 group_name: pulumi.Input[str]):
        """
        Kafka Shared Subscription properties
        :param pulumi.Input[int] group_minimum_share_number: The minimum number to use in a group for subscription.
        :param pulumi.Input[str] group_name: The name of the shared subscription.
        """
        pulumi.set(__self__, "group_minimum_share_number", group_minimum_share_number)
        pulumi.set(__self__, "group_name", group_name)

    @property
    @pulumi.getter(name="groupMinimumShareNumber")
    def group_minimum_share_number(self) -> pulumi.Input[int]:
        """
        The minimum number to use in a group for subscription.
        """
        return pulumi.get(self, "group_minimum_share_number")

    @group_minimum_share_number.setter
    def group_minimum_share_number(self, value: pulumi.Input[int]):
        pulumi.set(self, "group_minimum_share_number", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[str]:
        """
        The name of the shared subscription.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_name", value)


@pulumi.input_type
class KafkaToMqttRoutesArgs:
    def __init__(__self__, *,
                 kafka_topic: pulumi.Input[str],
                 mqtt_topic: pulumi.Input[str],
                 name: pulumi.Input[str],
                 consumer_group_id: Optional[pulumi.Input[str]] = None,
                 qos: Optional[pulumi.Input[int]] = None):
        """
        Kafka to Mqtt route properties
        :param pulumi.Input[str] kafka_topic: The kafka topic to pull from.
        :param pulumi.Input[str] mqtt_topic: The mqtt topic to publish to.
        :param pulumi.Input[str] name: The name of the route.
        :param pulumi.Input[str] consumer_group_id: The consumer group id to use.
        :param pulumi.Input[int] qos: The qos to use for mqtt.
        """
        pulumi.set(__self__, "kafka_topic", kafka_topic)
        pulumi.set(__self__, "mqtt_topic", mqtt_topic)
        pulumi.set(__self__, "name", name)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> pulumi.Input[str]:
        """
        The kafka topic to pull from.
        """
        return pulumi.get(self, "kafka_topic")

    @kafka_topic.setter
    def kafka_topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "kafka_topic", value)

    @property
    @pulumi.getter(name="mqttTopic")
    def mqtt_topic(self) -> pulumi.Input[str]:
        """
        The mqtt topic to publish to.
        """
        return pulumi.get(self, "mqtt_topic")

    @mqtt_topic.setter
    def mqtt_topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "mqtt_topic", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the route.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The consumer group id to use.
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[int]]:
        """
        The qos to use for mqtt.
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qos", value)


@pulumi.input_type
class KafkaTokenKeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 vault: pulumi.Input['KeyVaultConnectionPropertiesArgs'],
                 vault_secret: pulumi.Input['KeyVaultSecretObjectArgs'],
                 username: Optional[pulumi.Input[str]] = None):
        """
        Kafka Token KeyVault properties.
        :param pulumi.Input['KeyVaultConnectionPropertiesArgs'] vault: KeyVault properties.
        :param pulumi.Input['KeyVaultSecretObjectArgs'] vault_secret: KeyVault secret details.
        :param pulumi.Input[str] username: Username to connect with.
        """
        pulumi.set(__self__, "vault", vault)
        pulumi.set(__self__, "vault_secret", vault_secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def vault(self) -> pulumi.Input['KeyVaultConnectionPropertiesArgs']:
        """
        KeyVault properties.
        """
        return pulumi.get(self, "vault")

    @vault.setter
    def vault(self, value: pulumi.Input['KeyVaultConnectionPropertiesArgs']):
        pulumi.set(self, "vault", value)

    @property
    @pulumi.getter(name="vaultSecret")
    def vault_secret(self) -> pulumi.Input['KeyVaultSecretObjectArgs']:
        """
        KeyVault secret details.
        """
        return pulumi.get(self, "vault_secret")

    @vault_secret.setter
    def vault_secret(self, value: pulumi.Input['KeyVaultSecretObjectArgs']):
        pulumi.set(self, "vault_secret", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username to connect with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class KafkaTopicMapBatchingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 latency_ms: Optional[pulumi.Input[int]] = None,
                 max_bytes: Optional[pulumi.Input[float]] = None,
                 max_messages: Optional[pulumi.Input[float]] = None):
        """
        Kafka TopicMap Batching properties
        :param pulumi.Input[bool] enabled: The setting to enable or disable batching.
        :param pulumi.Input[int] latency_ms: The latency of message batching.
        :param pulumi.Input[float] max_bytes: The maximum bytes to send in a batch.
        :param pulumi.Input[float] max_messages: The maximum messages to send in a batch.
        """
        if enabled is None:
            enabled = False
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if latency_ms is None:
            latency_ms = 5
        if latency_ms is not None:
            pulumi.set(__self__, "latency_ms", latency_ms)
        if max_bytes is None:
            max_bytes = 1000000
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        The setting to enable or disable batching.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="latencyMs")
    def latency_ms(self) -> Optional[pulumi.Input[int]]:
        """
        The latency of message batching.
        """
        return pulumi.get(self, "latency_ms")

    @latency_ms.setter
    def latency_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "latency_ms", value)

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum bytes to send in a batch.
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_bytes", value)

    @property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum messages to send in a batch.
        """
        return pulumi.get(self, "max_messages")

    @max_messages.setter
    def max_messages(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_messages", value)


@pulumi.input_type
class KafkaX509AuthenticationArgs:
    def __init__(__self__, *,
                 key_vault: Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        Kafka RemoteBrokerConnection X509 Authentication properties.
        :param pulumi.Input['KeyVaultCertificatePropertiesArgs'] key_vault: Keyvault X509 secret properties.
        :param pulumi.Input[str] secret_name: Secret where cert details are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']]:
        """
        Keyvault X509 secret properties.
        """
        return pulumi.get(self, "key_vault")

    @key_vault.setter
    def key_vault(self, value: Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']]):
        pulumi.set(self, "key_vault", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret where cert details are stored.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KeyVaultCertificatePropertiesArgs:
    def __init__(__self__, *,
                 vault: pulumi.Input['KeyVaultConnectionPropertiesArgs'],
                 vault_cert: pulumi.Input['KeyVaultSecretObjectArgs'],
                 vault_ca_chain_secret: Optional[pulumi.Input['KeyVaultSecretObjectArgs']] = None):
        """
        KeyVault certificate properties
        :param pulumi.Input['KeyVaultConnectionPropertiesArgs'] vault: KeyVault properties.
        :param pulumi.Input['KeyVaultSecretObjectArgs'] vault_cert: KeyVault Cert secret details.
        :param pulumi.Input['KeyVaultSecretObjectArgs'] vault_ca_chain_secret: KeyVault CA chain secret details.
        """
        pulumi.set(__self__, "vault", vault)
        pulumi.set(__self__, "vault_cert", vault_cert)
        if vault_ca_chain_secret is not None:
            pulumi.set(__self__, "vault_ca_chain_secret", vault_ca_chain_secret)

    @property
    @pulumi.getter
    def vault(self) -> pulumi.Input['KeyVaultConnectionPropertiesArgs']:
        """
        KeyVault properties.
        """
        return pulumi.get(self, "vault")

    @vault.setter
    def vault(self, value: pulumi.Input['KeyVaultConnectionPropertiesArgs']):
        pulumi.set(self, "vault", value)

    @property
    @pulumi.getter(name="vaultCert")
    def vault_cert(self) -> pulumi.Input['KeyVaultSecretObjectArgs']:
        """
        KeyVault Cert secret details.
        """
        return pulumi.get(self, "vault_cert")

    @vault_cert.setter
    def vault_cert(self, value: pulumi.Input['KeyVaultSecretObjectArgs']):
        pulumi.set(self, "vault_cert", value)

    @property
    @pulumi.getter(name="vaultCaChainSecret")
    def vault_ca_chain_secret(self) -> Optional[pulumi.Input['KeyVaultSecretObjectArgs']]:
        """
        KeyVault CA chain secret details.
        """
        return pulumi.get(self, "vault_ca_chain_secret")

    @vault_ca_chain_secret.setter
    def vault_ca_chain_secret(self, value: Optional[pulumi.Input['KeyVaultSecretObjectArgs']]):
        pulumi.set(self, "vault_ca_chain_secret", value)


@pulumi.input_type
class KeyVaultConnectionPropertiesArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['KeyVaultCredentialsPropertiesArgs'],
                 directory_id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        KeyVault properties
        :param pulumi.Input['KeyVaultCredentialsPropertiesArgs'] credentials: KeyVault credentials.
        :param pulumi.Input[str] directory_id: KeyVault directoryId.
        :param pulumi.Input[str] name: KeyVault name.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "directory_id", directory_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['KeyVaultCredentialsPropertiesArgs']:
        """
        KeyVault credentials.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['KeyVaultCredentialsPropertiesArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> pulumi.Input[str]:
        """
        KeyVault directoryId.
        """
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "directory_id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        KeyVault name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KeyVaultCredentialsPropertiesArgs:
    def __init__(__self__, *,
                 service_principal_local_secret_name: pulumi.Input[str]):
        """
        KeyVault credentials properties. NOTE - Future this will be ENUM.
        :param pulumi.Input[str] service_principal_local_secret_name: KeyVault service principal local secret name.
        """
        pulumi.set(__self__, "service_principal_local_secret_name", service_principal_local_secret_name)

    @property
    @pulumi.getter(name="servicePrincipalLocalSecretName")
    def service_principal_local_secret_name(self) -> pulumi.Input[str]:
        """
        KeyVault service principal local secret name.
        """
        return pulumi.get(self, "service_principal_local_secret_name")

    @service_principal_local_secret_name.setter
    def service_principal_local_secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_principal_local_secret_name", value)


@pulumi.input_type
class KeyVaultSecretObjectArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 version: Optional[pulumi.Input[str]] = None):
        """
        KeyVault secret object properties
        :param pulumi.Input[str] name: KeyVault secret name.
        :param pulumi.Input[str] version: KeyVault secret version.
        """
        pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        KeyVault secret name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        KeyVault secret version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KeyVaultSecretPropertiesArgs:
    def __init__(__self__, *,
                 vault: pulumi.Input['KeyVaultConnectionPropertiesArgs'],
                 vault_secret: pulumi.Input['KeyVaultSecretObjectArgs']):
        """
        KeyVault secret properties
        :param pulumi.Input['KeyVaultConnectionPropertiesArgs'] vault: KeyVault properties.
        :param pulumi.Input['KeyVaultSecretObjectArgs'] vault_secret: KeyVault secret details.
        """
        pulumi.set(__self__, "vault", vault)
        pulumi.set(__self__, "vault_secret", vault_secret)

    @property
    @pulumi.getter
    def vault(self) -> pulumi.Input['KeyVaultConnectionPropertiesArgs']:
        """
        KeyVault properties.
        """
        return pulumi.get(self, "vault")

    @vault.setter
    def vault(self, value: pulumi.Input['KeyVaultConnectionPropertiesArgs']):
        pulumi.set(self, "vault", value)

    @property
    @pulumi.getter(name="vaultSecret")
    def vault_secret(self) -> pulumi.Input['KeyVaultSecretObjectArgs']:
        """
        KeyVault secret details.
        """
        return pulumi.get(self, "vault_secret")

    @vault_secret.setter
    def vault_secret(self, value: pulumi.Input['KeyVaultSecretObjectArgs']):
        pulumi.set(self, "vault_secret", value)


@pulumi.input_type
class LocalBrokerAuthenticationMethodsArgs:
    def __init__(__self__, *,
                 kubernetes: pulumi.Input['LocalBrokerKubernetesAuthenticationArgs']):
        """
        Mqtt Local Broker Authentication details. Only one method at a time is supported. Default - kubernetes authentication
        :param pulumi.Input['LocalBrokerKubernetesAuthenticationArgs'] kubernetes: Kubernetes local broker authentication method.
        """
        pulumi.set(__self__, "kubernetes", kubernetes)

    @property
    @pulumi.getter
    def kubernetes(self) -> pulumi.Input['LocalBrokerKubernetesAuthenticationArgs']:
        """
        Kubernetes local broker authentication method.
        """
        return pulumi.get(self, "kubernetes")

    @kubernetes.setter
    def kubernetes(self, value: pulumi.Input['LocalBrokerKubernetesAuthenticationArgs']):
        pulumi.set(self, "kubernetes", value)


@pulumi.input_type
class LocalBrokerConnectionSpecArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['LocalBrokerAuthenticationMethodsArgs']] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 tls: Optional[pulumi.Input['LocalBrokerConnectionTlsArgs']] = None):
        """
        Mqtt Local Broker ConnectionSpec details
        :param pulumi.Input['LocalBrokerAuthenticationMethodsArgs'] authentication: The authentication methods for LocalBroker connection. NOTE - Enum only one method at a time is supported.
        :param pulumi.Input[str] endpoint: The endpoint of local broker to connect to.
        :param pulumi.Input['LocalBrokerConnectionTlsArgs'] tls: TLS details for Local broker Connection.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if endpoint is None:
            endpoint = 'aio-mq-dmqtt-frontend:1883'
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['LocalBrokerAuthenticationMethodsArgs']]:
        """
        The authentication methods for LocalBroker connection. NOTE - Enum only one method at a time is supported.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['LocalBrokerAuthenticationMethodsArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint of local broker to connect to.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['LocalBrokerConnectionTlsArgs']]:
        """
        TLS details for Local broker Connection.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['LocalBrokerConnectionTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class LocalBrokerConnectionTlsArgs:
    def __init__(__self__, *,
                 tls_enabled: Optional[pulumi.Input[bool]] = None,
                 trusted_ca_certificate_config_map: Optional[pulumi.Input[str]] = None):
        """
        Mqtt Local Broker Connection TLS details
        :param pulumi.Input[bool] tls_enabled: Tls Enabled on Local Broker Connection.
        :param pulumi.Input[str] trusted_ca_certificate_config_map: Trusted CA certificate config map name for Local Broker.
        """
        if tls_enabled is None:
            tls_enabled = False
        if tls_enabled is not None:
            pulumi.set(__self__, "tls_enabled", tls_enabled)
        if trusted_ca_certificate_config_map is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map", trusted_ca_certificate_config_map)

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Tls Enabled on Local Broker Connection.
        """
        return pulumi.get(self, "tls_enabled")

    @tls_enabled.setter
    def tls_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_enabled", value)

    @property
    @pulumi.getter(name="trustedCaCertificateConfigMap")
    def trusted_ca_certificate_config_map(self) -> Optional[pulumi.Input[str]]:
        """
        Trusted CA certificate config map name for Local Broker.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map")

    @trusted_ca_certificate_config_map.setter
    def trusted_ca_certificate_config_map(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_certificate_config_map", value)


@pulumi.input_type
class LocalBrokerKubernetesAuthenticationArgs:
    def __init__(__self__, *,
                 secret_path: Optional[pulumi.Input[str]] = None,
                 service_account_token_name: Optional[pulumi.Input[str]] = None):
        """
        Local Broker Kubernetes Authentication
        :param pulumi.Input[str] secret_path: Secret Path where SAT is mounted.
        :param pulumi.Input[str] service_account_token_name: Token name where SAT is mounted on secret path.
        """
        if secret_path is None:
            secret_path = '/var/run/serviceaccount/localbroker'
        if secret_path is not None:
            pulumi.set(__self__, "secret_path", secret_path)
        if service_account_token_name is None:
            service_account_token_name = 'sat'
        if service_account_token_name is not None:
            pulumi.set(__self__, "service_account_token_name", service_account_token_name)

    @property
    @pulumi.getter(name="secretPath")
    def secret_path(self) -> Optional[pulumi.Input[str]]:
        """
        Secret Path where SAT is mounted.
        """
        return pulumi.get(self, "secret_path")

    @secret_path.setter
    def secret_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_path", value)

    @property
    @pulumi.getter(name="serviceAccountTokenName")
    def service_account_token_name(self) -> Optional[pulumi.Input[str]]:
        """
        Token name where SAT is mounted on secret path.
        """
        return pulumi.get(self, "service_account_token_name")

    @service_account_token_name.setter
    def service_account_token_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_token_name", value)


@pulumi.input_type
class ManagedIdentityAuthenticationArgs:
    def __init__(__self__, *,
                 audience: pulumi.Input[str],
                 extension_name: Optional[pulumi.Input[str]] = None):
        """
        Managed identity authentication details.
        :param pulumi.Input[str] audience: Token audience.
        :param pulumi.Input[str] extension_name: Arc Extension name.
        """
        pulumi.set(__self__, "audience", audience)
        if extension_name is not None:
            pulumi.set(__self__, "extension_name", extension_name)

    @property
    @pulumi.getter
    def audience(self) -> pulumi.Input[str]:
        """
        Token audience.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: pulumi.Input[str]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter(name="extensionName")
    def extension_name(self) -> Optional[pulumi.Input[str]]:
        """
        Arc Extension name.
        """
        return pulumi.get(self, "extension_name")

    @extension_name.setter
    def extension_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extension_name", value)


@pulumi.input_type
class ManualCertMethodArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str],
                 secret_namespace: Optional[pulumi.Input[str]] = None):
        """
        Manual TLS server certificate management through a defined secret
        :param pulumi.Input[str] secret_name: secret containing TLS cert.
        :param pulumi.Input[str] secret_namespace: namespace of secret; omit to use default namespace.
        """
        pulumi.set(__self__, "secret_name", secret_name)
        if secret_namespace is not None:
            pulumi.set(__self__, "secret_namespace", secret_namespace)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        secret containing TLS cert.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter(name="secretNamespace")
    def secret_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        namespace of secret; omit to use default namespace.
        """
        return pulumi.get(self, "secret_namespace")

    @secret_namespace.setter
    def secret_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_namespace", value)


@pulumi.input_type
class MqttBridgeRemoteBrokerAuthenticationMethodsArgs:
    def __init__(__self__, *,
                 system_assigned_managed_identity: Optional[pulumi.Input['ManagedIdentityAuthenticationArgs']] = None,
                 x509: Optional[pulumi.Input['MqttBridgeRemoteBrokerX509AuthenticationArgs']] = None):
        """
        MqttBridge RemoteBrokerConnection Authentication methods. NOTE - Enum only one is allowed to be passed.
        :param pulumi.Input['ManagedIdentityAuthenticationArgs'] system_assigned_managed_identity: Managed identity remote broker authentication method.
        :param pulumi.Input['MqttBridgeRemoteBrokerX509AuthenticationArgs'] x509: X509 remote broker authentication method.
        """
        if system_assigned_managed_identity is not None:
            pulumi.set(__self__, "system_assigned_managed_identity", system_assigned_managed_identity)
        if x509 is not None:
            pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter(name="systemAssignedManagedIdentity")
    def system_assigned_managed_identity(self) -> Optional[pulumi.Input['ManagedIdentityAuthenticationArgs']]:
        """
        Managed identity remote broker authentication method.
        """
        return pulumi.get(self, "system_assigned_managed_identity")

    @system_assigned_managed_identity.setter
    def system_assigned_managed_identity(self, value: Optional[pulumi.Input['ManagedIdentityAuthenticationArgs']]):
        pulumi.set(self, "system_assigned_managed_identity", value)

    @property
    @pulumi.getter
    def x509(self) -> Optional[pulumi.Input['MqttBridgeRemoteBrokerX509AuthenticationArgs']]:
        """
        X509 remote broker authentication method.
        """
        return pulumi.get(self, "x509")

    @x509.setter
    def x509(self, value: Optional[pulumi.Input['MqttBridgeRemoteBrokerX509AuthenticationArgs']]):
        pulumi.set(self, "x509", value)


@pulumi.input_type
class MqttBridgeRemoteBrokerConnectionSpecArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['MqttBridgeRemoteBrokerAuthenticationMethodsArgs'],
                 endpoint: pulumi.Input[str],
                 tls: pulumi.Input['MqttBridgeRemoteBrokerConnectionTlsArgs'],
                 protocol: Optional[pulumi.Input[Union[str, 'MqttBridgeRemoteBrokerProtocol']]] = None):
        """
        MqttBridge RemoteBrokerConnectionSpec details
        :param pulumi.Input['MqttBridgeRemoteBrokerAuthenticationMethodsArgs'] authentication: The remote broker authentication methods. NOTE - Enum only one method is allowed to be passed.
        :param pulumi.Input[str] endpoint: The endpoint of remote broker to connect to.
        :param pulumi.Input['MqttBridgeRemoteBrokerConnectionTlsArgs'] tls: TLS details for Remote broker Connection.
        :param pulumi.Input[Union[str, 'MqttBridgeRemoteBrokerProtocol']] protocol: Protocol for remote connection.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "tls", tls)
        if protocol is None:
            protocol = 'mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['MqttBridgeRemoteBrokerAuthenticationMethodsArgs']:
        """
        The remote broker authentication methods. NOTE - Enum only one method is allowed to be passed.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['MqttBridgeRemoteBrokerAuthenticationMethodsArgs']):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        The endpoint of remote broker to connect to.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def tls(self) -> pulumi.Input['MqttBridgeRemoteBrokerConnectionTlsArgs']:
        """
        TLS details for Remote broker Connection.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: pulumi.Input['MqttBridgeRemoteBrokerConnectionTlsArgs']):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[str, 'MqttBridgeRemoteBrokerProtocol']]]:
        """
        Protocol for remote connection.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[str, 'MqttBridgeRemoteBrokerProtocol']]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class MqttBridgeRemoteBrokerConnectionTlsArgs:
    def __init__(__self__, *,
                 tls_enabled: pulumi.Input[bool],
                 trusted_ca_certificate_config_map: Optional[pulumi.Input[str]] = None):
        """
        MqttBridge RemoteBrokerConnection TLS details
        :param pulumi.Input[bool] tls_enabled: Tls Enabled on Remote Broker Connection.
        :param pulumi.Input[str] trusted_ca_certificate_config_map: Trusted CA certificate name for Remote Broker.
        """
        pulumi.set(__self__, "tls_enabled", tls_enabled)
        if trusted_ca_certificate_config_map is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map", trusted_ca_certificate_config_map)

    @property
    @pulumi.getter(name="tlsEnabled")
    def tls_enabled(self) -> pulumi.Input[bool]:
        """
        Tls Enabled on Remote Broker Connection.
        """
        return pulumi.get(self, "tls_enabled")

    @tls_enabled.setter
    def tls_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "tls_enabled", value)

    @property
    @pulumi.getter(name="trustedCaCertificateConfigMap")
    def trusted_ca_certificate_config_map(self) -> Optional[pulumi.Input[str]]:
        """
        Trusted CA certificate name for Remote Broker.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map")

    @trusted_ca_certificate_config_map.setter
    def trusted_ca_certificate_config_map(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_certificate_config_map", value)


@pulumi.input_type
class MqttBridgeRemoteBrokerX509AuthenticationArgs:
    def __init__(__self__, *,
                 key_vault: Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        MqttBridge RemoteBroker X509 Authentication properties.
        :param pulumi.Input['KeyVaultCertificatePropertiesArgs'] key_vault: Keyvault X509 secret properties.
        :param pulumi.Input[str] secret_name: Secret where cert details are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']]:
        """
        Keyvault X509 secret properties.
        """
        return pulumi.get(self, "key_vault")

    @key_vault.setter
    def key_vault(self, value: Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']]):
        pulumi.set(self, "key_vault", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret where cert details are stored.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class MqttBridgeRouteSharedSubscriptionArgs:
    def __init__(__self__, *,
                 group_minimum_share_number: pulumi.Input[int],
                 group_name: pulumi.Input[str]):
        """
        MqttBridgeRoute Shared subscription properties
        :param pulumi.Input[int] group_minimum_share_number: The group shared subscription minimum share number.
        :param pulumi.Input[str] group_name: The group name for Shared subscription.
        """
        pulumi.set(__self__, "group_minimum_share_number", group_minimum_share_number)
        pulumi.set(__self__, "group_name", group_name)

    @property
    @pulumi.getter(name="groupMinimumShareNumber")
    def group_minimum_share_number(self) -> pulumi.Input[int]:
        """
        The group shared subscription minimum share number.
        """
        return pulumi.get(self, "group_minimum_share_number")

    @group_minimum_share_number.setter
    def group_minimum_share_number(self, value: pulumi.Input[int]):
        pulumi.set(self, "group_minimum_share_number", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[str]:
        """
        The group name for Shared subscription.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_name", value)


@pulumi.input_type
class MqttBridgeRoutesArgs:
    def __init__(__self__, *,
                 direction: pulumi.Input[Union[str, 'MqttBridgeRouteDirection']],
                 name: pulumi.Input[str],
                 source: pulumi.Input[str],
                 qos: Optional[pulumi.Input[int]] = None,
                 shared_subscription: Optional[pulumi.Input['MqttBridgeRouteSharedSubscriptionArgs']] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        MqttBridgeTopicMap route properties
        :param pulumi.Input[Union[str, 'MqttBridgeRouteDirection']] direction: Direction of the route.
        :param pulumi.Input[str] name: Name of the route.
        :param pulumi.Input[str] source: Source topic of the route.
        :param pulumi.Input[int] qos: Qos for MQTT connection.
        :param pulumi.Input['MqttBridgeRouteSharedSubscriptionArgs'] shared_subscription: Shared subscription topic details.
        :param pulumi.Input[str] target: Target topic of the route. Ignore if same as source
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if shared_subscription is not None:
            pulumi.set(__self__, "shared_subscription", shared_subscription)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[Union[str, 'MqttBridgeRouteDirection']]:
        """
        Direction of the route.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[Union[str, 'MqttBridgeRouteDirection']]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the route.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Source topic of the route.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[int]]:
        """
        Qos for MQTT connection.
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qos", value)

    @property
    @pulumi.getter(name="sharedSubscription")
    def shared_subscription(self) -> Optional[pulumi.Input['MqttBridgeRouteSharedSubscriptionArgs']]:
        """
        Shared subscription topic details.
        """
        return pulumi.get(self, "shared_subscription")

    @shared_subscription.setter
    def shared_subscription(self, value: Optional[pulumi.Input['MqttBridgeRouteSharedSubscriptionArgs']]):
        pulumi.set(self, "shared_subscription", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Target topic of the route. Ignore if same as source
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class MqttToKafkaRoutesArgs:
    def __init__(__self__, *,
                 kafka_acks: pulumi.Input[Union[str, 'KafkaAcks']],
                 kafka_topic: pulumi.Input[str],
                 mqtt_topic: pulumi.Input[str],
                 name: pulumi.Input[str],
                 qos: Optional[pulumi.Input[int]] = None,
                 shared_subscription: Optional[pulumi.Input['KafkaSharedSubscriptionPropertiesArgs']] = None):
        """
        Mqtt to Kafka route properties
        :param pulumi.Input[Union[str, 'KafkaAcks']] kafka_acks: The kafka acks to use.
        :param pulumi.Input[str] kafka_topic: The kafka topic to publish to.
        :param pulumi.Input[str] mqtt_topic: The mqtt topic to pull from.
        :param pulumi.Input[str] name: The name of the route.
        :param pulumi.Input[int] qos: The qos to use for mqtt.
        :param pulumi.Input['KafkaSharedSubscriptionPropertiesArgs'] shared_subscription: The properties for shared subscription.
        """
        pulumi.set(__self__, "kafka_acks", kafka_acks)
        pulumi.set(__self__, "kafka_topic", kafka_topic)
        pulumi.set(__self__, "mqtt_topic", mqtt_topic)
        pulumi.set(__self__, "name", name)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if shared_subscription is not None:
            pulumi.set(__self__, "shared_subscription", shared_subscription)

    @property
    @pulumi.getter(name="kafkaAcks")
    def kafka_acks(self) -> pulumi.Input[Union[str, 'KafkaAcks']]:
        """
        The kafka acks to use.
        """
        return pulumi.get(self, "kafka_acks")

    @kafka_acks.setter
    def kafka_acks(self, value: pulumi.Input[Union[str, 'KafkaAcks']]):
        pulumi.set(self, "kafka_acks", value)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> pulumi.Input[str]:
        """
        The kafka topic to publish to.
        """
        return pulumi.get(self, "kafka_topic")

    @kafka_topic.setter
    def kafka_topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "kafka_topic", value)

    @property
    @pulumi.getter(name="mqttTopic")
    def mqtt_topic(self) -> pulumi.Input[str]:
        """
        The mqtt topic to pull from.
        """
        return pulumi.get(self, "mqtt_topic")

    @mqtt_topic.setter
    def mqtt_topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "mqtt_topic", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the route.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[int]]:
        """
        The qos to use for mqtt.
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qos", value)

    @property
    @pulumi.getter(name="sharedSubscription")
    def shared_subscription(self) -> Optional[pulumi.Input['KafkaSharedSubscriptionPropertiesArgs']]:
        """
        The properties for shared subscription.
        """
        return pulumi.get(self, "shared_subscription")

    @shared_subscription.setter
    def shared_subscription(self, value: Optional[pulumi.Input['KafkaSharedSubscriptionPropertiesArgs']]):
        pulumi.set(self, "shared_subscription", value)


@pulumi.input_type
class NodeTolerationsArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        Defines the Node Tolerations details
        :param pulumi.Input[str] effect: Toleration effect.
        :param pulumi.Input[str] key: Toleration key.
        :param pulumi.Input[str] operator: Toleration operator like 'Exists', 'Equal' etc.
        :param pulumi.Input[str] value: Toleration Value.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        Toleration effect.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Toleration key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Toleration operator like 'Exists', 'Equal' etc.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Toleration Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PrincipalDefinitionArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]] = None,
                 clientids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 usernames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        PrincipalDefinition properties of Basic Rule
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]] attributes: A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] clientids: A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] usernames: A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if clientids is not None:
            pulumi.set(__self__, "clientids", clientids)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]:
        """
        A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter
    def clientids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        """
        return pulumi.get(self, "clientids")

    @clientids.setter
    def clientids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "clientids", value)

    @property
    @pulumi.getter
    def usernames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "usernames", value)


@pulumi.input_type
class ResourceInfoDefinitionArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[str, 'ResourceInfoDefinitionMethods']],
                 topics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        ResourceInfoDefinition properties of Basic Rule. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
        :param pulumi.Input[Union[str, 'ResourceInfoDefinitionMethods']] method: The type of action that the clients can perform on the broker: Connect, Publish or Subscribe.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topics: A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        pulumi.set(__self__, "method", method)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[str, 'ResourceInfoDefinitionMethods']]:
        """
        The type of action that the clients can perform on the broker: Connect, Publish or Subscribe.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[str, 'ResourceInfoDefinitionMethods']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "topics", value)


@pulumi.input_type
class SanForCertArgs:
    def __init__(__self__, *,
                 dns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 ip: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        SANs for certificate.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns: DNS SANs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip: IP address SANs.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def dns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        DNS SANs.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        IP address SANs.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class SaslRemoteBrokerBasicAuthenticationTokenArgs:
    def __init__(__self__, *,
                 key_vault: Optional[pulumi.Input['KafkaTokenKeyVaultPropertiesArgs']] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        Kafka RemoteBrokerConnection Sasl Authentication token properties. NOTE - Enum only one method is allowed to be passed.
        :param pulumi.Input['KafkaTokenKeyVaultPropertiesArgs'] key_vault: Keyvault token keyvault secret properties.
        :param pulumi.Input[str] secret_name: Secret where cert details are stored.
        """
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional[pulumi.Input['KafkaTokenKeyVaultPropertiesArgs']]:
        """
        Keyvault token keyvault secret properties.
        """
        return pulumi.get(self, "key_vault")

    @key_vault.setter
    def key_vault(self, value: Optional[pulumi.Input['KafkaTokenKeyVaultPropertiesArgs']]):
        pulumi.set(self, "key_vault", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret where cert details are stored.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class SaslRemoteBrokerBasicAuthenticationArgs:
    def __init__(__self__, *,
                 sasl_type: pulumi.Input[Union[str, 'KafkaSaslType']],
                 token: pulumi.Input['SaslRemoteBrokerBasicAuthenticationTokenArgs']):
        """
        Kafka RemoteBrokerConnection Sasl Authentication properties.
        :param pulumi.Input[Union[str, 'KafkaSaslType']] sasl_type: Sasl Mechanism for remote broker authentication.
        :param pulumi.Input['SaslRemoteBrokerBasicAuthenticationTokenArgs'] token: Sasl token for remote broker authentication.
        """
        pulumi.set(__self__, "sasl_type", sasl_type)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="saslType")
    def sasl_type(self) -> pulumi.Input[Union[str, 'KafkaSaslType']]:
        """
        Sasl Mechanism for remote broker authentication.
        """
        return pulumi.get(self, "sasl_type")

    @sasl_type.setter
    def sasl_type(self, value: pulumi.Input[Union[str, 'KafkaSaslType']]):
        pulumi.set(self, "sasl_type", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input['SaslRemoteBrokerBasicAuthenticationTokenArgs']:
        """
        Sasl token for remote broker authentication.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input['SaslRemoteBrokerBasicAuthenticationTokenArgs']):
        pulumi.set(self, "token", value)


@pulumi.input_type
class TemporaryResourceLimitsConfigArgs:
    def __init__(__self__, *,
                 max_inflight_messages: pulumi.Input[int],
                 max_inflight_patches: pulumi.Input[int],
                 max_inflight_patches_per_client: pulumi.Input[int],
                 max_queued_messages: pulumi.Input[float],
                 max_queued_qos0_messages: pulumi.Input[float],
                 max_session_expiry_secs: pulumi.Input[float],
                 max_message_expiry_secs: Optional[pulumi.Input[float]] = None):
        """
        Internal knobs of Resource Limits for FE and BE
        :param pulumi.Input[int] max_inflight_messages: Maximum number of messages a client can have inflight.
        :param pulumi.Input[int] max_inflight_patches: Maximum number of patch inflight per node.
        :param pulumi.Input[int] max_inflight_patches_per_client: Maximum number of patch a client can have in flight.
        :param pulumi.Input[float] max_queued_messages: Maximum receive for external clients.
        :param pulumi.Input[float] max_queued_qos0_messages: Maximum receive QoS0 for external clients.
        :param pulumi.Input[float] max_session_expiry_secs: Maximum session expiry interval, in seconds.
        :param pulumi.Input[float] max_message_expiry_secs: Maximum message expiry interval, in seconds.
        """
        pulumi.set(__self__, "max_inflight_messages", max_inflight_messages)
        pulumi.set(__self__, "max_inflight_patches", max_inflight_patches)
        pulumi.set(__self__, "max_inflight_patches_per_client", max_inflight_patches_per_client)
        pulumi.set(__self__, "max_queued_messages", max_queued_messages)
        pulumi.set(__self__, "max_queued_qos0_messages", max_queued_qos0_messages)
        pulumi.set(__self__, "max_session_expiry_secs", max_session_expiry_secs)
        if max_message_expiry_secs is not None:
            pulumi.set(__self__, "max_message_expiry_secs", max_message_expiry_secs)

    @property
    @pulumi.getter(name="maxInflightMessages")
    def max_inflight_messages(self) -> pulumi.Input[int]:
        """
        Maximum number of messages a client can have inflight.
        """
        return pulumi.get(self, "max_inflight_messages")

    @max_inflight_messages.setter
    def max_inflight_messages(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_inflight_messages", value)

    @property
    @pulumi.getter(name="maxInflightPatches")
    def max_inflight_patches(self) -> pulumi.Input[int]:
        """
        Maximum number of patch inflight per node.
        """
        return pulumi.get(self, "max_inflight_patches")

    @max_inflight_patches.setter
    def max_inflight_patches(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_inflight_patches", value)

    @property
    @pulumi.getter(name="maxInflightPatchesPerClient")
    def max_inflight_patches_per_client(self) -> pulumi.Input[int]:
        """
        Maximum number of patch a client can have in flight.
        """
        return pulumi.get(self, "max_inflight_patches_per_client")

    @max_inflight_patches_per_client.setter
    def max_inflight_patches_per_client(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_inflight_patches_per_client", value)

    @property
    @pulumi.getter(name="maxQueuedMessages")
    def max_queued_messages(self) -> pulumi.Input[float]:
        """
        Maximum receive for external clients.
        """
        return pulumi.get(self, "max_queued_messages")

    @max_queued_messages.setter
    def max_queued_messages(self, value: pulumi.Input[float]):
        pulumi.set(self, "max_queued_messages", value)

    @property
    @pulumi.getter(name="maxQueuedQos0Messages")
    def max_queued_qos0_messages(self) -> pulumi.Input[float]:
        """
        Maximum receive QoS0 for external clients.
        """
        return pulumi.get(self, "max_queued_qos0_messages")

    @max_queued_qos0_messages.setter
    def max_queued_qos0_messages(self, value: pulumi.Input[float]):
        pulumi.set(self, "max_queued_qos0_messages", value)

    @property
    @pulumi.getter(name="maxSessionExpirySecs")
    def max_session_expiry_secs(self) -> pulumi.Input[float]:
        """
        Maximum session expiry interval, in seconds.
        """
        return pulumi.get(self, "max_session_expiry_secs")

    @max_session_expiry_secs.setter
    def max_session_expiry_secs(self, value: pulumi.Input[float]):
        pulumi.set(self, "max_session_expiry_secs", value)

    @property
    @pulumi.getter(name="maxMessageExpirySecs")
    def max_message_expiry_secs(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum message expiry interval, in seconds.
        """
        return pulumi.get(self, "max_message_expiry_secs")

    @max_message_expiry_secs.setter
    def max_message_expiry_secs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_message_expiry_secs", value)


@pulumi.input_type
class TlsCertMethodArgs:
    def __init__(__self__, *,
                 automatic: Optional[pulumi.Input['AutomaticCertMethodArgs']] = None,
                 key_vault: Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']] = None,
                 manual: Optional[pulumi.Input['ManualCertMethodArgs']] = None):
        """
        Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
        :param pulumi.Input['AutomaticCertMethodArgs'] automatic: Option 1 - Automatic TLS server certificate management with cert-manager.
        :param pulumi.Input['KeyVaultCertificatePropertiesArgs'] key_vault: Option 3 - TLS server certificate retrieved from Key Vault..
        :param pulumi.Input['ManualCertMethodArgs'] manual: Option 2 - Manual TLS server certificate management through a defined secret.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)
        if key_vault is not None:
            pulumi.set(__self__, "key_vault", key_vault)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @property
    @pulumi.getter
    def automatic(self) -> Optional[pulumi.Input['AutomaticCertMethodArgs']]:
        """
        Option 1 - Automatic TLS server certificate management with cert-manager.
        """
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: Optional[pulumi.Input['AutomaticCertMethodArgs']]):
        pulumi.set(self, "automatic", value)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']]:
        """
        Option 3 - TLS server certificate retrieved from Key Vault..
        """
        return pulumi.get(self, "key_vault")

    @key_vault.setter
    def key_vault(self, value: Optional[pulumi.Input['KeyVaultCertificatePropertiesArgs']]):
        pulumi.set(self, "key_vault", value)

    @property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['ManualCertMethodArgs']]:
        """
        Option 2 - Manual TLS server certificate management through a defined secret.
        """
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['ManualCertMethodArgs']]):
        pulumi.set(self, "manual", value)


@pulumi.input_type
class VolumeClaimDataSourceRefArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 name: pulumi.Input[str],
                 api_group: Optional[pulumi.Input[str]] = None):
        """
        VolumeClaimDataSourceRef properties
        :param pulumi.Input[str] kind: Kind is the type of resource being referenced
        :param pulumi.Input[str] name: Name is the name of resource being referenced
        :param pulumi.Input[str] api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[pulumi.Input[str]]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")

    @api_group.setter
    def api_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_group", value)


@pulumi.input_type
class VolumeClaimDataSourceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 name: pulumi.Input[str],
                 api_group: Optional[pulumi.Input[str]] = None):
        """
        VolumeClaimDataSource properties
        :param pulumi.Input[str] kind: Kind is the type of resource being referenced
        :param pulumi.Input[str] name: Name is the name of resource being referenced
        :param pulumi.Input[str] api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[pulumi.Input[str]]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")

    @api_group.setter
    def api_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_group", value)


@pulumi.input_type
class VolumeClaimResourceRequirementsArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        VolumeClaimResourceRequirements properties
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class VolumeClaimSpecSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        VolumeClaimSpecSelectorMatchExpressions properties
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class VolumeClaimSpecSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        VolumeClaimSpecSelector properties
        :param pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]] match_expressions: MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]]]:
        """
        MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class VolumeClaimSpecArgs:
    def __init__(__self__, *,
                 access_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 data_source: Optional[pulumi.Input['VolumeClaimDataSourceArgs']] = None,
                 data_source_ref: Optional[pulumi.Input['VolumeClaimDataSourceRefArgs']] = None,
                 resources: Optional[pulumi.Input['VolumeClaimResourceRequirementsArgs']] = None,
                 selector: Optional[pulumi.Input['VolumeClaimSpecSelectorArgs']] = None,
                 storage_class_name: Optional[pulumi.Input[str]] = None,
                 volume_mode: Optional[pulumi.Input[str]] = None,
                 volume_name: Optional[pulumi.Input[str]] = None):
        """
        VolumeClaimSpec properties
        :param pulumi.Input[Sequence[pulumi.Input[str]]] access_modes: AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        :param pulumi.Input['VolumeClaimDataSourceArgs'] data_source: This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        :param pulumi.Input['VolumeClaimDataSourceRefArgs'] data_source_ref: Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        :param pulumi.Input['VolumeClaimResourceRequirementsArgs'] resources: Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param pulumi.Input['VolumeClaimSpecSelectorArgs'] selector: A label query over volumes to consider for binding.
        :param pulumi.Input[str] storage_class_name: Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        :param pulumi.Input[str] volume_mode: volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        :param pulumi.Input[str] volume_name: VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        if access_modes is not None:
            pulumi.set(__self__, "access_modes", access_modes)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if data_source_ref is not None:
            pulumi.set(__self__, "data_source_ref", data_source_ref)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)
        if volume_mode is not None:
            pulumi.set(__self__, "volume_mode", volume_mode)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @access_modes.setter
    def access_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "access_modes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input['VolumeClaimDataSourceArgs']]:
        """
        This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input['VolumeClaimDataSourceArgs']]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter(name="dataSourceRef")
    def data_source_ref(self) -> Optional[pulumi.Input['VolumeClaimDataSourceRefArgs']]:
        """
        Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        """
        return pulumi.get(self, "data_source_ref")

    @data_source_ref.setter
    def data_source_ref(self, value: Optional[pulumi.Input['VolumeClaimDataSourceRefArgs']]):
        pulumi.set(self, "data_source_ref", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['VolumeClaimResourceRequirementsArgs']]:
        """
        Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['VolumeClaimResourceRequirementsArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['VolumeClaimSpecSelectorArgs']]:
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['VolumeClaimSpecSelectorArgs']]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        """
        return pulumi.get(self, "storage_class_name")

    @storage_class_name.setter
    def storage_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_class_name", value)

    @property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> Optional[pulumi.Input[str]]:
        """
        volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        """
        return pulumi.get(self, "volume_mode")

    @volume_mode.setter
    def volume_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_mode", value)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[pulumi.Input[str]]:
        """
        VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_name", value)


