# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'DatabaseIdentityArgs',
    'DatabaseIdentityArgsDict',
    'FirewallRulePropertiesArgs',
    'FirewallRulePropertiesArgsDict',
    'FleetDatabasePropertiesArgs',
    'FleetDatabasePropertiesArgsDict',
    'FleetPropertiesArgs',
    'FleetPropertiesArgsDict',
    'FleetTierPropertiesArgs',
    'FleetTierPropertiesArgsDict',
    'FleetspacePropertiesArgs',
    'FleetspacePropertiesArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'MainPrincipalArgs',
    'MainPrincipalArgsDict',
    'TransparentDataEncryptionArgs',
    'TransparentDataEncryptionArgsDict',
]

MYPY = False

if not MYPY:
    class DatabaseIdentityArgsDict(TypedDict):
        """
        Database Identity properties.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Client Id of the database identity.
        """
        principal_id: NotRequired[pulumi.Input[str]]
        """
        Principal Id of the database identity.
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        Resource Id of the database identity.
        """
elif False:
    DatabaseIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Database Identity properties.
        :param pulumi.Input[str] client_id: Client Id of the database identity.
        :param pulumi.Input[str] principal_id: Principal Id of the database identity.
        :param pulumi.Input[str] resource_id: Resource Id of the database identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client Id of the database identity.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        Principal Id of the database identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource Id of the database identity.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class FirewallRulePropertiesArgsDict(TypedDict):
        """
        A Firewall rule properties.
        """
        end_ip_address: NotRequired[pulumi.Input[str]]
        """
        End IP address.
        """
        start_ip_address: NotRequired[pulumi.Input[str]]
        """
        Start IP address.
        """
elif False:
    FirewallRulePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallRulePropertiesArgs:
    def __init__(__self__, *,
                 end_ip_address: Optional[pulumi.Input[str]] = None,
                 start_ip_address: Optional[pulumi.Input[str]] = None):
        """
        A Firewall rule properties.
        :param pulumi.Input[str] end_ip_address: End IP address.
        :param pulumi.Input[str] start_ip_address: Start IP address.
        """
        if end_ip_address is not None:
            pulumi.set(__self__, "end_ip_address", end_ip_address)
        if start_ip_address is not None:
            pulumi.set(__self__, "start_ip_address", start_ip_address)

    @property
    @pulumi.getter(name="endIpAddress")
    def end_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        End IP address.
        """
        return pulumi.get(self, "end_ip_address")

    @end_ip_address.setter
    def end_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_ip_address", value)

    @property
    @pulumi.getter(name="startIpAddress")
    def start_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Start IP address.
        """
        return pulumi.get(self, "start_ip_address")

    @start_ip_address.setter
    def start_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_ip_address", value)


if not MYPY:
    class FleetDatabasePropertiesArgsDict(TypedDict):
        """
        Fleet database properties.
        """
        collation: NotRequired[pulumi.Input[str]]
        """
        Database collation.
        """
        create_mode: NotRequired[pulumi.Input[Union[str, 'DatabaseCreateMode']]]
        """
        Create mode. Available options: Default - Create a database. Copy - Copy the source database (source database name must be specified) PointInTimeRestore - Create a database by restoring source database from a point in time (source database name and restore from time must be specified)
        """
        identity: NotRequired[pulumi.Input['IdentityArgsDict']]
        """
        Identity property.
        """
        resource_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional database properties to be applied as the underlying database resource tags.
        """
        restore_from_time: NotRequired[pulumi.Input[str]]
        """
        Restore from time when CreateMode is PointInTimeRestore.
        """
        source_database_name: NotRequired[pulumi.Input[str]]
        """
        Source database name used when CreateMode is Copy or PointInTimeRestore.
        """
        tier_name: NotRequired[pulumi.Input[str]]
        """
        Name of the tier this database belongs to.
        """
        transparent_data_encryption: NotRequired[pulumi.Input['TransparentDataEncryptionArgsDict']]
        """
        Transparent Data Encryption properties
        """
elif False:
    FleetDatabasePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetDatabasePropertiesArgs:
    def __init__(__self__, *,
                 collation: Optional[pulumi.Input[str]] = None,
                 create_mode: Optional[pulumi.Input[Union[str, 'DatabaseCreateMode']]] = None,
                 identity: Optional[pulumi.Input['IdentityArgs']] = None,
                 resource_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 restore_from_time: Optional[pulumi.Input[str]] = None,
                 source_database_name: Optional[pulumi.Input[str]] = None,
                 tier_name: Optional[pulumi.Input[str]] = None,
                 transparent_data_encryption: Optional[pulumi.Input['TransparentDataEncryptionArgs']] = None):
        """
        Fleet database properties.
        :param pulumi.Input[str] collation: Database collation.
        :param pulumi.Input[Union[str, 'DatabaseCreateMode']] create_mode: Create mode. Available options: Default - Create a database. Copy - Copy the source database (source database name must be specified) PointInTimeRestore - Create a database by restoring source database from a point in time (source database name and restore from time must be specified)
        :param pulumi.Input['IdentityArgs'] identity: Identity property.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] resource_tags: Additional database properties to be applied as the underlying database resource tags.
        :param pulumi.Input[str] restore_from_time: Restore from time when CreateMode is PointInTimeRestore.
        :param pulumi.Input[str] source_database_name: Source database name used when CreateMode is Copy or PointInTimeRestore.
        :param pulumi.Input[str] tier_name: Name of the tier this database belongs to.
        :param pulumi.Input['TransparentDataEncryptionArgs'] transparent_data_encryption: Transparent Data Encryption properties
        """
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if resource_tags is not None:
            pulumi.set(__self__, "resource_tags", resource_tags)
        if restore_from_time is not None:
            pulumi.set(__self__, "restore_from_time", restore_from_time)
        if source_database_name is not None:
            pulumi.set(__self__, "source_database_name", source_database_name)
        if tier_name is not None:
            pulumi.set(__self__, "tier_name", tier_name)
        if transparent_data_encryption is not None:
            pulumi.set(__self__, "transparent_data_encryption", transparent_data_encryption)

    @property
    @pulumi.getter
    def collation(self) -> Optional[pulumi.Input[str]]:
        """
        Database collation.
        """
        return pulumi.get(self, "collation")

    @collation.setter
    def collation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collation", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[pulumi.Input[Union[str, 'DatabaseCreateMode']]]:
        """
        Create mode. Available options: Default - Create a database. Copy - Copy the source database (source database name must be specified) PointInTimeRestore - Create a database by restoring source database from a point in time (source database name and restore from time must be specified)
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: Optional[pulumi.Input[Union[str, 'DatabaseCreateMode']]]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input['IdentityArgs']]:
        """
        Identity property.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input['IdentityArgs']]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="resourceTags")
    def resource_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional database properties to be applied as the underlying database resource tags.
        """
        return pulumi.get(self, "resource_tags")

    @resource_tags.setter
    def resource_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "resource_tags", value)

    @property
    @pulumi.getter(name="restoreFromTime")
    def restore_from_time(self) -> Optional[pulumi.Input[str]]:
        """
        Restore from time when CreateMode is PointInTimeRestore.
        """
        return pulumi.get(self, "restore_from_time")

    @restore_from_time.setter
    def restore_from_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "restore_from_time", value)

    @property
    @pulumi.getter(name="sourceDatabaseName")
    def source_database_name(self) -> Optional[pulumi.Input[str]]:
        """
        Source database name used when CreateMode is Copy or PointInTimeRestore.
        """
        return pulumi.get(self, "source_database_name")

    @source_database_name.setter
    def source_database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_database_name", value)

    @property
    @pulumi.getter(name="tierName")
    def tier_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the tier this database belongs to.
        """
        return pulumi.get(self, "tier_name")

    @tier_name.setter
    def tier_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier_name", value)

    @property
    @pulumi.getter(name="transparentDataEncryption")
    def transparent_data_encryption(self) -> Optional[pulumi.Input['TransparentDataEncryptionArgs']]:
        """
        Transparent Data Encryption properties
        """
        return pulumi.get(self, "transparent_data_encryption")

    @transparent_data_encryption.setter
    def transparent_data_encryption(self, value: Optional[pulumi.Input['TransparentDataEncryptionArgs']]):
        pulumi.set(self, "transparent_data_encryption", value)


if not MYPY:
    class FleetPropertiesArgsDict(TypedDict):
        """
        The Database Fleet properties.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Fleet description.
        """
elif False:
    FleetPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetPropertiesArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None):
        """
        The Database Fleet properties.
        :param pulumi.Input[str] description: Fleet description.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Fleet description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FleetTierPropertiesArgsDict(TypedDict):
        """
        A Fleet tier properties.
        """
        capacity: NotRequired[pulumi.Input[int]]
        """
        Capacity of provisioned resources in the tier, in units matching the specified service tier, for example vCore for GeneralPurpose.
        """
        database_capacity_max: NotRequired[pulumi.Input[float]]
        """
        Maximum allocated capacity per database, in units matching the specified service tier.
        """
        database_capacity_min: NotRequired[pulumi.Input[float]]
        """
        Minimum allocated capacity per database, in units matching the specified service tier.
        """
        database_size_gb_max: NotRequired[pulumi.Input[int]]
        """
        Maximum database size in Gb.
        """
        family: NotRequired[pulumi.Input[str]]
        """
        Family of provisioned resources, for example Gen5.
        """
        high_availability_replica_count: NotRequired[pulumi.Input[int]]
        """
        Number of high availability replicas for databases in this tier.
        """
        pool_num_of_databases_max: NotRequired[pulumi.Input[int]]
        """
        Maximum number of databases per pool.
        """
        pooled: NotRequired[pulumi.Input[bool]]
        """
        If true, databases are pooled.
        """
        serverless: NotRequired[pulumi.Input[bool]]
        """
        If true, serverless resources are provisioned in the tier.
        """
        service_tier: NotRequired[pulumi.Input[str]]
        """
        Service tier of provisioned resources. Supported values: GeneralPurpose, Hyperscale.
        """
        zone_redundancy: NotRequired[pulumi.Input[Union[str, 'ZoneRedundancy']]]
        """
        Enable zone redundancy for all databases in this tier.
        """
elif False:
    FleetTierPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetTierPropertiesArgs:
    def __init__(__self__, *,
                 capacity: Optional[pulumi.Input[int]] = None,
                 database_capacity_max: Optional[pulumi.Input[float]] = None,
                 database_capacity_min: Optional[pulumi.Input[float]] = None,
                 database_size_gb_max: Optional[pulumi.Input[int]] = None,
                 family: Optional[pulumi.Input[str]] = None,
                 high_availability_replica_count: Optional[pulumi.Input[int]] = None,
                 pool_num_of_databases_max: Optional[pulumi.Input[int]] = None,
                 pooled: Optional[pulumi.Input[bool]] = None,
                 serverless: Optional[pulumi.Input[bool]] = None,
                 service_tier: Optional[pulumi.Input[str]] = None,
                 zone_redundancy: Optional[pulumi.Input[Union[str, 'ZoneRedundancy']]] = None):
        """
        A Fleet tier properties.
        :param pulumi.Input[int] capacity: Capacity of provisioned resources in the tier, in units matching the specified service tier, for example vCore for GeneralPurpose.
        :param pulumi.Input[float] database_capacity_max: Maximum allocated capacity per database, in units matching the specified service tier.
        :param pulumi.Input[float] database_capacity_min: Minimum allocated capacity per database, in units matching the specified service tier.
        :param pulumi.Input[int] database_size_gb_max: Maximum database size in Gb.
        :param pulumi.Input[str] family: Family of provisioned resources, for example Gen5.
        :param pulumi.Input[int] high_availability_replica_count: Number of high availability replicas for databases in this tier.
        :param pulumi.Input[int] pool_num_of_databases_max: Maximum number of databases per pool.
        :param pulumi.Input[bool] pooled: If true, databases are pooled.
        :param pulumi.Input[bool] serverless: If true, serverless resources are provisioned in the tier.
        :param pulumi.Input[str] service_tier: Service tier of provisioned resources. Supported values: GeneralPurpose, Hyperscale.
        :param pulumi.Input[Union[str, 'ZoneRedundancy']] zone_redundancy: Enable zone redundancy for all databases in this tier.
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if database_capacity_max is not None:
            pulumi.set(__self__, "database_capacity_max", database_capacity_max)
        if database_capacity_min is not None:
            pulumi.set(__self__, "database_capacity_min", database_capacity_min)
        if database_size_gb_max is not None:
            pulumi.set(__self__, "database_size_gb_max", database_size_gb_max)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if high_availability_replica_count is not None:
            pulumi.set(__self__, "high_availability_replica_count", high_availability_replica_count)
        if pool_num_of_databases_max is not None:
            pulumi.set(__self__, "pool_num_of_databases_max", pool_num_of_databases_max)
        if pooled is not None:
            pulumi.set(__self__, "pooled", pooled)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)
        if service_tier is not None:
            pulumi.set(__self__, "service_tier", service_tier)
        if zone_redundancy is not None:
            pulumi.set(__self__, "zone_redundancy", zone_redundancy)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Capacity of provisioned resources in the tier, in units matching the specified service tier, for example vCore for GeneralPurpose.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter(name="databaseCapacityMax")
    def database_capacity_max(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum allocated capacity per database, in units matching the specified service tier.
        """
        return pulumi.get(self, "database_capacity_max")

    @database_capacity_max.setter
    def database_capacity_max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "database_capacity_max", value)

    @property
    @pulumi.getter(name="databaseCapacityMin")
    def database_capacity_min(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum allocated capacity per database, in units matching the specified service tier.
        """
        return pulumi.get(self, "database_capacity_min")

    @database_capacity_min.setter
    def database_capacity_min(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "database_capacity_min", value)

    @property
    @pulumi.getter(name="databaseSizeGbMax")
    def database_size_gb_max(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum database size in Gb.
        """
        return pulumi.get(self, "database_size_gb_max")

    @database_size_gb_max.setter
    def database_size_gb_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "database_size_gb_max", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        Family of provisioned resources, for example Gen5.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter(name="highAvailabilityReplicaCount")
    def high_availability_replica_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of high availability replicas for databases in this tier.
        """
        return pulumi.get(self, "high_availability_replica_count")

    @high_availability_replica_count.setter
    def high_availability_replica_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "high_availability_replica_count", value)

    @property
    @pulumi.getter(name="poolNumOfDatabasesMax")
    def pool_num_of_databases_max(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of databases per pool.
        """
        return pulumi.get(self, "pool_num_of_databases_max")

    @pool_num_of_databases_max.setter
    def pool_num_of_databases_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pool_num_of_databases_max", value)

    @property
    @pulumi.getter
    def pooled(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, databases are pooled.
        """
        return pulumi.get(self, "pooled")

    @pooled.setter
    def pooled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pooled", value)

    @property
    @pulumi.getter
    def serverless(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, serverless resources are provisioned in the tier.
        """
        return pulumi.get(self, "serverless")

    @serverless.setter
    def serverless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "serverless", value)

    @property
    @pulumi.getter(name="serviceTier")
    def service_tier(self) -> Optional[pulumi.Input[str]]:
        """
        Service tier of provisioned resources. Supported values: GeneralPurpose, Hyperscale.
        """
        return pulumi.get(self, "service_tier")

    @service_tier.setter
    def service_tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_tier", value)

    @property
    @pulumi.getter(name="zoneRedundancy")
    def zone_redundancy(self) -> Optional[pulumi.Input[Union[str, 'ZoneRedundancy']]]:
        """
        Enable zone redundancy for all databases in this tier.
        """
        return pulumi.get(self, "zone_redundancy")

    @zone_redundancy.setter
    def zone_redundancy(self, value: Optional[pulumi.Input[Union[str, 'ZoneRedundancy']]]):
        pulumi.set(self, "zone_redundancy", value)


if not MYPY:
    class FleetspacePropertiesArgsDict(TypedDict):
        """
        A Fleetspace properties.
        """
        capacity_max: NotRequired[pulumi.Input[int]]
        """
        Maximum number of vCores database fleet manager is allowed to provision in the fleetspace.
        """
        main_principal: NotRequired[pulumi.Input['MainPrincipalArgsDict']]
        """
        Main Microsoft Entra ID principal that has admin access to all databases in the fleetspace.
        """
elif False:
    FleetspacePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetspacePropertiesArgs:
    def __init__(__self__, *,
                 capacity_max: Optional[pulumi.Input[int]] = None,
                 main_principal: Optional[pulumi.Input['MainPrincipalArgs']] = None):
        """
        A Fleetspace properties.
        :param pulumi.Input[int] capacity_max: Maximum number of vCores database fleet manager is allowed to provision in the fleetspace.
        :param pulumi.Input['MainPrincipalArgs'] main_principal: Main Microsoft Entra ID principal that has admin access to all databases in the fleetspace.
        """
        if capacity_max is not None:
            pulumi.set(__self__, "capacity_max", capacity_max)
        if main_principal is not None:
            pulumi.set(__self__, "main_principal", main_principal)

    @property
    @pulumi.getter(name="capacityMax")
    def capacity_max(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of vCores database fleet manager is allowed to provision in the fleetspace.
        """
        return pulumi.get(self, "capacity_max")

    @capacity_max.setter
    def capacity_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity_max", value)

    @property
    @pulumi.getter(name="mainPrincipal")
    def main_principal(self) -> Optional[pulumi.Input['MainPrincipalArgs']]:
        """
        Main Microsoft Entra ID principal that has admin access to all databases in the fleetspace.
        """
        return pulumi.get(self, "main_principal")

    @main_principal.setter
    def main_principal(self, value: Optional[pulumi.Input['MainPrincipalArgs']]):
        pulumi.set(self, "main_principal", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Database Identity.
        """
        federated_client_id: NotRequired[pulumi.Input[str]]
        """
        The federated client id for the SQL Database. It is used for cross tenant CMK scenario.
        """
        identity_type: NotRequired[pulumi.Input[Union[str, 'IdentityType']]]
        """
        Identity type of the main principal.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseIdentityArgsDict']]]]
        """
        User identity ids
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 federated_client_id: Optional[pulumi.Input[str]] = None,
                 identity_type: Optional[pulumi.Input[Union[str, 'IdentityType']]] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseIdentityArgs']]]] = None):
        """
        Database Identity.
        :param pulumi.Input[str] federated_client_id: The federated client id for the SQL Database. It is used for cross tenant CMK scenario.
        :param pulumi.Input[Union[str, 'IdentityType']] identity_type: Identity type of the main principal.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseIdentityArgs']]] user_assigned_identities: User identity ids
        """
        if federated_client_id is not None:
            pulumi.set(__self__, "federated_client_id", federated_client_id)
        if identity_type is not None:
            pulumi.set(__self__, "identity_type", identity_type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="federatedClientId")
    def federated_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The federated client id for the SQL Database. It is used for cross tenant CMK scenario.
        """
        return pulumi.get(self, "federated_client_id")

    @federated_client_id.setter
    def federated_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "federated_client_id", value)

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> Optional[pulumi.Input[Union[str, 'IdentityType']]]:
        """
        Identity type of the main principal.
        """
        return pulumi.get(self, "identity_type")

    @identity_type.setter
    def identity_type(self, value: Optional[pulumi.Input[Union[str, 'IdentityType']]]):
        pulumi.set(self, "identity_type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseIdentityArgs']]]]:
        """
        User identity ids
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseIdentityArgs']]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MainPrincipalArgsDict(TypedDict):
        """
        A main principal.
        """
        application_id: NotRequired[pulumi.Input[str]]
        """
        Application Id of the main principal.
        """
        login: NotRequired[pulumi.Input[str]]
        """
        Login name of the main principal.
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        Object Id of the main principal.
        """
        principal_type: NotRequired[pulumi.Input[Union[str, 'PrincipalType']]]
        """
        Principal type of the main principal.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        Tenant Id of the main principal.
        """
elif False:
    MainPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MainPrincipalArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 principal_type: Optional[pulumi.Input[Union[str, 'PrincipalType']]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        A main principal.
        :param pulumi.Input[str] application_id: Application Id of the main principal.
        :param pulumi.Input[str] login: Login name of the main principal.
        :param pulumi.Input[str] object_id: Object Id of the main principal.
        :param pulumi.Input[Union[str, 'PrincipalType']] principal_type: Principal type of the main principal.
        :param pulumi.Input[str] tenant_id: Tenant Id of the main principal.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if principal_type is not None:
            pulumi.set(__self__, "principal_type", principal_type)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        Application Id of the main principal.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input[str]]:
        """
        Login name of the main principal.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        Object Id of the main principal.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> Optional[pulumi.Input[Union[str, 'PrincipalType']]]:
        """
        Principal type of the main principal.
        """
        return pulumi.get(self, "principal_type")

    @principal_type.setter
    def principal_type(self, value: Optional[pulumi.Input[Union[str, 'PrincipalType']]]):
        pulumi.set(self, "principal_type", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Tenant Id of the main principal.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TransparentDataEncryptionArgsDict(TypedDict):
        """
        Transparent Data Encryption properties.
        """
        enable_auto_rotation: NotRequired[pulumi.Input[bool]]
        """
        Enable key auto rotation
        """
        key_uri: NotRequired[pulumi.Input[str]]
        """
        Customer Managed Key (CMK) Uri.
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Additional Keys
        """
elif False:
    TransparentDataEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransparentDataEncryptionArgs:
    def __init__(__self__, *,
                 enable_auto_rotation: Optional[pulumi.Input[bool]] = None,
                 key_uri: Optional[pulumi.Input[str]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Transparent Data Encryption properties.
        :param pulumi.Input[bool] enable_auto_rotation: Enable key auto rotation
        :param pulumi.Input[str] key_uri: Customer Managed Key (CMK) Uri.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: Additional Keys
        """
        if enable_auto_rotation is not None:
            pulumi.set(__self__, "enable_auto_rotation", enable_auto_rotation)
        if key_uri is not None:
            pulumi.set(__self__, "key_uri", key_uri)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter(name="enableAutoRotation")
    def enable_auto_rotation(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable key auto rotation
        """
        return pulumi.get(self, "enable_auto_rotation")

    @enable_auto_rotation.setter
    def enable_auto_rotation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_auto_rotation", value)

    @property
    @pulumi.getter(name="keyUri")
    def key_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Customer Managed Key (CMK) Uri.
        """
        return pulumi.get(self, "key_uri")

    @key_uri.setter
    def key_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_uri", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Additional Keys
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)


