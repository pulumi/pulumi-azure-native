# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'DatabaseIdentityResponse',
    'FirewallRulePropertiesResponse',
    'FleetDatabasePropertiesResponse',
    'FleetPropertiesResponse',
    'FleetTierPropertiesResponse',
    'FleetspacePropertiesResponse',
    'IdentityResponse',
    'MainPrincipalResponse',
    'SystemDataResponse',
    'TransparentDataEncryptionResponse',
]

@pulumi.output_type
class DatabaseIdentityResponse(dict):
    """
    Database Identity properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 principal_id: Optional[builtins.str] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Database Identity properties.
        :param builtins.str client_id: Client Id of the database identity.
        :param builtins.str principal_id: Principal Id of the database identity.
        :param builtins.str resource_id: Resource Id of the database identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        Client Id of the database identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[builtins.str]:
        """
        Principal Id of the database identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        Resource Id of the database identity.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class FirewallRulePropertiesResponse(dict):
    """
    A Firewall rule properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "endIpAddress":
            suggest = "end_ip_address"
        elif key == "startIpAddress":
            suggest = "start_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallRulePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallRulePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallRulePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 end_ip_address: Optional[builtins.str] = None,
                 start_ip_address: Optional[builtins.str] = None):
        """
        A Firewall rule properties.
        :param builtins.str provisioning_state: Provisioning state.
        :param builtins.str end_ip_address: End IP address.
        :param builtins.str start_ip_address: Start IP address.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if end_ip_address is not None:
            pulumi.set(__self__, "end_ip_address", end_ip_address)
        if start_ip_address is not None:
            pulumi.set(__self__, "start_ip_address", start_ip_address)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="endIpAddress")
    def end_ip_address(self) -> Optional[builtins.str]:
        """
        End IP address.
        """
        return pulumi.get(self, "end_ip_address")

    @property
    @pulumi.getter(name="startIpAddress")
    def start_ip_address(self) -> Optional[builtins.str]:
        """
        Start IP address.
        """
        return pulumi.get(self, "start_ip_address")


@pulumi.output_type
class FleetDatabasePropertiesResponse(dict):
    """
    Fleet database properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupRetentionDays":
            suggest = "backup_retention_days"
        elif key == "connectionString":
            suggest = "connection_string"
        elif key == "databaseSizeGbMax":
            suggest = "database_size_gb_max"
        elif key == "earliestRestoreTime":
            suggest = "earliest_restore_time"
        elif key == "latestRestoreTime":
            suggest = "latest_restore_time"
        elif key == "originalDatabaseId":
            suggest = "original_database_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "createMode":
            suggest = "create_mode"
        elif key == "resourceTags":
            suggest = "resource_tags"
        elif key == "restoreFromTime":
            suggest = "restore_from_time"
        elif key == "sourceDatabaseName":
            suggest = "source_database_name"
        elif key == "tierName":
            suggest = "tier_name"
        elif key == "transparentDataEncryption":
            suggest = "transparent_data_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetDatabasePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetDatabasePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetDatabasePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_retention_days: builtins.int,
                 connection_string: builtins.str,
                 database_size_gb_max: builtins.int,
                 earliest_restore_time: builtins.str,
                 latest_restore_time: builtins.str,
                 original_database_id: builtins.str,
                 provisioning_state: builtins.str,
                 recoverable: builtins.bool,
                 collation: Optional[builtins.str] = None,
                 create_mode: Optional[builtins.str] = None,
                 identity: Optional['outputs.IdentityResponse'] = None,
                 resource_tags: Optional[Mapping[str, builtins.str]] = None,
                 restore_from_time: Optional[builtins.str] = None,
                 source_database_name: Optional[builtins.str] = None,
                 tier_name: Optional[builtins.str] = None,
                 transparent_data_encryption: Optional['outputs.TransparentDataEncryptionResponse'] = None):
        """
        Fleet database properties.
        :param builtins.int backup_retention_days: Backup retention in days.
        :param builtins.str connection_string: Connection string to connect to the database with.
        :param builtins.int database_size_gb_max: Maximum database size in Gb.
        :param builtins.str earliest_restore_time: Earliest restore time.
        :param builtins.str latest_restore_time: Latest restore time.
        :param builtins.str original_database_id: Resource identifier for the underlying database resource.
        :param builtins.str provisioning_state: Database state.
        :param builtins.bool recoverable: If true, database is recoverable.
        :param builtins.str collation: Database collation.
        :param builtins.str create_mode: Create mode. Available options: Default - Create a database. Copy - Copy the source database (source database name must be specified) PointInTimeRestore - Create a database by restoring source database from a point in time (source database name and restore from time must be specified)
        :param 'IdentityResponse' identity: Identity property.
        :param Mapping[str, builtins.str] resource_tags: Additional database properties to be applied as the underlying database resource tags.
        :param builtins.str restore_from_time: Restore from time when CreateMode is PointInTimeRestore.
        :param builtins.str source_database_name: Source database name used when CreateMode is Copy or PointInTimeRestore.
        :param builtins.str tier_name: Name of the tier this database belongs to.
        :param 'TransparentDataEncryptionResponse' transparent_data_encryption: Transparent Data Encryption properties
        """
        pulumi.set(__self__, "backup_retention_days", backup_retention_days)
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database_size_gb_max", database_size_gb_max)
        pulumi.set(__self__, "earliest_restore_time", earliest_restore_time)
        pulumi.set(__self__, "latest_restore_time", latest_restore_time)
        pulumi.set(__self__, "original_database_id", original_database_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "recoverable", recoverable)
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if resource_tags is not None:
            pulumi.set(__self__, "resource_tags", resource_tags)
        if restore_from_time is not None:
            pulumi.set(__self__, "restore_from_time", restore_from_time)
        if source_database_name is not None:
            pulumi.set(__self__, "source_database_name", source_database_name)
        if tier_name is not None:
            pulumi.set(__self__, "tier_name", tier_name)
        if transparent_data_encryption is not None:
            pulumi.set(__self__, "transparent_data_encryption", transparent_data_encryption)

    @property
    @pulumi.getter(name="backupRetentionDays")
    def backup_retention_days(self) -> builtins.int:
        """
        Backup retention in days.
        """
        return pulumi.get(self, "backup_retention_days")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> builtins.str:
        """
        Connection string to connect to the database with.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="databaseSizeGbMax")
    def database_size_gb_max(self) -> builtins.int:
        """
        Maximum database size in Gb.
        """
        return pulumi.get(self, "database_size_gb_max")

    @property
    @pulumi.getter(name="earliestRestoreTime")
    def earliest_restore_time(self) -> builtins.str:
        """
        Earliest restore time.
        """
        return pulumi.get(self, "earliest_restore_time")

    @property
    @pulumi.getter(name="latestRestoreTime")
    def latest_restore_time(self) -> builtins.str:
        """
        Latest restore time.
        """
        return pulumi.get(self, "latest_restore_time")

    @property
    @pulumi.getter(name="originalDatabaseId")
    def original_database_id(self) -> builtins.str:
        """
        Resource identifier for the underlying database resource.
        """
        return pulumi.get(self, "original_database_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Database state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def recoverable(self) -> builtins.bool:
        """
        If true, database is recoverable.
        """
        return pulumi.get(self, "recoverable")

    @property
    @pulumi.getter
    def collation(self) -> Optional[builtins.str]:
        """
        Database collation.
        """
        return pulumi.get(self, "collation")

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[builtins.str]:
        """
        Create mode. Available options: Default - Create a database. Copy - Copy the source database (source database name must be specified) PointInTimeRestore - Create a database by restoring source database from a point in time (source database name and restore from time must be specified)
        """
        return pulumi.get(self, "create_mode")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.IdentityResponse']:
        """
        Identity property.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="resourceTags")
    def resource_tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Additional database properties to be applied as the underlying database resource tags.
        """
        return pulumi.get(self, "resource_tags")

    @property
    @pulumi.getter(name="restoreFromTime")
    def restore_from_time(self) -> Optional[builtins.str]:
        """
        Restore from time when CreateMode is PointInTimeRestore.
        """
        return pulumi.get(self, "restore_from_time")

    @property
    @pulumi.getter(name="sourceDatabaseName")
    def source_database_name(self) -> Optional[builtins.str]:
        """
        Source database name used when CreateMode is Copy or PointInTimeRestore.
        """
        return pulumi.get(self, "source_database_name")

    @property
    @pulumi.getter(name="tierName")
    def tier_name(self) -> Optional[builtins.str]:
        """
        Name of the tier this database belongs to.
        """
        return pulumi.get(self, "tier_name")

    @property
    @pulumi.getter(name="transparentDataEncryption")
    def transparent_data_encryption(self) -> Optional['outputs.TransparentDataEncryptionResponse']:
        """
        Transparent Data Encryption properties
        """
        return pulumi.get(self, "transparent_data_encryption")


@pulumi.output_type
class FleetPropertiesResponse(dict):
    """
    The Database Fleet properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 description: Optional[builtins.str] = None):
        """
        The Database Fleet properties.
        :param builtins.str provisioning_state: Provisioning state.
        :param builtins.str description: Fleet description.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Fleet description.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class FleetTierPropertiesResponse(dict):
    """
    A Fleet tier properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "databaseCapacityMax":
            suggest = "database_capacity_max"
        elif key == "databaseCapacityMin":
            suggest = "database_capacity_min"
        elif key == "databaseSizeGbMax":
            suggest = "database_size_gb_max"
        elif key == "highAvailabilityReplicaCount":
            suggest = "high_availability_replica_count"
        elif key == "poolNumOfDatabasesMax":
            suggest = "pool_num_of_databases_max"
        elif key == "serviceTier":
            suggest = "service_tier"
        elif key == "zoneRedundancy":
            suggest = "zone_redundancy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetTierPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetTierPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetTierPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: builtins.bool,
                 provisioning_state: builtins.str,
                 capacity: Optional[builtins.int] = None,
                 database_capacity_max: Optional[builtins.float] = None,
                 database_capacity_min: Optional[builtins.float] = None,
                 database_size_gb_max: Optional[builtins.int] = None,
                 family: Optional[builtins.str] = None,
                 high_availability_replica_count: Optional[builtins.int] = None,
                 pool_num_of_databases_max: Optional[builtins.int] = None,
                 pooled: Optional[builtins.bool] = None,
                 serverless: Optional[builtins.bool] = None,
                 service_tier: Optional[builtins.str] = None,
                 zone_redundancy: Optional[builtins.str] = None):
        """
        A Fleet tier properties.
        :param builtins.bool disabled: If true, tier is disabled.
        :param builtins.str provisioning_state: Provisioning state.
        :param builtins.int capacity: Capacity of provisioned resources in the tier, in units matching the specified service tier, for example vCore for GeneralPurpose.
        :param builtins.float database_capacity_max: Maximum allocated capacity per database, in units matching the specified service tier.
        :param builtins.float database_capacity_min: Minimum allocated capacity per database, in units matching the specified service tier.
        :param builtins.int database_size_gb_max: Maximum database size in Gb.
        :param builtins.str family: Family of provisioned resources, for example Gen5.
        :param builtins.int high_availability_replica_count: Number of high availability replicas for databases in this tier.
        :param builtins.int pool_num_of_databases_max: Maximum number of databases per pool.
        :param builtins.bool pooled: If true, databases are pooled.
        :param builtins.bool serverless: If true, serverless resources are provisioned in the tier.
        :param builtins.str service_tier: Service tier of provisioned resources. Supported values: GeneralPurpose, Hyperscale.
        :param builtins.str zone_redundancy: Enable zone redundancy for all databases in this tier.
        """
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if database_capacity_max is not None:
            pulumi.set(__self__, "database_capacity_max", database_capacity_max)
        if database_capacity_min is not None:
            pulumi.set(__self__, "database_capacity_min", database_capacity_min)
        if database_size_gb_max is not None:
            pulumi.set(__self__, "database_size_gb_max", database_size_gb_max)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if high_availability_replica_count is not None:
            pulumi.set(__self__, "high_availability_replica_count", high_availability_replica_count)
        if pool_num_of_databases_max is not None:
            pulumi.set(__self__, "pool_num_of_databases_max", pool_num_of_databases_max)
        if pooled is not None:
            pulumi.set(__self__, "pooled", pooled)
        if serverless is not None:
            pulumi.set(__self__, "serverless", serverless)
        if service_tier is not None:
            pulumi.set(__self__, "service_tier", service_tier)
        if zone_redundancy is not None:
            pulumi.set(__self__, "zone_redundancy", zone_redundancy)

    @property
    @pulumi.getter
    def disabled(self) -> builtins.bool:
        """
        If true, tier is disabled.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[builtins.int]:
        """
        Capacity of provisioned resources in the tier, in units matching the specified service tier, for example vCore for GeneralPurpose.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter(name="databaseCapacityMax")
    def database_capacity_max(self) -> Optional[builtins.float]:
        """
        Maximum allocated capacity per database, in units matching the specified service tier.
        """
        return pulumi.get(self, "database_capacity_max")

    @property
    @pulumi.getter(name="databaseCapacityMin")
    def database_capacity_min(self) -> Optional[builtins.float]:
        """
        Minimum allocated capacity per database, in units matching the specified service tier.
        """
        return pulumi.get(self, "database_capacity_min")

    @property
    @pulumi.getter(name="databaseSizeGbMax")
    def database_size_gb_max(self) -> Optional[builtins.int]:
        """
        Maximum database size in Gb.
        """
        return pulumi.get(self, "database_size_gb_max")

    @property
    @pulumi.getter
    def family(self) -> Optional[builtins.str]:
        """
        Family of provisioned resources, for example Gen5.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter(name="highAvailabilityReplicaCount")
    def high_availability_replica_count(self) -> Optional[builtins.int]:
        """
        Number of high availability replicas for databases in this tier.
        """
        return pulumi.get(self, "high_availability_replica_count")

    @property
    @pulumi.getter(name="poolNumOfDatabasesMax")
    def pool_num_of_databases_max(self) -> Optional[builtins.int]:
        """
        Maximum number of databases per pool.
        """
        return pulumi.get(self, "pool_num_of_databases_max")

    @property
    @pulumi.getter
    def pooled(self) -> Optional[builtins.bool]:
        """
        If true, databases are pooled.
        """
        return pulumi.get(self, "pooled")

    @property
    @pulumi.getter
    def serverless(self) -> Optional[builtins.bool]:
        """
        If true, serverless resources are provisioned in the tier.
        """
        return pulumi.get(self, "serverless")

    @property
    @pulumi.getter(name="serviceTier")
    def service_tier(self) -> Optional[builtins.str]:
        """
        Service tier of provisioned resources. Supported values: GeneralPurpose, Hyperscale.
        """
        return pulumi.get(self, "service_tier")

    @property
    @pulumi.getter(name="zoneRedundancy")
    def zone_redundancy(self) -> Optional[builtins.str]:
        """
        Enable zone redundancy for all databases in this tier.
        """
        return pulumi.get(self, "zone_redundancy")


@pulumi.output_type
class FleetspacePropertiesResponse(dict):
    """
    A Fleetspace properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "capacityMax":
            suggest = "capacity_max"
        elif key == "mainPrincipal":
            suggest = "main_principal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FleetspacePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FleetspacePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FleetspacePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 capacity_max: Optional[builtins.int] = None,
                 main_principal: Optional['outputs.MainPrincipalResponse'] = None):
        """
        A Fleetspace properties.
        :param builtins.str provisioning_state: Fleetspace state.
        :param builtins.int capacity_max: Maximum number of vCores database fleet manager is allowed to provision in the fleetspace.
        :param 'MainPrincipalResponse' main_principal: Main Microsoft Entra ID principal that has admin access to all databases in the fleetspace.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if capacity_max is not None:
            pulumi.set(__self__, "capacity_max", capacity_max)
        if main_principal is not None:
            pulumi.set(__self__, "main_principal", main_principal)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Fleetspace state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="capacityMax")
    def capacity_max(self) -> Optional[builtins.int]:
        """
        Maximum number of vCores database fleet manager is allowed to provision in the fleetspace.
        """
        return pulumi.get(self, "capacity_max")

    @property
    @pulumi.getter(name="mainPrincipal")
    def main_principal(self) -> Optional['outputs.MainPrincipalResponse']:
        """
        Main Microsoft Entra ID principal that has admin access to all databases in the fleetspace.
        """
        return pulumi.get(self, "main_principal")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Database Identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "federatedClientId":
            suggest = "federated_client_id"
        elif key == "identityType":
            suggest = "identity_type"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 federated_client_id: Optional[builtins.str] = None,
                 identity_type: Optional[builtins.str] = None,
                 user_assigned_identities: Optional[Sequence['outputs.DatabaseIdentityResponse']] = None):
        """
        Database Identity.
        :param builtins.str federated_client_id: The federated client id for the SQL Database. It is used for cross tenant CMK scenario.
        :param builtins.str identity_type: Identity type of the main principal.
        :param Sequence['DatabaseIdentityResponse'] user_assigned_identities: User identity ids
        """
        if federated_client_id is not None:
            pulumi.set(__self__, "federated_client_id", federated_client_id)
        if identity_type is not None:
            pulumi.set(__self__, "identity_type", identity_type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="federatedClientId")
    def federated_client_id(self) -> Optional[builtins.str]:
        """
        The federated client id for the SQL Database. It is used for cross tenant CMK scenario.
        """
        return pulumi.get(self, "federated_client_id")

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> Optional[builtins.str]:
        """
        Identity type of the main principal.
        """
        return pulumi.get(self, "identity_type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Sequence['outputs.DatabaseIdentityResponse']]:
        """
        User identity ids
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MainPrincipalResponse(dict):
    """
    A main principal.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "principalType":
            suggest = "principal_type"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MainPrincipalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MainPrincipalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MainPrincipalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[builtins.str] = None,
                 login: Optional[builtins.str] = None,
                 object_id: Optional[builtins.str] = None,
                 principal_type: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None):
        """
        A main principal.
        :param builtins.str application_id: Application Id of the main principal.
        :param builtins.str login: Login name of the main principal.
        :param builtins.str object_id: Object Id of the main principal.
        :param builtins.str principal_type: Principal type of the main principal.
        :param builtins.str tenant_id: Tenant Id of the main principal.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if principal_type is not None:
            pulumi.set(__self__, "principal_type", principal_type)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[builtins.str]:
        """
        Application Id of the main principal.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter
    def login(self) -> Optional[builtins.str]:
        """
        Login name of the main principal.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[builtins.str]:
        """
        Object Id of the main principal.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> Optional[builtins.str]:
        """
        Principal type of the main principal.
        """
        return pulumi.get(self, "principal_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        Tenant Id of the main principal.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TransparentDataEncryptionResponse(dict):
    """
    Transparent Data Encryption properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableAutoRotation":
            suggest = "enable_auto_rotation"
        elif key == "keyUri":
            suggest = "key_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransparentDataEncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransparentDataEncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransparentDataEncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_auto_rotation: Optional[builtins.bool] = None,
                 key_uri: Optional[builtins.str] = None,
                 keys: Optional[Sequence[builtins.str]] = None):
        """
        Transparent Data Encryption properties.
        :param builtins.bool enable_auto_rotation: Enable key auto rotation
        :param builtins.str key_uri: Customer Managed Key (CMK) Uri.
        :param Sequence[builtins.str] keys: Additional Keys
        """
        if enable_auto_rotation is not None:
            pulumi.set(__self__, "enable_auto_rotation", enable_auto_rotation)
        if key_uri is not None:
            pulumi.set(__self__, "key_uri", key_uri)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter(name="enableAutoRotation")
    def enable_auto_rotation(self) -> Optional[builtins.bool]:
        """
        Enable key auto rotation
        """
        return pulumi.get(self, "enable_auto_rotation")

    @property
    @pulumi.getter(name="keyUri")
    def key_uri(self) -> Optional[builtins.str]:
        """
        Customer Managed Key (CMK) Uri.
        """
        return pulumi.get(self, "key_uri")

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[builtins.str]]:
        """
        Additional Keys
        """
        return pulumi.get(self, "keys")


