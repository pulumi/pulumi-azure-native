# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ClusterSkuArgs',
    'ClusterSkuArgsDict',
    'ColumnArgs',
    'ColumnArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'KeyVaultPropertiesArgs',
    'KeyVaultPropertiesArgsDict',
    'LogAnalyticsQueryPackQueryPropertiesRelatedArgs',
    'LogAnalyticsQueryPackQueryPropertiesRelatedArgsDict',
    'MachineReferenceWithHintsArgs',
    'MachineReferenceWithHintsArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'RestoredLogsArgs',
    'RestoredLogsArgsDict',
    'SchemaArgs',
    'SchemaArgsDict',
    'SearchResultsArgs',
    'SearchResultsArgsDict',
    'StorageAccountArgs',
    'StorageAccountArgsDict',
    'TagArgs',
    'TagArgsDict',
    'WorkspaceCappingArgs',
    'WorkspaceCappingArgsDict',
    'WorkspaceFeaturesArgs',
    'WorkspaceFeaturesArgsDict',
    'WorkspaceSkuArgs',
    'WorkspaceSkuArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterSkuArgsDict(TypedDict):
        """
        The cluster sku definition.
        """
        capacity: NotRequired[pulumi.Input[builtins.float]]
        """
        The capacity reservation level in Gigabytes for this cluster.
        """
        name: NotRequired[pulumi.Input[Union[builtins.str, 'ClusterSkuNameEnum']]]
        """
        The SKU (tier) of a cluster.
        """
elif False:
    ClusterSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSkuArgs:
    def __init__(__self__, *,
                 capacity: Optional[pulumi.Input[builtins.float]] = None,
                 name: Optional[pulumi.Input[Union[builtins.str, 'ClusterSkuNameEnum']]] = None):
        """
        The cluster sku definition.
        :param pulumi.Input[builtins.float] capacity: The capacity reservation level in Gigabytes for this cluster.
        :param pulumi.Input[Union[builtins.str, 'ClusterSkuNameEnum']] name: The SKU (tier) of a cluster.
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The capacity reservation level in Gigabytes for this cluster.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[Union[builtins.str, 'ClusterSkuNameEnum']]]:
        """
        The SKU (tier) of a cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[Union[builtins.str, 'ClusterSkuNameEnum']]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ColumnArgsDict(TypedDict):
        """
        Table column.
        """
        data_type_hint: NotRequired[pulumi.Input[Union[builtins.str, 'ColumnDataTypeHintEnum']]]
        """
        Column data type logical hint.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Column description.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Column display name.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Column name.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'ColumnTypeEnum']]]
        """
        Column data type.
        """
elif False:
    ColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ColumnArgs:
    def __init__(__self__, *,
                 data_type_hint: Optional[pulumi.Input[Union[builtins.str, 'ColumnDataTypeHintEnum']]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'ColumnTypeEnum']]] = None):
        """
        Table column.
        :param pulumi.Input[Union[builtins.str, 'ColumnDataTypeHintEnum']] data_type_hint: Column data type logical hint.
        :param pulumi.Input[builtins.str] description: Column description.
        :param pulumi.Input[builtins.str] display_name: Column display name.
        :param pulumi.Input[builtins.str] name: Column name.
        :param pulumi.Input[Union[builtins.str, 'ColumnTypeEnum']] type: Column data type.
        """
        if data_type_hint is not None:
            pulumi.set(__self__, "data_type_hint", data_type_hint)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dataTypeHint")
    def data_type_hint(self) -> Optional[pulumi.Input[Union[builtins.str, 'ColumnDataTypeHintEnum']]]:
        """
        Column data type logical hint.
        """
        return pulumi.get(self, "data_type_hint")

    @data_type_hint.setter
    def data_type_hint(self, value: Optional[pulumi.Input[Union[builtins.str, 'ColumnDataTypeHintEnum']]]):
        pulumi.set(self, "data_type_hint", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Column name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ColumnTypeEnum']]]:
        """
        Column data type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ColumnTypeEnum']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: pulumi.Input['IdentityType']
        """
        Type of managed service identity.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['IdentityType'],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Identity for the resource.
        :param pulumi.Input['IdentityType'] type: Type of managed service identity.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['IdentityType']:
        """
        Type of managed service identity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['IdentityType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class KeyVaultPropertiesArgsDict(TypedDict):
        """
        The key vault properties.
        """
        key_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the key associated with the Log Analytics cluster.
        """
        key_rsa_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Selected key minimum required size.
        """
        key_vault_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The Key Vault uri which holds they key associated with the Log Analytics cluster.
        """
        key_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The version of the key associated with the Log Analytics cluster.
        """
elif False:
    KeyVaultPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 key_name: Optional[pulumi.Input[builtins.str]] = None,
                 key_rsa_size: Optional[pulumi.Input[builtins.int]] = None,
                 key_vault_uri: Optional[pulumi.Input[builtins.str]] = None,
                 key_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        The key vault properties.
        :param pulumi.Input[builtins.str] key_name: The name of the key associated with the Log Analytics cluster.
        :param pulumi.Input[builtins.int] key_rsa_size: Selected key minimum required size.
        :param pulumi.Input[builtins.str] key_vault_uri: The Key Vault uri which holds they key associated with the Log Analytics cluster.
        :param pulumi.Input[builtins.str] key_version: The version of the key associated with the Log Analytics cluster.
        """
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_rsa_size is not None:
            pulumi.set(__self__, "key_rsa_size", key_rsa_size)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the key associated with the Log Analytics cluster.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter(name="keyRsaSize")
    def key_rsa_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Selected key minimum required size.
        """
        return pulumi.get(self, "key_rsa_size")

    @key_rsa_size.setter
    def key_rsa_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "key_rsa_size", value)

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Key Vault uri which holds they key associated with the Log Analytics cluster.
        """
        return pulumi.get(self, "key_vault_uri")

    @key_vault_uri.setter
    def key_vault_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_vault_uri", value)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version of the key associated with the Log Analytics cluster.
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_version", value)


if not MYPY:
    class LogAnalyticsQueryPackQueryPropertiesRelatedArgsDict(TypedDict):
        """
        The related metadata items for the function.
        """
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The related categories for the function.
        """
        resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The related resource types for the function.
        """
        solutions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The related Log Analytics solutions for the function.
        """
elif False:
    LogAnalyticsQueryPackQueryPropertiesRelatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsQueryPackQueryPropertiesRelatedArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 solutions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The related metadata items for the function.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] categories: The related categories for the function.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] resource_types: The related resource types for the function.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] solutions: The related Log Analytics solutions for the function.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if solutions is not None:
            pulumi.set(__self__, "solutions", solutions)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The related categories for the function.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The related resource types for the function.
        """
        return pulumi.get(self, "resource_types")

    @resource_types.setter
    def resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "resource_types", value)

    @property
    @pulumi.getter
    def solutions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The related Log Analytics solutions for the function.
        """
        return pulumi.get(self, "solutions")

    @solutions.setter
    def solutions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "solutions", value)


if not MYPY:
    class MachineReferenceWithHintsArgsDict(TypedDict):
        """
        A machine reference with a hint of the machine's name and operating system.
        """
        id: pulumi.Input[builtins.str]
        """
        Resource URI.
        """
        kind: pulumi.Input[builtins.str]
        """
        Specifies the sub-class of the reference.
        Expected value is 'ref:machinewithhints'.
        """
elif False:
    MachineReferenceWithHintsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineReferenceWithHintsArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 kind: pulumi.Input[builtins.str]):
        """
        A machine reference with a hint of the machine's name and operating system.
        :param pulumi.Input[builtins.str] id: Resource URI.
        :param pulumi.Input[builtins.str] kind: Specifies the sub-class of the reference.
               Expected value is 'ref:machinewithhints'.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kind", 'ref:machinewithhints')

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Resource URI.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the sub-class of the reference.
        Expected value is 'ref:machinewithhints'.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class RestoredLogsArgsDict(TypedDict):
        """
        Restore parameters.
        """
        end_restore_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The timestamp to end the restore by (UTC).
        """
        source_table: NotRequired[pulumi.Input[builtins.str]]
        """
        The table to restore data from.
        """
        start_restore_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The timestamp to start the restore from (UTC).
        """
elif False:
    RestoredLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RestoredLogsArgs:
    def __init__(__self__, *,
                 end_restore_time: Optional[pulumi.Input[builtins.str]] = None,
                 source_table: Optional[pulumi.Input[builtins.str]] = None,
                 start_restore_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Restore parameters.
        :param pulumi.Input[builtins.str] end_restore_time: The timestamp to end the restore by (UTC).
        :param pulumi.Input[builtins.str] source_table: The table to restore data from.
        :param pulumi.Input[builtins.str] start_restore_time: The timestamp to start the restore from (UTC).
        """
        if end_restore_time is not None:
            pulumi.set(__self__, "end_restore_time", end_restore_time)
        if source_table is not None:
            pulumi.set(__self__, "source_table", source_table)
        if start_restore_time is not None:
            pulumi.set(__self__, "start_restore_time", start_restore_time)

    @property
    @pulumi.getter(name="endRestoreTime")
    def end_restore_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The timestamp to end the restore by (UTC).
        """
        return pulumi.get(self, "end_restore_time")

    @end_restore_time.setter
    def end_restore_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_restore_time", value)

    @property
    @pulumi.getter(name="sourceTable")
    def source_table(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The table to restore data from.
        """
        return pulumi.get(self, "source_table")

    @source_table.setter
    def source_table(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_table", value)

    @property
    @pulumi.getter(name="startRestoreTime")
    def start_restore_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The timestamp to start the restore from (UTC).
        """
        return pulumi.get(self, "start_restore_time")

    @start_restore_time.setter
    def start_restore_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_restore_time", value)


if not MYPY:
    class SchemaArgsDict(TypedDict):
        """
        Table's schema.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ColumnArgsDict']]]]
        """
        A list of table custom columns.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Table description.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Table display name.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Table name.
        """
elif False:
    SchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Table's schema.
        :param pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]] columns: A list of table custom columns.
        :param pulumi.Input[builtins.str] description: Table description.
        :param pulumi.Input[builtins.str] display_name: Table display name.
        :param pulumi.Input[builtins.str] name: Table name.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]]:
        """
        A list of table custom columns.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Table description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Table display name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Table name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SearchResultsArgsDict(TypedDict):
        """
        Parameters of the search job that initiated this table.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Search job Description.
        """
        end_search_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The timestamp to end the search by (UTC)
        """
        limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Limit the search job to return up to specified number of rows.
        """
        query: NotRequired[pulumi.Input[builtins.str]]
        """
        Search job query.
        """
        start_search_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The timestamp to start the search from (UTC)
        """
elif False:
    SearchResultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SearchResultsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 end_search_time: Optional[pulumi.Input[builtins.str]] = None,
                 limit: Optional[pulumi.Input[builtins.int]] = None,
                 query: Optional[pulumi.Input[builtins.str]] = None,
                 start_search_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Parameters of the search job that initiated this table.
        :param pulumi.Input[builtins.str] description: Search job Description.
        :param pulumi.Input[builtins.str] end_search_time: The timestamp to end the search by (UTC)
        :param pulumi.Input[builtins.int] limit: Limit the search job to return up to specified number of rows.
        :param pulumi.Input[builtins.str] query: Search job query.
        :param pulumi.Input[builtins.str] start_search_time: The timestamp to start the search from (UTC)
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if end_search_time is not None:
            pulumi.set(__self__, "end_search_time", end_search_time)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if start_search_time is not None:
            pulumi.set(__self__, "start_search_time", start_search_time)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Search job Description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="endSearchTime")
    def end_search_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The timestamp to end the search by (UTC)
        """
        return pulumi.get(self, "end_search_time")

    @end_search_time.setter
    def end_search_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_search_time", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Limit the search job to return up to specified number of rows.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Search job query.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="startSearchTime")
    def start_search_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The timestamp to start the search from (UTC)
        """
        return pulumi.get(self, "start_search_time")

    @start_search_time.setter
    def start_search_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_search_time", value)


if not MYPY:
    class StorageAccountArgsDict(TypedDict):
        """
        Describes a storage account connection.
        """
        id: pulumi.Input[builtins.str]
        """
        The Azure Resource Manager ID of the storage account resource.
        """
        key: pulumi.Input[builtins.str]
        """
        The storage account key.
        """
elif False:
    StorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageAccountArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 key: pulumi.Input[builtins.str]):
        """
        Describes a storage account connection.
        :param pulumi.Input[builtins.str] id: The Azure Resource Manager ID of the storage account resource.
        :param pulumi.Input[builtins.str] key: The storage account key.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The Azure Resource Manager ID of the storage account resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The storage account key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class TagArgsDict(TypedDict):
        """
        A tag of a saved search.
        """
        name: pulumi.Input[builtins.str]
        """
        The tag name.
        """
        value: pulumi.Input[builtins.str]
        """
        The tag value.
        """
elif False:
    TagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        A tag of a saved search.
        :param pulumi.Input[builtins.str] name: The tag name.
        :param pulumi.Input[builtins.str] value: The tag value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The tag name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WorkspaceCappingArgsDict(TypedDict):
        """
        The daily volume cap for ingestion.
        """
        daily_quota_gb: NotRequired[pulumi.Input[builtins.float]]
        """
        The workspace daily quota for ingestion.
        """
elif False:
    WorkspaceCappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceCappingArgs:
    def __init__(__self__, *,
                 daily_quota_gb: Optional[pulumi.Input[builtins.float]] = None):
        """
        The daily volume cap for ingestion.
        :param pulumi.Input[builtins.float] daily_quota_gb: The workspace daily quota for ingestion.
        """
        if daily_quota_gb is not None:
            pulumi.set(__self__, "daily_quota_gb", daily_quota_gb)

    @property
    @pulumi.getter(name="dailyQuotaGb")
    def daily_quota_gb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The workspace daily quota for ingestion.
        """
        return pulumi.get(self, "daily_quota_gb")

    @daily_quota_gb.setter
    def daily_quota_gb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "daily_quota_gb", value)


if not MYPY:
    class WorkspaceFeaturesArgsDict(TypedDict):
        """
        Workspace features.
        """
        cluster_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Dedicated LA cluster resourceId that is linked to the workspaces.
        """
        disable_local_auth: NotRequired[pulumi.Input[builtins.bool]]
        """
        Disable Non-AAD based Auth.
        """
        enable_data_export: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag that indicate if data should be exported.
        """
        enable_log_access_using_only_resource_permissions: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag that indicate which permission to use - resource or workspace or both.
        """
        immediate_purge_data_on30_days: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag that describes if we want to remove the data after 30 days.
        """
elif False:
    WorkspaceFeaturesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceFeaturesArgs:
    def __init__(__self__, *,
                 cluster_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 disable_local_auth: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_data_export: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_log_access_using_only_resource_permissions: Optional[pulumi.Input[builtins.bool]] = None,
                 immediate_purge_data_on30_days: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Workspace features.
        :param pulumi.Input[builtins.str] cluster_resource_id: Dedicated LA cluster resourceId that is linked to the workspaces.
        :param pulumi.Input[builtins.bool] disable_local_auth: Disable Non-AAD based Auth.
        :param pulumi.Input[builtins.bool] enable_data_export: Flag that indicate if data should be exported.
        :param pulumi.Input[builtins.bool] enable_log_access_using_only_resource_permissions: Flag that indicate which permission to use - resource or workspace or both.
        :param pulumi.Input[builtins.bool] immediate_purge_data_on30_days: Flag that describes if we want to remove the data after 30 days.
        """
        if cluster_resource_id is not None:
            pulumi.set(__self__, "cluster_resource_id", cluster_resource_id)
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if enable_data_export is not None:
            pulumi.set(__self__, "enable_data_export", enable_data_export)
        if enable_log_access_using_only_resource_permissions is not None:
            pulumi.set(__self__, "enable_log_access_using_only_resource_permissions", enable_log_access_using_only_resource_permissions)
        if immediate_purge_data_on30_days is not None:
            pulumi.set(__self__, "immediate_purge_data_on30_days", immediate_purge_data_on30_days)

    @property
    @pulumi.getter(name="clusterResourceId")
    def cluster_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Dedicated LA cluster resourceId that is linked to the workspaces.
        """
        return pulumi.get(self, "cluster_resource_id")

    @cluster_resource_id.setter
    def cluster_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_resource_id", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Disable Non-AAD based Auth.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter(name="enableDataExport")
    def enable_data_export(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag that indicate if data should be exported.
        """
        return pulumi.get(self, "enable_data_export")

    @enable_data_export.setter
    def enable_data_export(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_data_export", value)

    @property
    @pulumi.getter(name="enableLogAccessUsingOnlyResourcePermissions")
    def enable_log_access_using_only_resource_permissions(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag that indicate which permission to use - resource or workspace or both.
        """
        return pulumi.get(self, "enable_log_access_using_only_resource_permissions")

    @enable_log_access_using_only_resource_permissions.setter
    def enable_log_access_using_only_resource_permissions(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_log_access_using_only_resource_permissions", value)

    @property
    @pulumi.getter(name="immediatePurgeDataOn30Days")
    def immediate_purge_data_on30_days(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag that describes if we want to remove the data after 30 days.
        """
        return pulumi.get(self, "immediate_purge_data_on30_days")

    @immediate_purge_data_on30_days.setter
    def immediate_purge_data_on30_days(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "immediate_purge_data_on30_days", value)


if not MYPY:
    class WorkspaceSkuArgsDict(TypedDict):
        """
        The SKU (tier) of a workspace.
        """
        name: pulumi.Input[Union[builtins.str, 'WorkspaceSkuNameEnum']]
        """
        The name of the SKU.
        """
        capacity_reservation_level: NotRequired[pulumi.Input[builtins.int]]
        """
        The capacity reservation level in GB for this workspace, when CapacityReservation sku is selected.
        """
elif False:
    WorkspaceSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceSkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[Union[builtins.str, 'WorkspaceSkuNameEnum']],
                 capacity_reservation_level: Optional[pulumi.Input[builtins.int]] = None):
        """
        The SKU (tier) of a workspace.
        :param pulumi.Input[Union[builtins.str, 'WorkspaceSkuNameEnum']] name: The name of the SKU.
        :param pulumi.Input[builtins.int] capacity_reservation_level: The capacity reservation level in GB for this workspace, when CapacityReservation sku is selected.
        """
        pulumi.set(__self__, "name", name)
        if capacity_reservation_level is not None:
            pulumi.set(__self__, "capacity_reservation_level", capacity_reservation_level)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[Union[builtins.str, 'WorkspaceSkuNameEnum']]:
        """
        The name of the SKU.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[Union[builtins.str, 'WorkspaceSkuNameEnum']]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="capacityReservationLevel")
    def capacity_reservation_level(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The capacity reservation level in GB for this workspace, when CapacityReservation sku is selected.
        """
        return pulumi.get(self, "capacity_reservation_level")

    @capacity_reservation_level.setter
    def capacity_reservation_level(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "capacity_reservation_level", value)


