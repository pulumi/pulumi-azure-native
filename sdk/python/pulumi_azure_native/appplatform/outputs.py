# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AcceleratorBasicAuthSettingResponse',
    'AcceleratorGitRepositoryResponse',
    'AcceleratorPublicSettingResponse',
    'AcceleratorSshSettingResponse',
    'ApiPortalCustomDomainPropertiesResponse',
    'ApiPortalInstanceResponse',
    'ApiPortalPropertiesResponse',
    'ApiPortalResourceRequestsResponse',
    'ApmPropertiesResponse',
    'ApmReferenceResponse',
    'AppResourcePropertiesResponse',
    'AppVNetAddonsResponse',
    'ApplicationAcceleratorComponentResponse',
    'ApplicationAcceleratorInstanceResponse',
    'ApplicationAcceleratorPropertiesResponse',
    'ApplicationAcceleratorResourceRequestsResponse',
    'ApplicationInsightsAgentVersionsResponse',
    'ApplicationLiveViewComponentResponse',
    'ApplicationLiveViewInstanceResponse',
    'ApplicationLiveViewPropertiesResponse',
    'ApplicationLiveViewResourceRequestsResponse',
    'AzureFileVolumeResponse',
    'BindingResourcePropertiesResponse',
    'BuildPropertiesResponse',
    'BuildResourceRequestsResponse',
    'BuildResultUserSourceInfoResponse',
    'BuildServiceAgentPoolPropertiesResponse',
    'BuildServiceAgentPoolSizePropertiesResponse',
    'BuilderPropertiesResponse',
    'BuildpackBindingLaunchPropertiesResponse',
    'BuildpackBindingPropertiesResponse',
    'BuildpackPropertiesResponse',
    'BuildpacksGroupPropertiesResponse',
    'CertificateReferenceResponse',
    'ClusterResourcePropertiesResponse',
    'ConfigServerGitPropertyResponse',
    'ConfigServerPropertiesResponse',
    'ConfigServerSettingsResponse',
    'ConfigurationServiceGitPropertyResponse',
    'ConfigurationServiceGitRepositoryResponse',
    'ConfigurationServiceInstanceResponse',
    'ConfigurationServicePropertiesResponse',
    'ConfigurationServiceResourceRequestsResponse',
    'ConfigurationServiceSettingsResponse',
    'ContainerProbeSettingsResponse',
    'ContainerRegistryBasicCredentialsResponse',
    'ContainerRegistryPropertiesResponse',
    'ContentCertificatePropertiesResponse',
    'CustomContainerResponse',
    'CustomContainerUserSourceInfoResponse',
    'CustomDomainPropertiesResponse',
    'CustomPersistentDiskResourceResponse',
    'CustomScaleRuleResponse',
    'CustomizedAcceleratorPropertiesResponse',
    'DeploymentInstanceResponse',
    'DeploymentResourcePropertiesResponse',
    'DeploymentSettingsResponse',
    'DevToolPortalComponentResponse',
    'DevToolPortalFeatureDetailResponse',
    'DevToolPortalFeatureSettingsResponse',
    'DevToolPortalInstanceResponse',
    'DevToolPortalPropertiesResponse',
    'DevToolPortalResourceRequestsResponse',
    'DevToolPortalSsoPropertiesResponse',
    'EnvVarResponse',
    'ErrorResponse',
    'ExecActionResponse',
    'GatewayApiMetadataPropertiesResponse',
    'GatewayApiRouteResponse',
    'GatewayCorsPropertiesResponse',
    'GatewayCustomDomainPropertiesResponse',
    'GatewayInstanceResponse',
    'GatewayLocalResponseCachePerInstancePropertiesResponse',
    'GatewayLocalResponseCachePerRoutePropertiesResponse',
    'GatewayOperatorPropertiesResponse',
    'GatewayOperatorResourceRequestsResponse',
    'GatewayPropertiesResponse',
    'GatewayPropertiesResponseClientAuth',
    'GatewayPropertiesResponseEnvironmentVariables',
    'GatewayResourceRequestsResponse',
    'GatewayRouteConfigOpenApiPropertiesResponse',
    'GatewayRouteConfigPropertiesResponse',
    'GitPatternRepositoryResponse',
    'HTTPGetActionResponse',
    'HttpScaleRuleResponse',
    'ImageRegistryCredentialResponse',
    'IngressConfigResponse',
    'IngressSettingsResponse',
    'IngressSettingsResponseClientAuth',
    'JarUploadedUserSourceInfoResponse',
    'JobExecutionTemplateResponse',
    'JobResourcePropertiesResponse',
    'JobResourceRequestsResponse',
    'KeyVaultCertificatePropertiesResponse',
    'LoadedCertificateResponse',
    'ManagedComponentReferenceResponse',
    'ManagedIdentityPropertiesResponse',
    'ManualJobTriggerConfigResponse',
    'MarketplaceResourceResponse',
    'MonitoringSettingPropertiesResponse',
    'NetCoreZipUploadedUserSourceInfoResponse',
    'NetworkProfileResponse',
    'NetworkProfileResponseOutboundIPs',
    'PersistentDiskResponse',
    'ProbeResponse',
    'QueueScaleRuleResponse',
    'RequiredTrafficResponse',
    'ResourceRequestsResponse',
    'ScaleResponse',
    'ScaleRuleAuthResponse',
    'ScaleRuleResponse',
    'SecretResponse',
    'ServiceRegistryInstanceResponse',
    'ServiceRegistryPropertiesResponse',
    'ServiceRegistryResourceRequestsResponse',
    'ServiceVNetAddonsResponse',
    'SkuResponse',
    'SourceUploadedUserSourceInfoResponse',
    'SsoPropertiesResponse',
    'StackPropertiesResponse',
    'StorageAccountResponse',
    'SystemDataResponse',
    'TCPSocketActionResponse',
    'TcpScaleRuleResponse',
    'TemporaryDiskResponse',
    'TriggeredBuildResultResponse',
    'UploadedUserSourceInfoResponse',
    'UserAssignedManagedIdentityResponse',
    'WarUploadedUserSourceInfoResponse',
    'WeeklyMaintenanceScheduleConfigurationResponse',
]

@pulumi.output_type
class AcceleratorBasicAuthSettingResponse(dict):
    """
    Auth setting for basic auth.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "caCertResourceId":
            suggest = "ca_cert_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AcceleratorBasicAuthSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AcceleratorBasicAuthSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AcceleratorBasicAuthSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 username: builtins.str,
                 ca_cert_resource_id: Optional[builtins.str] = None):
        """
        Auth setting for basic auth.
        :param builtins.str auth_type: The type of the auth setting.
               Expected value is 'BasicAuth'.
        :param builtins.str username: Username of git repository basic auth.
        :param builtins.str ca_cert_resource_id: Resource Id of CA certificate for https URL of Git repository.
        """
        pulumi.set(__self__, "auth_type", 'BasicAuth')
        pulumi.set(__self__, "username", username)
        if ca_cert_resource_id is not None:
            pulumi.set(__self__, "ca_cert_resource_id", ca_cert_resource_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        The type of the auth setting.
        Expected value is 'BasicAuth'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        Username of git repository basic auth.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="caCertResourceId")
    def ca_cert_resource_id(self) -> Optional[builtins.str]:
        """
        Resource Id of CA certificate for https URL of Git repository.
        """
        return pulumi.get(self, "ca_cert_resource_id")


@pulumi.output_type
class AcceleratorGitRepositoryResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authSetting":
            suggest = "auth_setting"
        elif key == "gitTag":
            suggest = "git_tag"
        elif key == "intervalInSeconds":
            suggest = "interval_in_seconds"
        elif key == "subPath":
            suggest = "sub_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AcceleratorGitRepositoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AcceleratorGitRepositoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AcceleratorGitRepositoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_setting: Any,
                 url: builtins.str,
                 branch: Optional[builtins.str] = None,
                 commit: Optional[builtins.str] = None,
                 git_tag: Optional[builtins.str] = None,
                 interval_in_seconds: Optional[builtins.int] = None,
                 sub_path: Optional[builtins.str] = None):
        """
        :param Union['AcceleratorBasicAuthSettingResponse', 'AcceleratorPublicSettingResponse', 'AcceleratorSshSettingResponse'] auth_setting: Properties of the auth setting payload.
        :param builtins.str url: Git repository URL for the accelerator.
        :param builtins.str branch: Git repository branch to be used.
        :param builtins.str commit: Git repository commit to be used.
        :param builtins.str git_tag: Git repository tag to be used.
        :param builtins.int interval_in_seconds: Interval for checking for updates to Git or image repository.
        :param builtins.str sub_path: Folder path inside the git repository to consider as the root of the accelerator or fragment.
        """
        pulumi.set(__self__, "auth_setting", auth_setting)
        pulumi.set(__self__, "url", url)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit is not None:
            pulumi.set(__self__, "commit", commit)
        if git_tag is not None:
            pulumi.set(__self__, "git_tag", git_tag)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)

    @property
    @pulumi.getter(name="authSetting")
    def auth_setting(self) -> Any:
        """
        Properties of the auth setting payload.
        """
        return pulumi.get(self, "auth_setting")

    @property
    @pulumi.getter
    def url(self) -> builtins.str:
        """
        Git repository URL for the accelerator.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def branch(self) -> Optional[builtins.str]:
        """
        Git repository branch to be used.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter
    def commit(self) -> Optional[builtins.str]:
        """
        Git repository commit to be used.
        """
        return pulumi.get(self, "commit")

    @property
    @pulumi.getter(name="gitTag")
    def git_tag(self) -> Optional[builtins.str]:
        """
        Git repository tag to be used.
        """
        return pulumi.get(self, "git_tag")

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[builtins.int]:
        """
        Interval for checking for updates to Git or image repository.
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[builtins.str]:
        """
        Folder path inside the git repository to consider as the root of the accelerator or fragment.
        """
        return pulumi.get(self, "sub_path")


@pulumi.output_type
class AcceleratorPublicSettingResponse(dict):
    """
    Auth setting for public url.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "caCertResourceId":
            suggest = "ca_cert_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AcceleratorPublicSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AcceleratorPublicSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AcceleratorPublicSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str,
                 ca_cert_resource_id: Optional[builtins.str] = None):
        """
        Auth setting for public url.
        :param builtins.str auth_type: The type of the auth setting.
               Expected value is 'Public'.
        :param builtins.str ca_cert_resource_id: Resource Id of CA certificate for https URL of Git repository.
        """
        pulumi.set(__self__, "auth_type", 'Public')
        if ca_cert_resource_id is not None:
            pulumi.set(__self__, "ca_cert_resource_id", ca_cert_resource_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        The type of the auth setting.
        Expected value is 'Public'.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="caCertResourceId")
    def ca_cert_resource_id(self) -> Optional[builtins.str]:
        """
        Resource Id of CA certificate for https URL of Git repository.
        """
        return pulumi.get(self, "ca_cert_resource_id")


@pulumi.output_type
class AcceleratorSshSettingResponse(dict):
    """
    Auth setting for SSH auth.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AcceleratorSshSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AcceleratorSshSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AcceleratorSshSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: builtins.str):
        """
        Auth setting for SSH auth.
        :param builtins.str auth_type: The type of the auth setting.
               Expected value is 'SSH'.
        """
        pulumi.set(__self__, "auth_type", 'SSH')

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        The type of the auth setting.
        Expected value is 'SSH'.
        """
        return pulumi.get(self, "auth_type")


@pulumi.output_type
class ApiPortalCustomDomainPropertiesResponse(dict):
    """
    The properties of custom domain for API portal
    """
    def __init__(__self__, *,
                 thumbprint: Optional[builtins.str] = None):
        """
        The properties of custom domain for API portal
        :param builtins.str thumbprint: The thumbprint of bound certificate.
        """
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of bound certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class ApiPortalInstanceResponse(dict):
    """
    Collection of instances belong to the API portal
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 status: builtins.str):
        """
        Collection of instances belong to the API portal
        :param builtins.str name: Name of the API portal instance
        :param builtins.str status: Status of the API portal instance
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the API portal instance
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the API portal instance
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ApiPortalPropertiesResponse(dict):
    """
    API portal properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceRequests":
            suggest = "resource_requests"
        elif key == "apiTryOutEnabledState":
            suggest = "api_try_out_enabled_state"
        elif key == "gatewayIds":
            suggest = "gateway_ids"
        elif key == "httpsOnly":
            suggest = "https_only"
        elif key == "sourceUrls":
            suggest = "source_urls"
        elif key == "ssoProperties":
            suggest = "sso_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiPortalPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiPortalPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiPortalPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.ApiPortalInstanceResponse'],
                 provisioning_state: builtins.str,
                 resource_requests: 'outputs.ApiPortalResourceRequestsResponse',
                 url: builtins.str,
                 api_try_out_enabled_state: Optional[builtins.str] = None,
                 gateway_ids: Optional[Sequence[builtins.str]] = None,
                 https_only: Optional[builtins.bool] = None,
                 public: Optional[builtins.bool] = None,
                 source_urls: Optional[Sequence[builtins.str]] = None,
                 sso_properties: Optional['outputs.SsoPropertiesResponse'] = None):
        """
        API portal properties payload
        :param Sequence['ApiPortalInstanceResponse'] instances: Collection of instances belong to API portal.
        :param builtins.str provisioning_state: State of the API portal.
        :param 'ApiPortalResourceRequestsResponse' resource_requests: The requested resource quantity for required CPU and Memory.
        :param builtins.str url: URL of the API portal, exposed when 'public' is true.
        :param builtins.str api_try_out_enabled_state: Indicates whether the API try-out feature is enabled or disabled. When enabled, users can try out the API by sending requests and viewing responses in API portal. When disabled, users cannot try out the API.
        :param Sequence[builtins.str] gateway_ids: The array of resource Ids of gateway to integrate with API portal.
        :param builtins.bool https_only: Indicate if only https is allowed.
        :param builtins.bool public: Indicates whether the API portal exposes endpoint.
        :param Sequence[builtins.str] source_urls: Collection of OpenAPI source URL locations.
        :param 'SsoPropertiesResponse' sso_properties: Single sign-on related configuration
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "resource_requests", resource_requests)
        pulumi.set(__self__, "url", url)
        if api_try_out_enabled_state is None:
            api_try_out_enabled_state = 'Enabled'
        if api_try_out_enabled_state is not None:
            pulumi.set(__self__, "api_try_out_enabled_state", api_try_out_enabled_state)
        if gateway_ids is not None:
            pulumi.set(__self__, "gateway_ids", gateway_ids)
        if https_only is None:
            https_only = False
        if https_only is not None:
            pulumi.set(__self__, "https_only", https_only)
        if public is None:
            public = False
        if public is not None:
            pulumi.set(__self__, "public", public)
        if source_urls is not None:
            pulumi.set(__self__, "source_urls", source_urls)
        if sso_properties is not None:
            pulumi.set(__self__, "sso_properties", sso_properties)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.ApiPortalInstanceResponse']:
        """
        Collection of instances belong to API portal.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the API portal.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> 'outputs.ApiPortalResourceRequestsResponse':
        """
        The requested resource quantity for required CPU and Memory.
        """
        return pulumi.get(self, "resource_requests")

    @property
    @pulumi.getter
    def url(self) -> builtins.str:
        """
        URL of the API portal, exposed when 'public' is true.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="apiTryOutEnabledState")
    def api_try_out_enabled_state(self) -> Optional[builtins.str]:
        """
        Indicates whether the API try-out feature is enabled or disabled. When enabled, users can try out the API by sending requests and viewing responses in API portal. When disabled, users cannot try out the API.
        """
        return pulumi.get(self, "api_try_out_enabled_state")

    @property
    @pulumi.getter(name="gatewayIds")
    def gateway_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        The array of resource Ids of gateway to integrate with API portal.
        """
        return pulumi.get(self, "gateway_ids")

    @property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> Optional[builtins.bool]:
        """
        Indicate if only https is allowed.
        """
        return pulumi.get(self, "https_only")

    @property
    @pulumi.getter
    def public(self) -> Optional[builtins.bool]:
        """
        Indicates whether the API portal exposes endpoint.
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="sourceUrls")
    def source_urls(self) -> Optional[Sequence[builtins.str]]:
        """
        Collection of OpenAPI source URL locations.
        """
        return pulumi.get(self, "source_urls")

    @property
    @pulumi.getter(name="ssoProperties")
    def sso_properties(self) -> Optional['outputs.SsoPropertiesResponse']:
        """
        Single sign-on related configuration
        """
        return pulumi.get(self, "sso_properties")


@pulumi.output_type
class ApiPortalResourceRequestsResponse(dict):
    """
    Resource requests of the API portal
    """
    def __init__(__self__, *,
                 cpu: builtins.str,
                 memory: builtins.str):
        """
        Resource requests of the API portal
        :param builtins.str cpu: Cpu allocated to each API portal instance
        :param builtins.str memory: Memory allocated to each API portal instance
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.str:
        """
        Cpu allocated to each API portal instance
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> builtins.str:
        """
        Memory allocated to each API portal instance
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ApmPropertiesResponse(dict):
    """
    Properties of an APM
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApmPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApmPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApmPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 type: builtins.str,
                 properties: Optional[Mapping[str, builtins.str]] = None):
        """
        Properties of an APM
        :param builtins.str provisioning_state: State of the APM.
        :param builtins.str type: APM Type
        :param Mapping[str, builtins.str] properties: Non-sensitive properties for the APM
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the APM.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        APM Type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Non-sensitive properties for the APM
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class ApmReferenceResponse(dict):
    """
    A reference to the APM
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApmReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApmReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApmReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: builtins.str):
        """
        A reference to the APM
        :param builtins.str resource_id: Resource Id of the APM
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> builtins.str:
        """
        Resource Id of the APM
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class AppResourcePropertiesResponse(dict):
    """
    App resource properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "addonConfigs":
            suggest = "addon_configs"
        elif key == "customPersistentDisks":
            suggest = "custom_persistent_disks"
        elif key == "enableEndToEndTLS":
            suggest = "enable_end_to_end_tls"
        elif key == "httpsOnly":
            suggest = "https_only"
        elif key == "ingressSettings":
            suggest = "ingress_settings"
        elif key == "loadedCertificates":
            suggest = "loaded_certificates"
        elif key == "persistentDisk":
            suggest = "persistent_disk"
        elif key == "temporaryDisk":
            suggest = "temporary_disk"
        elif key == "testEndpointAuthState":
            suggest = "test_endpoint_auth_state"
        elif key == "vnetAddons":
            suggest = "vnet_addons"
        elif key == "workloadProfileName":
            suggest = "workload_profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: builtins.str,
                 provisioning_state: builtins.str,
                 url: builtins.str,
                 addon_configs: Optional[Mapping[str, Any]] = None,
                 custom_persistent_disks: Optional[Sequence['outputs.CustomPersistentDiskResourceResponse']] = None,
                 enable_end_to_end_tls: Optional[builtins.bool] = None,
                 https_only: Optional[builtins.bool] = None,
                 ingress_settings: Optional['outputs.IngressSettingsResponse'] = None,
                 loaded_certificates: Optional[Sequence['outputs.LoadedCertificateResponse']] = None,
                 persistent_disk: Optional['outputs.PersistentDiskResponse'] = None,
                 public: Optional[builtins.bool] = None,
                 secrets: Optional[Sequence['outputs.SecretResponse']] = None,
                 temporary_disk: Optional['outputs.TemporaryDiskResponse'] = None,
                 test_endpoint_auth_state: Optional[builtins.str] = None,
                 vnet_addons: Optional['outputs.AppVNetAddonsResponse'] = None,
                 workload_profile_name: Optional[builtins.str] = None):
        """
        App resource properties payload
        :param builtins.str fqdn: Fully qualified dns Name.
        :param builtins.str provisioning_state: Provisioning state of the App
        :param builtins.str url: URL of the App
        :param Mapping[str, Any] addon_configs: Collection of addons
        :param Sequence['CustomPersistentDiskResourceResponse'] custom_persistent_disks: List of custom persistent disks
        :param builtins.bool enable_end_to_end_tls: Indicate if end to end TLS is enabled.
        :param builtins.bool https_only: Indicate if only https is allowed.
        :param 'IngressSettingsResponse' ingress_settings: App ingress settings payload.
        :param Sequence['LoadedCertificateResponse'] loaded_certificates: Collection of loaded certificates
        :param 'PersistentDiskResponse' persistent_disk: Persistent disk settings
        :param builtins.bool public: Indicates whether the App exposes public endpoint
        :param Sequence['SecretResponse'] secrets: Collection of auth secrets
        :param 'TemporaryDiskResponse' temporary_disk: Temporary disk settings
        :param builtins.str test_endpoint_auth_state: State of test endpoint auth.
        :param 'AppVNetAddonsResponse' vnet_addons: Additional App settings in vnet injection instance
        :param builtins.str workload_profile_name: The workload profile used for this app. Supported for Consumption + Dedicated plan.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "url", url)
        if addon_configs is not None:
            pulumi.set(__self__, "addon_configs", addon_configs)
        if custom_persistent_disks is not None:
            pulumi.set(__self__, "custom_persistent_disks", custom_persistent_disks)
        if enable_end_to_end_tls is None:
            enable_end_to_end_tls = False
        if enable_end_to_end_tls is not None:
            pulumi.set(__self__, "enable_end_to_end_tls", enable_end_to_end_tls)
        if https_only is None:
            https_only = False
        if https_only is not None:
            pulumi.set(__self__, "https_only", https_only)
        if ingress_settings is not None:
            pulumi.set(__self__, "ingress_settings", ingress_settings)
        if loaded_certificates is not None:
            pulumi.set(__self__, "loaded_certificates", loaded_certificates)
        if persistent_disk is not None:
            pulumi.set(__self__, "persistent_disk", persistent_disk)
        if public is not None:
            pulumi.set(__self__, "public", public)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if temporary_disk is not None:
            pulumi.set(__self__, "temporary_disk", temporary_disk)
        if test_endpoint_auth_state is None:
            test_endpoint_auth_state = 'Enabled'
        if test_endpoint_auth_state is not None:
            pulumi.set(__self__, "test_endpoint_auth_state", test_endpoint_auth_state)
        if vnet_addons is not None:
            pulumi.set(__self__, "vnet_addons", vnet_addons)
        if workload_profile_name is not None:
            pulumi.set(__self__, "workload_profile_name", workload_profile_name)

    @property
    @pulumi.getter
    def fqdn(self) -> builtins.str:
        """
        Fully qualified dns Name.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the App
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def url(self) -> builtins.str:
        """
        URL of the App
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="addonConfigs")
    def addon_configs(self) -> Optional[Mapping[str, Any]]:
        """
        Collection of addons
        """
        return pulumi.get(self, "addon_configs")

    @property
    @pulumi.getter(name="customPersistentDisks")
    def custom_persistent_disks(self) -> Optional[Sequence['outputs.CustomPersistentDiskResourceResponse']]:
        """
        List of custom persistent disks
        """
        return pulumi.get(self, "custom_persistent_disks")

    @property
    @pulumi.getter(name="enableEndToEndTLS")
    def enable_end_to_end_tls(self) -> Optional[builtins.bool]:
        """
        Indicate if end to end TLS is enabled.
        """
        return pulumi.get(self, "enable_end_to_end_tls")

    @property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> Optional[builtins.bool]:
        """
        Indicate if only https is allowed.
        """
        return pulumi.get(self, "https_only")

    @property
    @pulumi.getter(name="ingressSettings")
    def ingress_settings(self) -> Optional['outputs.IngressSettingsResponse']:
        """
        App ingress settings payload.
        """
        return pulumi.get(self, "ingress_settings")

    @property
    @pulumi.getter(name="loadedCertificates")
    def loaded_certificates(self) -> Optional[Sequence['outputs.LoadedCertificateResponse']]:
        """
        Collection of loaded certificates
        """
        return pulumi.get(self, "loaded_certificates")

    @property
    @pulumi.getter(name="persistentDisk")
    def persistent_disk(self) -> Optional['outputs.PersistentDiskResponse']:
        """
        Persistent disk settings
        """
        return pulumi.get(self, "persistent_disk")

    @property
    @pulumi.getter
    def public(self) -> Optional[builtins.bool]:
        """
        Indicates whether the App exposes public endpoint
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.SecretResponse']]:
        """
        Collection of auth secrets
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="temporaryDisk")
    def temporary_disk(self) -> Optional['outputs.TemporaryDiskResponse']:
        """
        Temporary disk settings
        """
        return pulumi.get(self, "temporary_disk")

    @property
    @pulumi.getter(name="testEndpointAuthState")
    def test_endpoint_auth_state(self) -> Optional[builtins.str]:
        """
        State of test endpoint auth.
        """
        return pulumi.get(self, "test_endpoint_auth_state")

    @property
    @pulumi.getter(name="vnetAddons")
    def vnet_addons(self) -> Optional['outputs.AppVNetAddonsResponse']:
        """
        Additional App settings in vnet injection instance
        """
        return pulumi.get(self, "vnet_addons")

    @property
    @pulumi.getter(name="workloadProfileName")
    def workload_profile_name(self) -> Optional[builtins.str]:
        """
        The workload profile used for this app. Supported for Consumption + Dedicated plan.
        """
        return pulumi.get(self, "workload_profile_name")


@pulumi.output_type
class AppVNetAddonsResponse(dict):
    """
    Additional App settings in vnet injection instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicEndpointUrl":
            suggest = "public_endpoint_url"
        elif key == "publicEndpoint":
            suggest = "public_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVNetAddonsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVNetAddonsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVNetAddonsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_endpoint_url: builtins.str,
                 public_endpoint: Optional[builtins.bool] = None):
        """
        Additional App settings in vnet injection instance
        :param builtins.str public_endpoint_url: URL of the App in vnet injection instance which could be accessed from internet
        :param builtins.bool public_endpoint: Indicates whether the App in vnet injection instance exposes endpoint which could be accessed from internet.
        """
        pulumi.set(__self__, "public_endpoint_url", public_endpoint_url)
        if public_endpoint is None:
            public_endpoint = False
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="publicEndpointUrl")
    def public_endpoint_url(self) -> builtins.str:
        """
        URL of the App in vnet injection instance which could be accessed from internet
        """
        return pulumi.get(self, "public_endpoint_url")

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[builtins.bool]:
        """
        Indicates whether the App in vnet injection instance exposes endpoint which could be accessed from internet.
        """
        return pulumi.get(self, "public_endpoint")


@pulumi.output_type
class ApplicationAcceleratorComponentResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceRequests":
            suggest = "resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAcceleratorComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAcceleratorComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAcceleratorComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.ApplicationAcceleratorInstanceResponse'],
                 name: builtins.str,
                 resource_requests: Optional['outputs.ApplicationAcceleratorResourceRequestsResponse'] = None):
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "name", name)
        if resource_requests is not None:
            pulumi.set(__self__, "resource_requests", resource_requests)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.ApplicationAcceleratorInstanceResponse']:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> Optional['outputs.ApplicationAcceleratorResourceRequestsResponse']:
        return pulumi.get(self, "resource_requests")


@pulumi.output_type
class ApplicationAcceleratorInstanceResponse(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 status: builtins.str):
        """
        :param builtins.str name: Name of the Application Accelerator instance.
        :param builtins.str status: Status of the Application Accelerator instance. It can be Pending, Running, Succeeded, Failed, Unknown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the Application Accelerator instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the Application Accelerator instance. It can be Pending, Running, Succeeded, Failed, Unknown.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ApplicationAcceleratorPropertiesResponse(dict):
    """
    Application accelerator properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAcceleratorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAcceleratorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAcceleratorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 components: Sequence['outputs.ApplicationAcceleratorComponentResponse'],
                 provisioning_state: builtins.str):
        """
        Application accelerator properties payload
        :param Sequence['ApplicationAcceleratorComponentResponse'] components: Collection of components belong to application accelerator.
        :param builtins.str provisioning_state: State of the application accelerator.
        """
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.ApplicationAcceleratorComponentResponse']:
        """
        Collection of components belong to application accelerator.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the application accelerator.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class ApplicationAcceleratorResourceRequestsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAcceleratorResourceRequestsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAcceleratorResourceRequestsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAcceleratorResourceRequestsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: builtins.str,
                 instance_count: builtins.int,
                 memory: builtins.str):
        """
        :param builtins.str cpu: Cpu allocated to each application accelerator component. 1 core can be represented by 1 or 1000m
        :param builtins.int instance_count: Instance count of the application accelerator component.
        :param builtins.str memory: Memory allocated to each application accelerator component. 1 GB can be represented by 1Gi or 1024Mi.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.str:
        """
        Cpu allocated to each application accelerator component. 1 core can be represented by 1 or 1000m
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> builtins.int:
        """
        Instance count of the application accelerator component.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter
    def memory(self) -> builtins.str:
        """
        Memory allocated to each application accelerator component. 1 GB can be represented by 1Gi or 1024Mi.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ApplicationInsightsAgentVersionsResponse(dict):
    """
    Application Insights agent versions properties payload
    """
    def __init__(__self__, *,
                 java: builtins.str):
        """
        Application Insights agent versions properties payload
        :param builtins.str java: Indicates the version of application insight java agent
        """
        pulumi.set(__self__, "java", java)

    @property
    @pulumi.getter
    def java(self) -> builtins.str:
        """
        Indicates the version of application insight java agent
        """
        return pulumi.get(self, "java")


@pulumi.output_type
class ApplicationLiveViewComponentResponse(dict):
    """
    Application Live View properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceRequests":
            suggest = "resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationLiveViewComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationLiveViewComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationLiveViewComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.ApplicationLiveViewInstanceResponse'],
                 name: Any,
                 resource_requests: 'outputs.ApplicationLiveViewResourceRequestsResponse'):
        """
        Application Live View properties payload
        :param Sequence['ApplicationLiveViewInstanceResponse'] instances: Collection of instances belong to Application Live View.
        :param Any name: Name of the component.
        :param 'ApplicationLiveViewResourceRequestsResponse' resource_requests: The requested resource quantity for required CPU and Memory.
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_requests", resource_requests)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.ApplicationLiveViewInstanceResponse']:
        """
        Collection of instances belong to Application Live View.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def name(self) -> Any:
        """
        Name of the component.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> 'outputs.ApplicationLiveViewResourceRequestsResponse':
        """
        The requested resource quantity for required CPU and Memory.
        """
        return pulumi.get(self, "resource_requests")


@pulumi.output_type
class ApplicationLiveViewInstanceResponse(dict):
    """
    Collection of instances belong to the Application Live View
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 status: builtins.str):
        """
        Collection of instances belong to the Application Live View
        :param builtins.str name: Name of the Application Live View instance.
        :param builtins.str status: Status of the Application Live View instance. It can be Pending, Running, Succeeded, Failed, Unknown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the Application Live View instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the Application Live View instance. It can be Pending, Running, Succeeded, Failed, Unknown.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ApplicationLiveViewPropertiesResponse(dict):
    """
    Application Live View properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationLiveViewPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationLiveViewPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationLiveViewPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 components: Sequence['outputs.ApplicationLiveViewComponentResponse'],
                 provisioning_state: builtins.str):
        """
        Application Live View properties payload
        :param Sequence['ApplicationLiveViewComponentResponse'] components: Component details of Application Live View
        :param builtins.str provisioning_state: State of the Application Live View.
        """
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.ApplicationLiveViewComponentResponse']:
        """
        Component details of Application Live View
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the Application Live View.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class ApplicationLiveViewResourceRequestsResponse(dict):
    """
    The resource quantity for required CPU and Memory of Application Live View component
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationLiveViewResourceRequestsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationLiveViewResourceRequestsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationLiveViewResourceRequestsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: builtins.str,
                 instance_count: builtins.int,
                 memory: builtins.str):
        """
        The resource quantity for required CPU and Memory of Application Live View component
        :param builtins.str cpu: Cpu quantity allocated to each Application Live View component instance. 1 core can be represented by 1 or 1000m.
        :param builtins.int instance_count: Desired instance count of Application Live View component instance.
        :param builtins.str memory: Memory quantity allocated to each Application Live View component instance. 1 GB can be represented by 1Gi or 1024Mi.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.str:
        """
        Cpu quantity allocated to each Application Live View component instance. 1 core can be represented by 1 or 1000m.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> builtins.int:
        """
        Desired instance count of Application Live View component instance.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter
    def memory(self) -> builtins.str:
        """
        Memory quantity allocated to each Application Live View component instance. 1 GB can be represented by 1Gi or 1024Mi.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class AzureFileVolumeResponse(dict):
    """
    The properties of the Azure File volume. Azure File shares are mounted as volumes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "enableSubPath":
            suggest = "enable_sub_path"
        elif key == "mountOptions":
            suggest = "mount_options"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "shareName":
            suggest = "share_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFileVolumeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFileVolumeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFileVolumeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: builtins.str,
                 type: builtins.str,
                 enable_sub_path: Optional[builtins.bool] = None,
                 mount_options: Optional[Sequence[builtins.str]] = None,
                 read_only: Optional[builtins.bool] = None,
                 share_name: Optional[builtins.str] = None):
        """
        The properties of the Azure File volume. Azure File shares are mounted as volumes.
        :param builtins.str mount_path: The mount path of the persistent disk.
        :param builtins.str type: The type of the underlying resource to mount as a persistent disk.
               Expected value is 'AzureFileVolume'.
        :param builtins.bool enable_sub_path: If set to true, it will create and mount a dedicated directory for every individual app instance.
        :param Sequence[builtins.str] mount_options: These are the mount options for a persistent disk.
        :param builtins.bool read_only: Indicates whether the persistent disk is a readOnly one.
        :param builtins.str share_name: The share name of the Azure File share.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "type", 'AzureFileVolume')
        if enable_sub_path is None:
            enable_sub_path = False
        if enable_sub_path is not None:
            pulumi.set(__self__, "enable_sub_path", enable_sub_path)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> builtins.str:
        """
        The mount path of the persistent disk.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the underlying resource to mount as a persistent disk.
        Expected value is 'AzureFileVolume'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="enableSubPath")
    def enable_sub_path(self) -> Optional[builtins.bool]:
        """
        If set to true, it will create and mount a dedicated directory for every individual app instance.
        """
        return pulumi.get(self, "enable_sub_path")

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[Sequence[builtins.str]]:
        """
        These are the mount options for a persistent disk.
        """
        return pulumi.get(self, "mount_options")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[builtins.bool]:
        """
        Indicates whether the persistent disk is a readOnly one.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[builtins.str]:
        """
        The share name of the Azure File share.
        """
        return pulumi.get(self, "share_name")


@pulumi.output_type
class BindingResourcePropertiesResponse(dict):
    """
    Binding resource properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "generatedProperties":
            suggest = "generated_properties"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "bindingParameters":
            suggest = "binding_parameters"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BindingResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BindingResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BindingResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: builtins.str,
                 generated_properties: builtins.str,
                 resource_name: builtins.str,
                 resource_type: builtins.str,
                 updated_at: builtins.str,
                 binding_parameters: Optional[Mapping[str, builtins.str]] = None,
                 key: Optional[builtins.str] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Binding resource properties payload
        :param builtins.str created_at: Creation time of the Binding resource
        :param builtins.str generated_properties: The generated Spring Boot property file for this binding. The secret will be deducted.
        :param builtins.str resource_name: The name of the bound resource
        :param builtins.str resource_type: The standard Azure resource type of the bound resource
        :param builtins.str updated_at: Update time of the Binding resource
        :param Mapping[str, builtins.str] binding_parameters: Binding parameters of the Binding resource
        :param builtins.str key: The key of the bound resource
        :param builtins.str resource_id: The Azure resource id of the bound resource
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "generated_properties", generated_properties)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "updated_at", updated_at)
        if binding_parameters is not None:
            pulumi.set(__self__, "binding_parameters", binding_parameters)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> builtins.str:
        """
        Creation time of the Binding resource
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="generatedProperties")
    def generated_properties(self) -> builtins.str:
        """
        The generated Spring Boot property file for this binding. The secret will be deducted.
        """
        return pulumi.get(self, "generated_properties")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> builtins.str:
        """
        The name of the bound resource
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> builtins.str:
        """
        The standard Azure resource type of the bound resource
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> builtins.str:
        """
        Update time of the Binding resource
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="bindingParameters")
    def binding_parameters(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Binding parameters of the Binding resource
        """
        return pulumi.get(self, "binding_parameters")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        The key of the bound resource
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The Azure resource id of the bound resource
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class BuildPropertiesResponse(dict):
    """
    Build resource properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "triggeredBuildResult":
            suggest = "triggered_build_result"
        elif key == "agentPool":
            suggest = "agent_pool"
        elif key == "relativePath":
            suggest = "relative_path"
        elif key == "resourceRequests":
            suggest = "resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 triggered_build_result: 'outputs.TriggeredBuildResultResponse',
                 agent_pool: Optional[builtins.str] = None,
                 apms: Optional[Sequence['outputs.ApmReferenceResponse']] = None,
                 builder: Optional[builtins.str] = None,
                 certificates: Optional[Sequence['outputs.CertificateReferenceResponse']] = None,
                 env: Optional[Mapping[str, builtins.str]] = None,
                 relative_path: Optional[builtins.str] = None,
                 resource_requests: Optional['outputs.BuildResourceRequestsResponse'] = None):
        """
        Build resource properties payload
        :param builtins.str provisioning_state: Provisioning state of the KPack build result
        :param 'TriggeredBuildResultResponse' triggered_build_result:  The build result triggered by this build
        :param builtins.str agent_pool: The resource id of agent pool
        :param Sequence['ApmReferenceResponse'] apms: The APMs for this build
        :param builtins.str builder: The resource id of builder to build the source code
        :param Sequence['CertificateReferenceResponse'] certificates: The CA Certificates for this build
        :param Mapping[str, builtins.str] env: The environment variables for this build
        :param builtins.str relative_path: The relative path of source code
        :param 'BuildResourceRequestsResponse' resource_requests: The customized build resource for this build
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "triggered_build_result", triggered_build_result)
        if agent_pool is not None:
            pulumi.set(__self__, "agent_pool", agent_pool)
        if apms is not None:
            pulumi.set(__self__, "apms", apms)
        if builder is not None:
            pulumi.set(__self__, "builder", builder)
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)
        if resource_requests is not None:
            pulumi.set(__self__, "resource_requests", resource_requests)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the KPack build result
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="triggeredBuildResult")
    def triggered_build_result(self) -> 'outputs.TriggeredBuildResultResponse':
        """
         The build result triggered by this build
        """
        return pulumi.get(self, "triggered_build_result")

    @property
    @pulumi.getter(name="agentPool")
    def agent_pool(self) -> Optional[builtins.str]:
        """
        The resource id of agent pool
        """
        return pulumi.get(self, "agent_pool")

    @property
    @pulumi.getter
    def apms(self) -> Optional[Sequence['outputs.ApmReferenceResponse']]:
        """
        The APMs for this build
        """
        return pulumi.get(self, "apms")

    @property
    @pulumi.getter
    def builder(self) -> Optional[builtins.str]:
        """
        The resource id of builder to build the source code
        """
        return pulumi.get(self, "builder")

    @property
    @pulumi.getter
    def certificates(self) -> Optional[Sequence['outputs.CertificateReferenceResponse']]:
        """
        The CA Certificates for this build
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The environment variables for this build
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[builtins.str]:
        """
        The relative path of source code
        """
        return pulumi.get(self, "relative_path")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> Optional['outputs.BuildResourceRequestsResponse']:
        """
        The customized build resource for this build
        """
        return pulumi.get(self, "resource_requests")


@pulumi.output_type
class BuildResourceRequestsResponse(dict):
    """
    Resource request payload of Build Resource.
    """
    def __init__(__self__, *,
                 cpu: Optional[builtins.str] = None,
                 memory: Optional[builtins.str] = None):
        """
        Resource request payload of Build Resource.
        :param builtins.str cpu: Optional Cpu allocated to the build resource. 1 core can be represented by 1 or 1000m. 
               The default value is 1, this should not exceed build service agent pool cpu size.
        :param builtins.str memory: Optional Memory allocated to the build resource. 1 GB can be represented by 1Gi or 1024Mi. 
               The default value is 2Gi, this should not exceed build service agent pool memory size.
        """
        if cpu is None:
            cpu = '1'
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is None:
            memory = '2Gi'
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[builtins.str]:
        """
        Optional Cpu allocated to the build resource. 1 core can be represented by 1 or 1000m. 
        The default value is 1, this should not exceed build service agent pool cpu size.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> Optional[builtins.str]:
        """
        Optional Memory allocated to the build resource. 1 GB can be represented by 1Gi or 1024Mi. 
        The default value is 2Gi, this should not exceed build service agent pool memory size.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class BuildResultUserSourceInfoResponse(dict):
    """
    Reference to a build result
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildResultId":
            suggest = "build_result_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildResultUserSourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildResultUserSourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildResultUserSourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 build_result_id: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Reference to a build result
        :param builtins.str type: Type of the source uploaded
               Expected value is 'BuildResult'.
        :param builtins.str build_result_id: Resource id of an existing succeeded build result under the same Spring instance.
        :param builtins.str version: Version of the source
        """
        pulumi.set(__self__, "type", 'BuildResult')
        if build_result_id is not None:
            pulumi.set(__self__, "build_result_id", build_result_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the source uploaded
        Expected value is 'BuildResult'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="buildResultId")
    def build_result_id(self) -> Optional[builtins.str]:
        """
        Resource id of an existing succeeded build result under the same Spring instance.
        """
        return pulumi.get(self, "build_result_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class BuildServiceAgentPoolPropertiesResponse(dict):
    """
    Build service agent pool properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "poolSize":
            suggest = "pool_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildServiceAgentPoolPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildServiceAgentPoolPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildServiceAgentPoolPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 pool_size: Optional['outputs.BuildServiceAgentPoolSizePropertiesResponse'] = None):
        """
        Build service agent pool properties
        :param builtins.str provisioning_state: Provisioning state of the build service agent pool
        :param 'BuildServiceAgentPoolSizePropertiesResponse' pool_size: build service agent pool size properties
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if pool_size is not None:
            pulumi.set(__self__, "pool_size", pool_size)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the build service agent pool
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional['outputs.BuildServiceAgentPoolSizePropertiesResponse']:
        """
        build service agent pool size properties
        """
        return pulumi.get(self, "pool_size")


@pulumi.output_type
class BuildServiceAgentPoolSizePropertiesResponse(dict):
    """
    Build service agent pool size properties
    """
    def __init__(__self__, *,
                 cpu: builtins.str,
                 memory: builtins.str,
                 name: Optional[builtins.str] = None):
        """
        Build service agent pool size properties
        :param builtins.str cpu: The cpu property of build service agent pool size
        :param builtins.str memory: The memory property of build service agent pool size
        :param builtins.str name: The name of build service agent pool size
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.str:
        """
        The cpu property of build service agent pool size
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> builtins.str:
        """
        The memory property of build service agent pool size
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of build service agent pool size
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class BuilderPropertiesResponse(dict):
    """
    KPack Builder properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "buildpackGroups":
            suggest = "buildpack_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuilderPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuilderPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuilderPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 buildpack_groups: Optional[Sequence['outputs.BuildpacksGroupPropertiesResponse']] = None,
                 stack: Optional['outputs.StackPropertiesResponse'] = None):
        """
        KPack Builder properties payload
        :param builtins.str provisioning_state: Builder provision status.
        :param Sequence['BuildpacksGroupPropertiesResponse'] buildpack_groups: Builder buildpack groups.
        :param 'StackPropertiesResponse' stack: Builder cluster stack property.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if buildpack_groups is not None:
            pulumi.set(__self__, "buildpack_groups", buildpack_groups)
        if stack is not None:
            pulumi.set(__self__, "stack", stack)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Builder provision status.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="buildpackGroups")
    def buildpack_groups(self) -> Optional[Sequence['outputs.BuildpacksGroupPropertiesResponse']]:
        """
        Builder buildpack groups.
        """
        return pulumi.get(self, "buildpack_groups")

    @property
    @pulumi.getter
    def stack(self) -> Optional['outputs.StackPropertiesResponse']:
        """
        Builder cluster stack property.
        """
        return pulumi.get(self, "stack")


@pulumi.output_type
class BuildpackBindingLaunchPropertiesResponse(dict):
    """
    Buildpack Binding Launch Properties
    """
    def __init__(__self__, *,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 secrets: Optional[Mapping[str, builtins.str]] = None):
        """
        Buildpack Binding Launch Properties
        :param Mapping[str, builtins.str] properties: Non-sensitive properties for launchProperties
        :param Mapping[str, builtins.str] secrets: Sensitive properties for launchProperties
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Non-sensitive properties for launchProperties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Sensitive properties for launchProperties
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class BuildpackBindingPropertiesResponse(dict):
    """
    Properties of a buildpack binding
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "bindingType":
            suggest = "binding_type"
        elif key == "launchProperties":
            suggest = "launch_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildpackBindingPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildpackBindingPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildpackBindingPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 binding_type: Optional[builtins.str] = None,
                 launch_properties: Optional['outputs.BuildpackBindingLaunchPropertiesResponse'] = None):
        """
        Properties of a buildpack binding
        :param builtins.str provisioning_state: State of the Buildpack Binding.
        :param builtins.str binding_type: Buildpack Binding Type
        :param 'BuildpackBindingLaunchPropertiesResponse' launch_properties: The object describes the buildpack binding launch properties
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if binding_type is not None:
            pulumi.set(__self__, "binding_type", binding_type)
        if launch_properties is not None:
            pulumi.set(__self__, "launch_properties", launch_properties)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the Buildpack Binding.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="bindingType")
    def binding_type(self) -> Optional[builtins.str]:
        """
        Buildpack Binding Type
        """
        return pulumi.get(self, "binding_type")

    @property
    @pulumi.getter(name="launchProperties")
    def launch_properties(self) -> Optional['outputs.BuildpackBindingLaunchPropertiesResponse']:
        """
        The object describes the buildpack binding launch properties
        """
        return pulumi.get(self, "launch_properties")


@pulumi.output_type
class BuildpackPropertiesResponse(dict):
    """
    Buildpack properties payload
    """
    def __init__(__self__, *,
                 version: builtins.str,
                 id: Optional[builtins.str] = None):
        """
        Buildpack properties payload
        :param builtins.str version: Version of the buildpack
        :param builtins.str id: Id of the buildpack
        """
        pulumi.set(__self__, "version", version)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Version of the buildpack
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Id of the buildpack
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BuildpacksGroupPropertiesResponse(dict):
    """
    Buildpack group properties of the Builder
    """
    def __init__(__self__, *,
                 buildpacks: Optional[Sequence['outputs.BuildpackPropertiesResponse']] = None,
                 name: Optional[builtins.str] = None):
        """
        Buildpack group properties of the Builder
        :param Sequence['BuildpackPropertiesResponse'] buildpacks: Buildpacks in the buildpack group
        :param builtins.str name: Buildpack group name
        """
        if buildpacks is not None:
            pulumi.set(__self__, "buildpacks", buildpacks)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def buildpacks(self) -> Optional[Sequence['outputs.BuildpackPropertiesResponse']]:
        """
        Buildpacks in the buildpack group
        """
        return pulumi.get(self, "buildpacks")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Buildpack group name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CertificateReferenceResponse(dict):
    """
    A reference to the certificate
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: builtins.str):
        """
        A reference to the certificate
        :param builtins.str resource_id: Resource Id of the certificate
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> builtins.str:
        """
        Resource Id of the certificate
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ClusterResourcePropertiesResponse(dict):
    """
    Service properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "powerState":
            suggest = "power_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceId":
            suggest = "service_id"
        elif key == "infraResourceGroup":
            suggest = "infra_resource_group"
        elif key == "maintenanceScheduleConfiguration":
            suggest = "maintenance_schedule_configuration"
        elif key == "managedEnvironmentId":
            suggest = "managed_environment_id"
        elif key == "marketplaceResource":
            suggest = "marketplace_resource"
        elif key == "networkProfile":
            suggest = "network_profile"
        elif key == "vnetAddons":
            suggest = "vnet_addons"
        elif key == "zoneRedundant":
            suggest = "zone_redundant"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: builtins.str,
                 power_state: builtins.str,
                 provisioning_state: builtins.str,
                 service_id: builtins.str,
                 version: builtins.int,
                 infra_resource_group: Optional[builtins.str] = None,
                 maintenance_schedule_configuration: Optional['outputs.WeeklyMaintenanceScheduleConfigurationResponse'] = None,
                 managed_environment_id: Optional[builtins.str] = None,
                 marketplace_resource: Optional['outputs.MarketplaceResourceResponse'] = None,
                 network_profile: Optional['outputs.NetworkProfileResponse'] = None,
                 vnet_addons: Optional['outputs.ServiceVNetAddonsResponse'] = None,
                 zone_redundant: Optional[builtins.bool] = None):
        """
        Service properties payload
        :param builtins.str fqdn: Fully qualified dns name of the service instance
        :param builtins.str power_state: Power state of the Service
        :param builtins.str provisioning_state: Provisioning state of the Service
        :param builtins.str service_id: ServiceInstanceEntity Id which uniquely identifies a created resource
        :param builtins.int version: Version of the Service
        :param builtins.str infra_resource_group: The name of the resource group that contains the infrastructure resources
        :param 'WeeklyMaintenanceScheduleConfigurationResponse' maintenance_schedule_configuration: Additional Service settings for planned maintenance
        :param builtins.str managed_environment_id: The resource Id of the Managed Environment that the Spring Apps instance builds on
        :param 'MarketplaceResourceResponse' marketplace_resource: Purchasing 3rd party product of the Service resource.
        :param 'NetworkProfileResponse' network_profile: Network profile of the Service
        :param 'ServiceVNetAddonsResponse' vnet_addons: Additional Service settings in vnet injection instance
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "power_state", power_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "version", version)
        if infra_resource_group is not None:
            pulumi.set(__self__, "infra_resource_group", infra_resource_group)
        if maintenance_schedule_configuration is not None:
            pulumi.set(__self__, "maintenance_schedule_configuration", maintenance_schedule_configuration)
        if managed_environment_id is not None:
            pulumi.set(__self__, "managed_environment_id", managed_environment_id)
        if marketplace_resource is not None:
            pulumi.set(__self__, "marketplace_resource", marketplace_resource)
        if network_profile is not None:
            pulumi.set(__self__, "network_profile", network_profile)
        if vnet_addons is not None:
            pulumi.set(__self__, "vnet_addons", vnet_addons)
        if zone_redundant is None:
            zone_redundant = False
        if zone_redundant is not None:
            pulumi.set(__self__, "zone_redundant", zone_redundant)

    @property
    @pulumi.getter
    def fqdn(self) -> builtins.str:
        """
        Fully qualified dns name of the service instance
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="powerState")
    def power_state(self) -> builtins.str:
        """
        Power state of the Service
        """
        return pulumi.get(self, "power_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the Service
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> builtins.str:
        """
        ServiceInstanceEntity Id which uniquely identifies a created resource
        """
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter
    def version(self) -> builtins.int:
        """
        Version of the Service
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="infraResourceGroup")
    def infra_resource_group(self) -> Optional[builtins.str]:
        """
        The name of the resource group that contains the infrastructure resources
        """
        return pulumi.get(self, "infra_resource_group")

    @property
    @pulumi.getter(name="maintenanceScheduleConfiguration")
    def maintenance_schedule_configuration(self) -> Optional['outputs.WeeklyMaintenanceScheduleConfigurationResponse']:
        """
        Additional Service settings for planned maintenance
        """
        return pulumi.get(self, "maintenance_schedule_configuration")

    @property
    @pulumi.getter(name="managedEnvironmentId")
    def managed_environment_id(self) -> Optional[builtins.str]:
        """
        The resource Id of the Managed Environment that the Spring Apps instance builds on
        """
        return pulumi.get(self, "managed_environment_id")

    @property
    @pulumi.getter(name="marketplaceResource")
    def marketplace_resource(self) -> Optional['outputs.MarketplaceResourceResponse']:
        """
        Purchasing 3rd party product of the Service resource.
        """
        return pulumi.get(self, "marketplace_resource")

    @property
    @pulumi.getter(name="networkProfile")
    def network_profile(self) -> Optional['outputs.NetworkProfileResponse']:
        """
        Network profile of the Service
        """
        return pulumi.get(self, "network_profile")

    @property
    @pulumi.getter(name="vnetAddons")
    def vnet_addons(self) -> Optional['outputs.ServiceVNetAddonsResponse']:
        """
        Additional Service settings in vnet injection instance
        """
        return pulumi.get(self, "vnet_addons")

    @property
    @pulumi.getter(name="zoneRedundant")
    def zone_redundant(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "zone_redundant")


@pulumi.output_type
class ConfigServerGitPropertyResponse(dict):
    """
    Property of git.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostKey":
            suggest = "host_key"
        elif key == "hostKeyAlgorithm":
            suggest = "host_key_algorithm"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "searchPaths":
            suggest = "search_paths"
        elif key == "strictHostKeyChecking":
            suggest = "strict_host_key_checking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigServerGitPropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigServerGitPropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigServerGitPropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: builtins.str,
                 host_key: Optional[builtins.str] = None,
                 host_key_algorithm: Optional[builtins.str] = None,
                 label: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 repositories: Optional[Sequence['outputs.GitPatternRepositoryResponse']] = None,
                 search_paths: Optional[Sequence[builtins.str]] = None,
                 strict_host_key_checking: Optional[builtins.bool] = None,
                 username: Optional[builtins.str] = None):
        """
        Property of git.
        :param builtins.str uri: URI of the repository
        :param builtins.str host_key: Public sshKey of git repository.
        :param builtins.str host_key_algorithm: SshKey algorithm of git repository.
        :param builtins.str label: Label of the repository
        :param builtins.str password: Password of git repository basic auth.
        :param builtins.str private_key: Private sshKey algorithm of git repository.
        :param Sequence['GitPatternRepositoryResponse'] repositories: Repositories of git.
        :param Sequence[builtins.str] search_paths: Searching path of the repository
        :param builtins.bool strict_host_key_checking: Strict host key checking or not.
        :param builtins.str username: Username of git repository basic auth.
        """
        pulumi.set(__self__, "uri", uri)
        if host_key is not None:
            pulumi.set(__self__, "host_key", host_key)
        if host_key_algorithm is not None:
            pulumi.set(__self__, "host_key_algorithm", host_key_algorithm)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if repositories is not None:
            pulumi.set(__self__, "repositories", repositories)
        if search_paths is not None:
            pulumi.set(__self__, "search_paths", search_paths)
        if strict_host_key_checking is not None:
            pulumi.set(__self__, "strict_host_key_checking", strict_host_key_checking)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        URI of the repository
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="hostKey")
    def host_key(self) -> Optional[builtins.str]:
        """
        Public sshKey of git repository.
        """
        return pulumi.get(self, "host_key")

    @property
    @pulumi.getter(name="hostKeyAlgorithm")
    def host_key_algorithm(self) -> Optional[builtins.str]:
        """
        SshKey algorithm of git repository.
        """
        return pulumi.get(self, "host_key_algorithm")

    @property
    @pulumi.getter
    def label(self) -> Optional[builtins.str]:
        """
        Label of the repository
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        Password of git repository basic auth.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        """
        Private sshKey algorithm of git repository.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def repositories(self) -> Optional[Sequence['outputs.GitPatternRepositoryResponse']]:
        """
        Repositories of git.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter(name="searchPaths")
    def search_paths(self) -> Optional[Sequence[builtins.str]]:
        """
        Searching path of the repository
        """
        return pulumi.get(self, "search_paths")

    @property
    @pulumi.getter(name="strictHostKeyChecking")
    def strict_host_key_checking(self) -> Optional[builtins.bool]:
        """
        Strict host key checking or not.
        """
        return pulumi.get(self, "strict_host_key_checking")

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        Username of git repository basic auth.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConfigServerPropertiesResponse(dict):
    """
    Config server git properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "configServer":
            suggest = "config_server"
        elif key == "enabledState":
            suggest = "enabled_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigServerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigServerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigServerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 config_server: Optional['outputs.ConfigServerSettingsResponse'] = None,
                 enabled_state: Optional[builtins.str] = None,
                 error: Optional['outputs.ErrorResponse'] = None):
        """
        Config server git properties payload
        :param builtins.str provisioning_state: State of the config server.
        :param 'ConfigServerSettingsResponse' config_server: Settings of config server.
        :param builtins.str enabled_state: Enabled state of the config server. This is only used in Consumption tier.
        :param 'ErrorResponse' error: Error when apply config server settings.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if config_server is not None:
            pulumi.set(__self__, "config_server", config_server)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)
        if error is not None:
            pulumi.set(__self__, "error", error)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the config server.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="configServer")
    def config_server(self) -> Optional['outputs.ConfigServerSettingsResponse']:
        """
        Settings of config server.
        """
        return pulumi.get(self, "config_server")

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[builtins.str]:
        """
        Enabled state of the config server. This is only used in Consumption tier.
        """
        return pulumi.get(self, "enabled_state")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ErrorResponse']:
        """
        Error when apply config server settings.
        """
        return pulumi.get(self, "error")


@pulumi.output_type
class ConfigServerSettingsResponse(dict):
    """
    The settings of config server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gitProperty":
            suggest = "git_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigServerSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigServerSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigServerSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 git_property: Optional['outputs.ConfigServerGitPropertyResponse'] = None):
        """
        The settings of config server.
        :param 'ConfigServerGitPropertyResponse' git_property: Property of git environment.
        """
        if git_property is not None:
            pulumi.set(__self__, "git_property", git_property)

    @property
    @pulumi.getter(name="gitProperty")
    def git_property(self) -> Optional['outputs.ConfigServerGitPropertyResponse']:
        """
        Property of git environment.
        """
        return pulumi.get(self, "git_property")


@pulumi.output_type
class ConfigurationServiceGitPropertyResponse(dict):
    """
    Property of git environment.
    """
    def __init__(__self__, *,
                 repositories: Optional[Sequence['outputs.ConfigurationServiceGitRepositoryResponse']] = None):
        """
        Property of git environment.
        :param Sequence['ConfigurationServiceGitRepositoryResponse'] repositories: Repositories of Application Configuration Service git property.
        """
        if repositories is not None:
            pulumi.set(__self__, "repositories", repositories)

    @property
    @pulumi.getter
    def repositories(self) -> Optional[Sequence['outputs.ConfigurationServiceGitRepositoryResponse']]:
        """
        Repositories of Application Configuration Service git property.
        """
        return pulumi.get(self, "repositories")


@pulumi.output_type
class ConfigurationServiceGitRepositoryResponse(dict):
    """
    Git repository property payload for Application Configuration Service
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertResourceId":
            suggest = "ca_cert_resource_id"
        elif key == "gitImplementation":
            suggest = "git_implementation"
        elif key == "hostKey":
            suggest = "host_key"
        elif key == "hostKeyAlgorithm":
            suggest = "host_key_algorithm"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "searchPaths":
            suggest = "search_paths"
        elif key == "strictHostKeyChecking":
            suggest = "strict_host_key_checking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationServiceGitRepositoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationServiceGitRepositoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationServiceGitRepositoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: builtins.str,
                 name: builtins.str,
                 patterns: Sequence[builtins.str],
                 uri: builtins.str,
                 ca_cert_resource_id: Optional[builtins.str] = None,
                 git_implementation: Optional[builtins.str] = None,
                 host_key: Optional[builtins.str] = None,
                 host_key_algorithm: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 search_paths: Optional[Sequence[builtins.str]] = None,
                 strict_host_key_checking: Optional[builtins.bool] = None,
                 username: Optional[builtins.str] = None):
        """
        Git repository property payload for Application Configuration Service
        :param builtins.str label: Label of the repository
        :param builtins.str name: Name of the repository
        :param Sequence[builtins.str] patterns: Collection of patterns of the repository
        :param builtins.str uri: URI of the repository
        :param builtins.str ca_cert_resource_id: Resource Id of CA certificate for https URL of Git repository.
        :param builtins.str git_implementation: Git libraries used to support various repository providers
        :param builtins.str host_key: Public sshKey of git repository.
        :param builtins.str host_key_algorithm: SshKey algorithm of git repository.
        :param builtins.str password: Password of git repository basic auth.
        :param builtins.str private_key: Private sshKey algorithm of git repository.
        :param Sequence[builtins.str] search_paths: Searching path of the repository
        :param builtins.bool strict_host_key_checking: Strict host key checking or not.
        :param builtins.str username: Username of git repository basic auth.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "patterns", patterns)
        pulumi.set(__self__, "uri", uri)
        if ca_cert_resource_id is not None:
            pulumi.set(__self__, "ca_cert_resource_id", ca_cert_resource_id)
        if git_implementation is not None:
            pulumi.set(__self__, "git_implementation", git_implementation)
        if host_key is not None:
            pulumi.set(__self__, "host_key", host_key)
        if host_key_algorithm is not None:
            pulumi.set(__self__, "host_key_algorithm", host_key_algorithm)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if search_paths is not None:
            pulumi.set(__self__, "search_paths", search_paths)
        if strict_host_key_checking is not None:
            pulumi.set(__self__, "strict_host_key_checking", strict_host_key_checking)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def label(self) -> builtins.str:
        """
        Label of the repository
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the repository
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def patterns(self) -> Sequence[builtins.str]:
        """
        Collection of patterns of the repository
        """
        return pulumi.get(self, "patterns")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        URI of the repository
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="caCertResourceId")
    def ca_cert_resource_id(self) -> Optional[builtins.str]:
        """
        Resource Id of CA certificate for https URL of Git repository.
        """
        return pulumi.get(self, "ca_cert_resource_id")

    @property
    @pulumi.getter(name="gitImplementation")
    def git_implementation(self) -> Optional[builtins.str]:
        """
        Git libraries used to support various repository providers
        """
        return pulumi.get(self, "git_implementation")

    @property
    @pulumi.getter(name="hostKey")
    def host_key(self) -> Optional[builtins.str]:
        """
        Public sshKey of git repository.
        """
        return pulumi.get(self, "host_key")

    @property
    @pulumi.getter(name="hostKeyAlgorithm")
    def host_key_algorithm(self) -> Optional[builtins.str]:
        """
        SshKey algorithm of git repository.
        """
        return pulumi.get(self, "host_key_algorithm")

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        Password of git repository basic auth.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        """
        Private sshKey algorithm of git repository.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="searchPaths")
    def search_paths(self) -> Optional[Sequence[builtins.str]]:
        """
        Searching path of the repository
        """
        return pulumi.get(self, "search_paths")

    @property
    @pulumi.getter(name="strictHostKeyChecking")
    def strict_host_key_checking(self) -> Optional[builtins.bool]:
        """
        Strict host key checking or not.
        """
        return pulumi.get(self, "strict_host_key_checking")

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        Username of git repository basic auth.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConfigurationServiceInstanceResponse(dict):
    """
    Collection of instances belong to the Application Configuration Service
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 status: builtins.str):
        """
        Collection of instances belong to the Application Configuration Service
        :param builtins.str name: Name of the Application Configuration Service instance
        :param builtins.str status: Status of the Application Configuration Service instance
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the Application Configuration Service instance
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the Application Configuration Service instance
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ConfigurationServicePropertiesResponse(dict):
    """
    Application Configuration Service properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceRequests":
            suggest = "resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationServicePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationServicePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationServicePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.ConfigurationServiceInstanceResponse'],
                 provisioning_state: builtins.str,
                 resource_requests: 'outputs.ConfigurationServiceResourceRequestsResponse',
                 generation: Optional[builtins.str] = None,
                 settings: Optional['outputs.ConfigurationServiceSettingsResponse'] = None):
        """
        Application Configuration Service properties payload
        :param Sequence['ConfigurationServiceInstanceResponse'] instances: Collection of instances belong to Application Configuration Service.
        :param builtins.str provisioning_state: State of the Application Configuration Service.
        :param 'ConfigurationServiceResourceRequestsResponse' resource_requests: The requested resource quantity for required CPU and Memory.
        :param builtins.str generation: The generation of the Application Configuration Service.
        :param 'ConfigurationServiceSettingsResponse' settings: The settings of Application Configuration Service.
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "resource_requests", resource_requests)
        if generation is None:
            generation = 'Gen1'
        if generation is not None:
            pulumi.set(__self__, "generation", generation)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.ConfigurationServiceInstanceResponse']:
        """
        Collection of instances belong to Application Configuration Service.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the Application Configuration Service.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> 'outputs.ConfigurationServiceResourceRequestsResponse':
        """
        The requested resource quantity for required CPU and Memory.
        """
        return pulumi.get(self, "resource_requests")

    @property
    @pulumi.getter
    def generation(self) -> Optional[builtins.str]:
        """
        The generation of the Application Configuration Service.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.ConfigurationServiceSettingsResponse']:
        """
        The settings of Application Configuration Service.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class ConfigurationServiceResourceRequestsResponse(dict):
    """
    Resource request payload of Application Configuration Service
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationServiceResourceRequestsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationServiceResourceRequestsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationServiceResourceRequestsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: builtins.str,
                 instance_count: builtins.int,
                 memory: builtins.str):
        """
        Resource request payload of Application Configuration Service
        :param builtins.str cpu: Cpu allocated to each Application Configuration Service instance
        :param builtins.int instance_count: Instance count of the Application Configuration Service
        :param builtins.str memory: Memory allocated to each Application Configuration Service instance
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.str:
        """
        Cpu allocated to each Application Configuration Service instance
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> builtins.int:
        """
        Instance count of the Application Configuration Service
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter
    def memory(self) -> builtins.str:
        """
        Memory allocated to each Application Configuration Service instance
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ConfigurationServiceSettingsResponse(dict):
    """
    The settings of Application Configuration Service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gitProperty":
            suggest = "git_property"
        elif key == "refreshIntervalInSeconds":
            suggest = "refresh_interval_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationServiceSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationServiceSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationServiceSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 git_property: Optional['outputs.ConfigurationServiceGitPropertyResponse'] = None,
                 refresh_interval_in_seconds: Optional[builtins.int] = None):
        """
        The settings of Application Configuration Service.
        :param 'ConfigurationServiceGitPropertyResponse' git_property: Property of git environment.
        :param builtins.int refresh_interval_in_seconds: How often (in seconds) to check repository updates. Minimum value is 0.
        """
        if git_property is not None:
            pulumi.set(__self__, "git_property", git_property)
        if refresh_interval_in_seconds is not None:
            pulumi.set(__self__, "refresh_interval_in_seconds", refresh_interval_in_seconds)

    @property
    @pulumi.getter(name="gitProperty")
    def git_property(self) -> Optional['outputs.ConfigurationServiceGitPropertyResponse']:
        """
        Property of git environment.
        """
        return pulumi.get(self, "git_property")

    @property
    @pulumi.getter(name="refreshIntervalInSeconds")
    def refresh_interval_in_seconds(self) -> Optional[builtins.int]:
        """
        How often (in seconds) to check repository updates. Minimum value is 0.
        """
        return pulumi.get(self, "refresh_interval_in_seconds")


@pulumi.output_type
class ContainerProbeSettingsResponse(dict):
    """
    Container liveness and readiness probe settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableProbe":
            suggest = "disable_probe"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerProbeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerProbeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerProbeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_probe: Optional[builtins.bool] = None):
        """
        Container liveness and readiness probe settings
        :param builtins.bool disable_probe: Indicates whether disable the liveness and readiness probe
        """
        if disable_probe is not None:
            pulumi.set(__self__, "disable_probe", disable_probe)

    @property
    @pulumi.getter(name="disableProbe")
    def disable_probe(self) -> Optional[builtins.bool]:
        """
        Indicates whether disable the liveness and readiness probe
        """
        return pulumi.get(self, "disable_probe")


@pulumi.output_type
class ContainerRegistryBasicCredentialsResponse(dict):
    """
    The basic authentication properties for the container registry resource.
    """
    def __init__(__self__, *,
                 server: builtins.str,
                 type: builtins.str,
                 username: builtins.str):
        """
        The basic authentication properties for the container registry resource.
        :param builtins.str server: The login server of the Container Registry.
        :param builtins.str type: The credential type of the container registry credentials.
               Expected value is 'BasicAuth'.
        :param builtins.str username: The username of the Container Registry.
        """
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "type", 'BasicAuth')
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def server(self) -> builtins.str:
        """
        The login server of the Container Registry.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The credential type of the container registry credentials.
        Expected value is 'BasicAuth'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        The username of the Container Registry.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContainerRegistryPropertiesResponse(dict):
    """
    Container registry resource payload.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerRegistryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerRegistryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerRegistryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.ContainerRegistryBasicCredentialsResponse',
                 provisioning_state: builtins.str):
        """
        Container registry resource payload.
        :param 'ContainerRegistryBasicCredentialsResponse' credentials: The credentials of the container registry resource.
        :param builtins.str provisioning_state: State of the Container Registry.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.ContainerRegistryBasicCredentialsResponse':
        """
        The credentials of the container registry resource.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the Container Registry.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class ContentCertificatePropertiesResponse(dict):
    """
    Properties of certificate imported from key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activateDate":
            suggest = "activate_date"
        elif key == "dnsNames":
            suggest = "dns_names"
        elif key == "expirationDate":
            suggest = "expiration_date"
        elif key == "issuedDate":
            suggest = "issued_date"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "subjectName":
            suggest = "subject_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentCertificatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentCertificatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentCertificatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activate_date: builtins.str,
                 dns_names: Sequence[builtins.str],
                 expiration_date: builtins.str,
                 issued_date: builtins.str,
                 issuer: builtins.str,
                 provisioning_state: builtins.str,
                 subject_name: builtins.str,
                 thumbprint: builtins.str,
                 type: builtins.str):
        """
        Properties of certificate imported from key vault.
        :param builtins.str activate_date: The activate date of certificate.
        :param Sequence[builtins.str] dns_names: The domain list of certificate.
        :param builtins.str expiration_date: The expiration date of certificate.
        :param builtins.str issued_date: The issue date of certificate.
        :param builtins.str issuer: The issuer of certificate.
        :param builtins.str provisioning_state: Provisioning state of the Certificate
        :param builtins.str subject_name: The subject name of certificate.
        :param builtins.str thumbprint: The thumbprint of certificate.
        :param builtins.str type: The type of the certificate source.
               Expected value is 'ContentCertificate'.
        """
        pulumi.set(__self__, "activate_date", activate_date)
        pulumi.set(__self__, "dns_names", dns_names)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "issued_date", issued_date)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "subject_name", subject_name)
        pulumi.set(__self__, "thumbprint", thumbprint)
        pulumi.set(__self__, "type", 'ContentCertificate')

    @property
    @pulumi.getter(name="activateDate")
    def activate_date(self) -> builtins.str:
        """
        The activate date of certificate.
        """
        return pulumi.get(self, "activate_date")

    @property
    @pulumi.getter(name="dnsNames")
    def dns_names(self) -> Sequence[builtins.str]:
        """
        The domain list of certificate.
        """
        return pulumi.get(self, "dns_names")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> builtins.str:
        """
        The expiration date of certificate.
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="issuedDate")
    def issued_date(self) -> builtins.str:
        """
        The issue date of certificate.
        """
        return pulumi.get(self, "issued_date")

    @property
    @pulumi.getter
    def issuer(self) -> builtins.str:
        """
        The issuer of certificate.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the Certificate
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> builtins.str:
        """
        The subject name of certificate.
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter
    def thumbprint(self) -> builtins.str:
        """
        The thumbprint of certificate.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the certificate source.
        Expected value is 'ContentCertificate'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CustomContainerResponse(dict):
    """
    Custom container payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerImage":
            suggest = "container_image"
        elif key == "imageRegistryCredential":
            suggest = "image_registry_credential"
        elif key == "languageFramework":
            suggest = "language_framework"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Optional[Sequence[builtins.str]] = None,
                 command: Optional[Sequence[builtins.str]] = None,
                 container_image: Optional[builtins.str] = None,
                 image_registry_credential: Optional['outputs.ImageRegistryCredentialResponse'] = None,
                 language_framework: Optional[builtins.str] = None,
                 server: Optional[builtins.str] = None):
        """
        Custom container payload
        :param Sequence[builtins.str] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        :param Sequence[builtins.str] command: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided.
        :param builtins.str container_image: Container image of the custom container. This should be in the form of <repository>:<tag> without the server name of the registry
        :param 'ImageRegistryCredentialResponse' image_registry_credential: Credential of the image registry
        :param builtins.str language_framework: Language framework of the container image uploaded. Supported values: "springboot", "", null.
        :param builtins.str server: The name of the registry that contains the container image
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if image_registry_credential is not None:
            pulumi.set(__self__, "image_registry_credential", image_registry_credential)
        if language_framework is not None:
            pulumi.set(__self__, "language_framework", language_framework)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[builtins.str]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[builtins.str]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[builtins.str]:
        """
        Container image of the custom container. This should be in the form of <repository>:<tag> without the server name of the registry
        """
        return pulumi.get(self, "container_image")

    @property
    @pulumi.getter(name="imageRegistryCredential")
    def image_registry_credential(self) -> Optional['outputs.ImageRegistryCredentialResponse']:
        """
        Credential of the image registry
        """
        return pulumi.get(self, "image_registry_credential")

    @property
    @pulumi.getter(name="languageFramework")
    def language_framework(self) -> Optional[builtins.str]:
        """
        Language framework of the container image uploaded. Supported values: "springboot", "", null.
        """
        return pulumi.get(self, "language_framework")

    @property
    @pulumi.getter
    def server(self) -> Optional[builtins.str]:
        """
        The name of the registry that contains the container image
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class CustomContainerUserSourceInfoResponse(dict):
    """
    Custom container user source info
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customContainer":
            suggest = "custom_container"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomContainerUserSourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomContainerUserSourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomContainerUserSourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 custom_container: Optional['outputs.CustomContainerResponse'] = None,
                 version: Optional[builtins.str] = None):
        """
        Custom container user source info
        :param builtins.str type: Type of the source uploaded
               Expected value is 'Container'.
        :param 'CustomContainerResponse' custom_container: Custom container payload
        :param builtins.str version: Version of the source
        """
        pulumi.set(__self__, "type", 'Container')
        if custom_container is not None:
            pulumi.set(__self__, "custom_container", custom_container)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the source uploaded
        Expected value is 'Container'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="customContainer")
    def custom_container(self) -> Optional['outputs.CustomContainerResponse']:
        """
        Custom container payload
        """
        return pulumi.get(self, "custom_container")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class CustomDomainPropertiesResponse(dict):
    """
    Custom domain of app resource payload.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appName":
            suggest = "app_name"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "certName":
            suggest = "cert_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_name: builtins.str,
                 provisioning_state: builtins.str,
                 cert_name: Optional[builtins.str] = None,
                 thumbprint: Optional[builtins.str] = None):
        """
        Custom domain of app resource payload.
        :param builtins.str app_name: The app name of domain.
        :param builtins.str provisioning_state: Provisioning state of the Domain
        :param builtins.str cert_name: The bound certificate name of domain.
        :param builtins.str thumbprint: The thumbprint of bound certificate.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if cert_name is not None:
            pulumi.set(__self__, "cert_name", cert_name)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> builtins.str:
        """
        The app name of domain.
        """
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the Domain
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="certName")
    def cert_name(self) -> Optional[builtins.str]:
        """
        The bound certificate name of domain.
        """
        return pulumi.get(self, "cert_name")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of bound certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class CustomPersistentDiskResourceResponse(dict):
    """
    Custom persistent disk resource payload.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageId":
            suggest = "storage_id"
        elif key == "customPersistentDiskProperties":
            suggest = "custom_persistent_disk_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomPersistentDiskResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomPersistentDiskResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomPersistentDiskResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_id: builtins.str,
                 custom_persistent_disk_properties: Optional['outputs.AzureFileVolumeResponse'] = None):
        """
        Custom persistent disk resource payload.
        :param builtins.str storage_id: The resource id of Azure Spring Apps Storage resource.
        :param 'AzureFileVolumeResponse' custom_persistent_disk_properties: Properties of the custom persistent disk resource payload.
        """
        pulumi.set(__self__, "storage_id", storage_id)
        if custom_persistent_disk_properties is not None:
            pulumi.set(__self__, "custom_persistent_disk_properties", custom_persistent_disk_properties)

    @property
    @pulumi.getter(name="storageId")
    def storage_id(self) -> builtins.str:
        """
        The resource id of Azure Spring Apps Storage resource.
        """
        return pulumi.get(self, "storage_id")

    @property
    @pulumi.getter(name="customPersistentDiskProperties")
    def custom_persistent_disk_properties(self) -> Optional['outputs.AzureFileVolumeResponse']:
        """
        Properties of the custom persistent disk resource payload.
        """
        return pulumi.get(self, "custom_persistent_disk_properties")


@pulumi.output_type
class CustomScaleRuleResponse(dict):
    """
    Azure Spring Apps App Instance Custom scaling rule.
    """
    def __init__(__self__, *,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        """
        Azure Spring Apps App Instance Custom scaling rule.
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the custom scale rule.
        :param Mapping[str, builtins.str] metadata: Metadata properties to describe custom scale rule.
        :param builtins.str type: Type of the custom scale rule
               eg: azure-servicebus, redis etc.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Metadata properties to describe custom scale rule.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the custom scale rule
        eg: azure-servicebus, redis etc.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CustomizedAcceleratorPropertiesResponse(dict):
    """
    Customized accelerator properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gitRepository":
            suggest = "git_repository"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "acceleratorTags":
            suggest = "accelerator_tags"
        elif key == "acceleratorType":
            suggest = "accelerator_type"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "iconUrl":
            suggest = "icon_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomizedAcceleratorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomizedAcceleratorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomizedAcceleratorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 git_repository: 'outputs.AcceleratorGitRepositoryResponse',
                 imports: Sequence[builtins.str],
                 provisioning_state: builtins.str,
                 accelerator_tags: Optional[Sequence[builtins.str]] = None,
                 accelerator_type: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 icon_url: Optional[builtins.str] = None):
        """
        Customized accelerator properties payload
        :param Sequence[builtins.str] imports: Imports references all imports that this accelerator/fragment depends upon.
        :param builtins.str provisioning_state: State of the customized accelerator.
        :param builtins.str accelerator_type: Type of the customized accelerator.
        """
        pulumi.set(__self__, "git_repository", git_repository)
        pulumi.set(__self__, "imports", imports)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if accelerator_tags is not None:
            pulumi.set(__self__, "accelerator_tags", accelerator_tags)
        if accelerator_type is not None:
            pulumi.set(__self__, "accelerator_type", accelerator_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if icon_url is not None:
            pulumi.set(__self__, "icon_url", icon_url)

    @property
    @pulumi.getter(name="gitRepository")
    def git_repository(self) -> 'outputs.AcceleratorGitRepositoryResponse':
        return pulumi.get(self, "git_repository")

    @property
    @pulumi.getter
    def imports(self) -> Sequence[builtins.str]:
        """
        Imports references all imports that this accelerator/fragment depends upon.
        """
        return pulumi.get(self, "imports")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the customized accelerator.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="acceleratorTags")
    def accelerator_tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "accelerator_tags")

    @property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> Optional[builtins.str]:
        """
        Type of the customized accelerator.
        """
        return pulumi.get(self, "accelerator_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "icon_url")


@pulumi.output_type
class DeploymentInstanceResponse(dict):
    """
    Deployment instance payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discoveryStatus":
            suggest = "discovery_status"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentInstanceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentInstanceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentInstanceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discovery_status: builtins.str,
                 name: builtins.str,
                 reason: builtins.str,
                 start_time: builtins.str,
                 status: builtins.str,
                 zone: builtins.str):
        """
        Deployment instance payload
        :param builtins.str discovery_status: Discovery status of the deployment instance
        :param builtins.str name: Name of the deployment instance
        :param builtins.str reason: Failed reason of the deployment instance
        :param builtins.str start_time: Start time of the deployment instance
        :param builtins.str status: Status of the deployment instance
        :param builtins.str zone: Availability zone information of the deployment instance
        """
        pulumi.set(__self__, "discovery_status", discovery_status)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="discoveryStatus")
    def discovery_status(self) -> builtins.str:
        """
        Discovery status of the deployment instance
        """
        return pulumi.get(self, "discovery_status")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the deployment instance
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def reason(self) -> builtins.str:
        """
        Failed reason of the deployment instance
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> builtins.str:
        """
        Start time of the deployment instance
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the deployment instance
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> builtins.str:
        """
        Availability zone information of the deployment instance
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class DeploymentResourcePropertiesResponse(dict):
    """
    Deployment resource properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "deploymentSettings":
            suggest = "deployment_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.DeploymentInstanceResponse'],
                 provisioning_state: builtins.str,
                 status: builtins.str,
                 active: Optional[builtins.bool] = None,
                 deployment_settings: Optional['outputs.DeploymentSettingsResponse'] = None,
                 source: Optional[Any] = None):
        """
        Deployment resource properties payload
        :param Sequence['DeploymentInstanceResponse'] instances: Collection of instances belong to the Deployment
        :param builtins.str provisioning_state: Provisioning state of the Deployment
        :param builtins.str status: Status of the Deployment
        :param builtins.bool active: Indicates whether the Deployment is active
        :param 'DeploymentSettingsResponse' deployment_settings: Deployment settings of the Deployment
        :param Union['BuildResultUserSourceInfoResponse', 'CustomContainerUserSourceInfoResponse', 'JarUploadedUserSourceInfoResponse', 'NetCoreZipUploadedUserSourceInfoResponse', 'SourceUploadedUserSourceInfoResponse', 'UploadedUserSourceInfoResponse', 'WarUploadedUserSourceInfoResponse'] source: Uploaded source information of the deployment.
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if deployment_settings is not None:
            pulumi.set(__self__, "deployment_settings", deployment_settings)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.DeploymentInstanceResponse']:
        """
        Collection of instances belong to the Deployment
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the Deployment
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def active(self) -> Optional[builtins.bool]:
        """
        Indicates whether the Deployment is active
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="deploymentSettings")
    def deployment_settings(self) -> Optional['outputs.DeploymentSettingsResponse']:
        """
        Deployment settings of the Deployment
        """
        return pulumi.get(self, "deployment_settings")

    @property
    @pulumi.getter
    def source(self) -> Optional[Any]:
        """
        Uploaded source information of the deployment.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class DeploymentSettingsResponse(dict):
    """
    Deployment settings payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addonConfigs":
            suggest = "addon_configs"
        elif key == "containerProbeSettings":
            suggest = "container_probe_settings"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "resourceRequests":
            suggest = "resource_requests"
        elif key == "startupProbe":
            suggest = "startup_probe"
        elif key == "terminationGracePeriodSeconds":
            suggest = "termination_grace_period_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addon_configs: Optional[Mapping[str, Any]] = None,
                 apms: Optional[Sequence['outputs.ApmReferenceResponse']] = None,
                 container_probe_settings: Optional['outputs.ContainerProbeSettingsResponse'] = None,
                 environment_variables: Optional[Mapping[str, builtins.str]] = None,
                 liveness_probe: Optional['outputs.ProbeResponse'] = None,
                 readiness_probe: Optional['outputs.ProbeResponse'] = None,
                 resource_requests: Optional['outputs.ResourceRequestsResponse'] = None,
                 scale: Optional['outputs.ScaleResponse'] = None,
                 startup_probe: Optional['outputs.ProbeResponse'] = None,
                 termination_grace_period_seconds: Optional[builtins.int] = None):
        """
        Deployment settings payload
        :param Mapping[str, Any] addon_configs: Collection of addons
        :param Sequence['ApmReferenceResponse'] apms: Collection of ApmReferences
        :param 'ContainerProbeSettingsResponse' container_probe_settings: Container liveness and readiness probe settings
        :param Mapping[str, builtins.str] environment_variables: Collection of environment variables
        :param 'ProbeResponse' liveness_probe: Periodic probe of App Instance liveness. App Instance will be restarted if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param 'ProbeResponse' readiness_probe: Periodic probe of App Instance service readiness. App Instance will be removed from service endpoints if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param 'ResourceRequestsResponse' resource_requests: The requested resource quantity for required CPU and Memory. It is recommended that using this field to represent the required CPU and Memory, the old field cpu and memoryInGB will be deprecated later.
        :param 'ScaleResponse' scale: Scaling properties for the Azure Spring Apps App Instance.
        :param 'ProbeResponse' startup_probe: StartupProbe indicates that the App Instance has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a App Instance's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param builtins.int termination_grace_period_seconds: Optional duration in seconds the App Instance needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the App Instance are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 90 seconds.
        """
        if addon_configs is not None:
            pulumi.set(__self__, "addon_configs", addon_configs)
        if apms is not None:
            pulumi.set(__self__, "apms", apms)
        if container_probe_settings is not None:
            pulumi.set(__self__, "container_probe_settings", container_probe_settings)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resource_requests is not None:
            pulumi.set(__self__, "resource_requests", resource_requests)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if termination_grace_period_seconds is None:
            termination_grace_period_seconds = 90
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @property
    @pulumi.getter(name="addonConfigs")
    def addon_configs(self) -> Optional[Mapping[str, Any]]:
        """
        Collection of addons
        """
        return pulumi.get(self, "addon_configs")

    @property
    @pulumi.getter
    def apms(self) -> Optional[Sequence['outputs.ApmReferenceResponse']]:
        """
        Collection of ApmReferences
        """
        return pulumi.get(self, "apms")

    @property
    @pulumi.getter(name="containerProbeSettings")
    def container_probe_settings(self) -> Optional['outputs.ContainerProbeSettingsResponse']:
        """
        Container liveness and readiness probe settings
        """
        return pulumi.get(self, "container_probe_settings")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Collection of environment variables
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.ProbeResponse']:
        """
        Periodic probe of App Instance liveness. App Instance will be restarted if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.ProbeResponse']:
        """
        Periodic probe of App Instance service readiness. App Instance will be removed from service endpoints if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> Optional['outputs.ResourceRequestsResponse']:
        """
        The requested resource quantity for required CPU and Memory. It is recommended that using this field to represent the required CPU and Memory, the old field cpu and memoryInGB will be deprecated later.
        """
        return pulumi.get(self, "resource_requests")

    @property
    @pulumi.getter
    def scale(self) -> Optional['outputs.ScaleResponse']:
        """
        Scaling properties for the Azure Spring Apps App Instance.
        """
        return pulumi.get(self, "scale")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.ProbeResponse']:
        """
        StartupProbe indicates that the App Instance has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a App Instance's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[builtins.int]:
        """
        Optional duration in seconds the App Instance needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the App Instance are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 90 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")


@pulumi.output_type
class DevToolPortalComponentResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceRequests":
            suggest = "resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevToolPortalComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevToolPortalComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevToolPortalComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.DevToolPortalInstanceResponse'],
                 name: builtins.str,
                 resource_requests: 'outputs.DevToolPortalResourceRequestsResponse'):
        """
        :param Sequence['DevToolPortalInstanceResponse'] instances: Collection of instances belong to Dev Tool Portal.
        :param 'DevToolPortalResourceRequestsResponse' resource_requests: The requested resource quantity for required CPU and Memory.
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_requests", resource_requests)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.DevToolPortalInstanceResponse']:
        """
        Collection of instances belong to Dev Tool Portal.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> 'outputs.DevToolPortalResourceRequestsResponse':
        """
        The requested resource quantity for required CPU and Memory.
        """
        return pulumi.get(self, "resource_requests")


@pulumi.output_type
class DevToolPortalFeatureDetailResponse(dict):
    """
    Detail settings for Dev Tool Portal feature
    """
    def __init__(__self__, *,
                 route: builtins.str,
                 state: Optional[builtins.str] = None):
        """
        Detail settings for Dev Tool Portal feature
        :param builtins.str route: Route path to visit the plugin
        :param builtins.str state: State of the plugin
        """
        pulumi.set(__self__, "route", route)
        if state is None:
            state = 'Enabled'
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def route(self) -> builtins.str:
        """
        Route path to visit the plugin
        """
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        State of the plugin
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DevToolPortalFeatureSettingsResponse(dict):
    """
    Settings for Dev Tool Portal
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationAccelerator":
            suggest = "application_accelerator"
        elif key == "applicationLiveView":
            suggest = "application_live_view"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevToolPortalFeatureSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevToolPortalFeatureSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevToolPortalFeatureSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_accelerator: Optional['outputs.DevToolPortalFeatureDetailResponse'] = None,
                 application_live_view: Optional['outputs.DevToolPortalFeatureDetailResponse'] = None):
        """
        Settings for Dev Tool Portal
        :param 'DevToolPortalFeatureDetailResponse' application_accelerator: Detail of Accelerator plugin
        :param 'DevToolPortalFeatureDetailResponse' application_live_view: Detail of App Live View plugin
        """
        if application_accelerator is not None:
            pulumi.set(__self__, "application_accelerator", application_accelerator)
        if application_live_view is not None:
            pulumi.set(__self__, "application_live_view", application_live_view)

    @property
    @pulumi.getter(name="applicationAccelerator")
    def application_accelerator(self) -> Optional['outputs.DevToolPortalFeatureDetailResponse']:
        """
        Detail of Accelerator plugin
        """
        return pulumi.get(self, "application_accelerator")

    @property
    @pulumi.getter(name="applicationLiveView")
    def application_live_view(self) -> Optional['outputs.DevToolPortalFeatureDetailResponse']:
        """
        Detail of App Live View plugin
        """
        return pulumi.get(self, "application_live_view")


@pulumi.output_type
class DevToolPortalInstanceResponse(dict):
    """
    Collection of instances belong to the Dev Tool Portal.
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 status: builtins.str):
        """
        Collection of instances belong to the Dev Tool Portal.
        :param builtins.str name: Name of the Dev Tool Portal instance.
        :param builtins.str status: Status of the Dev Tool Portal instance. It can be Pending, Running, Succeeded, Failed, Unknown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the Dev Tool Portal instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the Dev Tool Portal instance. It can be Pending, Running, Succeeded, Failed, Unknown.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DevToolPortalPropertiesResponse(dict):
    """
    Dev Tool Portal properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "ssoProperties":
            suggest = "sso_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevToolPortalPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevToolPortalPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevToolPortalPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 components: Sequence['outputs.DevToolPortalComponentResponse'],
                 provisioning_state: builtins.str,
                 url: builtins.str,
                 features: Optional['outputs.DevToolPortalFeatureSettingsResponse'] = None,
                 public: Optional[builtins.bool] = None,
                 sso_properties: Optional['outputs.DevToolPortalSsoPropertiesResponse'] = None):
        """
        Dev Tool Portal properties payload
        :param Sequence['DevToolPortalComponentResponse'] components: Collection of components belong to Dev Tool Portal.
        :param builtins.str provisioning_state: State of the Dev Tool Portal.
        :param builtins.str url: URL of the resource, exposed when 'public' is true.
        :param 'DevToolPortalFeatureSettingsResponse' features: Settings for Dev Tool Portal
        :param builtins.bool public: Indicates whether the resource exposes public endpoint
        :param 'DevToolPortalSsoPropertiesResponse' sso_properties: Single sign-on related configuration
        """
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "url", url)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if public is None:
            public = False
        if public is not None:
            pulumi.set(__self__, "public", public)
        if sso_properties is not None:
            pulumi.set(__self__, "sso_properties", sso_properties)

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.DevToolPortalComponentResponse']:
        """
        Collection of components belong to Dev Tool Portal.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the Dev Tool Portal.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def url(self) -> builtins.str:
        """
        URL of the resource, exposed when 'public' is true.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def features(self) -> Optional['outputs.DevToolPortalFeatureSettingsResponse']:
        """
        Settings for Dev Tool Portal
        """
        return pulumi.get(self, "features")

    @property
    @pulumi.getter
    def public(self) -> Optional[builtins.bool]:
        """
        Indicates whether the resource exposes public endpoint
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="ssoProperties")
    def sso_properties(self) -> Optional['outputs.DevToolPortalSsoPropertiesResponse']:
        """
        Single sign-on related configuration
        """
        return pulumi.get(self, "sso_properties")


@pulumi.output_type
class DevToolPortalResourceRequestsResponse(dict):
    """
    The resource quantity for required CPU and Memory of Dev Tool Portal
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevToolPortalResourceRequestsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevToolPortalResourceRequestsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevToolPortalResourceRequestsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: builtins.str,
                 instance_count: builtins.int,
                 memory: builtins.str):
        """
        The resource quantity for required CPU and Memory of Dev Tool Portal
        :param builtins.str cpu: Cpu quantity allocated to each Dev Tool Portal instance. 1 core can be represented by 1 or 1000m
        :param builtins.int instance_count: Desired instance count of Dev Tool Portal.
        :param builtins.str memory: Memory quantity allocated to each Dev Tool Portal instance. 1 GB can be represented by 1Gi or 1024Mi.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.str:
        """
        Cpu quantity allocated to each Dev Tool Portal instance. 1 core can be represented by 1 or 1000m
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> builtins.int:
        """
        Desired instance count of Dev Tool Portal.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter
    def memory(self) -> builtins.str:
        """
        Memory quantity allocated to each Dev Tool Portal instance. 1 GB can be represented by 1Gi or 1024Mi.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class DevToolPortalSsoPropertiesResponse(dict):
    """
    Single sign-on related configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "metadataUrl":
            suggest = "metadata_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DevToolPortalSsoPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DevToolPortalSsoPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DevToolPortalSsoPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 metadata_url: Optional[builtins.str] = None,
                 scopes: Optional[Sequence[builtins.str]] = None):
        """
        Single sign-on related configuration
        :param builtins.str client_id: The public identifier for the application
        :param builtins.str client_secret: The secret known only to the application and the authorization server
        :param builtins.str metadata_url: The URI of a JSON file with generic OIDC provider configuration.
        :param Sequence[builtins.str] scopes: It defines the specific actions applications can be allowed to do on a user's behalf
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if metadata_url is not None:
            pulumi.set(__self__, "metadata_url", metadata_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The public identifier for the application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The secret known only to the application and the authorization server
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> Optional[builtins.str]:
        """
        The URI of a JSON file with generic OIDC provider configuration.
        """
        return pulumi.get(self, "metadata_url")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        It defines the specific actions applications can be allowed to do on a user's behalf
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class EnvVarResponse(dict):
    """
    Azure Spring Apps components' environment variable.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretValue":
            suggest = "secret_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvVarResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvVarResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvVarResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 secret_value: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        Azure Spring Apps components' environment variable.
        :param builtins.str name: Environment variable name.
        :param builtins.str secret_value: secret environment variable value.
        :param builtins.str value: Non-secret environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_value is not None:
            pulumi.set(__self__, "secret_value", secret_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Environment variable name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretValue")
    def secret_value(self) -> Optional[builtins.str]:
        """
        secret environment variable value.
        """
        return pulumi.get(self, "secret_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Non-secret environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ErrorResponse(dict):
    """
    The error code compose of code and message.
    """
    def __init__(__self__, *,
                 code: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None):
        """
        The error code compose of code and message.
        :param builtins.str code: The code of error.
        :param builtins.str message: The message of error.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[builtins.str]:
        """
        The code of error.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        The message of error.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ExecActionResponse(dict):
    """
    ExecAction describes a "run in container" action.
    """
    def __init__(__self__, *,
                 type: builtins.str,
                 command: Optional[Sequence[builtins.str]] = None):
        """
        ExecAction describes a "run in container" action.
        :param builtins.str type: The type of the action to take to perform the health check.
               Expected value is 'ExecAction'.
        :param Sequence[builtins.str] command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        pulumi.set(__self__, "type", 'ExecAction')
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the action to take to perform the health check.
        Expected value is 'ExecAction'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[builtins.str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "command")


@pulumi.output_type
class GatewayApiMetadataPropertiesResponse(dict):
    """
    API metadata property for Spring Cloud Gateway
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverUrl":
            suggest = "server_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayApiMetadataPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayApiMetadataPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayApiMetadataPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[builtins.str] = None,
                 documentation: Optional[builtins.str] = None,
                 server_url: Optional[builtins.str] = None,
                 title: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        API metadata property for Spring Cloud Gateway
        :param builtins.str description: Detailed description of the APIs available on the Gateway instance (default: `Generated OpenAPI 3 document that describes the API routes configured.`)
        :param builtins.str documentation: Location of additional documentation for the APIs available on the Gateway instance
        :param builtins.str server_url: Base URL that API consumers will use to access APIs on the Gateway instance.
        :param builtins.str title: Title describing the context of the APIs available on the Gateway instance (default: `Spring Cloud Gateway for K8S`)
        :param builtins.str version: Version of APIs available on this Gateway instance (default: `unspecified`).
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if documentation is not None:
            pulumi.set(__self__, "documentation", documentation)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Detailed description of the APIs available on the Gateway instance (default: `Generated OpenAPI 3 document that describes the API routes configured.`)
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def documentation(self) -> Optional[builtins.str]:
        """
        Location of additional documentation for the APIs available on the Gateway instance
        """
        return pulumi.get(self, "documentation")

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[builtins.str]:
        """
        Base URL that API consumers will use to access APIs on the Gateway instance.
        """
        return pulumi.get(self, "server_url")

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        Title describing the context of the APIs available on the Gateway instance (default: `Spring Cloud Gateway for K8S`)
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of APIs available on this Gateway instance (default: `unspecified`).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GatewayApiRouteResponse(dict):
    """
    API route config of the Spring Cloud Gateway
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ssoEnabled":
            suggest = "sso_enabled"
        elif key == "tokenRelay":
            suggest = "token_relay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayApiRouteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayApiRouteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayApiRouteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[builtins.str] = None,
                 filters: Optional[Sequence[builtins.str]] = None,
                 order: Optional[builtins.int] = None,
                 predicates: Optional[Sequence[builtins.str]] = None,
                 sso_enabled: Optional[builtins.bool] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 title: Optional[builtins.str] = None,
                 token_relay: Optional[builtins.bool] = None,
                 uri: Optional[builtins.str] = None):
        """
        API route config of the Spring Cloud Gateway
        :param builtins.str description: A description, will be applied to methods in the generated OpenAPI documentation.
        :param Sequence[builtins.str] filters: To modify the request before sending it to the target endpoint, or the received response.
        :param builtins.int order: Route processing order.
        :param Sequence[builtins.str] predicates: A number of conditions to evaluate a route for each request. Each predicate may be evaluated against request headers and parameter values. All of the predicates associated with a route must evaluate to true for the route to be matched to the request.
        :param builtins.bool sso_enabled: Enable sso validation.
        :param Sequence[builtins.str] tags: Classification tags, will be applied to methods in the generated OpenAPI documentation.
        :param builtins.str title: A title, will be applied to methods in the generated OpenAPI documentation.
        :param builtins.bool token_relay: Pass currently-authenticated user's identity token to application service, default is 'false'
        :param builtins.str uri: Full uri, will override `appName`.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)
        if sso_enabled is not None:
            pulumi.set(__self__, "sso_enabled", sso_enabled)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if token_relay is not None:
            pulumi.set(__self__, "token_relay", token_relay)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A description, will be applied to methods in the generated OpenAPI documentation.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence[builtins.str]]:
        """
        To modify the request before sending it to the target endpoint, or the received response.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def order(self) -> Optional[builtins.int]:
        """
        Route processing order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def predicates(self) -> Optional[Sequence[builtins.str]]:
        """
        A number of conditions to evaluate a route for each request. Each predicate may be evaluated against request headers and parameter values. All of the predicates associated with a route must evaluate to true for the route to be matched to the request.
        """
        return pulumi.get(self, "predicates")

    @property
    @pulumi.getter(name="ssoEnabled")
    def sso_enabled(self) -> Optional[builtins.bool]:
        """
        Enable sso validation.
        """
        return pulumi.get(self, "sso_enabled")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        """
        Classification tags, will be applied to methods in the generated OpenAPI documentation.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        A title, will be applied to methods in the generated OpenAPI documentation.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="tokenRelay")
    def token_relay(self) -> Optional[builtins.bool]:
        """
        Pass currently-authenticated user's identity token to application service, default is 'false'
        """
        return pulumi.get(self, "token_relay")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        Full uri, will override `appName`.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GatewayCorsPropertiesResponse(dict):
    """
    Cross-Origin Resource Sharing property
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOriginPatterns":
            suggest = "allowed_origin_patterns"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "exposedHeaders":
            suggest = "exposed_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayCorsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayCorsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayCorsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[builtins.bool] = None,
                 allowed_headers: Optional[Sequence[builtins.str]] = None,
                 allowed_methods: Optional[Sequence[builtins.str]] = None,
                 allowed_origin_patterns: Optional[Sequence[builtins.str]] = None,
                 allowed_origins: Optional[Sequence[builtins.str]] = None,
                 exposed_headers: Optional[Sequence[builtins.str]] = None,
                 max_age: Optional[builtins.int] = None):
        """
        Cross-Origin Resource Sharing property
        :param builtins.bool allow_credentials: Whether user credentials are supported on cross-site requests. Valid values: `true`, `false`.
        :param Sequence[builtins.str] allowed_headers: Allowed headers in cross-site requests. The special value `*` allows actual requests to send any header.
        :param Sequence[builtins.str] allowed_methods: Allowed HTTP methods on cross-site requests. The special value `*` allows all methods. If not set, `GET` and `HEAD` are allowed by default.
        :param Sequence[builtins.str] allowed_origin_patterns: Allowed origin patterns to make cross-site requests.
        :param Sequence[builtins.str] allowed_origins: Allowed origins to make cross-site requests. The special value `*` allows all domains.
        :param Sequence[builtins.str] exposed_headers: HTTP response headers to expose for cross-site requests.
        :param builtins.int max_age: How long, in seconds, the response from a pre-flight request can be cached by clients.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origin_patterns is not None:
            pulumi.set(__self__, "allowed_origin_patterns", allowed_origin_patterns)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[builtins.bool]:
        """
        Whether user credentials are supported on cross-site requests. Valid values: `true`, `false`.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[builtins.str]]:
        """
        Allowed headers in cross-site requests. The special value `*` allows actual requests to send any header.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        Allowed HTTP methods on cross-site requests. The special value `*` allows all methods. If not set, `GET` and `HEAD` are allowed by default.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOriginPatterns")
    def allowed_origin_patterns(self) -> Optional[Sequence[builtins.str]]:
        """
        Allowed origin patterns to make cross-site requests.
        """
        return pulumi.get(self, "allowed_origin_patterns")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[builtins.str]]:
        """
        Allowed origins to make cross-site requests. The special value `*` allows all domains.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[Sequence[builtins.str]]:
        """
        HTTP response headers to expose for cross-site requests.
        """
        return pulumi.get(self, "exposed_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[builtins.int]:
        """
        How long, in seconds, the response from a pre-flight request can be cached by clients.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GatewayCustomDomainPropertiesResponse(dict):
    """
    The properties of custom domain for Spring Cloud Gateway
    """
    def __init__(__self__, *,
                 thumbprint: Optional[builtins.str] = None):
        """
        The properties of custom domain for Spring Cloud Gateway
        :param builtins.str thumbprint: The thumbprint of bound certificate.
        """
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        The thumbprint of bound certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class GatewayInstanceResponse(dict):
    """
    Collection of instances belong to the Spring Cloud Gateway
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 status: builtins.str):
        """
        Collection of instances belong to the Spring Cloud Gateway
        :param builtins.str name: Name of the Spring Cloud Gateway instance
        :param builtins.str status: Status of the Spring Cloud Gateway instance
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the Spring Cloud Gateway instance
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the Spring Cloud Gateway instance
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GatewayLocalResponseCachePerInstancePropertiesResponse(dict):
    """
    Spring Cloud Gateway local response cache per instance properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCacheType":
            suggest = "response_cache_type"
        elif key == "timeToLive":
            suggest = "time_to_live"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayLocalResponseCachePerInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayLocalResponseCachePerInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayLocalResponseCachePerInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_cache_type: builtins.str,
                 size: Optional[builtins.str] = None,
                 time_to_live: Optional[builtins.str] = None):
        """
        Spring Cloud Gateway local response cache per instance properties.
        :param builtins.str response_cache_type: The type of the response cache.
               Expected value is 'LocalCachePerInstance'.
        :param builtins.str size: Maximum size of cache (10MB, 900KB, 1GB...) to determine if the cache needs to evict some entries
        :param builtins.str time_to_live: Time before a cached entry is expired (300s, 5m, 1h...)
        """
        pulumi.set(__self__, "response_cache_type", 'LocalCachePerInstance')
        if size is not None:
            pulumi.set(__self__, "size", size)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @property
    @pulumi.getter(name="responseCacheType")
    def response_cache_type(self) -> builtins.str:
        """
        The type of the response cache.
        Expected value is 'LocalCachePerInstance'.
        """
        return pulumi.get(self, "response_cache_type")

    @property
    @pulumi.getter
    def size(self) -> Optional[builtins.str]:
        """
        Maximum size of cache (10MB, 900KB, 1GB...) to determine if the cache needs to evict some entries
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[builtins.str]:
        """
        Time before a cached entry is expired (300s, 5m, 1h...)
        """
        return pulumi.get(self, "time_to_live")


@pulumi.output_type
class GatewayLocalResponseCachePerRoutePropertiesResponse(dict):
    """
    Spring Cloud Gateway local response cache per route properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseCacheType":
            suggest = "response_cache_type"
        elif key == "timeToLive":
            suggest = "time_to_live"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayLocalResponseCachePerRoutePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayLocalResponseCachePerRoutePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayLocalResponseCachePerRoutePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_cache_type: builtins.str,
                 size: Optional[builtins.str] = None,
                 time_to_live: Optional[builtins.str] = None):
        """
        Spring Cloud Gateway local response cache per route properties.
        :param builtins.str response_cache_type: The type of the response cache.
               Expected value is 'LocalCachePerRoute'.
        :param builtins.str size: Maximum size of cache (10MB, 900KB, 1GB...) to determine if the cache needs to evict some entries.
        :param builtins.str time_to_live: Time before a cached entry is expired (300s, 5m, 1h...)
        """
        pulumi.set(__self__, "response_cache_type", 'LocalCachePerRoute')
        if size is not None:
            pulumi.set(__self__, "size", size)
        if time_to_live is not None:
            pulumi.set(__self__, "time_to_live", time_to_live)

    @property
    @pulumi.getter(name="responseCacheType")
    def response_cache_type(self) -> builtins.str:
        """
        The type of the response cache.
        Expected value is 'LocalCachePerRoute'.
        """
        return pulumi.get(self, "response_cache_type")

    @property
    @pulumi.getter
    def size(self) -> Optional[builtins.str]:
        """
        Maximum size of cache (10MB, 900KB, 1GB...) to determine if the cache needs to evict some entries.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="timeToLive")
    def time_to_live(self) -> Optional[builtins.str]:
        """
        Time before a cached entry is expired (300s, 5m, 1h...)
        """
        return pulumi.get(self, "time_to_live")


@pulumi.output_type
class GatewayOperatorPropertiesResponse(dict):
    """
    Properties of the Spring Cloud Gateway Operator.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceRequests":
            suggest = "resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayOperatorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayOperatorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayOperatorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.GatewayInstanceResponse'],
                 resource_requests: 'outputs.GatewayOperatorResourceRequestsResponse'):
        """
        Properties of the Spring Cloud Gateway Operator.
        :param Sequence['GatewayInstanceResponse'] instances: Collection of instances belong to Spring Cloud Gateway operator.
        :param 'GatewayOperatorResourceRequestsResponse' resource_requests: The requested resource quantity for required CPU and Memory.
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "resource_requests", resource_requests)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GatewayInstanceResponse']:
        """
        Collection of instances belong to Spring Cloud Gateway operator.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> 'outputs.GatewayOperatorResourceRequestsResponse':
        """
        The requested resource quantity for required CPU and Memory.
        """
        return pulumi.get(self, "resource_requests")


@pulumi.output_type
class GatewayOperatorResourceRequestsResponse(dict):
    """
    Properties of the Spring Cloud Gateway Operator.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayOperatorResourceRequestsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayOperatorResourceRequestsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayOperatorResourceRequestsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: builtins.str,
                 instance_count: builtins.int,
                 memory: builtins.str):
        """
        Properties of the Spring Cloud Gateway Operator.
        :param builtins.str cpu: Cpu allocated to each Spring Cloud Gateway Operator instance.
        :param builtins.int instance_count: Instance count of the Spring Cloud Gateway Operator.
        :param builtins.str memory: Memory allocated to each Spring Cloud Gateway Operator instance.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.str:
        """
        Cpu allocated to each Spring Cloud Gateway Operator instance.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> builtins.int:
        """
        Instance count of the Spring Cloud Gateway Operator.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter
    def memory(self) -> builtins.str:
        """
        Memory allocated to each Spring Cloud Gateway Operator instance.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class GatewayPropertiesResponse(dict):
    """
    Spring Cloud Gateway properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorProperties":
            suggest = "operator_properties"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "addonConfigs":
            suggest = "addon_configs"
        elif key == "apiMetadataProperties":
            suggest = "api_metadata_properties"
        elif key == "apmTypes":
            suggest = "apm_types"
        elif key == "clientAuth":
            suggest = "client_auth"
        elif key == "corsProperties":
            suggest = "cors_properties"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "httpsOnly":
            suggest = "https_only"
        elif key == "resourceRequests":
            suggest = "resource_requests"
        elif key == "responseCacheProperties":
            suggest = "response_cache_properties"
        elif key == "ssoProperties":
            suggest = "sso_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.GatewayInstanceResponse'],
                 operator_properties: 'outputs.GatewayOperatorPropertiesResponse',
                 provisioning_state: builtins.str,
                 url: builtins.str,
                 addon_configs: Optional[Mapping[str, Any]] = None,
                 api_metadata_properties: Optional['outputs.GatewayApiMetadataPropertiesResponse'] = None,
                 apm_types: Optional[Sequence[builtins.str]] = None,
                 apms: Optional[Sequence['outputs.ApmReferenceResponse']] = None,
                 client_auth: Optional['outputs.GatewayPropertiesResponseClientAuth'] = None,
                 cors_properties: Optional['outputs.GatewayCorsPropertiesResponse'] = None,
                 environment_variables: Optional['outputs.GatewayPropertiesResponseEnvironmentVariables'] = None,
                 https_only: Optional[builtins.bool] = None,
                 public: Optional[builtins.bool] = None,
                 resource_requests: Optional['outputs.GatewayResourceRequestsResponse'] = None,
                 response_cache_properties: Optional[Any] = None,
                 sso_properties: Optional['outputs.SsoPropertiesResponse'] = None):
        """
        Spring Cloud Gateway properties payload
        :param Sequence['GatewayInstanceResponse'] instances: Collection of instances belong to Spring Cloud Gateway.
        :param 'GatewayOperatorPropertiesResponse' operator_properties: Properties of the Spring Cloud Gateway Operator.
        :param builtins.str provisioning_state: State of the Spring Cloud Gateway.
        :param builtins.str url: URL of the Spring Cloud Gateway, exposed when 'public' is true.
        :param Mapping[str, Any] addon_configs: Collection of addons for Spring Cloud Gateway
        :param 'GatewayApiMetadataPropertiesResponse' api_metadata_properties: API metadata property for Spring Cloud Gateway
        :param Sequence[builtins.str] apm_types: Collection of APM type used in Spring Cloud Gateway
        :param Sequence['ApmReferenceResponse'] apms: Collection of ApmReferences in service level
        :param 'GatewayPropertiesResponseClientAuth' client_auth: Client-Certification Authentication.
        :param 'GatewayCorsPropertiesResponse' cors_properties: Cross-Origin Resource Sharing property
        :param 'GatewayPropertiesResponseEnvironmentVariables' environment_variables: Environment variables of Spring Cloud Gateway
        :param builtins.bool https_only: Indicate if only https is allowed.
        :param builtins.bool public: Indicates whether the Spring Cloud Gateway exposes endpoint.
        :param 'GatewayResourceRequestsResponse' resource_requests: The requested resource quantity for required CPU and Memory.
        :param Union['GatewayLocalResponseCachePerInstancePropertiesResponse', 'GatewayLocalResponseCachePerRoutePropertiesResponse'] response_cache_properties: The properties to configure different types of response cache for Spring Cloud Gateway.
        :param 'SsoPropertiesResponse' sso_properties: Single sign-on related configuration
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "operator_properties", operator_properties)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "url", url)
        if addon_configs is not None:
            pulumi.set(__self__, "addon_configs", addon_configs)
        if api_metadata_properties is not None:
            pulumi.set(__self__, "api_metadata_properties", api_metadata_properties)
        if apm_types is not None:
            pulumi.set(__self__, "apm_types", apm_types)
        if apms is not None:
            pulumi.set(__self__, "apms", apms)
        if client_auth is not None:
            pulumi.set(__self__, "client_auth", client_auth)
        if cors_properties is not None:
            pulumi.set(__self__, "cors_properties", cors_properties)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if https_only is None:
            https_only = False
        if https_only is not None:
            pulumi.set(__self__, "https_only", https_only)
        if public is None:
            public = False
        if public is not None:
            pulumi.set(__self__, "public", public)
        if resource_requests is not None:
            pulumi.set(__self__, "resource_requests", resource_requests)
        if response_cache_properties is not None:
            pulumi.set(__self__, "response_cache_properties", response_cache_properties)
        if sso_properties is not None:
            pulumi.set(__self__, "sso_properties", sso_properties)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GatewayInstanceResponse']:
        """
        Collection of instances belong to Spring Cloud Gateway.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="operatorProperties")
    def operator_properties(self) -> 'outputs.GatewayOperatorPropertiesResponse':
        """
        Properties of the Spring Cloud Gateway Operator.
        """
        return pulumi.get(self, "operator_properties")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the Spring Cloud Gateway.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def url(self) -> builtins.str:
        """
        URL of the Spring Cloud Gateway, exposed when 'public' is true.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="addonConfigs")
    def addon_configs(self) -> Optional[Mapping[str, Any]]:
        """
        Collection of addons for Spring Cloud Gateway
        """
        return pulumi.get(self, "addon_configs")

    @property
    @pulumi.getter(name="apiMetadataProperties")
    def api_metadata_properties(self) -> Optional['outputs.GatewayApiMetadataPropertiesResponse']:
        """
        API metadata property for Spring Cloud Gateway
        """
        return pulumi.get(self, "api_metadata_properties")

    @property
    @pulumi.getter(name="apmTypes")
    def apm_types(self) -> Optional[Sequence[builtins.str]]:
        """
        Collection of APM type used in Spring Cloud Gateway
        """
        return pulumi.get(self, "apm_types")

    @property
    @pulumi.getter
    def apms(self) -> Optional[Sequence['outputs.ApmReferenceResponse']]:
        """
        Collection of ApmReferences in service level
        """
        return pulumi.get(self, "apms")

    @property
    @pulumi.getter(name="clientAuth")
    def client_auth(self) -> Optional['outputs.GatewayPropertiesResponseClientAuth']:
        """
        Client-Certification Authentication.
        """
        return pulumi.get(self, "client_auth")

    @property
    @pulumi.getter(name="corsProperties")
    def cors_properties(self) -> Optional['outputs.GatewayCorsPropertiesResponse']:
        """
        Cross-Origin Resource Sharing property
        """
        return pulumi.get(self, "cors_properties")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional['outputs.GatewayPropertiesResponseEnvironmentVariables']:
        """
        Environment variables of Spring Cloud Gateway
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> Optional[builtins.bool]:
        """
        Indicate if only https is allowed.
        """
        return pulumi.get(self, "https_only")

    @property
    @pulumi.getter
    def public(self) -> Optional[builtins.bool]:
        """
        Indicates whether the Spring Cloud Gateway exposes endpoint.
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> Optional['outputs.GatewayResourceRequestsResponse']:
        """
        The requested resource quantity for required CPU and Memory.
        """
        return pulumi.get(self, "resource_requests")

    @property
    @pulumi.getter(name="responseCacheProperties")
    def response_cache_properties(self) -> Optional[Any]:
        """
        The properties to configure different types of response cache for Spring Cloud Gateway.
        """
        return pulumi.get(self, "response_cache_properties")

    @property
    @pulumi.getter(name="ssoProperties")
    def sso_properties(self) -> Optional['outputs.SsoPropertiesResponse']:
        """
        Single sign-on related configuration
        """
        return pulumi.get(self, "sso_properties")


@pulumi.output_type
class GatewayPropertiesResponseClientAuth(dict):
    """
    Client-Certification Authentication.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateVerification":
            suggest = "certificate_verification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayPropertiesResponseClientAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayPropertiesResponseClientAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayPropertiesResponseClientAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_verification: Optional[builtins.str] = None,
                 certificates: Optional[Sequence[builtins.str]] = None):
        """
        Client-Certification Authentication.
        :param builtins.str certificate_verification: Whether to enable certificate verification or not
        :param Sequence[builtins.str] certificates: Collection of certificate resource Ids in Azure Spring Apps.
        """
        if certificate_verification is None:
            certificate_verification = 'Disabled'
        if certificate_verification is not None:
            pulumi.set(__self__, "certificate_verification", certificate_verification)
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)

    @property
    @pulumi.getter(name="certificateVerification")
    def certificate_verification(self) -> Optional[builtins.str]:
        """
        Whether to enable certificate verification or not
        """
        return pulumi.get(self, "certificate_verification")

    @property
    @pulumi.getter
    def certificates(self) -> Optional[Sequence[builtins.str]]:
        """
        Collection of certificate resource Ids in Azure Spring Apps.
        """
        return pulumi.get(self, "certificates")


@pulumi.output_type
class GatewayPropertiesResponseEnvironmentVariables(dict):
    """
    Environment variables of Spring Cloud Gateway
    """
    def __init__(__self__, *,
                 properties: Optional[Mapping[str, builtins.str]] = None,
                 secrets: Optional[Mapping[str, builtins.str]] = None):
        """
        Environment variables of Spring Cloud Gateway
        :param Mapping[str, builtins.str] properties: Non-sensitive properties
        :param Mapping[str, builtins.str] secrets: Sensitive properties
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Non-sensitive properties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Sensitive properties
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class GatewayResourceRequestsResponse(dict):
    """
    Resource request payload of Spring Cloud Gateway.
    """
    def __init__(__self__, *,
                 cpu: Optional[builtins.str] = None,
                 memory: Optional[builtins.str] = None):
        """
        Resource request payload of Spring Cloud Gateway.
        :param builtins.str cpu: Cpu allocated to each Spring Cloud Gateway instance.
        :param builtins.str memory: Memory allocated to each Spring Cloud Gateway instance.
        """
        if cpu is None:
            cpu = '1'
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is None:
            memory = '2Gi'
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[builtins.str]:
        """
        Cpu allocated to each Spring Cloud Gateway instance.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> Optional[builtins.str]:
        """
        Memory allocated to each Spring Cloud Gateway instance.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class GatewayRouteConfigOpenApiPropertiesResponse(dict):
    """
    OpenAPI properties of Spring Cloud Gateway route config.
    """
    def __init__(__self__, *,
                 uri: Optional[builtins.str] = None):
        """
        OpenAPI properties of Spring Cloud Gateway route config.
        :param builtins.str uri: The URI of OpenAPI specification.
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        The URI of OpenAPI specification.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GatewayRouteConfigPropertiesResponse(dict):
    """
    API route config of the Spring Cloud Gateway
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "appResourceId":
            suggest = "app_resource_id"
        elif key == "openApi":
            suggest = "open_api"
        elif key == "ssoEnabled":
            suggest = "sso_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayRouteConfigPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayRouteConfigPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayRouteConfigPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 app_resource_id: Optional[builtins.str] = None,
                 filters: Optional[Sequence[builtins.str]] = None,
                 open_api: Optional['outputs.GatewayRouteConfigOpenApiPropertiesResponse'] = None,
                 predicates: Optional[Sequence[builtins.str]] = None,
                 protocol: Optional[builtins.str] = None,
                 routes: Optional[Sequence['outputs.GatewayApiRouteResponse']] = None,
                 sso_enabled: Optional[builtins.bool] = None):
        """
        API route config of the Spring Cloud Gateway
        :param builtins.str provisioning_state: State of the Spring Cloud Gateway route config.
        :param builtins.str app_resource_id: The resource Id of the Azure Spring Apps app, required unless route defines `uri`.
        :param Sequence[builtins.str] filters: To modify the request before sending it to the target endpoint, or the received response in app level.
        :param 'GatewayRouteConfigOpenApiPropertiesResponse' open_api: OpenAPI properties of Spring Cloud Gateway route config.
        :param Sequence[builtins.str] predicates: A number of conditions to evaluate a route for each request in app level. Each predicate may be evaluated against request headers and parameter values. All of the predicates associated with a route must evaluate to true for the route to be matched to the request.
        :param builtins.str protocol: Protocol of routed Azure Spring Apps applications.
        :param Sequence['GatewayApiRouteResponse'] routes: Array of API routes, each route contains properties such as `title`, `uri`, `ssoEnabled`, `predicates`, `filters`.
        :param builtins.bool sso_enabled: Enable Single Sign-On in app level.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if app_resource_id is not None:
            pulumi.set(__self__, "app_resource_id", app_resource_id)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if open_api is not None:
            pulumi.set(__self__, "open_api", open_api)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)
        if protocol is None:
            protocol = 'HTTP'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if sso_enabled is not None:
            pulumi.set(__self__, "sso_enabled", sso_enabled)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the Spring Cloud Gateway route config.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="appResourceId")
    def app_resource_id(self) -> Optional[builtins.str]:
        """
        The resource Id of the Azure Spring Apps app, required unless route defines `uri`.
        """
        return pulumi.get(self, "app_resource_id")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence[builtins.str]]:
        """
        To modify the request before sending it to the target endpoint, or the received response in app level.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="openApi")
    def open_api(self) -> Optional['outputs.GatewayRouteConfigOpenApiPropertiesResponse']:
        """
        OpenAPI properties of Spring Cloud Gateway route config.
        """
        return pulumi.get(self, "open_api")

    @property
    @pulumi.getter
    def predicates(self) -> Optional[Sequence[builtins.str]]:
        """
        A number of conditions to evaluate a route for each request in app level. Each predicate may be evaluated against request headers and parameter values. All of the predicates associated with a route must evaluate to true for the route to be matched to the request.
        """
        return pulumi.get(self, "predicates")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        """
        Protocol of routed Azure Spring Apps applications.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.GatewayApiRouteResponse']]:
        """
        Array of API routes, each route contains properties such as `title`, `uri`, `ssoEnabled`, `predicates`, `filters`.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter(name="ssoEnabled")
    def sso_enabled(self) -> Optional[builtins.bool]:
        """
        Enable Single Sign-On in app level.
        """
        return pulumi.get(self, "sso_enabled")


@pulumi.output_type
class GitPatternRepositoryResponse(dict):
    """
    Git repository property payload for config server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostKey":
            suggest = "host_key"
        elif key == "hostKeyAlgorithm":
            suggest = "host_key_algorithm"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "searchPaths":
            suggest = "search_paths"
        elif key == "strictHostKeyChecking":
            suggest = "strict_host_key_checking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitPatternRepositoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitPatternRepositoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitPatternRepositoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 uri: builtins.str,
                 host_key: Optional[builtins.str] = None,
                 host_key_algorithm: Optional[builtins.str] = None,
                 label: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 pattern: Optional[Sequence[builtins.str]] = None,
                 private_key: Optional[builtins.str] = None,
                 search_paths: Optional[Sequence[builtins.str]] = None,
                 strict_host_key_checking: Optional[builtins.bool] = None,
                 username: Optional[builtins.str] = None):
        """
        Git repository property payload for config server
        :param builtins.str name: Name of the repository
        :param builtins.str uri: URI of the repository
        :param builtins.str host_key: Public sshKey of git repository.
        :param builtins.str host_key_algorithm: SshKey algorithm of git repository.
        :param builtins.str label: Label of the repository
        :param builtins.str password: Password of git repository basic auth.
        :param Sequence[builtins.str] pattern: Collection of pattern of the repository
        :param builtins.str private_key: Private sshKey algorithm of git repository.
        :param Sequence[builtins.str] search_paths: Searching path of the repository
        :param builtins.bool strict_host_key_checking: Strict host key checking or not.
        :param builtins.str username: Username of git repository basic auth.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uri", uri)
        if host_key is not None:
            pulumi.set(__self__, "host_key", host_key)
        if host_key_algorithm is not None:
            pulumi.set(__self__, "host_key_algorithm", host_key_algorithm)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if search_paths is not None:
            pulumi.set(__self__, "search_paths", search_paths)
        if strict_host_key_checking is not None:
            pulumi.set(__self__, "strict_host_key_checking", strict_host_key_checking)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the repository
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        URI of the repository
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="hostKey")
    def host_key(self) -> Optional[builtins.str]:
        """
        Public sshKey of git repository.
        """
        return pulumi.get(self, "host_key")

    @property
    @pulumi.getter(name="hostKeyAlgorithm")
    def host_key_algorithm(self) -> Optional[builtins.str]:
        """
        SshKey algorithm of git repository.
        """
        return pulumi.get(self, "host_key_algorithm")

    @property
    @pulumi.getter
    def label(self) -> Optional[builtins.str]:
        """
        Label of the repository
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        Password of git repository basic auth.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[Sequence[builtins.str]]:
        """
        Collection of pattern of the repository
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        """
        Private sshKey algorithm of git repository.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="searchPaths")
    def search_paths(self) -> Optional[Sequence[builtins.str]]:
        """
        Searching path of the repository
        """
        return pulumi.get(self, "search_paths")

    @property
    @pulumi.getter(name="strictHostKeyChecking")
    def strict_host_key_checking(self) -> Optional[builtins.bool]:
        """
        Strict host key checking or not.
        """
        return pulumi.get(self, "strict_host_key_checking")

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        Username of git repository basic auth.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class HTTPGetActionResponse(dict):
    """
    HTTPGetAction describes an action based on HTTP Get requests.
    """
    def __init__(__self__, *,
                 type: builtins.str,
                 path: Optional[builtins.str] = None,
                 scheme: Optional[builtins.str] = None):
        """
        HTTPGetAction describes an action based on HTTP Get requests.
        :param builtins.str type: The type of the action to take to perform the health check.
               Expected value is 'HTTPGetAction'.
        :param builtins.str path: Path to access on the HTTP server.
        :param builtins.str scheme: Scheme to use for connecting to the host. Defaults to HTTP.
               
               Possible enum values:
                - `"HTTP"` means that the scheme used will be http://
                - `"HTTPS"` means that the scheme used will be https://
        """
        pulumi.set(__self__, "type", 'HTTPGetAction')
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the action to take to perform the health check.
        Expected value is 'HTTPGetAction'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[builtins.str]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.

        Possible enum values:
         - `"HTTP"` means that the scheme used will be http://
         - `"HTTPS"` means that the scheme used will be https://
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class HttpScaleRuleResponse(dict):
    """
    Azure Spring Apps App Instance Http scaling rule.
    """
    def __init__(__self__, *,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None):
        """
        Azure Spring Apps App Instance Http scaling rule.
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the custom scale rule.
        :param Mapping[str, builtins.str] metadata: Metadata properties to describe http scale rule.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Metadata properties to describe http scale rule.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class ImageRegistryCredentialResponse(dict):
    """
    Credential of the image registry
    """
    def __init__(__self__, *,
                 password: Optional[builtins.str] = None,
                 username: Optional[builtins.str] = None):
        """
        Credential of the image registry
        :param builtins.str password: The password of the image registry credential
        :param builtins.str username: The username of the image registry credential
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        The password of the image registry credential
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        The username of the image registry credential
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class IngressConfigResponse(dict):
    """
    Ingress configuration payload for Azure Spring Apps resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readTimeoutInSeconds":
            suggest = "read_timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_timeout_in_seconds: Optional[builtins.int] = None):
        """
        Ingress configuration payload for Azure Spring Apps resource.
        :param builtins.int read_timeout_in_seconds: Ingress read time out in seconds.
        """
        if read_timeout_in_seconds is not None:
            pulumi.set(__self__, "read_timeout_in_seconds", read_timeout_in_seconds)

    @property
    @pulumi.getter(name="readTimeoutInSeconds")
    def read_timeout_in_seconds(self) -> Optional[builtins.int]:
        """
        Ingress read time out in seconds.
        """
        return pulumi.get(self, "read_timeout_in_seconds")


@pulumi.output_type
class IngressSettingsResponse(dict):
    """
    App ingress settings payload.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendProtocol":
            suggest = "backend_protocol"
        elif key == "clientAuth":
            suggest = "client_auth"
        elif key == "readTimeoutInSeconds":
            suggest = "read_timeout_in_seconds"
        elif key == "sendTimeoutInSeconds":
            suggest = "send_timeout_in_seconds"
        elif key == "sessionAffinity":
            suggest = "session_affinity"
        elif key == "sessionCookieMaxAge":
            suggest = "session_cookie_max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_protocol: Optional[builtins.str] = None,
                 client_auth: Optional['outputs.IngressSettingsResponseClientAuth'] = None,
                 read_timeout_in_seconds: Optional[builtins.int] = None,
                 send_timeout_in_seconds: Optional[builtins.int] = None,
                 session_affinity: Optional[builtins.str] = None,
                 session_cookie_max_age: Optional[builtins.int] = None):
        """
        App ingress settings payload.
        :param builtins.str backend_protocol: How ingress should communicate with this app backend service.
        :param 'IngressSettingsResponseClientAuth' client_auth: Client-Certification Authentication.
        :param builtins.int read_timeout_in_seconds: Ingress read time out in seconds.
        :param builtins.int send_timeout_in_seconds: Ingress send time out in seconds.
        :param builtins.str session_affinity: Type of the affinity, set this to Cookie to enable session affinity.
        :param builtins.int session_cookie_max_age: Time in seconds until the cookie expires.
        """
        if backend_protocol is not None:
            pulumi.set(__self__, "backend_protocol", backend_protocol)
        if client_auth is not None:
            pulumi.set(__self__, "client_auth", client_auth)
        if read_timeout_in_seconds is not None:
            pulumi.set(__self__, "read_timeout_in_seconds", read_timeout_in_seconds)
        if send_timeout_in_seconds is not None:
            pulumi.set(__self__, "send_timeout_in_seconds", send_timeout_in_seconds)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if session_cookie_max_age is not None:
            pulumi.set(__self__, "session_cookie_max_age", session_cookie_max_age)

    @property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> Optional[builtins.str]:
        """
        How ingress should communicate with this app backend service.
        """
        return pulumi.get(self, "backend_protocol")

    @property
    @pulumi.getter(name="clientAuth")
    def client_auth(self) -> Optional['outputs.IngressSettingsResponseClientAuth']:
        """
        Client-Certification Authentication.
        """
        return pulumi.get(self, "client_auth")

    @property
    @pulumi.getter(name="readTimeoutInSeconds")
    def read_timeout_in_seconds(self) -> Optional[builtins.int]:
        """
        Ingress read time out in seconds.
        """
        return pulumi.get(self, "read_timeout_in_seconds")

    @property
    @pulumi.getter(name="sendTimeoutInSeconds")
    def send_timeout_in_seconds(self) -> Optional[builtins.int]:
        """
        Ingress send time out in seconds.
        """
        return pulumi.get(self, "send_timeout_in_seconds")

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[builtins.str]:
        """
        Type of the affinity, set this to Cookie to enable session affinity.
        """
        return pulumi.get(self, "session_affinity")

    @property
    @pulumi.getter(name="sessionCookieMaxAge")
    def session_cookie_max_age(self) -> Optional[builtins.int]:
        """
        Time in seconds until the cookie expires.
        """
        return pulumi.get(self, "session_cookie_max_age")


@pulumi.output_type
class IngressSettingsResponseClientAuth(dict):
    """
    Client-Certification Authentication.
    """
    def __init__(__self__, *,
                 certificates: Optional[Sequence[builtins.str]] = None):
        """
        Client-Certification Authentication.
        :param Sequence[builtins.str] certificates: Collection of certificate resource id.
        """
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)

    @property
    @pulumi.getter
    def certificates(self) -> Optional[Sequence[builtins.str]]:
        """
        Collection of certificate resource id.
        """
        return pulumi.get(self, "certificates")


@pulumi.output_type
class JarUploadedUserSourceInfoResponse(dict):
    """
    Uploaded Jar binary for a deployment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jvmOptions":
            suggest = "jvm_options"
        elif key == "relativePath":
            suggest = "relative_path"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JarUploadedUserSourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JarUploadedUserSourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JarUploadedUserSourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 jvm_options: Optional[builtins.str] = None,
                 relative_path: Optional[builtins.str] = None,
                 runtime_version: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Uploaded Jar binary for a deployment
        :param builtins.str type: Type of the source uploaded
               Expected value is 'Jar'.
        :param builtins.str jvm_options: JVM parameter
        :param builtins.str relative_path: Relative path of the storage which stores the source
        :param builtins.str runtime_version: Runtime version of the Jar file
        :param builtins.str version: Version of the source
        """
        pulumi.set(__self__, "type", 'Jar')
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the source uploaded
        Expected value is 'Jar'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[builtins.str]:
        """
        JVM parameter
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[builtins.str]:
        """
        Relative path of the storage which stores the source
        """
        return pulumi.get(self, "relative_path")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[builtins.str]:
        """
        Runtime version of the Jar file
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class JobExecutionTemplateResponse(dict):
    """
    Job's execution template, containing configuration for an execution
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "resourceRequests":
            suggest = "resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobExecutionTemplateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobExecutionTemplateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobExecutionTemplateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Optional[Sequence[builtins.str]] = None,
                 environment_variables: Optional[Sequence['outputs.EnvVarResponse']] = None,
                 resource_requests: Optional['outputs.JobResourceRequestsResponse'] = None):
        """
        Job's execution template, containing configuration for an execution
        :param Sequence[builtins.str] args: Arguments for the Job execution.
        :param Sequence['EnvVarResponse'] environment_variables: Environment variables of Job execution
        :param 'JobResourceRequestsResponse' resource_requests: The requested resource quantity for required CPU and Memory.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if resource_requests is not None:
            pulumi.set(__self__, "resource_requests", resource_requests)

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[builtins.str]]:
        """
        Arguments for the Job execution.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Sequence['outputs.EnvVarResponse']]:
        """
        Environment variables of Job execution
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> Optional['outputs.JobResourceRequestsResponse']:
        """
        The requested resource quantity for required CPU and Memory.
        """
        return pulumi.get(self, "resource_requests")


@pulumi.output_type
class JobResourcePropertiesResponse(dict):
    """
    Job resource properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "managedComponentReferences":
            suggest = "managed_component_references"
        elif key == "triggerConfig":
            suggest = "trigger_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 managed_component_references: Optional[Sequence['outputs.ManagedComponentReferenceResponse']] = None,
                 source: Optional[Any] = None,
                 template: Optional['outputs.JobExecutionTemplateResponse'] = None,
                 trigger_config: Optional['outputs.ManualJobTriggerConfigResponse'] = None):
        """
        Job resource properties payload
        :param builtins.str provisioning_state: Provisioning state of the Job
        :param Sequence['ManagedComponentReferenceResponse'] managed_component_references: Referenced managed components collection
        :param Union['BuildResultUserSourceInfoResponse', 'CustomContainerUserSourceInfoResponse', 'JarUploadedUserSourceInfoResponse', 'NetCoreZipUploadedUserSourceInfoResponse', 'SourceUploadedUserSourceInfoResponse', 'UploadedUserSourceInfoResponse', 'WarUploadedUserSourceInfoResponse'] source: Uploaded source information of the Job.
        :param 'JobExecutionTemplateResponse' template: The template which is applied for all executions of the Job.
        :param 'ManualJobTriggerConfigResponse' trigger_config: The Job trigger related configuration.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if managed_component_references is not None:
            pulumi.set(__self__, "managed_component_references", managed_component_references)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if trigger_config is not None:
            pulumi.set(__self__, "trigger_config", trigger_config)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the Job
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="managedComponentReferences")
    def managed_component_references(self) -> Optional[Sequence['outputs.ManagedComponentReferenceResponse']]:
        """
        Referenced managed components collection
        """
        return pulumi.get(self, "managed_component_references")

    @property
    @pulumi.getter
    def source(self) -> Optional[Any]:
        """
        Uploaded source information of the Job.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.JobExecutionTemplateResponse']:
        """
        The template which is applied for all executions of the Job.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="triggerConfig")
    def trigger_config(self) -> Optional['outputs.ManualJobTriggerConfigResponse']:
        """
        The Job trigger related configuration.
        """
        return pulumi.get(self, "trigger_config")


@pulumi.output_type
class JobResourceRequestsResponse(dict):
    """
    Job resource request payload
    """
    def __init__(__self__, *,
                 cpu: Optional[builtins.str] = None,
                 memory: Optional[builtins.str] = None):
        """
        Job resource request payload
        :param builtins.str cpu: CPU allocated to each job execution instance.
        :param builtins.str memory: Memory allocated to each job execution instance.
        """
        if cpu is None:
            cpu = '1'
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is None:
            memory = '2Gi'
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[builtins.str]:
        """
        CPU allocated to each job execution instance.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> Optional[builtins.str]:
        """
        Memory allocated to each job execution instance.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class KeyVaultCertificatePropertiesResponse(dict):
    """
    Properties of certificate imported from key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activateDate":
            suggest = "activate_date"
        elif key == "dnsNames":
            suggest = "dns_names"
        elif key == "expirationDate":
            suggest = "expiration_date"
        elif key == "issuedDate":
            suggest = "issued_date"
        elif key == "keyVaultCertName":
            suggest = "key_vault_cert_name"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "subjectName":
            suggest = "subject_name"
        elif key == "vaultUri":
            suggest = "vault_uri"
        elif key == "autoSync":
            suggest = "auto_sync"
        elif key == "certVersion":
            suggest = "cert_version"
        elif key == "excludePrivateKey":
            suggest = "exclude_private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultCertificatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultCertificatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultCertificatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activate_date: builtins.str,
                 dns_names: Sequence[builtins.str],
                 expiration_date: builtins.str,
                 issued_date: builtins.str,
                 issuer: builtins.str,
                 key_vault_cert_name: builtins.str,
                 provisioning_state: builtins.str,
                 subject_name: builtins.str,
                 thumbprint: builtins.str,
                 type: builtins.str,
                 vault_uri: builtins.str,
                 auto_sync: Optional[builtins.str] = None,
                 cert_version: Optional[builtins.str] = None,
                 exclude_private_key: Optional[builtins.bool] = None):
        """
        Properties of certificate imported from key vault.
        :param builtins.str activate_date: The activate date of certificate.
        :param Sequence[builtins.str] dns_names: The domain list of certificate.
        :param builtins.str expiration_date: The expiration date of certificate.
        :param builtins.str issued_date: The issue date of certificate.
        :param builtins.str issuer: The issuer of certificate.
        :param builtins.str key_vault_cert_name: The certificate name of key vault.
        :param builtins.str provisioning_state: Provisioning state of the Certificate
        :param builtins.str subject_name: The subject name of certificate.
        :param builtins.str thumbprint: The thumbprint of certificate.
        :param builtins.str type: The type of the certificate source.
               Expected value is 'KeyVaultCertificate'.
        :param builtins.str vault_uri: The vault uri of user key vault.
        :param builtins.str auto_sync: Indicates whether to automatically synchronize certificate from key vault or not.
        :param builtins.str cert_version: The certificate version of key vault.
        :param builtins.bool exclude_private_key: Optional. If set to true, it will not import private key from key vault.
        """
        pulumi.set(__self__, "activate_date", activate_date)
        pulumi.set(__self__, "dns_names", dns_names)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "issued_date", issued_date)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "key_vault_cert_name", key_vault_cert_name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "subject_name", subject_name)
        pulumi.set(__self__, "thumbprint", thumbprint)
        pulumi.set(__self__, "type", 'KeyVaultCertificate')
        pulumi.set(__self__, "vault_uri", vault_uri)
        if auto_sync is None:
            auto_sync = 'Disabled'
        if auto_sync is not None:
            pulumi.set(__self__, "auto_sync", auto_sync)
        if cert_version is not None:
            pulumi.set(__self__, "cert_version", cert_version)
        if exclude_private_key is None:
            exclude_private_key = False
        if exclude_private_key is not None:
            pulumi.set(__self__, "exclude_private_key", exclude_private_key)

    @property
    @pulumi.getter(name="activateDate")
    def activate_date(self) -> builtins.str:
        """
        The activate date of certificate.
        """
        return pulumi.get(self, "activate_date")

    @property
    @pulumi.getter(name="dnsNames")
    def dns_names(self) -> Sequence[builtins.str]:
        """
        The domain list of certificate.
        """
        return pulumi.get(self, "dns_names")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> builtins.str:
        """
        The expiration date of certificate.
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="issuedDate")
    def issued_date(self) -> builtins.str:
        """
        The issue date of certificate.
        """
        return pulumi.get(self, "issued_date")

    @property
    @pulumi.getter
    def issuer(self) -> builtins.str:
        """
        The issuer of certificate.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="keyVaultCertName")
    def key_vault_cert_name(self) -> builtins.str:
        """
        The certificate name of key vault.
        """
        return pulumi.get(self, "key_vault_cert_name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Provisioning state of the Certificate
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> builtins.str:
        """
        The subject name of certificate.
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter
    def thumbprint(self) -> builtins.str:
        """
        The thumbprint of certificate.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the certificate source.
        Expected value is 'KeyVaultCertificate'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> builtins.str:
        """
        The vault uri of user key vault.
        """
        return pulumi.get(self, "vault_uri")

    @property
    @pulumi.getter(name="autoSync")
    def auto_sync(self) -> Optional[builtins.str]:
        """
        Indicates whether to automatically synchronize certificate from key vault or not.
        """
        return pulumi.get(self, "auto_sync")

    @property
    @pulumi.getter(name="certVersion")
    def cert_version(self) -> Optional[builtins.str]:
        """
        The certificate version of key vault.
        """
        return pulumi.get(self, "cert_version")

    @property
    @pulumi.getter(name="excludePrivateKey")
    def exclude_private_key(self) -> Optional[builtins.bool]:
        """
        Optional. If set to true, it will not import private key from key vault.
        """
        return pulumi.get(self, "exclude_private_key")


@pulumi.output_type
class LoadedCertificateResponse(dict):
    """
    Loaded certificate payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "loadTrustStore":
            suggest = "load_trust_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadedCertificateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadedCertificateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadedCertificateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: builtins.str,
                 load_trust_store: Optional[builtins.bool] = None):
        """
        Loaded certificate payload
        :param builtins.str resource_id: Resource Id of loaded certificate
        :param builtins.bool load_trust_store: Indicate whether the certificate will be loaded into default trust store, only work for Java runtime.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        if load_trust_store is None:
            load_trust_store = False
        if load_trust_store is not None:
            pulumi.set(__self__, "load_trust_store", load_trust_store)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> builtins.str:
        """
        Resource Id of loaded certificate
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="loadTrustStore")
    def load_trust_store(self) -> Optional[builtins.bool]:
        """
        Indicate whether the certificate will be loaded into default trust store, only work for Java runtime.
        """
        return pulumi.get(self, "load_trust_store")


@pulumi.output_type
class ManagedComponentReferenceResponse(dict):
    """
    A reference to the managed component like Config Server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedComponentReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedComponentReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedComponentReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: builtins.str):
        """
        A reference to the managed component like Config Server.
        :param builtins.str resource_id: Resource Id of the managed component
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> builtins.str:
        """
        Resource Id of the managed component
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ManagedIdentityPropertiesResponse(dict):
    """
    Managed identity properties retrieved from ARM request headers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedManagedIdentityResponse']] = None):
        """
        Managed identity properties retrieved from ARM request headers.
        :param builtins.str principal_id: Principal Id of system-assigned managed identity.
        :param builtins.str tenant_id: Tenant Id of system-assigned managed identity.
        :param builtins.str type: Type of the managed identity
        :param Mapping[str, 'UserAssignedManagedIdentityResponse'] user_assigned_identities: Properties of user-assigned managed identities
        """
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[builtins.str]:
        """
        Principal Id of system-assigned managed identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        Tenant Id of system-assigned managed identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the managed identity
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedManagedIdentityResponse']]:
        """
        Properties of user-assigned managed identities
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ManualJobTriggerConfigResponse(dict):
    """
    Configuration for manual triggered job
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"
        elif key == "retryLimit":
            suggest = "retry_limit"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManualJobTriggerConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManualJobTriggerConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManualJobTriggerConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger_type: Optional[builtins.str] = None,
                 parallelism: Optional[builtins.int] = None,
                 retry_limit: Optional[builtins.int] = None,
                 timeout_in_seconds: Optional[builtins.int] = None):
        """
        Configuration for manual triggered job
        :param builtins.str trigger_type: Type of job trigger
               Expected value is 'Manual'.
        :param builtins.int parallelism: Number of parallel replicas of a job execution can run.
        :param builtins.int retry_limit: Maximum number of retries before failing the job.
        :param builtins.int timeout_in_seconds: Maximum number of seconds an execution is allowed to run.
        """
        if trigger_type is None:
            trigger_type = 'Manual'
        pulumi.set(__self__, "trigger_type", 'Manual')
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if retry_limit is not None:
            pulumi.set(__self__, "retry_limit", retry_limit)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> builtins.str:
        """
        Type of job trigger
        Expected value is 'Manual'.
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[builtins.int]:
        """
        Number of parallel replicas of a job execution can run.
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter(name="retryLimit")
    def retry_limit(self) -> Optional[builtins.int]:
        """
        Maximum number of retries before failing the job.
        """
        return pulumi.get(self, "retry_limit")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[builtins.int]:
        """
        Maximum number of seconds an execution is allowed to run.
        """
        return pulumi.get(self, "timeout_in_seconds")


@pulumi.output_type
class MarketplaceResourceResponse(dict):
    """
    Purchasing 3rd Party product for one Azure Spring Apps instance
    """
    def __init__(__self__, *,
                 plan: Optional[builtins.str] = None,
                 product: Optional[builtins.str] = None,
                 publisher: Optional[builtins.str] = None):
        """
        Purchasing 3rd Party product for one Azure Spring Apps instance
        :param builtins.str plan: The plan id of the 3rd Party Artifact that is being procured.
        :param builtins.str product: The 3rd Party artifact that is being procured.
        :param builtins.str publisher: The publisher id of the 3rd Party Artifact that is being bought.
        """
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def plan(self) -> Optional[builtins.str]:
        """
        The plan id of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def product(self) -> Optional[builtins.str]:
        """
        The 3rd Party artifact that is being procured.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[builtins.str]:
        """
        The publisher id of the 3rd Party Artifact that is being bought.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class MonitoringSettingPropertiesResponse(dict):
    """
    Monitoring Setting properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "appInsightsAgentVersions":
            suggest = "app_insights_agent_versions"
        elif key == "appInsightsInstrumentationKey":
            suggest = "app_insights_instrumentation_key"
        elif key == "appInsightsSamplingRate":
            suggest = "app_insights_sampling_rate"
        elif key == "traceEnabled":
            suggest = "trace_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringSettingPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringSettingPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringSettingPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 app_insights_agent_versions: Optional['outputs.ApplicationInsightsAgentVersionsResponse'] = None,
                 app_insights_instrumentation_key: Optional[builtins.str] = None,
                 app_insights_sampling_rate: Optional[builtins.float] = None,
                 error: Optional['outputs.ErrorResponse'] = None,
                 trace_enabled: Optional[builtins.bool] = None):
        """
        Monitoring Setting properties payload
        :param builtins.str provisioning_state: State of the Monitoring Setting.
        :param 'ApplicationInsightsAgentVersionsResponse' app_insights_agent_versions: Indicates the versions of application insight agent
        :param builtins.str app_insights_instrumentation_key: Target application insight instrumentation key, null or whitespace include empty will disable monitoringSettings
        :param builtins.float app_insights_sampling_rate: Indicates the sampling rate of application insight agent, should be in range [0.0, 100.0]
        :param 'ErrorResponse' error: Error when apply Monitoring Setting changes.
        :param builtins.bool trace_enabled: Indicates whether enable the trace functionality, which will be deprecated since api version 2020-11-01-preview. Please leverage appInsightsInstrumentationKey to indicate if monitoringSettings enabled or not
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if app_insights_agent_versions is not None:
            pulumi.set(__self__, "app_insights_agent_versions", app_insights_agent_versions)
        if app_insights_instrumentation_key is not None:
            pulumi.set(__self__, "app_insights_instrumentation_key", app_insights_instrumentation_key)
        if app_insights_sampling_rate is not None:
            pulumi.set(__self__, "app_insights_sampling_rate", app_insights_sampling_rate)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if trace_enabled is not None:
            pulumi.set(__self__, "trace_enabled", trace_enabled)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the Monitoring Setting.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="appInsightsAgentVersions")
    def app_insights_agent_versions(self) -> Optional['outputs.ApplicationInsightsAgentVersionsResponse']:
        """
        Indicates the versions of application insight agent
        """
        return pulumi.get(self, "app_insights_agent_versions")

    @property
    @pulumi.getter(name="appInsightsInstrumentationKey")
    def app_insights_instrumentation_key(self) -> Optional[builtins.str]:
        """
        Target application insight instrumentation key, null or whitespace include empty will disable monitoringSettings
        """
        return pulumi.get(self, "app_insights_instrumentation_key")

    @property
    @pulumi.getter(name="appInsightsSamplingRate")
    def app_insights_sampling_rate(self) -> Optional[builtins.float]:
        """
        Indicates the sampling rate of application insight agent, should be in range [0.0, 100.0]
        """
        return pulumi.get(self, "app_insights_sampling_rate")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ErrorResponse']:
        """
        Error when apply Monitoring Setting changes.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="traceEnabled")
    def trace_enabled(self) -> Optional[builtins.bool]:
        """
        Indicates whether enable the trace functionality, which will be deprecated since api version 2020-11-01-preview. Please leverage appInsightsInstrumentationKey to indicate if monitoringSettings enabled or not
        """
        return pulumi.get(self, "trace_enabled")


@pulumi.output_type
class NetCoreZipUploadedUserSourceInfoResponse(dict):
    """
    Uploaded Jar binary for a deployment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "netCoreMainEntryPath":
            suggest = "net_core_main_entry_path"
        elif key == "relativePath":
            suggest = "relative_path"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetCoreZipUploadedUserSourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetCoreZipUploadedUserSourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetCoreZipUploadedUserSourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 net_core_main_entry_path: Optional[builtins.str] = None,
                 relative_path: Optional[builtins.str] = None,
                 runtime_version: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Uploaded Jar binary for a deployment
        :param builtins.str type: Type of the source uploaded
               Expected value is 'NetCoreZip'.
        :param builtins.str net_core_main_entry_path: The path to the .NET executable relative to zip root
        :param builtins.str relative_path: Relative path of the storage which stores the source
        :param builtins.str runtime_version: Runtime version of the .Net file
        :param builtins.str version: Version of the source
        """
        pulumi.set(__self__, "type", 'NetCoreZip')
        if net_core_main_entry_path is not None:
            pulumi.set(__self__, "net_core_main_entry_path", net_core_main_entry_path)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the source uploaded
        Expected value is 'NetCoreZip'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="netCoreMainEntryPath")
    def net_core_main_entry_path(self) -> Optional[builtins.str]:
        """
        The path to the .NET executable relative to zip root
        """
        return pulumi.get(self, "net_core_main_entry_path")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[builtins.str]:
        """
        Relative path of the storage which stores the source
        """
        return pulumi.get(self, "relative_path")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[builtins.str]:
        """
        Runtime version of the .Net file
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class NetworkProfileResponse(dict):
    """
    Service network profile payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outboundIPs":
            suggest = "outbound_ips"
        elif key == "requiredTraffics":
            suggest = "required_traffics"
        elif key == "appNetworkResourceGroup":
            suggest = "app_network_resource_group"
        elif key == "appSubnetId":
            suggest = "app_subnet_id"
        elif key == "ingressConfig":
            suggest = "ingress_config"
        elif key == "outboundType":
            suggest = "outbound_type"
        elif key == "serviceCidr":
            suggest = "service_cidr"
        elif key == "serviceRuntimeNetworkResourceGroup":
            suggest = "service_runtime_network_resource_group"
        elif key == "serviceRuntimeSubnetId":
            suggest = "service_runtime_subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 outbound_ips: 'outputs.NetworkProfileResponseOutboundIPs',
                 required_traffics: Sequence['outputs.RequiredTrafficResponse'],
                 app_network_resource_group: Optional[builtins.str] = None,
                 app_subnet_id: Optional[builtins.str] = None,
                 ingress_config: Optional['outputs.IngressConfigResponse'] = None,
                 outbound_type: Optional[builtins.str] = None,
                 service_cidr: Optional[builtins.str] = None,
                 service_runtime_network_resource_group: Optional[builtins.str] = None,
                 service_runtime_subnet_id: Optional[builtins.str] = None):
        """
        Service network profile payload
        :param 'NetworkProfileResponseOutboundIPs' outbound_ips: Desired outbound IP resources for Azure Spring Apps resource.
        :param Sequence['RequiredTrafficResponse'] required_traffics: Required inbound or outbound traffics for Azure Spring Apps resource.
        :param builtins.str app_network_resource_group: Name of the resource group containing network resources for customer apps in Azure Spring Apps
        :param builtins.str app_subnet_id: Fully qualified resource Id of the subnet to host customer apps in Azure Spring Apps
        :param 'IngressConfigResponse' ingress_config: Ingress configuration payload for Azure Spring Apps resource.
        :param builtins.str outbound_type: The egress traffic type of Azure Spring Apps VNet instances.
        :param builtins.str service_cidr: Azure Spring Apps service reserved CIDR
        :param builtins.str service_runtime_network_resource_group: Name of the resource group containing network resources of Azure Spring Apps Service Runtime
        :param builtins.str service_runtime_subnet_id: Fully qualified resource Id of the subnet to host Azure Spring Apps Service Runtime
        """
        pulumi.set(__self__, "outbound_ips", outbound_ips)
        pulumi.set(__self__, "required_traffics", required_traffics)
        if app_network_resource_group is not None:
            pulumi.set(__self__, "app_network_resource_group", app_network_resource_group)
        if app_subnet_id is not None:
            pulumi.set(__self__, "app_subnet_id", app_subnet_id)
        if ingress_config is not None:
            pulumi.set(__self__, "ingress_config", ingress_config)
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if service_runtime_network_resource_group is not None:
            pulumi.set(__self__, "service_runtime_network_resource_group", service_runtime_network_resource_group)
        if service_runtime_subnet_id is not None:
            pulumi.set(__self__, "service_runtime_subnet_id", service_runtime_subnet_id)

    @property
    @pulumi.getter(name="outboundIPs")
    def outbound_ips(self) -> 'outputs.NetworkProfileResponseOutboundIPs':
        """
        Desired outbound IP resources for Azure Spring Apps resource.
        """
        return pulumi.get(self, "outbound_ips")

    @property
    @pulumi.getter(name="requiredTraffics")
    def required_traffics(self) -> Sequence['outputs.RequiredTrafficResponse']:
        """
        Required inbound or outbound traffics for Azure Spring Apps resource.
        """
        return pulumi.get(self, "required_traffics")

    @property
    @pulumi.getter(name="appNetworkResourceGroup")
    def app_network_resource_group(self) -> Optional[builtins.str]:
        """
        Name of the resource group containing network resources for customer apps in Azure Spring Apps
        """
        return pulumi.get(self, "app_network_resource_group")

    @property
    @pulumi.getter(name="appSubnetId")
    def app_subnet_id(self) -> Optional[builtins.str]:
        """
        Fully qualified resource Id of the subnet to host customer apps in Azure Spring Apps
        """
        return pulumi.get(self, "app_subnet_id")

    @property
    @pulumi.getter(name="ingressConfig")
    def ingress_config(self) -> Optional['outputs.IngressConfigResponse']:
        """
        Ingress configuration payload for Azure Spring Apps resource.
        """
        return pulumi.get(self, "ingress_config")

    @property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[builtins.str]:
        """
        The egress traffic type of Azure Spring Apps VNet instances.
        """
        return pulumi.get(self, "outbound_type")

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[builtins.str]:
        """
        Azure Spring Apps service reserved CIDR
        """
        return pulumi.get(self, "service_cidr")

    @property
    @pulumi.getter(name="serviceRuntimeNetworkResourceGroup")
    def service_runtime_network_resource_group(self) -> Optional[builtins.str]:
        """
        Name of the resource group containing network resources of Azure Spring Apps Service Runtime
        """
        return pulumi.get(self, "service_runtime_network_resource_group")

    @property
    @pulumi.getter(name="serviceRuntimeSubnetId")
    def service_runtime_subnet_id(self) -> Optional[builtins.str]:
        """
        Fully qualified resource Id of the subnet to host Azure Spring Apps Service Runtime
        """
        return pulumi.get(self, "service_runtime_subnet_id")


@pulumi.output_type
class NetworkProfileResponseOutboundIPs(dict):
    """
    Desired outbound IP resources for Azure Spring Apps resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIPs":
            suggest = "public_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkProfileResponseOutboundIPs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkProfileResponseOutboundIPs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkProfileResponseOutboundIPs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ips: Sequence[builtins.str]):
        """
        Desired outbound IP resources for Azure Spring Apps resource.
        :param Sequence[builtins.str] public_ips: A list of public IP addresses.
        """
        pulumi.set(__self__, "public_ips", public_ips)

    @property
    @pulumi.getter(name="publicIPs")
    def public_ips(self) -> Sequence[builtins.str]:
        """
        A list of public IP addresses.
        """
        return pulumi.get(self, "public_ips")


@pulumi.output_type
class PersistentDiskResponse(dict):
    """
    Persistent disk payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usedInGB":
            suggest = "used_in_gb"
        elif key == "mountPath":
            suggest = "mount_path"
        elif key == "sizeInGB":
            suggest = "size_in_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PersistentDiskResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PersistentDiskResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PersistentDiskResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 used_in_gb: builtins.int,
                 mount_path: Optional[builtins.str] = None,
                 size_in_gb: Optional[builtins.int] = None):
        """
        Persistent disk payload
        :param builtins.int used_in_gb: Size of the used persistent disk in GB
        :param builtins.str mount_path: Mount path of the persistent disk
        :param builtins.int size_in_gb: Size of the persistent disk in GB
        """
        pulumi.set(__self__, "used_in_gb", used_in_gb)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if size_in_gb is not None:
            pulumi.set(__self__, "size_in_gb", size_in_gb)

    @property
    @pulumi.getter(name="usedInGB")
    def used_in_gb(self) -> builtins.int:
        """
        Size of the used persistent disk in GB
        """
        return pulumi.get(self, "used_in_gb")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[builtins.str]:
        """
        Mount path of the persistent disk
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="sizeInGB")
    def size_in_gb(self) -> Optional[builtins.int]:
        """
        Size of the persistent disk in GB
        """
        return pulumi.get(self, "size_in_gb")


@pulumi.output_type
class ProbeResponse(dict):
    """
    Probe describes a health check to be performed against an App Instance to determine whether it is alive or ready to receive traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableProbe":
            suggest = "disable_probe"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "probeAction":
            suggest = "probe_action"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProbeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProbeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProbeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_probe: Optional[builtins.bool] = None,
                 failure_threshold: Optional[builtins.int] = None,
                 initial_delay_seconds: Optional[builtins.int] = None,
                 period_seconds: Optional[builtins.int] = None,
                 probe_action: Optional[Any] = None,
                 success_threshold: Optional[builtins.int] = None,
                 timeout_seconds: Optional[builtins.int] = None):
        """
        Probe describes a health check to be performed against an App Instance to determine whether it is alive or ready to receive traffic.
        :param builtins.bool disable_probe: Indicate whether the probe is disabled.
        :param builtins.int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Minimum value is 1.
        :param builtins.int initial_delay_seconds: Number of seconds after the App Instance has started before probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param builtins.int period_seconds: How often (in seconds) to perform the probe. Minimum value is 1.
        :param Union['ExecActionResponse', 'HTTPGetActionResponse', 'TCPSocketActionResponse'] probe_action: The action of the probe.
        :param builtins.int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Must be 1 for liveness and startup. Minimum value is 1.
        :param builtins.int timeout_seconds: Number of seconds after which the probe times out. Minimum value is 1.
        """
        if disable_probe is None:
            disable_probe = False
        pulumi.set(__self__, "disable_probe", disable_probe)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if probe_action is not None:
            pulumi.set(__self__, "probe_action", probe_action)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="disableProbe")
    def disable_probe(self) -> builtins.bool:
        """
        Indicate whether the probe is disabled.
        """
        return pulumi.get(self, "disable_probe")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[builtins.int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[builtins.int]:
        """
        Number of seconds after the App Instance has started before probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[builtins.int]:
        """
        How often (in seconds) to perform the probe. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="probeAction")
    def probe_action(self) -> Optional[Any]:
        """
        The action of the probe.
        """
        return pulumi.get(self, "probe_action")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[builtins.int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Must be 1 for liveness and startup. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[builtins.int]:
        """
        Number of seconds after which the probe times out. Minimum value is 1.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class QueueScaleRuleResponse(dict):
    """
    Azure Spring Apps App Instance Azure Queue based scaling rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueLength":
            suggest = "queue_length"
        elif key == "queueName":
            suggest = "queue_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueScaleRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueScaleRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueScaleRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 queue_length: Optional[builtins.int] = None,
                 queue_name: Optional[builtins.str] = None):
        """
        Azure Spring Apps App Instance Azure Queue based scaling rule.
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the queue scale rule.
        :param builtins.int queue_length: Queue length.
        :param builtins.str queue_name: Queue name.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if queue_length is not None:
            pulumi.set(__self__, "queue_length", queue_length)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)

    @property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the queue scale rule.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="queueLength")
    def queue_length(self) -> Optional[builtins.int]:
        """
        Queue length.
        """
        return pulumi.get(self, "queue_length")

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[builtins.str]:
        """
        Queue name.
        """
        return pulumi.get(self, "queue_name")


@pulumi.output_type
class RequiredTrafficResponse(dict):
    """
    Required inbound or outbound traffic for Azure Spring Apps resource.
    """
    def __init__(__self__, *,
                 direction: builtins.str,
                 fqdns: Sequence[builtins.str],
                 ips: Sequence[builtins.str],
                 port: builtins.int,
                 protocol: builtins.str):
        """
        Required inbound or outbound traffic for Azure Spring Apps resource.
        :param builtins.str direction: The direction of required traffic
        :param Sequence[builtins.str] fqdns: The FQDN list of required traffic
        :param Sequence[builtins.str] ips: The ip list of required traffic
        :param builtins.int port: The port of required traffic
        :param builtins.str protocol: The protocol of required traffic
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "fqdns", fqdns)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def direction(self) -> builtins.str:
        """
        The direction of required traffic
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def fqdns(self) -> Sequence[builtins.str]:
        """
        The FQDN list of required traffic
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[builtins.str]:
        """
        The ip list of required traffic
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        The port of required traffic
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> builtins.str:
        """
        The protocol of required traffic
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ResourceRequestsResponse(dict):
    """
    Deployment resource request payload
    """
    def __init__(__self__, *,
                 cpu: Optional[builtins.str] = None,
                 memory: Optional[builtins.str] = None):
        """
        Deployment resource request payload
        :param builtins.str cpu: Required CPU. 1 core can be represented by 1 or 1000m. This should be 500m or 1 for Basic tier, and {500m, 1, 2, 3, 4} for Standard tier.
        :param builtins.str memory: Required memory. 1 GB can be represented by 1Gi or 1024Mi. This should be {512Mi, 1Gi, 2Gi} for Basic tier, and {512Mi, 1Gi, 2Gi, ..., 8Gi} for Standard tier.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[builtins.str]:
        """
        Required CPU. 1 core can be represented by 1 or 1000m. This should be 500m or 1 for Basic tier, and {500m, 1, 2, 3, 4} for Standard tier.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> Optional[builtins.str]:
        """
        Required memory. 1 GB can be represented by 1Gi or 1024Mi. This should be {512Mi, 1Gi, 2Gi} for Basic tier, and {512Mi, 1Gi, 2Gi, ..., 8Gi} for Standard tier.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ScaleResponse(dict):
    """
    Azure Spring Apps scaling configurations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: Optional[builtins.int] = None,
                 min_replicas: Optional[builtins.int] = None,
                 rules: Optional[Sequence['outputs.ScaleRuleResponse']] = None):
        """
        Azure Spring Apps scaling configurations.
        :param builtins.int max_replicas: Optional. Maximum number of container replicas. Defaults to 10 if not set.
        :param builtins.int min_replicas: Optional. Minimum number of container replicas.
        :param Sequence['ScaleRuleResponse'] rules: Scaling rules.
        """
        if max_replicas is None:
            max_replicas = 10
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[builtins.int]:
        """
        Optional. Maximum number of container replicas. Defaults to 10 if not set.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[builtins.int]:
        """
        Optional. Minimum number of container replicas.
        """
        return pulumi.get(self, "min_replicas")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ScaleRuleResponse']]:
        """
        Scaling rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ScaleRuleAuthResponse(dict):
    """
    Auth Secrets for Azure Spring Apps App Instance Scale Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"
        elif key == "triggerParameter":
            suggest = "trigger_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleRuleAuthResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleRuleAuthResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleRuleAuthResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: Optional[builtins.str] = None,
                 trigger_parameter: Optional[builtins.str] = None):
        """
        Auth Secrets for Azure Spring Apps App Instance Scale Rule
        :param builtins.str secret_ref: Name of the Azure Spring Apps App Instance secret from which to pull the auth params.
        :param builtins.str trigger_parameter: Trigger Parameter that uses the secret
        """
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if trigger_parameter is not None:
            pulumi.set(__self__, "trigger_parameter", trigger_parameter)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[builtins.str]:
        """
        Name of the Azure Spring Apps App Instance secret from which to pull the auth params.
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter(name="triggerParameter")
    def trigger_parameter(self) -> Optional[builtins.str]:
        """
        Trigger Parameter that uses the secret
        """
        return pulumi.get(self, "trigger_parameter")


@pulumi.output_type
class ScaleRuleResponse(dict):
    """
    Azure Spring Apps App Instance scaling rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureQueue":
            suggest = "azure_queue"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_queue: Optional['outputs.QueueScaleRuleResponse'] = None,
                 custom: Optional['outputs.CustomScaleRuleResponse'] = None,
                 http: Optional['outputs.HttpScaleRuleResponse'] = None,
                 name: Optional[builtins.str] = None,
                 tcp: Optional['outputs.TcpScaleRuleResponse'] = None):
        """
        Azure Spring Apps App Instance scaling rule.
        :param 'QueueScaleRuleResponse' azure_queue: Azure Queue based scaling.
        :param 'CustomScaleRuleResponse' custom: Custom scale rule.
        :param 'HttpScaleRuleResponse' http: HTTP requests based scaling.
        :param builtins.str name: Scale Rule Name
        :param 'TcpScaleRuleResponse' tcp: Tcp requests based scaling.
        """
        if azure_queue is not None:
            pulumi.set(__self__, "azure_queue", azure_queue)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter(name="azureQueue")
    def azure_queue(self) -> Optional['outputs.QueueScaleRuleResponse']:
        """
        Azure Queue based scaling.
        """
        return pulumi.get(self, "azure_queue")

    @property
    @pulumi.getter
    def custom(self) -> Optional['outputs.CustomScaleRuleResponse']:
        """
        Custom scale rule.
        """
        return pulumi.get(self, "custom")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.HttpScaleRuleResponse']:
        """
        HTTP requests based scaling.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Scale Rule Name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.TcpScaleRuleResponse']:
        """
        Tcp requests based scaling.
        """
        return pulumi.get(self, "tcp")


@pulumi.output_type
class SecretResponse(dict):
    """
    Secret definition.
    """
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None):
        """
        Secret definition.
        :param builtins.str name: Secret Name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ServiceRegistryInstanceResponse(dict):
    """
    Collection of instances belong to the Service Registry
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 status: builtins.str):
        """
        Collection of instances belong to the Service Registry
        :param builtins.str name: Name of the Service Registry instance
        :param builtins.str status: Status of the Service Registry instance
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the Service Registry instance
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the Service Registry instance
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ServiceRegistryPropertiesResponse(dict):
    """
    Service Registry properties payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceRequests":
            suggest = "resource_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceRegistryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceRegistryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceRegistryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.ServiceRegistryInstanceResponse'],
                 provisioning_state: builtins.str,
                 resource_requests: 'outputs.ServiceRegistryResourceRequestsResponse'):
        """
        Service Registry properties payload
        :param Sequence['ServiceRegistryInstanceResponse'] instances: Collection of instances belong to Service Registry.
        :param builtins.str provisioning_state: State of the Service Registry.
        :param 'ServiceRegistryResourceRequestsResponse' resource_requests: The requested resource quantity for required CPU and Memory.
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "resource_requests", resource_requests)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.ServiceRegistryInstanceResponse']:
        """
        Collection of instances belong to Service Registry.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        State of the Service Registry.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> 'outputs.ServiceRegistryResourceRequestsResponse':
        """
        The requested resource quantity for required CPU and Memory.
        """
        return pulumi.get(self, "resource_requests")


@pulumi.output_type
class ServiceRegistryResourceRequestsResponse(dict):
    """
    Resource request payload of Service Registry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceRegistryResourceRequestsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceRegistryResourceRequestsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceRegistryResourceRequestsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: builtins.str,
                 instance_count: builtins.int,
                 memory: builtins.str):
        """
        Resource request payload of Service Registry
        :param builtins.str cpu: Cpu allocated to each Service Registry instance
        :param builtins.int instance_count: Instance count of the Service Registry
        :param builtins.str memory: Memory allocated to each Service Registry instance
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.str:
        """
        Cpu allocated to each Service Registry instance
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> builtins.int:
        """
        Instance count of the Service Registry
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter
    def memory(self) -> builtins.str:
        """
        Memory allocated to each Service Registry instance
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ServiceVNetAddonsResponse(dict):
    """
    Additional Service settings in vnet injection instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPlanePublicEndpoint":
            suggest = "data_plane_public_endpoint"
        elif key == "logStreamPublicEndpoint":
            suggest = "log_stream_public_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceVNetAddonsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceVNetAddonsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceVNetAddonsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_plane_public_endpoint: Optional[builtins.bool] = None,
                 log_stream_public_endpoint: Optional[builtins.bool] = None):
        """
        Additional Service settings in vnet injection instance
        :param builtins.bool data_plane_public_endpoint: Indicates whether the data plane components(log stream, app connect, remote debugging) in vnet injection instance could be accessed from internet.
        :param builtins.bool log_stream_public_endpoint: Indicates whether the log stream in vnet injection instance could be accessed from internet.
        """
        if data_plane_public_endpoint is None:
            data_plane_public_endpoint = False
        if data_plane_public_endpoint is not None:
            pulumi.set(__self__, "data_plane_public_endpoint", data_plane_public_endpoint)
        if log_stream_public_endpoint is None:
            log_stream_public_endpoint = False
        if log_stream_public_endpoint is not None:
            pulumi.set(__self__, "log_stream_public_endpoint", log_stream_public_endpoint)

    @property
    @pulumi.getter(name="dataPlanePublicEndpoint")
    def data_plane_public_endpoint(self) -> Optional[builtins.bool]:
        """
        Indicates whether the data plane components(log stream, app connect, remote debugging) in vnet injection instance could be accessed from internet.
        """
        return pulumi.get(self, "data_plane_public_endpoint")

    @property
    @pulumi.getter(name="logStreamPublicEndpoint")
    def log_stream_public_endpoint(self) -> Optional[builtins.bool]:
        """
        Indicates whether the log stream in vnet injection instance could be accessed from internet.
        """
        return pulumi.get(self, "log_stream_public_endpoint")


@pulumi.output_type
class SkuResponse(dict):
    """
    Sku of Azure Spring Apps
    """
    def __init__(__self__, *,
                 capacity: Optional[builtins.int] = None,
                 name: Optional[builtins.str] = None,
                 tier: Optional[builtins.str] = None):
        """
        Sku of Azure Spring Apps
        :param builtins.int capacity: Current capacity of the target resource
        :param builtins.str name: Name of the Sku
        :param builtins.str tier: Tier of the Sku
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if name is None:
            name = 'S0'
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tier is None:
            tier = 'Standard'
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[builtins.int]:
        """
        Current capacity of the target resource
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the Sku
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[builtins.str]:
        """
        Tier of the Sku
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SourceUploadedUserSourceInfoResponse(dict):
    """
    Uploaded Java source code binary for a deployment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactSelector":
            suggest = "artifact_selector"
        elif key == "relativePath":
            suggest = "relative_path"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceUploadedUserSourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceUploadedUserSourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceUploadedUserSourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 artifact_selector: Optional[builtins.str] = None,
                 relative_path: Optional[builtins.str] = None,
                 runtime_version: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Uploaded Java source code binary for a deployment
        :param builtins.str type: Type of the source uploaded
               Expected value is 'Source'.
        :param builtins.str artifact_selector: Selector for the artifact to be used for the deployment for multi-module projects. This should be
               the relative path to the target module/project.
        :param builtins.str relative_path: Relative path of the storage which stores the source
        :param builtins.str runtime_version: Runtime version of the source file
        :param builtins.str version: Version of the source
        """
        pulumi.set(__self__, "type", 'Source')
        if artifact_selector is not None:
            pulumi.set(__self__, "artifact_selector", artifact_selector)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the source uploaded
        Expected value is 'Source'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="artifactSelector")
    def artifact_selector(self) -> Optional[builtins.str]:
        """
        Selector for the artifact to be used for the deployment for multi-module projects. This should be
        the relative path to the target module/project.
        """
        return pulumi.get(self, "artifact_selector")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[builtins.str]:
        """
        Relative path of the storage which stores the source
        """
        return pulumi.get(self, "relative_path")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[builtins.str]:
        """
        Runtime version of the source file
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SsoPropertiesResponse(dict):
    """
    Single sign-on related configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "issuerUri":
            suggest = "issuer_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsoPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsoPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsoPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 issuer_uri: Optional[builtins.str] = None,
                 scope: Optional[Sequence[builtins.str]] = None):
        """
        Single sign-on related configuration
        :param builtins.str client_id: The public identifier for the application
        :param builtins.str client_secret: The secret known only to the application and the authorization server
        :param builtins.str issuer_uri: The URI of Issuer Identifier
        :param Sequence[builtins.str] scope: It defines the specific actions applications can be allowed to do on a user's behalf
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if issuer_uri is not None:
            pulumi.set(__self__, "issuer_uri", issuer_uri)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The public identifier for the application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The secret known only to the application and the authorization server
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="issuerUri")
    def issuer_uri(self) -> Optional[builtins.str]:
        """
        The URI of Issuer Identifier
        """
        return pulumi.get(self, "issuer_uri")

    @property
    @pulumi.getter
    def scope(self) -> Optional[Sequence[builtins.str]]:
        """
        It defines the specific actions applications can be allowed to do on a user's behalf
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class StackPropertiesResponse(dict):
    """
    KPack ClusterStack properties payload
    """
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        KPack ClusterStack properties payload
        :param builtins.str id: Id of the ClusterStack.
        :param builtins.str version: Version of the ClusterStack
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Id of the ClusterStack.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the ClusterStack
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class StorageAccountResponse(dict):
    """
    storage resource of type Azure Storage Account.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "storageType":
            suggest = "storage_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageAccountResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageAccountResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageAccountResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: builtins.str,
                 storage_type: builtins.str):
        """
        storage resource of type Azure Storage Account.
        :param builtins.str account_name: The account name of the Azure Storage Account.
        :param builtins.str storage_type: The type of the storage.
               Expected value is 'StorageAccount'.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "storage_type", 'StorageAccount')

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> builtins.str:
        """
        The account name of the Azure Storage Account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> builtins.str:
        """
        The type of the storage.
        Expected value is 'StorageAccount'.
        """
        return pulumi.get(self, "storage_type")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource modification (UTC).
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource modification (UTC).
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TCPSocketActionResponse(dict):
    """
    TCPSocketAction describes an action based on opening a socket
    """
    def __init__(__self__, *,
                 type: builtins.str):
        """
        TCPSocketAction describes an action based on opening a socket
        :param builtins.str type: The type of the action to take to perform the health check.
               Expected value is 'TCPSocketAction'.
        """
        pulumi.set(__self__, "type", 'TCPSocketAction')

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the action to take to perform the health check.
        Expected value is 'TCPSocketAction'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TcpScaleRuleResponse(dict):
    """
    Azure Spring Apps App Instance Tcp scaling rule.
    """
    def __init__(__self__, *,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 metadata: Optional[Mapping[str, builtins.str]] = None):
        """
        Azure Spring Apps App Instance Tcp scaling rule.
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the tcp scale rule.
        :param Mapping[str, builtins.str] metadata: Metadata properties to describe tcp scale rule.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the tcp scale rule.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Metadata properties to describe tcp scale rule.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class TemporaryDiskResponse(dict):
    """
    Temporary disk payload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "sizeInGB":
            suggest = "size_in_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemporaryDiskResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemporaryDiskResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemporaryDiskResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: Optional[builtins.str] = None,
                 size_in_gb: Optional[builtins.int] = None):
        """
        Temporary disk payload
        :param builtins.str mount_path: Mount path of the temporary disk
        :param builtins.int size_in_gb: Size of the temporary disk in GB
        """
        if mount_path is None:
            mount_path = '/tmp'
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if size_in_gb is not None:
            pulumi.set(__self__, "size_in_gb", size_in_gb)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[builtins.str]:
        """
        Mount path of the temporary disk
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="sizeInGB")
    def size_in_gb(self) -> Optional[builtins.int]:
        """
        Size of the temporary disk in GB
        """
        return pulumi.get(self, "size_in_gb")


@pulumi.output_type
class TriggeredBuildResultResponse(dict):
    """
    The build result triggered by a build
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "lastTransitionReason":
            suggest = "last_transition_reason"
        elif key == "lastTransitionStatus":
            suggest = "last_transition_status"
        elif key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggeredBuildResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggeredBuildResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggeredBuildResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 id: Optional[builtins.str] = None,
                 image: Optional[builtins.str] = None,
                 last_transition_reason: Optional[builtins.str] = None,
                 last_transition_status: Optional[builtins.str] = None,
                 last_transition_time: Optional[builtins.str] = None):
        """
        The build result triggered by a build
        :param builtins.str provisioning_state: The provisioning state of this build result
        :param builtins.str id: The unique build id of this build result
        :param builtins.str image: The container image of this build result
        :param builtins.str last_transition_reason: The last transition reason of this build result
        :param builtins.str last_transition_status: The last transition status of this build result
        :param builtins.str last_transition_time: The last transition time of this build result
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if last_transition_reason is not None:
            pulumi.set(__self__, "last_transition_reason", last_transition_reason)
        if last_transition_status is not None:
            pulumi.set(__self__, "last_transition_status", last_transition_status)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provisioning state of this build result
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The unique build id of this build result
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def image(self) -> Optional[builtins.str]:
        """
        The container image of this build result
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="lastTransitionReason")
    def last_transition_reason(self) -> Optional[builtins.str]:
        """
        The last transition reason of this build result
        """
        return pulumi.get(self, "last_transition_reason")

    @property
    @pulumi.getter(name="lastTransitionStatus")
    def last_transition_status(self) -> Optional[builtins.str]:
        """
        The last transition status of this build result
        """
        return pulumi.get(self, "last_transition_status")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        The last transition time of this build result
        """
        return pulumi.get(self, "last_transition_time")


@pulumi.output_type
class UploadedUserSourceInfoResponse(dict):
    """
    Source with uploaded location
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativePath":
            suggest = "relative_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UploadedUserSourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UploadedUserSourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UploadedUserSourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 relative_path: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Source with uploaded location
        :param builtins.str type: Type of the source uploaded
               Expected value is 'UploadedUserSourceInfo'.
        :param builtins.str relative_path: Relative path of the storage which stores the source
        :param builtins.str version: Version of the source
        """
        pulumi.set(__self__, "type", 'UploadedUserSourceInfo')
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the source uploaded
        Expected value is 'UploadedUserSourceInfo'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[builtins.str]:
        """
        Relative path of the storage which stores the source
        """
        return pulumi.get(self, "relative_path")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class UserAssignedManagedIdentityResponse(dict):
    """
    The details of the user-assigned managed identity assigned to an App.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 principal_id: builtins.str):
        """
        The details of the user-assigned managed identity assigned to an App.
        :param builtins.str client_id: Client Id of user-assigned managed identity.
        :param builtins.str principal_id: Principal Id of user-assigned managed identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        Client Id of user-assigned managed identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        Principal Id of user-assigned managed identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class WarUploadedUserSourceInfoResponse(dict):
    """
    Uploaded War binary for a deployment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jvmOptions":
            suggest = "jvm_options"
        elif key == "relativePath":
            suggest = "relative_path"
        elif key == "runtimeVersion":
            suggest = "runtime_version"
        elif key == "serverVersion":
            suggest = "server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WarUploadedUserSourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WarUploadedUserSourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WarUploadedUserSourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 jvm_options: Optional[builtins.str] = None,
                 relative_path: Optional[builtins.str] = None,
                 runtime_version: Optional[builtins.str] = None,
                 server_version: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Uploaded War binary for a deployment
        :param builtins.str type: Type of the source uploaded
               Expected value is 'War'.
        :param builtins.str jvm_options: JVM parameter
        :param builtins.str relative_path: Relative path of the storage which stores the source
        :param builtins.str runtime_version: Runtime version of the war file
        :param builtins.str server_version: Server version, currently only Apache Tomcat is supported
        :param builtins.str version: Version of the source
        """
        pulumi.set(__self__, "type", 'War')
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)
        if server_version is not None:
            pulumi.set(__self__, "server_version", server_version)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of the source uploaded
        Expected value is 'War'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[builtins.str]:
        """
        JVM parameter
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[builtins.str]:
        """
        Relative path of the storage which stores the source
        """
        return pulumi.get(self, "relative_path")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[builtins.str]:
        """
        Runtime version of the war file
        """
        return pulumi.get(self, "runtime_version")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[builtins.str]:
        """
        Server version, currently only Apache Tomcat is supported
        """
        return pulumi.get(self, "server_version")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class WeeklyMaintenanceScheduleConfigurationResponse(dict):
    """
    Weekly planned maintenance
    """
    def __init__(__self__, *,
                 day: builtins.str,
                 duration: builtins.str,
                 frequency: builtins.str,
                 hour: builtins.int):
        """
        Weekly planned maintenance
        :param builtins.str day: The day to run the maintenance job
        :param builtins.str duration: The duration time to run the maintenance job, specified in ISO8601 format, e.g. PT8H
        :param builtins.str frequency: The frequency to run the maintenance job
               Expected value is 'Weekly'.
        :param builtins.int hour: The hour to run the maintenance job
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", 'Weekly')
        pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def day(self) -> builtins.str:
        """
        The day to run the maintenance job
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def duration(self) -> builtins.str:
        """
        The duration time to run the maintenance job, specified in ISO8601 format, e.g. PT8H
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def frequency(self) -> builtins.str:
        """
        The frequency to run the maintenance job
        Expected value is 'Weekly'.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def hour(self) -> builtins.int:
        """
        The hour to run the maintenance job
        """
        return pulumi.get(self, "hour")


