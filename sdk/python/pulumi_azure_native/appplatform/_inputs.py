# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'AcceleratorBasicAuthSettingArgs',
    'AcceleratorGitRepositoryArgs',
    'AcceleratorPublicSettingArgs',
    'AcceleratorSshSettingArgs',
    'ApiPortalCustomDomainPropertiesArgs',
    'ApiPortalPropertiesArgs',
    'ApmPropertiesArgs',
    'ApmReferenceArgs',
    'AppResourcePropertiesArgs',
    'AppVNetAddonsArgs',
    'AzureFileVolumeArgs',
    'BindingResourcePropertiesArgs',
    'BuildPropertiesArgs',
    'BuildResourceRequestsArgs',
    'BuildResultUserSourceInfoArgs',
    'BuildServiceAgentPoolPropertiesArgs',
    'BuildServiceAgentPoolSizePropertiesArgs',
    'BuilderPropertiesArgs',
    'BuildpackBindingLaunchPropertiesArgs',
    'BuildpackBindingPropertiesArgs',
    'BuildpackPropertiesArgs',
    'BuildpacksGroupPropertiesArgs',
    'CertificateReferenceArgs',
    'ClusterResourcePropertiesArgs',
    'ConfigServerGitPropertyArgs',
    'ConfigServerPropertiesArgs',
    'ConfigServerSettingsArgs',
    'ConfigurationServiceGitPropertyArgs',
    'ConfigurationServiceGitRepositoryArgs',
    'ConfigurationServicePropertiesArgs',
    'ConfigurationServiceSettingsArgs',
    'ContainerProbeSettingsArgs',
    'ContainerRegistryBasicCredentialsArgs',
    'ContainerRegistryPropertiesArgs',
    'ContentCertificatePropertiesArgs',
    'CustomContainerUserSourceInfoArgs',
    'CustomContainerArgs',
    'CustomDomainPropertiesArgs',
    'CustomPersistentDiskResourceArgs',
    'CustomScaleRuleArgs',
    'CustomizedAcceleratorPropertiesArgs',
    'DeploymentResourcePropertiesArgs',
    'DeploymentSettingsArgs',
    'DevToolPortalFeatureDetailArgs',
    'DevToolPortalFeatureSettingsArgs',
    'DevToolPortalPropertiesArgs',
    'DevToolPortalSsoPropertiesArgs',
    'ErrorArgs',
    'ExecActionArgs',
    'GatewayApiMetadataPropertiesArgs',
    'GatewayApiRouteArgs',
    'GatewayCorsPropertiesArgs',
    'GatewayCustomDomainPropertiesArgs',
    'GatewayPropertiesClientAuthArgs',
    'GatewayPropertiesEnvironmentVariablesArgs',
    'GatewayPropertiesArgs',
    'GatewayResourceRequestsArgs',
    'GatewayRouteConfigOpenApiPropertiesArgs',
    'GatewayRouteConfigPropertiesArgs',
    'GitPatternRepositoryArgs',
    'HTTPGetActionArgs',
    'HttpScaleRuleArgs',
    'ImageRegistryCredentialArgs',
    'IngressConfigArgs',
    'IngressSettingsClientAuthArgs',
    'IngressSettingsArgs',
    'JarUploadedUserSourceInfoArgs',
    'KeyVaultCertificatePropertiesArgs',
    'LoadedCertificateArgs',
    'ManagedIdentityPropertiesArgs',
    'MarketplaceResourceArgs',
    'MonitoringSettingPropertiesArgs',
    'NetCoreZipUploadedUserSourceInfoArgs',
    'NetworkProfileArgs',
    'PersistentDiskArgs',
    'ProbeArgs',
    'QueueScaleRuleArgs',
    'ResourceRequestsArgs',
    'ScaleRuleAuthArgs',
    'ScaleRuleArgs',
    'ScaleArgs',
    'SecretArgs',
    'ServiceVNetAddonsArgs',
    'SkuArgs',
    'SourceUploadedUserSourceInfoArgs',
    'SsoPropertiesArgs',
    'StackPropertiesArgs',
    'StorageAccountArgs',
    'TCPSocketActionArgs',
    'TcpScaleRuleArgs',
    'TemporaryDiskArgs',
    'UploadedUserSourceInfoArgs',
]

@pulumi.input_type
class AcceleratorBasicAuthSettingArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[str],
                 username: pulumi.Input[str],
                 ca_cert_resource_id: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None):
        """
        Auth setting for basic auth.
        :param pulumi.Input[str] auth_type: The type of the auth setting.
               Expected value is 'BasicAuth'.
        :param pulumi.Input[str] username: Username of git repository basic auth.
        :param pulumi.Input[str] ca_cert_resource_id: Resource Id of CA certificate for https URL of Git repository.
        :param pulumi.Input[str] password: Password of git repository basic auth.
        """
        AcceleratorBasicAuthSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_type=auth_type,
            username=username,
            ca_cert_resource_id=ca_cert_resource_id,
            password=password,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_type: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             ca_cert_resource_id: Optional[pulumi.Input[str]] = None,
             password: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_type is None and 'authType' in kwargs:
            auth_type = kwargs['authType']
        if auth_type is None:
            raise TypeError("Missing 'auth_type' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")
        if ca_cert_resource_id is None and 'caCertResourceId' in kwargs:
            ca_cert_resource_id = kwargs['caCertResourceId']

        _setter("auth_type", 'BasicAuth')
        _setter("username", username)
        if ca_cert_resource_id is not None:
            _setter("ca_cert_resource_id", ca_cert_resource_id)
        if password is not None:
            _setter("password", password)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[str]:
        """
        The type of the auth setting.
        Expected value is 'BasicAuth'.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username of git repository basic auth.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="caCertResourceId")
    def ca_cert_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource Id of CA certificate for https URL of Git repository.
        """
        return pulumi.get(self, "ca_cert_resource_id")

    @ca_cert_resource_id.setter
    def ca_cert_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert_resource_id", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password of git repository basic auth.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class AcceleratorGitRepositoryArgs:
    def __init__(__self__, *,
                 auth_setting: pulumi.Input[Union['AcceleratorBasicAuthSettingArgs', 'AcceleratorPublicSettingArgs', 'AcceleratorSshSettingArgs']],
                 url: pulumi.Input[str],
                 branch: Optional[pulumi.Input[str]] = None,
                 commit: Optional[pulumi.Input[str]] = None,
                 git_tag: Optional[pulumi.Input[str]] = None,
                 interval_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Union['AcceleratorBasicAuthSettingArgs', 'AcceleratorPublicSettingArgs', 'AcceleratorSshSettingArgs']] auth_setting: Properties of the auth setting payload.
        :param pulumi.Input[str] url: Git repository URL for the accelerator.
        :param pulumi.Input[str] branch: Git repository branch to be used.
        :param pulumi.Input[str] commit: Git repository commit to be used.
        :param pulumi.Input[str] git_tag: Git repository tag to be used.
        :param pulumi.Input[int] interval_in_seconds: Interval for checking for updates to Git or image repository.
        """
        AcceleratorGitRepositoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_setting=auth_setting,
            url=url,
            branch=branch,
            commit=commit,
            git_tag=git_tag,
            interval_in_seconds=interval_in_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_setting: Optional[pulumi.Input[Union['AcceleratorBasicAuthSettingArgs', 'AcceleratorPublicSettingArgs', 'AcceleratorSshSettingArgs']]] = None,
             url: Optional[pulumi.Input[str]] = None,
             branch: Optional[pulumi.Input[str]] = None,
             commit: Optional[pulumi.Input[str]] = None,
             git_tag: Optional[pulumi.Input[str]] = None,
             interval_in_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_setting is None and 'authSetting' in kwargs:
            auth_setting = kwargs['authSetting']
        if auth_setting is None:
            raise TypeError("Missing 'auth_setting' argument")
        if url is None:
            raise TypeError("Missing 'url' argument")
        if git_tag is None and 'gitTag' in kwargs:
            git_tag = kwargs['gitTag']
        if interval_in_seconds is None and 'intervalInSeconds' in kwargs:
            interval_in_seconds = kwargs['intervalInSeconds']

        _setter("auth_setting", auth_setting)
        _setter("url", url)
        if branch is not None:
            _setter("branch", branch)
        if commit is not None:
            _setter("commit", commit)
        if git_tag is not None:
            _setter("git_tag", git_tag)
        if interval_in_seconds is not None:
            _setter("interval_in_seconds", interval_in_seconds)

    @property
    @pulumi.getter(name="authSetting")
    def auth_setting(self) -> pulumi.Input[Union['AcceleratorBasicAuthSettingArgs', 'AcceleratorPublicSettingArgs', 'AcceleratorSshSettingArgs']]:
        """
        Properties of the auth setting payload.
        """
        return pulumi.get(self, "auth_setting")

    @auth_setting.setter
    def auth_setting(self, value: pulumi.Input[Union['AcceleratorBasicAuthSettingArgs', 'AcceleratorPublicSettingArgs', 'AcceleratorSshSettingArgs']]):
        pulumi.set(self, "auth_setting", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Git repository URL for the accelerator.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        Git repository branch to be used.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter
    def commit(self) -> Optional[pulumi.Input[str]]:
        """
        Git repository commit to be used.
        """
        return pulumi.get(self, "commit")

    @commit.setter
    def commit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit", value)

    @property
    @pulumi.getter(name="gitTag")
    def git_tag(self) -> Optional[pulumi.Input[str]]:
        """
        Git repository tag to be used.
        """
        return pulumi.get(self, "git_tag")

    @git_tag.setter
    def git_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "git_tag", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Interval for checking for updates to Git or image repository.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_in_seconds", value)


@pulumi.input_type
class AcceleratorPublicSettingArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[str],
                 ca_cert_resource_id: Optional[pulumi.Input[str]] = None):
        """
        Auth setting for public url.
        :param pulumi.Input[str] auth_type: The type of the auth setting.
               Expected value is 'Public'.
        :param pulumi.Input[str] ca_cert_resource_id: Resource Id of CA certificate for https URL of Git repository.
        """
        AcceleratorPublicSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_type=auth_type,
            ca_cert_resource_id=ca_cert_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_type: Optional[pulumi.Input[str]] = None,
             ca_cert_resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_type is None and 'authType' in kwargs:
            auth_type = kwargs['authType']
        if auth_type is None:
            raise TypeError("Missing 'auth_type' argument")
        if ca_cert_resource_id is None and 'caCertResourceId' in kwargs:
            ca_cert_resource_id = kwargs['caCertResourceId']

        _setter("auth_type", 'Public')
        if ca_cert_resource_id is not None:
            _setter("ca_cert_resource_id", ca_cert_resource_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[str]:
        """
        The type of the auth setting.
        Expected value is 'Public'.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="caCertResourceId")
    def ca_cert_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource Id of CA certificate for https URL of Git repository.
        """
        return pulumi.get(self, "ca_cert_resource_id")

    @ca_cert_resource_id.setter
    def ca_cert_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert_resource_id", value)


@pulumi.input_type
class AcceleratorSshSettingArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[str],
                 host_key: Optional[pulumi.Input[str]] = None,
                 host_key_algorithm: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None):
        """
        Auth setting for SSH auth.
        :param pulumi.Input[str] auth_type: The type of the auth setting.
               Expected value is 'SSH'.
        :param pulumi.Input[str] host_key: Public SSH Key of git repository.
        :param pulumi.Input[str] host_key_algorithm: SSH Key algorithm of git repository.
        :param pulumi.Input[str] private_key: Private SSH Key algorithm of git repository.
        """
        AcceleratorSshSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_type=auth_type,
            host_key=host_key,
            host_key_algorithm=host_key_algorithm,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_type: Optional[pulumi.Input[str]] = None,
             host_key: Optional[pulumi.Input[str]] = None,
             host_key_algorithm: Optional[pulumi.Input[str]] = None,
             private_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_type is None and 'authType' in kwargs:
            auth_type = kwargs['authType']
        if auth_type is None:
            raise TypeError("Missing 'auth_type' argument")
        if host_key is None and 'hostKey' in kwargs:
            host_key = kwargs['hostKey']
        if host_key_algorithm is None and 'hostKeyAlgorithm' in kwargs:
            host_key_algorithm = kwargs['hostKeyAlgorithm']
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']

        _setter("auth_type", 'SSH')
        if host_key is not None:
            _setter("host_key", host_key)
        if host_key_algorithm is not None:
            _setter("host_key_algorithm", host_key_algorithm)
        if private_key is not None:
            _setter("private_key", private_key)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[str]:
        """
        The type of the auth setting.
        Expected value is 'SSH'.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="hostKey")
    def host_key(self) -> Optional[pulumi.Input[str]]:
        """
        Public SSH Key of git repository.
        """
        return pulumi.get(self, "host_key")

    @host_key.setter
    def host_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_key", value)

    @property
    @pulumi.getter(name="hostKeyAlgorithm")
    def host_key_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        SSH Key algorithm of git repository.
        """
        return pulumi.get(self, "host_key_algorithm")

    @host_key_algorithm.setter
    def host_key_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_key_algorithm", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Private SSH Key algorithm of git repository.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)


@pulumi.input_type
class ApiPortalCustomDomainPropertiesArgs:
    def __init__(__self__, *,
                 thumbprint: Optional[pulumi.Input[str]] = None):
        """
        The properties of custom domain for API portal
        :param pulumi.Input[str] thumbprint: The thumbprint of bound certificate.
        """
        ApiPortalCustomDomainPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            thumbprint=thumbprint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             thumbprint: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if thumbprint is not None:
            _setter("thumbprint", thumbprint)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of bound certificate.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint", value)


@pulumi.input_type
class ApiPortalPropertiesArgs:
    def __init__(__self__, *,
                 gateway_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 https_only: Optional[pulumi.Input[bool]] = None,
                 public: Optional[pulumi.Input[bool]] = None,
                 source_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sso_properties: Optional[pulumi.Input['SsoPropertiesArgs']] = None):
        """
        API portal properties payload
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gateway_ids: The array of resource Ids of gateway to integrate with API portal.
        :param pulumi.Input[bool] https_only: Indicate if only https is allowed.
        :param pulumi.Input[bool] public: Indicates whether the API portal exposes endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_urls: Collection of OpenAPI source URL locations.
        :param pulumi.Input['SsoPropertiesArgs'] sso_properties: Single sign-on related configuration
        """
        ApiPortalPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gateway_ids=gateway_ids,
            https_only=https_only,
            public=public,
            source_urls=source_urls,
            sso_properties=sso_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gateway_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             https_only: Optional[pulumi.Input[bool]] = None,
             public: Optional[pulumi.Input[bool]] = None,
             source_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             sso_properties: Optional[pulumi.Input['SsoPropertiesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if gateway_ids is None and 'gatewayIds' in kwargs:
            gateway_ids = kwargs['gatewayIds']
        if https_only is None and 'httpsOnly' in kwargs:
            https_only = kwargs['httpsOnly']
        if source_urls is None and 'sourceUrls' in kwargs:
            source_urls = kwargs['sourceUrls']
        if sso_properties is None and 'ssoProperties' in kwargs:
            sso_properties = kwargs['ssoProperties']

        if gateway_ids is not None:
            _setter("gateway_ids", gateway_ids)
        if https_only is None:
            https_only = False
        if https_only is not None:
            _setter("https_only", https_only)
        if public is None:
            public = False
        if public is not None:
            _setter("public", public)
        if source_urls is not None:
            _setter("source_urls", source_urls)
        if sso_properties is not None:
            _setter("sso_properties", sso_properties)

    @property
    @pulumi.getter(name="gatewayIds")
    def gateway_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The array of resource Ids of gateway to integrate with API portal.
        """
        return pulumi.get(self, "gateway_ids")

    @gateway_ids.setter
    def gateway_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateway_ids", value)

    @property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate if only https is allowed.
        """
        return pulumi.get(self, "https_only")

    @https_only.setter
    def https_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "https_only", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the API portal exposes endpoint.
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter(name="sourceUrls")
    def source_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection of OpenAPI source URL locations.
        """
        return pulumi.get(self, "source_urls")

    @source_urls.setter
    def source_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_urls", value)

    @property
    @pulumi.getter(name="ssoProperties")
    def sso_properties(self) -> Optional[pulumi.Input['SsoPropertiesArgs']]:
        """
        Single sign-on related configuration
        """
        return pulumi.get(self, "sso_properties")

    @sso_properties.setter
    def sso_properties(self, value: Optional[pulumi.Input['SsoPropertiesArgs']]):
        pulumi.set(self, "sso_properties", value)


@pulumi.input_type
class ApmPropertiesArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Properties of an APM
        :param pulumi.Input[str] type: APM Type
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: Non-sensitive properties for the APM
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Sensitive properties for the APM
        """
        ApmPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            properties=properties,
            secrets=secrets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)
        if properties is not None:
            _setter("properties", properties)
        if secrets is not None:
            _setter("secrets", secrets)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        APM Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Non-sensitive properties for the APM
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Sensitive properties for the APM
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ApmReferenceArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str]):
        """
        A reference to the APM
        :param pulumi.Input[str] resource_id: Resource Id of the APM
        """
        ApmReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")

        _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        Resource Id of the APM
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class AppResourcePropertiesArgs:
    def __init__(__self__, *,
                 addon_configs: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 custom_persistent_disks: Optional[pulumi.Input[Sequence[pulumi.Input['CustomPersistentDiskResourceArgs']]]] = None,
                 enable_end_to_end_tls: Optional[pulumi.Input[bool]] = None,
                 https_only: Optional[pulumi.Input[bool]] = None,
                 ingress_settings: Optional[pulumi.Input['IngressSettingsArgs']] = None,
                 loaded_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['LoadedCertificateArgs']]]] = None,
                 persistent_disk: Optional[pulumi.Input['PersistentDiskArgs']] = None,
                 public: Optional[pulumi.Input[bool]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]] = None,
                 temporary_disk: Optional[pulumi.Input['TemporaryDiskArgs']] = None,
                 vnet_addons: Optional[pulumi.Input['AppVNetAddonsArgs']] = None,
                 workload_profile_name: Optional[pulumi.Input[str]] = None):
        """
        App resource properties payload
        :param pulumi.Input[Mapping[str, Any]] addon_configs: Collection of addons
        :param pulumi.Input[Sequence[pulumi.Input['CustomPersistentDiskResourceArgs']]] custom_persistent_disks: List of custom persistent disks
        :param pulumi.Input[bool] enable_end_to_end_tls: Indicate if end to end TLS is enabled.
        :param pulumi.Input[bool] https_only: Indicate if only https is allowed.
        :param pulumi.Input['IngressSettingsArgs'] ingress_settings: App ingress settings payload.
        :param pulumi.Input[Sequence[pulumi.Input['LoadedCertificateArgs']]] loaded_certificates: Collection of loaded certificates
        :param pulumi.Input['PersistentDiskArgs'] persistent_disk: Persistent disk settings
        :param pulumi.Input[bool] public: Indicates whether the App exposes public endpoint
        :param pulumi.Input[Sequence[pulumi.Input['SecretArgs']]] secrets: Collection of auth secrets
        :param pulumi.Input['TemporaryDiskArgs'] temporary_disk: Temporary disk settings
        :param pulumi.Input['AppVNetAddonsArgs'] vnet_addons: Additional App settings in vnet injection instance
        :param pulumi.Input[str] workload_profile_name: The workload profile used for this app. Supported for Consumption + Dedicated plan.
        """
        AppResourcePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addon_configs=addon_configs,
            custom_persistent_disks=custom_persistent_disks,
            enable_end_to_end_tls=enable_end_to_end_tls,
            https_only=https_only,
            ingress_settings=ingress_settings,
            loaded_certificates=loaded_certificates,
            persistent_disk=persistent_disk,
            public=public,
            secrets=secrets,
            temporary_disk=temporary_disk,
            vnet_addons=vnet_addons,
            workload_profile_name=workload_profile_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addon_configs: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             custom_persistent_disks: Optional[pulumi.Input[Sequence[pulumi.Input['CustomPersistentDiskResourceArgs']]]] = None,
             enable_end_to_end_tls: Optional[pulumi.Input[bool]] = None,
             https_only: Optional[pulumi.Input[bool]] = None,
             ingress_settings: Optional[pulumi.Input['IngressSettingsArgs']] = None,
             loaded_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['LoadedCertificateArgs']]]] = None,
             persistent_disk: Optional[pulumi.Input['PersistentDiskArgs']] = None,
             public: Optional[pulumi.Input[bool]] = None,
             secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]] = None,
             temporary_disk: Optional[pulumi.Input['TemporaryDiskArgs']] = None,
             vnet_addons: Optional[pulumi.Input['AppVNetAddonsArgs']] = None,
             workload_profile_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if addon_configs is None and 'addonConfigs' in kwargs:
            addon_configs = kwargs['addonConfigs']
        if custom_persistent_disks is None and 'customPersistentDisks' in kwargs:
            custom_persistent_disks = kwargs['customPersistentDisks']
        if enable_end_to_end_tls is None and 'enableEndToEndTLS' in kwargs:
            enable_end_to_end_tls = kwargs['enableEndToEndTLS']
        if https_only is None and 'httpsOnly' in kwargs:
            https_only = kwargs['httpsOnly']
        if ingress_settings is None and 'ingressSettings' in kwargs:
            ingress_settings = kwargs['ingressSettings']
        if loaded_certificates is None and 'loadedCertificates' in kwargs:
            loaded_certificates = kwargs['loadedCertificates']
        if persistent_disk is None and 'persistentDisk' in kwargs:
            persistent_disk = kwargs['persistentDisk']
        if temporary_disk is None and 'temporaryDisk' in kwargs:
            temporary_disk = kwargs['temporaryDisk']
        if vnet_addons is None and 'vnetAddons' in kwargs:
            vnet_addons = kwargs['vnetAddons']
        if workload_profile_name is None and 'workloadProfileName' in kwargs:
            workload_profile_name = kwargs['workloadProfileName']

        if addon_configs is not None:
            _setter("addon_configs", addon_configs)
        if custom_persistent_disks is not None:
            _setter("custom_persistent_disks", custom_persistent_disks)
        if enable_end_to_end_tls is None:
            enable_end_to_end_tls = False
        if enable_end_to_end_tls is not None:
            _setter("enable_end_to_end_tls", enable_end_to_end_tls)
        if https_only is None:
            https_only = False
        if https_only is not None:
            _setter("https_only", https_only)
        if ingress_settings is not None:
            _setter("ingress_settings", ingress_settings)
        if loaded_certificates is not None:
            _setter("loaded_certificates", loaded_certificates)
        if persistent_disk is not None:
            _setter("persistent_disk", persistent_disk)
        if public is not None:
            _setter("public", public)
        if secrets is not None:
            _setter("secrets", secrets)
        if temporary_disk is not None:
            _setter("temporary_disk", temporary_disk)
        if vnet_addons is not None:
            _setter("vnet_addons", vnet_addons)
        if workload_profile_name is not None:
            _setter("workload_profile_name", workload_profile_name)

    @property
    @pulumi.getter(name="addonConfigs")
    def addon_configs(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Collection of addons
        """
        return pulumi.get(self, "addon_configs")

    @addon_configs.setter
    def addon_configs(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "addon_configs", value)

    @property
    @pulumi.getter(name="customPersistentDisks")
    def custom_persistent_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomPersistentDiskResourceArgs']]]]:
        """
        List of custom persistent disks
        """
        return pulumi.get(self, "custom_persistent_disks")

    @custom_persistent_disks.setter
    def custom_persistent_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomPersistentDiskResourceArgs']]]]):
        pulumi.set(self, "custom_persistent_disks", value)

    @property
    @pulumi.getter(name="enableEndToEndTLS")
    def enable_end_to_end_tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate if end to end TLS is enabled.
        """
        return pulumi.get(self, "enable_end_to_end_tls")

    @enable_end_to_end_tls.setter
    def enable_end_to_end_tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_end_to_end_tls", value)

    @property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate if only https is allowed.
        """
        return pulumi.get(self, "https_only")

    @https_only.setter
    def https_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "https_only", value)

    @property
    @pulumi.getter(name="ingressSettings")
    def ingress_settings(self) -> Optional[pulumi.Input['IngressSettingsArgs']]:
        """
        App ingress settings payload.
        """
        return pulumi.get(self, "ingress_settings")

    @ingress_settings.setter
    def ingress_settings(self, value: Optional[pulumi.Input['IngressSettingsArgs']]):
        pulumi.set(self, "ingress_settings", value)

    @property
    @pulumi.getter(name="loadedCertificates")
    def loaded_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadedCertificateArgs']]]]:
        """
        Collection of loaded certificates
        """
        return pulumi.get(self, "loaded_certificates")

    @loaded_certificates.setter
    def loaded_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadedCertificateArgs']]]]):
        pulumi.set(self, "loaded_certificates", value)

    @property
    @pulumi.getter(name="persistentDisk")
    def persistent_disk(self) -> Optional[pulumi.Input['PersistentDiskArgs']]:
        """
        Persistent disk settings
        """
        return pulumi.get(self, "persistent_disk")

    @persistent_disk.setter
    def persistent_disk(self, value: Optional[pulumi.Input['PersistentDiskArgs']]):
        pulumi.set(self, "persistent_disk", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the App exposes public endpoint
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]:
        """
        Collection of auth secrets
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="temporaryDisk")
    def temporary_disk(self) -> Optional[pulumi.Input['TemporaryDiskArgs']]:
        """
        Temporary disk settings
        """
        return pulumi.get(self, "temporary_disk")

    @temporary_disk.setter
    def temporary_disk(self, value: Optional[pulumi.Input['TemporaryDiskArgs']]):
        pulumi.set(self, "temporary_disk", value)

    @property
    @pulumi.getter(name="vnetAddons")
    def vnet_addons(self) -> Optional[pulumi.Input['AppVNetAddonsArgs']]:
        """
        Additional App settings in vnet injection instance
        """
        return pulumi.get(self, "vnet_addons")

    @vnet_addons.setter
    def vnet_addons(self, value: Optional[pulumi.Input['AppVNetAddonsArgs']]):
        pulumi.set(self, "vnet_addons", value)

    @property
    @pulumi.getter(name="workloadProfileName")
    def workload_profile_name(self) -> Optional[pulumi.Input[str]]:
        """
        The workload profile used for this app. Supported for Consumption + Dedicated plan.
        """
        return pulumi.get(self, "workload_profile_name")

    @workload_profile_name.setter
    def workload_profile_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_profile_name", value)


@pulumi.input_type
class AppVNetAddonsArgs:
    def __init__(__self__, *,
                 public_endpoint: Optional[pulumi.Input[bool]] = None):
        """
        Additional App settings in vnet injection instance
        :param pulumi.Input[bool] public_endpoint: Indicates whether the App in vnet injection instance exposes endpoint which could be accessed from internet.
        """
        AppVNetAddonsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_endpoint=public_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_endpoint: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if public_endpoint is None and 'publicEndpoint' in kwargs:
            public_endpoint = kwargs['publicEndpoint']

        if public_endpoint is None:
            public_endpoint = False
        if public_endpoint is not None:
            _setter("public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the App in vnet injection instance exposes endpoint which could be accessed from internet.
        """
        return pulumi.get(self, "public_endpoint")

    @public_endpoint.setter
    def public_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_endpoint", value)


@pulumi.input_type
class AzureFileVolumeArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 enable_sub_path: Optional[pulumi.Input[bool]] = None,
                 mount_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None,
                 share_name: Optional[pulumi.Input[str]] = None):
        """
        The properties of the Azure File volume. Azure File shares are mounted as volumes.
        :param pulumi.Input[str] mount_path: The mount path of the persistent disk.
        :param pulumi.Input[str] type: The type of the underlying resource to mount as a persistent disk.
               Expected value is 'AzureFileVolume'.
        :param pulumi.Input[bool] enable_sub_path: If set to true, it will create and mount a dedicated directory for every individual app instance.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] mount_options: These are the mount options for a persistent disk.
        :param pulumi.Input[bool] read_only: Indicates whether the persistent disk is a readOnly one.
        :param pulumi.Input[str] share_name: The share name of the Azure File share.
        """
        AzureFileVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_path=mount_path,
            type=type,
            enable_sub_path=enable_sub_path,
            mount_options=mount_options,
            read_only=read_only,
            share_name=share_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_path: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             enable_sub_path: Optional[pulumi.Input[bool]] = None,
             mount_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             read_only: Optional[pulumi.Input[bool]] = None,
             share_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_path is None and 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if mount_path is None:
            raise TypeError("Missing 'mount_path' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if enable_sub_path is None and 'enableSubPath' in kwargs:
            enable_sub_path = kwargs['enableSubPath']
        if mount_options is None and 'mountOptions' in kwargs:
            mount_options = kwargs['mountOptions']
        if read_only is None and 'readOnly' in kwargs:
            read_only = kwargs['readOnly']
        if share_name is None and 'shareName' in kwargs:
            share_name = kwargs['shareName']

        _setter("mount_path", mount_path)
        _setter("type", 'AzureFileVolume')
        if enable_sub_path is None:
            enable_sub_path = False
        if enable_sub_path is not None:
            _setter("enable_sub_path", enable_sub_path)
        if mount_options is not None:
            _setter("mount_options", mount_options)
        if read_only is not None:
            _setter("read_only", read_only)
        if share_name is not None:
            _setter("share_name", share_name)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[str]:
        """
        The mount path of the persistent disk.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the underlying resource to mount as a persistent disk.
        Expected value is 'AzureFileVolume'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="enableSubPath")
    def enable_sub_path(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, it will create and mount a dedicated directory for every individual app instance.
        """
        return pulumi.get(self, "enable_sub_path")

    @enable_sub_path.setter
    def enable_sub_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_sub_path", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        These are the mount options for a persistent disk.
        """
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mount_options", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the persistent disk is a readOnly one.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[pulumi.Input[str]]:
        """
        The share name of the Azure File share.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "share_name", value)


@pulumi.input_type
class BindingResourcePropertiesArgs:
    def __init__(__self__, *,
                 binding_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        Binding resource properties payload
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] binding_parameters: Binding parameters of the Binding resource
        :param pulumi.Input[str] key: The key of the bound resource
        :param pulumi.Input[str] resource_id: The Azure resource id of the bound resource
        """
        BindingResourcePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            binding_parameters=binding_parameters,
            key=key,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             binding_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             key: Optional[pulumi.Input[str]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if binding_parameters is None and 'bindingParameters' in kwargs:
            binding_parameters = kwargs['bindingParameters']
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        if binding_parameters is not None:
            _setter("binding_parameters", binding_parameters)
        if key is not None:
            _setter("key", key)
        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="bindingParameters")
    def binding_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Binding parameters of the Binding resource
        """
        return pulumi.get(self, "binding_parameters")

    @binding_parameters.setter
    def binding_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "binding_parameters", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of the bound resource
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure resource id of the bound resource
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class BuildPropertiesArgs:
    def __init__(__self__, *,
                 agent_pool: Optional[pulumi.Input[str]] = None,
                 apms: Optional[pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]]] = None,
                 builder: Optional[pulumi.Input[str]] = None,
                 certificates: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateReferenceArgs']]]] = None,
                 env: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 relative_path: Optional[pulumi.Input[str]] = None,
                 resource_requests: Optional[pulumi.Input['BuildResourceRequestsArgs']] = None):
        """
        Build resource properties payload
        :param pulumi.Input[str] agent_pool: The resource id of agent pool
        :param pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]] apms: The APMs for this build
        :param pulumi.Input[str] builder: The resource id of builder to build the source code
        :param pulumi.Input[Sequence[pulumi.Input['CertificateReferenceArgs']]] certificates: The CA Certificates for this build
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] env: The environment variables for this build
        :param pulumi.Input[str] relative_path: The relative path of source code
        :param pulumi.Input['BuildResourceRequestsArgs'] resource_requests: The customized build resource for this build
        """
        BuildPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_pool=agent_pool,
            apms=apms,
            builder=builder,
            certificates=certificates,
            env=env,
            relative_path=relative_path,
            resource_requests=resource_requests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_pool: Optional[pulumi.Input[str]] = None,
             apms: Optional[pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]]] = None,
             builder: Optional[pulumi.Input[str]] = None,
             certificates: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateReferenceArgs']]]] = None,
             env: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             relative_path: Optional[pulumi.Input[str]] = None,
             resource_requests: Optional[pulumi.Input['BuildResourceRequestsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if agent_pool is None and 'agentPool' in kwargs:
            agent_pool = kwargs['agentPool']
        if relative_path is None and 'relativePath' in kwargs:
            relative_path = kwargs['relativePath']
        if resource_requests is None and 'resourceRequests' in kwargs:
            resource_requests = kwargs['resourceRequests']

        if agent_pool is not None:
            _setter("agent_pool", agent_pool)
        if apms is not None:
            _setter("apms", apms)
        if builder is not None:
            _setter("builder", builder)
        if certificates is not None:
            _setter("certificates", certificates)
        if env is not None:
            _setter("env", env)
        if relative_path is not None:
            _setter("relative_path", relative_path)
        if resource_requests is not None:
            _setter("resource_requests", resource_requests)

    @property
    @pulumi.getter(name="agentPool")
    def agent_pool(self) -> Optional[pulumi.Input[str]]:
        """
        The resource id of agent pool
        """
        return pulumi.get(self, "agent_pool")

    @agent_pool.setter
    def agent_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_pool", value)

    @property
    @pulumi.getter
    def apms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]]]:
        """
        The APMs for this build
        """
        return pulumi.get(self, "apms")

    @apms.setter
    def apms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]]]):
        pulumi.set(self, "apms", value)

    @property
    @pulumi.getter
    def builder(self) -> Optional[pulumi.Input[str]]:
        """
        The resource id of builder to build the source code
        """
        return pulumi.get(self, "builder")

    @builder.setter
    def builder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "builder", value)

    @property
    @pulumi.getter
    def certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CertificateReferenceArgs']]]]:
        """
        The CA Certificates for this build
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateReferenceArgs']]]]):
        pulumi.set(self, "certificates", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The environment variables for this build
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[pulumi.Input[str]]:
        """
        The relative path of source code
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relative_path", value)

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> Optional[pulumi.Input['BuildResourceRequestsArgs']]:
        """
        The customized build resource for this build
        """
        return pulumi.get(self, "resource_requests")

    @resource_requests.setter
    def resource_requests(self, value: Optional[pulumi.Input['BuildResourceRequestsArgs']]):
        pulumi.set(self, "resource_requests", value)


@pulumi.input_type
class BuildResourceRequestsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[str]] = None,
                 memory: Optional[pulumi.Input[str]] = None):
        """
        Resource request payload of Build Resource.
        :param pulumi.Input[str] cpu: Optional Cpu allocated to the build resource. 1 core can be represented by 1 or 1000m. 
               The default value is 1, this should not exceed build service agent pool cpu size.
        :param pulumi.Input[str] memory: Optional Memory allocated to the build resource. 1 GB can be represented by 1Gi or 1024Mi. 
               The default value is 2Gi, this should not exceed build service agent pool memory size.
        """
        BuildResourceRequestsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            memory=memory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: Optional[pulumi.Input[str]] = None,
             memory: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if cpu is None:
            cpu = '1'
        if cpu is not None:
            _setter("cpu", cpu)
        if memory is None:
            memory = '2Gi'
        if memory is not None:
            _setter("memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Optional Cpu allocated to the build resource. 1 core can be represented by 1 or 1000m. 
        The default value is 1, this should not exceed build service agent pool cpu size.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[str]]:
        """
        Optional Memory allocated to the build resource. 1 GB can be represented by 1Gi or 1024Mi. 
        The default value is 2Gi, this should not exceed build service agent pool memory size.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory", value)


@pulumi.input_type
class BuildResultUserSourceInfoArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 build_result_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Reference to a build result
        :param pulumi.Input[str] type: Type of the source uploaded
               Expected value is 'BuildResult'.
        :param pulumi.Input[str] build_result_id: Resource id of an existing succeeded build result under the same Spring instance.
        :param pulumi.Input[str] version: Version of the source
        """
        BuildResultUserSourceInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            build_result_id=build_result_id,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             build_result_id: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if build_result_id is None and 'buildResultId' in kwargs:
            build_result_id = kwargs['buildResultId']

        _setter("type", 'BuildResult')
        if build_result_id is not None:
            _setter("build_result_id", build_result_id)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the source uploaded
        Expected value is 'BuildResult'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="buildResultId")
    def build_result_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource id of an existing succeeded build result under the same Spring instance.
        """
        return pulumi.get(self, "build_result_id")

    @build_result_id.setter
    def build_result_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_result_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class BuildServiceAgentPoolPropertiesArgs:
    def __init__(__self__, *,
                 pool_size: Optional[pulumi.Input['BuildServiceAgentPoolSizePropertiesArgs']] = None):
        """
        Build service agent pool properties
        :param pulumi.Input['BuildServiceAgentPoolSizePropertiesArgs'] pool_size: build service agent pool size properties
        """
        BuildServiceAgentPoolPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pool_size=pool_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pool_size: Optional[pulumi.Input['BuildServiceAgentPoolSizePropertiesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if pool_size is None and 'poolSize' in kwargs:
            pool_size = kwargs['poolSize']

        if pool_size is not None:
            _setter("pool_size", pool_size)

    @property
    @pulumi.getter(name="poolSize")
    def pool_size(self) -> Optional[pulumi.Input['BuildServiceAgentPoolSizePropertiesArgs']]:
        """
        build service agent pool size properties
        """
        return pulumi.get(self, "pool_size")

    @pool_size.setter
    def pool_size(self, value: Optional[pulumi.Input['BuildServiceAgentPoolSizePropertiesArgs']]):
        pulumi.set(self, "pool_size", value)


@pulumi.input_type
class BuildServiceAgentPoolSizePropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Build service agent pool size properties
        :param pulumi.Input[str] name: The name of build service agent pool size
        """
        BuildServiceAgentPoolSizePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of build service agent pool size
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class BuilderPropertiesArgs:
    def __init__(__self__, *,
                 buildpack_groups: Optional[pulumi.Input[Sequence[pulumi.Input['BuildpacksGroupPropertiesArgs']]]] = None,
                 stack: Optional[pulumi.Input['StackPropertiesArgs']] = None):
        """
        KPack Builder properties payload
        :param pulumi.Input[Sequence[pulumi.Input['BuildpacksGroupPropertiesArgs']]] buildpack_groups: Builder buildpack groups.
        :param pulumi.Input['StackPropertiesArgs'] stack: Builder cluster stack property.
        """
        BuilderPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            buildpack_groups=buildpack_groups,
            stack=stack,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             buildpack_groups: Optional[pulumi.Input[Sequence[pulumi.Input['BuildpacksGroupPropertiesArgs']]]] = None,
             stack: Optional[pulumi.Input['StackPropertiesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if buildpack_groups is None and 'buildpackGroups' in kwargs:
            buildpack_groups = kwargs['buildpackGroups']

        if buildpack_groups is not None:
            _setter("buildpack_groups", buildpack_groups)
        if stack is not None:
            _setter("stack", stack)

    @property
    @pulumi.getter(name="buildpackGroups")
    def buildpack_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildpacksGroupPropertiesArgs']]]]:
        """
        Builder buildpack groups.
        """
        return pulumi.get(self, "buildpack_groups")

    @buildpack_groups.setter
    def buildpack_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildpacksGroupPropertiesArgs']]]]):
        pulumi.set(self, "buildpack_groups", value)

    @property
    @pulumi.getter
    def stack(self) -> Optional[pulumi.Input['StackPropertiesArgs']]:
        """
        Builder cluster stack property.
        """
        return pulumi.get(self, "stack")

    @stack.setter
    def stack(self, value: Optional[pulumi.Input['StackPropertiesArgs']]):
        pulumi.set(self, "stack", value)


@pulumi.input_type
class BuildpackBindingLaunchPropertiesArgs:
    def __init__(__self__, *,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Buildpack Binding Launch Properties
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: Non-sensitive properties for launchProperties
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Sensitive properties for launchProperties
        """
        BuildpackBindingLaunchPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            properties=properties,
            secrets=secrets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if properties is not None:
            _setter("properties", properties)
        if secrets is not None:
            _setter("secrets", secrets)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Non-sensitive properties for launchProperties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Sensitive properties for launchProperties
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class BuildpackBindingPropertiesArgs:
    def __init__(__self__, *,
                 binding_type: Optional[pulumi.Input[Union[str, 'BindingType']]] = None,
                 launch_properties: Optional[pulumi.Input['BuildpackBindingLaunchPropertiesArgs']] = None):
        """
        Properties of a buildpack binding
        :param pulumi.Input[Union[str, 'BindingType']] binding_type: Buildpack Binding Type
        :param pulumi.Input['BuildpackBindingLaunchPropertiesArgs'] launch_properties: The object describes the buildpack binding launch properties
        """
        BuildpackBindingPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            binding_type=binding_type,
            launch_properties=launch_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             binding_type: Optional[pulumi.Input[Union[str, 'BindingType']]] = None,
             launch_properties: Optional[pulumi.Input['BuildpackBindingLaunchPropertiesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if binding_type is None and 'bindingType' in kwargs:
            binding_type = kwargs['bindingType']
        if launch_properties is None and 'launchProperties' in kwargs:
            launch_properties = kwargs['launchProperties']

        if binding_type is not None:
            _setter("binding_type", binding_type)
        if launch_properties is not None:
            _setter("launch_properties", launch_properties)

    @property
    @pulumi.getter(name="bindingType")
    def binding_type(self) -> Optional[pulumi.Input[Union[str, 'BindingType']]]:
        """
        Buildpack Binding Type
        """
        return pulumi.get(self, "binding_type")

    @binding_type.setter
    def binding_type(self, value: Optional[pulumi.Input[Union[str, 'BindingType']]]):
        pulumi.set(self, "binding_type", value)

    @property
    @pulumi.getter(name="launchProperties")
    def launch_properties(self) -> Optional[pulumi.Input['BuildpackBindingLaunchPropertiesArgs']]:
        """
        The object describes the buildpack binding launch properties
        """
        return pulumi.get(self, "launch_properties")

    @launch_properties.setter
    def launch_properties(self, value: Optional[pulumi.Input['BuildpackBindingLaunchPropertiesArgs']]):
        pulumi.set(self, "launch_properties", value)


@pulumi.input_type
class BuildpackPropertiesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Buildpack properties payload
        :param pulumi.Input[str] id: Id of the buildpack
        """
        BuildpackPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the buildpack
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class BuildpacksGroupPropertiesArgs:
    def __init__(__self__, *,
                 buildpacks: Optional[pulumi.Input[Sequence[pulumi.Input['BuildpackPropertiesArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Buildpack group properties of the Builder
        :param pulumi.Input[Sequence[pulumi.Input['BuildpackPropertiesArgs']]] buildpacks: Buildpacks in the buildpack group
        :param pulumi.Input[str] name: Buildpack group name
        """
        BuildpacksGroupPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            buildpacks=buildpacks,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             buildpacks: Optional[pulumi.Input[Sequence[pulumi.Input['BuildpackPropertiesArgs']]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if buildpacks is not None:
            _setter("buildpacks", buildpacks)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def buildpacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BuildpackPropertiesArgs']]]]:
        """
        Buildpacks in the buildpack group
        """
        return pulumi.get(self, "buildpacks")

    @buildpacks.setter
    def buildpacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BuildpackPropertiesArgs']]]]):
        pulumi.set(self, "buildpacks", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Buildpack group name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CertificateReferenceArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str]):
        """
        A reference to the certificate
        :param pulumi.Input[str] resource_id: Resource Id of the certificate
        """
        CertificateReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")

        _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        Resource Id of the certificate
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class ClusterResourcePropertiesArgs:
    def __init__(__self__, *,
                 infra_resource_group: Optional[pulumi.Input[str]] = None,
                 managed_environment_id: Optional[pulumi.Input[str]] = None,
                 marketplace_resource: Optional[pulumi.Input['MarketplaceResourceArgs']] = None,
                 network_profile: Optional[pulumi.Input['NetworkProfileArgs']] = None,
                 vnet_addons: Optional[pulumi.Input['ServiceVNetAddonsArgs']] = None,
                 zone_redundant: Optional[pulumi.Input[bool]] = None):
        """
        Service properties payload
        :param pulumi.Input[str] infra_resource_group: The name of the resource group that contains the infrastructure resources
        :param pulumi.Input[str] managed_environment_id: The resource Id of the Managed Environment that the Spring Apps instance builds on
        :param pulumi.Input['MarketplaceResourceArgs'] marketplace_resource: Purchasing 3rd party product of the Service resource.
        :param pulumi.Input['NetworkProfileArgs'] network_profile: Network profile of the Service
        :param pulumi.Input['ServiceVNetAddonsArgs'] vnet_addons: Additional Service settings in vnet injection instance
        """
        ClusterResourcePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            infra_resource_group=infra_resource_group,
            managed_environment_id=managed_environment_id,
            marketplace_resource=marketplace_resource,
            network_profile=network_profile,
            vnet_addons=vnet_addons,
            zone_redundant=zone_redundant,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             infra_resource_group: Optional[pulumi.Input[str]] = None,
             managed_environment_id: Optional[pulumi.Input[str]] = None,
             marketplace_resource: Optional[pulumi.Input['MarketplaceResourceArgs']] = None,
             network_profile: Optional[pulumi.Input['NetworkProfileArgs']] = None,
             vnet_addons: Optional[pulumi.Input['ServiceVNetAddonsArgs']] = None,
             zone_redundant: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if infra_resource_group is None and 'infraResourceGroup' in kwargs:
            infra_resource_group = kwargs['infraResourceGroup']
        if managed_environment_id is None and 'managedEnvironmentId' in kwargs:
            managed_environment_id = kwargs['managedEnvironmentId']
        if marketplace_resource is None and 'marketplaceResource' in kwargs:
            marketplace_resource = kwargs['marketplaceResource']
        if network_profile is None and 'networkProfile' in kwargs:
            network_profile = kwargs['networkProfile']
        if vnet_addons is None and 'vnetAddons' in kwargs:
            vnet_addons = kwargs['vnetAddons']
        if zone_redundant is None and 'zoneRedundant' in kwargs:
            zone_redundant = kwargs['zoneRedundant']

        if infra_resource_group is not None:
            _setter("infra_resource_group", infra_resource_group)
        if managed_environment_id is not None:
            _setter("managed_environment_id", managed_environment_id)
        if marketplace_resource is not None:
            _setter("marketplace_resource", marketplace_resource)
        if network_profile is not None:
            _setter("network_profile", network_profile)
        if vnet_addons is not None:
            _setter("vnet_addons", vnet_addons)
        if zone_redundant is None:
            zone_redundant = False
        if zone_redundant is not None:
            _setter("zone_redundant", zone_redundant)

    @property
    @pulumi.getter(name="infraResourceGroup")
    def infra_resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the resource group that contains the infrastructure resources
        """
        return pulumi.get(self, "infra_resource_group")

    @infra_resource_group.setter
    def infra_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "infra_resource_group", value)

    @property
    @pulumi.getter(name="managedEnvironmentId")
    def managed_environment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource Id of the Managed Environment that the Spring Apps instance builds on
        """
        return pulumi.get(self, "managed_environment_id")

    @managed_environment_id.setter
    def managed_environment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_environment_id", value)

    @property
    @pulumi.getter(name="marketplaceResource")
    def marketplace_resource(self) -> Optional[pulumi.Input['MarketplaceResourceArgs']]:
        """
        Purchasing 3rd party product of the Service resource.
        """
        return pulumi.get(self, "marketplace_resource")

    @marketplace_resource.setter
    def marketplace_resource(self, value: Optional[pulumi.Input['MarketplaceResourceArgs']]):
        pulumi.set(self, "marketplace_resource", value)

    @property
    @pulumi.getter(name="networkProfile")
    def network_profile(self) -> Optional[pulumi.Input['NetworkProfileArgs']]:
        """
        Network profile of the Service
        """
        return pulumi.get(self, "network_profile")

    @network_profile.setter
    def network_profile(self, value: Optional[pulumi.Input['NetworkProfileArgs']]):
        pulumi.set(self, "network_profile", value)

    @property
    @pulumi.getter(name="vnetAddons")
    def vnet_addons(self) -> Optional[pulumi.Input['ServiceVNetAddonsArgs']]:
        """
        Additional Service settings in vnet injection instance
        """
        return pulumi.get(self, "vnet_addons")

    @vnet_addons.setter
    def vnet_addons(self, value: Optional[pulumi.Input['ServiceVNetAddonsArgs']]):
        pulumi.set(self, "vnet_addons", value)

    @property
    @pulumi.getter(name="zoneRedundant")
    def zone_redundant(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "zone_redundant")

    @zone_redundant.setter
    def zone_redundant(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "zone_redundant", value)


@pulumi.input_type
class ConfigServerGitPropertyArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 host_key: Optional[pulumi.Input[str]] = None,
                 host_key_algorithm: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 repositories: Optional[pulumi.Input[Sequence[pulumi.Input['GitPatternRepositoryArgs']]]] = None,
                 search_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strict_host_key_checking: Optional[pulumi.Input[bool]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Property of git.
        :param pulumi.Input[str] uri: URI of the repository
        :param pulumi.Input[str] host_key: Public sshKey of git repository.
        :param pulumi.Input[str] host_key_algorithm: SshKey algorithm of git repository.
        :param pulumi.Input[str] label: Label of the repository
        :param pulumi.Input[str] password: Password of git repository basic auth.
        :param pulumi.Input[str] private_key: Private sshKey algorithm of git repository.
        :param pulumi.Input[Sequence[pulumi.Input['GitPatternRepositoryArgs']]] repositories: Repositories of git.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] search_paths: Searching path of the repository
        :param pulumi.Input[bool] strict_host_key_checking: Strict host key checking or not.
        :param pulumi.Input[str] username: Username of git repository basic auth.
        """
        ConfigServerGitPropertyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            host_key=host_key,
            host_key_algorithm=host_key_algorithm,
            label=label,
            password=password,
            private_key=private_key,
            repositories=repositories,
            search_paths=search_paths,
            strict_host_key_checking=strict_host_key_checking,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[pulumi.Input[str]] = None,
             host_key: Optional[pulumi.Input[str]] = None,
             host_key_algorithm: Optional[pulumi.Input[str]] = None,
             label: Optional[pulumi.Input[str]] = None,
             password: Optional[pulumi.Input[str]] = None,
             private_key: Optional[pulumi.Input[str]] = None,
             repositories: Optional[pulumi.Input[Sequence[pulumi.Input['GitPatternRepositoryArgs']]]] = None,
             search_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             strict_host_key_checking: Optional[pulumi.Input[bool]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if host_key is None and 'hostKey' in kwargs:
            host_key = kwargs['hostKey']
        if host_key_algorithm is None and 'hostKeyAlgorithm' in kwargs:
            host_key_algorithm = kwargs['hostKeyAlgorithm']
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if search_paths is None and 'searchPaths' in kwargs:
            search_paths = kwargs['searchPaths']
        if strict_host_key_checking is None and 'strictHostKeyChecking' in kwargs:
            strict_host_key_checking = kwargs['strictHostKeyChecking']

        _setter("uri", uri)
        if host_key is not None:
            _setter("host_key", host_key)
        if host_key_algorithm is not None:
            _setter("host_key_algorithm", host_key_algorithm)
        if label is not None:
            _setter("label", label)
        if password is not None:
            _setter("password", password)
        if private_key is not None:
            _setter("private_key", private_key)
        if repositories is not None:
            _setter("repositories", repositories)
        if search_paths is not None:
            _setter("search_paths", search_paths)
        if strict_host_key_checking is not None:
            _setter("strict_host_key_checking", strict_host_key_checking)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        URI of the repository
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="hostKey")
    def host_key(self) -> Optional[pulumi.Input[str]]:
        """
        Public sshKey of git repository.
        """
        return pulumi.get(self, "host_key")

    @host_key.setter
    def host_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_key", value)

    @property
    @pulumi.getter(name="hostKeyAlgorithm")
    def host_key_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        SshKey algorithm of git repository.
        """
        return pulumi.get(self, "host_key_algorithm")

    @host_key_algorithm.setter
    def host_key_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_key_algorithm", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label of the repository
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password of git repository basic auth.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Private sshKey algorithm of git repository.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def repositories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitPatternRepositoryArgs']]]]:
        """
        Repositories of git.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitPatternRepositoryArgs']]]]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter(name="searchPaths")
    def search_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Searching path of the repository
        """
        return pulumi.get(self, "search_paths")

    @search_paths.setter
    def search_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_paths", value)

    @property
    @pulumi.getter(name="strictHostKeyChecking")
    def strict_host_key_checking(self) -> Optional[pulumi.Input[bool]]:
        """
        Strict host key checking or not.
        """
        return pulumi.get(self, "strict_host_key_checking")

    @strict_host_key_checking.setter
    def strict_host_key_checking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_host_key_checking", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username of git repository basic auth.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ConfigServerPropertiesArgs:
    def __init__(__self__, *,
                 config_server: Optional[pulumi.Input['ConfigServerSettingsArgs']] = None,
                 enabled_state: Optional[pulumi.Input[Union[str, 'ConfigServerEnabledState']]] = None,
                 error: Optional[pulumi.Input['ErrorArgs']] = None):
        """
        Config server git properties payload
        :param pulumi.Input['ConfigServerSettingsArgs'] config_server: Settings of config server.
        :param pulumi.Input[Union[str, 'ConfigServerEnabledState']] enabled_state: Enabled state of the config server. This is only used in Consumption tier.
        :param pulumi.Input['ErrorArgs'] error: Error when apply config server settings.
        """
        ConfigServerPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_server=config_server,
            enabled_state=enabled_state,
            error=error,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_server: Optional[pulumi.Input['ConfigServerSettingsArgs']] = None,
             enabled_state: Optional[pulumi.Input[Union[str, 'ConfigServerEnabledState']]] = None,
             error: Optional[pulumi.Input['ErrorArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if config_server is None and 'configServer' in kwargs:
            config_server = kwargs['configServer']
        if enabled_state is None and 'enabledState' in kwargs:
            enabled_state = kwargs['enabledState']

        if config_server is not None:
            _setter("config_server", config_server)
        if enabled_state is not None:
            _setter("enabled_state", enabled_state)
        if error is not None:
            _setter("error", error)

    @property
    @pulumi.getter(name="configServer")
    def config_server(self) -> Optional[pulumi.Input['ConfigServerSettingsArgs']]:
        """
        Settings of config server.
        """
        return pulumi.get(self, "config_server")

    @config_server.setter
    def config_server(self, value: Optional[pulumi.Input['ConfigServerSettingsArgs']]):
        pulumi.set(self, "config_server", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[Union[str, 'ConfigServerEnabledState']]]:
        """
        Enabled state of the config server. This is only used in Consumption tier.
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[Union[str, 'ConfigServerEnabledState']]]):
        pulumi.set(self, "enabled_state", value)

    @property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['ErrorArgs']]:
        """
        Error when apply config server settings.
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['ErrorArgs']]):
        pulumi.set(self, "error", value)


@pulumi.input_type
class ConfigServerSettingsArgs:
    def __init__(__self__, *,
                 git_property: Optional[pulumi.Input['ConfigServerGitPropertyArgs']] = None):
        """
        The settings of config server.
        :param pulumi.Input['ConfigServerGitPropertyArgs'] git_property: Property of git environment.
        """
        ConfigServerSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            git_property=git_property,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             git_property: Optional[pulumi.Input['ConfigServerGitPropertyArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if git_property is None and 'gitProperty' in kwargs:
            git_property = kwargs['gitProperty']

        if git_property is not None:
            _setter("git_property", git_property)

    @property
    @pulumi.getter(name="gitProperty")
    def git_property(self) -> Optional[pulumi.Input['ConfigServerGitPropertyArgs']]:
        """
        Property of git environment.
        """
        return pulumi.get(self, "git_property")

    @git_property.setter
    def git_property(self, value: Optional[pulumi.Input['ConfigServerGitPropertyArgs']]):
        pulumi.set(self, "git_property", value)


@pulumi.input_type
class ConfigurationServiceGitPropertyArgs:
    def __init__(__self__, *,
                 repositories: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationServiceGitRepositoryArgs']]]] = None):
        """
        Property of git environment.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigurationServiceGitRepositoryArgs']]] repositories: Repositories of Application Configuration Service git property.
        """
        ConfigurationServiceGitPropertyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            repositories=repositories,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             repositories: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationServiceGitRepositoryArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if repositories is not None:
            _setter("repositories", repositories)

    @property
    @pulumi.getter
    def repositories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationServiceGitRepositoryArgs']]]]:
        """
        Repositories of Application Configuration Service git property.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationServiceGitRepositoryArgs']]]]):
        pulumi.set(self, "repositories", value)


@pulumi.input_type
class ConfigurationServiceGitRepositoryArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 name: pulumi.Input[str],
                 patterns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 uri: pulumi.Input[str],
                 ca_cert_resource_id: Optional[pulumi.Input[str]] = None,
                 git_implementation: Optional[pulumi.Input[Union[str, 'GitImplementation']]] = None,
                 host_key: Optional[pulumi.Input[str]] = None,
                 host_key_algorithm: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 search_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strict_host_key_checking: Optional[pulumi.Input[bool]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Git repository property payload for Application Configuration Service
        :param pulumi.Input[str] label: Label of the repository
        :param pulumi.Input[str] name: Name of the repository
        :param pulumi.Input[Sequence[pulumi.Input[str]]] patterns: Collection of patterns of the repository
        :param pulumi.Input[str] uri: URI of the repository
        :param pulumi.Input[str] ca_cert_resource_id: Resource Id of CA certificate for https URL of Git repository.
        :param pulumi.Input[Union[str, 'GitImplementation']] git_implementation: Git libraries used to support various repository providers
        :param pulumi.Input[str] host_key: Public sshKey of git repository.
        :param pulumi.Input[str] host_key_algorithm: SshKey algorithm of git repository.
        :param pulumi.Input[str] password: Password of git repository basic auth.
        :param pulumi.Input[str] private_key: Private sshKey algorithm of git repository.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] search_paths: Searching path of the repository
        :param pulumi.Input[bool] strict_host_key_checking: Strict host key checking or not.
        :param pulumi.Input[str] username: Username of git repository basic auth.
        """
        ConfigurationServiceGitRepositoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label=label,
            name=name,
            patterns=patterns,
            uri=uri,
            ca_cert_resource_id=ca_cert_resource_id,
            git_implementation=git_implementation,
            host_key=host_key,
            host_key_algorithm=host_key_algorithm,
            password=password,
            private_key=private_key,
            search_paths=search_paths,
            strict_host_key_checking=strict_host_key_checking,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             uri: Optional[pulumi.Input[str]] = None,
             ca_cert_resource_id: Optional[pulumi.Input[str]] = None,
             git_implementation: Optional[pulumi.Input[Union[str, 'GitImplementation']]] = None,
             host_key: Optional[pulumi.Input[str]] = None,
             host_key_algorithm: Optional[pulumi.Input[str]] = None,
             password: Optional[pulumi.Input[str]] = None,
             private_key: Optional[pulumi.Input[str]] = None,
             search_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             strict_host_key_checking: Optional[pulumi.Input[bool]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if label is None:
            raise TypeError("Missing 'label' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if patterns is None:
            raise TypeError("Missing 'patterns' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if ca_cert_resource_id is None and 'caCertResourceId' in kwargs:
            ca_cert_resource_id = kwargs['caCertResourceId']
        if git_implementation is None and 'gitImplementation' in kwargs:
            git_implementation = kwargs['gitImplementation']
        if host_key is None and 'hostKey' in kwargs:
            host_key = kwargs['hostKey']
        if host_key_algorithm is None and 'hostKeyAlgorithm' in kwargs:
            host_key_algorithm = kwargs['hostKeyAlgorithm']
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if search_paths is None and 'searchPaths' in kwargs:
            search_paths = kwargs['searchPaths']
        if strict_host_key_checking is None and 'strictHostKeyChecking' in kwargs:
            strict_host_key_checking = kwargs['strictHostKeyChecking']

        _setter("label", label)
        _setter("name", name)
        _setter("patterns", patterns)
        _setter("uri", uri)
        if ca_cert_resource_id is not None:
            _setter("ca_cert_resource_id", ca_cert_resource_id)
        if git_implementation is not None:
            _setter("git_implementation", git_implementation)
        if host_key is not None:
            _setter("host_key", host_key)
        if host_key_algorithm is not None:
            _setter("host_key_algorithm", host_key_algorithm)
        if password is not None:
            _setter("password", password)
        if private_key is not None:
            _setter("private_key", private_key)
        if search_paths is not None:
            _setter("search_paths", search_paths)
        if strict_host_key_checking is not None:
            _setter("strict_host_key_checking", strict_host_key_checking)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        """
        Label of the repository
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the repository
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def patterns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Collection of patterns of the repository
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "patterns", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        URI of the repository
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="caCertResourceId")
    def ca_cert_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource Id of CA certificate for https URL of Git repository.
        """
        return pulumi.get(self, "ca_cert_resource_id")

    @ca_cert_resource_id.setter
    def ca_cert_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert_resource_id", value)

    @property
    @pulumi.getter(name="gitImplementation")
    def git_implementation(self) -> Optional[pulumi.Input[Union[str, 'GitImplementation']]]:
        """
        Git libraries used to support various repository providers
        """
        return pulumi.get(self, "git_implementation")

    @git_implementation.setter
    def git_implementation(self, value: Optional[pulumi.Input[Union[str, 'GitImplementation']]]):
        pulumi.set(self, "git_implementation", value)

    @property
    @pulumi.getter(name="hostKey")
    def host_key(self) -> Optional[pulumi.Input[str]]:
        """
        Public sshKey of git repository.
        """
        return pulumi.get(self, "host_key")

    @host_key.setter
    def host_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_key", value)

    @property
    @pulumi.getter(name="hostKeyAlgorithm")
    def host_key_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        SshKey algorithm of git repository.
        """
        return pulumi.get(self, "host_key_algorithm")

    @host_key_algorithm.setter
    def host_key_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_key_algorithm", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password of git repository basic auth.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Private sshKey algorithm of git repository.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="searchPaths")
    def search_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Searching path of the repository
        """
        return pulumi.get(self, "search_paths")

    @search_paths.setter
    def search_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_paths", value)

    @property
    @pulumi.getter(name="strictHostKeyChecking")
    def strict_host_key_checking(self) -> Optional[pulumi.Input[bool]]:
        """
        Strict host key checking or not.
        """
        return pulumi.get(self, "strict_host_key_checking")

    @strict_host_key_checking.setter
    def strict_host_key_checking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_host_key_checking", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username of git repository basic auth.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ConfigurationServicePropertiesArgs:
    def __init__(__self__, *,
                 generation: Optional[pulumi.Input[Union[str, 'ConfigurationServiceGeneration']]] = None,
                 settings: Optional[pulumi.Input['ConfigurationServiceSettingsArgs']] = None):
        """
        Application Configuration Service properties payload
        :param pulumi.Input[Union[str, 'ConfigurationServiceGeneration']] generation: The generation of the Application Configuration Service.
        :param pulumi.Input['ConfigurationServiceSettingsArgs'] settings: The settings of Application Configuration Service.
        """
        ConfigurationServicePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            generation=generation,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             generation: Optional[pulumi.Input[Union[str, 'ConfigurationServiceGeneration']]] = None,
             settings: Optional[pulumi.Input['ConfigurationServiceSettingsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if generation is None:
            generation = 'Gen1'
        if generation is not None:
            _setter("generation", generation)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter
    def generation(self) -> Optional[pulumi.Input[Union[str, 'ConfigurationServiceGeneration']]]:
        """
        The generation of the Application Configuration Service.
        """
        return pulumi.get(self, "generation")

    @generation.setter
    def generation(self, value: Optional[pulumi.Input[Union[str, 'ConfigurationServiceGeneration']]]):
        pulumi.set(self, "generation", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['ConfigurationServiceSettingsArgs']]:
        """
        The settings of Application Configuration Service.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['ConfigurationServiceSettingsArgs']]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class ConfigurationServiceSettingsArgs:
    def __init__(__self__, *,
                 git_property: Optional[pulumi.Input['ConfigurationServiceGitPropertyArgs']] = None):
        """
        The settings of Application Configuration Service.
        :param pulumi.Input['ConfigurationServiceGitPropertyArgs'] git_property: Property of git environment.
        """
        ConfigurationServiceSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            git_property=git_property,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             git_property: Optional[pulumi.Input['ConfigurationServiceGitPropertyArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if git_property is None and 'gitProperty' in kwargs:
            git_property = kwargs['gitProperty']

        if git_property is not None:
            _setter("git_property", git_property)

    @property
    @pulumi.getter(name="gitProperty")
    def git_property(self) -> Optional[pulumi.Input['ConfigurationServiceGitPropertyArgs']]:
        """
        Property of git environment.
        """
        return pulumi.get(self, "git_property")

    @git_property.setter
    def git_property(self, value: Optional[pulumi.Input['ConfigurationServiceGitPropertyArgs']]):
        pulumi.set(self, "git_property", value)


@pulumi.input_type
class ContainerProbeSettingsArgs:
    def __init__(__self__, *,
                 disable_probe: Optional[pulumi.Input[bool]] = None):
        """
        Container liveness and readiness probe settings
        :param pulumi.Input[bool] disable_probe: Indicates whether disable the liveness and readiness probe
        """
        ContainerProbeSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_probe=disable_probe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_probe: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_probe is None and 'disableProbe' in kwargs:
            disable_probe = kwargs['disableProbe']

        if disable_probe is not None:
            _setter("disable_probe", disable_probe)

    @property
    @pulumi.getter(name="disableProbe")
    def disable_probe(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether disable the liveness and readiness probe
        """
        return pulumi.get(self, "disable_probe")

    @disable_probe.setter
    def disable_probe(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_probe", value)


@pulumi.input_type
class ContainerRegistryBasicCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 server: pulumi.Input[str],
                 type: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        The basic authentication properties for the container registry resource.
        :param pulumi.Input[str] password: The password of the Container Registry.
        :param pulumi.Input[str] server: The login server of the Container Registry.
        :param pulumi.Input[str] type: The credential type of the container registry credentials.
               Expected value is 'BasicAuth'.
        :param pulumi.Input[str] username: The username of the Container Registry.
        """
        ContainerRegistryBasicCredentialsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            server=server,
            type=type,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             server: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if server is None:
            raise TypeError("Missing 'server' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("server", server)
        _setter("type", 'BasicAuth')
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password of the Container Registry.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[str]:
        """
        The login server of the Container Registry.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The credential type of the container registry credentials.
        Expected value is 'BasicAuth'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username of the Container Registry.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ContainerRegistryPropertiesArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['ContainerRegistryBasicCredentialsArgs']):
        """
        Container registry resource payload.
        :param pulumi.Input['ContainerRegistryBasicCredentialsArgs'] credentials: The credentials of the container registry resource.
        """
        ContainerRegistryPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: Optional[pulumi.Input['ContainerRegistryBasicCredentialsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if credentials is None:
            raise TypeError("Missing 'credentials' argument")

        _setter("credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['ContainerRegistryBasicCredentialsArgs']:
        """
        The credentials of the container registry resource.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['ContainerRegistryBasicCredentialsArgs']):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class ContentCertificatePropertiesArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 content: Optional[pulumi.Input[str]] = None):
        """
        Properties of certificate imported from key vault.
        :param pulumi.Input[str] type: The type of the certificate source.
               Expected value is 'ContentCertificate'.
        :param pulumi.Input[str] content: The content of uploaded certificate.
        """
        ContentCertificatePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            content=content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             content: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", 'ContentCertificate')
        if content is not None:
            _setter("content", content)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the certificate source.
        Expected value is 'ContentCertificate'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        The content of uploaded certificate.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)


@pulumi.input_type
class CustomContainerUserSourceInfoArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 custom_container: Optional[pulumi.Input['CustomContainerArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Custom container user source info
        :param pulumi.Input[str] type: Type of the source uploaded
               Expected value is 'Container'.
        :param pulumi.Input['CustomContainerArgs'] custom_container: Custom container payload
        :param pulumi.Input[str] version: Version of the source
        """
        CustomContainerUserSourceInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            custom_container=custom_container,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             custom_container: Optional[pulumi.Input['CustomContainerArgs']] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if custom_container is None and 'customContainer' in kwargs:
            custom_container = kwargs['customContainer']

        _setter("type", 'Container')
        if custom_container is not None:
            _setter("custom_container", custom_container)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the source uploaded
        Expected value is 'Container'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="customContainer")
    def custom_container(self) -> Optional[pulumi.Input['CustomContainerArgs']]:
        """
        Custom container payload
        """
        return pulumi.get(self, "custom_container")

    @custom_container.setter
    def custom_container(self, value: Optional[pulumi.Input['CustomContainerArgs']]):
        pulumi.set(self, "custom_container", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class CustomContainerArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 container_image: Optional[pulumi.Input[str]] = None,
                 image_registry_credential: Optional[pulumi.Input['ImageRegistryCredentialArgs']] = None,
                 language_framework: Optional[pulumi.Input[str]] = None,
                 server: Optional[pulumi.Input[str]] = None):
        """
        Custom container payload
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided.
        :param pulumi.Input[str] container_image: Container image of the custom container. This should be in the form of <repository>:<tag> without the server name of the registry
        :param pulumi.Input['ImageRegistryCredentialArgs'] image_registry_credential: Credential of the image registry
        :param pulumi.Input[str] language_framework: Language framework of the container image uploaded
        :param pulumi.Input[str] server: The name of the registry that contains the container image
        """
        CustomContainerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            args=args,
            command=command,
            container_image=container_image,
            image_registry_credential=image_registry_credential,
            language_framework=language_framework,
            server=server,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             container_image: Optional[pulumi.Input[str]] = None,
             image_registry_credential: Optional[pulumi.Input['ImageRegistryCredentialArgs']] = None,
             language_framework: Optional[pulumi.Input[str]] = None,
             server: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_image is None and 'containerImage' in kwargs:
            container_image = kwargs['containerImage']
        if image_registry_credential is None and 'imageRegistryCredential' in kwargs:
            image_registry_credential = kwargs['imageRegistryCredential']
        if language_framework is None and 'languageFramework' in kwargs:
            language_framework = kwargs['languageFramework']

        if args is not None:
            _setter("args", args)
        if command is not None:
            _setter("command", command)
        if container_image is not None:
            _setter("container_image", container_image)
        if image_registry_credential is not None:
            _setter("image_registry_credential", image_registry_credential)
        if language_framework is not None:
            _setter("language_framework", language_framework)
        if server is not None:
            _setter("server", server)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[pulumi.Input[str]]:
        """
        Container image of the custom container. This should be in the form of <repository>:<tag> without the server name of the registry
        """
        return pulumi.get(self, "container_image")

    @container_image.setter
    def container_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_image", value)

    @property
    @pulumi.getter(name="imageRegistryCredential")
    def image_registry_credential(self) -> Optional[pulumi.Input['ImageRegistryCredentialArgs']]:
        """
        Credential of the image registry
        """
        return pulumi.get(self, "image_registry_credential")

    @image_registry_credential.setter
    def image_registry_credential(self, value: Optional[pulumi.Input['ImageRegistryCredentialArgs']]):
        pulumi.set(self, "image_registry_credential", value)

    @property
    @pulumi.getter(name="languageFramework")
    def language_framework(self) -> Optional[pulumi.Input[str]]:
        """
        Language framework of the container image uploaded
        """
        return pulumi.get(self, "language_framework")

    @language_framework.setter
    def language_framework(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language_framework", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the registry that contains the container image
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server", value)


@pulumi.input_type
class CustomDomainPropertiesArgs:
    def __init__(__self__, *,
                 cert_name: Optional[pulumi.Input[str]] = None,
                 thumbprint: Optional[pulumi.Input[str]] = None):
        """
        Custom domain of app resource payload.
        :param pulumi.Input[str] cert_name: The bound certificate name of domain.
        :param pulumi.Input[str] thumbprint: The thumbprint of bound certificate.
        """
        CustomDomainPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cert_name=cert_name,
            thumbprint=thumbprint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cert_name: Optional[pulumi.Input[str]] = None,
             thumbprint: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cert_name is None and 'certName' in kwargs:
            cert_name = kwargs['certName']

        if cert_name is not None:
            _setter("cert_name", cert_name)
        if thumbprint is not None:
            _setter("thumbprint", thumbprint)

    @property
    @pulumi.getter(name="certName")
    def cert_name(self) -> Optional[pulumi.Input[str]]:
        """
        The bound certificate name of domain.
        """
        return pulumi.get(self, "cert_name")

    @cert_name.setter
    def cert_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cert_name", value)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of bound certificate.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint", value)


@pulumi.input_type
class CustomPersistentDiskResourceArgs:
    def __init__(__self__, *,
                 storage_id: pulumi.Input[str],
                 custom_persistent_disk_properties: Optional[pulumi.Input['AzureFileVolumeArgs']] = None):
        """
        Custom persistent disk resource payload.
        :param pulumi.Input[str] storage_id: The resource id of Azure Spring Apps Storage resource.
        :param pulumi.Input['AzureFileVolumeArgs'] custom_persistent_disk_properties: Properties of the custom persistent disk resource payload.
        """
        CustomPersistentDiskResourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_id=storage_id,
            custom_persistent_disk_properties=custom_persistent_disk_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_id: Optional[pulumi.Input[str]] = None,
             custom_persistent_disk_properties: Optional[pulumi.Input['AzureFileVolumeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if storage_id is None and 'storageId' in kwargs:
            storage_id = kwargs['storageId']
        if storage_id is None:
            raise TypeError("Missing 'storage_id' argument")
        if custom_persistent_disk_properties is None and 'customPersistentDiskProperties' in kwargs:
            custom_persistent_disk_properties = kwargs['customPersistentDiskProperties']

        _setter("storage_id", storage_id)
        if custom_persistent_disk_properties is not None:
            _setter("custom_persistent_disk_properties", custom_persistent_disk_properties)

    @property
    @pulumi.getter(name="storageId")
    def storage_id(self) -> pulumi.Input[str]:
        """
        The resource id of Azure Spring Apps Storage resource.
        """
        return pulumi.get(self, "storage_id")

    @storage_id.setter
    def storage_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_id", value)

    @property
    @pulumi.getter(name="customPersistentDiskProperties")
    def custom_persistent_disk_properties(self) -> Optional[pulumi.Input['AzureFileVolumeArgs']]:
        """
        Properties of the custom persistent disk resource payload.
        """
        return pulumi.get(self, "custom_persistent_disk_properties")

    @custom_persistent_disk_properties.setter
    def custom_persistent_disk_properties(self, value: Optional[pulumi.Input['AzureFileVolumeArgs']]):
        pulumi.set(self, "custom_persistent_disk_properties", value)


@pulumi.input_type
class CustomScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Azure Spring Apps App Instance Custom scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the custom scale rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Metadata properties to describe custom scale rule.
        :param pulumi.Input[str] type: Type of the custom scale rule
               eg: azure-servicebus, redis etc.
        """
        CustomScaleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth=auth,
            metadata=metadata,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
             metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if auth is not None:
            _setter("auth", auth)
        if metadata is not None:
            _setter("metadata", metadata)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Metadata properties to describe custom scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the custom scale rule
        eg: azure-servicebus, redis etc.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CustomizedAcceleratorPropertiesArgs:
    def __init__(__self__, *,
                 git_repository: pulumi.Input['AcceleratorGitRepositoryArgs'],
                 accelerator_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 icon_url: Optional[pulumi.Input[str]] = None):
        """
        Customized accelerator properties payload
        """
        CustomizedAcceleratorPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            git_repository=git_repository,
            accelerator_tags=accelerator_tags,
            description=description,
            display_name=display_name,
            icon_url=icon_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             git_repository: Optional[pulumi.Input['AcceleratorGitRepositoryArgs']] = None,
             accelerator_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             description: Optional[pulumi.Input[str]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             icon_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if git_repository is None and 'gitRepository' in kwargs:
            git_repository = kwargs['gitRepository']
        if git_repository is None:
            raise TypeError("Missing 'git_repository' argument")
        if accelerator_tags is None and 'acceleratorTags' in kwargs:
            accelerator_tags = kwargs['acceleratorTags']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if icon_url is None and 'iconUrl' in kwargs:
            icon_url = kwargs['iconUrl']

        _setter("git_repository", git_repository)
        if accelerator_tags is not None:
            _setter("accelerator_tags", accelerator_tags)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if icon_url is not None:
            _setter("icon_url", icon_url)

    @property
    @pulumi.getter(name="gitRepository")
    def git_repository(self) -> pulumi.Input['AcceleratorGitRepositoryArgs']:
        return pulumi.get(self, "git_repository")

    @git_repository.setter
    def git_repository(self, value: pulumi.Input['AcceleratorGitRepositoryArgs']):
        pulumi.set(self, "git_repository", value)

    @property
    @pulumi.getter(name="acceleratorTags")
    def accelerator_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "accelerator_tags")

    @accelerator_tags.setter
    def accelerator_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "accelerator_tags", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "icon_url")

    @icon_url.setter
    def icon_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icon_url", value)


@pulumi.input_type
class DeploymentResourcePropertiesArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None,
                 deployment_settings: Optional[pulumi.Input['DeploymentSettingsArgs']] = None,
                 source: Optional[pulumi.Input[Union['BuildResultUserSourceInfoArgs', 'CustomContainerUserSourceInfoArgs', 'JarUploadedUserSourceInfoArgs', 'NetCoreZipUploadedUserSourceInfoArgs', 'SourceUploadedUserSourceInfoArgs', 'UploadedUserSourceInfoArgs']]] = None):
        """
        Deployment resource properties payload
        :param pulumi.Input[bool] active: Indicates whether the Deployment is active
        :param pulumi.Input['DeploymentSettingsArgs'] deployment_settings: Deployment settings of the Deployment
        :param pulumi.Input[Union['BuildResultUserSourceInfoArgs', 'CustomContainerUserSourceInfoArgs', 'JarUploadedUserSourceInfoArgs', 'NetCoreZipUploadedUserSourceInfoArgs', 'SourceUploadedUserSourceInfoArgs', 'UploadedUserSourceInfoArgs']] source: Uploaded source information of the deployment.
        """
        DeploymentResourcePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active=active,
            deployment_settings=deployment_settings,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active: Optional[pulumi.Input[bool]] = None,
             deployment_settings: Optional[pulumi.Input['DeploymentSettingsArgs']] = None,
             source: Optional[pulumi.Input[Union['BuildResultUserSourceInfoArgs', 'CustomContainerUserSourceInfoArgs', 'JarUploadedUserSourceInfoArgs', 'NetCoreZipUploadedUserSourceInfoArgs', 'SourceUploadedUserSourceInfoArgs', 'UploadedUserSourceInfoArgs']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if deployment_settings is None and 'deploymentSettings' in kwargs:
            deployment_settings = kwargs['deploymentSettings']

        if active is not None:
            _setter("active", active)
        if deployment_settings is not None:
            _setter("deployment_settings", deployment_settings)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the Deployment is active
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="deploymentSettings")
    def deployment_settings(self) -> Optional[pulumi.Input['DeploymentSettingsArgs']]:
        """
        Deployment settings of the Deployment
        """
        return pulumi.get(self, "deployment_settings")

    @deployment_settings.setter
    def deployment_settings(self, value: Optional[pulumi.Input['DeploymentSettingsArgs']]):
        pulumi.set(self, "deployment_settings", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[Union['BuildResultUserSourceInfoArgs', 'CustomContainerUserSourceInfoArgs', 'JarUploadedUserSourceInfoArgs', 'NetCoreZipUploadedUserSourceInfoArgs', 'SourceUploadedUserSourceInfoArgs', 'UploadedUserSourceInfoArgs']]]:
        """
        Uploaded source information of the deployment.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[Union['BuildResultUserSourceInfoArgs', 'CustomContainerUserSourceInfoArgs', 'JarUploadedUserSourceInfoArgs', 'NetCoreZipUploadedUserSourceInfoArgs', 'SourceUploadedUserSourceInfoArgs', 'UploadedUserSourceInfoArgs']]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class DeploymentSettingsArgs:
    def __init__(__self__, *,
                 addon_configs: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 apms: Optional[pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]]] = None,
                 container_probe_settings: Optional[pulumi.Input['ContainerProbeSettingsArgs']] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 liveness_probe: Optional[pulumi.Input['ProbeArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['ProbeArgs']] = None,
                 resource_requests: Optional[pulumi.Input['ResourceRequestsArgs']] = None,
                 scale: Optional[pulumi.Input['ScaleArgs']] = None,
                 startup_probe: Optional[pulumi.Input['ProbeArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None):
        """
        Deployment settings payload
        :param pulumi.Input[Mapping[str, Any]] addon_configs: Collection of addons
        :param pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]] apms: Collection of ApmReferences
        :param pulumi.Input['ContainerProbeSettingsArgs'] container_probe_settings: Container liveness and readiness probe settings
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment_variables: Collection of environment variables
        :param pulumi.Input['ProbeArgs'] liveness_probe: Periodic probe of App Instance liveness. App Instance will be restarted if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param pulumi.Input['ProbeArgs'] readiness_probe: Periodic probe of App Instance service readiness. App Instance will be removed from service endpoints if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param pulumi.Input['ResourceRequestsArgs'] resource_requests: The requested resource quantity for required CPU and Memory. It is recommended that using this field to represent the required CPU and Memory, the old field cpu and memoryInGB will be deprecated later.
        :param pulumi.Input['ScaleArgs'] scale: Scaling properties for the Azure Spring Apps App Instance.
        :param pulumi.Input['ProbeArgs'] startup_probe: StartupProbe indicates that the App Instance has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a App Instance's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param pulumi.Input[int] termination_grace_period_seconds: Optional duration in seconds the App Instance needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the App Instance are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 90 seconds.
        """
        DeploymentSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addon_configs=addon_configs,
            apms=apms,
            container_probe_settings=container_probe_settings,
            environment_variables=environment_variables,
            liveness_probe=liveness_probe,
            readiness_probe=readiness_probe,
            resource_requests=resource_requests,
            scale=scale,
            startup_probe=startup_probe,
            termination_grace_period_seconds=termination_grace_period_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addon_configs: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             apms: Optional[pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]]] = None,
             container_probe_settings: Optional[pulumi.Input['ContainerProbeSettingsArgs']] = None,
             environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             liveness_probe: Optional[pulumi.Input['ProbeArgs']] = None,
             readiness_probe: Optional[pulumi.Input['ProbeArgs']] = None,
             resource_requests: Optional[pulumi.Input['ResourceRequestsArgs']] = None,
             scale: Optional[pulumi.Input['ScaleArgs']] = None,
             startup_probe: Optional[pulumi.Input['ProbeArgs']] = None,
             termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if addon_configs is None and 'addonConfigs' in kwargs:
            addon_configs = kwargs['addonConfigs']
        if container_probe_settings is None and 'containerProbeSettings' in kwargs:
            container_probe_settings = kwargs['containerProbeSettings']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if liveness_probe is None and 'livenessProbe' in kwargs:
            liveness_probe = kwargs['livenessProbe']
        if readiness_probe is None and 'readinessProbe' in kwargs:
            readiness_probe = kwargs['readinessProbe']
        if resource_requests is None and 'resourceRequests' in kwargs:
            resource_requests = kwargs['resourceRequests']
        if startup_probe is None and 'startupProbe' in kwargs:
            startup_probe = kwargs['startupProbe']
        if termination_grace_period_seconds is None and 'terminationGracePeriodSeconds' in kwargs:
            termination_grace_period_seconds = kwargs['terminationGracePeriodSeconds']

        if addon_configs is not None:
            _setter("addon_configs", addon_configs)
        if apms is not None:
            _setter("apms", apms)
        if container_probe_settings is not None:
            _setter("container_probe_settings", container_probe_settings)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if liveness_probe is not None:
            _setter("liveness_probe", liveness_probe)
        if readiness_probe is not None:
            _setter("readiness_probe", readiness_probe)
        if resource_requests is not None:
            _setter("resource_requests", resource_requests)
        if scale is not None:
            _setter("scale", scale)
        if startup_probe is not None:
            _setter("startup_probe", startup_probe)
        if termination_grace_period_seconds is None:
            termination_grace_period_seconds = 90
        if termination_grace_period_seconds is not None:
            _setter("termination_grace_period_seconds", termination_grace_period_seconds)

    @property
    @pulumi.getter(name="addonConfigs")
    def addon_configs(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Collection of addons
        """
        return pulumi.get(self, "addon_configs")

    @addon_configs.setter
    def addon_configs(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "addon_configs", value)

    @property
    @pulumi.getter
    def apms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]]]:
        """
        Collection of ApmReferences
        """
        return pulumi.get(self, "apms")

    @apms.setter
    def apms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmReferenceArgs']]]]):
        pulumi.set(self, "apms", value)

    @property
    @pulumi.getter(name="containerProbeSettings")
    def container_probe_settings(self) -> Optional[pulumi.Input['ContainerProbeSettingsArgs']]:
        """
        Container liveness and readiness probe settings
        """
        return pulumi.get(self, "container_probe_settings")

    @container_probe_settings.setter
    def container_probe_settings(self, value: Optional[pulumi.Input['ContainerProbeSettingsArgs']]):
        pulumi.set(self, "container_probe_settings", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Collection of environment variables
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['ProbeArgs']]:
        """
        Periodic probe of App Instance liveness. App Instance will be restarted if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['ProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['ProbeArgs']]:
        """
        Periodic probe of App Instance service readiness. App Instance will be removed from service endpoints if the probe fails. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['ProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> Optional[pulumi.Input['ResourceRequestsArgs']]:
        """
        The requested resource quantity for required CPU and Memory. It is recommended that using this field to represent the required CPU and Memory, the old field cpu and memoryInGB will be deprecated later.
        """
        return pulumi.get(self, "resource_requests")

    @resource_requests.setter
    def resource_requests(self, value: Optional[pulumi.Input['ResourceRequestsArgs']]):
        pulumi.set(self, "resource_requests", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['ScaleArgs']]:
        """
        Scaling properties for the Azure Spring Apps App Instance.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['ScaleArgs']]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional[pulumi.Input['ProbeArgs']]:
        """
        StartupProbe indicates that the App Instance has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a App Instance's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @startup_probe.setter
    def startup_probe(self, value: Optional[pulumi.Input['ProbeArgs']]):
        pulumi.set(self, "startup_probe", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Optional duration in seconds the App Instance needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the App Instance are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 90 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


@pulumi.input_type
class DevToolPortalFeatureDetailArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'DevToolPortalFeatureState']]] = None):
        """
        Detail settings for Dev Tool Portal feature
        :param pulumi.Input[Union[str, 'DevToolPortalFeatureState']] state: State of the plugin
        """
        DevToolPortalFeatureDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[pulumi.Input[Union[str, 'DevToolPortalFeatureState']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if state is None:
            state = 'Enabled'
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'DevToolPortalFeatureState']]]:
        """
        State of the plugin
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'DevToolPortalFeatureState']]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class DevToolPortalFeatureSettingsArgs:
    def __init__(__self__, *,
                 application_accelerator: Optional[pulumi.Input['DevToolPortalFeatureDetailArgs']] = None,
                 application_live_view: Optional[pulumi.Input['DevToolPortalFeatureDetailArgs']] = None):
        """
        Settings for Dev Tool Portal
        :param pulumi.Input['DevToolPortalFeatureDetailArgs'] application_accelerator: Detail of Accelerator plugin
        :param pulumi.Input['DevToolPortalFeatureDetailArgs'] application_live_view: Detail of App Live View plugin
        """
        DevToolPortalFeatureSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_accelerator=application_accelerator,
            application_live_view=application_live_view,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_accelerator: Optional[pulumi.Input['DevToolPortalFeatureDetailArgs']] = None,
             application_live_view: Optional[pulumi.Input['DevToolPortalFeatureDetailArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_accelerator is None and 'applicationAccelerator' in kwargs:
            application_accelerator = kwargs['applicationAccelerator']
        if application_live_view is None and 'applicationLiveView' in kwargs:
            application_live_view = kwargs['applicationLiveView']

        if application_accelerator is not None:
            _setter("application_accelerator", application_accelerator)
        if application_live_view is not None:
            _setter("application_live_view", application_live_view)

    @property
    @pulumi.getter(name="applicationAccelerator")
    def application_accelerator(self) -> Optional[pulumi.Input['DevToolPortalFeatureDetailArgs']]:
        """
        Detail of Accelerator plugin
        """
        return pulumi.get(self, "application_accelerator")

    @application_accelerator.setter
    def application_accelerator(self, value: Optional[pulumi.Input['DevToolPortalFeatureDetailArgs']]):
        pulumi.set(self, "application_accelerator", value)

    @property
    @pulumi.getter(name="applicationLiveView")
    def application_live_view(self) -> Optional[pulumi.Input['DevToolPortalFeatureDetailArgs']]:
        """
        Detail of App Live View plugin
        """
        return pulumi.get(self, "application_live_view")

    @application_live_view.setter
    def application_live_view(self, value: Optional[pulumi.Input['DevToolPortalFeatureDetailArgs']]):
        pulumi.set(self, "application_live_view", value)


@pulumi.input_type
class DevToolPortalPropertiesArgs:
    def __init__(__self__, *,
                 features: Optional[pulumi.Input['DevToolPortalFeatureSettingsArgs']] = None,
                 public: Optional[pulumi.Input[bool]] = None,
                 sso_properties: Optional[pulumi.Input['DevToolPortalSsoPropertiesArgs']] = None):
        """
        Dev Tool Portal properties payload
        :param pulumi.Input['DevToolPortalFeatureSettingsArgs'] features: Settings for Dev Tool Portal
        :param pulumi.Input[bool] public: Indicates whether the resource exposes public endpoint
        :param pulumi.Input['DevToolPortalSsoPropertiesArgs'] sso_properties: Single sign-on related configuration
        """
        DevToolPortalPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            features=features,
            public=public,
            sso_properties=sso_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             features: Optional[pulumi.Input['DevToolPortalFeatureSettingsArgs']] = None,
             public: Optional[pulumi.Input[bool]] = None,
             sso_properties: Optional[pulumi.Input['DevToolPortalSsoPropertiesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sso_properties is None and 'ssoProperties' in kwargs:
            sso_properties = kwargs['ssoProperties']

        if features is not None:
            _setter("features", features)
        if public is None:
            public = False
        if public is not None:
            _setter("public", public)
        if sso_properties is not None:
            _setter("sso_properties", sso_properties)

    @property
    @pulumi.getter
    def features(self) -> Optional[pulumi.Input['DevToolPortalFeatureSettingsArgs']]:
        """
        Settings for Dev Tool Portal
        """
        return pulumi.get(self, "features")

    @features.setter
    def features(self, value: Optional[pulumi.Input['DevToolPortalFeatureSettingsArgs']]):
        pulumi.set(self, "features", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the resource exposes public endpoint
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter(name="ssoProperties")
    def sso_properties(self) -> Optional[pulumi.Input['DevToolPortalSsoPropertiesArgs']]:
        """
        Single sign-on related configuration
        """
        return pulumi.get(self, "sso_properties")

    @sso_properties.setter
    def sso_properties(self, value: Optional[pulumi.Input['DevToolPortalSsoPropertiesArgs']]):
        pulumi.set(self, "sso_properties", value)


@pulumi.input_type
class DevToolPortalSsoPropertiesArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 metadata_url: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Single sign-on related configuration
        :param pulumi.Input[str] client_id: The public identifier for the application
        :param pulumi.Input[str] client_secret: The secret known only to the application and the authorization server
        :param pulumi.Input[str] metadata_url: The URI of a JSON file with generic OIDC provider configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: It defines the specific actions applications can be allowed to do on a user's behalf
        """
        DevToolPortalSsoPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret=client_secret,
            metadata_url=metadata_url,
            scopes=scopes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret: Optional[pulumi.Input[str]] = None,
             metadata_url: Optional[pulumi.Input[str]] = None,
             scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if metadata_url is None and 'metadataUrl' in kwargs:
            metadata_url = kwargs['metadataUrl']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret is not None:
            _setter("client_secret", client_secret)
        if metadata_url is not None:
            _setter("metadata_url", metadata_url)
        if scopes is not None:
            _setter("scopes", scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The public identifier for the application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The secret known only to the application and the authorization server
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of a JSON file with generic OIDC provider configuration.
        """
        return pulumi.get(self, "metadata_url")

    @metadata_url.setter
    def metadata_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_url", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        It defines the specific actions applications can be allowed to do on a user's behalf
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class ErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        """
        The error code compose of code and message.
        :param pulumi.Input[str] code: The code of error.
        :param pulumi.Input[str] message: The message of error.
        """
        ErrorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            message=message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[pulumi.Input[str]] = None,
             message: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if code is not None:
            _setter("code", code)
        if message is not None:
            _setter("message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        """
        The code of error.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The message of error.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


@pulumi.input_type
class ExecActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        ExecAction describes a "run in container" action.
        :param pulumi.Input[str] type: The type of the action to take to perform the health check.
               Expected value is 'ExecAction'.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        ExecActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            command=command,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", 'ExecAction')
        if command is not None:
            _setter("command", command)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the action to take to perform the health check.
        Expected value is 'ExecAction'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "command", value)


@pulumi.input_type
class GatewayApiMetadataPropertiesArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 documentation: Optional[pulumi.Input[str]] = None,
                 server_url: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        API metadata property for Spring Cloud Gateway
        :param pulumi.Input[str] description: Detailed description of the APIs available on the Gateway instance (default: `Generated OpenAPI 3 document that describes the API routes configured.`)
        :param pulumi.Input[str] documentation: Location of additional documentation for the APIs available on the Gateway instance
        :param pulumi.Input[str] server_url: Base URL that API consumers will use to access APIs on the Gateway instance.
        :param pulumi.Input[str] title: Title describing the context of the APIs available on the Gateway instance (default: `Spring Cloud Gateway for K8S`)
        :param pulumi.Input[str] version: Version of APIs available on this Gateway instance (default: `unspecified`).
        """
        GatewayApiMetadataPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            documentation=documentation,
            server_url=server_url,
            title=title,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[pulumi.Input[str]] = None,
             documentation: Optional[pulumi.Input[str]] = None,
             server_url: Optional[pulumi.Input[str]] = None,
             title: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if server_url is None and 'serverUrl' in kwargs:
            server_url = kwargs['serverUrl']

        if description is not None:
            _setter("description", description)
        if documentation is not None:
            _setter("documentation", documentation)
        if server_url is not None:
            _setter("server_url", server_url)
        if title is not None:
            _setter("title", title)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Detailed description of the APIs available on the Gateway instance (default: `Generated OpenAPI 3 document that describes the API routes configured.`)
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def documentation(self) -> Optional[pulumi.Input[str]]:
        """
        Location of additional documentation for the APIs available on the Gateway instance
        """
        return pulumi.get(self, "documentation")

    @documentation.setter
    def documentation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "documentation", value)

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[pulumi.Input[str]]:
        """
        Base URL that API consumers will use to access APIs on the Gateway instance.
        """
        return pulumi.get(self, "server_url")

    @server_url.setter
    def server_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_url", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title describing the context of the APIs available on the Gateway instance (default: `Spring Cloud Gateway for K8S`)
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of APIs available on this Gateway instance (default: `unspecified`).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class GatewayApiRouteArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 predicates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sso_enabled: Optional[pulumi.Input[bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 token_relay: Optional[pulumi.Input[bool]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        API route config of the Spring Cloud Gateway
        :param pulumi.Input[str] description: A description, will be applied to methods in the generated OpenAPI documentation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filters: To modify the request before sending it to the target endpoint, or the received response.
        :param pulumi.Input[int] order: Route processing order.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] predicates: A number of conditions to evaluate a route for each request. Each predicate may be evaluated against request headers and parameter values. All of the predicates associated with a route must evaluate to true for the route to be matched to the request.
        :param pulumi.Input[bool] sso_enabled: Enable sso validation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Classification tags, will be applied to methods in the generated OpenAPI documentation.
        :param pulumi.Input[str] title: A title, will be applied to methods in the generated OpenAPI documentation.
        :param pulumi.Input[bool] token_relay: Pass currently-authenticated user's identity token to application service, default is 'false'
        :param pulumi.Input[str] uri: Full uri, will override `appName`.
        """
        GatewayApiRouteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            filters=filters,
            order=order,
            predicates=predicates,
            sso_enabled=sso_enabled,
            tags=tags,
            title=title,
            token_relay=token_relay,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[pulumi.Input[str]] = None,
             filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             order: Optional[pulumi.Input[int]] = None,
             predicates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             sso_enabled: Optional[pulumi.Input[bool]] = None,
             tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             title: Optional[pulumi.Input[str]] = None,
             token_relay: Optional[pulumi.Input[bool]] = None,
             uri: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sso_enabled is None and 'ssoEnabled' in kwargs:
            sso_enabled = kwargs['ssoEnabled']
        if token_relay is None and 'tokenRelay' in kwargs:
            token_relay = kwargs['tokenRelay']

        if description is not None:
            _setter("description", description)
        if filters is not None:
            _setter("filters", filters)
        if order is not None:
            _setter("order", order)
        if predicates is not None:
            _setter("predicates", predicates)
        if sso_enabled is not None:
            _setter("sso_enabled", sso_enabled)
        if tags is not None:
            _setter("tags", tags)
        if title is not None:
            _setter("title", title)
        if token_relay is not None:
            _setter("token_relay", token_relay)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description, will be applied to methods in the generated OpenAPI documentation.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        To modify the request before sending it to the target endpoint, or the received response.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Route processing order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def predicates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A number of conditions to evaluate a route for each request. Each predicate may be evaluated against request headers and parameter values. All of the predicates associated with a route must evaluate to true for the route to be matched to the request.
        """
        return pulumi.get(self, "predicates")

    @predicates.setter
    def predicates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "predicates", value)

    @property
    @pulumi.getter(name="ssoEnabled")
    def sso_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable sso validation.
        """
        return pulumi.get(self, "sso_enabled")

    @sso_enabled.setter
    def sso_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sso_enabled", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Classification tags, will be applied to methods in the generated OpenAPI documentation.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        A title, will be applied to methods in the generated OpenAPI documentation.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="tokenRelay")
    def token_relay(self) -> Optional[pulumi.Input[bool]]:
        """
        Pass currently-authenticated user's identity token to application service, default is 'false'
        """
        return pulumi.get(self, "token_relay")

    @token_relay.setter
    def token_relay(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "token_relay", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        Full uri, will override `appName`.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class GatewayCorsPropertiesArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_origin_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exposed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        Cross-Origin Resource Sharing property
        :param pulumi.Input[bool] allow_credentials: Whether user credentials are supported on cross-site requests. Valid values: `true`, `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: Allowed headers in cross-site requests. The special value `*` allows actual requests to send any header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: Allowed HTTP methods on cross-site requests. The special value `*` allows all methods. If not set, `GET` and `HEAD` are allowed by default.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origin_patterns: Allowed origin patterns to make cross-site requests.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Allowed origins to make cross-site requests. The special value `*` allows all domains.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exposed_headers: HTTP response headers to expose for cross-site requests.
        :param pulumi.Input[int] max_age: How long, in seconds, the response from a pre-flight request can be cached by clients.
        """
        GatewayCorsPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_credentials=allow_credentials,
            allowed_headers=allowed_headers,
            allowed_methods=allowed_methods,
            allowed_origin_patterns=allowed_origin_patterns,
            allowed_origins=allowed_origins,
            exposed_headers=exposed_headers,
            max_age=max_age,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_credentials: Optional[pulumi.Input[bool]] = None,
             allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allowed_origin_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             exposed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             max_age: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_credentials is None and 'allowCredentials' in kwargs:
            allow_credentials = kwargs['allowCredentials']
        if allowed_headers is None and 'allowedHeaders' in kwargs:
            allowed_headers = kwargs['allowedHeaders']
        if allowed_methods is None and 'allowedMethods' in kwargs:
            allowed_methods = kwargs['allowedMethods']
        if allowed_origin_patterns is None and 'allowedOriginPatterns' in kwargs:
            allowed_origin_patterns = kwargs['allowedOriginPatterns']
        if allowed_origins is None and 'allowedOrigins' in kwargs:
            allowed_origins = kwargs['allowedOrigins']
        if exposed_headers is None and 'exposedHeaders' in kwargs:
            exposed_headers = kwargs['exposedHeaders']
        if max_age is None and 'maxAge' in kwargs:
            max_age = kwargs['maxAge']

        if allow_credentials is not None:
            _setter("allow_credentials", allow_credentials)
        if allowed_headers is not None:
            _setter("allowed_headers", allowed_headers)
        if allowed_methods is not None:
            _setter("allowed_methods", allowed_methods)
        if allowed_origin_patterns is not None:
            _setter("allowed_origin_patterns", allowed_origin_patterns)
        if allowed_origins is not None:
            _setter("allowed_origins", allowed_origins)
        if exposed_headers is not None:
            _setter("exposed_headers", exposed_headers)
        if max_age is not None:
            _setter("max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether user credentials are supported on cross-site requests. Valid values: `true`, `false`.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed headers in cross-site requests. The special value `*` allows actual requests to send any header.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed HTTP methods on cross-site requests. The special value `*` allows all methods. If not set, `GET` and `HEAD` are allowed by default.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOriginPatterns")
    def allowed_origin_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed origin patterns to make cross-site requests.
        """
        return pulumi.get(self, "allowed_origin_patterns")

    @allowed_origin_patterns.setter
    def allowed_origin_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origin_patterns", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed origins to make cross-site requests. The special value `*` allows all domains.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        HTTP response headers to expose for cross-site requests.
        """
        return pulumi.get(self, "exposed_headers")

    @exposed_headers.setter
    def exposed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exposed_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        How long, in seconds, the response from a pre-flight request can be cached by clients.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


@pulumi.input_type
class GatewayCustomDomainPropertiesArgs:
    def __init__(__self__, *,
                 thumbprint: Optional[pulumi.Input[str]] = None):
        """
        The properties of custom domain for Spring Cloud Gateway
        :param pulumi.Input[str] thumbprint: The thumbprint of bound certificate.
        """
        GatewayCustomDomainPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            thumbprint=thumbprint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             thumbprint: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if thumbprint is not None:
            _setter("thumbprint", thumbprint)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The thumbprint of bound certificate.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint", value)


@pulumi.input_type
class GatewayPropertiesClientAuthArgs:
    def __init__(__self__, *,
                 certificate_verification: Optional[pulumi.Input[Union[str, 'GatewayCertificateVerification']]] = None,
                 certificates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Client-Certification Authentication.
        :param pulumi.Input[Union[str, 'GatewayCertificateVerification']] certificate_verification: Whether to enable certificate verification or not
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificates: Collection of certificate resource Ids in Azure Spring Apps.
        """
        GatewayPropertiesClientAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_verification=certificate_verification,
            certificates=certificates,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_verification: Optional[pulumi.Input[Union[str, 'GatewayCertificateVerification']]] = None,
             certificates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_verification is None and 'certificateVerification' in kwargs:
            certificate_verification = kwargs['certificateVerification']

        if certificate_verification is None:
            certificate_verification = 'Disabled'
        if certificate_verification is not None:
            _setter("certificate_verification", certificate_verification)
        if certificates is not None:
            _setter("certificates", certificates)

    @property
    @pulumi.getter(name="certificateVerification")
    def certificate_verification(self) -> Optional[pulumi.Input[Union[str, 'GatewayCertificateVerification']]]:
        """
        Whether to enable certificate verification or not
        """
        return pulumi.get(self, "certificate_verification")

    @certificate_verification.setter
    def certificate_verification(self, value: Optional[pulumi.Input[Union[str, 'GatewayCertificateVerification']]]):
        pulumi.set(self, "certificate_verification", value)

    @property
    @pulumi.getter
    def certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection of certificate resource Ids in Azure Spring Apps.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "certificates", value)


@pulumi.input_type
class GatewayPropertiesEnvironmentVariablesArgs:
    def __init__(__self__, *,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Environment variables of Spring Cloud Gateway
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: Non-sensitive properties
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Sensitive properties
        """
        GatewayPropertiesEnvironmentVariablesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            properties=properties,
            secrets=secrets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if properties is not None:
            _setter("properties", properties)
        if secrets is not None:
            _setter("secrets", secrets)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Non-sensitive properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Sensitive properties
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class GatewayPropertiesArgs:
    def __init__(__self__, *,
                 addon_configs: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 api_metadata_properties: Optional[pulumi.Input['GatewayApiMetadataPropertiesArgs']] = None,
                 apm_types: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'ApmType']]]]] = None,
                 client_auth: Optional[pulumi.Input['GatewayPropertiesClientAuthArgs']] = None,
                 cors_properties: Optional[pulumi.Input['GatewayCorsPropertiesArgs']] = None,
                 environment_variables: Optional[pulumi.Input['GatewayPropertiesEnvironmentVariablesArgs']] = None,
                 https_only: Optional[pulumi.Input[bool]] = None,
                 public: Optional[pulumi.Input[bool]] = None,
                 resource_requests: Optional[pulumi.Input['GatewayResourceRequestsArgs']] = None,
                 sso_properties: Optional[pulumi.Input['SsoPropertiesArgs']] = None):
        """
        Spring Cloud Gateway properties payload
        :param pulumi.Input[Mapping[str, Any]] addon_configs: Collection of addons for Spring Cloud Gateway
        :param pulumi.Input['GatewayApiMetadataPropertiesArgs'] api_metadata_properties: API metadata property for Spring Cloud Gateway
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'ApmType']]]] apm_types: Collection of APM type used in Spring Cloud Gateway
        :param pulumi.Input['GatewayPropertiesClientAuthArgs'] client_auth: Client-Certification Authentication.
        :param pulumi.Input['GatewayCorsPropertiesArgs'] cors_properties: Cross-Origin Resource Sharing property
        :param pulumi.Input['GatewayPropertiesEnvironmentVariablesArgs'] environment_variables: Environment variables of Spring Cloud Gateway
        :param pulumi.Input[bool] https_only: Indicate if only https is allowed.
        :param pulumi.Input[bool] public: Indicates whether the Spring Cloud Gateway exposes endpoint.
        :param pulumi.Input['GatewayResourceRequestsArgs'] resource_requests: The requested resource quantity for required CPU and Memory.
        :param pulumi.Input['SsoPropertiesArgs'] sso_properties: Single sign-on related configuration
        """
        GatewayPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addon_configs=addon_configs,
            api_metadata_properties=api_metadata_properties,
            apm_types=apm_types,
            client_auth=client_auth,
            cors_properties=cors_properties,
            environment_variables=environment_variables,
            https_only=https_only,
            public=public,
            resource_requests=resource_requests,
            sso_properties=sso_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addon_configs: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             api_metadata_properties: Optional[pulumi.Input['GatewayApiMetadataPropertiesArgs']] = None,
             apm_types: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'ApmType']]]]] = None,
             client_auth: Optional[pulumi.Input['GatewayPropertiesClientAuthArgs']] = None,
             cors_properties: Optional[pulumi.Input['GatewayCorsPropertiesArgs']] = None,
             environment_variables: Optional[pulumi.Input['GatewayPropertiesEnvironmentVariablesArgs']] = None,
             https_only: Optional[pulumi.Input[bool]] = None,
             public: Optional[pulumi.Input[bool]] = None,
             resource_requests: Optional[pulumi.Input['GatewayResourceRequestsArgs']] = None,
             sso_properties: Optional[pulumi.Input['SsoPropertiesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if addon_configs is None and 'addonConfigs' in kwargs:
            addon_configs = kwargs['addonConfigs']
        if api_metadata_properties is None and 'apiMetadataProperties' in kwargs:
            api_metadata_properties = kwargs['apiMetadataProperties']
        if apm_types is None and 'apmTypes' in kwargs:
            apm_types = kwargs['apmTypes']
        if client_auth is None and 'clientAuth' in kwargs:
            client_auth = kwargs['clientAuth']
        if cors_properties is None and 'corsProperties' in kwargs:
            cors_properties = kwargs['corsProperties']
        if environment_variables is None and 'environmentVariables' in kwargs:
            environment_variables = kwargs['environmentVariables']
        if https_only is None and 'httpsOnly' in kwargs:
            https_only = kwargs['httpsOnly']
        if resource_requests is None and 'resourceRequests' in kwargs:
            resource_requests = kwargs['resourceRequests']
        if sso_properties is None and 'ssoProperties' in kwargs:
            sso_properties = kwargs['ssoProperties']

        if addon_configs is not None:
            _setter("addon_configs", addon_configs)
        if api_metadata_properties is not None:
            _setter("api_metadata_properties", api_metadata_properties)
        if apm_types is not None:
            _setter("apm_types", apm_types)
        if client_auth is not None:
            _setter("client_auth", client_auth)
        if cors_properties is not None:
            _setter("cors_properties", cors_properties)
        if environment_variables is not None:
            _setter("environment_variables", environment_variables)
        if https_only is None:
            https_only = False
        if https_only is not None:
            _setter("https_only", https_only)
        if public is None:
            public = False
        if public is not None:
            _setter("public", public)
        if resource_requests is not None:
            _setter("resource_requests", resource_requests)
        if sso_properties is not None:
            _setter("sso_properties", sso_properties)

    @property
    @pulumi.getter(name="addonConfigs")
    def addon_configs(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Collection of addons for Spring Cloud Gateway
        """
        return pulumi.get(self, "addon_configs")

    @addon_configs.setter
    def addon_configs(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "addon_configs", value)

    @property
    @pulumi.getter(name="apiMetadataProperties")
    def api_metadata_properties(self) -> Optional[pulumi.Input['GatewayApiMetadataPropertiesArgs']]:
        """
        API metadata property for Spring Cloud Gateway
        """
        return pulumi.get(self, "api_metadata_properties")

    @api_metadata_properties.setter
    def api_metadata_properties(self, value: Optional[pulumi.Input['GatewayApiMetadataPropertiesArgs']]):
        pulumi.set(self, "api_metadata_properties", value)

    @property
    @pulumi.getter(name="apmTypes")
    def apm_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'ApmType']]]]]:
        """
        Collection of APM type used in Spring Cloud Gateway
        """
        return pulumi.get(self, "apm_types")

    @apm_types.setter
    def apm_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'ApmType']]]]]):
        pulumi.set(self, "apm_types", value)

    @property
    @pulumi.getter(name="clientAuth")
    def client_auth(self) -> Optional[pulumi.Input['GatewayPropertiesClientAuthArgs']]:
        """
        Client-Certification Authentication.
        """
        return pulumi.get(self, "client_auth")

    @client_auth.setter
    def client_auth(self, value: Optional[pulumi.Input['GatewayPropertiesClientAuthArgs']]):
        pulumi.set(self, "client_auth", value)

    @property
    @pulumi.getter(name="corsProperties")
    def cors_properties(self) -> Optional[pulumi.Input['GatewayCorsPropertiesArgs']]:
        """
        Cross-Origin Resource Sharing property
        """
        return pulumi.get(self, "cors_properties")

    @cors_properties.setter
    def cors_properties(self, value: Optional[pulumi.Input['GatewayCorsPropertiesArgs']]):
        pulumi.set(self, "cors_properties", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input['GatewayPropertiesEnvironmentVariablesArgs']]:
        """
        Environment variables of Spring Cloud Gateway
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input['GatewayPropertiesEnvironmentVariablesArgs']]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter(name="httpsOnly")
    def https_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate if only https is allowed.
        """
        return pulumi.get(self, "https_only")

    @https_only.setter
    def https_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "https_only", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the Spring Cloud Gateway exposes endpoint.
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter(name="resourceRequests")
    def resource_requests(self) -> Optional[pulumi.Input['GatewayResourceRequestsArgs']]:
        """
        The requested resource quantity for required CPU and Memory.
        """
        return pulumi.get(self, "resource_requests")

    @resource_requests.setter
    def resource_requests(self, value: Optional[pulumi.Input['GatewayResourceRequestsArgs']]):
        pulumi.set(self, "resource_requests", value)

    @property
    @pulumi.getter(name="ssoProperties")
    def sso_properties(self) -> Optional[pulumi.Input['SsoPropertiesArgs']]:
        """
        Single sign-on related configuration
        """
        return pulumi.get(self, "sso_properties")

    @sso_properties.setter
    def sso_properties(self, value: Optional[pulumi.Input['SsoPropertiesArgs']]):
        pulumi.set(self, "sso_properties", value)


@pulumi.input_type
class GatewayResourceRequestsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[str]] = None,
                 memory: Optional[pulumi.Input[str]] = None):
        """
        Resource request payload of Spring Cloud Gateway.
        :param pulumi.Input[str] cpu: Cpu allocated to each Spring Cloud Gateway instance.
        :param pulumi.Input[str] memory: Memory allocated to each Spring Cloud Gateway instance.
        """
        GatewayResourceRequestsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            memory=memory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: Optional[pulumi.Input[str]] = None,
             memory: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if cpu is None:
            cpu = '1'
        if cpu is not None:
            _setter("cpu", cpu)
        if memory is None:
            memory = '2Gi'
        if memory is not None:
            _setter("memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Cpu allocated to each Spring Cloud Gateway instance.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[str]]:
        """
        Memory allocated to each Spring Cloud Gateway instance.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory", value)


@pulumi.input_type
class GatewayRouteConfigOpenApiPropertiesArgs:
    def __init__(__self__, *,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        OpenAPI properties of Spring Cloud Gateway route config.
        :param pulumi.Input[str] uri: The URI of OpenAPI specification.
        """
        GatewayRouteConfigOpenApiPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of OpenAPI specification.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class GatewayRouteConfigPropertiesArgs:
    def __init__(__self__, *,
                 app_resource_id: Optional[pulumi.Input[str]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 open_api: Optional[pulumi.Input['GatewayRouteConfigOpenApiPropertiesArgs']] = None,
                 predicates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 protocol: Optional[pulumi.Input[Union[str, 'GatewayRouteConfigProtocol']]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayApiRouteArgs']]]] = None,
                 sso_enabled: Optional[pulumi.Input[bool]] = None):
        """
        API route config of the Spring Cloud Gateway
        :param pulumi.Input[str] app_resource_id: The resource Id of the Azure Spring Apps app, required unless route defines `uri`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filters: To modify the request before sending it to the target endpoint, or the received response in app level.
        :param pulumi.Input['GatewayRouteConfigOpenApiPropertiesArgs'] open_api: OpenAPI properties of Spring Cloud Gateway route config.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] predicates: A number of conditions to evaluate a route for each request in app level. Each predicate may be evaluated against request headers and parameter values. All of the predicates associated with a route must evaluate to true for the route to be matched to the request.
        :param pulumi.Input[Union[str, 'GatewayRouteConfigProtocol']] protocol: Protocol of routed Azure Spring Apps applications.
        :param pulumi.Input[Sequence[pulumi.Input['GatewayApiRouteArgs']]] routes: Array of API routes, each route contains properties such as `title`, `uri`, `ssoEnabled`, `predicates`, `filters`.
        :param pulumi.Input[bool] sso_enabled: Enable Single Sign-On in app level.
        """
        GatewayRouteConfigPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_resource_id=app_resource_id,
            filters=filters,
            open_api=open_api,
            predicates=predicates,
            protocol=protocol,
            routes=routes,
            sso_enabled=sso_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_resource_id: Optional[pulumi.Input[str]] = None,
             filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             open_api: Optional[pulumi.Input['GatewayRouteConfigOpenApiPropertiesArgs']] = None,
             predicates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             protocol: Optional[pulumi.Input[Union[str, 'GatewayRouteConfigProtocol']]] = None,
             routes: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayApiRouteArgs']]]] = None,
             sso_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_resource_id is None and 'appResourceId' in kwargs:
            app_resource_id = kwargs['appResourceId']
        if open_api is None and 'openApi' in kwargs:
            open_api = kwargs['openApi']
        if sso_enabled is None and 'ssoEnabled' in kwargs:
            sso_enabled = kwargs['ssoEnabled']

        if app_resource_id is not None:
            _setter("app_resource_id", app_resource_id)
        if filters is not None:
            _setter("filters", filters)
        if open_api is not None:
            _setter("open_api", open_api)
        if predicates is not None:
            _setter("predicates", predicates)
        if protocol is None:
            protocol = 'HTTP'
        if protocol is not None:
            _setter("protocol", protocol)
        if routes is not None:
            _setter("routes", routes)
        if sso_enabled is not None:
            _setter("sso_enabled", sso_enabled)

    @property
    @pulumi.getter(name="appResourceId")
    def app_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource Id of the Azure Spring Apps app, required unless route defines `uri`.
        """
        return pulumi.get(self, "app_resource_id")

    @app_resource_id.setter
    def app_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_resource_id", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        To modify the request before sending it to the target endpoint, or the received response in app level.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter(name="openApi")
    def open_api(self) -> Optional[pulumi.Input['GatewayRouteConfigOpenApiPropertiesArgs']]:
        """
        OpenAPI properties of Spring Cloud Gateway route config.
        """
        return pulumi.get(self, "open_api")

    @open_api.setter
    def open_api(self, value: Optional[pulumi.Input['GatewayRouteConfigOpenApiPropertiesArgs']]):
        pulumi.set(self, "open_api", value)

    @property
    @pulumi.getter
    def predicates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A number of conditions to evaluate a route for each request in app level. Each predicate may be evaluated against request headers and parameter values. All of the predicates associated with a route must evaluate to true for the route to be matched to the request.
        """
        return pulumi.get(self, "predicates")

    @predicates.setter
    def predicates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "predicates", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[str, 'GatewayRouteConfigProtocol']]]:
        """
        Protocol of routed Azure Spring Apps applications.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[str, 'GatewayRouteConfigProtocol']]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewayApiRouteArgs']]]]:
        """
        Array of API routes, each route contains properties such as `title`, `uri`, `ssoEnabled`, `predicates`, `filters`.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewayApiRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter(name="ssoEnabled")
    def sso_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Single Sign-On in app level.
        """
        return pulumi.get(self, "sso_enabled")

    @sso_enabled.setter
    def sso_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sso_enabled", value)


@pulumi.input_type
class GitPatternRepositoryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 uri: pulumi.Input[str],
                 host_key: Optional[pulumi.Input[str]] = None,
                 host_key_algorithm: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 pattern: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 search_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strict_host_key_checking: Optional[pulumi.Input[bool]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Git repository property payload for config server
        :param pulumi.Input[str] name: Name of the repository
        :param pulumi.Input[str] uri: URI of the repository
        :param pulumi.Input[str] host_key: Public sshKey of git repository.
        :param pulumi.Input[str] host_key_algorithm: SshKey algorithm of git repository.
        :param pulumi.Input[str] label: Label of the repository
        :param pulumi.Input[str] password: Password of git repository basic auth.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pattern: Collection of pattern of the repository
        :param pulumi.Input[str] private_key: Private sshKey algorithm of git repository.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] search_paths: Searching path of the repository
        :param pulumi.Input[bool] strict_host_key_checking: Strict host key checking or not.
        :param pulumi.Input[str] username: Username of git repository basic auth.
        """
        GitPatternRepositoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            uri=uri,
            host_key=host_key,
            host_key_algorithm=host_key_algorithm,
            label=label,
            password=password,
            pattern=pattern,
            private_key=private_key,
            search_paths=search_paths,
            strict_host_key_checking=strict_host_key_checking,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             uri: Optional[pulumi.Input[str]] = None,
             host_key: Optional[pulumi.Input[str]] = None,
             host_key_algorithm: Optional[pulumi.Input[str]] = None,
             label: Optional[pulumi.Input[str]] = None,
             password: Optional[pulumi.Input[str]] = None,
             pattern: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             private_key: Optional[pulumi.Input[str]] = None,
             search_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             strict_host_key_checking: Optional[pulumi.Input[bool]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if uri is None:
            raise TypeError("Missing 'uri' argument")
        if host_key is None and 'hostKey' in kwargs:
            host_key = kwargs['hostKey']
        if host_key_algorithm is None and 'hostKeyAlgorithm' in kwargs:
            host_key_algorithm = kwargs['hostKeyAlgorithm']
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if search_paths is None and 'searchPaths' in kwargs:
            search_paths = kwargs['searchPaths']
        if strict_host_key_checking is None and 'strictHostKeyChecking' in kwargs:
            strict_host_key_checking = kwargs['strictHostKeyChecking']

        _setter("name", name)
        _setter("uri", uri)
        if host_key is not None:
            _setter("host_key", host_key)
        if host_key_algorithm is not None:
            _setter("host_key_algorithm", host_key_algorithm)
        if label is not None:
            _setter("label", label)
        if password is not None:
            _setter("password", password)
        if pattern is not None:
            _setter("pattern", pattern)
        if private_key is not None:
            _setter("private_key", private_key)
        if search_paths is not None:
            _setter("search_paths", search_paths)
        if strict_host_key_checking is not None:
            _setter("strict_host_key_checking", strict_host_key_checking)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the repository
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        URI of the repository
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="hostKey")
    def host_key(self) -> Optional[pulumi.Input[str]]:
        """
        Public sshKey of git repository.
        """
        return pulumi.get(self, "host_key")

    @host_key.setter
    def host_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_key", value)

    @property
    @pulumi.getter(name="hostKeyAlgorithm")
    def host_key_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        SshKey algorithm of git repository.
        """
        return pulumi.get(self, "host_key_algorithm")

    @host_key_algorithm.setter
    def host_key_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_key_algorithm", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Label of the repository
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password of git repository basic auth.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection of pattern of the repository
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        Private sshKey algorithm of git repository.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="searchPaths")
    def search_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Searching path of the repository
        """
        return pulumi.get(self, "search_paths")

    @search_paths.setter
    def search_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_paths", value)

    @property
    @pulumi.getter(name="strictHostKeyChecking")
    def strict_host_key_checking(self) -> Optional[pulumi.Input[bool]]:
        """
        Strict host key checking or not.
        """
        return pulumi.get(self, "strict_host_key_checking")

    @strict_host_key_checking.setter
    def strict_host_key_checking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_host_key_checking", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username of git repository basic auth.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class HTTPGetActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 scheme: Optional[pulumi.Input[Union[str, 'HTTPSchemeType']]] = None):
        """
        HTTPGetAction describes an action based on HTTP Get requests.
        :param pulumi.Input[str] type: The type of the action to take to perform the health check.
               Expected value is 'HTTPGetAction'.
        :param pulumi.Input[str] path: Path to access on the HTTP server.
        :param pulumi.Input[Union[str, 'HTTPSchemeType']] scheme: Scheme to use for connecting to the host. Defaults to HTTP.
               
               Possible enum values:
                - `"HTTP"` means that the scheme used will be http://
                - `"HTTPS"` means that the scheme used will be https://
        """
        HTTPGetActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            path=path,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             path: Optional[pulumi.Input[str]] = None,
             scheme: Optional[pulumi.Input[Union[str, 'HTTPSchemeType']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", 'HTTPGetAction')
        if path is not None:
            _setter("path", path)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the action to take to perform the health check.
        Expected value is 'HTTPGetAction'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[Union[str, 'HTTPSchemeType']]]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.

        Possible enum values:
         - `"HTTP"` means that the scheme used will be http://
         - `"HTTPS"` means that the scheme used will be https://
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[Union[str, 'HTTPSchemeType']]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class HttpScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Azure Spring Apps App Instance Http scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the custom scale rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Metadata properties to describe http scale rule.
        """
        HttpScaleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth=auth,
            metadata=metadata,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
             metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if auth is not None:
            _setter("auth", auth)
        if metadata is not None:
            _setter("metadata", metadata)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Metadata properties to describe http scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class ImageRegistryCredentialArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Credential of the image registry
        :param pulumi.Input[str] password: The password of the image registry credential
        :param pulumi.Input[str] username: The username of the image registry credential
        """
        ImageRegistryCredentialArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if password is not None:
            _setter("password", password)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password of the image registry credential
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username of the image registry credential
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class IngressConfigArgs:
    def __init__(__self__, *,
                 read_timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        Ingress configuration payload for Azure Spring Apps resource.
        :param pulumi.Input[int] read_timeout_in_seconds: Ingress read time out in seconds.
        """
        IngressConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read_timeout_in_seconds=read_timeout_in_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read_timeout_in_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if read_timeout_in_seconds is None and 'readTimeoutInSeconds' in kwargs:
            read_timeout_in_seconds = kwargs['readTimeoutInSeconds']

        if read_timeout_in_seconds is not None:
            _setter("read_timeout_in_seconds", read_timeout_in_seconds)

    @property
    @pulumi.getter(name="readTimeoutInSeconds")
    def read_timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Ingress read time out in seconds.
        """
        return pulumi.get(self, "read_timeout_in_seconds")

    @read_timeout_in_seconds.setter
    def read_timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_timeout_in_seconds", value)


@pulumi.input_type
class IngressSettingsClientAuthArgs:
    def __init__(__self__, *,
                 certificates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Client-Certification Authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificates: Collection of certificate resource id.
        """
        IngressSettingsClientAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if certificates is not None:
            _setter("certificates", certificates)

    @property
    @pulumi.getter
    def certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Collection of certificate resource id.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "certificates", value)


@pulumi.input_type
class IngressSettingsArgs:
    def __init__(__self__, *,
                 backend_protocol: Optional[pulumi.Input[Union[str, 'BackendProtocol']]] = None,
                 client_auth: Optional[pulumi.Input['IngressSettingsClientAuthArgs']] = None,
                 read_timeout_in_seconds: Optional[pulumi.Input[int]] = None,
                 send_timeout_in_seconds: Optional[pulumi.Input[int]] = None,
                 session_affinity: Optional[pulumi.Input[Union[str, 'SessionAffinity']]] = None,
                 session_cookie_max_age: Optional[pulumi.Input[int]] = None):
        """
        App ingress settings payload.
        :param pulumi.Input[Union[str, 'BackendProtocol']] backend_protocol: How ingress should communicate with this app backend service.
        :param pulumi.Input['IngressSettingsClientAuthArgs'] client_auth: Client-Certification Authentication.
        :param pulumi.Input[int] read_timeout_in_seconds: Ingress read time out in seconds.
        :param pulumi.Input[int] send_timeout_in_seconds: Ingress send time out in seconds.
        :param pulumi.Input[Union[str, 'SessionAffinity']] session_affinity: Type of the affinity, set this to Cookie to enable session affinity.
        :param pulumi.Input[int] session_cookie_max_age: Time in seconds until the cookie expires.
        """
        IngressSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_protocol=backend_protocol,
            client_auth=client_auth,
            read_timeout_in_seconds=read_timeout_in_seconds,
            send_timeout_in_seconds=send_timeout_in_seconds,
            session_affinity=session_affinity,
            session_cookie_max_age=session_cookie_max_age,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_protocol: Optional[pulumi.Input[Union[str, 'BackendProtocol']]] = None,
             client_auth: Optional[pulumi.Input['IngressSettingsClientAuthArgs']] = None,
             read_timeout_in_seconds: Optional[pulumi.Input[int]] = None,
             send_timeout_in_seconds: Optional[pulumi.Input[int]] = None,
             session_affinity: Optional[pulumi.Input[Union[str, 'SessionAffinity']]] = None,
             session_cookie_max_age: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backend_protocol is None and 'backendProtocol' in kwargs:
            backend_protocol = kwargs['backendProtocol']
        if client_auth is None and 'clientAuth' in kwargs:
            client_auth = kwargs['clientAuth']
        if read_timeout_in_seconds is None and 'readTimeoutInSeconds' in kwargs:
            read_timeout_in_seconds = kwargs['readTimeoutInSeconds']
        if send_timeout_in_seconds is None and 'sendTimeoutInSeconds' in kwargs:
            send_timeout_in_seconds = kwargs['sendTimeoutInSeconds']
        if session_affinity is None and 'sessionAffinity' in kwargs:
            session_affinity = kwargs['sessionAffinity']
        if session_cookie_max_age is None and 'sessionCookieMaxAge' in kwargs:
            session_cookie_max_age = kwargs['sessionCookieMaxAge']

        if backend_protocol is not None:
            _setter("backend_protocol", backend_protocol)
        if client_auth is not None:
            _setter("client_auth", client_auth)
        if read_timeout_in_seconds is not None:
            _setter("read_timeout_in_seconds", read_timeout_in_seconds)
        if send_timeout_in_seconds is not None:
            _setter("send_timeout_in_seconds", send_timeout_in_seconds)
        if session_affinity is not None:
            _setter("session_affinity", session_affinity)
        if session_cookie_max_age is not None:
            _setter("session_cookie_max_age", session_cookie_max_age)

    @property
    @pulumi.getter(name="backendProtocol")
    def backend_protocol(self) -> Optional[pulumi.Input[Union[str, 'BackendProtocol']]]:
        """
        How ingress should communicate with this app backend service.
        """
        return pulumi.get(self, "backend_protocol")

    @backend_protocol.setter
    def backend_protocol(self, value: Optional[pulumi.Input[Union[str, 'BackendProtocol']]]):
        pulumi.set(self, "backend_protocol", value)

    @property
    @pulumi.getter(name="clientAuth")
    def client_auth(self) -> Optional[pulumi.Input['IngressSettingsClientAuthArgs']]:
        """
        Client-Certification Authentication.
        """
        return pulumi.get(self, "client_auth")

    @client_auth.setter
    def client_auth(self, value: Optional[pulumi.Input['IngressSettingsClientAuthArgs']]):
        pulumi.set(self, "client_auth", value)

    @property
    @pulumi.getter(name="readTimeoutInSeconds")
    def read_timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Ingress read time out in seconds.
        """
        return pulumi.get(self, "read_timeout_in_seconds")

    @read_timeout_in_seconds.setter
    def read_timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="sendTimeoutInSeconds")
    def send_timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Ingress send time out in seconds.
        """
        return pulumi.get(self, "send_timeout_in_seconds")

    @send_timeout_in_seconds.setter
    def send_timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "send_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[Union[str, 'SessionAffinity']]]:
        """
        Type of the affinity, set this to Cookie to enable session affinity.
        """
        return pulumi.get(self, "session_affinity")

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[Union[str, 'SessionAffinity']]]):
        pulumi.set(self, "session_affinity", value)

    @property
    @pulumi.getter(name="sessionCookieMaxAge")
    def session_cookie_max_age(self) -> Optional[pulumi.Input[int]]:
        """
        Time in seconds until the cookie expires.
        """
        return pulumi.get(self, "session_cookie_max_age")

    @session_cookie_max_age.setter
    def session_cookie_max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_cookie_max_age", value)


@pulumi.input_type
class JarUploadedUserSourceInfoArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 jvm_options: Optional[pulumi.Input[str]] = None,
                 relative_path: Optional[pulumi.Input[str]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Uploaded Jar binary for a deployment
        :param pulumi.Input[str] type: Type of the source uploaded
               Expected value is 'Jar'.
        :param pulumi.Input[str] jvm_options: JVM parameter
        :param pulumi.Input[str] relative_path: Relative path of the storage which stores the source
        :param pulumi.Input[str] runtime_version: Runtime version of the Jar file
        :param pulumi.Input[str] version: Version of the source
        """
        JarUploadedUserSourceInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            jvm_options=jvm_options,
            relative_path=relative_path,
            runtime_version=runtime_version,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             jvm_options: Optional[pulumi.Input[str]] = None,
             relative_path: Optional[pulumi.Input[str]] = None,
             runtime_version: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if jvm_options is None and 'jvmOptions' in kwargs:
            jvm_options = kwargs['jvmOptions']
        if relative_path is None and 'relativePath' in kwargs:
            relative_path = kwargs['relativePath']
        if runtime_version is None and 'runtimeVersion' in kwargs:
            runtime_version = kwargs['runtimeVersion']

        _setter("type", 'Jar')
        if jvm_options is not None:
            _setter("jvm_options", jvm_options)
        if relative_path is not None:
            _setter("relative_path", relative_path)
        if runtime_version is not None:
            _setter("runtime_version", runtime_version)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the source uploaded
        Expected value is 'Jar'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input[str]]:
        """
        JVM parameter
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[pulumi.Input[str]]:
        """
        Relative path of the storage which stores the source
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relative_path", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        Runtime version of the Jar file
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KeyVaultCertificatePropertiesArgs:
    def __init__(__self__, *,
                 key_vault_cert_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 vault_uri: pulumi.Input[str],
                 cert_version: Optional[pulumi.Input[str]] = None,
                 exclude_private_key: Optional[pulumi.Input[bool]] = None):
        """
        Properties of certificate imported from key vault.
        :param pulumi.Input[str] key_vault_cert_name: The certificate name of key vault.
        :param pulumi.Input[str] type: The type of the certificate source.
               Expected value is 'KeyVaultCertificate'.
        :param pulumi.Input[str] vault_uri: The vault uri of user key vault.
        :param pulumi.Input[str] cert_version: The certificate version of key vault.
        :param pulumi.Input[bool] exclude_private_key: Optional. If set to true, it will not import private key from key vault.
        """
        KeyVaultCertificatePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_vault_cert_name=key_vault_cert_name,
            type=type,
            vault_uri=vault_uri,
            cert_version=cert_version,
            exclude_private_key=exclude_private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_vault_cert_name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             vault_uri: Optional[pulumi.Input[str]] = None,
             cert_version: Optional[pulumi.Input[str]] = None,
             exclude_private_key: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_vault_cert_name is None and 'keyVaultCertName' in kwargs:
            key_vault_cert_name = kwargs['keyVaultCertName']
        if key_vault_cert_name is None:
            raise TypeError("Missing 'key_vault_cert_name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if vault_uri is None and 'vaultUri' in kwargs:
            vault_uri = kwargs['vaultUri']
        if vault_uri is None:
            raise TypeError("Missing 'vault_uri' argument")
        if cert_version is None and 'certVersion' in kwargs:
            cert_version = kwargs['certVersion']
        if exclude_private_key is None and 'excludePrivateKey' in kwargs:
            exclude_private_key = kwargs['excludePrivateKey']

        _setter("key_vault_cert_name", key_vault_cert_name)
        _setter("type", 'KeyVaultCertificate')
        _setter("vault_uri", vault_uri)
        if cert_version is not None:
            _setter("cert_version", cert_version)
        if exclude_private_key is None:
            exclude_private_key = False
        if exclude_private_key is not None:
            _setter("exclude_private_key", exclude_private_key)

    @property
    @pulumi.getter(name="keyVaultCertName")
    def key_vault_cert_name(self) -> pulumi.Input[str]:
        """
        The certificate name of key vault.
        """
        return pulumi.get(self, "key_vault_cert_name")

    @key_vault_cert_name.setter
    def key_vault_cert_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_cert_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the certificate source.
        Expected value is 'KeyVaultCertificate'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> pulumi.Input[str]:
        """
        The vault uri of user key vault.
        """
        return pulumi.get(self, "vault_uri")

    @vault_uri.setter
    def vault_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "vault_uri", value)

    @property
    @pulumi.getter(name="certVersion")
    def cert_version(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate version of key vault.
        """
        return pulumi.get(self, "cert_version")

    @cert_version.setter
    def cert_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cert_version", value)

    @property
    @pulumi.getter(name="excludePrivateKey")
    def exclude_private_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. If set to true, it will not import private key from key vault.
        """
        return pulumi.get(self, "exclude_private_key")

    @exclude_private_key.setter
    def exclude_private_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_private_key", value)


@pulumi.input_type
class LoadedCertificateArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 load_trust_store: Optional[pulumi.Input[bool]] = None):
        """
        Loaded certificate payload
        :param pulumi.Input[str] resource_id: Resource Id of loaded certificate
        :param pulumi.Input[bool] load_trust_store: Indicate whether the certificate will be loaded into default trust store, only work for Java runtime.
        """
        LoadedCertificateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_id=resource_id,
            load_trust_store=load_trust_store,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_id: Optional[pulumi.Input[str]] = None,
             load_trust_store: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")
        if load_trust_store is None and 'loadTrustStore' in kwargs:
            load_trust_store = kwargs['loadTrustStore']

        _setter("resource_id", resource_id)
        if load_trust_store is None:
            load_trust_store = False
        if load_trust_store is not None:
            _setter("load_trust_store", load_trust_store)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        Resource Id of loaded certificate
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="loadTrustStore")
    def load_trust_store(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate whether the certificate will be loaded into default trust store, only work for Java runtime.
        """
        return pulumi.get(self, "load_trust_store")

    @load_trust_store.setter
    def load_trust_store(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "load_trust_store", value)


@pulumi.input_type
class ManagedIdentityPropertiesArgs:
    def __init__(__self__, *,
                 principal_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'ManagedIdentityType']]] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed identity properties retrieved from ARM request headers.
        :param pulumi.Input[str] principal_id: Principal Id of system-assigned managed identity.
        :param pulumi.Input[str] tenant_id: Tenant Id of system-assigned managed identity.
        :param pulumi.Input[Union[str, 'ManagedIdentityType']] type: Type of the managed identity
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: Properties of user-assigned managed identities
        """
        ManagedIdentityPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[pulumi.Input[str]] = None,
             tenant_id: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[Union[str, 'ManagedIdentityType']]] = None,
             user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        if principal_id is not None:
            _setter("principal_id", principal_id)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        Principal Id of system-assigned managed identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Tenant Id of system-assigned managed identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'ManagedIdentityType']]]:
        """
        Type of the managed identity
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'ManagedIdentityType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Properties of user-assigned managed identities
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


@pulumi.input_type
class MarketplaceResourceArgs:
    def __init__(__self__, *,
                 plan: Optional[pulumi.Input[str]] = None,
                 product: Optional[pulumi.Input[str]] = None,
                 publisher: Optional[pulumi.Input[str]] = None):
        """
        Purchasing 3rd Party product for one Azure Spring Apps instance
        :param pulumi.Input[str] plan: The plan id of the 3rd Party Artifact that is being procured.
        :param pulumi.Input[str] product: The 3rd Party artifact that is being procured.
        :param pulumi.Input[str] publisher: The publisher id of the 3rd Party Artifact that is being bought.
        """
        MarketplaceResourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plan=plan,
            product=product,
            publisher=publisher,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plan: Optional[pulumi.Input[str]] = None,
             product: Optional[pulumi.Input[str]] = None,
             publisher: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if plan is not None:
            _setter("plan", plan)
        if product is not None:
            _setter("product", product)
        if publisher is not None:
            _setter("publisher", publisher)

    @property
    @pulumi.getter
    def plan(self) -> Optional[pulumi.Input[str]]:
        """
        The plan id of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[str]]:
        """
        The 3rd Party artifact that is being procured.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> Optional[pulumi.Input[str]]:
        """
        The publisher id of the 3rd Party Artifact that is being bought.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publisher", value)


@pulumi.input_type
class MonitoringSettingPropertiesArgs:
    def __init__(__self__, *,
                 app_insights_instrumentation_key: Optional[pulumi.Input[str]] = None,
                 app_insights_sampling_rate: Optional[pulumi.Input[float]] = None,
                 error: Optional[pulumi.Input['ErrorArgs']] = None,
                 trace_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Monitoring Setting properties payload
        :param pulumi.Input[str] app_insights_instrumentation_key: Target application insight instrumentation key, null or whitespace include empty will disable monitoringSettings
        :param pulumi.Input[float] app_insights_sampling_rate: Indicates the sampling rate of application insight agent, should be in range [0.0, 100.0]
        :param pulumi.Input['ErrorArgs'] error: Error when apply Monitoring Setting changes.
        :param pulumi.Input[bool] trace_enabled: Indicates whether enable the trace functionality, which will be deprecated since api version 2020-11-01-preview. Please leverage appInsightsInstrumentationKey to indicate if monitoringSettings enabled or not
        """
        MonitoringSettingPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_insights_instrumentation_key=app_insights_instrumentation_key,
            app_insights_sampling_rate=app_insights_sampling_rate,
            error=error,
            trace_enabled=trace_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_insights_instrumentation_key: Optional[pulumi.Input[str]] = None,
             app_insights_sampling_rate: Optional[pulumi.Input[float]] = None,
             error: Optional[pulumi.Input['ErrorArgs']] = None,
             trace_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_insights_instrumentation_key is None and 'appInsightsInstrumentationKey' in kwargs:
            app_insights_instrumentation_key = kwargs['appInsightsInstrumentationKey']
        if app_insights_sampling_rate is None and 'appInsightsSamplingRate' in kwargs:
            app_insights_sampling_rate = kwargs['appInsightsSamplingRate']
        if trace_enabled is None and 'traceEnabled' in kwargs:
            trace_enabled = kwargs['traceEnabled']

        if app_insights_instrumentation_key is not None:
            _setter("app_insights_instrumentation_key", app_insights_instrumentation_key)
        if app_insights_sampling_rate is not None:
            _setter("app_insights_sampling_rate", app_insights_sampling_rate)
        if error is not None:
            _setter("error", error)
        if trace_enabled is not None:
            _setter("trace_enabled", trace_enabled)

    @property
    @pulumi.getter(name="appInsightsInstrumentationKey")
    def app_insights_instrumentation_key(self) -> Optional[pulumi.Input[str]]:
        """
        Target application insight instrumentation key, null or whitespace include empty will disable monitoringSettings
        """
        return pulumi.get(self, "app_insights_instrumentation_key")

    @app_insights_instrumentation_key.setter
    def app_insights_instrumentation_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_insights_instrumentation_key", value)

    @property
    @pulumi.getter(name="appInsightsSamplingRate")
    def app_insights_sampling_rate(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the sampling rate of application insight agent, should be in range [0.0, 100.0]
        """
        return pulumi.get(self, "app_insights_sampling_rate")

    @app_insights_sampling_rate.setter
    def app_insights_sampling_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "app_insights_sampling_rate", value)

    @property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['ErrorArgs']]:
        """
        Error when apply Monitoring Setting changes.
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['ErrorArgs']]):
        pulumi.set(self, "error", value)

    @property
    @pulumi.getter(name="traceEnabled")
    def trace_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether enable the trace functionality, which will be deprecated since api version 2020-11-01-preview. Please leverage appInsightsInstrumentationKey to indicate if monitoringSettings enabled or not
        """
        return pulumi.get(self, "trace_enabled")

    @trace_enabled.setter
    def trace_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trace_enabled", value)


@pulumi.input_type
class NetCoreZipUploadedUserSourceInfoArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 net_core_main_entry_path: Optional[pulumi.Input[str]] = None,
                 relative_path: Optional[pulumi.Input[str]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Uploaded Jar binary for a deployment
        :param pulumi.Input[str] type: Type of the source uploaded
               Expected value is 'NetCoreZip'.
        :param pulumi.Input[str] net_core_main_entry_path: The path to the .NET executable relative to zip root
        :param pulumi.Input[str] relative_path: Relative path of the storage which stores the source
        :param pulumi.Input[str] runtime_version: Runtime version of the .Net file
        :param pulumi.Input[str] version: Version of the source
        """
        NetCoreZipUploadedUserSourceInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            net_core_main_entry_path=net_core_main_entry_path,
            relative_path=relative_path,
            runtime_version=runtime_version,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             net_core_main_entry_path: Optional[pulumi.Input[str]] = None,
             relative_path: Optional[pulumi.Input[str]] = None,
             runtime_version: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if net_core_main_entry_path is None and 'netCoreMainEntryPath' in kwargs:
            net_core_main_entry_path = kwargs['netCoreMainEntryPath']
        if relative_path is None and 'relativePath' in kwargs:
            relative_path = kwargs['relativePath']
        if runtime_version is None and 'runtimeVersion' in kwargs:
            runtime_version = kwargs['runtimeVersion']

        _setter("type", 'NetCoreZip')
        if net_core_main_entry_path is not None:
            _setter("net_core_main_entry_path", net_core_main_entry_path)
        if relative_path is not None:
            _setter("relative_path", relative_path)
        if runtime_version is not None:
            _setter("runtime_version", runtime_version)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the source uploaded
        Expected value is 'NetCoreZip'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="netCoreMainEntryPath")
    def net_core_main_entry_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the .NET executable relative to zip root
        """
        return pulumi.get(self, "net_core_main_entry_path")

    @net_core_main_entry_path.setter
    def net_core_main_entry_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "net_core_main_entry_path", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[pulumi.Input[str]]:
        """
        Relative path of the storage which stores the source
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relative_path", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        Runtime version of the .Net file
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class NetworkProfileArgs:
    def __init__(__self__, *,
                 app_network_resource_group: Optional[pulumi.Input[str]] = None,
                 app_subnet_id: Optional[pulumi.Input[str]] = None,
                 ingress_config: Optional[pulumi.Input['IngressConfigArgs']] = None,
                 outbound_type: Optional[pulumi.Input[str]] = None,
                 service_cidr: Optional[pulumi.Input[str]] = None,
                 service_runtime_network_resource_group: Optional[pulumi.Input[str]] = None,
                 service_runtime_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        Service network profile payload
        :param pulumi.Input[str] app_network_resource_group: Name of the resource group containing network resources for customer apps in Azure Spring Apps
        :param pulumi.Input[str] app_subnet_id: Fully qualified resource Id of the subnet to host customer apps in Azure Spring Apps
        :param pulumi.Input['IngressConfigArgs'] ingress_config: Ingress configuration payload for Azure Spring Apps resource.
        :param pulumi.Input[str] outbound_type: The egress traffic type of Azure Spring Apps VNet instances.
        :param pulumi.Input[str] service_cidr: Azure Spring Apps service reserved CIDR
        :param pulumi.Input[str] service_runtime_network_resource_group: Name of the resource group containing network resources of Azure Spring Apps Service Runtime
        :param pulumi.Input[str] service_runtime_subnet_id: Fully qualified resource Id of the subnet to host Azure Spring Apps Service Runtime
        """
        NetworkProfileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_network_resource_group=app_network_resource_group,
            app_subnet_id=app_subnet_id,
            ingress_config=ingress_config,
            outbound_type=outbound_type,
            service_cidr=service_cidr,
            service_runtime_network_resource_group=service_runtime_network_resource_group,
            service_runtime_subnet_id=service_runtime_subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_network_resource_group: Optional[pulumi.Input[str]] = None,
             app_subnet_id: Optional[pulumi.Input[str]] = None,
             ingress_config: Optional[pulumi.Input['IngressConfigArgs']] = None,
             outbound_type: Optional[pulumi.Input[str]] = None,
             service_cidr: Optional[pulumi.Input[str]] = None,
             service_runtime_network_resource_group: Optional[pulumi.Input[str]] = None,
             service_runtime_subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if app_network_resource_group is None and 'appNetworkResourceGroup' in kwargs:
            app_network_resource_group = kwargs['appNetworkResourceGroup']
        if app_subnet_id is None and 'appSubnetId' in kwargs:
            app_subnet_id = kwargs['appSubnetId']
        if ingress_config is None and 'ingressConfig' in kwargs:
            ingress_config = kwargs['ingressConfig']
        if outbound_type is None and 'outboundType' in kwargs:
            outbound_type = kwargs['outboundType']
        if service_cidr is None and 'serviceCidr' in kwargs:
            service_cidr = kwargs['serviceCidr']
        if service_runtime_network_resource_group is None and 'serviceRuntimeNetworkResourceGroup' in kwargs:
            service_runtime_network_resource_group = kwargs['serviceRuntimeNetworkResourceGroup']
        if service_runtime_subnet_id is None and 'serviceRuntimeSubnetId' in kwargs:
            service_runtime_subnet_id = kwargs['serviceRuntimeSubnetId']

        if app_network_resource_group is not None:
            _setter("app_network_resource_group", app_network_resource_group)
        if app_subnet_id is not None:
            _setter("app_subnet_id", app_subnet_id)
        if ingress_config is not None:
            _setter("ingress_config", ingress_config)
        if outbound_type is not None:
            _setter("outbound_type", outbound_type)
        if service_cidr is not None:
            _setter("service_cidr", service_cidr)
        if service_runtime_network_resource_group is not None:
            _setter("service_runtime_network_resource_group", service_runtime_network_resource_group)
        if service_runtime_subnet_id is not None:
            _setter("service_runtime_subnet_id", service_runtime_subnet_id)

    @property
    @pulumi.getter(name="appNetworkResourceGroup")
    def app_network_resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the resource group containing network resources for customer apps in Azure Spring Apps
        """
        return pulumi.get(self, "app_network_resource_group")

    @app_network_resource_group.setter
    def app_network_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_network_resource_group", value)

    @property
    @pulumi.getter(name="appSubnetId")
    def app_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified resource Id of the subnet to host customer apps in Azure Spring Apps
        """
        return pulumi.get(self, "app_subnet_id")

    @app_subnet_id.setter
    def app_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_subnet_id", value)

    @property
    @pulumi.getter(name="ingressConfig")
    def ingress_config(self) -> Optional[pulumi.Input['IngressConfigArgs']]:
        """
        Ingress configuration payload for Azure Spring Apps resource.
        """
        return pulumi.get(self, "ingress_config")

    @ingress_config.setter
    def ingress_config(self, value: Optional[pulumi.Input['IngressConfigArgs']]):
        pulumi.set(self, "ingress_config", value)

    @property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[pulumi.Input[str]]:
        """
        The egress traffic type of Azure Spring Apps VNet instances.
        """
        return pulumi.get(self, "outbound_type")

    @outbound_type.setter
    def outbound_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outbound_type", value)

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Spring Apps service reserved CIDR
        """
        return pulumi.get(self, "service_cidr")

    @service_cidr.setter
    def service_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cidr", value)

    @property
    @pulumi.getter(name="serviceRuntimeNetworkResourceGroup")
    def service_runtime_network_resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the resource group containing network resources of Azure Spring Apps Service Runtime
        """
        return pulumi.get(self, "service_runtime_network_resource_group")

    @service_runtime_network_resource_group.setter
    def service_runtime_network_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_runtime_network_resource_group", value)

    @property
    @pulumi.getter(name="serviceRuntimeSubnetId")
    def service_runtime_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified resource Id of the subnet to host Azure Spring Apps Service Runtime
        """
        return pulumi.get(self, "service_runtime_subnet_id")

    @service_runtime_subnet_id.setter
    def service_runtime_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_runtime_subnet_id", value)


@pulumi.input_type
class PersistentDiskArgs:
    def __init__(__self__, *,
                 mount_path: Optional[pulumi.Input[str]] = None,
                 size_in_gb: Optional[pulumi.Input[int]] = None):
        """
        Persistent disk payload
        :param pulumi.Input[str] mount_path: Mount path of the persistent disk
        :param pulumi.Input[int] size_in_gb: Size of the persistent disk in GB
        """
        PersistentDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_path=mount_path,
            size_in_gb=size_in_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_path: Optional[pulumi.Input[str]] = None,
             size_in_gb: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_path is None and 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if size_in_gb is None and 'sizeInGB' in kwargs:
            size_in_gb = kwargs['sizeInGB']

        if mount_path is not None:
            _setter("mount_path", mount_path)
        if size_in_gb is not None:
            _setter("size_in_gb", size_in_gb)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        Mount path of the persistent disk
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="sizeInGB")
    def size_in_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the persistent disk in GB
        """
        return pulumi.get(self, "size_in_gb")

    @size_in_gb.setter
    def size_in_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_in_gb", value)


@pulumi.input_type
class ProbeArgs:
    def __init__(__self__, *,
                 disable_probe: Optional[pulumi.Input[bool]] = None,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 probe_action: Optional[pulumi.Input[Union['ExecActionArgs', 'HTTPGetActionArgs', 'TCPSocketActionArgs']]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Probe describes a health check to be performed against an App Instance to determine whether it is alive or ready to receive traffic.
        :param pulumi.Input[bool] disable_probe: Indicate whether the probe is disabled.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: Number of seconds after the App Instance has started before probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Minimum value is 1.
        :param pulumi.Input[Union['ExecActionArgs', 'HTTPGetActionArgs', 'TCPSocketActionArgs']] probe_action: The action of the probe.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Must be 1 for liveness and startup. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: Number of seconds after which the probe times out. Minimum value is 1.
        """
        ProbeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_probe=disable_probe,
            failure_threshold=failure_threshold,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            probe_action=probe_action,
            success_threshold=success_threshold,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_probe: Optional[pulumi.Input[bool]] = None,
             failure_threshold: Optional[pulumi.Input[int]] = None,
             initial_delay_seconds: Optional[pulumi.Input[int]] = None,
             period_seconds: Optional[pulumi.Input[int]] = None,
             probe_action: Optional[pulumi.Input[Union['ExecActionArgs', 'HTTPGetActionArgs', 'TCPSocketActionArgs']]] = None,
             success_threshold: Optional[pulumi.Input[int]] = None,
             timeout_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if disable_probe is None and 'disableProbe' in kwargs:
            disable_probe = kwargs['disableProbe']
        if failure_threshold is None and 'failureThreshold' in kwargs:
            failure_threshold = kwargs['failureThreshold']
        if initial_delay_seconds is None and 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if period_seconds is None and 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if probe_action is None and 'probeAction' in kwargs:
            probe_action = kwargs['probeAction']
        if success_threshold is None and 'successThreshold' in kwargs:
            success_threshold = kwargs['successThreshold']
        if timeout_seconds is None and 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if disable_probe is None:
            disable_probe = False
        _setter("disable_probe", disable_probe)
        if failure_threshold is not None:
            _setter("failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if probe_action is not None:
            _setter("probe_action", probe_action)
        if success_threshold is not None:
            _setter("success_threshold", success_threshold)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="disableProbe")
    def disable_probe(self) -> pulumi.Input[bool]:
        """
        Indicate whether the probe is disabled.
        """
        return pulumi.get(self, "disable_probe")

    @disable_probe.setter
    def disable_probe(self, value: pulumi.Input[bool]):
        pulumi.set(self, "disable_probe", value)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after the App Instance has started before probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="probeAction")
    def probe_action(self) -> Optional[pulumi.Input[Union['ExecActionArgs', 'HTTPGetActionArgs', 'TCPSocketActionArgs']]]:
        """
        The action of the probe.
        """
        return pulumi.get(self, "probe_action")

    @probe_action.setter
    def probe_action(self, value: Optional[pulumi.Input[Union['ExecActionArgs', 'HTTPGetActionArgs', 'TCPSocketActionArgs']]]):
        pulumi.set(self, "probe_action", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Must be 1 for liveness and startup. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after which the probe times out. Minimum value is 1.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class QueueScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 queue_length: Optional[pulumi.Input[int]] = None,
                 queue_name: Optional[pulumi.Input[str]] = None):
        """
        Azure Spring Apps App Instance Azure Queue based scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the queue scale rule.
        :param pulumi.Input[int] queue_length: Queue length.
        :param pulumi.Input[str] queue_name: Queue name.
        """
        QueueScaleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth=auth,
            queue_length=queue_length,
            queue_name=queue_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
             queue_length: Optional[pulumi.Input[int]] = None,
             queue_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if queue_length is None and 'queueLength' in kwargs:
            queue_length = kwargs['queueLength']
        if queue_name is None and 'queueName' in kwargs:
            queue_name = kwargs['queueName']

        if auth is not None:
            _setter("auth", auth)
        if queue_length is not None:
            _setter("queue_length", queue_length)
        if queue_name is not None:
            _setter("queue_name", queue_name)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the queue scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="queueLength")
    def queue_length(self) -> Optional[pulumi.Input[int]]:
        """
        Queue length.
        """
        return pulumi.get(self, "queue_length")

    @queue_length.setter
    def queue_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queue_length", value)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[str]]:
        """
        Queue name.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_name", value)


@pulumi.input_type
class ResourceRequestsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[str]] = None,
                 memory: Optional[pulumi.Input[str]] = None):
        """
        Deployment resource request payload
        :param pulumi.Input[str] cpu: Required CPU. 1 core can be represented by 1 or 1000m. This should be 500m or 1 for Basic tier, and {500m, 1, 2, 3, 4} for Standard tier.
        :param pulumi.Input[str] memory: Required memory. 1 GB can be represented by 1Gi or 1024Mi. This should be {512Mi, 1Gi, 2Gi} for Basic tier, and {512Mi, 1Gi, 2Gi, ..., 8Gi} for Standard tier.
        """
        ResourceRequestsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            memory=memory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: Optional[pulumi.Input[str]] = None,
             memory: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if cpu is not None:
            _setter("cpu", cpu)
        if memory is not None:
            _setter("memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Required CPU. 1 core can be represented by 1 or 1000m. This should be 500m or 1 for Basic tier, and {500m, 1, 2, 3, 4} for Standard tier.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[str]]:
        """
        Required memory. 1 GB can be represented by 1Gi or 1024Mi. This should be {512Mi, 1Gi, 2Gi} for Basic tier, and {512Mi, 1Gi, 2Gi, ..., 8Gi} for Standard tier.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory", value)


@pulumi.input_type
class ScaleRuleAuthArgs:
    def __init__(__self__, *,
                 secret_ref: Optional[pulumi.Input[str]] = None,
                 trigger_parameter: Optional[pulumi.Input[str]] = None):
        """
        Auth Secrets for Azure Spring Apps App Instance Scale Rule
        :param pulumi.Input[str] secret_ref: Name of the Azure Spring Apps App Instance secret from which to pull the auth params.
        :param pulumi.Input[str] trigger_parameter: Trigger Parameter that uses the secret
        """
        ScaleRuleAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_ref=secret_ref,
            trigger_parameter=trigger_parameter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_ref: Optional[pulumi.Input[str]] = None,
             trigger_parameter: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_ref is None and 'secretRef' in kwargs:
            secret_ref = kwargs['secretRef']
        if trigger_parameter is None and 'triggerParameter' in kwargs:
            trigger_parameter = kwargs['triggerParameter']

        if secret_ref is not None:
            _setter("secret_ref", secret_ref)
        if trigger_parameter is not None:
            _setter("trigger_parameter", trigger_parameter)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Azure Spring Apps App Instance secret from which to pull the auth params.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter(name="triggerParameter")
    def trigger_parameter(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger Parameter that uses the secret
        """
        return pulumi.get(self, "trigger_parameter")

    @trigger_parameter.setter
    def trigger_parameter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_parameter", value)


@pulumi.input_type
class ScaleRuleArgs:
    def __init__(__self__, *,
                 azure_queue: Optional[pulumi.Input['QueueScaleRuleArgs']] = None,
                 custom: Optional[pulumi.Input['CustomScaleRuleArgs']] = None,
                 http: Optional[pulumi.Input['HttpScaleRuleArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 tcp: Optional[pulumi.Input['TcpScaleRuleArgs']] = None):
        """
        Azure Spring Apps App Instance scaling rule.
        :param pulumi.Input['QueueScaleRuleArgs'] azure_queue: Azure Queue based scaling.
        :param pulumi.Input['CustomScaleRuleArgs'] custom: Custom scale rule.
        :param pulumi.Input['HttpScaleRuleArgs'] http: HTTP requests based scaling.
        :param pulumi.Input[str] name: Scale Rule Name
        :param pulumi.Input['TcpScaleRuleArgs'] tcp: Tcp requests based scaling.
        """
        ScaleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_queue=azure_queue,
            custom=custom,
            http=http,
            name=name,
            tcp=tcp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_queue: Optional[pulumi.Input['QueueScaleRuleArgs']] = None,
             custom: Optional[pulumi.Input['CustomScaleRuleArgs']] = None,
             http: Optional[pulumi.Input['HttpScaleRuleArgs']] = None,
             name: Optional[pulumi.Input[str]] = None,
             tcp: Optional[pulumi.Input['TcpScaleRuleArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_queue is None and 'azureQueue' in kwargs:
            azure_queue = kwargs['azureQueue']

        if azure_queue is not None:
            _setter("azure_queue", azure_queue)
        if custom is not None:
            _setter("custom", custom)
        if http is not None:
            _setter("http", http)
        if name is not None:
            _setter("name", name)
        if tcp is not None:
            _setter("tcp", tcp)

    @property
    @pulumi.getter(name="azureQueue")
    def azure_queue(self) -> Optional[pulumi.Input['QueueScaleRuleArgs']]:
        """
        Azure Queue based scaling.
        """
        return pulumi.get(self, "azure_queue")

    @azure_queue.setter
    def azure_queue(self, value: Optional[pulumi.Input['QueueScaleRuleArgs']]):
        pulumi.set(self, "azure_queue", value)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input['CustomScaleRuleArgs']]:
        """
        Custom scale rule.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input['CustomScaleRuleArgs']]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['HttpScaleRuleArgs']]:
        """
        HTTP requests based scaling.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['HttpScaleRuleArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Scale Rule Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['TcpScaleRuleArgs']]:
        """
        Tcp requests based scaling.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['TcpScaleRuleArgs']]):
        pulumi.set(self, "tcp", value)


@pulumi.input_type
class ScaleArgs:
    def __init__(__self__, *,
                 max_replicas: Optional[pulumi.Input[int]] = None,
                 min_replicas: Optional[pulumi.Input[int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]] = None):
        """
        Azure Spring Apps scaling configurations.
        :param pulumi.Input[int] max_replicas: Optional. Maximum number of container replicas. Defaults to 10 if not set.
        :param pulumi.Input[int] min_replicas: Optional. Minimum number of container replicas.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]] rules: Scaling rules.
        """
        ScaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_replicas=max_replicas,
            min_replicas=min_replicas,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_replicas: Optional[pulumi.Input[int]] = None,
             min_replicas: Optional[pulumi.Input[int]] = None,
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_replicas is None and 'maxReplicas' in kwargs:
            max_replicas = kwargs['maxReplicas']
        if min_replicas is None and 'minReplicas' in kwargs:
            min_replicas = kwargs['minReplicas']

        if max_replicas is None:
            max_replicas = 10
        if max_replicas is not None:
            _setter("max_replicas", max_replicas)
        if min_replicas is not None:
            _setter("min_replicas", min_replicas)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Maximum number of container replicas. Defaults to 10 if not set.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Minimum number of container replicas.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_replicas", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]]:
        """
        Scaling rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class SecretArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Secret definition.
        :param pulumi.Input[str] name: Secret Name.
        :param pulumi.Input[str] value: Secret Value.
        """
        SecretArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Secret Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServiceVNetAddonsArgs:
    def __init__(__self__, *,
                 data_plane_public_endpoint: Optional[pulumi.Input[bool]] = None,
                 log_stream_public_endpoint: Optional[pulumi.Input[bool]] = None):
        """
        Additional Service settings in vnet injection instance
        :param pulumi.Input[bool] data_plane_public_endpoint: Indicates whether the data plane components(log stream, app connect, remote debugging) in vnet injection instance could be accessed from internet.
        :param pulumi.Input[bool] log_stream_public_endpoint: Indicates whether the log stream in vnet injection instance could be accessed from internet.
        """
        ServiceVNetAddonsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_plane_public_endpoint=data_plane_public_endpoint,
            log_stream_public_endpoint=log_stream_public_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_plane_public_endpoint: Optional[pulumi.Input[bool]] = None,
             log_stream_public_endpoint: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_plane_public_endpoint is None and 'dataPlanePublicEndpoint' in kwargs:
            data_plane_public_endpoint = kwargs['dataPlanePublicEndpoint']
        if log_stream_public_endpoint is None and 'logStreamPublicEndpoint' in kwargs:
            log_stream_public_endpoint = kwargs['logStreamPublicEndpoint']

        if data_plane_public_endpoint is None:
            data_plane_public_endpoint = False
        if data_plane_public_endpoint is not None:
            _setter("data_plane_public_endpoint", data_plane_public_endpoint)
        if log_stream_public_endpoint is None:
            log_stream_public_endpoint = False
        if log_stream_public_endpoint is not None:
            _setter("log_stream_public_endpoint", log_stream_public_endpoint)

    @property
    @pulumi.getter(name="dataPlanePublicEndpoint")
    def data_plane_public_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the data plane components(log stream, app connect, remote debugging) in vnet injection instance could be accessed from internet.
        """
        return pulumi.get(self, "data_plane_public_endpoint")

    @data_plane_public_endpoint.setter
    def data_plane_public_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "data_plane_public_endpoint", value)

    @property
    @pulumi.getter(name="logStreamPublicEndpoint")
    def log_stream_public_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the log stream in vnet injection instance could be accessed from internet.
        """
        return pulumi.get(self, "log_stream_public_endpoint")

    @log_stream_public_endpoint.setter
    def log_stream_public_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "log_stream_public_endpoint", value)


@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 capacity: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 tier: Optional[pulumi.Input[str]] = None):
        """
        Sku of Azure Spring Apps
        :param pulumi.Input[int] capacity: Current capacity of the target resource
        :param pulumi.Input[str] name: Name of the Sku
        :param pulumi.Input[str] tier: Tier of the Sku
        """
        SkuArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity=capacity,
            name=name,
            tier=tier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity: Optional[pulumi.Input[int]] = None,
             name: Optional[pulumi.Input[str]] = None,
             tier: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if capacity is not None:
            _setter("capacity", capacity)
        if name is None:
            name = 'S0'
        if name is not None:
            _setter("name", name)
        if tier is None:
            tier = 'Standard'
        if tier is not None:
            _setter("tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Current capacity of the target resource
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Sku
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        Tier of the Sku
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)


@pulumi.input_type
class SourceUploadedUserSourceInfoArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 artifact_selector: Optional[pulumi.Input[str]] = None,
                 relative_path: Optional[pulumi.Input[str]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Uploaded Java source code binary for a deployment
        :param pulumi.Input[str] type: Type of the source uploaded
               Expected value is 'Source'.
        :param pulumi.Input[str] artifact_selector: Selector for the artifact to be used for the deployment for multi-module projects. This should be
               the relative path to the target module/project.
        :param pulumi.Input[str] relative_path: Relative path of the storage which stores the source
        :param pulumi.Input[str] runtime_version: Runtime version of the source file
        :param pulumi.Input[str] version: Version of the source
        """
        SourceUploadedUserSourceInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            artifact_selector=artifact_selector,
            relative_path=relative_path,
            runtime_version=runtime_version,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             artifact_selector: Optional[pulumi.Input[str]] = None,
             relative_path: Optional[pulumi.Input[str]] = None,
             runtime_version: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if artifact_selector is None and 'artifactSelector' in kwargs:
            artifact_selector = kwargs['artifactSelector']
        if relative_path is None and 'relativePath' in kwargs:
            relative_path = kwargs['relativePath']
        if runtime_version is None and 'runtimeVersion' in kwargs:
            runtime_version = kwargs['runtimeVersion']

        _setter("type", 'Source')
        if artifact_selector is not None:
            _setter("artifact_selector", artifact_selector)
        if relative_path is not None:
            _setter("relative_path", relative_path)
        if runtime_version is not None:
            _setter("runtime_version", runtime_version)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the source uploaded
        Expected value is 'Source'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="artifactSelector")
    def artifact_selector(self) -> Optional[pulumi.Input[str]]:
        """
        Selector for the artifact to be used for the deployment for multi-module projects. This should be
        the relative path to the target module/project.
        """
        return pulumi.get(self, "artifact_selector")

    @artifact_selector.setter
    def artifact_selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_selector", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[pulumi.Input[str]]:
        """
        Relative path of the storage which stores the source
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relative_path", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        Runtime version of the source file
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class SsoPropertiesArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 issuer_uri: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Single sign-on related configuration
        :param pulumi.Input[str] client_id: The public identifier for the application
        :param pulumi.Input[str] client_secret: The secret known only to the application and the authorization server
        :param pulumi.Input[str] issuer_uri: The URI of Issuer Identifier
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scope: It defines the specific actions applications can be allowed to do on a user's behalf
        """
        SsoPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret=client_secret,
            issuer_uri=issuer_uri,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret: Optional[pulumi.Input[str]] = None,
             issuer_uri: Optional[pulumi.Input[str]] = None,
             scope: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if issuer_uri is None and 'issuerUri' in kwargs:
            issuer_uri = kwargs['issuerUri']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret is not None:
            _setter("client_secret", client_secret)
        if issuer_uri is not None:
            _setter("issuer_uri", issuer_uri)
        if scope is not None:
            _setter("scope", scope)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The public identifier for the application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The secret known only to the application and the authorization server
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="issuerUri")
    def issuer_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of Issuer Identifier
        """
        return pulumi.get(self, "issuer_uri")

    @issuer_uri.setter
    def issuer_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_uri", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        It defines the specific actions applications can be allowed to do on a user's behalf
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class StackPropertiesArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        KPack ClusterStack properties payload
        :param pulumi.Input[str] id: Id of the ClusterStack.
        :param pulumi.Input[str] version: Version of the ClusterStack
        """
        StackPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the ClusterStack.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the ClusterStack
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class StorageAccountArgs:
    def __init__(__self__, *,
                 account_key: pulumi.Input[str],
                 account_name: pulumi.Input[str],
                 storage_type: pulumi.Input[str]):
        """
        storage resource of type Azure Storage Account.
        :param pulumi.Input[str] account_key: The account key of the Azure Storage Account.
        :param pulumi.Input[str] account_name: The account name of the Azure Storage Account.
        :param pulumi.Input[str] storage_type: The type of the storage.
               Expected value is 'StorageAccount'.
        """
        StorageAccountArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_key=account_key,
            account_name=account_name,
            storage_type=storage_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_key: Optional[pulumi.Input[str]] = None,
             account_name: Optional[pulumi.Input[str]] = None,
             storage_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_key is None and 'accountKey' in kwargs:
            account_key = kwargs['accountKey']
        if account_key is None:
            raise TypeError("Missing 'account_key' argument")
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if account_name is None:
            raise TypeError("Missing 'account_name' argument")
        if storage_type is None and 'storageType' in kwargs:
            storage_type = kwargs['storageType']
        if storage_type is None:
            raise TypeError("Missing 'storage_type' argument")

        _setter("account_key", account_key)
        _setter("account_name", account_name)
        _setter("storage_type", 'StorageAccount')

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> pulumi.Input[str]:
        """
        The account key of the Azure Storage Account.
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[str]:
        """
        The account name of the Azure Storage Account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> pulumi.Input[str]:
        """
        The type of the storage.
        Expected value is 'StorageAccount'.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_type", value)


@pulumi.input_type
class TCPSocketActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        TCPSocketAction describes an action based on opening a socket
        :param pulumi.Input[str] type: The type of the action to take to perform the health check.
               Expected value is 'TCPSocketAction'.
        """
        TCPSocketActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", 'TCPSocketAction')

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the action to take to perform the health check.
        Expected value is 'TCPSocketAction'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class TcpScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Azure Spring Apps App Instance Tcp scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the tcp scale rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Metadata properties to describe tcp scale rule.
        """
        TcpScaleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth=auth,
            metadata=metadata,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
             metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if auth is not None:
            _setter("auth", auth)
        if metadata is not None:
            _setter("metadata", metadata)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the tcp scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Metadata properties to describe tcp scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class TemporaryDiskArgs:
    def __init__(__self__, *,
                 mount_path: Optional[pulumi.Input[str]] = None,
                 size_in_gb: Optional[pulumi.Input[int]] = None):
        """
        Temporary disk payload
        :param pulumi.Input[str] mount_path: Mount path of the temporary disk
        :param pulumi.Input[int] size_in_gb: Size of the temporary disk in GB
        """
        TemporaryDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_path=mount_path,
            size_in_gb=size_in_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_path: Optional[pulumi.Input[str]] = None,
             size_in_gb: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if mount_path is None and 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if size_in_gb is None and 'sizeInGB' in kwargs:
            size_in_gb = kwargs['sizeInGB']

        if mount_path is None:
            mount_path = '/tmp'
        if mount_path is not None:
            _setter("mount_path", mount_path)
        if size_in_gb is not None:
            _setter("size_in_gb", size_in_gb)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        Mount path of the temporary disk
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="sizeInGB")
    def size_in_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the temporary disk in GB
        """
        return pulumi.get(self, "size_in_gb")

    @size_in_gb.setter
    def size_in_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_in_gb", value)


@pulumi.input_type
class UploadedUserSourceInfoArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 relative_path: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Source with uploaded location
        :param pulumi.Input[str] type: Type of the source uploaded
               Expected value is 'UploadedUserSourceInfo'.
        :param pulumi.Input[str] relative_path: Relative path of the storage which stores the source
        :param pulumi.Input[str] version: Version of the source
        """
        UploadedUserSourceInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            relative_path=relative_path,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             relative_path: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if relative_path is None and 'relativePath' in kwargs:
            relative_path = kwargs['relativePath']

        _setter("type", 'UploadedUserSourceInfo')
        if relative_path is not None:
            _setter("relative_path", relative_path)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the source uploaded
        Expected value is 'UploadedUserSourceInfo'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[pulumi.Input[str]]:
        """
        Relative path of the storage which stores the source
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relative_path", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the source
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


