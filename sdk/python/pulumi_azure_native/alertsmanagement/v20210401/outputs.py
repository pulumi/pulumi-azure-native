# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActionGroupsInformationResponse',
    'DetectorParameterDefinitionResponse',
    'DetectorResponse',
    'ThrottlingInformationResponse',
]

@pulumi.output_type
class ActionGroupsInformationResponse(dict):
    """
    The Action Groups information, used by the alert rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "customEmailSubject":
            suggest = "custom_email_subject"
        elif key == "customWebhookPayload":
            suggest = "custom_webhook_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupsInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupsInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupsInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[str],
                 custom_email_subject: Optional[str] = None,
                 custom_webhook_payload: Optional[str] = None):
        """
        The Action Groups information, used by the alert rule.
        :param Sequence[str] group_ids: The Action Group resource IDs.
        :param str custom_email_subject: An optional custom email subject to use in email notifications.
        :param str custom_webhook_payload: An optional custom web-hook payload to use in web-hook notifications.
        """
        ActionGroupsInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_ids=group_ids,
            custom_email_subject=custom_email_subject,
            custom_webhook_payload=custom_webhook_payload,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_ids: Sequence[str],
             custom_email_subject: Optional[str] = None,
             custom_webhook_payload: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_ids", group_ids)
        if custom_email_subject is not None:
            _setter("custom_email_subject", custom_email_subject)
        if custom_webhook_payload is not None:
            _setter("custom_webhook_payload", custom_webhook_payload)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[str]:
        """
        The Action Group resource IDs.
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="customEmailSubject")
    def custom_email_subject(self) -> Optional[str]:
        """
        An optional custom email subject to use in email notifications.
        """
        return pulumi.get(self, "custom_email_subject")

    @property
    @pulumi.getter(name="customWebhookPayload")
    def custom_webhook_payload(self) -> Optional[str]:
        """
        An optional custom web-hook payload to use in web-hook notifications.
        """
        return pulumi.get(self, "custom_webhook_payload")


@pulumi.output_type
class DetectorParameterDefinitionResponse(dict):
    """
    The detector parameter definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "isMandatory":
            suggest = "is_mandatory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorParameterDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorParameterDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorParameterDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 is_mandatory: Optional[bool] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        The detector parameter definition.
        :param str description: The detector parameter description.
        :param str display_name: The detector parameter display name.
        :param bool is_mandatory: A value indicating whether this detector parameter is mandatory.
        :param str name: The detector parameter name.
        :param str type: The detector parameter type.
        """
        DetectorParameterDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            display_name=display_name,
            is_mandatory=is_mandatory,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             is_mandatory: Optional[bool] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if is_mandatory is not None:
            _setter("is_mandatory", is_mandatory)
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The detector parameter description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The detector parameter display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isMandatory")
    def is_mandatory(self) -> Optional[bool]:
        """
        A value indicating whether this detector parameter is mandatory.
        """
        return pulumi.get(self, "is_mandatory")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The detector parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The detector parameter type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DetectorResponse(dict):
    """
    The detector information. By default this is not populated, unless it's specified in expandDetector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imagePaths":
            suggest = "image_paths"
        elif key == "parameterDefinitions":
            suggest = "parameter_definitions"
        elif key == "supportedCadences":
            suggest = "supported_cadences"
        elif key == "supportedResourceTypes":
            suggest = "supported_resource_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 id: str,
                 image_paths: Sequence[str],
                 name: str,
                 parameter_definitions: Sequence['outputs.DetectorParameterDefinitionResponse'],
                 supported_cadences: Sequence[int],
                 supported_resource_types: Sequence[str],
                 parameters: Optional[Mapping[str, Any]] = None):
        """
        The detector information. By default this is not populated, unless it's specified in expandDetector
        :param str description: The Smart Detector description.
        :param str id: The detector id.
        :param Sequence[str] image_paths: The Smart Detector image path. By default this is not populated, unless it's specified in expandDetector
        :param str name: The Smart Detector name.
        :param Sequence['DetectorParameterDefinitionResponse'] parameter_definitions: The Smart Detector parameters definitions.'
        :param Sequence[int] supported_cadences: The Smart Detector supported cadences.
        :param Sequence[str] supported_resource_types: The Smart Detector supported resource types.
        :param Mapping[str, Any] parameters: The detector's parameters.'
        """
        DetectorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            image_paths=image_paths,
            name=name,
            parameter_definitions=parameter_definitions,
            supported_cadences=supported_cadences,
            supported_resource_types=supported_resource_types,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: str,
             id: str,
             image_paths: Sequence[str],
             name: str,
             parameter_definitions: Sequence['outputs.DetectorParameterDefinitionResponse'],
             supported_cadences: Sequence[int],
             supported_resource_types: Sequence[str],
             parameters: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("description", description)
        _setter("id", id)
        _setter("image_paths", image_paths)
        _setter("name", name)
        _setter("parameter_definitions", parameter_definitions)
        _setter("supported_cadences", supported_cadences)
        _setter("supported_resource_types", supported_resource_types)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The Smart Detector description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The detector id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imagePaths")
    def image_paths(self) -> Sequence[str]:
        """
        The Smart Detector image path. By default this is not populated, unless it's specified in expandDetector
        """
        return pulumi.get(self, "image_paths")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Smart Detector name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterDefinitions")
    def parameter_definitions(self) -> Sequence['outputs.DetectorParameterDefinitionResponse']:
        """
        The Smart Detector parameters definitions.'
        """
        return pulumi.get(self, "parameter_definitions")

    @property
    @pulumi.getter(name="supportedCadences")
    def supported_cadences(self) -> Sequence[int]:
        """
        The Smart Detector supported cadences.
        """
        return pulumi.get(self, "supported_cadences")

    @property
    @pulumi.getter(name="supportedResourceTypes")
    def supported_resource_types(self) -> Sequence[str]:
        """
        The Smart Detector supported resource types.
        """
        return pulumi.get(self, "supported_resource_types")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        """
        The detector's parameters.'
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class ThrottlingInformationResponse(dict):
    """
    Optional throttling information for the alert rule.
    """
    def __init__(__self__, *,
                 duration: Optional[str] = None):
        """
        Optional throttling information for the alert rule.
        :param str duration: The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value is 0 minutes
        """
        ThrottlingInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration=duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if duration is not None:
            _setter("duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value is 0 minutes
        """
        return pulumi.get(self, "duration")


