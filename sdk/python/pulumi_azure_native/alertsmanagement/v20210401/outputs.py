# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActionGroupsInformationResponse',
    'DetectorParameterDefinitionResponse',
    'DetectorResponse',
    'ThrottlingInformationResponse',
]

@pulumi.output_type
class ActionGroupsInformationResponse(dict):
    """
    The Action Groups information, used by the alert rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "customEmailSubject":
            suggest = "custom_email_subject"
        elif key == "customWebhookPayload":
            suggest = "custom_webhook_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupsInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupsInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupsInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[str],
                 custom_email_subject: Optional[str] = None,
                 custom_webhook_payload: Optional[str] = None):
        """
        The Action Groups information, used by the alert rule.
        :param Sequence[str] group_ids: The Action Group resource IDs.
        :param str custom_email_subject: An optional custom email subject to use in email notifications.
        :param str custom_webhook_payload: An optional custom web-hook payload to use in web-hook notifications.
        """
        ActionGroupsInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_ids=group_ids,
            custom_email_subject=custom_email_subject,
            custom_webhook_payload=custom_webhook_payload,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_ids: Optional[Sequence[str]] = None,
             custom_email_subject: Optional[str] = None,
             custom_webhook_payload: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_ids is None and 'groupIds' in kwargs:
            group_ids = kwargs['groupIds']
        if group_ids is None:
            raise TypeError("Missing 'group_ids' argument")
        if custom_email_subject is None and 'customEmailSubject' in kwargs:
            custom_email_subject = kwargs['customEmailSubject']
        if custom_webhook_payload is None and 'customWebhookPayload' in kwargs:
            custom_webhook_payload = kwargs['customWebhookPayload']

        _setter("group_ids", group_ids)
        if custom_email_subject is not None:
            _setter("custom_email_subject", custom_email_subject)
        if custom_webhook_payload is not None:
            _setter("custom_webhook_payload", custom_webhook_payload)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[str]:
        """
        The Action Group resource IDs.
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="customEmailSubject")
    def custom_email_subject(self) -> Optional[str]:
        """
        An optional custom email subject to use in email notifications.
        """
        return pulumi.get(self, "custom_email_subject")

    @property
    @pulumi.getter(name="customWebhookPayload")
    def custom_webhook_payload(self) -> Optional[str]:
        """
        An optional custom web-hook payload to use in web-hook notifications.
        """
        return pulumi.get(self, "custom_webhook_payload")


@pulumi.output_type
class DetectorParameterDefinitionResponse(dict):
    """
    The detector parameter definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "isMandatory":
            suggest = "is_mandatory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorParameterDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorParameterDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorParameterDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 is_mandatory: Optional[bool] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        The detector parameter definition.
        :param str description: The detector parameter description.
        :param str display_name: The detector parameter display name.
        :param bool is_mandatory: A value indicating whether this detector parameter is mandatory.
        :param str name: The detector parameter name.
        :param str type: The detector parameter type.
        """
        DetectorParameterDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            display_name=display_name,
            is_mandatory=is_mandatory,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             is_mandatory: Optional[bool] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if is_mandatory is None and 'isMandatory' in kwargs:
            is_mandatory = kwargs['isMandatory']

        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if is_mandatory is not None:
            _setter("is_mandatory", is_mandatory)
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The detector parameter description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The detector parameter display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isMandatory")
    def is_mandatory(self) -> Optional[bool]:
        """
        A value indicating whether this detector parameter is mandatory.
        """
        return pulumi.get(self, "is_mandatory")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The detector parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The detector parameter type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DetectorResponse(dict):
    """
    The detector information. By default this is not populated, unless it's specified in expandDetector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imagePaths":
            suggest = "image_paths"
        elif key == "parameterDefinitions":
            suggest = "parameter_definitions"
        elif key == "supportedCadences":
            suggest = "supported_cadences"
        elif key == "supportedResourceTypes":
            suggest = "supported_resource_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 id: str,
                 image_paths: Sequence[str],
                 name: str,
                 parameter_definitions: Sequence['outputs.DetectorParameterDefinitionResponse'],
                 supported_cadences: Sequence[int],
                 supported_resource_types: Sequence[str],
                 parameters: Optional[Mapping[str, Any]] = None):
        """
        The detector information. By default this is not populated, unless it's specified in expandDetector
        :param str description: The Smart Detector description.
        :param str id: The detector id.
        :param Sequence[str] image_paths: The Smart Detector image path. By default this is not populated, unless it's specified in expandDetector
        :param str name: The Smart Detector name.
        :param Sequence['DetectorParameterDefinitionResponse'] parameter_definitions: The Smart Detector parameters definitions.'
        :param Sequence[int] supported_cadences: The Smart Detector supported cadences.
        :param Sequence[str] supported_resource_types: The Smart Detector supported resource types.
        :param Mapping[str, Any] parameters: The detector's parameters.'
        """
        DetectorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            image_paths=image_paths,
            name=name,
            parameter_definitions=parameter_definitions,
            supported_cadences=supported_cadences,
            supported_resource_types=supported_resource_types,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             id: Optional[str] = None,
             image_paths: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             parameter_definitions: Optional[Sequence['outputs.DetectorParameterDefinitionResponse']] = None,
             supported_cadences: Optional[Sequence[int]] = None,
             supported_resource_types: Optional[Sequence[str]] = None,
             parameters: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_paths is None and 'imagePaths' in kwargs:
            image_paths = kwargs['imagePaths']
        if image_paths is None:
            raise TypeError("Missing 'image_paths' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameter_definitions is None and 'parameterDefinitions' in kwargs:
            parameter_definitions = kwargs['parameterDefinitions']
        if parameter_definitions is None:
            raise TypeError("Missing 'parameter_definitions' argument")
        if supported_cadences is None and 'supportedCadences' in kwargs:
            supported_cadences = kwargs['supportedCadences']
        if supported_cadences is None:
            raise TypeError("Missing 'supported_cadences' argument")
        if supported_resource_types is None and 'supportedResourceTypes' in kwargs:
            supported_resource_types = kwargs['supportedResourceTypes']
        if supported_resource_types is None:
            raise TypeError("Missing 'supported_resource_types' argument")

        _setter("description", description)
        _setter("id", id)
        _setter("image_paths", image_paths)
        _setter("name", name)
        _setter("parameter_definitions", parameter_definitions)
        _setter("supported_cadences", supported_cadences)
        _setter("supported_resource_types", supported_resource_types)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The Smart Detector description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The detector id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imagePaths")
    def image_paths(self) -> Sequence[str]:
        """
        The Smart Detector image path. By default this is not populated, unless it's specified in expandDetector
        """
        return pulumi.get(self, "image_paths")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Smart Detector name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterDefinitions")
    def parameter_definitions(self) -> Sequence['outputs.DetectorParameterDefinitionResponse']:
        """
        The Smart Detector parameters definitions.'
        """
        return pulumi.get(self, "parameter_definitions")

    @property
    @pulumi.getter(name="supportedCadences")
    def supported_cadences(self) -> Sequence[int]:
        """
        The Smart Detector supported cadences.
        """
        return pulumi.get(self, "supported_cadences")

    @property
    @pulumi.getter(name="supportedResourceTypes")
    def supported_resource_types(self) -> Sequence[str]:
        """
        The Smart Detector supported resource types.
        """
        return pulumi.get(self, "supported_resource_types")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        """
        The detector's parameters.'
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class ThrottlingInformationResponse(dict):
    """
    Optional throttling information for the alert rule.
    """
    def __init__(__self__, *,
                 duration: Optional[str] = None):
        """
        Optional throttling information for the alert rule.
        :param str duration: The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value is 0 minutes
        """
        ThrottlingInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration=duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if duration is not None:
            _setter("duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value is 0 minutes
        """
        return pulumi.get(self, "duration")


