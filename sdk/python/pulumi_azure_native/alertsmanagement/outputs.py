# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActionGroupResponse',
    'ActionGroupsInformationResponse',
    'AddActionGroupsResponse',
    'AlertProcessingRulePropertiesResponse',
    'ConditionResponse',
    'ConditionsResponse',
    'CorrelateAlertsResponse',
    'CorrelateByResponse',
    'DailyRecurrenceResponse',
    'DetectorParameterDefinitionResponse',
    'DetectorResponse',
    'DiagnosticsResponse',
    'MonthlyRecurrenceResponse',
    'PrometheusRuleGroupActionResponse',
    'PrometheusRuleResolveConfigurationResponse',
    'PrometheusRuleResponse',
    'RemoveAllActionGroupsResponse',
    'ScheduleResponse',
    'ScopeResponse',
    'SuppressionConfigResponse',
    'SuppressionResponse',
    'SuppressionScheduleResponse',
    'SystemDataResponse',
    'ThrottlingInformationResponse',
    'WeeklyRecurrenceResponse',
]

@pulumi.output_type
class ActionGroupResponse(dict):
    """
    Action rule with action group configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroupId":
            suggest = "action_group_id"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_group_id: str,
                 created_at: str,
                 created_by: str,
                 last_modified_at: str,
                 last_modified_by: str,
                 type: str,
                 conditions: Optional['outputs.ConditionsResponse'] = None,
                 description: Optional[str] = None,
                 scope: Optional['outputs.ScopeResponse'] = None,
                 status: Optional[str] = None):
        """
        Action rule with action group configuration
        :param str action_group_id: Action group to trigger if action rule matches
        :param str created_at: Creation time of action rule. Date-Time in ISO-8601 format.
        :param str created_by: Created by user name.
        :param str last_modified_at: Last updated time of action rule. Date-Time in ISO-8601 format.
        :param str last_modified_by: Last modified by user name.
        :param str type: Indicates type of action rule
               Expected value is 'ActionGroup'.
        :param 'ConditionsResponse' conditions: conditions on which alerts will be filtered
        :param str description: Description of action rule
        :param 'ScopeResponse' scope: scope on which action rule will apply
        :param str status: Indicates if the given action rule is enabled or disabled
        """
        ActionGroupResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_group_id=action_group_id,
            created_at=created_at,
            created_by=created_by,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            type=type,
            conditions=conditions,
            description=description,
            scope=scope,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_group_id: Optional[str] = None,
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             type: Optional[str] = None,
             conditions: Optional['outputs.ConditionsResponse'] = None,
             description: Optional[str] = None,
             scope: Optional['outputs.ScopeResponse'] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_group_id is None and 'actionGroupId' in kwargs:
            action_group_id = kwargs['actionGroupId']
        if action_group_id is None:
            raise TypeError("Missing 'action_group_id' argument")
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_at is None:
            raise TypeError("Missing 'created_at' argument")
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by is None:
            raise TypeError("Missing 'created_by' argument")
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_at is None:
            raise TypeError("Missing 'last_modified_at' argument")
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by is None:
            raise TypeError("Missing 'last_modified_by' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("action_group_id", action_group_id)
        _setter("created_at", created_at)
        _setter("created_by", created_by)
        _setter("last_modified_at", last_modified_at)
        _setter("last_modified_by", last_modified_by)
        _setter("type", 'ActionGroup')
        if conditions is not None:
            _setter("conditions", conditions)
        if description is not None:
            _setter("description", description)
        if scope is not None:
            _setter("scope", scope)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> str:
        """
        Action group to trigger if action rule matches
        """
        return pulumi.get(self, "action_group_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Creation time of action rule. Date-Time in ISO-8601 format.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> str:
        """
        Created by user name.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> str:
        """
        Last updated time of action rule. Date-Time in ISO-8601 format.
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> str:
        """
        Last modified by user name.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Indicates type of action rule
        Expected value is 'ActionGroup'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.ConditionsResponse']:
        """
        conditions on which alerts will be filtered
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of action rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.ScopeResponse']:
        """
        scope on which action rule will apply
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates if the given action rule is enabled or disabled
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ActionGroupsInformationResponse(dict):
    """
    The Action Groups information, used by the alert rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "customEmailSubject":
            suggest = "custom_email_subject"
        elif key == "customWebhookPayload":
            suggest = "custom_webhook_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionGroupsInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionGroupsInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionGroupsInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[str],
                 custom_email_subject: Optional[str] = None,
                 custom_webhook_payload: Optional[str] = None):
        """
        The Action Groups information, used by the alert rule.
        :param Sequence[str] group_ids: The Action Group resource IDs.
        :param str custom_email_subject: An optional custom email subject to use in email notifications.
        :param str custom_webhook_payload: An optional custom web-hook payload to use in web-hook notifications.
        """
        ActionGroupsInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_ids=group_ids,
            custom_email_subject=custom_email_subject,
            custom_webhook_payload=custom_webhook_payload,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_ids: Optional[Sequence[str]] = None,
             custom_email_subject: Optional[str] = None,
             custom_webhook_payload: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_ids is None and 'groupIds' in kwargs:
            group_ids = kwargs['groupIds']
        if group_ids is None:
            raise TypeError("Missing 'group_ids' argument")
        if custom_email_subject is None and 'customEmailSubject' in kwargs:
            custom_email_subject = kwargs['customEmailSubject']
        if custom_webhook_payload is None and 'customWebhookPayload' in kwargs:
            custom_webhook_payload = kwargs['customWebhookPayload']

        _setter("group_ids", group_ids)
        if custom_email_subject is not None:
            _setter("custom_email_subject", custom_email_subject)
        if custom_webhook_payload is not None:
            _setter("custom_webhook_payload", custom_webhook_payload)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[str]:
        """
        The Action Group resource IDs.
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="customEmailSubject")
    def custom_email_subject(self) -> Optional[str]:
        """
        An optional custom email subject to use in email notifications.
        """
        return pulumi.get(self, "custom_email_subject")

    @property
    @pulumi.getter(name="customWebhookPayload")
    def custom_webhook_payload(self) -> Optional[str]:
        """
        An optional custom web-hook payload to use in web-hook notifications.
        """
        return pulumi.get(self, "custom_webhook_payload")


@pulumi.output_type
class AddActionGroupsResponse(dict):
    """
    Add action groups to alert processing rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroupIds":
            suggest = "action_group_ids"
        elif key == "actionType":
            suggest = "action_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddActionGroupsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddActionGroupsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddActionGroupsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_group_ids: Sequence[str],
                 action_type: str):
        """
        Add action groups to alert processing rule.
        :param Sequence[str] action_group_ids: List of action group Ids to add to alert processing rule.
        :param str action_type: Action that should be applied.
               Expected value is 'AddActionGroups'.
        """
        AddActionGroupsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_group_ids=action_group_ids,
            action_type=action_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_group_ids: Optional[Sequence[str]] = None,
             action_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_group_ids is None and 'actionGroupIds' in kwargs:
            action_group_ids = kwargs['actionGroupIds']
        if action_group_ids is None:
            raise TypeError("Missing 'action_group_ids' argument")
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")

        _setter("action_group_ids", action_group_ids)
        _setter("action_type", 'AddActionGroups')

    @property
    @pulumi.getter(name="actionGroupIds")
    def action_group_ids(self) -> Sequence[str]:
        """
        List of action group Ids to add to alert processing rule.
        """
        return pulumi.get(self, "action_group_ids")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Action that should be applied.
        Expected value is 'AddActionGroups'.
        """
        return pulumi.get(self, "action_type")


@pulumi.output_type
class AlertProcessingRulePropertiesResponse(dict):
    """
    Alert processing rule properties defining scopes, conditions and scheduling logic for alert processing rule.
    """
    def __init__(__self__, *,
                 actions: Sequence[Any],
                 scopes: Sequence[str],
                 conditions: Optional[Sequence['outputs.ConditionResponse']] = None,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 schedule: Optional['outputs.ScheduleResponse'] = None):
        """
        Alert processing rule properties defining scopes, conditions and scheduling logic for alert processing rule.
        :param Sequence[Union['AddActionGroupsResponse', 'CorrelateAlertsResponse', 'RemoveAllActionGroupsResponse']] actions: Actions to be applied.
        :param Sequence[str] scopes: Scopes on which alert processing rule will apply.
        :param Sequence['ConditionResponse'] conditions: Conditions on which alerts will be filtered.
        :param str description: Description of alert processing rule.
        :param bool enabled: Indicates if the given alert processing rule is enabled or disabled.
        :param 'ScheduleResponse' schedule: Scheduling for alert processing rule.
        """
        AlertProcessingRulePropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            scopes=scopes,
            conditions=conditions,
            description=description,
            enabled=enabled,
            schedule=schedule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[Sequence[Any]] = None,
             scopes: Optional[Sequence[str]] = None,
             conditions: Optional[Sequence['outputs.ConditionResponse']] = None,
             description: Optional[str] = None,
             enabled: Optional[bool] = None,
             schedule: Optional['outputs.ScheduleResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if scopes is None:
            raise TypeError("Missing 'scopes' argument")

        _setter("actions", actions)
        _setter("scopes", scopes)
        if conditions is not None:
            _setter("conditions", conditions)
        if description is not None:
            _setter("description", description)
        if enabled is None:
            enabled = True
        if enabled is not None:
            _setter("enabled", enabled)
        if schedule is not None:
            _setter("schedule", schedule)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[Any]:
        """
        Actions to be applied.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        Scopes on which alert processing rule will apply.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ConditionResponse']]:
        """
        Conditions on which alerts will be filtered.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of alert processing rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates if the given alert processing rule is enabled or disabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.ScheduleResponse']:
        """
        Scheduling for alert processing rule.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class ConditionResponse(dict):
    """
    Condition to trigger an alert processing rule.
    """
    def __init__(__self__, *,
                 field: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        Condition to trigger an alert processing rule.
        :param str field: Field for a given condition.
        :param str operator: Operator for a given condition.
        :param Sequence[str] values: List of values to match for a given condition.
        """
        ConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            operator=operator,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: Optional[str] = None,
             operator: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if field is not None:
            _setter("field", field)
        if operator is not None:
            _setter("operator", operator)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        Field for a given condition.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator for a given condition.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        List of values to match for a given condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ConditionsResponse(dict):
    """
    Conditions in alert instance to be matched for a given action rule. Default value is all. Multiple values could be provided with comma separation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertContext":
            suggest = "alert_context"
        elif key == "alertRuleId":
            suggest = "alert_rule_id"
        elif key == "alertRuleName":
            suggest = "alert_rule_name"
        elif key == "monitorCondition":
            suggest = "monitor_condition"
        elif key == "monitorService":
            suggest = "monitor_service"
        elif key == "targetResourceType":
            suggest = "target_resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConditionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConditionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConditionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_context: Optional['outputs.ConditionResponse'] = None,
                 alert_rule_id: Optional['outputs.ConditionResponse'] = None,
                 alert_rule_name: Optional['outputs.ConditionResponse'] = None,
                 description: Optional['outputs.ConditionResponse'] = None,
                 monitor_condition: Optional['outputs.ConditionResponse'] = None,
                 monitor_service: Optional['outputs.ConditionResponse'] = None,
                 severity: Optional['outputs.ConditionResponse'] = None,
                 target_resource_type: Optional['outputs.ConditionResponse'] = None):
        """
        Conditions in alert instance to be matched for a given action rule. Default value is all. Multiple values could be provided with comma separation.
        :param 'ConditionResponse' alert_context: filter alerts by alert context (payload)
        :param 'ConditionResponse' alert_rule_id: filter alerts by alert rule id
        :param 'ConditionResponse' alert_rule_name: filter alerts by alert rule name
        :param 'ConditionResponse' description: filter alerts by alert rule description
        :param 'ConditionResponse' monitor_condition: filter alerts by monitor condition
        :param 'ConditionResponse' monitor_service: filter alerts by monitor service
        :param 'ConditionResponse' severity: filter alerts by severity
        :param 'ConditionResponse' target_resource_type: filter alerts by target resource type
        """
        ConditionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_context=alert_context,
            alert_rule_id=alert_rule_id,
            alert_rule_name=alert_rule_name,
            description=description,
            monitor_condition=monitor_condition,
            monitor_service=monitor_service,
            severity=severity,
            target_resource_type=target_resource_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_context: Optional['outputs.ConditionResponse'] = None,
             alert_rule_id: Optional['outputs.ConditionResponse'] = None,
             alert_rule_name: Optional['outputs.ConditionResponse'] = None,
             description: Optional['outputs.ConditionResponse'] = None,
             monitor_condition: Optional['outputs.ConditionResponse'] = None,
             monitor_service: Optional['outputs.ConditionResponse'] = None,
             severity: Optional['outputs.ConditionResponse'] = None,
             target_resource_type: Optional['outputs.ConditionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_context is None and 'alertContext' in kwargs:
            alert_context = kwargs['alertContext']
        if alert_rule_id is None and 'alertRuleId' in kwargs:
            alert_rule_id = kwargs['alertRuleId']
        if alert_rule_name is None and 'alertRuleName' in kwargs:
            alert_rule_name = kwargs['alertRuleName']
        if monitor_condition is None and 'monitorCondition' in kwargs:
            monitor_condition = kwargs['monitorCondition']
        if monitor_service is None and 'monitorService' in kwargs:
            monitor_service = kwargs['monitorService']
        if target_resource_type is None and 'targetResourceType' in kwargs:
            target_resource_type = kwargs['targetResourceType']

        if alert_context is not None:
            _setter("alert_context", alert_context)
        if alert_rule_id is not None:
            _setter("alert_rule_id", alert_rule_id)
        if alert_rule_name is not None:
            _setter("alert_rule_name", alert_rule_name)
        if description is not None:
            _setter("description", description)
        if monitor_condition is not None:
            _setter("monitor_condition", monitor_condition)
        if monitor_service is not None:
            _setter("monitor_service", monitor_service)
        if severity is not None:
            _setter("severity", severity)
        if target_resource_type is not None:
            _setter("target_resource_type", target_resource_type)

    @property
    @pulumi.getter(name="alertContext")
    def alert_context(self) -> Optional['outputs.ConditionResponse']:
        """
        filter alerts by alert context (payload)
        """
        return pulumi.get(self, "alert_context")

    @property
    @pulumi.getter(name="alertRuleId")
    def alert_rule_id(self) -> Optional['outputs.ConditionResponse']:
        """
        filter alerts by alert rule id
        """
        return pulumi.get(self, "alert_rule_id")

    @property
    @pulumi.getter(name="alertRuleName")
    def alert_rule_name(self) -> Optional['outputs.ConditionResponse']:
        """
        filter alerts by alert rule name
        """
        return pulumi.get(self, "alert_rule_name")

    @property
    @pulumi.getter
    def description(self) -> Optional['outputs.ConditionResponse']:
        """
        filter alerts by alert rule description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="monitorCondition")
    def monitor_condition(self) -> Optional['outputs.ConditionResponse']:
        """
        filter alerts by monitor condition
        """
        return pulumi.get(self, "monitor_condition")

    @property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional['outputs.ConditionResponse']:
        """
        filter alerts by monitor service
        """
        return pulumi.get(self, "monitor_service")

    @property
    @pulumi.getter
    def severity(self) -> Optional['outputs.ConditionResponse']:
        """
        filter alerts by severity
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional['outputs.ConditionResponse']:
        """
        filter alerts by target resource type
        """
        return pulumi.get(self, "target_resource_type")


@pulumi.output_type
class CorrelateAlertsResponse(dict):
    """
    Add logic for alerts correlation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "correlateBy":
            suggest = "correlate_by"
        elif key == "correlationInterval":
            suggest = "correlation_interval"
        elif key == "notificationsForCorrelatedAlerts":
            suggest = "notifications_for_correlated_alerts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CorrelateAlertsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CorrelateAlertsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CorrelateAlertsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 correlate_by: Sequence['outputs.CorrelateByResponse'],
                 correlation_interval: str,
                 priority: int,
                 notifications_for_correlated_alerts: Optional[str] = None):
        """
        Add logic for alerts correlation.
        :param str action_type: Action that should be applied.
               Expected value is 'CorrelateAlerts'.
        :param Sequence['CorrelateByResponse'] correlate_by: The list of conditions for the alerts correlations.
        :param str correlation_interval: The required duration (in ISO8601 format) for the alerts correlation.
        :param int priority: The priority of this correlation.
        :param str notifications_for_correlated_alerts: Indicates how to handle child alerts notifications.
        """
        CorrelateAlertsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            correlate_by=correlate_by,
            correlation_interval=correlation_interval,
            priority=priority,
            notifications_for_correlated_alerts=notifications_for_correlated_alerts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             correlate_by: Optional[Sequence['outputs.CorrelateByResponse']] = None,
             correlation_interval: Optional[str] = None,
             priority: Optional[int] = None,
             notifications_for_correlated_alerts: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")
        if correlate_by is None and 'correlateBy' in kwargs:
            correlate_by = kwargs['correlateBy']
        if correlate_by is None:
            raise TypeError("Missing 'correlate_by' argument")
        if correlation_interval is None and 'correlationInterval' in kwargs:
            correlation_interval = kwargs['correlationInterval']
        if correlation_interval is None:
            raise TypeError("Missing 'correlation_interval' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if notifications_for_correlated_alerts is None and 'notificationsForCorrelatedAlerts' in kwargs:
            notifications_for_correlated_alerts = kwargs['notificationsForCorrelatedAlerts']

        _setter("action_type", 'CorrelateAlerts')
        _setter("correlate_by", correlate_by)
        _setter("correlation_interval", correlation_interval)
        _setter("priority", priority)
        if notifications_for_correlated_alerts is None:
            notifications_for_correlated_alerts = 'SuppressAlways'
        if notifications_for_correlated_alerts is not None:
            _setter("notifications_for_correlated_alerts", notifications_for_correlated_alerts)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Action that should be applied.
        Expected value is 'CorrelateAlerts'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="correlateBy")
    def correlate_by(self) -> Sequence['outputs.CorrelateByResponse']:
        """
        The list of conditions for the alerts correlations.
        """
        return pulumi.get(self, "correlate_by")

    @property
    @pulumi.getter(name="correlationInterval")
    def correlation_interval(self) -> str:
        """
        The required duration (in ISO8601 format) for the alerts correlation.
        """
        return pulumi.get(self, "correlation_interval")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        The priority of this correlation.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="notificationsForCorrelatedAlerts")
    def notifications_for_correlated_alerts(self) -> Optional[str]:
        """
        Indicates how to handle child alerts notifications.
        """
        return pulumi.get(self, "notifications_for_correlated_alerts")


@pulumi.output_type
class CorrelateByResponse(dict):
    """
    The logic for the correlation.
    """
    def __init__(__self__, *,
                 field: Optional[str] = None):
        """
        The logic for the correlation.
        :param str field: The JPath of the property that the alerts should be correlated by.
        """
        CorrelateByResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if field is not None:
            _setter("field", field)

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        The JPath of the property that the alerts should be correlated by.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class DailyRecurrenceResponse(dict):
    """
    Daily recurrence object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DailyRecurrenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DailyRecurrenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DailyRecurrenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 recurrence_type: str,
                 start_time: str):
        """
        Daily recurrence object.
        :param str end_time: End time for recurrence.
        :param str recurrence_type: Specifies when the recurrence should be applied.
               Expected value is 'Daily'.
        :param str start_time: Start time for recurrence.
        """
        DailyRecurrenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_time=end_time,
            recurrence_type=recurrence_type,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_time: Optional[str] = None,
             recurrence_type: Optional[str] = None,
             start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if end_time is None:
            raise TypeError("Missing 'end_time' argument")
        if recurrence_type is None and 'recurrenceType' in kwargs:
            recurrence_type = kwargs['recurrenceType']
        if recurrence_type is None:
            raise TypeError("Missing 'recurrence_type' argument")
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if start_time is None:
            raise TypeError("Missing 'start_time' argument")

        _setter("end_time", end_time)
        _setter("recurrence_type", 'Daily')
        _setter("start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        End time for recurrence.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> str:
        """
        Specifies when the recurrence should be applied.
        Expected value is 'Daily'.
        """
        return pulumi.get(self, "recurrence_type")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Start time for recurrence.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class DetectorParameterDefinitionResponse(dict):
    """
    The detector parameter definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "isMandatory":
            suggest = "is_mandatory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorParameterDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorParameterDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorParameterDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 display_name: Optional[str] = None,
                 is_mandatory: Optional[bool] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        The detector parameter definition.
        :param str description: The detector parameter description.
        :param str display_name: The detector parameter display name.
        :param bool is_mandatory: A value indicating whether this detector parameter is mandatory.
        :param str name: The detector parameter name.
        :param str type: The detector parameter type.
        """
        DetectorParameterDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            display_name=display_name,
            is_mandatory=is_mandatory,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             display_name: Optional[str] = None,
             is_mandatory: Optional[bool] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if is_mandatory is None and 'isMandatory' in kwargs:
            is_mandatory = kwargs['isMandatory']

        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if is_mandatory is not None:
            _setter("is_mandatory", is_mandatory)
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The detector parameter description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The detector parameter display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="isMandatory")
    def is_mandatory(self) -> Optional[bool]:
        """
        A value indicating whether this detector parameter is mandatory.
        """
        return pulumi.get(self, "is_mandatory")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The detector parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The detector parameter type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DetectorResponse(dict):
    """
    The detector information. By default this is not populated, unless it's specified in expandDetector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imagePaths":
            suggest = "image_paths"
        elif key == "parameterDefinitions":
            suggest = "parameter_definitions"
        elif key == "supportedCadences":
            suggest = "supported_cadences"
        elif key == "supportedResourceTypes":
            suggest = "supported_resource_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DetectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DetectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DetectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 id: str,
                 image_paths: Sequence[str],
                 name: str,
                 parameter_definitions: Sequence['outputs.DetectorParameterDefinitionResponse'],
                 supported_cadences: Sequence[int],
                 supported_resource_types: Sequence[str],
                 parameters: Optional[Mapping[str, Any]] = None):
        """
        The detector information. By default this is not populated, unless it's specified in expandDetector
        :param str description: The Smart Detector description.
        :param str id: The detector id.
        :param Sequence[str] image_paths: The Smart Detector image path. By default this is not populated, unless it's specified in expandDetector
        :param str name: The Smart Detector name.
        :param Sequence['DetectorParameterDefinitionResponse'] parameter_definitions: The Smart Detector parameters definitions.'
        :param Sequence[int] supported_cadences: The Smart Detector supported cadences.
        :param Sequence[str] supported_resource_types: The Smart Detector supported resource types.
        :param Mapping[str, Any] parameters: The detector's parameters.'
        """
        DetectorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            image_paths=image_paths,
            name=name,
            parameter_definitions=parameter_definitions,
            supported_cadences=supported_cadences,
            supported_resource_types=supported_resource_types,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             id: Optional[str] = None,
             image_paths: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             parameter_definitions: Optional[Sequence['outputs.DetectorParameterDefinitionResponse']] = None,
             supported_cadences: Optional[Sequence[int]] = None,
             supported_resource_types: Optional[Sequence[str]] = None,
             parameters: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if image_paths is None and 'imagePaths' in kwargs:
            image_paths = kwargs['imagePaths']
        if image_paths is None:
            raise TypeError("Missing 'image_paths' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameter_definitions is None and 'parameterDefinitions' in kwargs:
            parameter_definitions = kwargs['parameterDefinitions']
        if parameter_definitions is None:
            raise TypeError("Missing 'parameter_definitions' argument")
        if supported_cadences is None and 'supportedCadences' in kwargs:
            supported_cadences = kwargs['supportedCadences']
        if supported_cadences is None:
            raise TypeError("Missing 'supported_cadences' argument")
        if supported_resource_types is None and 'supportedResourceTypes' in kwargs:
            supported_resource_types = kwargs['supportedResourceTypes']
        if supported_resource_types is None:
            raise TypeError("Missing 'supported_resource_types' argument")

        _setter("description", description)
        _setter("id", id)
        _setter("image_paths", image_paths)
        _setter("name", name)
        _setter("parameter_definitions", parameter_definitions)
        _setter("supported_cadences", supported_cadences)
        _setter("supported_resource_types", supported_resource_types)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The Smart Detector description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The detector id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imagePaths")
    def image_paths(self) -> Sequence[str]:
        """
        The Smart Detector image path. By default this is not populated, unless it's specified in expandDetector
        """
        return pulumi.get(self, "image_paths")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Smart Detector name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parameterDefinitions")
    def parameter_definitions(self) -> Sequence['outputs.DetectorParameterDefinitionResponse']:
        """
        The Smart Detector parameters definitions.'
        """
        return pulumi.get(self, "parameter_definitions")

    @property
    @pulumi.getter(name="supportedCadences")
    def supported_cadences(self) -> Sequence[int]:
        """
        The Smart Detector supported cadences.
        """
        return pulumi.get(self, "supported_cadences")

    @property
    @pulumi.getter(name="supportedResourceTypes")
    def supported_resource_types(self) -> Sequence[str]:
        """
        The Smart Detector supported resource types.
        """
        return pulumi.get(self, "supported_resource_types")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        """
        The detector's parameters.'
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DiagnosticsResponse(dict):
    """
    Action rule with diagnostics configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiagnosticsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiagnosticsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiagnosticsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: str,
                 created_by: str,
                 last_modified_at: str,
                 last_modified_by: str,
                 type: str,
                 conditions: Optional['outputs.ConditionsResponse'] = None,
                 description: Optional[str] = None,
                 scope: Optional['outputs.ScopeResponse'] = None,
                 status: Optional[str] = None):
        """
        Action rule with diagnostics configuration
        :param str created_at: Creation time of action rule. Date-Time in ISO-8601 format.
        :param str created_by: Created by user name.
        :param str last_modified_at: Last updated time of action rule. Date-Time in ISO-8601 format.
        :param str last_modified_by: Last modified by user name.
        :param str type: Indicates type of action rule
               Expected value is 'Diagnostics'.
        :param 'ConditionsResponse' conditions: conditions on which alerts will be filtered
        :param str description: Description of action rule
        :param 'ScopeResponse' scope: scope on which action rule will apply
        :param str status: Indicates if the given action rule is enabled or disabled
        """
        DiagnosticsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            type=type,
            conditions=conditions,
            description=description,
            scope=scope,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             type: Optional[str] = None,
             conditions: Optional['outputs.ConditionsResponse'] = None,
             description: Optional[str] = None,
             scope: Optional['outputs.ScopeResponse'] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_at is None:
            raise TypeError("Missing 'created_at' argument")
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by is None:
            raise TypeError("Missing 'created_by' argument")
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_at is None:
            raise TypeError("Missing 'last_modified_at' argument")
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by is None:
            raise TypeError("Missing 'last_modified_by' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("created_at", created_at)
        _setter("created_by", created_by)
        _setter("last_modified_at", last_modified_at)
        _setter("last_modified_by", last_modified_by)
        _setter("type", 'Diagnostics')
        if conditions is not None:
            _setter("conditions", conditions)
        if description is not None:
            _setter("description", description)
        if scope is not None:
            _setter("scope", scope)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Creation time of action rule. Date-Time in ISO-8601 format.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> str:
        """
        Created by user name.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> str:
        """
        Last updated time of action rule. Date-Time in ISO-8601 format.
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> str:
        """
        Last modified by user name.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Indicates type of action rule
        Expected value is 'Diagnostics'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.ConditionsResponse']:
        """
        conditions on which alerts will be filtered
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of action rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.ScopeResponse']:
        """
        scope on which action rule will apply
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates if the given action rule is enabled or disabled
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class MonthlyRecurrenceResponse(dict):
    """
    Monthly recurrence object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonth":
            suggest = "days_of_month"
        elif key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonthlyRecurrenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonthlyRecurrenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonthlyRecurrenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_month: Sequence[int],
                 recurrence_type: str,
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        Monthly recurrence object.
        :param Sequence[int] days_of_month: Specifies the values for monthly recurrence pattern.
        :param str recurrence_type: Specifies when the recurrence should be applied.
               Expected value is 'Monthly'.
        :param str end_time: End time for recurrence.
        :param str start_time: Start time for recurrence.
        """
        MonthlyRecurrenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days_of_month=days_of_month,
            recurrence_type=recurrence_type,
            end_time=end_time,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days_of_month: Optional[Sequence[int]] = None,
             recurrence_type: Optional[str] = None,
             end_time: Optional[str] = None,
             start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if days_of_month is None and 'daysOfMonth' in kwargs:
            days_of_month = kwargs['daysOfMonth']
        if days_of_month is None:
            raise TypeError("Missing 'days_of_month' argument")
        if recurrence_type is None and 'recurrenceType' in kwargs:
            recurrence_type = kwargs['recurrenceType']
        if recurrence_type is None:
            raise TypeError("Missing 'recurrence_type' argument")
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']

        _setter("days_of_month", days_of_month)
        _setter("recurrence_type", 'Monthly')
        if end_time is not None:
            _setter("end_time", end_time)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="daysOfMonth")
    def days_of_month(self) -> Sequence[int]:
        """
        Specifies the values for monthly recurrence pattern.
        """
        return pulumi.get(self, "days_of_month")

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> str:
        """
        Specifies when the recurrence should be applied.
        Expected value is 'Monthly'.
        """
        return pulumi.get(self, "recurrence_type")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        End time for recurrence.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Start time for recurrence.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class PrometheusRuleGroupActionResponse(dict):
    """
    An alert action. Only relevant for alerts.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroupId":
            suggest = "action_group_id"
        elif key == "actionProperties":
            suggest = "action_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusRuleGroupActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusRuleGroupActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusRuleGroupActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_group_id: Optional[str] = None,
                 action_properties: Optional[Mapping[str, str]] = None):
        """
        An alert action. Only relevant for alerts.
        :param str action_group_id: The resource id of the action group to use.
        :param Mapping[str, str] action_properties: The properties of an action group object.
        """
        PrometheusRuleGroupActionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_group_id=action_group_id,
            action_properties=action_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_group_id: Optional[str] = None,
             action_properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_group_id is None and 'actionGroupId' in kwargs:
            action_group_id = kwargs['actionGroupId']
        if action_properties is None and 'actionProperties' in kwargs:
            action_properties = kwargs['actionProperties']

        if action_group_id is not None:
            _setter("action_group_id", action_group_id)
        if action_properties is not None:
            _setter("action_properties", action_properties)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> Optional[str]:
        """
        The resource id of the action group to use.
        """
        return pulumi.get(self, "action_group_id")

    @property
    @pulumi.getter(name="actionProperties")
    def action_properties(self) -> Optional[Mapping[str, str]]:
        """
        The properties of an action group object.
        """
        return pulumi.get(self, "action_properties")


@pulumi.output_type
class PrometheusRuleResolveConfigurationResponse(dict):
    """
    Specifies the Prometheus alert rule configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoResolved":
            suggest = "auto_resolved"
        elif key == "timeToResolve":
            suggest = "time_to_resolve"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusRuleResolveConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusRuleResolveConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusRuleResolveConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_resolved: Optional[bool] = None,
                 time_to_resolve: Optional[str] = None):
        """
        Specifies the Prometheus alert rule configuration.
        :param bool auto_resolved: Enable alert auto-resolution.
        :param str time_to_resolve: Alert auto-resolution timeout.
        """
        PrometheusRuleResolveConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_resolved=auto_resolved,
            time_to_resolve=time_to_resolve,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_resolved: Optional[bool] = None,
             time_to_resolve: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auto_resolved is None and 'autoResolved' in kwargs:
            auto_resolved = kwargs['autoResolved']
        if time_to_resolve is None and 'timeToResolve' in kwargs:
            time_to_resolve = kwargs['timeToResolve']

        if auto_resolved is not None:
            _setter("auto_resolved", auto_resolved)
        if time_to_resolve is not None:
            _setter("time_to_resolve", time_to_resolve)

    @property
    @pulumi.getter(name="autoResolved")
    def auto_resolved(self) -> Optional[bool]:
        """
        Enable alert auto-resolution.
        """
        return pulumi.get(self, "auto_resolved")

    @property
    @pulumi.getter(name="timeToResolve")
    def time_to_resolve(self) -> Optional[str]:
        """
        Alert auto-resolution timeout.
        """
        return pulumi.get(self, "time_to_resolve")


@pulumi.output_type
class PrometheusRuleResponse(dict):
    """
    An Azure Prometheus alerting or recording rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "for":
            suggest = "for_"
        elif key == "resolveConfiguration":
            suggest = "resolve_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 actions: Optional[Sequence['outputs.PrometheusRuleGroupActionResponse']] = None,
                 alert: Optional[str] = None,
                 annotations: Optional[Mapping[str, str]] = None,
                 enabled: Optional[bool] = None,
                 for_: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 record: Optional[str] = None,
                 resolve_configuration: Optional['outputs.PrometheusRuleResolveConfigurationResponse'] = None,
                 severity: Optional[int] = None):
        """
        An Azure Prometheus alerting or recording rule.
        :param str expression: The PromQL expression to evaluate. https://prometheus.io/docs/prometheus/latest/querying/basics/. Evaluated periodically as given by 'interval', and the result recorded as a new set of time series with the metric name as given by 'record'.
        :param Sequence['PrometheusRuleGroupActionResponse'] actions: Actions that are performed when the alert rule becomes active, and when an alert condition is resolved.
        :param str alert: Alert rule name.
        :param Mapping[str, str] annotations: The annotations clause specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links. The annotation values can be templated.
        :param bool enabled: Enable/disable rule.
        :param str for_: The amount of time alert must be active before firing.
        :param Mapping[str, str] labels: Labels to add or overwrite before storing the result.
        :param str record: Recorded metrics name.
        :param 'PrometheusRuleResolveConfigurationResponse' resolve_configuration: Defines the configuration for resolving fired alerts. Only relevant for alerts.
        :param int severity: The severity of the alerts fired by the rule. Must be between 0 and 4.
        """
        PrometheusRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            actions=actions,
            alert=alert,
            annotations=annotations,
            enabled=enabled,
            for_=for_,
            labels=labels,
            record=record,
            resolve_configuration=resolve_configuration,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: Optional[str] = None,
             actions: Optional[Sequence['outputs.PrometheusRuleGroupActionResponse']] = None,
             alert: Optional[str] = None,
             annotations: Optional[Mapping[str, str]] = None,
             enabled: Optional[bool] = None,
             for_: Optional[str] = None,
             labels: Optional[Mapping[str, str]] = None,
             record: Optional[str] = None,
             resolve_configuration: Optional['outputs.PrometheusRuleResolveConfigurationResponse'] = None,
             severity: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if expression is None:
            raise TypeError("Missing 'expression' argument")
        if for_ is None and 'for' in kwargs:
            for_ = kwargs['for']
        if resolve_configuration is None and 'resolveConfiguration' in kwargs:
            resolve_configuration = kwargs['resolveConfiguration']

        _setter("expression", expression)
        if actions is not None:
            _setter("actions", actions)
        if alert is not None:
            _setter("alert", alert)
        if annotations is not None:
            _setter("annotations", annotations)
        if enabled is not None:
            _setter("enabled", enabled)
        if for_ is not None:
            _setter("for_", for_)
        if labels is not None:
            _setter("labels", labels)
        if record is not None:
            _setter("record", record)
        if resolve_configuration is not None:
            _setter("resolve_configuration", resolve_configuration)
        if severity is not None:
            _setter("severity", severity)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The PromQL expression to evaluate. https://prometheus.io/docs/prometheus/latest/querying/basics/. Evaluated periodically as given by 'interval', and the result recorded as a new set of time series with the metric name as given by 'record'.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.PrometheusRuleGroupActionResponse']]:
        """
        Actions that are performed when the alert rule becomes active, and when an alert condition is resolved.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def alert(self) -> Optional[str]:
        """
        Alert rule name.
        """
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        The annotations clause specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links. The annotation values can be templated.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable/disable rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[str]:
        """
        The amount of time alert must be active before firing.
        """
        return pulumi.get(self, "for_")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to add or overwrite before storing the result.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def record(self) -> Optional[str]:
        """
        Recorded metrics name.
        """
        return pulumi.get(self, "record")

    @property
    @pulumi.getter(name="resolveConfiguration")
    def resolve_configuration(self) -> Optional['outputs.PrometheusRuleResolveConfigurationResponse']:
        """
        Defines the configuration for resolving fired alerts. Only relevant for alerts.
        """
        return pulumi.get(self, "resolve_configuration")

    @property
    @pulumi.getter
    def severity(self) -> Optional[int]:
        """
        The severity of the alerts fired by the rule. Must be between 0 and 4.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class RemoveAllActionGroupsResponse(dict):
    """
    Indicates if all action groups should be removed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoveAllActionGroupsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoveAllActionGroupsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoveAllActionGroupsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str):
        """
        Indicates if all action groups should be removed.
        :param str action_type: Action that should be applied.
               Expected value is 'RemoveAllActionGroups'.
        """
        RemoveAllActionGroupsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")

        _setter("action_type", 'RemoveAllActionGroups')

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        Action that should be applied.
        Expected value is 'RemoveAllActionGroups'.
        """
        return pulumi.get(self, "action_type")


@pulumi.output_type
class ScheduleResponse(dict):
    """
    Scheduling configuration for a given alert processing rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveFrom":
            suggest = "effective_from"
        elif key == "effectiveUntil":
            suggest = "effective_until"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_from: Optional[str] = None,
                 effective_until: Optional[str] = None,
                 recurrences: Optional[Sequence[Any]] = None,
                 time_zone: Optional[str] = None):
        """
        Scheduling configuration for a given alert processing rule.
        :param str effective_from: Scheduling effective from time. Date-Time in ISO-8601 format without timezone suffix.
        :param str effective_until: Scheduling effective until time. Date-Time in ISO-8601 format without timezone suffix.
        :param Sequence[Union['DailyRecurrenceResponse', 'MonthlyRecurrenceResponse', 'WeeklyRecurrenceResponse']] recurrences: List of recurrences.
        :param str time_zone: Scheduling time zone.
        """
        ScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effective_from=effective_from,
            effective_until=effective_until,
            recurrences=recurrences,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effective_from: Optional[str] = None,
             effective_until: Optional[str] = None,
             recurrences: Optional[Sequence[Any]] = None,
             time_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if effective_from is None and 'effectiveFrom' in kwargs:
            effective_from = kwargs['effectiveFrom']
        if effective_until is None and 'effectiveUntil' in kwargs:
            effective_until = kwargs['effectiveUntil']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        if effective_from is not None:
            _setter("effective_from", effective_from)
        if effective_until is not None:
            _setter("effective_until", effective_until)
        if recurrences is not None:
            _setter("recurrences", recurrences)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter(name="effectiveFrom")
    def effective_from(self) -> Optional[str]:
        """
        Scheduling effective from time. Date-Time in ISO-8601 format without timezone suffix.
        """
        return pulumi.get(self, "effective_from")

    @property
    @pulumi.getter(name="effectiveUntil")
    def effective_until(self) -> Optional[str]:
        """
        Scheduling effective until time. Date-Time in ISO-8601 format without timezone suffix.
        """
        return pulumi.get(self, "effective_until")

    @property
    @pulumi.getter
    def recurrences(self) -> Optional[Sequence[Any]]:
        """
        List of recurrences.
        """
        return pulumi.get(self, "recurrences")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        Scheduling time zone.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class ScopeResponse(dict):
    """
    Target scope for a given action rule. By default scope will be the subscription. User can also provide list of resource groups or list of resources from the scope subscription as well.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scopeType":
            suggest = "scope_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScopeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScopeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScopeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scope_type: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        Target scope for a given action rule. By default scope will be the subscription. User can also provide list of resource groups or list of resources from the scope subscription as well.
        :param str scope_type: type of target scope
        :param Sequence[str] values: list of ARM IDs of the given scope type which will be the target of the given action rule.
        """
        ScopeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scope_type=scope_type,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scope_type: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scope_type is None and 'scopeType' in kwargs:
            scope_type = kwargs['scopeType']

        if scope_type is not None:
            _setter("scope_type", scope_type)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="scopeType")
    def scope_type(self) -> Optional[str]:
        """
        type of target scope
        """
        return pulumi.get(self, "scope_type")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        list of ARM IDs of the given scope type which will be the target of the given action rule.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SuppressionConfigResponse(dict):
    """
    Suppression logic for a given action rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceType":
            suggest = "recurrence_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuppressionConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuppressionConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuppressionConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurrence_type: str,
                 schedule: Optional['outputs.SuppressionScheduleResponse'] = None):
        """
        Suppression logic for a given action rule
        :param str recurrence_type: Specifies when the suppression should be applied
        :param 'SuppressionScheduleResponse' schedule: suppression schedule configuration
        """
        SuppressionConfigResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recurrence_type=recurrence_type,
            schedule=schedule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recurrence_type: Optional[str] = None,
             schedule: Optional['outputs.SuppressionScheduleResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if recurrence_type is None and 'recurrenceType' in kwargs:
            recurrence_type = kwargs['recurrenceType']
        if recurrence_type is None:
            raise TypeError("Missing 'recurrence_type' argument")

        _setter("recurrence_type", recurrence_type)
        if schedule is not None:
            _setter("schedule", schedule)

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> str:
        """
        Specifies when the suppression should be applied
        """
        return pulumi.get(self, "recurrence_type")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.SuppressionScheduleResponse']:
        """
        suppression schedule configuration
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class SuppressionResponse(dict):
    """
    Action rule with suppression configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "suppressionConfig":
            suggest = "suppression_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuppressionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuppressionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuppressionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: str,
                 created_by: str,
                 last_modified_at: str,
                 last_modified_by: str,
                 suppression_config: 'outputs.SuppressionConfigResponse',
                 type: str,
                 conditions: Optional['outputs.ConditionsResponse'] = None,
                 description: Optional[str] = None,
                 scope: Optional['outputs.ScopeResponse'] = None,
                 status: Optional[str] = None):
        """
        Action rule with suppression configuration
        :param str created_at: Creation time of action rule. Date-Time in ISO-8601 format.
        :param str created_by: Created by user name.
        :param str last_modified_at: Last updated time of action rule. Date-Time in ISO-8601 format.
        :param str last_modified_by: Last modified by user name.
        :param 'SuppressionConfigResponse' suppression_config: suppression configuration for the action rule
        :param str type: Indicates type of action rule
               Expected value is 'Suppression'.
        :param 'ConditionsResponse' conditions: conditions on which alerts will be filtered
        :param str description: Description of action rule
        :param 'ScopeResponse' scope: scope on which action rule will apply
        :param str status: Indicates if the given action rule is enabled or disabled
        """
        SuppressionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            suppression_config=suppression_config,
            type=type,
            conditions=conditions,
            description=description,
            scope=scope,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             suppression_config: Optional['outputs.SuppressionConfigResponse'] = None,
             type: Optional[str] = None,
             conditions: Optional['outputs.ConditionsResponse'] = None,
             description: Optional[str] = None,
             scope: Optional['outputs.ScopeResponse'] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_at is None:
            raise TypeError("Missing 'created_at' argument")
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by is None:
            raise TypeError("Missing 'created_by' argument")
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_at is None:
            raise TypeError("Missing 'last_modified_at' argument")
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by is None:
            raise TypeError("Missing 'last_modified_by' argument")
        if suppression_config is None and 'suppressionConfig' in kwargs:
            suppression_config = kwargs['suppressionConfig']
        if suppression_config is None:
            raise TypeError("Missing 'suppression_config' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("created_at", created_at)
        _setter("created_by", created_by)
        _setter("last_modified_at", last_modified_at)
        _setter("last_modified_by", last_modified_by)
        _setter("suppression_config", suppression_config)
        _setter("type", 'Suppression')
        if conditions is not None:
            _setter("conditions", conditions)
        if description is not None:
            _setter("description", description)
        if scope is not None:
            _setter("scope", scope)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Creation time of action rule. Date-Time in ISO-8601 format.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> str:
        """
        Created by user name.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> str:
        """
        Last updated time of action rule. Date-Time in ISO-8601 format.
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> str:
        """
        Last modified by user name.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="suppressionConfig")
    def suppression_config(self) -> 'outputs.SuppressionConfigResponse':
        """
        suppression configuration for the action rule
        """
        return pulumi.get(self, "suppression_config")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Indicates type of action rule
        Expected value is 'Suppression'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def conditions(self) -> Optional['outputs.ConditionsResponse']:
        """
        conditions on which alerts will be filtered
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of action rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.ScopeResponse']:
        """
        scope on which action rule will apply
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates if the given action rule is enabled or disabled
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SuppressionScheduleResponse(dict):
    """
    Schedule for a given suppression configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "recurrenceValues":
            suggest = "recurrence_values"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuppressionScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuppressionScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuppressionScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: Optional[str] = None,
                 end_time: Optional[str] = None,
                 recurrence_values: Optional[Sequence[int]] = None,
                 start_date: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        Schedule for a given suppression configuration.
        :param str end_date: End date for suppression
        :param str end_time: End date for suppression
        :param Sequence[int] recurrence_values: Specifies the values for recurrence pattern
        :param str start_date: Start date for suppression
        :param str start_time: Start time for suppression
        """
        SuppressionScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_date=end_date,
            end_time=end_time,
            recurrence_values=recurrence_values,
            start_date=start_date,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_date: Optional[str] = None,
             end_time: Optional[str] = None,
             recurrence_values: Optional[Sequence[int]] = None,
             start_date: Optional[str] = None,
             start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end_date is None and 'endDate' in kwargs:
            end_date = kwargs['endDate']
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if recurrence_values is None and 'recurrenceValues' in kwargs:
            recurrence_values = kwargs['recurrenceValues']
        if start_date is None and 'startDate' in kwargs:
            start_date = kwargs['startDate']
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']

        if end_date is not None:
            _setter("end_date", end_date)
        if end_time is not None:
            _setter("end_time", end_time)
        if recurrence_values is not None:
            _setter("recurrence_values", recurrence_values)
        if start_date is not None:
            _setter("start_date", start_date)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        End date for suppression
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        End date for suppression
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="recurrenceValues")
    def recurrence_values(self) -> Optional[Sequence[int]]:
        """
        Specifies the values for recurrence pattern
        """
        return pulumi.get(self, "recurrence_values")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        Start date for suppression
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Start time for suppression
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class ThrottlingInformationResponse(dict):
    """
    Optional throttling information for the alert rule.
    """
    def __init__(__self__, *,
                 duration: Optional[str] = None):
        """
        Optional throttling information for the alert rule.
        :param str duration: The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value is 0 minutes
        """
        ThrottlingInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration=duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if duration is not None:
            _setter("duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value is 0 minutes
        """
        return pulumi.get(self, "duration")


@pulumi.output_type
class WeeklyRecurrenceResponse(dict):
    """
    Weekly recurrence object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeek":
            suggest = "days_of_week"
        elif key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WeeklyRecurrenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WeeklyRecurrenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WeeklyRecurrenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_week: Sequence[str],
                 recurrence_type: str,
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        Weekly recurrence object.
        :param Sequence[str] days_of_week: Specifies the values for weekly recurrence pattern.
        :param str recurrence_type: Specifies when the recurrence should be applied.
               Expected value is 'Weekly'.
        :param str end_time: End time for recurrence.
        :param str start_time: Start time for recurrence.
        """
        WeeklyRecurrenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days_of_week=days_of_week,
            recurrence_type=recurrence_type,
            end_time=end_time,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days_of_week: Optional[Sequence[str]] = None,
             recurrence_type: Optional[str] = None,
             end_time: Optional[str] = None,
             start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if days_of_week is None and 'daysOfWeek' in kwargs:
            days_of_week = kwargs['daysOfWeek']
        if days_of_week is None:
            raise TypeError("Missing 'days_of_week' argument")
        if recurrence_type is None and 'recurrenceType' in kwargs:
            recurrence_type = kwargs['recurrenceType']
        if recurrence_type is None:
            raise TypeError("Missing 'recurrence_type' argument")
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']

        _setter("days_of_week", days_of_week)
        _setter("recurrence_type", 'Weekly')
        if end_time is not None:
            _setter("end_time", end_time)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Sequence[str]:
        """
        Specifies the values for weekly recurrence pattern.
        """
        return pulumi.get(self, "days_of_week")

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> str:
        """
        Specifies when the recurrence should be applied.
        Expected value is 'Weekly'.
        """
        return pulumi.get(self, "recurrence_type")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        End time for recurrence.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Start time for recurrence.
        """
        return pulumi.get(self, "start_time")


