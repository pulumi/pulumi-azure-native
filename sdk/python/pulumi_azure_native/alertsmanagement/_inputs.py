# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ActionGroupsInformationArgs',
    'ActionGroupsInformationArgsDict',
    'ActionGroupArgs',
    'ActionGroupArgsDict',
    'AddActionGroupsArgs',
    'AddActionGroupsArgsDict',
    'AlertProcessingRulePropertiesArgs',
    'AlertProcessingRulePropertiesArgsDict',
    'ConditionsArgs',
    'ConditionsArgsDict',
    'ConditionArgs',
    'ConditionArgsDict',
    'DailyRecurrenceArgs',
    'DailyRecurrenceArgsDict',
    'DetectorArgs',
    'DetectorArgsDict',
    'DiagnosticsArgs',
    'DiagnosticsArgsDict',
    'IssuePropertiesArgs',
    'IssuePropertiesArgsDict',
    'MonthlyRecurrenceArgs',
    'MonthlyRecurrenceArgsDict',
    'PrometheusRuleGroupActionArgs',
    'PrometheusRuleGroupActionArgsDict',
    'PrometheusRuleResolveConfigurationArgs',
    'PrometheusRuleResolveConfigurationArgsDict',
    'PrometheusRuleArgs',
    'PrometheusRuleArgsDict',
    'RemoveAllActionGroupsArgs',
    'RemoveAllActionGroupsArgsDict',
    'ScheduleArgs',
    'ScheduleArgsDict',
    'ScopeArgs',
    'ScopeArgsDict',
    'SuppressionConfigArgs',
    'SuppressionConfigArgsDict',
    'SuppressionScheduleArgs',
    'SuppressionScheduleArgsDict',
    'SuppressionArgs',
    'SuppressionArgsDict',
    'ThrottlingInformationArgs',
    'ThrottlingInformationArgsDict',
    'WeeklyRecurrenceArgs',
    'WeeklyRecurrenceArgsDict',
]

MYPY = False

if not MYPY:
    class ActionGroupsInformationArgsDict(TypedDict):
        """
        The Action Groups information, used by the alert rule.
        """
        group_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The Action Group resource IDs.
        """
        custom_email_subject: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional custom email subject to use in email notifications.
        """
        custom_webhook_payload: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional custom web-hook payload to use in web-hook notifications.
        """
elif False:
    ActionGroupsInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupsInformationArgs:
    def __init__(__self__, *,
                 group_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 custom_email_subject: Optional[pulumi.Input[builtins.str]] = None,
                 custom_webhook_payload: Optional[pulumi.Input[builtins.str]] = None):
        """
        The Action Groups information, used by the alert rule.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] group_ids: The Action Group resource IDs.
        :param pulumi.Input[builtins.str] custom_email_subject: An optional custom email subject to use in email notifications.
        :param pulumi.Input[builtins.str] custom_webhook_payload: An optional custom web-hook payload to use in web-hook notifications.
        """
        pulumi.set(__self__, "group_ids", group_ids)
        if custom_email_subject is not None:
            pulumi.set(__self__, "custom_email_subject", custom_email_subject)
        if custom_webhook_payload is not None:
            pulumi.set(__self__, "custom_webhook_payload", custom_webhook_payload)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The Action Group resource IDs.
        """
        return pulumi.get(self, "group_ids")

    @group_ids.setter
    def group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "group_ids", value)

    @property
    @pulumi.getter(name="customEmailSubject")
    def custom_email_subject(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional custom email subject to use in email notifications.
        """
        return pulumi.get(self, "custom_email_subject")

    @custom_email_subject.setter
    def custom_email_subject(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_email_subject", value)

    @property
    @pulumi.getter(name="customWebhookPayload")
    def custom_webhook_payload(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional custom web-hook payload to use in web-hook notifications.
        """
        return pulumi.get(self, "custom_webhook_payload")

    @custom_webhook_payload.setter
    def custom_webhook_payload(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_webhook_payload", value)


if not MYPY:
    class ActionGroupArgsDict(TypedDict):
        """
        Action rule with action group configuration
        """
        action_group_id: pulumi.Input[builtins.str]
        """
        Action group to trigger if action rule matches
        """
        type: pulumi.Input[builtins.str]
        """
        Indicates type of action rule
        Expected value is 'ActionGroup'.
        """
        conditions: NotRequired[pulumi.Input['ConditionsArgsDict']]
        """
        conditions on which alerts will be filtered
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of action rule
        """
        scope: NotRequired[pulumi.Input['ScopeArgsDict']]
        """
        scope on which action rule will apply
        """
        status: NotRequired[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]]
        """
        Indicates if the given action rule is enabled or disabled
        """
elif False:
    ActionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionGroupArgs:
    def __init__(__self__, *,
                 action_group_id: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 conditions: Optional[pulumi.Input['ConditionsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 scope: Optional[pulumi.Input['ScopeArgs']] = None,
                 status: Optional[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]] = None):
        """
        Action rule with action group configuration
        :param pulumi.Input[builtins.str] action_group_id: Action group to trigger if action rule matches
        :param pulumi.Input[builtins.str] type: Indicates type of action rule
               Expected value is 'ActionGroup'.
        :param pulumi.Input['ConditionsArgs'] conditions: conditions on which alerts will be filtered
        :param pulumi.Input[builtins.str] description: Description of action rule
        :param pulumi.Input['ScopeArgs'] scope: scope on which action rule will apply
        :param pulumi.Input[Union[builtins.str, 'ActionRuleStatus']] status: Indicates if the given action rule is enabled or disabled
        """
        pulumi.set(__self__, "action_group_id", action_group_id)
        pulumi.set(__self__, "type", 'ActionGroup')
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> pulumi.Input[builtins.str]:
        """
        Action group to trigger if action rule matches
        """
        return pulumi.get(self, "action_group_id")

    @action_group_id.setter
    def action_group_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action_group_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Indicates type of action rule
        Expected value is 'ActionGroup'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input['ConditionsArgs']]:
        """
        conditions on which alerts will be filtered
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input['ConditionsArgs']]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of action rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['ScopeArgs']]:
        """
        scope on which action rule will apply
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['ScopeArgs']]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]]:
        """
        Indicates if the given action rule is enabled or disabled
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class AddActionGroupsArgsDict(TypedDict):
        """
        Add action groups to alert processing rule.
        """
        action_group_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of action group Ids to add to alert processing rule.
        """
        action_type: pulumi.Input[builtins.str]
        """
        Action that should be applied.
        Expected value is 'AddActionGroups'.
        """
elif False:
    AddActionGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddActionGroupsArgs:
    def __init__(__self__, *,
                 action_group_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 action_type: pulumi.Input[builtins.str]):
        """
        Add action groups to alert processing rule.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] action_group_ids: List of action group Ids to add to alert processing rule.
        :param pulumi.Input[builtins.str] action_type: Action that should be applied.
               Expected value is 'AddActionGroups'.
        """
        pulumi.set(__self__, "action_group_ids", action_group_ids)
        pulumi.set(__self__, "action_type", 'AddActionGroups')

    @property
    @pulumi.getter(name="actionGroupIds")
    def action_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of action group Ids to add to alert processing rule.
        """
        return pulumi.get(self, "action_group_ids")

    @action_group_ids.setter
    def action_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "action_group_ids", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[builtins.str]:
        """
        Action that should be applied.
        Expected value is 'AddActionGroups'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action_type", value)


if not MYPY:
    class AlertProcessingRulePropertiesArgsDict(TypedDict):
        """
        Alert processing rule properties defining scopes, conditions and scheduling logic for alert processing rule.
        """
        actions: pulumi.Input[Sequence[pulumi.Input[Union['AddActionGroupsArgsDict', 'RemoveAllActionGroupsArgsDict']]]]
        """
        Actions to be applied.
        """
        scopes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Scopes on which alert processing rule will apply.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConditionArgsDict']]]]
        """
        Conditions on which alerts will be filtered.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of alert processing rule.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the given alert processing rule is enabled or disabled.
        """
        schedule: NotRequired[pulumi.Input['ScheduleArgsDict']]
        """
        Scheduling for alert processing rule.
        """
elif False:
    AlertProcessingRulePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertProcessingRulePropertiesArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[Union['AddActionGroupsArgs', 'RemoveAllActionGroupsArgs']]]],
                 scopes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ConditionArgs']]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 schedule: Optional[pulumi.Input['ScheduleArgs']] = None):
        """
        Alert processing rule properties defining scopes, conditions and scheduling logic for alert processing rule.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AddActionGroupsArgs', 'RemoveAllActionGroupsArgs']]]] actions: Actions to be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes on which alert processing rule will apply.
        :param pulumi.Input[Sequence[pulumi.Input['ConditionArgs']]] conditions: Conditions on which alerts will be filtered.
        :param pulumi.Input[builtins.str] description: Description of alert processing rule.
        :param pulumi.Input[builtins.bool] enabled: Indicates if the given alert processing rule is enabled or disabled.
        :param pulumi.Input['ScheduleArgs'] schedule: Scheduling for alert processing rule.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "scopes", scopes)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is None:
            enabled = True
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[Union['AddActionGroupsArgs', 'RemoveAllActionGroupsArgs']]]]:
        """
        Actions to be applied.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[Union['AddActionGroupsArgs', 'RemoveAllActionGroupsArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def scopes(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Scopes on which alert processing rule will apply.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConditionArgs']]]]:
        """
        Conditions on which alerts will be filtered.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of alert processing rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the given alert processing rule is enabled or disabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['ScheduleArgs']]:
        """
        Scheduling for alert processing rule.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['ScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class ConditionsArgsDict(TypedDict):
        """
        Conditions in alert instance to be matched for a given action rule. Default value is all. Multiple values could be provided with comma separation.
        """
        alert_context: NotRequired[pulumi.Input['ConditionArgsDict']]
        """
        filter alerts by alert context (payload)
        """
        alert_rule_id: NotRequired[pulumi.Input['ConditionArgsDict']]
        """
        filter alerts by alert rule id
        """
        alert_rule_name: NotRequired[pulumi.Input['ConditionArgsDict']]
        """
        filter alerts by alert rule name
        """
        description: NotRequired[pulumi.Input['ConditionArgsDict']]
        """
        filter alerts by alert rule description
        """
        monitor_condition: NotRequired[pulumi.Input['ConditionArgsDict']]
        """
        filter alerts by monitor condition
        """
        monitor_service: NotRequired[pulumi.Input['ConditionArgsDict']]
        """
        filter alerts by monitor service
        """
        severity: NotRequired[pulumi.Input['ConditionArgsDict']]
        """
        filter alerts by severity
        """
        target_resource_type: NotRequired[pulumi.Input['ConditionArgsDict']]
        """
        filter alerts by target resource type
        """
elif False:
    ConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConditionsArgs:
    def __init__(__self__, *,
                 alert_context: Optional[pulumi.Input['ConditionArgs']] = None,
                 alert_rule_id: Optional[pulumi.Input['ConditionArgs']] = None,
                 alert_rule_name: Optional[pulumi.Input['ConditionArgs']] = None,
                 description: Optional[pulumi.Input['ConditionArgs']] = None,
                 monitor_condition: Optional[pulumi.Input['ConditionArgs']] = None,
                 monitor_service: Optional[pulumi.Input['ConditionArgs']] = None,
                 severity: Optional[pulumi.Input['ConditionArgs']] = None,
                 target_resource_type: Optional[pulumi.Input['ConditionArgs']] = None):
        """
        Conditions in alert instance to be matched for a given action rule. Default value is all. Multiple values could be provided with comma separation.
        :param pulumi.Input['ConditionArgs'] alert_context: filter alerts by alert context (payload)
        :param pulumi.Input['ConditionArgs'] alert_rule_id: filter alerts by alert rule id
        :param pulumi.Input['ConditionArgs'] alert_rule_name: filter alerts by alert rule name
        :param pulumi.Input['ConditionArgs'] description: filter alerts by alert rule description
        :param pulumi.Input['ConditionArgs'] monitor_condition: filter alerts by monitor condition
        :param pulumi.Input['ConditionArgs'] monitor_service: filter alerts by monitor service
        :param pulumi.Input['ConditionArgs'] severity: filter alerts by severity
        :param pulumi.Input['ConditionArgs'] target_resource_type: filter alerts by target resource type
        """
        if alert_context is not None:
            pulumi.set(__self__, "alert_context", alert_context)
        if alert_rule_id is not None:
            pulumi.set(__self__, "alert_rule_id", alert_rule_id)
        if alert_rule_name is not None:
            pulumi.set(__self__, "alert_rule_name", alert_rule_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if monitor_condition is not None:
            pulumi.set(__self__, "monitor_condition", monitor_condition)
        if monitor_service is not None:
            pulumi.set(__self__, "monitor_service", monitor_service)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if target_resource_type is not None:
            pulumi.set(__self__, "target_resource_type", target_resource_type)

    @property
    @pulumi.getter(name="alertContext")
    def alert_context(self) -> Optional[pulumi.Input['ConditionArgs']]:
        """
        filter alerts by alert context (payload)
        """
        return pulumi.get(self, "alert_context")

    @alert_context.setter
    def alert_context(self, value: Optional[pulumi.Input['ConditionArgs']]):
        pulumi.set(self, "alert_context", value)

    @property
    @pulumi.getter(name="alertRuleId")
    def alert_rule_id(self) -> Optional[pulumi.Input['ConditionArgs']]:
        """
        filter alerts by alert rule id
        """
        return pulumi.get(self, "alert_rule_id")

    @alert_rule_id.setter
    def alert_rule_id(self, value: Optional[pulumi.Input['ConditionArgs']]):
        pulumi.set(self, "alert_rule_id", value)

    @property
    @pulumi.getter(name="alertRuleName")
    def alert_rule_name(self) -> Optional[pulumi.Input['ConditionArgs']]:
        """
        filter alerts by alert rule name
        """
        return pulumi.get(self, "alert_rule_name")

    @alert_rule_name.setter
    def alert_rule_name(self, value: Optional[pulumi.Input['ConditionArgs']]):
        pulumi.set(self, "alert_rule_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input['ConditionArgs']]:
        """
        filter alerts by alert rule description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input['ConditionArgs']]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="monitorCondition")
    def monitor_condition(self) -> Optional[pulumi.Input['ConditionArgs']]:
        """
        filter alerts by monitor condition
        """
        return pulumi.get(self, "monitor_condition")

    @monitor_condition.setter
    def monitor_condition(self, value: Optional[pulumi.Input['ConditionArgs']]):
        pulumi.set(self, "monitor_condition", value)

    @property
    @pulumi.getter(name="monitorService")
    def monitor_service(self) -> Optional[pulumi.Input['ConditionArgs']]:
        """
        filter alerts by monitor service
        """
        return pulumi.get(self, "monitor_service")

    @monitor_service.setter
    def monitor_service(self, value: Optional[pulumi.Input['ConditionArgs']]):
        pulumi.set(self, "monitor_service", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input['ConditionArgs']]:
        """
        filter alerts by severity
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input['ConditionArgs']]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> Optional[pulumi.Input['ConditionArgs']]:
        """
        filter alerts by target resource type
        """
        return pulumi.get(self, "target_resource_type")

    @target_resource_type.setter
    def target_resource_type(self, value: Optional[pulumi.Input['ConditionArgs']]):
        pulumi.set(self, "target_resource_type", value)


if not MYPY:
    class ConditionArgsDict(TypedDict):
        """
        Condition to trigger an alert processing rule.
        """
        field: NotRequired[pulumi.Input[Union[builtins.str, 'Field']]]
        """
        Field for a given condition.
        """
        operator: NotRequired[pulumi.Input[Union[builtins.str, 'Operator']]]
        """
        Operator for a given condition.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of values to match for a given condition.
        """
elif False:
    ConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConditionArgs:
    def __init__(__self__, *,
                 field: Optional[pulumi.Input[Union[builtins.str, 'Field']]] = None,
                 operator: Optional[pulumi.Input[Union[builtins.str, 'Operator']]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Condition to trigger an alert processing rule.
        :param pulumi.Input[Union[builtins.str, 'Field']] field: Field for a given condition.
        :param pulumi.Input[Union[builtins.str, 'Operator']] operator: Operator for a given condition.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: List of values to match for a given condition.
        """
        if field is not None:
            pulumi.set(__self__, "field", field)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[Union[builtins.str, 'Field']]]:
        """
        Field for a given condition.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[Union[builtins.str, 'Field']]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[builtins.str, 'Operator']]]:
        """
        Operator for a given condition.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[builtins.str, 'Operator']]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of values to match for a given condition.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DailyRecurrenceArgsDict(TypedDict):
        """
        Daily recurrence object.
        """
        end_time: pulumi.Input[builtins.str]
        """
        End time for recurrence.
        """
        recurrence_type: pulumi.Input[builtins.str]
        """
        Specifies when the recurrence should be applied.
        Expected value is 'Daily'.
        """
        start_time: pulumi.Input[builtins.str]
        """
        Start time for recurrence.
        """
elif False:
    DailyRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DailyRecurrenceArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[builtins.str],
                 recurrence_type: pulumi.Input[builtins.str],
                 start_time: pulumi.Input[builtins.str]):
        """
        Daily recurrence object.
        :param pulumi.Input[builtins.str] end_time: End time for recurrence.
        :param pulumi.Input[builtins.str] recurrence_type: Specifies when the recurrence should be applied.
               Expected value is 'Daily'.
        :param pulumi.Input[builtins.str] start_time: Start time for recurrence.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "recurrence_type", 'Daily')
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[builtins.str]:
        """
        End time for recurrence.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> pulumi.Input[builtins.str]:
        """
        Specifies when the recurrence should be applied.
        Expected value is 'Daily'.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "recurrence_type", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[builtins.str]:
        """
        Start time for recurrence.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class DetectorArgsDict(TypedDict):
        """
        The detector information. By default this is not populated, unless it's specified in expandDetector
        """
        id: pulumi.Input[builtins.str]
        """
        The detector id.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, Any]]]
        """
        The detector's parameters.'
        """
elif False:
    DetectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DetectorArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        The detector information. By default this is not populated, unless it's specified in expandDetector
        :param pulumi.Input[builtins.str] id: The detector id.
        :param pulumi.Input[Mapping[str, Any]] parameters: The detector's parameters.'
        """
        pulumi.set(__self__, "id", id)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The detector id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The detector's parameters.'
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DiagnosticsArgsDict(TypedDict):
        """
        Action rule with diagnostics configuration
        """
        type: pulumi.Input[builtins.str]
        """
        Indicates type of action rule
        Expected value is 'Diagnostics'.
        """
        conditions: NotRequired[pulumi.Input['ConditionsArgsDict']]
        """
        conditions on which alerts will be filtered
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of action rule
        """
        scope: NotRequired[pulumi.Input['ScopeArgsDict']]
        """
        scope on which action rule will apply
        """
        status: NotRequired[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]]
        """
        Indicates if the given action rule is enabled or disabled
        """
elif False:
    DiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosticsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 conditions: Optional[pulumi.Input['ConditionsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 scope: Optional[pulumi.Input['ScopeArgs']] = None,
                 status: Optional[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]] = None):
        """
        Action rule with diagnostics configuration
        :param pulumi.Input[builtins.str] type: Indicates type of action rule
               Expected value is 'Diagnostics'.
        :param pulumi.Input['ConditionsArgs'] conditions: conditions on which alerts will be filtered
        :param pulumi.Input[builtins.str] description: Description of action rule
        :param pulumi.Input['ScopeArgs'] scope: scope on which action rule will apply
        :param pulumi.Input[Union[builtins.str, 'ActionRuleStatus']] status: Indicates if the given action rule is enabled or disabled
        """
        pulumi.set(__self__, "type", 'Diagnostics')
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Indicates type of action rule
        Expected value is 'Diagnostics'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input['ConditionsArgs']]:
        """
        conditions on which alerts will be filtered
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input['ConditionsArgs']]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of action rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['ScopeArgs']]:
        """
        scope on which action rule will apply
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['ScopeArgs']]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]]:
        """
        Indicates if the given action rule is enabled or disabled
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class IssuePropertiesArgsDict(TypedDict):
        """
        The issue properties
        """
        impact_time: pulumi.Input[builtins.str]
        """
        The issue impact time (in UTC)
        """
        severity: pulumi.Input[builtins.str]
        """
        The issue severity
        """
        status: pulumi.Input[Union[builtins.str, 'Status']]
        """
        The issue status
        """
        title: pulumi.Input[builtins.str]
        """
        The issue title
        """
elif False:
    IssuePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IssuePropertiesArgs:
    def __init__(__self__, *,
                 impact_time: pulumi.Input[builtins.str],
                 severity: pulumi.Input[builtins.str],
                 status: pulumi.Input[Union[builtins.str, 'Status']],
                 title: pulumi.Input[builtins.str]):
        """
        The issue properties
        :param pulumi.Input[builtins.str] impact_time: The issue impact time (in UTC)
        :param pulumi.Input[builtins.str] severity: The issue severity
        :param pulumi.Input[Union[builtins.str, 'Status']] status: The issue status
        :param pulumi.Input[builtins.str] title: The issue title
        """
        pulumi.set(__self__, "impact_time", impact_time)
        pulumi.set(__self__, "severity", severity)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="impactTime")
    def impact_time(self) -> pulumi.Input[builtins.str]:
        """
        The issue impact time (in UTC)
        """
        return pulumi.get(self, "impact_time")

    @impact_time.setter
    def impact_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "impact_time", value)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[builtins.str]:
        """
        The issue severity
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[builtins.str, 'Status']]:
        """
        The issue status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[builtins.str, 'Status']]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        """
        The issue title
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)


if not MYPY:
    class MonthlyRecurrenceArgsDict(TypedDict):
        """
        Monthly recurrence object.
        """
        days_of_month: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]
        """
        Specifies the values for monthly recurrence pattern.
        """
        recurrence_type: pulumi.Input[builtins.str]
        """
        Specifies when the recurrence should be applied.
        Expected value is 'Monthly'.
        """
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        End time for recurrence.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Start time for recurrence.
        """
elif False:
    MonthlyRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonthlyRecurrenceArgs:
    def __init__(__self__, *,
                 days_of_month: pulumi.Input[Sequence[pulumi.Input[builtins.int]]],
                 recurrence_type: pulumi.Input[builtins.str],
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Monthly recurrence object.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] days_of_month: Specifies the values for monthly recurrence pattern.
        :param pulumi.Input[builtins.str] recurrence_type: Specifies when the recurrence should be applied.
               Expected value is 'Monthly'.
        :param pulumi.Input[builtins.str] end_time: End time for recurrence.
        :param pulumi.Input[builtins.str] start_time: Start time for recurrence.
        """
        pulumi.set(__self__, "days_of_month", days_of_month)
        pulumi.set(__self__, "recurrence_type", 'Monthly')
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfMonth")
    def days_of_month(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.int]]]:
        """
        Specifies the values for monthly recurrence pattern.
        """
        return pulumi.get(self, "days_of_month")

    @days_of_month.setter
    def days_of_month(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(self, "days_of_month", value)

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> pulumi.Input[builtins.str]:
        """
        Specifies when the recurrence should be applied.
        Expected value is 'Monthly'.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "recurrence_type", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End time for recurrence.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start time for recurrence.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class PrometheusRuleGroupActionArgsDict(TypedDict):
        """
        An alert action. Only relevant for alerts.
        """
        action_group_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The resource id of the action group to use.
        """
        action_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        The properties of an action group object.
        """
elif False:
    PrometheusRuleGroupActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusRuleGroupActionArgs:
    def __init__(__self__, *,
                 action_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 action_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        An alert action. Only relevant for alerts.
        :param pulumi.Input[builtins.str] action_group_id: The resource id of the action group to use.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] action_properties: The properties of an action group object.
        """
        if action_group_id is not None:
            pulumi.set(__self__, "action_group_id", action_group_id)
        if action_properties is not None:
            pulumi.set(__self__, "action_properties", action_properties)

    @property
    @pulumi.getter(name="actionGroupId")
    def action_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The resource id of the action group to use.
        """
        return pulumi.get(self, "action_group_id")

    @action_group_id.setter
    def action_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action_group_id", value)

    @property
    @pulumi.getter(name="actionProperties")
    def action_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        The properties of an action group object.
        """
        return pulumi.get(self, "action_properties")

    @action_properties.setter
    def action_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "action_properties", value)


if not MYPY:
    class PrometheusRuleResolveConfigurationArgsDict(TypedDict):
        """
        Specifies the Prometheus alert rule configuration.
        """
        auto_resolved: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable alert auto-resolution.
        """
        time_to_resolve: NotRequired[pulumi.Input[builtins.str]]
        """
        Alert auto-resolution timeout.
        """
elif False:
    PrometheusRuleResolveConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusRuleResolveConfigurationArgs:
    def __init__(__self__, *,
                 auto_resolved: Optional[pulumi.Input[builtins.bool]] = None,
                 time_to_resolve: Optional[pulumi.Input[builtins.str]] = None):
        """
        Specifies the Prometheus alert rule configuration.
        :param pulumi.Input[builtins.bool] auto_resolved: Enable alert auto-resolution.
        :param pulumi.Input[builtins.str] time_to_resolve: Alert auto-resolution timeout.
        """
        if auto_resolved is not None:
            pulumi.set(__self__, "auto_resolved", auto_resolved)
        if time_to_resolve is not None:
            pulumi.set(__self__, "time_to_resolve", time_to_resolve)

    @property
    @pulumi.getter(name="autoResolved")
    def auto_resolved(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable alert auto-resolution.
        """
        return pulumi.get(self, "auto_resolved")

    @auto_resolved.setter
    def auto_resolved(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auto_resolved", value)

    @property
    @pulumi.getter(name="timeToResolve")
    def time_to_resolve(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Alert auto-resolution timeout.
        """
        return pulumi.get(self, "time_to_resolve")

    @time_to_resolve.setter
    def time_to_resolve(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_to_resolve", value)


if not MYPY:
    class PrometheusRuleArgsDict(TypedDict):
        """
        An Azure Prometheus alerting or recording rule.
        """
        expression: pulumi.Input[builtins.str]
        """
        The PromQL expression to evaluate. https://prometheus.io/docs/prometheus/latest/querying/basics/. Evaluated periodically as given by 'interval', and the result recorded as a new set of time series with the metric name as given by 'record'.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrometheusRuleGroupActionArgsDict']]]]
        """
        Actions that are performed when the alert rule becomes active, and when an alert condition is resolved.
        """
        alert: NotRequired[pulumi.Input[builtins.str]]
        """
        Alert rule name.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        The annotations clause specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links. The annotation values can be templated.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable/disable rule.
        """
        for_: NotRequired[pulumi.Input[builtins.str]]
        """
        The amount of time alert must be active before firing.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Labels to add or overwrite before storing the result.
        """
        record: NotRequired[pulumi.Input[builtins.str]]
        """
        Recorded metrics name.
        """
        resolve_configuration: NotRequired[pulumi.Input['PrometheusRuleResolveConfigurationArgsDict']]
        """
        Defines the configuration for resolving fired alerts. Only relevant for alerts.
        """
        severity: NotRequired[pulumi.Input[builtins.int]]
        """
        The severity of the alerts fired by the rule. Must be between 0 and 4.
        """
elif False:
    PrometheusRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusRuleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['PrometheusRuleGroupActionArgs']]]] = None,
                 alert: Optional[pulumi.Input[builtins.str]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 for_: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 record: Optional[pulumi.Input[builtins.str]] = None,
                 resolve_configuration: Optional[pulumi.Input['PrometheusRuleResolveConfigurationArgs']] = None,
                 severity: Optional[pulumi.Input[builtins.int]] = None):
        """
        An Azure Prometheus alerting or recording rule.
        :param pulumi.Input[builtins.str] expression: The PromQL expression to evaluate. https://prometheus.io/docs/prometheus/latest/querying/basics/. Evaluated periodically as given by 'interval', and the result recorded as a new set of time series with the metric name as given by 'record'.
        :param pulumi.Input[Sequence[pulumi.Input['PrometheusRuleGroupActionArgs']]] actions: Actions that are performed when the alert rule becomes active, and when an alert condition is resolved.
        :param pulumi.Input[builtins.str] alert: Alert rule name.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] annotations: The annotations clause specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links. The annotation values can be templated.
        :param pulumi.Input[builtins.bool] enabled: Enable/disable rule.
        :param pulumi.Input[builtins.str] for_: The amount of time alert must be active before firing.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Labels to add or overwrite before storing the result.
        :param pulumi.Input[builtins.str] record: Recorded metrics name.
        :param pulumi.Input['PrometheusRuleResolveConfigurationArgs'] resolve_configuration: Defines the configuration for resolving fired alerts. Only relevant for alerts.
        :param pulumi.Input[builtins.int] severity: The severity of the alerts fired by the rule. Must be between 0 and 4.
        """
        pulumi.set(__self__, "expression", expression)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if for_ is not None:
            pulumi.set(__self__, "for_", for_)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if record is not None:
            pulumi.set(__self__, "record", record)
        if resolve_configuration is not None:
            pulumi.set(__self__, "resolve_configuration", resolve_configuration)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        """
        The PromQL expression to evaluate. https://prometheus.io/docs/prometheus/latest/querying/basics/. Evaluated periodically as given by 'interval', and the result recorded as a new set of time series with the metric name as given by 'record'.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrometheusRuleGroupActionArgs']]]]:
        """
        Actions that are performed when the alert rule becomes active, and when an alert condition is resolved.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrometheusRuleGroupActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Alert rule name.
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        The annotations clause specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links. The annotation values can be templated.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable/disable rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="for")
    def for_(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The amount of time alert must be active before firing.
        """
        return pulumi.get(self, "for_")

    @for_.setter
    def for_(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "for_", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Labels to add or overwrite before storing the result.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def record(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Recorded metrics name.
        """
        return pulumi.get(self, "record")

    @record.setter
    def record(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "record", value)

    @property
    @pulumi.getter(name="resolveConfiguration")
    def resolve_configuration(self) -> Optional[pulumi.Input['PrometheusRuleResolveConfigurationArgs']]:
        """
        Defines the configuration for resolving fired alerts. Only relevant for alerts.
        """
        return pulumi.get(self, "resolve_configuration")

    @resolve_configuration.setter
    def resolve_configuration(self, value: Optional[pulumi.Input['PrometheusRuleResolveConfigurationArgs']]):
        pulumi.set(self, "resolve_configuration", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The severity of the alerts fired by the rule. Must be between 0 and 4.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class RemoveAllActionGroupsArgsDict(TypedDict):
        """
        Indicates if all action groups should be removed.
        """
        action_type: pulumi.Input[builtins.str]
        """
        Action that should be applied.
        Expected value is 'RemoveAllActionGroups'.
        """
elif False:
    RemoveAllActionGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoveAllActionGroupsArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[builtins.str]):
        """
        Indicates if all action groups should be removed.
        :param pulumi.Input[builtins.str] action_type: Action that should be applied.
               Expected value is 'RemoveAllActionGroups'.
        """
        pulumi.set(__self__, "action_type", 'RemoveAllActionGroups')

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[builtins.str]:
        """
        Action that should be applied.
        Expected value is 'RemoveAllActionGroups'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "action_type", value)


if not MYPY:
    class ScheduleArgsDict(TypedDict):
        """
        Scheduling configuration for a given alert processing rule.
        """
        effective_from: NotRequired[pulumi.Input[builtins.str]]
        """
        Scheduling effective from time. Date-Time in ISO-8601 format without timezone suffix.
        """
        effective_until: NotRequired[pulumi.Input[builtins.str]]
        """
        Scheduling effective until time. Date-Time in ISO-8601 format without timezone suffix.
        """
        recurrences: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['DailyRecurrenceArgsDict', 'MonthlyRecurrenceArgsDict', 'WeeklyRecurrenceArgsDict']]]]]
        """
        List of recurrences.
        """
        time_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        Scheduling time zone.
        """
elif False:
    ScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleArgs:
    def __init__(__self__, *,
                 effective_from: Optional[pulumi.Input[builtins.str]] = None,
                 effective_until: Optional[pulumi.Input[builtins.str]] = None,
                 recurrences: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DailyRecurrenceArgs', 'MonthlyRecurrenceArgs', 'WeeklyRecurrenceArgs']]]]] = None,
                 time_zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        Scheduling configuration for a given alert processing rule.
        :param pulumi.Input[builtins.str] effective_from: Scheduling effective from time. Date-Time in ISO-8601 format without timezone suffix.
        :param pulumi.Input[builtins.str] effective_until: Scheduling effective until time. Date-Time in ISO-8601 format without timezone suffix.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DailyRecurrenceArgs', 'MonthlyRecurrenceArgs', 'WeeklyRecurrenceArgs']]]] recurrences: List of recurrences.
        :param pulumi.Input[builtins.str] time_zone: Scheduling time zone.
        """
        if effective_from is not None:
            pulumi.set(__self__, "effective_from", effective_from)
        if effective_until is not None:
            pulumi.set(__self__, "effective_until", effective_until)
        if recurrences is not None:
            pulumi.set(__self__, "recurrences", recurrences)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="effectiveFrom")
    def effective_from(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Scheduling effective from time. Date-Time in ISO-8601 format without timezone suffix.
        """
        return pulumi.get(self, "effective_from")

    @effective_from.setter
    def effective_from(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effective_from", value)

    @property
    @pulumi.getter(name="effectiveUntil")
    def effective_until(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Scheduling effective until time. Date-Time in ISO-8601 format without timezone suffix.
        """
        return pulumi.get(self, "effective_until")

    @effective_until.setter
    def effective_until(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effective_until", value)

    @property
    @pulumi.getter
    def recurrences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DailyRecurrenceArgs', 'MonthlyRecurrenceArgs', 'WeeklyRecurrenceArgs']]]]]:
        """
        List of recurrences.
        """
        return pulumi.get(self, "recurrences")

    @recurrences.setter
    def recurrences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DailyRecurrenceArgs', 'MonthlyRecurrenceArgs', 'WeeklyRecurrenceArgs']]]]]):
        pulumi.set(self, "recurrences", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Scheduling time zone.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class ScopeArgsDict(TypedDict):
        """
        Target scope for a given action rule. By default scope will be the subscription. User can also provide list of resource groups or list of resources from the scope subscription as well.
        """
        scope_type: NotRequired[pulumi.Input[Union[builtins.str, 'ScopeType']]]
        """
        type of target scope
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        list of ARM IDs of the given scope type which will be the target of the given action rule.
        """
elif False:
    ScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScopeArgs:
    def __init__(__self__, *,
                 scope_type: Optional[pulumi.Input[Union[builtins.str, 'ScopeType']]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Target scope for a given action rule. By default scope will be the subscription. User can also provide list of resource groups or list of resources from the scope subscription as well.
        :param pulumi.Input[Union[builtins.str, 'ScopeType']] scope_type: type of target scope
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: list of ARM IDs of the given scope type which will be the target of the given action rule.
        """
        if scope_type is not None:
            pulumi.set(__self__, "scope_type", scope_type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="scopeType")
    def scope_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ScopeType']]]:
        """
        type of target scope
        """
        return pulumi.get(self, "scope_type")

    @scope_type.setter
    def scope_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ScopeType']]]):
        pulumi.set(self, "scope_type", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        list of ARM IDs of the given scope type which will be the target of the given action rule.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SuppressionConfigArgsDict(TypedDict):
        """
        Suppression logic for a given action rule
        """
        recurrence_type: pulumi.Input[Union[builtins.str, 'SuppressionType']]
        """
        Specifies when the suppression should be applied
        """
        schedule: NotRequired[pulumi.Input['SuppressionScheduleArgsDict']]
        """
        suppression schedule configuration
        """
elif False:
    SuppressionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SuppressionConfigArgs:
    def __init__(__self__, *,
                 recurrence_type: pulumi.Input[Union[builtins.str, 'SuppressionType']],
                 schedule: Optional[pulumi.Input['SuppressionScheduleArgs']] = None):
        """
        Suppression logic for a given action rule
        :param pulumi.Input[Union[builtins.str, 'SuppressionType']] recurrence_type: Specifies when the suppression should be applied
        :param pulumi.Input['SuppressionScheduleArgs'] schedule: suppression schedule configuration
        """
        pulumi.set(__self__, "recurrence_type", recurrence_type)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> pulumi.Input[Union[builtins.str, 'SuppressionType']]:
        """
        Specifies when the suppression should be applied
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: pulumi.Input[Union[builtins.str, 'SuppressionType']]):
        pulumi.set(self, "recurrence_type", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['SuppressionScheduleArgs']]:
        """
        suppression schedule configuration
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['SuppressionScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class SuppressionScheduleArgsDict(TypedDict):
        """
        Schedule for a given suppression configuration.
        """
        end_date: NotRequired[pulumi.Input[builtins.str]]
        """
        End date for suppression
        """
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        End date for suppression
        """
        recurrence_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        Specifies the values for recurrence pattern
        """
        start_date: NotRequired[pulumi.Input[builtins.str]]
        """
        Start date for suppression
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Start time for suppression
        """
elif False:
    SuppressionScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SuppressionScheduleArgs:
    def __init__(__self__, *,
                 end_date: Optional[pulumi.Input[builtins.str]] = None,
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 recurrence_values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 start_date: Optional[pulumi.Input[builtins.str]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Schedule for a given suppression configuration.
        :param pulumi.Input[builtins.str] end_date: End date for suppression
        :param pulumi.Input[builtins.str] end_time: End date for suppression
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] recurrence_values: Specifies the values for recurrence pattern
        :param pulumi.Input[builtins.str] start_date: Start date for suppression
        :param pulumi.Input[builtins.str] start_time: Start time for suppression
        """
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_values is not None:
            pulumi.set(__self__, "recurrence_values", recurrence_values)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End date for suppression
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End date for suppression
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="recurrenceValues")
    def recurrence_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        Specifies the values for recurrence pattern
        """
        return pulumi.get(self, "recurrence_values")

    @recurrence_values.setter
    def recurrence_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "recurrence_values", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start date for suppression
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start time for suppression
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class SuppressionArgsDict(TypedDict):
        """
        Action rule with suppression configuration
        """
        suppression_config: pulumi.Input['SuppressionConfigArgsDict']
        """
        suppression configuration for the action rule
        """
        type: pulumi.Input[builtins.str]
        """
        Indicates type of action rule
        Expected value is 'Suppression'.
        """
        conditions: NotRequired[pulumi.Input['ConditionsArgsDict']]
        """
        conditions on which alerts will be filtered
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of action rule
        """
        scope: NotRequired[pulumi.Input['ScopeArgsDict']]
        """
        scope on which action rule will apply
        """
        status: NotRequired[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]]
        """
        Indicates if the given action rule is enabled or disabled
        """
elif False:
    SuppressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SuppressionArgs:
    def __init__(__self__, *,
                 suppression_config: pulumi.Input['SuppressionConfigArgs'],
                 type: pulumi.Input[builtins.str],
                 conditions: Optional[pulumi.Input['ConditionsArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 scope: Optional[pulumi.Input['ScopeArgs']] = None,
                 status: Optional[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]] = None):
        """
        Action rule with suppression configuration
        :param pulumi.Input['SuppressionConfigArgs'] suppression_config: suppression configuration for the action rule
        :param pulumi.Input[builtins.str] type: Indicates type of action rule
               Expected value is 'Suppression'.
        :param pulumi.Input['ConditionsArgs'] conditions: conditions on which alerts will be filtered
        :param pulumi.Input[builtins.str] description: Description of action rule
        :param pulumi.Input['ScopeArgs'] scope: scope on which action rule will apply
        :param pulumi.Input[Union[builtins.str, 'ActionRuleStatus']] status: Indicates if the given action rule is enabled or disabled
        """
        pulumi.set(__self__, "suppression_config", suppression_config)
        pulumi.set(__self__, "type", 'Suppression')
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="suppressionConfig")
    def suppression_config(self) -> pulumi.Input['SuppressionConfigArgs']:
        """
        suppression configuration for the action rule
        """
        return pulumi.get(self, "suppression_config")

    @suppression_config.setter
    def suppression_config(self, value: pulumi.Input['SuppressionConfigArgs']):
        pulumi.set(self, "suppression_config", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Indicates type of action rule
        Expected value is 'Suppression'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input['ConditionsArgs']]:
        """
        conditions on which alerts will be filtered
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input['ConditionsArgs']]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of action rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['ScopeArgs']]:
        """
        scope on which action rule will apply
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['ScopeArgs']]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]]:
        """
        Indicates if the given action rule is enabled or disabled
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[builtins.str, 'ActionRuleStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ThrottlingInformationArgsDict(TypedDict):
        """
        Optional throttling information for the alert rule.
        """
        duration: NotRequired[pulumi.Input[builtins.str]]
        """
        The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value is 0 minutes
        """
elif False:
    ThrottlingInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThrottlingInformationArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[builtins.str]] = None):
        """
        Optional throttling information for the alert rule.
        :param pulumi.Input[builtins.str] duration: The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value is 0 minutes
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The required duration (in ISO8601 format) to wait before notifying on the alert rule again. The time granularity must be in minutes and minimum value is 0 minutes
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class WeeklyRecurrenceArgsDict(TypedDict):
        """
        Weekly recurrence object.
        """
        days_of_week: pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'DaysOfWeek']]]]
        """
        Specifies the values for weekly recurrence pattern.
        """
        recurrence_type: pulumi.Input[builtins.str]
        """
        Specifies when the recurrence should be applied.
        Expected value is 'Weekly'.
        """
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        End time for recurrence.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Start time for recurrence.
        """
elif False:
    WeeklyRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WeeklyRecurrenceArgs:
    def __init__(__self__, *,
                 days_of_week: pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'DaysOfWeek']]]],
                 recurrence_type: pulumi.Input[builtins.str],
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Weekly recurrence object.
        :param pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'DaysOfWeek']]]] days_of_week: Specifies the values for weekly recurrence pattern.
        :param pulumi.Input[builtins.str] recurrence_type: Specifies when the recurrence should be applied.
               Expected value is 'Weekly'.
        :param pulumi.Input[builtins.str] end_time: End time for recurrence.
        :param pulumi.Input[builtins.str] start_time: Start time for recurrence.
        """
        pulumi.set(__self__, "days_of_week", days_of_week)
        pulumi.set(__self__, "recurrence_type", 'Weekly')
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'DaysOfWeek']]]]:
        """
        Specifies the values for weekly recurrence pattern.
        """
        return pulumi.get(self, "days_of_week")

    @days_of_week.setter
    def days_of_week(self, value: pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'DaysOfWeek']]]]):
        pulumi.set(self, "days_of_week", value)

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> pulumi.Input[builtins.str]:
        """
        Specifies when the recurrence should be applied.
        Expected value is 'Weekly'.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "recurrence_type", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End time for recurrence.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start time for recurrence.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


