# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AcceptedAudiencesArgs',
    'AcceptedAudiencesArgsDict',
    'AzureSkuArgs',
    'AzureSkuArgsDict',
    'CalloutPolicyArgs',
    'CalloutPolicyArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'KeyVaultPropertiesArgs',
    'KeyVaultPropertiesArgsDict',
    'LanguageExtensionsListArgs',
    'LanguageExtensionsListArgsDict',
    'LanguageExtensionArgs',
    'LanguageExtensionArgsDict',
    'OptimizedAutoscaleArgs',
    'OptimizedAutoscaleArgsDict',
    'PrivateLinkServiceConnectionStatePropertyArgs',
    'PrivateLinkServiceConnectionStatePropertyArgsDict',
    'TableLevelSharingPropertiesArgs',
    'TableLevelSharingPropertiesArgsDict',
    'TrustedExternalTenantArgs',
    'TrustedExternalTenantArgsDict',
    'VirtualNetworkConfigurationArgs',
    'VirtualNetworkConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class AcceptedAudiencesArgsDict(TypedDict):
        """
        Represents an accepted audience trusted by the cluster.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        GUID or valid URL representing an accepted audience.
        """
elif False:
    AcceptedAudiencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AcceptedAudiencesArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Represents an accepted audience trusted by the cluster.
        :param pulumi.Input[builtins.str] value: GUID or valid URL representing an accepted audience.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        GUID or valid URL representing an accepted audience.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AzureSkuArgsDict(TypedDict):
        """
        Azure SKU definition.
        """
        name: pulumi.Input[Union[builtins.str, 'AzureSkuName']]
        """
        SKU name.
        """
        tier: pulumi.Input[Union[builtins.str, 'AzureSkuTier']]
        """
        SKU tier.
        """
        capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of instances of the cluster.
        """
elif False:
    AzureSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureSkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[Union[builtins.str, 'AzureSkuName']],
                 tier: pulumi.Input[Union[builtins.str, 'AzureSkuTier']],
                 capacity: Optional[pulumi.Input[builtins.int]] = None):
        """
        Azure SKU definition.
        :param pulumi.Input[Union[builtins.str, 'AzureSkuName']] name: SKU name.
        :param pulumi.Input[Union[builtins.str, 'AzureSkuTier']] tier: SKU tier.
        :param pulumi.Input[builtins.int] capacity: The number of instances of the cluster.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tier", tier)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[Union[builtins.str, 'AzureSkuName']]:
        """
        SKU name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[Union[builtins.str, 'AzureSkuName']]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tier(self) -> pulumi.Input[Union[builtins.str, 'AzureSkuTier']]:
        """
        SKU tier.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: pulumi.Input[Union[builtins.str, 'AzureSkuTier']]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of instances of the cluster.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "capacity", value)


if not MYPY:
    class CalloutPolicyArgsDict(TypedDict):
        """
        Configuration for external callout policies, including URI patterns, access types, and service types.
        """
        callout_type: NotRequired[pulumi.Input[Union[builtins.str, 'CalloutType']]]
        """
        Type of the callout service, specifying the kind of external resource or service being accessed.
        """
        callout_uri_regex: NotRequired[pulumi.Input[builtins.str]]
        """
        Regular expression or FQDN pattern for the callout URI.
        """
        outbound_access: NotRequired[pulumi.Input[Union[builtins.str, 'OutboundAccess']]]
        """
        Indicates whether outbound access is permitted for the specified URI pattern.
        """
elif False:
    CalloutPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CalloutPolicyArgs:
    def __init__(__self__, *,
                 callout_type: Optional[pulumi.Input[Union[builtins.str, 'CalloutType']]] = None,
                 callout_uri_regex: Optional[pulumi.Input[builtins.str]] = None,
                 outbound_access: Optional[pulumi.Input[Union[builtins.str, 'OutboundAccess']]] = None):
        """
        Configuration for external callout policies, including URI patterns, access types, and service types.
        :param pulumi.Input[Union[builtins.str, 'CalloutType']] callout_type: Type of the callout service, specifying the kind of external resource or service being accessed.
        :param pulumi.Input[builtins.str] callout_uri_regex: Regular expression or FQDN pattern for the callout URI.
        :param pulumi.Input[Union[builtins.str, 'OutboundAccess']] outbound_access: Indicates whether outbound access is permitted for the specified URI pattern.
        """
        if callout_type is not None:
            pulumi.set(__self__, "callout_type", callout_type)
        if callout_uri_regex is not None:
            pulumi.set(__self__, "callout_uri_regex", callout_uri_regex)
        if outbound_access is not None:
            pulumi.set(__self__, "outbound_access", outbound_access)

    @property
    @pulumi.getter(name="calloutType")
    def callout_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'CalloutType']]]:
        """
        Type of the callout service, specifying the kind of external resource or service being accessed.
        """
        return pulumi.get(self, "callout_type")

    @callout_type.setter
    def callout_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'CalloutType']]]):
        pulumi.set(self, "callout_type", value)

    @property
    @pulumi.getter(name="calloutUriRegex")
    def callout_uri_regex(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Regular expression or FQDN pattern for the callout URI.
        """
        return pulumi.get(self, "callout_uri_regex")

    @callout_uri_regex.setter
    def callout_uri_regex(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "callout_uri_regex", value)

    @property
    @pulumi.getter(name="outboundAccess")
    def outbound_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'OutboundAccess']]]:
        """
        Indicates whether outbound access is permitted for the specified URI pattern.
        """
        return pulumi.get(self, "outbound_access")

    @outbound_access.setter
    def outbound_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'OutboundAccess']]]):
        pulumi.set(self, "outbound_access", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: pulumi.Input[Union[builtins.str, 'IdentityType']]
        """
        The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove all identities.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of user identities associated with the Kusto cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[builtins.str, 'IdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Identity for the resource.
        :param pulumi.Input[Union[builtins.str, 'IdentityType']] type: The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove all identities.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The list of user identities associated with the Kusto cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'IdentityType']]:
        """
        The type of managed identity used. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user-assigned identities. The type 'None' will remove all identities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'IdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of user identities associated with the Kusto cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class KeyVaultPropertiesArgsDict(TypedDict):
        """
        Properties of the key vault.
        """
        key_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the key vault key.
        """
        key_vault_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The Uri of the key vault.
        """
        key_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The version of the key vault key.
        """
        user_identity: NotRequired[pulumi.Input[builtins.str]]
        """
        The user assigned identity (ARM resource id) that has access to the key.
        """
elif False:
    KeyVaultPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 key_name: Optional[pulumi.Input[builtins.str]] = None,
                 key_vault_uri: Optional[pulumi.Input[builtins.str]] = None,
                 key_version: Optional[pulumi.Input[builtins.str]] = None,
                 user_identity: Optional[pulumi.Input[builtins.str]] = None):
        """
        Properties of the key vault.
        :param pulumi.Input[builtins.str] key_name: The name of the key vault key.
        :param pulumi.Input[builtins.str] key_vault_uri: The Uri of the key vault.
        :param pulumi.Input[builtins.str] key_version: The version of the key vault key.
        :param pulumi.Input[builtins.str] user_identity: The user assigned identity (ARM resource id) that has access to the key.
        """
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)
        if user_identity is not None:
            pulumi.set(__self__, "user_identity", user_identity)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the key vault key.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Uri of the key vault.
        """
        return pulumi.get(self, "key_vault_uri")

    @key_vault_uri.setter
    def key_vault_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_vault_uri", value)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version of the key vault key.
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_version", value)

    @property
    @pulumi.getter(name="userIdentity")
    def user_identity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The user assigned identity (ARM resource id) that has access to the key.
        """
        return pulumi.get(self, "user_identity")

    @user_identity.setter
    def user_identity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_identity", value)


if not MYPY:
    class LanguageExtensionsListArgsDict(TypedDict):
        """
        The list of language extension objects.
        """
        value: NotRequired[pulumi.Input[Sequence[pulumi.Input['LanguageExtensionArgsDict']]]]
        """
        The list of language extensions.
        """
elif False:
    LanguageExtensionsListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LanguageExtensionsListArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[Sequence[pulumi.Input['LanguageExtensionArgs']]]] = None):
        """
        The list of language extension objects.
        :param pulumi.Input[Sequence[pulumi.Input['LanguageExtensionArgs']]] value: The list of language extensions.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LanguageExtensionArgs']]]]:
        """
        The list of language extensions.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LanguageExtensionArgs']]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LanguageExtensionArgsDict(TypedDict):
        """
        The language extension object.
        """
        language_extension_custom_image_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The language extension custom image name.
        """
        language_extension_image_name: NotRequired[pulumi.Input[Union[builtins.str, 'LanguageExtensionImageName']]]
        """
        The language extension image name.
        """
        language_extension_name: NotRequired[pulumi.Input[Union[builtins.str, 'LanguageExtensionName']]]
        """
        The language extension name.
        """
elif False:
    LanguageExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LanguageExtensionArgs:
    def __init__(__self__, *,
                 language_extension_custom_image_name: Optional[pulumi.Input[builtins.str]] = None,
                 language_extension_image_name: Optional[pulumi.Input[Union[builtins.str, 'LanguageExtensionImageName']]] = None,
                 language_extension_name: Optional[pulumi.Input[Union[builtins.str, 'LanguageExtensionName']]] = None):
        """
        The language extension object.
        :param pulumi.Input[builtins.str] language_extension_custom_image_name: The language extension custom image name.
        :param pulumi.Input[Union[builtins.str, 'LanguageExtensionImageName']] language_extension_image_name: The language extension image name.
        :param pulumi.Input[Union[builtins.str, 'LanguageExtensionName']] language_extension_name: The language extension name.
        """
        if language_extension_custom_image_name is not None:
            pulumi.set(__self__, "language_extension_custom_image_name", language_extension_custom_image_name)
        if language_extension_image_name is not None:
            pulumi.set(__self__, "language_extension_image_name", language_extension_image_name)
        if language_extension_name is not None:
            pulumi.set(__self__, "language_extension_name", language_extension_name)

    @property
    @pulumi.getter(name="languageExtensionCustomImageName")
    def language_extension_custom_image_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The language extension custom image name.
        """
        return pulumi.get(self, "language_extension_custom_image_name")

    @language_extension_custom_image_name.setter
    def language_extension_custom_image_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "language_extension_custom_image_name", value)

    @property
    @pulumi.getter(name="languageExtensionImageName")
    def language_extension_image_name(self) -> Optional[pulumi.Input[Union[builtins.str, 'LanguageExtensionImageName']]]:
        """
        The language extension image name.
        """
        return pulumi.get(self, "language_extension_image_name")

    @language_extension_image_name.setter
    def language_extension_image_name(self, value: Optional[pulumi.Input[Union[builtins.str, 'LanguageExtensionImageName']]]):
        pulumi.set(self, "language_extension_image_name", value)

    @property
    @pulumi.getter(name="languageExtensionName")
    def language_extension_name(self) -> Optional[pulumi.Input[Union[builtins.str, 'LanguageExtensionName']]]:
        """
        The language extension name.
        """
        return pulumi.get(self, "language_extension_name")

    @language_extension_name.setter
    def language_extension_name(self, value: Optional[pulumi.Input[Union[builtins.str, 'LanguageExtensionName']]]):
        pulumi.set(self, "language_extension_name", value)


if not MYPY:
    class OptimizedAutoscaleArgsDict(TypedDict):
        """
        A class that contains the optimized auto scale definition.
        """
        is_enabled: pulumi.Input[builtins.bool]
        """
        A boolean value that indicate if the optimized autoscale feature is enabled or not.
        """
        maximum: pulumi.Input[builtins.int]
        """
        Maximum allowed instances count.
        """
        minimum: pulumi.Input[builtins.int]
        """
        Minimum allowed instances count.
        """
        version: pulumi.Input[builtins.int]
        """
        The version of the template defined, for instance 1.
        """
elif False:
    OptimizedAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptimizedAutoscaleArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[builtins.bool],
                 maximum: pulumi.Input[builtins.int],
                 minimum: pulumi.Input[builtins.int],
                 version: pulumi.Input[builtins.int]):
        """
        A class that contains the optimized auto scale definition.
        :param pulumi.Input[builtins.bool] is_enabled: A boolean value that indicate if the optimized autoscale feature is enabled or not.
        :param pulumi.Input[builtins.int] maximum: Maximum allowed instances count.
        :param pulumi.Input[builtins.int] minimum: Minimum allowed instances count.
        :param pulumi.Input[builtins.int] version: The version of the template defined, for instance 1.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "maximum", maximum)
        pulumi.set(__self__, "minimum", minimum)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[builtins.bool]:
        """
        A boolean value that indicate if the optimized autoscale feature is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def maximum(self) -> pulumi.Input[builtins.int]:
        """
        Maximum allowed instances count.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> pulumi.Input[builtins.int]:
        """
        Minimum allowed instances count.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[builtins.int]:
        """
        The version of the template defined, for instance 1.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PrivateLinkServiceConnectionStatePropertyArgsDict(TypedDict):
        """
        Connection State of the Private Endpoint Connection.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The private link service connection description.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        The private link service connection status.
        """
elif False:
    PrivateLinkServiceConnectionStatePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkServiceConnectionStatePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        Connection State of the Private Endpoint Connection.
        :param pulumi.Input[builtins.str] description: The private link service connection description.
        :param pulumi.Input[builtins.str] status: The private link service connection status.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The private link service connection description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The private link service connection status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class TableLevelSharingPropertiesArgsDict(TypedDict):
        """
        Tables that will be included and excluded in the follower database
        """
        external_tables_to_exclude: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of external tables to exclude from the follower database
        """
        external_tables_to_include: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of external tables to include in the follower database
        """
        functions_to_exclude: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of functions to exclude from the follower database
        """
        functions_to_include: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of functions to include in the follower database
        """
        materialized_views_to_exclude: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of materialized views to exclude from the follower database
        """
        materialized_views_to_include: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of materialized views to include in the follower database
        """
        tables_to_exclude: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of tables to exclude from the follower database
        """
        tables_to_include: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of tables to include in the follower database
        """
elif False:
    TableLevelSharingPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableLevelSharingPropertiesArgs:
    def __init__(__self__, *,
                 external_tables_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 external_tables_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 functions_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 functions_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 materialized_views_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 materialized_views_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 tables_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 tables_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Tables that will be included and excluded in the follower database
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] external_tables_to_exclude: List of external tables to exclude from the follower database
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] external_tables_to_include: List of external tables to include in the follower database
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] functions_to_exclude: List of functions to exclude from the follower database
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] functions_to_include: List of functions to include in the follower database
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] materialized_views_to_exclude: List of materialized views to exclude from the follower database
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] materialized_views_to_include: List of materialized views to include in the follower database
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tables_to_exclude: List of tables to exclude from the follower database
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tables_to_include: List of tables to include in the follower database
        """
        if external_tables_to_exclude is not None:
            pulumi.set(__self__, "external_tables_to_exclude", external_tables_to_exclude)
        if external_tables_to_include is not None:
            pulumi.set(__self__, "external_tables_to_include", external_tables_to_include)
        if functions_to_exclude is not None:
            pulumi.set(__self__, "functions_to_exclude", functions_to_exclude)
        if functions_to_include is not None:
            pulumi.set(__self__, "functions_to_include", functions_to_include)
        if materialized_views_to_exclude is not None:
            pulumi.set(__self__, "materialized_views_to_exclude", materialized_views_to_exclude)
        if materialized_views_to_include is not None:
            pulumi.set(__self__, "materialized_views_to_include", materialized_views_to_include)
        if tables_to_exclude is not None:
            pulumi.set(__self__, "tables_to_exclude", tables_to_exclude)
        if tables_to_include is not None:
            pulumi.set(__self__, "tables_to_include", tables_to_include)

    @property
    @pulumi.getter(name="externalTablesToExclude")
    def external_tables_to_exclude(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of external tables to exclude from the follower database
        """
        return pulumi.get(self, "external_tables_to_exclude")

    @external_tables_to_exclude.setter
    def external_tables_to_exclude(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "external_tables_to_exclude", value)

    @property
    @pulumi.getter(name="externalTablesToInclude")
    def external_tables_to_include(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of external tables to include in the follower database
        """
        return pulumi.get(self, "external_tables_to_include")

    @external_tables_to_include.setter
    def external_tables_to_include(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "external_tables_to_include", value)

    @property
    @pulumi.getter(name="functionsToExclude")
    def functions_to_exclude(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of functions to exclude from the follower database
        """
        return pulumi.get(self, "functions_to_exclude")

    @functions_to_exclude.setter
    def functions_to_exclude(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "functions_to_exclude", value)

    @property
    @pulumi.getter(name="functionsToInclude")
    def functions_to_include(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of functions to include in the follower database
        """
        return pulumi.get(self, "functions_to_include")

    @functions_to_include.setter
    def functions_to_include(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "functions_to_include", value)

    @property
    @pulumi.getter(name="materializedViewsToExclude")
    def materialized_views_to_exclude(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of materialized views to exclude from the follower database
        """
        return pulumi.get(self, "materialized_views_to_exclude")

    @materialized_views_to_exclude.setter
    def materialized_views_to_exclude(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "materialized_views_to_exclude", value)

    @property
    @pulumi.getter(name="materializedViewsToInclude")
    def materialized_views_to_include(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of materialized views to include in the follower database
        """
        return pulumi.get(self, "materialized_views_to_include")

    @materialized_views_to_include.setter
    def materialized_views_to_include(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "materialized_views_to_include", value)

    @property
    @pulumi.getter(name="tablesToExclude")
    def tables_to_exclude(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of tables to exclude from the follower database
        """
        return pulumi.get(self, "tables_to_exclude")

    @tables_to_exclude.setter
    def tables_to_exclude(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tables_to_exclude", value)

    @property
    @pulumi.getter(name="tablesToInclude")
    def tables_to_include(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of tables to include in the follower database
        """
        return pulumi.get(self, "tables_to_include")

    @tables_to_include.setter
    def tables_to_include(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tables_to_include", value)


if not MYPY:
    class TrustedExternalTenantArgsDict(TypedDict):
        """
        Represents a tenant ID that is trusted by the cluster.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        GUID representing an external tenant.
        """
elif False:
    TrustedExternalTenantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrustedExternalTenantArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Represents a tenant ID that is trusted by the cluster.
        :param pulumi.Input[builtins.str] value: GUID representing an external tenant.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        GUID representing an external tenant.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualNetworkConfigurationArgsDict(TypedDict):
        """
        A class that contains virtual network definition.
        """
        data_management_public_ip_id: pulumi.Input[builtins.str]
        """
        Data management's service public IP address resource id.
        """
        engine_public_ip_id: pulumi.Input[builtins.str]
        """
        Engine service's public IP address resource id.
        """
        subnet_id: pulumi.Input[builtins.str]
        """
        The subnet resource id.
        """
        state: NotRequired[pulumi.Input[Union[builtins.str, 'VnetState']]]
        """
        When enabled, the cluster is deployed into the configured subnet, when disabled it will be removed from the subnet.
        """
elif False:
    VirtualNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkConfigurationArgs:
    def __init__(__self__, *,
                 data_management_public_ip_id: pulumi.Input[builtins.str],
                 engine_public_ip_id: pulumi.Input[builtins.str],
                 subnet_id: pulumi.Input[builtins.str],
                 state: Optional[pulumi.Input[Union[builtins.str, 'VnetState']]] = None):
        """
        A class that contains virtual network definition.
        :param pulumi.Input[builtins.str] data_management_public_ip_id: Data management's service public IP address resource id.
        :param pulumi.Input[builtins.str] engine_public_ip_id: Engine service's public IP address resource id.
        :param pulumi.Input[builtins.str] subnet_id: The subnet resource id.
        :param pulumi.Input[Union[builtins.str, 'VnetState']] state: When enabled, the cluster is deployed into the configured subnet, when disabled it will be removed from the subnet.
        """
        pulumi.set(__self__, "data_management_public_ip_id", data_management_public_ip_id)
        pulumi.set(__self__, "engine_public_ip_id", engine_public_ip_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if state is None:
            state = 'Enabled'
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dataManagementPublicIpId")
    def data_management_public_ip_id(self) -> pulumi.Input[builtins.str]:
        """
        Data management's service public IP address resource id.
        """
        return pulumi.get(self, "data_management_public_ip_id")

    @data_management_public_ip_id.setter
    def data_management_public_ip_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_management_public_ip_id", value)

    @property
    @pulumi.getter(name="enginePublicIpId")
    def engine_public_ip_id(self) -> pulumi.Input[builtins.str]:
        """
        Engine service's public IP address resource id.
        """
        return pulumi.get(self, "engine_public_ip_id")

    @engine_public_ip_id.setter
    def engine_public_ip_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "engine_public_ip_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[builtins.str]:
        """
        The subnet resource id.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[builtins.str, 'VnetState']]]:
        """
        When enabled, the cluster is deployed into the configured subnet, when disabled it will be removed from the subnet.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[builtins.str, 'VnetState']]]):
        pulumi.set(self, "state", value)


