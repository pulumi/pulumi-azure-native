# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AdvancedSettingsArgs',
    'AdvancedSettingsArgsDict',
    'AkriConnectorTemplateAioMetadataArgs',
    'AkriConnectorTemplateAioMetadataArgsDict',
    'AkriConnectorTemplateBucketizedAllocationArgs',
    'AkriConnectorTemplateBucketizedAllocationArgsDict',
    'AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgs',
    'AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgsDict',
    'AkriConnectorTemplateDeviceInboundEndpointTypeArgs',
    'AkriConnectorTemplateDeviceInboundEndpointTypeArgsDict',
    'AkriConnectorTemplateDiagnosticsArgs',
    'AkriConnectorTemplateDiagnosticsArgsDict',
    'AkriConnectorTemplateHelmAdvancedConfigurationArgs',
    'AkriConnectorTemplateHelmAdvancedConfigurationArgsDict',
    'AkriConnectorTemplateHelmAuthSecretRefArgs',
    'AkriConnectorTemplateHelmAuthSecretRefArgsDict',
    'AkriConnectorTemplateHelmConfigurationSettingsArgs',
    'AkriConnectorTemplateHelmConfigurationSettingsArgsDict',
    'AkriConnectorTemplateHelmConfigurationArgs',
    'AkriConnectorTemplateHelmConfigurationArgsDict',
    'AkriConnectorTemplateHelmContainerRegistrySettingsArgs',
    'AkriConnectorTemplateHelmContainerRegistrySettingsArgsDict',
    'AkriConnectorTemplateHelmContainerRegistryArgs',
    'AkriConnectorTemplateHelmContainerRegistryArgsDict',
    'AkriConnectorTemplateHelmDeleteConfigurationArgs',
    'AkriConnectorTemplateHelmDeleteConfigurationArgsDict',
    'AkriConnectorTemplateHelmInstallConfigurationArgs',
    'AkriConnectorTemplateHelmInstallConfigurationArgsDict',
    'AkriConnectorTemplateHelmRegistryEndpointRefArgs',
    'AkriConnectorTemplateHelmRegistryEndpointRefArgsDict',
    'AkriConnectorTemplateHelmUpgradeConfigurationArgs',
    'AkriConnectorTemplateHelmUpgradeConfigurationArgsDict',
    'AkriConnectorTemplateManagedConfigurationArgs',
    'AkriConnectorTemplateManagedConfigurationArgsDict',
    'AkriConnectorTemplatePersistentVolumeClaimArgs',
    'AkriConnectorTemplatePersistentVolumeClaimArgsDict',
    'AkriConnectorTemplatePropertiesArgs',
    'AkriConnectorTemplatePropertiesArgsDict',
    'AkriConnectorTemplateRuntimeImageConfigurationSettingsArgs',
    'AkriConnectorTemplateRuntimeImageConfigurationSettingsArgsDict',
    'AkriConnectorTemplateRuntimeImageConfigurationArgs',
    'AkriConnectorTemplateRuntimeImageConfigurationArgsDict',
    'AkriConnectorTemplateRuntimeStatefulSetConfigurationArgs',
    'AkriConnectorTemplateRuntimeStatefulSetConfigurationArgsDict',
    'AkriConnectorTemplateTrustListArgs',
    'AkriConnectorTemplateTrustListArgsDict',
    'AkriConnectorsContainerRegistrySettingsArgs',
    'AkriConnectorsContainerRegistrySettingsArgsDict',
    'AkriConnectorsContainerRegistryArgs',
    'AkriConnectorsContainerRegistryArgsDict',
    'AkriConnectorsDiagnosticsLogsArgs',
    'AkriConnectorsDiagnosticsLogsArgsDict',
    'AkriConnectorsDigestArgs',
    'AkriConnectorsDigestArgsDict',
    'AkriConnectorsImagePullSecretArgs',
    'AkriConnectorsImagePullSecretArgsDict',
    'AkriConnectorsMqttConnectionConfigurationArgs',
    'AkriConnectorsMqttConnectionConfigurationArgsDict',
    'AkriConnectorsRegistryEndpointRefArgs',
    'AkriConnectorsRegistryEndpointRefArgsDict',
    'AkriConnectorsSecretArgs',
    'AkriConnectorsSecretArgsDict',
    'AkriConnectorsServiceAccountAuthenticationArgs',
    'AkriConnectorsServiceAccountAuthenticationArgsDict',
    'AkriConnectorsServiceAccountTokenSettingsArgs',
    'AkriConnectorsServiceAccountTokenSettingsArgsDict',
    'AkriConnectorsTagArgs',
    'AkriConnectorsTagArgsDict',
    'AuthorizationConfigArgs',
    'AuthorizationConfigArgsDict',
    'AuthorizationRuleArgs',
    'AuthorizationRuleArgsDict',
    'BackendChainArgs',
    'BackendChainArgsDict',
    'BatchingConfigurationArgs',
    'BatchingConfigurationArgsDict',
    'BrokerAuthenticationPropertiesArgs',
    'BrokerAuthenticationPropertiesArgsDict',
    'BrokerAuthenticatorCustomAuthArgs',
    'BrokerAuthenticatorCustomAuthArgsDict',
    'BrokerAuthenticatorMethodCustomArgs',
    'BrokerAuthenticatorMethodCustomArgsDict',
    'BrokerAuthenticatorMethodSatArgs',
    'BrokerAuthenticatorMethodSatArgsDict',
    'BrokerAuthenticatorMethodX509AttributesArgs',
    'BrokerAuthenticatorMethodX509AttributesArgsDict',
    'BrokerAuthenticatorMethodX509Args',
    'BrokerAuthenticatorMethodX509ArgsDict',
    'BrokerAuthenticatorMethodsArgs',
    'BrokerAuthenticatorMethodsArgsDict',
    'BrokerAuthorizationPropertiesArgs',
    'BrokerAuthorizationPropertiesArgsDict',
    'BrokerDiagnosticsArgs',
    'BrokerDiagnosticsArgsDict',
    'BrokerListenerPropertiesArgs',
    'BrokerListenerPropertiesArgsDict',
    'BrokerPropertiesArgs',
    'BrokerPropertiesArgsDict',
    'BrokerResourceRuleArgs',
    'BrokerResourceRuleArgsDict',
    'CardinalityArgs',
    'CardinalityArgsDict',
    'CertManagerCertOptionsArgs',
    'CertManagerCertOptionsArgsDict',
    'CertManagerCertificateSpecArgs',
    'CertManagerCertificateSpecArgsDict',
    'CertManagerIssuerRefArgs',
    'CertManagerIssuerRefArgsDict',
    'CertManagerPrivateKeyArgs',
    'CertManagerPrivateKeyArgsDict',
    'ClientConfigArgs',
    'ClientConfigArgsDict',
    'DataflowBuiltInTransformationDatasetArgs',
    'DataflowBuiltInTransformationDatasetArgsDict',
    'DataflowBuiltInTransformationFilterArgs',
    'DataflowBuiltInTransformationFilterArgsDict',
    'DataflowBuiltInTransformationMapArgs',
    'DataflowBuiltInTransformationMapArgsDict',
    'DataflowBuiltInTransformationSettingsArgs',
    'DataflowBuiltInTransformationSettingsArgsDict',
    'DataflowDestinationOperationSettingsArgs',
    'DataflowDestinationOperationSettingsArgsDict',
    'DataflowEndpointAuthenticationAccessTokenArgs',
    'DataflowEndpointAuthenticationAccessTokenArgsDict',
    'DataflowEndpointAuthenticationSaslArgs',
    'DataflowEndpointAuthenticationSaslArgsDict',
    'DataflowEndpointAuthenticationServiceAccountTokenArgs',
    'DataflowEndpointAuthenticationServiceAccountTokenArgsDict',
    'DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs',
    'DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict',
    'DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs',
    'DataflowEndpointAuthenticationUserAssignedManagedIdentityArgsDict',
    'DataflowEndpointAuthenticationX509Args',
    'DataflowEndpointAuthenticationX509ArgsDict',
    'DataflowEndpointDataExplorerAuthenticationArgs',
    'DataflowEndpointDataExplorerAuthenticationArgsDict',
    'DataflowEndpointDataExplorerArgs',
    'DataflowEndpointDataExplorerArgsDict',
    'DataflowEndpointDataLakeStorageAuthenticationArgs',
    'DataflowEndpointDataLakeStorageAuthenticationArgsDict',
    'DataflowEndpointDataLakeStorageArgs',
    'DataflowEndpointDataLakeStorageArgsDict',
    'DataflowEndpointFabricOneLakeAuthenticationArgs',
    'DataflowEndpointFabricOneLakeAuthenticationArgsDict',
    'DataflowEndpointFabricOneLakeNamesArgs',
    'DataflowEndpointFabricOneLakeNamesArgsDict',
    'DataflowEndpointFabricOneLakeArgs',
    'DataflowEndpointFabricOneLakeArgsDict',
    'DataflowEndpointKafkaAuthenticationArgs',
    'DataflowEndpointKafkaAuthenticationArgsDict',
    'DataflowEndpointKafkaBatchingArgs',
    'DataflowEndpointKafkaBatchingArgsDict',
    'DataflowEndpointKafkaArgs',
    'DataflowEndpointKafkaArgsDict',
    'DataflowEndpointLocalStorageArgs',
    'DataflowEndpointLocalStorageArgsDict',
    'DataflowEndpointMqttAuthenticationArgs',
    'DataflowEndpointMqttAuthenticationArgsDict',
    'DataflowEndpointMqttArgs',
    'DataflowEndpointMqttArgsDict',
    'DataflowEndpointPropertiesArgs',
    'DataflowEndpointPropertiesArgsDict',
    'DataflowGraphConnectionInputArgs',
    'DataflowGraphConnectionInputArgsDict',
    'DataflowGraphConnectionOutputArgs',
    'DataflowGraphConnectionOutputArgsDict',
    'DataflowGraphConnectionSchemaSettingsArgs',
    'DataflowGraphConnectionSchemaSettingsArgsDict',
    'DataflowGraphDestinationNodeSettingsArgs',
    'DataflowGraphDestinationNodeSettingsArgsDict',
    'DataflowGraphDestinationNodeArgs',
    'DataflowGraphDestinationNodeArgsDict',
    'DataflowGraphDestinationSchemaSettingsArgs',
    'DataflowGraphDestinationSchemaSettingsArgsDict',
    'DataflowGraphGraphNodeConfigurationArgs',
    'DataflowGraphGraphNodeConfigurationArgsDict',
    'DataflowGraphGraphNodeArgs',
    'DataflowGraphGraphNodeArgsDict',
    'DataflowGraphNodeConnectionArgs',
    'DataflowGraphNodeConnectionArgsDict',
    'DataflowGraphNodeGraphSettingsArgs',
    'DataflowGraphNodeGraphSettingsArgsDict',
    'DataflowGraphPropertiesArgs',
    'DataflowGraphPropertiesArgsDict',
    'DataflowGraphSourceNodeArgs',
    'DataflowGraphSourceNodeArgsDict',
    'DataflowGraphSourceSettingsArgs',
    'DataflowGraphSourceSettingsArgsDict',
    'DataflowOperationArgs',
    'DataflowOperationArgsDict',
    'DataflowProfilePropertiesArgs',
    'DataflowProfilePropertiesArgsDict',
    'DataflowPropertiesArgs',
    'DataflowPropertiesArgsDict',
    'DataflowSourceOperationSettingsArgs',
    'DataflowSourceOperationSettingsArgsDict',
    'DiagnosticsLogsArgs',
    'DiagnosticsLogsArgsDict',
    'DiskBackedMessageBufferArgs',
    'DiskBackedMessageBufferArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'FrontendArgs',
    'FrontendArgsDict',
    'GenerateResourceLimitsArgs',
    'GenerateResourceLimitsArgsDict',
    'InstancePropertiesArgs',
    'InstancePropertiesArgsDict',
    'KubernetesReferenceArgs',
    'KubernetesReferenceArgsDict',
    'ListenerPortArgs',
    'ListenerPortArgsDict',
    'LocalKubernetesReferenceArgs',
    'LocalKubernetesReferenceArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'MetricsArgs',
    'MetricsArgsDict',
    'PrincipalDefinitionArgs',
    'PrincipalDefinitionArgsDict',
    'ProfileDiagnosticsArgs',
    'ProfileDiagnosticsArgsDict',
    'RegistryEndpointAnonymousAuthenticationArgs',
    'RegistryEndpointAnonymousAuthenticationArgsDict',
    'RegistryEndpointArtifactPullSecretAuthenticationArgs',
    'RegistryEndpointArtifactPullSecretAuthenticationArgsDict',
    'RegistryEndpointArtifactPullSecretSettingsArgs',
    'RegistryEndpointArtifactPullSecretSettingsArgsDict',
    'RegistryEndpointPropertiesArgs',
    'RegistryEndpointPropertiesArgsDict',
    'RegistryEndpointSystemAssignedIdentityAuthenticationArgs',
    'RegistryEndpointSystemAssignedIdentityAuthenticationArgsDict',
    'RegistryEndpointSystemAssignedManagedIdentitySettingsArgs',
    'RegistryEndpointSystemAssignedManagedIdentitySettingsArgsDict',
    'RegistryEndpointTrustedSettingsArgs',
    'RegistryEndpointTrustedSettingsArgsDict',
    'RegistryEndpointTrustedSigningKeyConfigMapArgs',
    'RegistryEndpointTrustedSigningKeyConfigMapArgsDict',
    'RegistryEndpointTrustedSigningKeySecretArgs',
    'RegistryEndpointTrustedSigningKeySecretArgsDict',
    'RegistryEndpointUserAssignedIdentityAuthenticationArgs',
    'RegistryEndpointUserAssignedIdentityAuthenticationArgsDict',
    'RegistryEndpointUserAssignedManagedIdentitySettingsArgs',
    'RegistryEndpointUserAssignedManagedIdentitySettingsArgsDict',
    'SanForCertArgs',
    'SanForCertArgsDict',
    'SchemaRegistryRefArgs',
    'SchemaRegistryRefArgsDict',
    'SelfCheckArgs',
    'SelfCheckArgsDict',
    'SelfTracingArgs',
    'SelfTracingArgsDict',
    'StateStoreResourceRuleArgs',
    'StateStoreResourceRuleArgsDict',
    'SubscriberQueueLimitArgs',
    'SubscriberQueueLimitArgsDict',
    'TlsCertMethodArgs',
    'TlsCertMethodArgsDict',
    'TlsPropertiesArgs',
    'TlsPropertiesArgsDict',
    'TracesArgs',
    'TracesArgsDict',
    'VolumeClaimResourceRequirementsArgs',
    'VolumeClaimResourceRequirementsArgsDict',
    'VolumeClaimSpecSelectorMatchExpressionsArgs',
    'VolumeClaimSpecSelectorMatchExpressionsArgsDict',
    'VolumeClaimSpecSelectorArgs',
    'VolumeClaimSpecSelectorArgsDict',
    'VolumeClaimSpecArgs',
    'VolumeClaimSpecArgsDict',
    'X509ManualCertificateArgs',
    'X509ManualCertificateArgsDict',
]

MYPY = False

if not MYPY:
    class AdvancedSettingsArgsDict(TypedDict):
        """
        Broker Advanced Settings
        """
        clients: NotRequired[pulumi.Input['ClientConfigArgsDict']]
        """
        Configurations related to All Clients.
        """
        encrypt_internal_traffic: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        The setting to enable or disable encryption of internal Traffic.
        """
        internal_certs: NotRequired[pulumi.Input['CertManagerCertOptionsArgsDict']]
        """
        Certificate rotation and private key configuration.
        """
elif False:
    AdvancedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedSettingsArgs:
    def __init__(__self__, *,
                 clients: Optional[pulumi.Input['ClientConfigArgs']] = None,
                 encrypt_internal_traffic: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None,
                 internal_certs: Optional[pulumi.Input['CertManagerCertOptionsArgs']] = None):
        """
        Broker Advanced Settings
        :param pulumi.Input['ClientConfigArgs'] clients: Configurations related to All Clients.
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] encrypt_internal_traffic: The setting to enable or disable encryption of internal Traffic.
        :param pulumi.Input['CertManagerCertOptionsArgs'] internal_certs: Certificate rotation and private key configuration.
        """
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if encrypt_internal_traffic is None:
            encrypt_internal_traffic = 'Enabled'
        if encrypt_internal_traffic is not None:
            pulumi.set(__self__, "encrypt_internal_traffic", encrypt_internal_traffic)
        if internal_certs is not None:
            pulumi.set(__self__, "internal_certs", internal_certs)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional[pulumi.Input['ClientConfigArgs']]:
        """
        Configurations related to All Clients.
        """
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: Optional[pulumi.Input['ClientConfigArgs']]):
        pulumi.set(self, "clients", value)

    @_builtins.property
    @pulumi.getter(name="encryptInternalTraffic")
    def encrypt_internal_traffic(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        The setting to enable or disable encryption of internal Traffic.
        """
        return pulumi.get(self, "encrypt_internal_traffic")

    @encrypt_internal_traffic.setter
    def encrypt_internal_traffic(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "encrypt_internal_traffic", value)

    @_builtins.property
    @pulumi.getter(name="internalCerts")
    def internal_certs(self) -> Optional[pulumi.Input['CertManagerCertOptionsArgs']]:
        """
        Certificate rotation and private key configuration.
        """
        return pulumi.get(self, "internal_certs")

    @internal_certs.setter
    def internal_certs(self, value: Optional[pulumi.Input['CertManagerCertOptionsArgs']]):
        pulumi.set(self, "internal_certs", value)


if not MYPY:
    class AkriConnectorTemplateAioMetadataArgsDict(TypedDict):
        """
        AkriConnectorTemplateAioMetadata properties.
        """
        aio_max_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum version of AIO required for the connector.
        """
        aio_min_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The minimum version of AIO required for the connector.
        """
elif False:
    AkriConnectorTemplateAioMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateAioMetadataArgs:
    def __init__(__self__, *,
                 aio_max_version: Optional[pulumi.Input[_builtins.str]] = None,
                 aio_min_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        AkriConnectorTemplateAioMetadata properties.
        :param pulumi.Input[_builtins.str] aio_max_version: The maximum version of AIO required for the connector.
        :param pulumi.Input[_builtins.str] aio_min_version: The minimum version of AIO required for the connector.
        """
        if aio_max_version is not None:
            pulumi.set(__self__, "aio_max_version", aio_max_version)
        if aio_min_version is not None:
            pulumi.set(__self__, "aio_min_version", aio_min_version)

    @_builtins.property
    @pulumi.getter(name="aioMaxVersion")
    def aio_max_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum version of AIO required for the connector.
        """
        return pulumi.get(self, "aio_max_version")

    @aio_max_version.setter
    def aio_max_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aio_max_version", value)

    @_builtins.property
    @pulumi.getter(name="aioMinVersion")
    def aio_min_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The minimum version of AIO required for the connector.
        """
        return pulumi.get(self, "aio_min_version")

    @aio_min_version.setter
    def aio_min_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aio_min_version", value)


if not MYPY:
    class AkriConnectorTemplateBucketizedAllocationArgsDict(TypedDict):
        """
        AkriConnectorTemplateBucketizedAllocation properties.
        """
        bucket_size: pulumi.Input[_builtins.int]
        """
        The bucketized allocation of AEPs for connectors.
        """
        policy: pulumi.Input[_builtins.str]
        """
        AkriConnectorTemplateAllocationPolicy properties.
        Expected value is 'Bucketized'.
        """
elif False:
    AkriConnectorTemplateBucketizedAllocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateBucketizedAllocationArgs:
    def __init__(__self__, *,
                 bucket_size: pulumi.Input[_builtins.int],
                 policy: pulumi.Input[_builtins.str]):
        """
        AkriConnectorTemplateBucketizedAllocation properties.
        :param pulumi.Input[_builtins.int] bucket_size: The bucketized allocation of AEPs for connectors.
        :param pulumi.Input[_builtins.str] policy: AkriConnectorTemplateAllocationPolicy properties.
               Expected value is 'Bucketized'.
        """
        pulumi.set(__self__, "bucket_size", bucket_size)
        pulumi.set(__self__, "policy", 'Bucketized')

    @_builtins.property
    @pulumi.getter(name="bucketSize")
    def bucket_size(self) -> pulumi.Input[_builtins.int]:
        """
        The bucketized allocation of AEPs for connectors.
        """
        return pulumi.get(self, "bucket_size")

    @bucket_size.setter
    def bucket_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "bucket_size", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> pulumi.Input[_builtins.str]:
        """
        AkriConnectorTemplateAllocationPolicy properties.
        Expected value is 'Bucketized'.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy", value)


if not MYPY:
    class AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgsDict(TypedDict):
        """
        AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefs properties.
        """
        additional_config_schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        The additional configuration schema reference.
        """
        default_dataset_config_schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default configuration schema reference for datasets.
        """
        default_events_config_schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default configuration schema reference for events.
        """
        default_process_control_config_schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default configuration schema reference for process control.
        """
        default_streams_config_schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default configuration schema reference for streams.
        """
elif False:
    AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgs:
    def __init__(__self__, *,
                 additional_config_schema_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 default_dataset_config_schema_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 default_events_config_schema_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 default_process_control_config_schema_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 default_streams_config_schema_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefs properties.
        :param pulumi.Input[_builtins.str] additional_config_schema_ref: The additional configuration schema reference.
        :param pulumi.Input[_builtins.str] default_dataset_config_schema_ref: The default configuration schema reference for datasets.
        :param pulumi.Input[_builtins.str] default_events_config_schema_ref: The default configuration schema reference for events.
        :param pulumi.Input[_builtins.str] default_process_control_config_schema_ref: The default configuration schema reference for process control.
        :param pulumi.Input[_builtins.str] default_streams_config_schema_ref: The default configuration schema reference for streams.
        """
        if additional_config_schema_ref is not None:
            pulumi.set(__self__, "additional_config_schema_ref", additional_config_schema_ref)
        if default_dataset_config_schema_ref is not None:
            pulumi.set(__self__, "default_dataset_config_schema_ref", default_dataset_config_schema_ref)
        if default_events_config_schema_ref is not None:
            pulumi.set(__self__, "default_events_config_schema_ref", default_events_config_schema_ref)
        if default_process_control_config_schema_ref is not None:
            pulumi.set(__self__, "default_process_control_config_schema_ref", default_process_control_config_schema_ref)
        if default_streams_config_schema_ref is not None:
            pulumi.set(__self__, "default_streams_config_schema_ref", default_streams_config_schema_ref)

    @_builtins.property
    @pulumi.getter(name="additionalConfigSchemaRef")
    def additional_config_schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The additional configuration schema reference.
        """
        return pulumi.get(self, "additional_config_schema_ref")

    @additional_config_schema_ref.setter
    def additional_config_schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_config_schema_ref", value)

    @_builtins.property
    @pulumi.getter(name="defaultDatasetConfigSchemaRef")
    def default_dataset_config_schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default configuration schema reference for datasets.
        """
        return pulumi.get(self, "default_dataset_config_schema_ref")

    @default_dataset_config_schema_ref.setter
    def default_dataset_config_schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_dataset_config_schema_ref", value)

    @_builtins.property
    @pulumi.getter(name="defaultEventsConfigSchemaRef")
    def default_events_config_schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default configuration schema reference for events.
        """
        return pulumi.get(self, "default_events_config_schema_ref")

    @default_events_config_schema_ref.setter
    def default_events_config_schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_events_config_schema_ref", value)

    @_builtins.property
    @pulumi.getter(name="defaultProcessControlConfigSchemaRef")
    def default_process_control_config_schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default configuration schema reference for process control.
        """
        return pulumi.get(self, "default_process_control_config_schema_ref")

    @default_process_control_config_schema_ref.setter
    def default_process_control_config_schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_process_control_config_schema_ref", value)

    @_builtins.property
    @pulumi.getter(name="defaultStreamsConfigSchemaRef")
    def default_streams_config_schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default configuration schema reference for streams.
        """
        return pulumi.get(self, "default_streams_config_schema_ref")

    @default_streams_config_schema_ref.setter
    def default_streams_config_schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_streams_config_schema_ref", value)


if not MYPY:
    class AkriConnectorTemplateDeviceInboundEndpointTypeArgsDict(TypedDict):
        """
        AkriConnectorTemplateDeviceInboundEndpointType properties.
        """
        endpoint_type: pulumi.Input[_builtins.str]
        """
        The type of the device inbound endpoint.
        """
        configuration_schema_refs: NotRequired[pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgsDict']]
        """
        The configuration schema references for the device inbound endpoint.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the device inbound endpoint.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the device inbound endpoint.
        """
elif False:
    AkriConnectorTemplateDeviceInboundEndpointTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateDeviceInboundEndpointTypeArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[_builtins.str],
                 configuration_schema_refs: Optional[pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        AkriConnectorTemplateDeviceInboundEndpointType properties.
        :param pulumi.Input[_builtins.str] endpoint_type: The type of the device inbound endpoint.
        :param pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgs'] configuration_schema_refs: The configuration schema references for the device inbound endpoint.
        :param pulumi.Input[_builtins.str] description: A description of the device inbound endpoint.
        :param pulumi.Input[_builtins.str] version: The version of the device inbound endpoint.
        """
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        if configuration_schema_refs is not None:
            pulumi.set(__self__, "configuration_schema_refs", configuration_schema_refs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the device inbound endpoint.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint_type", value)

    @_builtins.property
    @pulumi.getter(name="configurationSchemaRefs")
    def configuration_schema_refs(self) -> Optional[pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgs']]:
        """
        The configuration schema references for the device inbound endpoint.
        """
        return pulumi.get(self, "configuration_schema_refs")

    @configuration_schema_refs.setter
    def configuration_schema_refs(self, value: Optional[pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsArgs']]):
        pulumi.set(self, "configuration_schema_refs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the device inbound endpoint.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the device inbound endpoint.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class AkriConnectorTemplateDiagnosticsArgsDict(TypedDict):
        """
        AkriConnectorTemplateDiagnostics properties.
        """
        logs: pulumi.Input['AkriConnectorsDiagnosticsLogsArgsDict']
        """
        The log settings for the Connector template.
        """
elif False:
    AkriConnectorTemplateDiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateDiagnosticsArgs:
    def __init__(__self__, *,
                 logs: pulumi.Input['AkriConnectorsDiagnosticsLogsArgs']):
        """
        AkriConnectorTemplateDiagnostics properties.
        :param pulumi.Input['AkriConnectorsDiagnosticsLogsArgs'] logs: The log settings for the Connector template.
        """
        pulumi.set(__self__, "logs", logs)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> pulumi.Input['AkriConnectorsDiagnosticsLogsArgs']:
        """
        The log settings for the Connector template.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: pulumi.Input['AkriConnectorsDiagnosticsLogsArgs']):
        pulumi.set(self, "logs", value)


if not MYPY:
    class AkriConnectorTemplateHelmAdvancedConfigurationArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmAdvancedConfiguration properties.
        """
        delete: NotRequired[pulumi.Input['AkriConnectorTemplateHelmDeleteConfigurationArgsDict']]
        """
        Delete operation configuration for the Helm chart.
        """
        install: NotRequired[pulumi.Input['AkriConnectorTemplateHelmInstallConfigurationArgsDict']]
        """
        Install operation configuration for the Helm chart.
        """
        upgrade: NotRequired[pulumi.Input['AkriConnectorTemplateHelmUpgradeConfigurationArgsDict']]
        """
        Upgrade operation configuration for the Helm chart.
        """
elif False:
    AkriConnectorTemplateHelmAdvancedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input['AkriConnectorTemplateHelmDeleteConfigurationArgs']] = None,
                 install: Optional[pulumi.Input['AkriConnectorTemplateHelmInstallConfigurationArgs']] = None,
                 upgrade: Optional[pulumi.Input['AkriConnectorTemplateHelmUpgradeConfigurationArgs']] = None):
        """
        AkriConnectorTemplateHelmAdvancedConfiguration properties.
        :param pulumi.Input['AkriConnectorTemplateHelmDeleteConfigurationArgs'] delete: Delete operation configuration for the Helm chart.
        :param pulumi.Input['AkriConnectorTemplateHelmInstallConfigurationArgs'] install: Install operation configuration for the Helm chart.
        :param pulumi.Input['AkriConnectorTemplateHelmUpgradeConfigurationArgs'] upgrade: Upgrade operation configuration for the Helm chart.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if install is not None:
            pulumi.set(__self__, "install", install)
        if upgrade is not None:
            pulumi.set(__self__, "upgrade", upgrade)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input['AkriConnectorTemplateHelmDeleteConfigurationArgs']]:
        """
        Delete operation configuration for the Helm chart.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input['AkriConnectorTemplateHelmDeleteConfigurationArgs']]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def install(self) -> Optional[pulumi.Input['AkriConnectorTemplateHelmInstallConfigurationArgs']]:
        """
        Install operation configuration for the Helm chart.
        """
        return pulumi.get(self, "install")

    @install.setter
    def install(self, value: Optional[pulumi.Input['AkriConnectorTemplateHelmInstallConfigurationArgs']]):
        pulumi.set(self, "install", value)

    @_builtins.property
    @pulumi.getter
    def upgrade(self) -> Optional[pulumi.Input['AkriConnectorTemplateHelmUpgradeConfigurationArgs']]:
        """
        Upgrade operation configuration for the Helm chart.
        """
        return pulumi.get(self, "upgrade")

    @upgrade.setter
    def upgrade(self, value: Optional[pulumi.Input['AkriConnectorTemplateHelmUpgradeConfigurationArgs']]):
        pulumi.set(self, "upgrade", value)


if not MYPY:
    class AkriConnectorTemplateHelmAuthSecretRefArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmAuthSecretRef properties.
        """
        password_key: pulumi.Input[_builtins.str]
        """
        The key of the password in the secret.
        """
        secret_ref: pulumi.Input[_builtins.str]
        """
        The name of the secret.
        """
        username_key: pulumi.Input[_builtins.str]
        """
        The key of the username in the secret.
        """
elif False:
    AkriConnectorTemplateHelmAuthSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmAuthSecretRefArgs:
    def __init__(__self__, *,
                 password_key: pulumi.Input[_builtins.str],
                 secret_ref: pulumi.Input[_builtins.str],
                 username_key: pulumi.Input[_builtins.str]):
        """
        AkriConnectorTemplateHelmAuthSecretRef properties.
        :param pulumi.Input[_builtins.str] password_key: The key of the password in the secret.
        :param pulumi.Input[_builtins.str] secret_ref: The name of the secret.
        :param pulumi.Input[_builtins.str] username_key: The key of the username in the secret.
        """
        pulumi.set(__self__, "password_key", password_key)
        pulumi.set(__self__, "secret_ref", secret_ref)
        pulumi.set(__self__, "username_key", username_key)

    @_builtins.property
    @pulumi.getter(name="passwordKey")
    def password_key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the password in the secret.
        """
        return pulumi.get(self, "password_key")

    @password_key.setter
    def password_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password_key", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the secret.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="usernameKey")
    def username_key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the username in the secret.
        """
        return pulumi.get(self, "username_key")

    @username_key.setter
    def username_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username_key", value)


if not MYPY:
    class AkriConnectorTemplateHelmConfigurationSettingsArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmConfiguration properties.
        """
        release_name: pulumi.Input[_builtins.str]
        """
        The release name of the Helm chart.
        """
        repository_name: pulumi.Input[_builtins.str]
        """
        The name of the repository
        """
        version: pulumi.Input[_builtins.str]
        """
        The version of the Helm chart.
        """
        advanced_configuration: NotRequired[pulumi.Input['AkriConnectorTemplateHelmAdvancedConfigurationArgsDict']]
        """
        Advanced configuration for the Helm chart.
        Install, upgrade, and uninstall options for the helm chart such as atomic, wait, timeout, `wait_for_jobs`, and `disable_hooks`.
        """
        registry_settings: NotRequired[pulumi.Input[Union['AkriConnectorTemplateHelmContainerRegistryArgsDict', 'AkriConnectorTemplateHelmRegistryEndpointRefArgsDict']]]
        """
        The registry settings for the helm chart to be used.
        """
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A map of values to pass to the helm chart.
        """
elif False:
    AkriConnectorTemplateHelmConfigurationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmConfigurationSettingsArgs:
    def __init__(__self__, *,
                 release_name: pulumi.Input[_builtins.str],
                 repository_name: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str],
                 advanced_configuration: Optional[pulumi.Input['AkriConnectorTemplateHelmAdvancedConfigurationArgs']] = None,
                 registry_settings: Optional[pulumi.Input[Union['AkriConnectorTemplateHelmContainerRegistryArgs', 'AkriConnectorTemplateHelmRegistryEndpointRefArgs']]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        AkriConnectorTemplateHelmConfiguration properties.
        :param pulumi.Input[_builtins.str] release_name: The release name of the Helm chart.
        :param pulumi.Input[_builtins.str] repository_name: The name of the repository
        :param pulumi.Input[_builtins.str] version: The version of the Helm chart.
        :param pulumi.Input['AkriConnectorTemplateHelmAdvancedConfigurationArgs'] advanced_configuration: Advanced configuration for the Helm chart.
               Install, upgrade, and uninstall options for the helm chart such as atomic, wait, timeout, `wait_for_jobs`, and `disable_hooks`.
        :param pulumi.Input[Union['AkriConnectorTemplateHelmContainerRegistryArgs', 'AkriConnectorTemplateHelmRegistryEndpointRefArgs']] registry_settings: The registry settings for the helm chart to be used.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] values: A map of values to pass to the helm chart.
        """
        pulumi.set(__self__, "release_name", release_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "version", version)
        if advanced_configuration is not None:
            pulumi.set(__self__, "advanced_configuration", advanced_configuration)
        if registry_settings is not None:
            pulumi.set(__self__, "registry_settings", registry_settings)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="releaseName")
    def release_name(self) -> pulumi.Input[_builtins.str]:
        """
        The release name of the Helm chart.
        """
        return pulumi.get(self, "release_name")

    @release_name.setter
    def release_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "release_name", value)

    @_builtins.property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the repository
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "repository_name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        The version of the Helm chart.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="advancedConfiguration")
    def advanced_configuration(self) -> Optional[pulumi.Input['AkriConnectorTemplateHelmAdvancedConfigurationArgs']]:
        """
        Advanced configuration for the Helm chart.
        Install, upgrade, and uninstall options for the helm chart such as atomic, wait, timeout, `wait_for_jobs`, and `disable_hooks`.
        """
        return pulumi.get(self, "advanced_configuration")

    @advanced_configuration.setter
    def advanced_configuration(self, value: Optional[pulumi.Input['AkriConnectorTemplateHelmAdvancedConfigurationArgs']]):
        pulumi.set(self, "advanced_configuration", value)

    @_builtins.property
    @pulumi.getter(name="registrySettings")
    def registry_settings(self) -> Optional[pulumi.Input[Union['AkriConnectorTemplateHelmContainerRegistryArgs', 'AkriConnectorTemplateHelmRegistryEndpointRefArgs']]]:
        """
        The registry settings for the helm chart to be used.
        """
        return pulumi.get(self, "registry_settings")

    @registry_settings.setter
    def registry_settings(self, value: Optional[pulumi.Input[Union['AkriConnectorTemplateHelmContainerRegistryArgs', 'AkriConnectorTemplateHelmRegistryEndpointRefArgs']]]):
        pulumi.set(self, "registry_settings", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A map of values to pass to the helm chart.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AkriConnectorTemplateHelmConfigurationArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmConfiguration properties.
        """
        helm_configuration_settings: pulumi.Input['AkriConnectorTemplateHelmConfigurationSettingsArgsDict']
        """
        The Helm configuration settings.
        """
        runtime_configuration_type: pulumi.Input[_builtins.str]
        """
        Runtime configuration types.
        Expected value is 'HelmConfiguration'.
        """
elif False:
    AkriConnectorTemplateHelmConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmConfigurationArgs:
    def __init__(__self__, *,
                 helm_configuration_settings: pulumi.Input['AkriConnectorTemplateHelmConfigurationSettingsArgs'],
                 runtime_configuration_type: pulumi.Input[_builtins.str]):
        """
        AkriConnectorTemplateHelmConfiguration properties.
        :param pulumi.Input['AkriConnectorTemplateHelmConfigurationSettingsArgs'] helm_configuration_settings: The Helm configuration settings.
        :param pulumi.Input[_builtins.str] runtime_configuration_type: Runtime configuration types.
               Expected value is 'HelmConfiguration'.
        """
        pulumi.set(__self__, "helm_configuration_settings", helm_configuration_settings)
        pulumi.set(__self__, "runtime_configuration_type", 'HelmConfiguration')

    @_builtins.property
    @pulumi.getter(name="helmConfigurationSettings")
    def helm_configuration_settings(self) -> pulumi.Input['AkriConnectorTemplateHelmConfigurationSettingsArgs']:
        """
        The Helm configuration settings.
        """
        return pulumi.get(self, "helm_configuration_settings")

    @helm_configuration_settings.setter
    def helm_configuration_settings(self, value: pulumi.Input['AkriConnectorTemplateHelmConfigurationSettingsArgs']):
        pulumi.set(self, "helm_configuration_settings", value)

    @_builtins.property
    @pulumi.getter(name="runtimeConfigurationType")
    def runtime_configuration_type(self) -> pulumi.Input[_builtins.str]:
        """
        Runtime configuration types.
        Expected value is 'HelmConfiguration'.
        """
        return pulumi.get(self, "runtime_configuration_type")

    @runtime_configuration_type.setter
    def runtime_configuration_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runtime_configuration_type", value)


if not MYPY:
    class AkriConnectorTemplateHelmContainerRegistrySettingsArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmContainerRegistrySettings properties.
        """
        registry: pulumi.Input[_builtins.str]
        """
        The registry to use for the Helm chart.
        """
        auth_secret_ref: NotRequired[pulumi.Input['AkriConnectorTemplateHelmAuthSecretRefArgsDict']]
        """
        Optional reference to a secret in the same namespace to use for pulling the Helm chart.
        """
elif False:
    AkriConnectorTemplateHelmContainerRegistrySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmContainerRegistrySettingsArgs:
    def __init__(__self__, *,
                 registry: pulumi.Input[_builtins.str],
                 auth_secret_ref: Optional[pulumi.Input['AkriConnectorTemplateHelmAuthSecretRefArgs']] = None):
        """
        AkriConnectorTemplateHelmContainerRegistrySettings properties.
        :param pulumi.Input[_builtins.str] registry: The registry to use for the Helm chart.
        :param pulumi.Input['AkriConnectorTemplateHelmAuthSecretRefArgs'] auth_secret_ref: Optional reference to a secret in the same namespace to use for pulling the Helm chart.
        """
        pulumi.set(__self__, "registry", registry)
        if auth_secret_ref is not None:
            pulumi.set(__self__, "auth_secret_ref", auth_secret_ref)

    @_builtins.property
    @pulumi.getter
    def registry(self) -> pulumi.Input[_builtins.str]:
        """
        The registry to use for the Helm chart.
        """
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry", value)

    @_builtins.property
    @pulumi.getter(name="authSecretRef")
    def auth_secret_ref(self) -> Optional[pulumi.Input['AkriConnectorTemplateHelmAuthSecretRefArgs']]:
        """
        Optional reference to a secret in the same namespace to use for pulling the Helm chart.
        """
        return pulumi.get(self, "auth_secret_ref")

    @auth_secret_ref.setter
    def auth_secret_ref(self, value: Optional[pulumi.Input['AkriConnectorTemplateHelmAuthSecretRefArgs']]):
        pulumi.set(self, "auth_secret_ref", value)


if not MYPY:
    class AkriConnectorTemplateHelmContainerRegistryArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmContainerRegistry properties.
        """
        container_registry_settings: pulumi.Input['AkriConnectorTemplateHelmContainerRegistrySettingsArgsDict']
        """
        The registry settings for the container registry.
        """
        registry_settings_type: pulumi.Input[_builtins.str]
        """
        AkriConnectorTemplateHelmRegistrySettingsType values.
        Expected value is 'ContainerRegistry'.
        """
elif False:
    AkriConnectorTemplateHelmContainerRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmContainerRegistryArgs:
    def __init__(__self__, *,
                 container_registry_settings: pulumi.Input['AkriConnectorTemplateHelmContainerRegistrySettingsArgs'],
                 registry_settings_type: pulumi.Input[_builtins.str]):
        """
        AkriConnectorTemplateHelmContainerRegistry properties.
        :param pulumi.Input['AkriConnectorTemplateHelmContainerRegistrySettingsArgs'] container_registry_settings: The registry settings for the container registry.
        :param pulumi.Input[_builtins.str] registry_settings_type: AkriConnectorTemplateHelmRegistrySettingsType values.
               Expected value is 'ContainerRegistry'.
        """
        pulumi.set(__self__, "container_registry_settings", container_registry_settings)
        pulumi.set(__self__, "registry_settings_type", 'ContainerRegistry')

    @_builtins.property
    @pulumi.getter(name="containerRegistrySettings")
    def container_registry_settings(self) -> pulumi.Input['AkriConnectorTemplateHelmContainerRegistrySettingsArgs']:
        """
        The registry settings for the container registry.
        """
        return pulumi.get(self, "container_registry_settings")

    @container_registry_settings.setter
    def container_registry_settings(self, value: pulumi.Input['AkriConnectorTemplateHelmContainerRegistrySettingsArgs']):
        pulumi.set(self, "container_registry_settings", value)

    @_builtins.property
    @pulumi.getter(name="registrySettingsType")
    def registry_settings_type(self) -> pulumi.Input[_builtins.str]:
        """
        AkriConnectorTemplateHelmRegistrySettingsType values.
        Expected value is 'ContainerRegistry'.
        """
        return pulumi.get(self, "registry_settings_type")

    @registry_settings_type.setter
    def registry_settings_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_settings_type", value)


if not MYPY:
    class AkriConnectorTemplateHelmDeleteConfigurationArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmDeleteConfiguration properties.
        """
        atomic: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        """
        disable_hooks: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable pre/post upgrade hooks for the operation.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        """
        wait: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        """
        wait_for_jobs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the operation will wait for jobs to complete before marking the release as successful.
        """
elif False:
    AkriConnectorTemplateHelmDeleteConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmDeleteConfigurationArgs:
    def __init__(__self__, *,
                 atomic: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_hooks: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 wait: Optional[pulumi.Input[_builtins.bool]] = None,
                 wait_for_jobs: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        AkriConnectorTemplateHelmDeleteConfiguration properties.
        :param pulumi.Input[_builtins.bool] atomic: If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        :param pulumi.Input[_builtins.bool] disable_hooks: Disable pre/post upgrade hooks for the operation.
        :param pulumi.Input[_builtins.int] timeout: Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        :param pulumi.Input[_builtins.bool] wait: If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        :param pulumi.Input[_builtins.bool] wait_for_jobs: If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        if atomic is not None:
            pulumi.set(__self__, "atomic", atomic)
        if disable_hooks is not None:
            pulumi.set(__self__, "disable_hooks", disable_hooks)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)
        if wait_for_jobs is not None:
            pulumi.set(__self__, "wait_for_jobs", wait_for_jobs)

    @_builtins.property
    @pulumi.getter
    def atomic(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        """
        return pulumi.get(self, "atomic")

    @atomic.setter
    def atomic(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "atomic", value)

    @_builtins.property
    @pulumi.getter(name="disableHooks")
    def disable_hooks(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable pre/post upgrade hooks for the operation.
        """
        return pulumi.get(self, "disable_hooks")

    @disable_hooks.setter
    def disable_hooks(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_hooks", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "wait", value)

    @_builtins.property
    @pulumi.getter(name="waitForJobs")
    def wait_for_jobs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        return pulumi.get(self, "wait_for_jobs")

    @wait_for_jobs.setter
    def wait_for_jobs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "wait_for_jobs", value)


if not MYPY:
    class AkriConnectorTemplateHelmInstallConfigurationArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmInstallConfiguration properties.
        """
        atomic: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        """
        disable_hooks: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable pre/post upgrade hooks for the operation.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        """
        wait: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        """
        wait_for_jobs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the operation will wait for jobs to complete before marking the release as successful.
        """
elif False:
    AkriConnectorTemplateHelmInstallConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmInstallConfigurationArgs:
    def __init__(__self__, *,
                 atomic: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_hooks: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 wait: Optional[pulumi.Input[_builtins.bool]] = None,
                 wait_for_jobs: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        AkriConnectorTemplateHelmInstallConfiguration properties.
        :param pulumi.Input[_builtins.bool] atomic: If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        :param pulumi.Input[_builtins.bool] disable_hooks: Disable pre/post upgrade hooks for the operation.
        :param pulumi.Input[_builtins.int] timeout: Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        :param pulumi.Input[_builtins.bool] wait: If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        :param pulumi.Input[_builtins.bool] wait_for_jobs: If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        if atomic is not None:
            pulumi.set(__self__, "atomic", atomic)
        if disable_hooks is not None:
            pulumi.set(__self__, "disable_hooks", disable_hooks)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)
        if wait_for_jobs is not None:
            pulumi.set(__self__, "wait_for_jobs", wait_for_jobs)

    @_builtins.property
    @pulumi.getter
    def atomic(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        """
        return pulumi.get(self, "atomic")

    @atomic.setter
    def atomic(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "atomic", value)

    @_builtins.property
    @pulumi.getter(name="disableHooks")
    def disable_hooks(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable pre/post upgrade hooks for the operation.
        """
        return pulumi.get(self, "disable_hooks")

    @disable_hooks.setter
    def disable_hooks(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_hooks", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "wait", value)

    @_builtins.property
    @pulumi.getter(name="waitForJobs")
    def wait_for_jobs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        return pulumi.get(self, "wait_for_jobs")

    @wait_for_jobs.setter
    def wait_for_jobs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "wait_for_jobs", value)


if not MYPY:
    class AkriConnectorTemplateHelmRegistryEndpointRefArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmRegistryEndpointRef properties.
        """
        registry_endpoint_ref: pulumi.Input[_builtins.str]
        """
        The name of the registry endpoint.
        """
        registry_settings_type: pulumi.Input[_builtins.str]
        """
        AkriConnectorTemplateHelmRegistrySettingsType values.
        Expected value is 'RegistryEndpointRef'.
        """
elif False:
    AkriConnectorTemplateHelmRegistryEndpointRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmRegistryEndpointRefArgs:
    def __init__(__self__, *,
                 registry_endpoint_ref: pulumi.Input[_builtins.str],
                 registry_settings_type: pulumi.Input[_builtins.str]):
        """
        AkriConnectorTemplateHelmRegistryEndpointRef properties.
        :param pulumi.Input[_builtins.str] registry_endpoint_ref: The name of the registry endpoint.
        :param pulumi.Input[_builtins.str] registry_settings_type: AkriConnectorTemplateHelmRegistrySettingsType values.
               Expected value is 'RegistryEndpointRef'.
        """
        pulumi.set(__self__, "registry_endpoint_ref", registry_endpoint_ref)
        pulumi.set(__self__, "registry_settings_type", 'RegistryEndpointRef')

    @_builtins.property
    @pulumi.getter(name="registryEndpointRef")
    def registry_endpoint_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the registry endpoint.
        """
        return pulumi.get(self, "registry_endpoint_ref")

    @registry_endpoint_ref.setter
    def registry_endpoint_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_endpoint_ref", value)

    @_builtins.property
    @pulumi.getter(name="registrySettingsType")
    def registry_settings_type(self) -> pulumi.Input[_builtins.str]:
        """
        AkriConnectorTemplateHelmRegistrySettingsType values.
        Expected value is 'RegistryEndpointRef'.
        """
        return pulumi.get(self, "registry_settings_type")

    @registry_settings_type.setter
    def registry_settings_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_settings_type", value)


if not MYPY:
    class AkriConnectorTemplateHelmUpgradeConfigurationArgsDict(TypedDict):
        """
        AkriConnectorTemplateHelmUpgradeConfiguration properties.
        """
        atomic: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        """
        disable_hooks: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable pre/post upgrade hooks for the operation.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        """
        wait: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        """
        wait_for_jobs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, the operation will wait for jobs to complete before marking the release as successful.
        """
elif False:
    AkriConnectorTemplateHelmUpgradeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateHelmUpgradeConfigurationArgs:
    def __init__(__self__, *,
                 atomic: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_hooks: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 wait: Optional[pulumi.Input[_builtins.bool]] = None,
                 wait_for_jobs: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        AkriConnectorTemplateHelmUpgradeConfiguration properties.
        :param pulumi.Input[_builtins.bool] atomic: If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        :param pulumi.Input[_builtins.bool] disable_hooks: Disable pre/post upgrade hooks for the operation.
        :param pulumi.Input[_builtins.int] timeout: Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        :param pulumi.Input[_builtins.bool] wait: If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        :param pulumi.Input[_builtins.bool] wait_for_jobs: If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        if atomic is not None:
            pulumi.set(__self__, "atomic", atomic)
        if disable_hooks is not None:
            pulumi.set(__self__, "disable_hooks", disable_hooks)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)
        if wait_for_jobs is not None:
            pulumi.set(__self__, "wait_for_jobs", wait_for_jobs)

    @_builtins.property
    @pulumi.getter
    def atomic(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        """
        return pulumi.get(self, "atomic")

    @atomic.setter
    def atomic(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "atomic", value)

    @_builtins.property
    @pulumi.getter(name="disableHooks")
    def disable_hooks(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable pre/post upgrade hooks for the operation.
        """
        return pulumi.get(self, "disable_hooks")

    @disable_hooks.setter
    def disable_hooks(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_hooks", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def wait(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        """
        return pulumi.get(self, "wait")

    @wait.setter
    def wait(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "wait", value)

    @_builtins.property
    @pulumi.getter(name="waitForJobs")
    def wait_for_jobs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        return pulumi.get(self, "wait_for_jobs")

    @wait_for_jobs.setter
    def wait_for_jobs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "wait_for_jobs", value)


if not MYPY:
    class AkriConnectorTemplateManagedConfigurationArgsDict(TypedDict):
        """
        AkriConnectorTemplateManagedConfiguration properties.
        """
        managed_configuration_settings: pulumi.Input[Union['AkriConnectorTemplateRuntimeImageConfigurationArgsDict', 'AkriConnectorTemplateRuntimeStatefulSetConfigurationArgsDict']]
        """
        The managed configuration settings.
        """
        runtime_configuration_type: pulumi.Input[_builtins.str]
        """
        Runtime configuration types.
        Expected value is 'ManagedConfiguration'.
        """
elif False:
    AkriConnectorTemplateManagedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateManagedConfigurationArgs:
    def __init__(__self__, *,
                 managed_configuration_settings: pulumi.Input[Union['AkriConnectorTemplateRuntimeImageConfigurationArgs', 'AkriConnectorTemplateRuntimeStatefulSetConfigurationArgs']],
                 runtime_configuration_type: pulumi.Input[_builtins.str]):
        """
        AkriConnectorTemplateManagedConfiguration properties.
        :param pulumi.Input[Union['AkriConnectorTemplateRuntimeImageConfigurationArgs', 'AkriConnectorTemplateRuntimeStatefulSetConfigurationArgs']] managed_configuration_settings: The managed configuration settings.
        :param pulumi.Input[_builtins.str] runtime_configuration_type: Runtime configuration types.
               Expected value is 'ManagedConfiguration'.
        """
        pulumi.set(__self__, "managed_configuration_settings", managed_configuration_settings)
        pulumi.set(__self__, "runtime_configuration_type", 'ManagedConfiguration')

    @_builtins.property
    @pulumi.getter(name="managedConfigurationSettings")
    def managed_configuration_settings(self) -> pulumi.Input[Union['AkriConnectorTemplateRuntimeImageConfigurationArgs', 'AkriConnectorTemplateRuntimeStatefulSetConfigurationArgs']]:
        """
        The managed configuration settings.
        """
        return pulumi.get(self, "managed_configuration_settings")

    @managed_configuration_settings.setter
    def managed_configuration_settings(self, value: pulumi.Input[Union['AkriConnectorTemplateRuntimeImageConfigurationArgs', 'AkriConnectorTemplateRuntimeStatefulSetConfigurationArgs']]):
        pulumi.set(self, "managed_configuration_settings", value)

    @_builtins.property
    @pulumi.getter(name="runtimeConfigurationType")
    def runtime_configuration_type(self) -> pulumi.Input[_builtins.str]:
        """
        Runtime configuration types.
        Expected value is 'ManagedConfiguration'.
        """
        return pulumi.get(self, "runtime_configuration_type")

    @runtime_configuration_type.setter
    def runtime_configuration_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runtime_configuration_type", value)


if not MYPY:
    class AkriConnectorTemplatePersistentVolumeClaimArgsDict(TypedDict):
        """
        AkriConnectorTemplatePersistentVolumeClaim properties.
        """
        claim_name: pulumi.Input[_builtins.str]
        """
        The name of the persistent volume claim.
        """
        mount_path: pulumi.Input[_builtins.str]
        """
        The mount path for the persistent volume claim.
        """
elif False:
    AkriConnectorTemplatePersistentVolumeClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplatePersistentVolumeClaimArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 mount_path: pulumi.Input[_builtins.str]):
        """
        AkriConnectorTemplatePersistentVolumeClaim properties.
        :param pulumi.Input[_builtins.str] claim_name: The name of the persistent volume claim.
        :param pulumi.Input[_builtins.str] mount_path: The mount path for the persistent volume claim.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "mount_path", mount_path)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the persistent volume claim.
        """
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        The mount path for the persistent volume claim.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class AkriConnectorTemplatePropertiesArgsDict(TypedDict):
        """
        AkriConnectorTemplate properties.
        """
        device_inbound_endpoint_types: pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointTypeArgsDict']]]
        """
        Device inbound endpoint types.
        """
        runtime_configuration: pulumi.Input[Union['AkriConnectorTemplateHelmConfigurationArgsDict', 'AkriConnectorTemplateManagedConfigurationArgsDict']]
        """
        The runtime configuration for the Connector template.
        """
        aio_metadata: NotRequired[pulumi.Input['AkriConnectorTemplateAioMetadataArgsDict']]
        """
        Metadata about AIO.
        """
        diagnostics: NotRequired[pulumi.Input['AkriConnectorTemplateDiagnosticsArgsDict']]
        """
        Diagnostics settings for the Connector template.
        """
        mqtt_connection_configuration: NotRequired[pulumi.Input['AkriConnectorsMqttConnectionConfigurationArgsDict']]
        """
        Mqtt connection configuration settings.
        """
elif False:
    AkriConnectorTemplatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplatePropertiesArgs:
    def __init__(__self__, *,
                 device_inbound_endpoint_types: pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointTypeArgs']]],
                 runtime_configuration: pulumi.Input[Union['AkriConnectorTemplateHelmConfigurationArgs', 'AkriConnectorTemplateManagedConfigurationArgs']],
                 aio_metadata: Optional[pulumi.Input['AkriConnectorTemplateAioMetadataArgs']] = None,
                 diagnostics: Optional[pulumi.Input['AkriConnectorTemplateDiagnosticsArgs']] = None,
                 mqtt_connection_configuration: Optional[pulumi.Input['AkriConnectorsMqttConnectionConfigurationArgs']] = None):
        """
        AkriConnectorTemplate properties.
        :param pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointTypeArgs']]] device_inbound_endpoint_types: Device inbound endpoint types.
        :param pulumi.Input[Union['AkriConnectorTemplateHelmConfigurationArgs', 'AkriConnectorTemplateManagedConfigurationArgs']] runtime_configuration: The runtime configuration for the Connector template.
        :param pulumi.Input['AkriConnectorTemplateAioMetadataArgs'] aio_metadata: Metadata about AIO.
        :param pulumi.Input['AkriConnectorTemplateDiagnosticsArgs'] diagnostics: Diagnostics settings for the Connector template.
        :param pulumi.Input['AkriConnectorsMqttConnectionConfigurationArgs'] mqtt_connection_configuration: Mqtt connection configuration settings.
        """
        pulumi.set(__self__, "device_inbound_endpoint_types", device_inbound_endpoint_types)
        pulumi.set(__self__, "runtime_configuration", runtime_configuration)
        if aio_metadata is not None:
            pulumi.set(__self__, "aio_metadata", aio_metadata)
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if mqtt_connection_configuration is not None:
            pulumi.set(__self__, "mqtt_connection_configuration", mqtt_connection_configuration)

    @_builtins.property
    @pulumi.getter(name="deviceInboundEndpointTypes")
    def device_inbound_endpoint_types(self) -> pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointTypeArgs']]]:
        """
        Device inbound endpoint types.
        """
        return pulumi.get(self, "device_inbound_endpoint_types")

    @device_inbound_endpoint_types.setter
    def device_inbound_endpoint_types(self, value: pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplateDeviceInboundEndpointTypeArgs']]]):
        pulumi.set(self, "device_inbound_endpoint_types", value)

    @_builtins.property
    @pulumi.getter(name="runtimeConfiguration")
    def runtime_configuration(self) -> pulumi.Input[Union['AkriConnectorTemplateHelmConfigurationArgs', 'AkriConnectorTemplateManagedConfigurationArgs']]:
        """
        The runtime configuration for the Connector template.
        """
        return pulumi.get(self, "runtime_configuration")

    @runtime_configuration.setter
    def runtime_configuration(self, value: pulumi.Input[Union['AkriConnectorTemplateHelmConfigurationArgs', 'AkriConnectorTemplateManagedConfigurationArgs']]):
        pulumi.set(self, "runtime_configuration", value)

    @_builtins.property
    @pulumi.getter(name="aioMetadata")
    def aio_metadata(self) -> Optional[pulumi.Input['AkriConnectorTemplateAioMetadataArgs']]:
        """
        Metadata about AIO.
        """
        return pulumi.get(self, "aio_metadata")

    @aio_metadata.setter
    def aio_metadata(self, value: Optional[pulumi.Input['AkriConnectorTemplateAioMetadataArgs']]):
        pulumi.set(self, "aio_metadata", value)

    @_builtins.property
    @pulumi.getter
    def diagnostics(self) -> Optional[pulumi.Input['AkriConnectorTemplateDiagnosticsArgs']]:
        """
        Diagnostics settings for the Connector template.
        """
        return pulumi.get(self, "diagnostics")

    @diagnostics.setter
    def diagnostics(self, value: Optional[pulumi.Input['AkriConnectorTemplateDiagnosticsArgs']]):
        pulumi.set(self, "diagnostics", value)

    @_builtins.property
    @pulumi.getter(name="mqttConnectionConfiguration")
    def mqtt_connection_configuration(self) -> Optional[pulumi.Input['AkriConnectorsMqttConnectionConfigurationArgs']]:
        """
        Mqtt connection configuration settings.
        """
        return pulumi.get(self, "mqtt_connection_configuration")

    @mqtt_connection_configuration.setter
    def mqtt_connection_configuration(self, value: Optional[pulumi.Input['AkriConnectorsMqttConnectionConfigurationArgs']]):
        pulumi.set(self, "mqtt_connection_configuration", value)


if not MYPY:
    class AkriConnectorTemplateRuntimeImageConfigurationSettingsArgsDict(TypedDict):
        """
        AkriConnectorTemplateRuntimeImageConfiguration properties.
        """
        image_name: pulumi.Input[_builtins.str]
        """
        The image name without any registry reference, tag or digest.
        """
        image_pull_policy: NotRequired[pulumi.Input[Union[_builtins.str, 'AkriConnectorsImagePullPolicy']]]
        """
        The pull policy of the image.
        """
        registry_settings: NotRequired[pulumi.Input[Union['AkriConnectorsContainerRegistryArgsDict', 'AkriConnectorsRegistryEndpointRefArgsDict']]]
        """
        The registry settings for the image. You can omit this field if using the default docker hub repository or using a local image.
        """
        replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of replicas to be set up.
        """
        tag_digest_settings: NotRequired[pulumi.Input[Union['AkriConnectorsDigestArgsDict', 'AkriConnectorsTagArgsDict']]]
        """
        Optional image tag or digest. If not specified, the default tag is `latest`.
        """
elif False:
    AkriConnectorTemplateRuntimeImageConfigurationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateRuntimeImageConfigurationSettingsArgs:
    def __init__(__self__, *,
                 image_name: pulumi.Input[_builtins.str],
                 image_pull_policy: Optional[pulumi.Input[Union[_builtins.str, 'AkriConnectorsImagePullPolicy']]] = None,
                 registry_settings: Optional[pulumi.Input[Union['AkriConnectorsContainerRegistryArgs', 'AkriConnectorsRegistryEndpointRefArgs']]] = None,
                 replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 tag_digest_settings: Optional[pulumi.Input[Union['AkriConnectorsDigestArgs', 'AkriConnectorsTagArgs']]] = None):
        """
        AkriConnectorTemplateRuntimeImageConfiguration properties.
        :param pulumi.Input[_builtins.str] image_name: The image name without any registry reference, tag or digest.
        :param pulumi.Input[Union[_builtins.str, 'AkriConnectorsImagePullPolicy']] image_pull_policy: The pull policy of the image.
        :param pulumi.Input[Union['AkriConnectorsContainerRegistryArgs', 'AkriConnectorsRegistryEndpointRefArgs']] registry_settings: The registry settings for the image. You can omit this field if using the default docker hub repository or using a local image.
        :param pulumi.Input[_builtins.int] replicas: The number of replicas to be set up.
        :param pulumi.Input[Union['AkriConnectorsDigestArgs', 'AkriConnectorsTagArgs']] tag_digest_settings: Optional image tag or digest. If not specified, the default tag is `latest`.
        """
        pulumi.set(__self__, "image_name", image_name)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if registry_settings is not None:
            pulumi.set(__self__, "registry_settings", registry_settings)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if tag_digest_settings is not None:
            pulumi.set(__self__, "tag_digest_settings", tag_digest_settings)

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[_builtins.str]:
        """
        The image name without any registry reference, tag or digest.
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image_name", value)

    @_builtins.property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AkriConnectorsImagePullPolicy']]]:
        """
        The pull policy of the image.
        """
        return pulumi.get(self, "image_pull_policy")

    @image_pull_policy.setter
    def image_pull_policy(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AkriConnectorsImagePullPolicy']]]):
        pulumi.set(self, "image_pull_policy", value)

    @_builtins.property
    @pulumi.getter(name="registrySettings")
    def registry_settings(self) -> Optional[pulumi.Input[Union['AkriConnectorsContainerRegistryArgs', 'AkriConnectorsRegistryEndpointRefArgs']]]:
        """
        The registry settings for the image. You can omit this field if using the default docker hub repository or using a local image.
        """
        return pulumi.get(self, "registry_settings")

    @registry_settings.setter
    def registry_settings(self, value: Optional[pulumi.Input[Union['AkriConnectorsContainerRegistryArgs', 'AkriConnectorsRegistryEndpointRefArgs']]]):
        pulumi.set(self, "registry_settings", value)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of replicas to be set up.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replicas", value)

    @_builtins.property
    @pulumi.getter(name="tagDigestSettings")
    def tag_digest_settings(self) -> Optional[pulumi.Input[Union['AkriConnectorsDigestArgs', 'AkriConnectorsTagArgs']]]:
        """
        Optional image tag or digest. If not specified, the default tag is `latest`.
        """
        return pulumi.get(self, "tag_digest_settings")

    @tag_digest_settings.setter
    def tag_digest_settings(self, value: Optional[pulumi.Input[Union['AkriConnectorsDigestArgs', 'AkriConnectorsTagArgs']]]):
        pulumi.set(self, "tag_digest_settings", value)


if not MYPY:
    class AkriConnectorTemplateRuntimeImageConfigurationArgsDict(TypedDict):
        """
        AkriConnectorTemplateRuntimeImageConfiguration properties.
        """
        image_configuration_settings: pulumi.Input['AkriConnectorTemplateRuntimeImageConfigurationSettingsArgsDict']
        """
        The image configuration settings.
        """
        managed_configuration_type: pulumi.Input[_builtins.str]
        """
        Managed configuration types.
        Expected value is 'ImageConfiguration'.
        """
        additional_configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional configuration for the image of the managed configuration.
        """
        allocation: NotRequired[pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgsDict']]
        """
        Allocation settings for the managed configuration.
        """
        persistent_volume_claim_templates: NotRequired[pulumi.Input[Sequence[Any]]]
        """
        The persistent volume claim templates for the managed configuration.
        See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        """
        persistent_volume_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgsDict']]]]
        """
        The persistent volume claims for the managed configuration.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgsDict']]]]
        """
        Connector secrets that will be mounted onto all connector instances.
        """
        trust_settings: NotRequired[pulumi.Input['AkriConnectorTemplateTrustListArgsDict']]
        """
        Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
elif False:
    AkriConnectorTemplateRuntimeImageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateRuntimeImageConfigurationArgs:
    def __init__(__self__, *,
                 image_configuration_settings: pulumi.Input['AkriConnectorTemplateRuntimeImageConfigurationSettingsArgs'],
                 managed_configuration_type: pulumi.Input[_builtins.str],
                 additional_configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 allocation: Optional[pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgs']] = None,
                 persistent_volume_claim_templates: Optional[pulumi.Input[Sequence[Any]]] = None,
                 persistent_volume_claims: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgs']]]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgs']]]] = None,
                 trust_settings: Optional[pulumi.Input['AkriConnectorTemplateTrustListArgs']] = None):
        """
        AkriConnectorTemplateRuntimeImageConfiguration properties.
        :param pulumi.Input['AkriConnectorTemplateRuntimeImageConfigurationSettingsArgs'] image_configuration_settings: The image configuration settings.
        :param pulumi.Input[_builtins.str] managed_configuration_type: Managed configuration types.
               Expected value is 'ImageConfiguration'.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] additional_configuration: Additional configuration for the image of the managed configuration.
        :param pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgs'] allocation: Allocation settings for the managed configuration.
        :param pulumi.Input[Sequence[Any]] persistent_volume_claim_templates: The persistent volume claim templates for the managed configuration.
               See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        :param pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgs']]] persistent_volume_claims: The persistent volume claims for the managed configuration.
        :param pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgs']]] secrets: Connector secrets that will be mounted onto all connector instances.
        :param pulumi.Input['AkriConnectorTemplateTrustListArgs'] trust_settings: Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
        pulumi.set(__self__, "image_configuration_settings", image_configuration_settings)
        pulumi.set(__self__, "managed_configuration_type", 'ImageConfiguration')
        if additional_configuration is not None:
            pulumi.set(__self__, "additional_configuration", additional_configuration)
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if persistent_volume_claim_templates is not None:
            pulumi.set(__self__, "persistent_volume_claim_templates", persistent_volume_claim_templates)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if trust_settings is not None:
            pulumi.set(__self__, "trust_settings", trust_settings)

    @_builtins.property
    @pulumi.getter(name="imageConfigurationSettings")
    def image_configuration_settings(self) -> pulumi.Input['AkriConnectorTemplateRuntimeImageConfigurationSettingsArgs']:
        """
        The image configuration settings.
        """
        return pulumi.get(self, "image_configuration_settings")

    @image_configuration_settings.setter
    def image_configuration_settings(self, value: pulumi.Input['AkriConnectorTemplateRuntimeImageConfigurationSettingsArgs']):
        pulumi.set(self, "image_configuration_settings", value)

    @_builtins.property
    @pulumi.getter(name="managedConfigurationType")
    def managed_configuration_type(self) -> pulumi.Input[_builtins.str]:
        """
        Managed configuration types.
        Expected value is 'ImageConfiguration'.
        """
        return pulumi.get(self, "managed_configuration_type")

    @managed_configuration_type.setter
    def managed_configuration_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "managed_configuration_type", value)

    @_builtins.property
    @pulumi.getter(name="additionalConfiguration")
    def additional_configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional configuration for the image of the managed configuration.
        """
        return pulumi.get(self, "additional_configuration")

    @additional_configuration.setter
    def additional_configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "additional_configuration", value)

    @_builtins.property
    @pulumi.getter
    def allocation(self) -> Optional[pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgs']]:
        """
        Allocation settings for the managed configuration.
        """
        return pulumi.get(self, "allocation")

    @allocation.setter
    def allocation(self, value: Optional[pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgs']]):
        pulumi.set(self, "allocation", value)

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaimTemplates")
    def persistent_volume_claim_templates(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        The persistent volume claim templates for the managed configuration.
        See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        """
        return pulumi.get(self, "persistent_volume_claim_templates")

    @persistent_volume_claim_templates.setter
    def persistent_volume_claim_templates(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "persistent_volume_claim_templates", value)

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgs']]]]:
        """
        The persistent volume claims for the managed configuration.
        """
        return pulumi.get(self, "persistent_volume_claims")

    @persistent_volume_claims.setter
    def persistent_volume_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgs']]]]):
        pulumi.set(self, "persistent_volume_claims", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgs']]]]:
        """
        Connector secrets that will be mounted onto all connector instances.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @_builtins.property
    @pulumi.getter(name="trustSettings")
    def trust_settings(self) -> Optional[pulumi.Input['AkriConnectorTemplateTrustListArgs']]:
        """
        Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
        return pulumi.get(self, "trust_settings")

    @trust_settings.setter
    def trust_settings(self, value: Optional[pulumi.Input['AkriConnectorTemplateTrustListArgs']]):
        pulumi.set(self, "trust_settings", value)


if not MYPY:
    class AkriConnectorTemplateRuntimeStatefulSetConfigurationArgsDict(TypedDict):
        """
        AkriConnectorTemplateRuntimeStatefulSetConfiguration properties.
        """
        managed_configuration_type: pulumi.Input[_builtins.str]
        """
        Managed configuration types.
        Expected value is 'StatefulSetConfiguration'.
        """
        stateful_set_configuration_settings: Any
        """
        The stateful set configuration settings. This corresponds to the Kubernetes StatefulSet resource.
        See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json#/components/schemas/io.k8s.api.apps.v1.StatefulSetSpec
        """
        additional_configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional configuration for the image of the managed configuration.
        """
        allocation: NotRequired[pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgsDict']]
        """
        Allocation settings for the managed configuration.
        """
        persistent_volume_claim_templates: NotRequired[pulumi.Input[Sequence[Any]]]
        """
        The persistent volume claim templates for the managed configuration.
        See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        """
        persistent_volume_claims: NotRequired[pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgsDict']]]]
        """
        The persistent volume claims for the managed configuration.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgsDict']]]]
        """
        Connector secrets that will be mounted onto all connector instances.
        """
        trust_settings: NotRequired[pulumi.Input['AkriConnectorTemplateTrustListArgsDict']]
        """
        Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
elif False:
    AkriConnectorTemplateRuntimeStatefulSetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateRuntimeStatefulSetConfigurationArgs:
    def __init__(__self__, *,
                 managed_configuration_type: pulumi.Input[_builtins.str],
                 stateful_set_configuration_settings: Any,
                 additional_configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 allocation: Optional[pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgs']] = None,
                 persistent_volume_claim_templates: Optional[pulumi.Input[Sequence[Any]]] = None,
                 persistent_volume_claims: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgs']]]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgs']]]] = None,
                 trust_settings: Optional[pulumi.Input['AkriConnectorTemplateTrustListArgs']] = None):
        """
        AkriConnectorTemplateRuntimeStatefulSetConfiguration properties.
        :param pulumi.Input[_builtins.str] managed_configuration_type: Managed configuration types.
               Expected value is 'StatefulSetConfiguration'.
        :param Any stateful_set_configuration_settings: The stateful set configuration settings. This corresponds to the Kubernetes StatefulSet resource.
               See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json#/components/schemas/io.k8s.api.apps.v1.StatefulSetSpec
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] additional_configuration: Additional configuration for the image of the managed configuration.
        :param pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgs'] allocation: Allocation settings for the managed configuration.
        :param pulumi.Input[Sequence[Any]] persistent_volume_claim_templates: The persistent volume claim templates for the managed configuration.
               See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        :param pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgs']]] persistent_volume_claims: The persistent volume claims for the managed configuration.
        :param pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgs']]] secrets: Connector secrets that will be mounted onto all connector instances.
        :param pulumi.Input['AkriConnectorTemplateTrustListArgs'] trust_settings: Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
        pulumi.set(__self__, "managed_configuration_type", 'StatefulSetConfiguration')
        pulumi.set(__self__, "stateful_set_configuration_settings", stateful_set_configuration_settings)
        if additional_configuration is not None:
            pulumi.set(__self__, "additional_configuration", additional_configuration)
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if persistent_volume_claim_templates is not None:
            pulumi.set(__self__, "persistent_volume_claim_templates", persistent_volume_claim_templates)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if trust_settings is not None:
            pulumi.set(__self__, "trust_settings", trust_settings)

    @_builtins.property
    @pulumi.getter(name="managedConfigurationType")
    def managed_configuration_type(self) -> pulumi.Input[_builtins.str]:
        """
        Managed configuration types.
        Expected value is 'StatefulSetConfiguration'.
        """
        return pulumi.get(self, "managed_configuration_type")

    @managed_configuration_type.setter
    def managed_configuration_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "managed_configuration_type", value)

    @_builtins.property
    @pulumi.getter(name="statefulSetConfigurationSettings")
    def stateful_set_configuration_settings(self) -> Any:
        """
        The stateful set configuration settings. This corresponds to the Kubernetes StatefulSet resource.
        See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json#/components/schemas/io.k8s.api.apps.v1.StatefulSetSpec
        """
        return pulumi.get(self, "stateful_set_configuration_settings")

    @stateful_set_configuration_settings.setter
    def stateful_set_configuration_settings(self, value: Any):
        pulumi.set(self, "stateful_set_configuration_settings", value)

    @_builtins.property
    @pulumi.getter(name="additionalConfiguration")
    def additional_configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional configuration for the image of the managed configuration.
        """
        return pulumi.get(self, "additional_configuration")

    @additional_configuration.setter
    def additional_configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "additional_configuration", value)

    @_builtins.property
    @pulumi.getter
    def allocation(self) -> Optional[pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgs']]:
        """
        Allocation settings for the managed configuration.
        """
        return pulumi.get(self, "allocation")

    @allocation.setter
    def allocation(self, value: Optional[pulumi.Input['AkriConnectorTemplateBucketizedAllocationArgs']]):
        pulumi.set(self, "allocation", value)

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaimTemplates")
    def persistent_volume_claim_templates(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        The persistent volume claim templates for the managed configuration.
        See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        """
        return pulumi.get(self, "persistent_volume_claim_templates")

    @persistent_volume_claim_templates.setter
    def persistent_volume_claim_templates(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "persistent_volume_claim_templates", value)

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgs']]]]:
        """
        The persistent volume claims for the managed configuration.
        """
        return pulumi.get(self, "persistent_volume_claims")

    @persistent_volume_claims.setter
    def persistent_volume_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorTemplatePersistentVolumeClaimArgs']]]]):
        pulumi.set(self, "persistent_volume_claims", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgs']]]]:
        """
        Connector secrets that will be mounted onto all connector instances.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsSecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @_builtins.property
    @pulumi.getter(name="trustSettings")
    def trust_settings(self) -> Optional[pulumi.Input['AkriConnectorTemplateTrustListArgs']]:
        """
        Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
        return pulumi.get(self, "trust_settings")

    @trust_settings.setter
    def trust_settings(self, value: Optional[pulumi.Input['AkriConnectorTemplateTrustListArgs']]):
        pulumi.set(self, "trust_settings", value)


if not MYPY:
    class AkriConnectorTemplateTrustListArgsDict(TypedDict):
        """
        AkriConnectorTemplateTrustList properties.
        """
        trust_list_secret_ref: pulumi.Input[_builtins.str]
        """
        The secret reference for certificates to trust.
        """
elif False:
    AkriConnectorTemplateTrustListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorTemplateTrustListArgs:
    def __init__(__self__, *,
                 trust_list_secret_ref: pulumi.Input[_builtins.str]):
        """
        AkriConnectorTemplateTrustList properties.
        :param pulumi.Input[_builtins.str] trust_list_secret_ref: The secret reference for certificates to trust.
        """
        pulumi.set(__self__, "trust_list_secret_ref", trust_list_secret_ref)

    @_builtins.property
    @pulumi.getter(name="trustListSecretRef")
    def trust_list_secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The secret reference for certificates to trust.
        """
        return pulumi.get(self, "trust_list_secret_ref")

    @trust_list_secret_ref.setter
    def trust_list_secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "trust_list_secret_ref", value)


if not MYPY:
    class AkriConnectorsContainerRegistrySettingsArgsDict(TypedDict):
        """
        AkriConnectorsContainerRegistry properties.
        """
        registry: pulumi.Input[_builtins.str]
        """
        The container registry to use for the artifact.
        """
        image_pull_secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsImagePullSecretArgsDict']]]]
        """
        Optional list of references to secrets in the same namespace to use for pulling the connector image.
        """
elif False:
    AkriConnectorsContainerRegistrySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsContainerRegistrySettingsArgs:
    def __init__(__self__, *,
                 registry: pulumi.Input[_builtins.str],
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsImagePullSecretArgs']]]] = None):
        """
        AkriConnectorsContainerRegistry properties.
        :param pulumi.Input[_builtins.str] registry: The container registry to use for the artifact.
        :param pulumi.Input[Sequence[pulumi.Input['AkriConnectorsImagePullSecretArgs']]] image_pull_secrets: Optional list of references to secrets in the same namespace to use for pulling the connector image.
        """
        pulumi.set(__self__, "registry", registry)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)

    @_builtins.property
    @pulumi.getter
    def registry(self) -> pulumi.Input[_builtins.str]:
        """
        The container registry to use for the artifact.
        """
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry", value)

    @_builtins.property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsImagePullSecretArgs']]]]:
        """
        Optional list of references to secrets in the same namespace to use for pulling the connector image.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AkriConnectorsImagePullSecretArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)


if not MYPY:
    class AkriConnectorsContainerRegistryArgsDict(TypedDict):
        """
        AkriConnectorsContainerRegistry properties.
        """
        container_registry_settings: pulumi.Input['AkriConnectorsContainerRegistrySettingsArgsDict']
        """
        The registry settings for the container registry.
        """
        registry_settings_type: pulumi.Input[_builtins.str]
        """
        AkriConnectorsRegistrySettings properties.
        Expected value is 'ContainerRegistry'.
        """
elif False:
    AkriConnectorsContainerRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsContainerRegistryArgs:
    def __init__(__self__, *,
                 container_registry_settings: pulumi.Input['AkriConnectorsContainerRegistrySettingsArgs'],
                 registry_settings_type: pulumi.Input[_builtins.str]):
        """
        AkriConnectorsContainerRegistry properties.
        :param pulumi.Input['AkriConnectorsContainerRegistrySettingsArgs'] container_registry_settings: The registry settings for the container registry.
        :param pulumi.Input[_builtins.str] registry_settings_type: AkriConnectorsRegistrySettings properties.
               Expected value is 'ContainerRegistry'.
        """
        pulumi.set(__self__, "container_registry_settings", container_registry_settings)
        pulumi.set(__self__, "registry_settings_type", 'ContainerRegistry')

    @_builtins.property
    @pulumi.getter(name="containerRegistrySettings")
    def container_registry_settings(self) -> pulumi.Input['AkriConnectorsContainerRegistrySettingsArgs']:
        """
        The registry settings for the container registry.
        """
        return pulumi.get(self, "container_registry_settings")

    @container_registry_settings.setter
    def container_registry_settings(self, value: pulumi.Input['AkriConnectorsContainerRegistrySettingsArgs']):
        pulumi.set(self, "container_registry_settings", value)

    @_builtins.property
    @pulumi.getter(name="registrySettingsType")
    def registry_settings_type(self) -> pulumi.Input[_builtins.str]:
        """
        AkriConnectorsRegistrySettings properties.
        Expected value is 'ContainerRegistry'.
        """
        return pulumi.get(self, "registry_settings_type")

    @registry_settings_type.setter
    def registry_settings_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_settings_type", value)


if not MYPY:
    class AkriConnectorsDiagnosticsLogsArgsDict(TypedDict):
        """
        AkriConnectorsDiagnostic Log properties.
        """
        level: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
elif False:
    AkriConnectorsDiagnosticsLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsDiagnosticsLogsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        AkriConnectorsDiagnostic Log properties.
        :param pulumi.Input[_builtins.str] level: The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        if level is None:
            level = 'info'
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class AkriConnectorsDigestArgsDict(TypedDict):
        """
        AkriConnectorsDigest properties.
        """
        digest: pulumi.Input[_builtins.str]
        """
        The digest of the image.
        """
        tag_digest_type: pulumi.Input[_builtins.str]
        """
        AkriConnectorsTagDigestType values.
        Expected value is 'Digest'.
        """
elif False:
    AkriConnectorsDigestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsDigestArgs:
    def __init__(__self__, *,
                 digest: pulumi.Input[_builtins.str],
                 tag_digest_type: pulumi.Input[_builtins.str]):
        """
        AkriConnectorsDigest properties.
        :param pulumi.Input[_builtins.str] digest: The digest of the image.
        :param pulumi.Input[_builtins.str] tag_digest_type: AkriConnectorsTagDigestType values.
               Expected value is 'Digest'.
        """
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "tag_digest_type", 'Digest')

    @_builtins.property
    @pulumi.getter
    def digest(self) -> pulumi.Input[_builtins.str]:
        """
        The digest of the image.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "digest", value)

    @_builtins.property
    @pulumi.getter(name="tagDigestType")
    def tag_digest_type(self) -> pulumi.Input[_builtins.str]:
        """
        AkriConnectorsTagDigestType values.
        Expected value is 'Digest'.
        """
        return pulumi.get(self, "tag_digest_type")

    @tag_digest_type.setter
    def tag_digest_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_digest_type", value)


if not MYPY:
    class AkriConnectorsImagePullSecretArgsDict(TypedDict):
        """
        AkriConnectorsImagePullSecret properties.
        """
        secret_ref: pulumi.Input[_builtins.str]
        """
        The name of the image pull secret.
        """
elif False:
    AkriConnectorsImagePullSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsImagePullSecretArgs:
    def __init__(__self__, *,
                 secret_ref: pulumi.Input[_builtins.str]):
        """
        AkriConnectorsImagePullSecret properties.
        :param pulumi.Input[_builtins.str] secret_ref: The name of the image pull secret.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the image pull secret.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class AkriConnectorsMqttConnectionConfigurationArgsDict(TypedDict):
        """
        AkriConnectorsMqttConnectionConfiguration properties.
        """
        authentication: NotRequired[pulumi.Input['AkriConnectorsServiceAccountAuthenticationArgsDict']]
        """
        Authentication properties.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host of the Broker in the form of <hostname>:<port>.
        """
        keep_alive_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        KeepAlive for connection in seconds.
        """
        max_inflight_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        """
        protocol: NotRequired[pulumi.Input[Union[_builtins.str, 'AkriConnectorsMqttProtocolType']]]
        """
        The protocol to use for the connection. Currently only `mqtt` is supported.
        """
        session_expiry_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Session expiry in seconds.
        """
        tls: NotRequired[pulumi.Input['TlsPropertiesArgsDict']]
        """
        TLS configuration.
        """
elif False:
    AkriConnectorsMqttConnectionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsMqttConnectionConfigurationArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['AkriConnectorsServiceAccountAuthenticationArgs']] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 keep_alive_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 max_inflight_messages: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[Union[_builtins.str, 'AkriConnectorsMqttProtocolType']]] = None,
                 session_expiry_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 tls: Optional[pulumi.Input['TlsPropertiesArgs']] = None):
        """
        AkriConnectorsMqttConnectionConfiguration properties.
        :param pulumi.Input['AkriConnectorsServiceAccountAuthenticationArgs'] authentication: Authentication properties.
        :param pulumi.Input[_builtins.str] host: Host of the Broker in the form of <hostname>:<port>.
        :param pulumi.Input[_builtins.int] keep_alive_seconds: KeepAlive for connection in seconds.
        :param pulumi.Input[_builtins.int] max_inflight_messages: The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        :param pulumi.Input[Union[_builtins.str, 'AkriConnectorsMqttProtocolType']] protocol: The protocol to use for the connection. Currently only `mqtt` is supported.
        :param pulumi.Input[_builtins.int] session_expiry_seconds: Session expiry in seconds.
        :param pulumi.Input['TlsPropertiesArgs'] tls: TLS configuration.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_alive_seconds is not None:
            pulumi.set(__self__, "keep_alive_seconds", keep_alive_seconds)
        if max_inflight_messages is not None:
            pulumi.set(__self__, "max_inflight_messages", max_inflight_messages)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if session_expiry_seconds is not None:
            pulumi.set(__self__, "session_expiry_seconds", session_expiry_seconds)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['AkriConnectorsServiceAccountAuthenticationArgs']]:
        """
        Authentication properties.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['AkriConnectorsServiceAccountAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host of the Broker in the form of <hostname>:<port>.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveSeconds")
    def keep_alive_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        KeepAlive for connection in seconds.
        """
        return pulumi.get(self, "keep_alive_seconds")

    @keep_alive_seconds.setter
    def keep_alive_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_seconds", value)

    @_builtins.property
    @pulumi.getter(name="maxInflightMessages")
    def max_inflight_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        """
        return pulumi.get(self, "max_inflight_messages")

    @max_inflight_messages.setter
    def max_inflight_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_inflight_messages", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[_builtins.str, 'AkriConnectorsMqttProtocolType']]]:
        """
        The protocol to use for the connection. Currently only `mqtt` is supported.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[_builtins.str, 'AkriConnectorsMqttProtocolType']]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="sessionExpirySeconds")
    def session_expiry_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Session expiry in seconds.
        """
        return pulumi.get(self, "session_expiry_seconds")

    @session_expiry_seconds.setter
    def session_expiry_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "session_expiry_seconds", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['TlsPropertiesArgs']]:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['TlsPropertiesArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class AkriConnectorsRegistryEndpointRefArgsDict(TypedDict):
        """
        AkriConnectorsRegistryEndpointRef properties.
        """
        registry_endpoint_ref: pulumi.Input[_builtins.str]
        """
        The name of the registry endpoint.
        """
        registry_settings_type: pulumi.Input[_builtins.str]
        """
        AkriConnectorsRegistrySettings properties.
        Expected value is 'RegistryEndpointRef'.
        """
elif False:
    AkriConnectorsRegistryEndpointRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsRegistryEndpointRefArgs:
    def __init__(__self__, *,
                 registry_endpoint_ref: pulumi.Input[_builtins.str],
                 registry_settings_type: pulumi.Input[_builtins.str]):
        """
        AkriConnectorsRegistryEndpointRef properties.
        :param pulumi.Input[_builtins.str] registry_endpoint_ref: The name of the registry endpoint.
        :param pulumi.Input[_builtins.str] registry_settings_type: AkriConnectorsRegistrySettings properties.
               Expected value is 'RegistryEndpointRef'.
        """
        pulumi.set(__self__, "registry_endpoint_ref", registry_endpoint_ref)
        pulumi.set(__self__, "registry_settings_type", 'RegistryEndpointRef')

    @_builtins.property
    @pulumi.getter(name="registryEndpointRef")
    def registry_endpoint_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the registry endpoint.
        """
        return pulumi.get(self, "registry_endpoint_ref")

    @registry_endpoint_ref.setter
    def registry_endpoint_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_endpoint_ref", value)

    @_builtins.property
    @pulumi.getter(name="registrySettingsType")
    def registry_settings_type(self) -> pulumi.Input[_builtins.str]:
        """
        AkriConnectorsRegistrySettings properties.
        Expected value is 'RegistryEndpointRef'.
        """
        return pulumi.get(self, "registry_settings_type")

    @registry_settings_type.setter
    def registry_settings_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_settings_type", value)


if not MYPY:
    class AkriConnectorsSecretArgsDict(TypedDict):
        """
        AkriConnectorsSecret properties.
        """
        secret_alias: pulumi.Input[_builtins.str]
        """
        The application-defined alias for the secret.
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        The key in the secret to be mounted.
        """
        secret_ref: pulumi.Input[_builtins.str]
        """
        The name of the secret to be mounted.
        """
elif False:
    AkriConnectorsSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsSecretArgs:
    def __init__(__self__, *,
                 secret_alias: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 secret_ref: pulumi.Input[_builtins.str]):
        """
        AkriConnectorsSecret properties.
        :param pulumi.Input[_builtins.str] secret_alias: The application-defined alias for the secret.
        :param pulumi.Input[_builtins.str] secret_key: The key in the secret to be mounted.
        :param pulumi.Input[_builtins.str] secret_ref: The name of the secret to be mounted.
        """
        pulumi.set(__self__, "secret_alias", secret_alias)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretAlias")
    def secret_alias(self) -> pulumi.Input[_builtins.str]:
        """
        The application-defined alias for the secret.
        """
        return pulumi.get(self, "secret_alias")

    @secret_alias.setter
    def secret_alias(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_alias", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        The key in the secret to be mounted.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the secret to be mounted.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class AkriConnectorsServiceAccountAuthenticationArgsDict(TypedDict):
        """
        AkriConnectorsServiceAccountAuthentication properties.
        """
        method: pulumi.Input[_builtins.str]
        """
        AkriConnectorsMqttAuthenticationMethod properties.
        Expected value is 'ServiceAccountToken'.
        """
        service_account_token_settings: pulumi.Input['AkriConnectorsServiceAccountTokenSettingsArgsDict']
        """
        The service account token for the MQTT connection.
        """
elif False:
    AkriConnectorsServiceAccountAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsServiceAccountAuthenticationArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[_builtins.str],
                 service_account_token_settings: pulumi.Input['AkriConnectorsServiceAccountTokenSettingsArgs']):
        """
        AkriConnectorsServiceAccountAuthentication properties.
        :param pulumi.Input[_builtins.str] method: AkriConnectorsMqttAuthenticationMethod properties.
               Expected value is 'ServiceAccountToken'.
        :param pulumi.Input['AkriConnectorsServiceAccountTokenSettingsArgs'] service_account_token_settings: The service account token for the MQTT connection.
        """
        pulumi.set(__self__, "method", 'ServiceAccountToken')
        pulumi.set(__self__, "service_account_token_settings", service_account_token_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[_builtins.str]:
        """
        AkriConnectorsMqttAuthenticationMethod properties.
        Expected value is 'ServiceAccountToken'.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountTokenSettings")
    def service_account_token_settings(self) -> pulumi.Input['AkriConnectorsServiceAccountTokenSettingsArgs']:
        """
        The service account token for the MQTT connection.
        """
        return pulumi.get(self, "service_account_token_settings")

    @service_account_token_settings.setter
    def service_account_token_settings(self, value: pulumi.Input['AkriConnectorsServiceAccountTokenSettingsArgs']):
        pulumi.set(self, "service_account_token_settings", value)


if not MYPY:
    class AkriConnectorsServiceAccountTokenSettingsArgsDict(TypedDict):
        """
        AkriConnectorsServiceAccountTokenSettings properties.
        """
        audience: pulumi.Input[_builtins.str]
        """
        The audience for the service account token.
        """
elif False:
    AkriConnectorsServiceAccountTokenSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsServiceAccountTokenSettingsArgs:
    def __init__(__self__, *,
                 audience: pulumi.Input[_builtins.str]):
        """
        AkriConnectorsServiceAccountTokenSettings properties.
        :param pulumi.Input[_builtins.str] audience: The audience for the service account token.
        """
        pulumi.set(__self__, "audience", audience)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> pulumi.Input[_builtins.str]:
        """
        The audience for the service account token.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audience", value)


if not MYPY:
    class AkriConnectorsTagArgsDict(TypedDict):
        """
        AkriConnectorsTag properties.
        """
        tag: pulumi.Input[_builtins.str]
        """
        The tag of the image.
        """
        tag_digest_type: pulumi.Input[_builtins.str]
        """
        AkriConnectorsTagDigestType values.
        Expected value is 'Tag'.
        """
elif False:
    AkriConnectorsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AkriConnectorsTagArgs:
    def __init__(__self__, *,
                 tag: pulumi.Input[_builtins.str],
                 tag_digest_type: pulumi.Input[_builtins.str]):
        """
        AkriConnectorsTag properties.
        :param pulumi.Input[_builtins.str] tag: The tag of the image.
        :param pulumi.Input[_builtins.str] tag_digest_type: AkriConnectorsTagDigestType values.
               Expected value is 'Tag'.
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tag_digest_type", 'Tag')

    @_builtins.property
    @pulumi.getter
    def tag(self) -> pulumi.Input[_builtins.str]:
        """
        The tag of the image.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter(name="tagDigestType")
    def tag_digest_type(self) -> pulumi.Input[_builtins.str]:
        """
        AkriConnectorsTagDigestType values.
        Expected value is 'Tag'.
        """
        return pulumi.get(self, "tag_digest_type")

    @tag_digest_type.setter
    def tag_digest_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tag_digest_type", value)


if not MYPY:
    class AuthorizationConfigArgsDict(TypedDict):
        """
        Broker AuthorizationConfig properties
        """
        cache: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        Enable caching of the authorization rules.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgsDict']]]]
        """
        The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
elif False:
    AuthorizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationConfigArgs:
    def __init__(__self__, *,
                 cache: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgs']]]] = None):
        """
        Broker AuthorizationConfig properties
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] cache: Enable caching of the authorization rules.
        :param pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgs']]] rules: The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        if cache is None:
            cache = 'Enabled'
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        Enable caching of the authorization rules.
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "cache", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgs']]]]:
        """
        The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AuthorizationRuleArgsDict(TypedDict):
        """
        AuthorizationConfig Rule Properties
        """
        broker_resources: pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgsDict']]]
        """
        Give access to Broker methods and topics.
        """
        principals: pulumi.Input['PrincipalDefinitionArgsDict']
        """
        Give access to clients based on the following properties.
        """
        state_store_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgsDict']]]]
        """
        Give access to state store resources.
        """
elif False:
    AuthorizationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationRuleArgs:
    def __init__(__self__, *,
                 broker_resources: pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgs']]],
                 principals: pulumi.Input['PrincipalDefinitionArgs'],
                 state_store_resources: Optional[pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgs']]]] = None):
        """
        AuthorizationConfig Rule Properties
        :param pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgs']]] broker_resources: Give access to Broker methods and topics.
        :param pulumi.Input['PrincipalDefinitionArgs'] principals: Give access to clients based on the following properties.
        :param pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgs']]] state_store_resources: Give access to state store resources.
        """
        pulumi.set(__self__, "broker_resources", broker_resources)
        pulumi.set(__self__, "principals", principals)
        if state_store_resources is not None:
            pulumi.set(__self__, "state_store_resources", state_store_resources)

    @_builtins.property
    @pulumi.getter(name="brokerResources")
    def broker_resources(self) -> pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgs']]]:
        """
        Give access to Broker methods and topics.
        """
        return pulumi.get(self, "broker_resources")

    @broker_resources.setter
    def broker_resources(self, value: pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgs']]]):
        pulumi.set(self, "broker_resources", value)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> pulumi.Input['PrincipalDefinitionArgs']:
        """
        Give access to clients based on the following properties.
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: pulumi.Input['PrincipalDefinitionArgs']):
        pulumi.set(self, "principals", value)

    @_builtins.property
    @pulumi.getter(name="stateStoreResources")
    def state_store_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgs']]]]:
        """
        Give access to state store resources.
        """
        return pulumi.get(self, "state_store_resources")

    @state_store_resources.setter
    def state_store_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgs']]]]):
        pulumi.set(self, "state_store_resources", value)


if not MYPY:
    class BackendChainArgsDict(TypedDict):
        """
        Desired properties of the backend instances of the broker
        """
        partitions: pulumi.Input[_builtins.int]
        """
        The desired number of physical backend partitions.
        """
        redundancy_factor: pulumi.Input[_builtins.int]
        """
        The desired numbers of backend replicas (pods) in a physical partition.
        """
        workers: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of logical backend workers per replica (pod).
        """
elif False:
    BackendChainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendChainArgs:
    def __init__(__self__, *,
                 partitions: pulumi.Input[_builtins.int],
                 redundancy_factor: pulumi.Input[_builtins.int],
                 workers: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Desired properties of the backend instances of the broker
        :param pulumi.Input[_builtins.int] partitions: The desired number of physical backend partitions.
        :param pulumi.Input[_builtins.int] redundancy_factor: The desired numbers of backend replicas (pods) in a physical partition.
        :param pulumi.Input[_builtins.int] workers: Number of logical backend workers per replica (pod).
        """
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "redundancy_factor", redundancy_factor)
        if workers is None:
            workers = 1
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> pulumi.Input[_builtins.int]:
        """
        The desired number of physical backend partitions.
        """
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "partitions", value)

    @_builtins.property
    @pulumi.getter(name="redundancyFactor")
    def redundancy_factor(self) -> pulumi.Input[_builtins.int]:
        """
        The desired numbers of backend replicas (pods) in a physical partition.
        """
        return pulumi.get(self, "redundancy_factor")

    @redundancy_factor.setter
    def redundancy_factor(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "redundancy_factor", value)

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of logical backend workers per replica (pod).
        """
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "workers", value)


if not MYPY:
    class BatchingConfigurationArgsDict(TypedDict):
        """
        Batching configuration
        """
        latency_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Batching latency in seconds.
        """
        max_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of messages in a batch.
        """
elif False:
    BatchingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchingConfigurationArgs:
    def __init__(__self__, *,
                 latency_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 max_messages: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Batching configuration
        :param pulumi.Input[_builtins.int] latency_seconds: Batching latency in seconds.
        :param pulumi.Input[_builtins.int] max_messages: Maximum number of messages in a batch.
        """
        if latency_seconds is None:
            latency_seconds = 60
        if latency_seconds is not None:
            pulumi.set(__self__, "latency_seconds", latency_seconds)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)

    @_builtins.property
    @pulumi.getter(name="latencySeconds")
    def latency_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Batching latency in seconds.
        """
        return pulumi.get(self, "latency_seconds")

    @latency_seconds.setter
    def latency_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "latency_seconds", value)

    @_builtins.property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of messages in a batch.
        """
        return pulumi.get(self, "max_messages")

    @max_messages.setter
    def max_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_messages", value)


if not MYPY:
    class BrokerAuthenticationPropertiesArgsDict(TypedDict):
        """
        BrokerAuthentication Resource properties
        """
        authentication_methods: pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgsDict']]]
        """
        Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        """
elif False:
    BrokerAuthenticationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticationPropertiesArgs:
    def __init__(__self__, *,
                 authentication_methods: pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgs']]]):
        """
        BrokerAuthentication Resource properties
        :param pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgs']]] authentication_methods: Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        """
        pulumi.set(__self__, "authentication_methods", authentication_methods)

    @_builtins.property
    @pulumi.getter(name="authenticationMethods")
    def authentication_methods(self) -> pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgs']]]:
        """
        Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        """
        return pulumi.get(self, "authentication_methods")

    @authentication_methods.setter
    def authentication_methods(self, value: pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgs']]]):
        pulumi.set(self, "authentication_methods", value)


if not MYPY:
    class BrokerAuthenticatorCustomAuthArgsDict(TypedDict):
        """
        Custom Authentication properties
        """
        x509: pulumi.Input['X509ManualCertificateArgsDict']
        """
        X509 Custom Auth type details.
        """
elif False:
    BrokerAuthenticatorCustomAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorCustomAuthArgs:
    def __init__(__self__, *,
                 x509: pulumi.Input['X509ManualCertificateArgs']):
        """
        Custom Authentication properties
        :param pulumi.Input['X509ManualCertificateArgs'] x509: X509 Custom Auth type details.
        """
        pulumi.set(__self__, "x509", x509)

    @_builtins.property
    @pulumi.getter
    def x509(self) -> pulumi.Input['X509ManualCertificateArgs']:
        """
        X509 Custom Auth type details.
        """
        return pulumi.get(self, "x509")

    @x509.setter
    def x509(self, value: pulumi.Input['X509ManualCertificateArgs']):
        pulumi.set(self, "x509", value)


if not MYPY:
    class BrokerAuthenticatorMethodCustomArgsDict(TypedDict):
        """
        Custom method for BrokerAuthentication
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        """
        auth: NotRequired[pulumi.Input['BrokerAuthenticatorCustomAuthArgsDict']]
        """
        Optional authentication needed for authenticating with the custom authentication server.
        """
        ca_cert_config_map: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional CA certificate for validating the custom authentication server's certificate.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional HTTP headers to pass to the custom authentication server.
        """
elif False:
    BrokerAuthenticatorMethodCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodCustomArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 auth: Optional[pulumi.Input['BrokerAuthenticatorCustomAuthArgs']] = None,
                 ca_cert_config_map: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        Custom method for BrokerAuthentication
        :param pulumi.Input[_builtins.str] endpoint: Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        :param pulumi.Input['BrokerAuthenticatorCustomAuthArgs'] auth: Optional authentication needed for authenticating with the custom authentication server.
        :param pulumi.Input[_builtins.str] ca_cert_config_map: Optional CA certificate for validating the custom authentication server's certificate.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: Additional HTTP headers to pass to the custom authentication server.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if ca_cert_config_map is not None:
            pulumi.set(__self__, "ca_cert_config_map", ca_cert_config_map)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['BrokerAuthenticatorCustomAuthArgs']]:
        """
        Optional authentication needed for authenticating with the custom authentication server.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['BrokerAuthenticatorCustomAuthArgs']]):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter(name="caCertConfigMap")
    def ca_cert_config_map(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional CA certificate for validating the custom authentication server's certificate.
        """
        return pulumi.get(self, "ca_cert_config_map")

    @ca_cert_config_map.setter
    def ca_cert_config_map(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_cert_config_map", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional HTTP headers to pass to the custom authentication server.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class BrokerAuthenticatorMethodSatArgsDict(TypedDict):
        """
        Service Account Token for BrokerAuthentication
        """
        audiences: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of allowed audience.
        """
elif False:
    BrokerAuthenticatorMethodSatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodSatArgs:
    def __init__(__self__, *,
                 audiences: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Service Account Token for BrokerAuthentication
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] audiences: List of allowed audience.
        """
        pulumi.set(__self__, "audiences", audiences)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of allowed audience.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "audiences", value)


if not MYPY:
    class BrokerAuthenticatorMethodX509AttributesArgsDict(TypedDict):
        """
        BrokerAuthenticatorMethodX509Attributes properties.
        """
        attributes: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Attributes object.
        """
        subject: pulumi.Input[_builtins.str]
        """
        Subject of the X509 attribute.
        """
elif False:
    BrokerAuthenticatorMethodX509AttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodX509AttributesArgs:
    def __init__(__self__, *,
                 attributes: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 subject: pulumi.Input[_builtins.str]):
        """
        BrokerAuthenticatorMethodX509Attributes properties.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] attributes: Attributes object.
        :param pulumi.Input[_builtins.str] subject: Subject of the X509 attribute.
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Attributes object.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        Subject of the X509 attribute.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class BrokerAuthenticatorMethodX509ArgsDict(TypedDict):
        """
        X509 for BrokerAuthentication.
        """
        authorization_attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgsDict']]]]
        """
        X509 authorization attributes properties.
        """
        trusted_client_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the trusted client ca cert resource.
        """
elif False:
    BrokerAuthenticatorMethodX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodX509Args:
    def __init__(__self__, *,
                 authorization_attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]]] = None,
                 trusted_client_ca_cert: Optional[pulumi.Input[_builtins.str]] = None):
        """
        X509 for BrokerAuthentication.
        :param pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]] authorization_attributes: X509 authorization attributes properties.
        :param pulumi.Input[_builtins.str] trusted_client_ca_cert: Name of the trusted client ca cert resource.
        """
        if authorization_attributes is not None:
            pulumi.set(__self__, "authorization_attributes", authorization_attributes)
        if trusted_client_ca_cert is None:
            trusted_client_ca_cert = 'client-ca'
        if trusted_client_ca_cert is not None:
            pulumi.set(__self__, "trusted_client_ca_cert", trusted_client_ca_cert)

    @_builtins.property
    @pulumi.getter(name="authorizationAttributes")
    def authorization_attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]]]:
        """
        X509 authorization attributes properties.
        """
        return pulumi.get(self, "authorization_attributes")

    @authorization_attributes.setter
    def authorization_attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]]]):
        pulumi.set(self, "authorization_attributes", value)

    @_builtins.property
    @pulumi.getter(name="trustedClientCaCert")
    def trusted_client_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the trusted client ca cert resource.
        """
        return pulumi.get(self, "trusted_client_ca_cert")

    @trusted_client_ca_cert.setter
    def trusted_client_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trusted_client_ca_cert", value)


if not MYPY:
    class BrokerAuthenticatorMethodsArgsDict(TypedDict):
        """
        Set of broker authentication policies. Only one method is supported for each entry.
        """
        method: pulumi.Input[Union[_builtins.str, 'BrokerAuthenticationMethod']]
        """
        Custom authentication configuration.
        """
        custom_settings: NotRequired[pulumi.Input['BrokerAuthenticatorMethodCustomArgsDict']]
        """
        Custom authentication configuration.
        """
        service_account_token_settings: NotRequired[pulumi.Input['BrokerAuthenticatorMethodSatArgsDict']]
        """
        ServiceAccountToken authentication configuration.
        """
        x509_settings: NotRequired[pulumi.Input['BrokerAuthenticatorMethodX509ArgsDict']]
        """
        X.509 authentication configuration.
        """
elif False:
    BrokerAuthenticatorMethodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodsArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[_builtins.str, 'BrokerAuthenticationMethod']],
                 custom_settings: Optional[pulumi.Input['BrokerAuthenticatorMethodCustomArgs']] = None,
                 service_account_token_settings: Optional[pulumi.Input['BrokerAuthenticatorMethodSatArgs']] = None,
                 x509_settings: Optional[pulumi.Input['BrokerAuthenticatorMethodX509Args']] = None):
        """
        Set of broker authentication policies. Only one method is supported for each entry.
        :param pulumi.Input[Union[_builtins.str, 'BrokerAuthenticationMethod']] method: Custom authentication configuration.
        :param pulumi.Input['BrokerAuthenticatorMethodCustomArgs'] custom_settings: Custom authentication configuration.
        :param pulumi.Input['BrokerAuthenticatorMethodSatArgs'] service_account_token_settings: ServiceAccountToken authentication configuration.
        :param pulumi.Input['BrokerAuthenticatorMethodX509Args'] x509_settings: X.509 authentication configuration.
        """
        pulumi.set(__self__, "method", method)
        if custom_settings is not None:
            pulumi.set(__self__, "custom_settings", custom_settings)
        if service_account_token_settings is not None:
            pulumi.set(__self__, "service_account_token_settings", service_account_token_settings)
        if x509_settings is not None:
            pulumi.set(__self__, "x509_settings", x509_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[_builtins.str, 'BrokerAuthenticationMethod']]:
        """
        Custom authentication configuration.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[_builtins.str, 'BrokerAuthenticationMethod']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="customSettings")
    def custom_settings(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodCustomArgs']]:
        """
        Custom authentication configuration.
        """
        return pulumi.get(self, "custom_settings")

    @custom_settings.setter
    def custom_settings(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodCustomArgs']]):
        pulumi.set(self, "custom_settings", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountTokenSettings")
    def service_account_token_settings(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodSatArgs']]:
        """
        ServiceAccountToken authentication configuration.
        """
        return pulumi.get(self, "service_account_token_settings")

    @service_account_token_settings.setter
    def service_account_token_settings(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodSatArgs']]):
        pulumi.set(self, "service_account_token_settings", value)

    @_builtins.property
    @pulumi.getter(name="x509Settings")
    def x509_settings(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodX509Args']]:
        """
        X.509 authentication configuration.
        """
        return pulumi.get(self, "x509_settings")

    @x509_settings.setter
    def x509_settings(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodX509Args']]):
        pulumi.set(self, "x509_settings", value)


if not MYPY:
    class BrokerAuthorizationPropertiesArgsDict(TypedDict):
        """
        BrokerAuthorization Resource properties
        """
        authorization_policies: pulumi.Input['AuthorizationConfigArgsDict']
        """
        The list of authorization policies supported by the Authorization Resource.
        """
elif False:
    BrokerAuthorizationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthorizationPropertiesArgs:
    def __init__(__self__, *,
                 authorization_policies: pulumi.Input['AuthorizationConfigArgs']):
        """
        BrokerAuthorization Resource properties
        :param pulumi.Input['AuthorizationConfigArgs'] authorization_policies: The list of authorization policies supported by the Authorization Resource.
        """
        pulumi.set(__self__, "authorization_policies", authorization_policies)

    @_builtins.property
    @pulumi.getter(name="authorizationPolicies")
    def authorization_policies(self) -> pulumi.Input['AuthorizationConfigArgs']:
        """
        The list of authorization policies supported by the Authorization Resource.
        """
        return pulumi.get(self, "authorization_policies")

    @authorization_policies.setter
    def authorization_policies(self, value: pulumi.Input['AuthorizationConfigArgs']):
        pulumi.set(self, "authorization_policies", value)


if not MYPY:
    class BrokerDiagnosticsArgsDict(TypedDict):
        """
        Broker Diagnostic Setting properties
        """
        logs: NotRequired[pulumi.Input['DiagnosticsLogsArgsDict']]
        """
        Diagnostic log settings for the resource.
        """
        metrics: NotRequired[pulumi.Input['MetricsArgsDict']]
        """
        The metrics settings for the resource.
        """
        self_check: NotRequired[pulumi.Input['SelfCheckArgsDict']]
        """
        The self check properties.
        """
        traces: NotRequired[pulumi.Input['TracesArgsDict']]
        """
        The trace properties.
        """
elif False:
    BrokerDiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerDiagnosticsArgs:
    def __init__(__self__, *,
                 logs: Optional[pulumi.Input['DiagnosticsLogsArgs']] = None,
                 metrics: Optional[pulumi.Input['MetricsArgs']] = None,
                 self_check: Optional[pulumi.Input['SelfCheckArgs']] = None,
                 traces: Optional[pulumi.Input['TracesArgs']] = None):
        """
        Broker Diagnostic Setting properties
        :param pulumi.Input['DiagnosticsLogsArgs'] logs: Diagnostic log settings for the resource.
        :param pulumi.Input['MetricsArgs'] metrics: The metrics settings for the resource.
        :param pulumi.Input['SelfCheckArgs'] self_check: The self check properties.
        :param pulumi.Input['TracesArgs'] traces: The trace properties.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if self_check is not None:
            pulumi.set(__self__, "self_check", self_check)
        if traces is not None:
            pulumi.set(__self__, "traces", traces)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input['DiagnosticsLogsArgs']]:
        """
        Diagnostic log settings for the resource.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input['DiagnosticsLogsArgs']]):
        pulumi.set(self, "logs", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['MetricsArgs']]:
        """
        The metrics settings for the resource.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['MetricsArgs']]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter(name="selfCheck")
    def self_check(self) -> Optional[pulumi.Input['SelfCheckArgs']]:
        """
        The self check properties.
        """
        return pulumi.get(self, "self_check")

    @self_check.setter
    def self_check(self, value: Optional[pulumi.Input['SelfCheckArgs']]):
        pulumi.set(self, "self_check", value)

    @_builtins.property
    @pulumi.getter
    def traces(self) -> Optional[pulumi.Input['TracesArgs']]:
        """
        The trace properties.
        """
        return pulumi.get(self, "traces")

    @traces.setter
    def traces(self, value: Optional[pulumi.Input['TracesArgs']]):
        pulumi.set(self, "traces", value)


if not MYPY:
    class BrokerListenerPropertiesArgsDict(TypedDict):
        """
        Defines a Broker listener. A listener is a collection of ports on which the broker accepts connections from clients.
        """
        ports: pulumi.Input[Sequence[pulumi.Input['ListenerPortArgsDict']]]
        """
        Ports on which this listener accepts client connections.
        """
        service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kubernetes Service name of this listener.
        """
        service_type: NotRequired[pulumi.Input[Union[_builtins.str, 'ServiceType']]]
        """
        Kubernetes Service type of this listener.
        """
elif False:
    BrokerListenerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerListenerPropertiesArgs:
    def __init__(__self__, *,
                 ports: pulumi.Input[Sequence[pulumi.Input['ListenerPortArgs']]],
                 service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 service_type: Optional[pulumi.Input[Union[_builtins.str, 'ServiceType']]] = None):
        """
        Defines a Broker listener. A listener is a collection of ports on which the broker accepts connections from clients.
        :param pulumi.Input[Sequence[pulumi.Input['ListenerPortArgs']]] ports: Ports on which this listener accepts client connections.
        :param pulumi.Input[_builtins.str] service_name: Kubernetes Service name of this listener.
        :param pulumi.Input[Union[_builtins.str, 'ServiceType']] service_type: Kubernetes Service type of this listener.
        """
        pulumi.set(__self__, "ports", ports)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_type is None:
            service_type = 'ClusterIp'
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input['ListenerPortArgs']]]:
        """
        Ports on which this listener accepts client connections.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input['ListenerPortArgs']]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kubernetes Service name of this listener.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_name", value)

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'ServiceType']]]:
        """
        Kubernetes Service type of this listener.
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'ServiceType']]]):
        pulumi.set(self, "service_type", value)


if not MYPY:
    class BrokerPropertiesArgsDict(TypedDict):
        """
        Broker Resource properties
        """
        advanced: NotRequired[pulumi.Input['AdvancedSettingsArgsDict']]
        """
        Advanced settings of Broker.
        """
        cardinality: NotRequired[pulumi.Input['CardinalityArgsDict']]
        """
        The cardinality details of the broker.
        """
        diagnostics: NotRequired[pulumi.Input['BrokerDiagnosticsArgsDict']]
        """
        Spec defines the desired identities of Broker diagnostics settings.
        """
        disk_backed_message_buffer: NotRequired[pulumi.Input['DiskBackedMessageBufferArgsDict']]
        """
        Settings of Disk Backed Message Buffer.
        """
        generate_resource_limits: NotRequired[pulumi.Input['GenerateResourceLimitsArgsDict']]
        """
        This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        """
        memory_profile: NotRequired[pulumi.Input[Union[_builtins.str, 'BrokerMemoryProfile']]]
        """
        Memory profile of Broker.
        """
elif False:
    BrokerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerPropertiesArgs:
    def __init__(__self__, *,
                 advanced: Optional[pulumi.Input['AdvancedSettingsArgs']] = None,
                 cardinality: Optional[pulumi.Input['CardinalityArgs']] = None,
                 diagnostics: Optional[pulumi.Input['BrokerDiagnosticsArgs']] = None,
                 disk_backed_message_buffer: Optional[pulumi.Input['DiskBackedMessageBufferArgs']] = None,
                 generate_resource_limits: Optional[pulumi.Input['GenerateResourceLimitsArgs']] = None,
                 memory_profile: Optional[pulumi.Input[Union[_builtins.str, 'BrokerMemoryProfile']]] = None):
        """
        Broker Resource properties
        :param pulumi.Input['AdvancedSettingsArgs'] advanced: Advanced settings of Broker.
        :param pulumi.Input['CardinalityArgs'] cardinality: The cardinality details of the broker.
        :param pulumi.Input['BrokerDiagnosticsArgs'] diagnostics: Spec defines the desired identities of Broker diagnostics settings.
        :param pulumi.Input['DiskBackedMessageBufferArgs'] disk_backed_message_buffer: Settings of Disk Backed Message Buffer.
        :param pulumi.Input['GenerateResourceLimitsArgs'] generate_resource_limits: This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        :param pulumi.Input[Union[_builtins.str, 'BrokerMemoryProfile']] memory_profile: Memory profile of Broker.
        """
        if advanced is not None:
            pulumi.set(__self__, "advanced", advanced)
        if cardinality is not None:
            pulumi.set(__self__, "cardinality", cardinality)
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if disk_backed_message_buffer is not None:
            pulumi.set(__self__, "disk_backed_message_buffer", disk_backed_message_buffer)
        if generate_resource_limits is not None:
            pulumi.set(__self__, "generate_resource_limits", generate_resource_limits)
        if memory_profile is None:
            memory_profile = 'Medium'
        if memory_profile is not None:
            pulumi.set(__self__, "memory_profile", memory_profile)

    @_builtins.property
    @pulumi.getter
    def advanced(self) -> Optional[pulumi.Input['AdvancedSettingsArgs']]:
        """
        Advanced settings of Broker.
        """
        return pulumi.get(self, "advanced")

    @advanced.setter
    def advanced(self, value: Optional[pulumi.Input['AdvancedSettingsArgs']]):
        pulumi.set(self, "advanced", value)

    @_builtins.property
    @pulumi.getter
    def cardinality(self) -> Optional[pulumi.Input['CardinalityArgs']]:
        """
        The cardinality details of the broker.
        """
        return pulumi.get(self, "cardinality")

    @cardinality.setter
    def cardinality(self, value: Optional[pulumi.Input['CardinalityArgs']]):
        pulumi.set(self, "cardinality", value)

    @_builtins.property
    @pulumi.getter
    def diagnostics(self) -> Optional[pulumi.Input['BrokerDiagnosticsArgs']]:
        """
        Spec defines the desired identities of Broker diagnostics settings.
        """
        return pulumi.get(self, "diagnostics")

    @diagnostics.setter
    def diagnostics(self, value: Optional[pulumi.Input['BrokerDiagnosticsArgs']]):
        pulumi.set(self, "diagnostics", value)

    @_builtins.property
    @pulumi.getter(name="diskBackedMessageBuffer")
    def disk_backed_message_buffer(self) -> Optional[pulumi.Input['DiskBackedMessageBufferArgs']]:
        """
        Settings of Disk Backed Message Buffer.
        """
        return pulumi.get(self, "disk_backed_message_buffer")

    @disk_backed_message_buffer.setter
    def disk_backed_message_buffer(self, value: Optional[pulumi.Input['DiskBackedMessageBufferArgs']]):
        pulumi.set(self, "disk_backed_message_buffer", value)

    @_builtins.property
    @pulumi.getter(name="generateResourceLimits")
    def generate_resource_limits(self) -> Optional[pulumi.Input['GenerateResourceLimitsArgs']]:
        """
        This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        """
        return pulumi.get(self, "generate_resource_limits")

    @generate_resource_limits.setter
    def generate_resource_limits(self, value: Optional[pulumi.Input['GenerateResourceLimitsArgs']]):
        pulumi.set(self, "generate_resource_limits", value)

    @_builtins.property
    @pulumi.getter(name="memoryProfile")
    def memory_profile(self) -> Optional[pulumi.Input[Union[_builtins.str, 'BrokerMemoryProfile']]]:
        """
        Memory profile of Broker.
        """
        return pulumi.get(self, "memory_profile")

    @memory_profile.setter
    def memory_profile(self, value: Optional[pulumi.Input[Union[_builtins.str, 'BrokerMemoryProfile']]]):
        pulumi.set(self, "memory_profile", value)


if not MYPY:
    class BrokerResourceRuleArgsDict(TypedDict):
        """
        Broker Resource Rule properties. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
        """
        method: pulumi.Input[Union[_builtins.str, 'BrokerResourceDefinitionMethods']]
        """
        Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        """
        client_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection. This subfield may be set if the method is Connect.
        """
        topics: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
elif False:
    BrokerResourceRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerResourceRuleArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[_builtins.str, 'BrokerResourceDefinitionMethods']],
                 client_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 topics: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Broker Resource Rule properties. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
        :param pulumi.Input[Union[_builtins.str, 'BrokerResourceDefinitionMethods']] method: Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] client_ids: A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection. This subfield may be set if the method is Connect.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] topics: A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        pulumi.set(__self__, "method", method)
        if client_ids is not None:
            pulumi.set(__self__, "client_ids", client_ids)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[_builtins.str, 'BrokerResourceDefinitionMethods']]:
        """
        Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[_builtins.str, 'BrokerResourceDefinitionMethods']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection. This subfield may be set if the method is Connect.
        """
        return pulumi.get(self, "client_ids")

    @client_ids.setter
    def client_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "client_ids", value)

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "topics", value)


if not MYPY:
    class CardinalityArgsDict(TypedDict):
        """
        Cardinality properties
        """
        backend_chain: pulumi.Input['BackendChainArgsDict']
        """
        The backend broker desired properties
        """
        frontend: pulumi.Input['FrontendArgsDict']
        """
        The frontend desired properties
        """
elif False:
    CardinalityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CardinalityArgs:
    def __init__(__self__, *,
                 backend_chain: pulumi.Input['BackendChainArgs'],
                 frontend: pulumi.Input['FrontendArgs']):
        """
        Cardinality properties
        :param pulumi.Input['BackendChainArgs'] backend_chain: The backend broker desired properties
        :param pulumi.Input['FrontendArgs'] frontend: The frontend desired properties
        """
        pulumi.set(__self__, "backend_chain", backend_chain)
        pulumi.set(__self__, "frontend", frontend)

    @_builtins.property
    @pulumi.getter(name="backendChain")
    def backend_chain(self) -> pulumi.Input['BackendChainArgs']:
        """
        The backend broker desired properties
        """
        return pulumi.get(self, "backend_chain")

    @backend_chain.setter
    def backend_chain(self, value: pulumi.Input['BackendChainArgs']):
        pulumi.set(self, "backend_chain", value)

    @_builtins.property
    @pulumi.getter
    def frontend(self) -> pulumi.Input['FrontendArgs']:
        """
        The frontend desired properties
        """
        return pulumi.get(self, "frontend")

    @frontend.setter
    def frontend(self, value: pulumi.Input['FrontendArgs']):
        pulumi.set(self, "frontend", value)


if not MYPY:
    class CertManagerCertOptionsArgsDict(TypedDict):
        """
        Cert Manager Cert properties
        """
        duration: pulumi.Input[_builtins.str]
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        private_key: pulumi.Input['CertManagerPrivateKeyArgsDict']
        """
        Configuration of certificate private key.
        """
        renew_before: pulumi.Input[_builtins.str]
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
elif False:
    CertManagerCertOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertManagerCertOptionsArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input['CertManagerPrivateKeyArgs'],
                 renew_before: pulumi.Input[_builtins.str]):
        """
        Cert Manager Cert properties
        :param pulumi.Input[_builtins.str] duration: Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param pulumi.Input['CertManagerPrivateKeyArgs'] private_key: Configuration of certificate private key.
        :param pulumi.Input[_builtins.str] renew_before: When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "renew_before", renew_before)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> pulumi.Input[_builtins.str]:
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input['CertManagerPrivateKeyArgs']:
        """
        Configuration of certificate private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input['CertManagerPrivateKeyArgs']):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> pulumi.Input[_builtins.str]:
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "renew_before")

    @renew_before.setter
    def renew_before(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "renew_before", value)


if not MYPY:
    class CertManagerCertificateSpecArgsDict(TypedDict):
        """
        Automatic TLS server certificate management with cert-manager
        """
        issuer_ref: pulumi.Input['CertManagerIssuerRefArgsDict']
        """
        cert-manager issuerRef.
        """
        duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        private_key: NotRequired[pulumi.Input['CertManagerPrivateKeyArgsDict']]
        """
        Type of certificate private key.
        """
        renew_before: NotRequired[pulumi.Input[_builtins.str]]
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        san: NotRequired[pulumi.Input['SanForCertArgsDict']]
        """
        Additional Subject Alternative Names (SANs) to include in the certificate.
        """
        secret_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
elif False:
    CertManagerCertificateSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertManagerCertificateSpecArgs:
    def __init__(__self__, *,
                 issuer_ref: pulumi.Input['CertManagerIssuerRefArgs'],
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key: Optional[pulumi.Input['CertManagerPrivateKeyArgs']] = None,
                 renew_before: Optional[pulumi.Input[_builtins.str]] = None,
                 san: Optional[pulumi.Input['SanForCertArgs']] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Automatic TLS server certificate management with cert-manager
        :param pulumi.Input['CertManagerIssuerRefArgs'] issuer_ref: cert-manager issuerRef.
        :param pulumi.Input[_builtins.str] duration: Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param pulumi.Input['CertManagerPrivateKeyArgs'] private_key: Type of certificate private key.
        :param pulumi.Input[_builtins.str] renew_before: When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param pulumi.Input['SanForCertArgs'] san: Additional Subject Alternative Names (SANs) to include in the certificate.
        :param pulumi.Input[_builtins.str] secret_name: Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
        pulumi.set(__self__, "issuer_ref", issuer_ref)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if renew_before is not None:
            pulumi.set(__self__, "renew_before", renew_before)
        if san is not None:
            pulumi.set(__self__, "san", san)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> pulumi.Input['CertManagerIssuerRefArgs']:
        """
        cert-manager issuerRef.
        """
        return pulumi.get(self, "issuer_ref")

    @issuer_ref.setter
    def issuer_ref(self, value: pulumi.Input['CertManagerIssuerRefArgs']):
        pulumi.set(self, "issuer_ref", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input['CertManagerPrivateKeyArgs']]:
        """
        Type of certificate private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input['CertManagerPrivateKeyArgs']]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "renew_before")

    @renew_before.setter
    def renew_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "renew_before", value)

    @_builtins.property
    @pulumi.getter
    def san(self) -> Optional[pulumi.Input['SanForCertArgs']]:
        """
        Additional Subject Alternative Names (SANs) to include in the certificate.
        """
        return pulumi.get(self, "san")

    @san.setter
    def san(self, value: Optional[pulumi.Input['SanForCertArgs']]):
        pulumi.set(self, "san", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class CertManagerIssuerRefArgsDict(TypedDict):
        """
        Cert-Manager issuerRef properties
        """
        group: pulumi.Input[_builtins.str]
        """
        group of issuer.
        """
        kind: pulumi.Input[Union[_builtins.str, 'CertManagerIssuerKind']]
        """
        kind of issuer (Issuer or ClusterIssuer).
        """
        name: pulumi.Input[_builtins.str]
        """
        name of issuer.
        """
elif False:
    CertManagerIssuerRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertManagerIssuerRefArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: pulumi.Input[Union[_builtins.str, 'CertManagerIssuerKind']],
                 name: pulumi.Input[_builtins.str]):
        """
        Cert-Manager issuerRef properties
        :param pulumi.Input[_builtins.str] group: group of issuer.
        :param pulumi.Input[Union[_builtins.str, 'CertManagerIssuerKind']] kind: kind of issuer (Issuer or ClusterIssuer).
        :param pulumi.Input[_builtins.str] name: name of issuer.
        """
        if group is None:
            group = 'cert-manager.io'
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def group(self) -> pulumi.Input[_builtins.str]:
        """
        group of issuer.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[Union[_builtins.str, 'CertManagerIssuerKind']]:
        """
        kind of issuer (Issuer or ClusterIssuer).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[Union[_builtins.str, 'CertManagerIssuerKind']]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        name of issuer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CertManagerPrivateKeyArgsDict(TypedDict):
        """
        Cert Manager private key properties
        """
        algorithm: pulumi.Input[Union[_builtins.str, 'PrivateKeyAlgorithm']]
        """
        algorithm for private key.
        """
        rotation_policy: pulumi.Input[Union[_builtins.str, 'PrivateKeyRotationPolicy']]
        """
        cert-manager private key rotationPolicy.
        """
elif False:
    CertManagerPrivateKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertManagerPrivateKeyArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[Union[_builtins.str, 'PrivateKeyAlgorithm']],
                 rotation_policy: pulumi.Input[Union[_builtins.str, 'PrivateKeyRotationPolicy']]):
        """
        Cert Manager private key properties
        :param pulumi.Input[Union[_builtins.str, 'PrivateKeyAlgorithm']] algorithm: algorithm for private key.
        :param pulumi.Input[Union[_builtins.str, 'PrivateKeyRotationPolicy']] rotation_policy: cert-manager private key rotationPolicy.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "rotation_policy", rotation_policy)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[Union[_builtins.str, 'PrivateKeyAlgorithm']]:
        """
        algorithm for private key.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[Union[_builtins.str, 'PrivateKeyAlgorithm']]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="rotationPolicy")
    def rotation_policy(self) -> pulumi.Input[Union[_builtins.str, 'PrivateKeyRotationPolicy']]:
        """
        cert-manager private key rotationPolicy.
        """
        return pulumi.get(self, "rotation_policy")

    @rotation_policy.setter
    def rotation_policy(self, value: pulumi.Input[Union[_builtins.str, 'PrivateKeyRotationPolicy']]):
        pulumi.set(self, "rotation_policy", value)


if not MYPY:
    class ClientConfigArgsDict(TypedDict):
        """
        The settings of Client Config.
        """
        max_keep_alive_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Upper bound of a client's Keep Alive, in seconds.
        """
        max_message_expiry_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Upper bound of Message Expiry Interval, in seconds.
        """
        max_packet_size_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max message size for a packet in Bytes.
        """
        max_receive_maximum: NotRequired[pulumi.Input[_builtins.int]]
        """
        Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        """
        max_session_expiry_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Upper bound of Session Expiry Interval, in seconds.
        """
        subscriber_queue_limit: NotRequired[pulumi.Input['SubscriberQueueLimitArgsDict']]
        """
        The limit on the number of queued messages for a subscriber.
        """
elif False:
    ClientConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientConfigArgs:
    def __init__(__self__, *,
                 max_keep_alive_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 max_message_expiry_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 max_packet_size_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 max_receive_maximum: Optional[pulumi.Input[_builtins.int]] = None,
                 max_session_expiry_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 subscriber_queue_limit: Optional[pulumi.Input['SubscriberQueueLimitArgs']] = None):
        """
        The settings of Client Config.
        :param pulumi.Input[_builtins.int] max_keep_alive_seconds: Upper bound of a client's Keep Alive, in seconds.
        :param pulumi.Input[_builtins.int] max_message_expiry_seconds: Upper bound of Message Expiry Interval, in seconds.
        :param pulumi.Input[_builtins.int] max_packet_size_bytes: Max message size for a packet in Bytes.
        :param pulumi.Input[_builtins.int] max_receive_maximum: Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        :param pulumi.Input[_builtins.int] max_session_expiry_seconds: Upper bound of Session Expiry Interval, in seconds.
        :param pulumi.Input['SubscriberQueueLimitArgs'] subscriber_queue_limit: The limit on the number of queued messages for a subscriber.
        """
        if max_keep_alive_seconds is not None:
            pulumi.set(__self__, "max_keep_alive_seconds", max_keep_alive_seconds)
        if max_message_expiry_seconds is not None:
            pulumi.set(__self__, "max_message_expiry_seconds", max_message_expiry_seconds)
        if max_packet_size_bytes is not None:
            pulumi.set(__self__, "max_packet_size_bytes", max_packet_size_bytes)
        if max_receive_maximum is not None:
            pulumi.set(__self__, "max_receive_maximum", max_receive_maximum)
        if max_session_expiry_seconds is not None:
            pulumi.set(__self__, "max_session_expiry_seconds", max_session_expiry_seconds)
        if subscriber_queue_limit is not None:
            pulumi.set(__self__, "subscriber_queue_limit", subscriber_queue_limit)

    @_builtins.property
    @pulumi.getter(name="maxKeepAliveSeconds")
    def max_keep_alive_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Upper bound of a client's Keep Alive, in seconds.
        """
        return pulumi.get(self, "max_keep_alive_seconds")

    @max_keep_alive_seconds.setter
    def max_keep_alive_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_keep_alive_seconds", value)

    @_builtins.property
    @pulumi.getter(name="maxMessageExpirySeconds")
    def max_message_expiry_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Upper bound of Message Expiry Interval, in seconds.
        """
        return pulumi.get(self, "max_message_expiry_seconds")

    @max_message_expiry_seconds.setter
    def max_message_expiry_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_message_expiry_seconds", value)

    @_builtins.property
    @pulumi.getter(name="maxPacketSizeBytes")
    def max_packet_size_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max message size for a packet in Bytes.
        """
        return pulumi.get(self, "max_packet_size_bytes")

    @max_packet_size_bytes.setter
    def max_packet_size_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_packet_size_bytes", value)

    @_builtins.property
    @pulumi.getter(name="maxReceiveMaximum")
    def max_receive_maximum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        """
        return pulumi.get(self, "max_receive_maximum")

    @max_receive_maximum.setter
    def max_receive_maximum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_receive_maximum", value)

    @_builtins.property
    @pulumi.getter(name="maxSessionExpirySeconds")
    def max_session_expiry_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Upper bound of Session Expiry Interval, in seconds.
        """
        return pulumi.get(self, "max_session_expiry_seconds")

    @max_session_expiry_seconds.setter
    def max_session_expiry_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_session_expiry_seconds", value)

    @_builtins.property
    @pulumi.getter(name="subscriberQueueLimit")
    def subscriber_queue_limit(self) -> Optional[pulumi.Input['SubscriberQueueLimitArgs']]:
        """
        The limit on the number of queued messages for a subscriber.
        """
        return pulumi.get(self, "subscriber_queue_limit")

    @subscriber_queue_limit.setter
    def subscriber_queue_limit(self, value: Optional[pulumi.Input['SubscriberQueueLimitArgs']]):
        pulumi.set(self, "subscriber_queue_limit", value)


if not MYPY:
    class DataflowBuiltInTransformationDatasetArgsDict(TypedDict):
        """
        Dataflow BuiltIn Transformation dataset properties
        """
        inputs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of fields for enriching from the Broker State Store.
        """
        key: pulumi.Input[_builtins.str]
        """
        The key of the dataset.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user provided optional description of the dataset.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
elif False:
    DataflowBuiltInTransformationDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowBuiltInTransformationDatasetArgs:
    def __init__(__self__, *,
                 inputs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 key: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Dataflow BuiltIn Transformation dataset properties
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inputs: List of fields for enriching from the Broker State Store.
        :param pulumi.Input[_builtins.str] key: The key of the dataset.
        :param pulumi.Input[_builtins.str] description: A user provided optional description of the dataset.
        :param pulumi.Input[_builtins.str] expression: Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        :param pulumi.Input[_builtins.str] schema_ref: The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "key", key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of fields for enriching from the Broker State Store.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "inputs", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the dataset.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user provided optional description of the dataset.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
        return pulumi.get(self, "schema_ref")

    @schema_ref.setter
    def schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_ref", value)


if not MYPY:
    class DataflowBuiltInTransformationFilterArgsDict(TypedDict):
        """
        Dataflow BuiltIn Transformation filter properties
        """
        expression: pulumi.Input[_builtins.str]
        """
        Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        inputs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of fields for filtering in JSON path expression.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user provided optional description of the filter.
        """
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'FilterType']]]
        """
        The type of dataflow operation.
        """
elif False:
    DataflowBuiltInTransformationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowBuiltInTransformationFilterArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 inputs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'FilterType']]] = None):
        """
        Dataflow BuiltIn Transformation filter properties
        :param pulumi.Input[_builtins.str] expression: Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inputs: List of fields for filtering in JSON path expression.
        :param pulumi.Input[_builtins.str] description: A user provided optional description of the filter.
        :param pulumi.Input[Union[_builtins.str, 'FilterType']] type: The type of dataflow operation.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "inputs", inputs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is None:
            type = 'Filter'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of fields for filtering in JSON path expression.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "inputs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user provided optional description of the filter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'FilterType']]]:
        """
        The type of dataflow operation.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'FilterType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataflowBuiltInTransformationMapArgsDict(TypedDict):
        """
        Dataflow BuiltIn Transformation map properties
        """
        inputs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of fields for mapping in JSON path expression.
        """
        output: pulumi.Input[_builtins.str]
        """
        Where and how the input fields to be organized in the output record.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A user provided optional description of the mapping function.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        """
        type: NotRequired[pulumi.Input[Union[_builtins.str, 'DataflowMappingType']]]
        """
        Type of transformation.
        """
elif False:
    DataflowBuiltInTransformationMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowBuiltInTransformationMapArgs:
    def __init__(__self__, *,
                 inputs: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 output: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[_builtins.str, 'DataflowMappingType']]] = None):
        """
        Dataflow BuiltIn Transformation map properties
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inputs: List of fields for mapping in JSON path expression.
        :param pulumi.Input[_builtins.str] output: Where and how the input fields to be organized in the output record.
        :param pulumi.Input[_builtins.str] description: A user provided optional description of the mapping function.
        :param pulumi.Input[_builtins.str] expression: Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        :param pulumi.Input[Union[_builtins.str, 'DataflowMappingType']] type: Type of transformation.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "output", output)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of fields for mapping in JSON path expression.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "inputs", value)

    @_builtins.property
    @pulumi.getter
    def output(self) -> pulumi.Input[_builtins.str]:
        """
        Where and how the input fields to be organized in the output record.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A user provided optional description of the mapping function.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[_builtins.str, 'DataflowMappingType']]]:
        """
        Type of transformation.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[_builtins.str, 'DataflowMappingType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataflowBuiltInTransformationSettingsArgsDict(TypedDict):
        """
        Dataflow BuiltIn Transformation properties
        """
        datasets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationDatasetArgsDict']]]]
        """
        Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        """
        filter: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationFilterArgsDict']]]]
        """
        Filters input record or datapoints based on condition.
        """
        map: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationMapArgsDict']]]]
        """
        Maps input to output message.
        """
        schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference to the schema that describes the output of the transformation.
        """
        serialization_format: NotRequired[pulumi.Input[Union[_builtins.str, 'TransformationSerializationFormat']]]
        """
        Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
elif False:
    DataflowBuiltInTransformationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowBuiltInTransformationSettingsArgs:
    def __init__(__self__, *,
                 datasets: Optional[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationDatasetArgs']]]] = None,
                 filter: Optional[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationFilterArgs']]]] = None,
                 map: Optional[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationMapArgs']]]] = None,
                 schema_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 serialization_format: Optional[pulumi.Input[Union[_builtins.str, 'TransformationSerializationFormat']]] = None):
        """
        Dataflow BuiltIn Transformation properties
        :param pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationDatasetArgs']]] datasets: Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        :param pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationFilterArgs']]] filter: Filters input record or datapoints based on condition.
        :param pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationMapArgs']]] map: Maps input to output message.
        :param pulumi.Input[_builtins.str] schema_ref: Reference to the schema that describes the output of the transformation.
        :param pulumi.Input[Union[_builtins.str, 'TransformationSerializationFormat']] serialization_format: Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
        if datasets is not None:
            pulumi.set(__self__, "datasets", datasets)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if map is not None:
            pulumi.set(__self__, "map", map)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is None:
            serialization_format = 'Json'
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @_builtins.property
    @pulumi.getter
    def datasets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationDatasetArgs']]]]:
        """
        Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        """
        return pulumi.get(self, "datasets")

    @datasets.setter
    def datasets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationDatasetArgs']]]]):
        pulumi.set(self, "datasets", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationFilterArgs']]]]:
        """
        Filters input record or datapoints based on condition.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationFilterArgs']]]]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationMapArgs']]]]:
        """
        Maps input to output message.
        """
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataflowBuiltInTransformationMapArgs']]]]):
        pulumi.set(self, "map", value)

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to the schema that describes the output of the transformation.
        """
        return pulumi.get(self, "schema_ref")

    @schema_ref.setter
    def schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_ref", value)

    @_builtins.property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[pulumi.Input[Union[_builtins.str, 'TransformationSerializationFormat']]]:
        """
        Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
        return pulumi.get(self, "serialization_format")

    @serialization_format.setter
    def serialization_format(self, value: Optional[pulumi.Input[Union[_builtins.str, 'TransformationSerializationFormat']]]):
        pulumi.set(self, "serialization_format", value)


if not MYPY:
    class DataflowDestinationOperationSettingsArgsDict(TypedDict):
        """
        Dataflow Destination Operation properties
        """
        data_destination: pulumi.Input[_builtins.str]
        """
        Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        """
        endpoint_ref: pulumi.Input[_builtins.str]
        """
        Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
elif False:
    DataflowDestinationOperationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowDestinationOperationSettingsArgs:
    def __init__(__self__, *,
                 data_destination: pulumi.Input[_builtins.str],
                 endpoint_ref: pulumi.Input[_builtins.str]):
        """
        Dataflow Destination Operation properties
        :param pulumi.Input[_builtins.str] data_destination: Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        :param pulumi.Input[_builtins.str] endpoint_ref: Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
        pulumi.set(__self__, "data_destination", data_destination)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)

    @_builtins.property
    @pulumi.getter(name="dataDestination")
    def data_destination(self) -> pulumi.Input[_builtins.str]:
        """
        Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        """
        return pulumi.get(self, "data_destination")

    @data_destination.setter
    def data_destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_destination", value)

    @_builtins.property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> pulumi.Input[_builtins.str]:
        """
        Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
        return pulumi.get(self, "endpoint_ref")

    @endpoint_ref.setter
    def endpoint_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint_ref", value)


if not MYPY:
    class DataflowEndpointAuthenticationAccessTokenArgsDict(TypedDict):
        """
        DataflowEndpoint Authentication Access Token properties
        """
        secret_ref: pulumi.Input[_builtins.str]
        """
        Token secret name.
        """
elif False:
    DataflowEndpointAuthenticationAccessTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointAuthenticationAccessTokenArgs:
    def __init__(__self__, *,
                 secret_ref: pulumi.Input[_builtins.str]):
        """
        DataflowEndpoint Authentication Access Token properties
        :param pulumi.Input[_builtins.str] secret_ref: Token secret name.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        Token secret name.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class DataflowEndpointAuthenticationSaslArgsDict(TypedDict):
        """
        DataflowEndpoint Authentication Sasl properties
        """
        sasl_type: pulumi.Input[Union[_builtins.str, 'DataflowEndpointAuthenticationSaslType']]
        """
        Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        """
        secret_ref: pulumi.Input[_builtins.str]
        """
        Token secret name.
        """
elif False:
    DataflowEndpointAuthenticationSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointAuthenticationSaslArgs:
    def __init__(__self__, *,
                 sasl_type: pulumi.Input[Union[_builtins.str, 'DataflowEndpointAuthenticationSaslType']],
                 secret_ref: pulumi.Input[_builtins.str]):
        """
        DataflowEndpoint Authentication Sasl properties
        :param pulumi.Input[Union[_builtins.str, 'DataflowEndpointAuthenticationSaslType']] sasl_type: Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        :param pulumi.Input[_builtins.str] secret_ref: Token secret name.
        """
        pulumi.set(__self__, "sasl_type", sasl_type)
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="saslType")
    def sasl_type(self) -> pulumi.Input[Union[_builtins.str, 'DataflowEndpointAuthenticationSaslType']]:
        """
        Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        """
        return pulumi.get(self, "sasl_type")

    @sasl_type.setter
    def sasl_type(self, value: pulumi.Input[Union[_builtins.str, 'DataflowEndpointAuthenticationSaslType']]):
        pulumi.set(self, "sasl_type", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        Token secret name.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class DataflowEndpointAuthenticationServiceAccountTokenArgsDict(TypedDict):
        """
        Service Account Token for BrokerAuthentication
        """
        audience: pulumi.Input[_builtins.str]
        """
        Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
elif False:
    DataflowEndpointAuthenticationServiceAccountTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointAuthenticationServiceAccountTokenArgs:
    def __init__(__self__, *,
                 audience: pulumi.Input[_builtins.str]):
        """
        Service Account Token for BrokerAuthentication
        :param pulumi.Input[_builtins.str] audience: Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
        pulumi.set(__self__, "audience", audience)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> pulumi.Input[_builtins.str]:
        """
        Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audience", value)


if not MYPY:
    class DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict(TypedDict):
        """
        DataflowEndpoint Authentication SystemAssignedManagedIdentity properties
        """
        audience: NotRequired[pulumi.Input[_builtins.str]]
        """
        Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
elif False:
    DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs:
    def __init__(__self__, *,
                 audience: Optional[pulumi.Input[_builtins.str]] = None):
        """
        DataflowEndpoint Authentication SystemAssignedManagedIdentity properties
        :param pulumi.Input[_builtins.str] audience: Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audience", value)


if not MYPY:
    class DataflowEndpointAuthenticationUserAssignedManagedIdentityArgsDict(TypedDict):
        """
        DataflowEndpoint Authentication UserAssignedManagedIdentity properties
        """
        client_id: pulumi.Input[_builtins.str]
        """
        Client ID for the user-assigned managed identity.
        """
        tenant_id: pulumi.Input[_builtins.str]
        """
        Tenant ID.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
elif False:
    DataflowEndpointAuthenticationUserAssignedManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 tenant_id: pulumi.Input[_builtins.str],
                 scope: Optional[pulumi.Input[_builtins.str]] = None):
        """
        DataflowEndpoint Authentication UserAssignedManagedIdentity properties
        :param pulumi.Input[_builtins.str] client_id: Client ID for the user-assigned managed identity.
        :param pulumi.Input[_builtins.str] tenant_id: Tenant ID.
        :param pulumi.Input[_builtins.str] scope: Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        Client ID for the user-assigned managed identity.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[_builtins.str]:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class DataflowEndpointAuthenticationX509ArgsDict(TypedDict):
        """
        DataflowEndpoint Authentication X509 properties
        """
        secret_ref: pulumi.Input[_builtins.str]
        """
        Secret reference of the X.509 certificate.
        """
elif False:
    DataflowEndpointAuthenticationX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointAuthenticationX509Args:
    def __init__(__self__, *,
                 secret_ref: pulumi.Input[_builtins.str]):
        """
        DataflowEndpoint Authentication X509 properties
        :param pulumi.Input[_builtins.str] secret_ref: Secret reference of the X.509 certificate.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        Secret reference of the X.509 certificate.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class DataflowEndpointDataExplorerAuthenticationArgsDict(TypedDict):
        """
        Azure Data Explorer Authentication properties. NOTE - only authentication property is allowed per entry.
        """
        method: Any
        """
        Mode of Authentication.
        """
        system_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict']]
        """
        System-assigned managed identity authentication.
        """
        user_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgsDict']]
        """
        User-assigned managed identity authentication.
        """
elif False:
    DataflowEndpointDataExplorerAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointDataExplorerAuthenticationArgs:
    def __init__(__self__, *,
                 method: Any,
                 system_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']] = None,
                 user_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']] = None):
        """
        Azure Data Explorer Authentication properties. NOTE - only authentication property is allowed per entry.
        :param Any method: Mode of Authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs'] system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs'] user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        """
        pulumi.set(__self__, "method", method)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Any:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Any):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @system_assigned_managed_identity_settings.setter
    def system_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]):
        pulumi.set(self, "system_assigned_managed_identity_settings", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @user_assigned_managed_identity_settings.setter
    def user_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]):
        pulumi.set(self, "user_assigned_managed_identity_settings", value)


if not MYPY:
    class DataflowEndpointDataExplorerArgsDict(TypedDict):
        """
        Azure Data Explorer endpoint properties
        """
        authentication: pulumi.Input['DataflowEndpointDataExplorerAuthenticationArgsDict']
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        database: pulumi.Input[_builtins.str]
        """
        Database name.
        """
        host: pulumi.Input[_builtins.str]
        """
        Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        """
        batching: NotRequired[pulumi.Input['BatchingConfigurationArgsDict']]
        """
        Azure Data Explorer endpoint batching configuration.
        """
elif False:
    DataflowEndpointDataExplorerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointDataExplorerArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['DataflowEndpointDataExplorerAuthenticationArgs'],
                 database: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 batching: Optional[pulumi.Input['BatchingConfigurationArgs']] = None):
        """
        Azure Data Explorer endpoint properties
        :param pulumi.Input['DataflowEndpointDataExplorerAuthenticationArgs'] authentication: Authentication configuration. NOTE - only authentication property is allowed per entry.
        :param pulumi.Input[_builtins.str] database: Database name.
        :param pulumi.Input[_builtins.str] host: Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        :param pulumi.Input['BatchingConfigurationArgs'] batching: Azure Data Explorer endpoint batching configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['DataflowEndpointDataExplorerAuthenticationArgs']:
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['DataflowEndpointDataExplorerAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def database(self) -> pulumi.Input[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def batching(self) -> Optional[pulumi.Input['BatchingConfigurationArgs']]:
        """
        Azure Data Explorer endpoint batching configuration.
        """
        return pulumi.get(self, "batching")

    @batching.setter
    def batching(self, value: Optional[pulumi.Input['BatchingConfigurationArgs']]):
        pulumi.set(self, "batching", value)


if not MYPY:
    class DataflowEndpointDataLakeStorageAuthenticationArgsDict(TypedDict):
        """
        Azure Data Lake endpoint Authentication properties.  NOTE Enum - Only one method is supported for one entry
        """
        method: pulumi.Input[Union[_builtins.str, 'DataLakeStorageAuthMethod']]
        """
        Mode of Authentication.
        """
        access_token_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationAccessTokenArgsDict']]
        """
        SAS token authentication.
        """
        system_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict']]
        """
        System-assigned managed identity authentication.
        """
        user_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgsDict']]
        """
        User-assigned managed identity authentication.
        """
elif False:
    DataflowEndpointDataLakeStorageAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointDataLakeStorageAuthenticationArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[_builtins.str, 'DataLakeStorageAuthMethod']],
                 access_token_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationAccessTokenArgs']] = None,
                 system_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']] = None,
                 user_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']] = None):
        """
        Azure Data Lake endpoint Authentication properties.  NOTE Enum - Only one method is supported for one entry
        :param pulumi.Input[Union[_builtins.str, 'DataLakeStorageAuthMethod']] method: Mode of Authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationAccessTokenArgs'] access_token_settings: SAS token authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs'] system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs'] user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        """
        pulumi.set(__self__, "method", method)
        if access_token_settings is not None:
            pulumi.set(__self__, "access_token_settings", access_token_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[_builtins.str, 'DataLakeStorageAuthMethod']]:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[_builtins.str, 'DataLakeStorageAuthMethod']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="accessTokenSettings")
    def access_token_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationAccessTokenArgs']]:
        """
        SAS token authentication.
        """
        return pulumi.get(self, "access_token_settings")

    @access_token_settings.setter
    def access_token_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationAccessTokenArgs']]):
        pulumi.set(self, "access_token_settings", value)

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @system_assigned_managed_identity_settings.setter
    def system_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]):
        pulumi.set(self, "system_assigned_managed_identity_settings", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @user_assigned_managed_identity_settings.setter
    def user_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]):
        pulumi.set(self, "user_assigned_managed_identity_settings", value)


if not MYPY:
    class DataflowEndpointDataLakeStorageArgsDict(TypedDict):
        """
        Azure Data Lake endpoint properties
        """
        authentication: pulumi.Input['DataflowEndpointDataLakeStorageAuthenticationArgsDict']
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        host: pulumi.Input[_builtins.str]
        """
        Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        """
        batching: NotRequired[pulumi.Input['BatchingConfigurationArgsDict']]
        """
        Azure Data Lake endpoint batching configuration.
        """
elif False:
    DataflowEndpointDataLakeStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointDataLakeStorageArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['DataflowEndpointDataLakeStorageAuthenticationArgs'],
                 host: pulumi.Input[_builtins.str],
                 batching: Optional[pulumi.Input['BatchingConfigurationArgs']] = None):
        """
        Azure Data Lake endpoint properties
        :param pulumi.Input['DataflowEndpointDataLakeStorageAuthenticationArgs'] authentication: Authentication configuration. NOTE - only authentication property is allowed per entry.
        :param pulumi.Input[_builtins.str] host: Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        :param pulumi.Input['BatchingConfigurationArgs'] batching: Azure Data Lake endpoint batching configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['DataflowEndpointDataLakeStorageAuthenticationArgs']:
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['DataflowEndpointDataLakeStorageAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def batching(self) -> Optional[pulumi.Input['BatchingConfigurationArgs']]:
        """
        Azure Data Lake endpoint batching configuration.
        """
        return pulumi.get(self, "batching")

    @batching.setter
    def batching(self, value: Optional[pulumi.Input['BatchingConfigurationArgs']]):
        pulumi.set(self, "batching", value)


if not MYPY:
    class DataflowEndpointFabricOneLakeAuthenticationArgsDict(TypedDict):
        """
        Microsoft Fabric endpoint. Authentication properties. NOTE - Only one method is supported for one entry
        """
        method: Any
        """
        Mode of Authentication.
        """
        system_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict']]
        """
        System-assigned managed identity authentication.
        """
        user_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgsDict']]
        """
        User-assigned managed identity authentication.
        """
elif False:
    DataflowEndpointFabricOneLakeAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointFabricOneLakeAuthenticationArgs:
    def __init__(__self__, *,
                 method: Any,
                 system_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']] = None,
                 user_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']] = None):
        """
        Microsoft Fabric endpoint. Authentication properties. NOTE - Only one method is supported for one entry
        :param Any method: Mode of Authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs'] system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs'] user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        """
        pulumi.set(__self__, "method", method)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Any:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Any):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @system_assigned_managed_identity_settings.setter
    def system_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]):
        pulumi.set(self, "system_assigned_managed_identity_settings", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @user_assigned_managed_identity_settings.setter
    def user_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]):
        pulumi.set(self, "user_assigned_managed_identity_settings", value)


if not MYPY:
    class DataflowEndpointFabricOneLakeNamesArgsDict(TypedDict):
        """
        Microsoft Fabric endpoint Names properties
        """
        lakehouse_name: pulumi.Input[_builtins.str]
        """
        Lakehouse name.
        """
        workspace_name: pulumi.Input[_builtins.str]
        """
        Workspace name.
        """
elif False:
    DataflowEndpointFabricOneLakeNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointFabricOneLakeNamesArgs:
    def __init__(__self__, *,
                 lakehouse_name: pulumi.Input[_builtins.str],
                 workspace_name: pulumi.Input[_builtins.str]):
        """
        Microsoft Fabric endpoint Names properties
        :param pulumi.Input[_builtins.str] lakehouse_name: Lakehouse name.
        :param pulumi.Input[_builtins.str] workspace_name: Workspace name.
        """
        pulumi.set(__self__, "lakehouse_name", lakehouse_name)
        pulumi.set(__self__, "workspace_name", workspace_name)

    @_builtins.property
    @pulumi.getter(name="lakehouseName")
    def lakehouse_name(self) -> pulumi.Input[_builtins.str]:
        """
        Lakehouse name.
        """
        return pulumi.get(self, "lakehouse_name")

    @lakehouse_name.setter
    def lakehouse_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lakehouse_name", value)

    @_builtins.property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> pulumi.Input[_builtins.str]:
        """
        Workspace name.
        """
        return pulumi.get(self, "workspace_name")

    @workspace_name.setter
    def workspace_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workspace_name", value)


if not MYPY:
    class DataflowEndpointFabricOneLakeArgsDict(TypedDict):
        """
        Microsoft Fabric endpoint properties
        """
        authentication: pulumi.Input['DataflowEndpointFabricOneLakeAuthenticationArgsDict']
        """
        Authentication configuration. NOTE - only one authentication property is allowed per entry.
        """
        host: pulumi.Input[_builtins.str]
        """
        Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        """
        names: pulumi.Input['DataflowEndpointFabricOneLakeNamesArgsDict']
        """
        Names of the workspace and lakehouse.
        """
        one_lake_path_type: pulumi.Input[Union[_builtins.str, 'DataflowEndpointFabricPathType']]
        """
        Type of location of the data in the workspace. Can be either tables or files.
        """
        batching: NotRequired[pulumi.Input['BatchingConfigurationArgsDict']]
        """
        Batching configuration.
        """
elif False:
    DataflowEndpointFabricOneLakeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointFabricOneLakeArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['DataflowEndpointFabricOneLakeAuthenticationArgs'],
                 host: pulumi.Input[_builtins.str],
                 names: pulumi.Input['DataflowEndpointFabricOneLakeNamesArgs'],
                 one_lake_path_type: pulumi.Input[Union[_builtins.str, 'DataflowEndpointFabricPathType']],
                 batching: Optional[pulumi.Input['BatchingConfigurationArgs']] = None):
        """
        Microsoft Fabric endpoint properties
        :param pulumi.Input['DataflowEndpointFabricOneLakeAuthenticationArgs'] authentication: Authentication configuration. NOTE - only one authentication property is allowed per entry.
        :param pulumi.Input[_builtins.str] host: Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        :param pulumi.Input['DataflowEndpointFabricOneLakeNamesArgs'] names: Names of the workspace and lakehouse.
        :param pulumi.Input[Union[_builtins.str, 'DataflowEndpointFabricPathType']] one_lake_path_type: Type of location of the data in the workspace. Can be either tables or files.
        :param pulumi.Input['BatchingConfigurationArgs'] batching: Batching configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "one_lake_path_type", one_lake_path_type)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['DataflowEndpointFabricOneLakeAuthenticationArgs']:
        """
        Authentication configuration. NOTE - only one authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['DataflowEndpointFabricOneLakeAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def names(self) -> pulumi.Input['DataflowEndpointFabricOneLakeNamesArgs']:
        """
        Names of the workspace and lakehouse.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: pulumi.Input['DataflowEndpointFabricOneLakeNamesArgs']):
        pulumi.set(self, "names", value)

    @_builtins.property
    @pulumi.getter(name="oneLakePathType")
    def one_lake_path_type(self) -> pulumi.Input[Union[_builtins.str, 'DataflowEndpointFabricPathType']]:
        """
        Type of location of the data in the workspace. Can be either tables or files.
        """
        return pulumi.get(self, "one_lake_path_type")

    @one_lake_path_type.setter
    def one_lake_path_type(self, value: pulumi.Input[Union[_builtins.str, 'DataflowEndpointFabricPathType']]):
        pulumi.set(self, "one_lake_path_type", value)

    @_builtins.property
    @pulumi.getter
    def batching(self) -> Optional[pulumi.Input['BatchingConfigurationArgs']]:
        """
        Batching configuration.
        """
        return pulumi.get(self, "batching")

    @batching.setter
    def batching(self, value: Optional[pulumi.Input['BatchingConfigurationArgs']]):
        pulumi.set(self, "batching", value)


if not MYPY:
    class DataflowEndpointKafkaAuthenticationArgsDict(TypedDict):
        """
        Kafka endpoint Authentication properties. NOTE - only authentication property is allowed per entry
        """
        method: pulumi.Input[Union[_builtins.str, 'KafkaAuthMethod']]
        """
        Mode of Authentication.
        """
        sasl_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationSaslArgsDict']]
        """
        SASL authentication.
        """
        system_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict']]
        """
        System-assigned managed identity authentication.
        """
        user_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgsDict']]
        """
        User-assigned managed identity authentication.
        """
        x509_certificate_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationX509ArgsDict']]
        """
        X.509 certificate authentication.
        """
elif False:
    DataflowEndpointKafkaAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointKafkaAuthenticationArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[_builtins.str, 'KafkaAuthMethod']],
                 sasl_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationSaslArgs']] = None,
                 system_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']] = None,
                 user_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']] = None,
                 x509_certificate_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationX509Args']] = None):
        """
        Kafka endpoint Authentication properties. NOTE - only authentication property is allowed per entry
        :param pulumi.Input[Union[_builtins.str, 'KafkaAuthMethod']] method: Mode of Authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationSaslArgs'] sasl_settings: SASL authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs'] system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs'] user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationX509Args'] x509_certificate_settings: X.509 certificate authentication.
        """
        pulumi.set(__self__, "method", method)
        if sasl_settings is not None:
            pulumi.set(__self__, "sasl_settings", sasl_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)
        if x509_certificate_settings is not None:
            pulumi.set(__self__, "x509_certificate_settings", x509_certificate_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[_builtins.str, 'KafkaAuthMethod']]:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[_builtins.str, 'KafkaAuthMethod']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="saslSettings")
    def sasl_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationSaslArgs']]:
        """
        SASL authentication.
        """
        return pulumi.get(self, "sasl_settings")

    @sasl_settings.setter
    def sasl_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationSaslArgs']]):
        pulumi.set(self, "sasl_settings", value)

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @system_assigned_managed_identity_settings.setter
    def system_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]):
        pulumi.set(self, "system_assigned_managed_identity_settings", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @user_assigned_managed_identity_settings.setter
    def user_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]):
        pulumi.set(self, "user_assigned_managed_identity_settings", value)

    @_builtins.property
    @pulumi.getter(name="x509CertificateSettings")
    def x509_certificate_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationX509Args']]:
        """
        X.509 certificate authentication.
        """
        return pulumi.get(self, "x509_certificate_settings")

    @x509_certificate_settings.setter
    def x509_certificate_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationX509Args']]):
        pulumi.set(self, "x509_certificate_settings", value)


if not MYPY:
    class DataflowEndpointKafkaBatchingArgsDict(TypedDict):
        """
        Kafka endpoint Batching properties
        """
        latency_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        Batching latency in milliseconds.
        """
        max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of bytes in a batch.
        """
        max_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of messages in a batch.
        """
        mode: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        Mode for batching.
        """
elif False:
    DataflowEndpointKafkaBatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointKafkaBatchingArgs:
    def __init__(__self__, *,
                 latency_ms: Optional[pulumi.Input[_builtins.int]] = None,
                 max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 max_messages: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None):
        """
        Kafka endpoint Batching properties
        :param pulumi.Input[_builtins.int] latency_ms: Batching latency in milliseconds.
        :param pulumi.Input[_builtins.int] max_bytes: Maximum number of bytes in a batch.
        :param pulumi.Input[_builtins.int] max_messages: Maximum number of messages in a batch.
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] mode: Mode for batching.
        """
        if latency_ms is None:
            latency_ms = 5
        if latency_ms is not None:
            pulumi.set(__self__, "latency_ms", latency_ms)
        if max_bytes is None:
            max_bytes = 1000000
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="latencyMs")
    def latency_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Batching latency in milliseconds.
        """
        return pulumi.get(self, "latency_ms")

    @latency_ms.setter
    def latency_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "latency_ms", value)

    @_builtins.property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of bytes in a batch.
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_bytes", value)

    @_builtins.property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of messages in a batch.
        """
        return pulumi.get(self, "max_messages")

    @max_messages.setter
    def max_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_messages", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        Mode for batching.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class DataflowEndpointKafkaArgsDict(TypedDict):
        """
        Kafka endpoint properties
        """
        authentication: pulumi.Input['DataflowEndpointKafkaAuthenticationArgsDict']
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        host: pulumi.Input[_builtins.str]
        """
        Kafka endpoint host.
        """
        batching: NotRequired[pulumi.Input['DataflowEndpointKafkaBatchingArgsDict']]
        """
        Batching configuration.
        """
        cloud_event_attributes: NotRequired[pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']]]
        """
        Cloud event mapping config.
        """
        compression: NotRequired[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaCompression']]]
        """
        Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        """
        consumer_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Consumer group ID.
        """
        copy_mqtt_properties: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        """
        kafka_acks: NotRequired[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaAcks']]]
        """
        Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        """
        partition_strategy: NotRequired[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaPartitionStrategy']]]
        """
        Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        """
        tls: NotRequired[pulumi.Input['TlsPropertiesArgsDict']]
        """
        TLS configuration.
        """
elif False:
    DataflowEndpointKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointKafkaArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['DataflowEndpointKafkaAuthenticationArgs'],
                 host: pulumi.Input[_builtins.str],
                 batching: Optional[pulumi.Input['DataflowEndpointKafkaBatchingArgs']] = None,
                 cloud_event_attributes: Optional[pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']]] = None,
                 compression: Optional[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaCompression']]] = None,
                 consumer_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 copy_mqtt_properties: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None,
                 kafka_acks: Optional[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaAcks']]] = None,
                 partition_strategy: Optional[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaPartitionStrategy']]] = None,
                 tls: Optional[pulumi.Input['TlsPropertiesArgs']] = None):
        """
        Kafka endpoint properties
        :param pulumi.Input['DataflowEndpointKafkaAuthenticationArgs'] authentication: Authentication configuration. NOTE - only authentication property is allowed per entry.
        :param pulumi.Input[_builtins.str] host: Kafka endpoint host.
        :param pulumi.Input['DataflowEndpointKafkaBatchingArgs'] batching: Batching configuration.
        :param pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']] cloud_event_attributes: Cloud event mapping config.
        :param pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaCompression']] compression: Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        :param pulumi.Input[_builtins.str] consumer_group_id: Consumer group ID.
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] copy_mqtt_properties: Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        :param pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaAcks']] kafka_acks: Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        :param pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaPartitionStrategy']] partition_strategy: Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        :param pulumi.Input['TlsPropertiesArgs'] tls: TLS configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)
        if cloud_event_attributes is not None:
            pulumi.set(__self__, "cloud_event_attributes", cloud_event_attributes)
        if compression is None:
            compression = 'None'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if copy_mqtt_properties is None:
            copy_mqtt_properties = 'Enabled'
        if copy_mqtt_properties is not None:
            pulumi.set(__self__, "copy_mqtt_properties", copy_mqtt_properties)
        if kafka_acks is None:
            kafka_acks = 'All'
        if kafka_acks is not None:
            pulumi.set(__self__, "kafka_acks", kafka_acks)
        if partition_strategy is None:
            partition_strategy = 'Default'
        if partition_strategy is not None:
            pulumi.set(__self__, "partition_strategy", partition_strategy)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['DataflowEndpointKafkaAuthenticationArgs']:
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['DataflowEndpointKafkaAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        Kafka endpoint host.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def batching(self) -> Optional[pulumi.Input['DataflowEndpointKafkaBatchingArgs']]:
        """
        Batching configuration.
        """
        return pulumi.get(self, "batching")

    @batching.setter
    def batching(self, value: Optional[pulumi.Input['DataflowEndpointKafkaBatchingArgs']]):
        pulumi.set(self, "batching", value)

    @_builtins.property
    @pulumi.getter(name="cloudEventAttributes")
    def cloud_event_attributes(self) -> Optional[pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']]]:
        """
        Cloud event mapping config.
        """
        return pulumi.get(self, "cloud_event_attributes")

    @cloud_event_attributes.setter
    def cloud_event_attributes(self, value: Optional[pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']]]):
        pulumi.set(self, "cloud_event_attributes", value)

    @_builtins.property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaCompression']]]:
        """
        Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaCompression']]]):
        pulumi.set(self, "compression", value)

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Consumer group ID.
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_group_id", value)

    @_builtins.property
    @pulumi.getter(name="copyMqttProperties")
    def copy_mqtt_properties(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        """
        return pulumi.get(self, "copy_mqtt_properties")

    @copy_mqtt_properties.setter
    def copy_mqtt_properties(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "copy_mqtt_properties", value)

    @_builtins.property
    @pulumi.getter(name="kafkaAcks")
    def kafka_acks(self) -> Optional[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaAcks']]]:
        """
        Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "kafka_acks")

    @kafka_acks.setter
    def kafka_acks(self, value: Optional[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaAcks']]]):
        pulumi.set(self, "kafka_acks", value)

    @_builtins.property
    @pulumi.getter(name="partitionStrategy")
    def partition_strategy(self) -> Optional[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaPartitionStrategy']]]:
        """
        Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "partition_strategy")

    @partition_strategy.setter
    def partition_strategy(self, value: Optional[pulumi.Input[Union[_builtins.str, 'DataflowEndpointKafkaPartitionStrategy']]]):
        pulumi.set(self, "partition_strategy", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['TlsPropertiesArgs']]:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['TlsPropertiesArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class DataflowEndpointLocalStorageArgsDict(TypedDict):
        """
        Local persistent volume endpoint properties
        """
        persistent_volume_claim_ref: pulumi.Input[_builtins.str]
        """
        Persistent volume claim name.
        """
elif False:
    DataflowEndpointLocalStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointLocalStorageArgs:
    def __init__(__self__, *,
                 persistent_volume_claim_ref: pulumi.Input[_builtins.str]):
        """
        Local persistent volume endpoint properties
        :param pulumi.Input[_builtins.str] persistent_volume_claim_ref: Persistent volume claim name.
        """
        pulumi.set(__self__, "persistent_volume_claim_ref", persistent_volume_claim_ref)

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaimRef")
    def persistent_volume_claim_ref(self) -> pulumi.Input[_builtins.str]:
        """
        Persistent volume claim name.
        """
        return pulumi.get(self, "persistent_volume_claim_ref")

    @persistent_volume_claim_ref.setter
    def persistent_volume_claim_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "persistent_volume_claim_ref", value)


if not MYPY:
    class DataflowEndpointMqttAuthenticationArgsDict(TypedDict):
        """
        Mqtt endpoint Authentication properties. NOTE - only authentication property is allowed per entry.
        """
        method: pulumi.Input[Union[_builtins.str, 'MqttAuthMethod']]
        """
        Mode of Authentication.
        """
        service_account_token_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationServiceAccountTokenArgsDict']]
        """
        Kubernetes service account token authentication. Default audience if not set is aio-internal
        """
        system_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict']]
        """
        System-assigned managed identity authentication.
        """
        user_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgsDict']]
        """
        User-assigned managed identity authentication.
        """
        x509_certificate_settings: NotRequired[pulumi.Input['DataflowEndpointAuthenticationX509ArgsDict']]
        """
        X.509 certificate authentication.
        """
elif False:
    DataflowEndpointMqttAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointMqttAuthenticationArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[_builtins.str, 'MqttAuthMethod']],
                 service_account_token_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationServiceAccountTokenArgs']] = None,
                 system_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']] = None,
                 user_assigned_managed_identity_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']] = None,
                 x509_certificate_settings: Optional[pulumi.Input['DataflowEndpointAuthenticationX509Args']] = None):
        """
        Mqtt endpoint Authentication properties. NOTE - only authentication property is allowed per entry.
        :param pulumi.Input[Union[_builtins.str, 'MqttAuthMethod']] method: Mode of Authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationServiceAccountTokenArgs'] service_account_token_settings: Kubernetes service account token authentication. Default audience if not set is aio-internal
        :param pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs'] system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs'] user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        :param pulumi.Input['DataflowEndpointAuthenticationX509Args'] x509_certificate_settings: X.509 certificate authentication.
        """
        pulumi.set(__self__, "method", method)
        if service_account_token_settings is not None:
            pulumi.set(__self__, "service_account_token_settings", service_account_token_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)
        if x509_certificate_settings is not None:
            pulumi.set(__self__, "x509_certificate_settings", x509_certificate_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[_builtins.str, 'MqttAuthMethod']]:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[_builtins.str, 'MqttAuthMethod']]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountTokenSettings")
    def service_account_token_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationServiceAccountTokenArgs']]:
        """
        Kubernetes service account token authentication. Default audience if not set is aio-internal
        """
        return pulumi.get(self, "service_account_token_settings")

    @service_account_token_settings.setter
    def service_account_token_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationServiceAccountTokenArgs']]):
        pulumi.set(self, "service_account_token_settings", value)

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @system_assigned_managed_identity_settings.setter
    def system_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]):
        pulumi.set(self, "system_assigned_managed_identity_settings", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @user_assigned_managed_identity_settings.setter
    def user_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationUserAssignedManagedIdentityArgs']]):
        pulumi.set(self, "user_assigned_managed_identity_settings", value)

    @_builtins.property
    @pulumi.getter(name="x509CertificateSettings")
    def x509_certificate_settings(self) -> Optional[pulumi.Input['DataflowEndpointAuthenticationX509Args']]:
        """
        X.509 certificate authentication.
        """
        return pulumi.get(self, "x509_certificate_settings")

    @x509_certificate_settings.setter
    def x509_certificate_settings(self, value: Optional[pulumi.Input['DataflowEndpointAuthenticationX509Args']]):
        pulumi.set(self, "x509_certificate_settings", value)


if not MYPY:
    class DataflowEndpointMqttArgsDict(TypedDict):
        """
        Broker endpoint properties
        """
        authentication: pulumi.Input['DataflowEndpointMqttAuthenticationArgsDict']
        """
        authentication properties. DEFAULT: kubernetes.audience=aio-internal. NOTE - Enum field only property is allowed
        """
        client_id_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        """
        cloud_event_attributes: NotRequired[pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']]]
        """
        Cloud event mapping config.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        """
        keep_alive_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Broker KeepAlive for connection in seconds.
        """
        max_inflight_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        """
        protocol: NotRequired[pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']]]
        """
        Enable or disable websockets.
        """
        qos: NotRequired[pulumi.Input[_builtins.int]]
        """
        Qos for Broker connection.
        """
        retain: NotRequired[pulumi.Input[Union[_builtins.str, 'MqttRetainType']]]
        """
        Whether or not to keep the retain setting.
        """
        session_expiry_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Session expiry in seconds.
        """
        tls: NotRequired[pulumi.Input['TlsPropertiesArgsDict']]
        """
        TLS configuration.
        """
elif False:
    DataflowEndpointMqttArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointMqttArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['DataflowEndpointMqttAuthenticationArgs'],
                 client_id_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 cloud_event_attributes: Optional[pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 keep_alive_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 max_inflight_messages: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']]] = None,
                 qos: Optional[pulumi.Input[_builtins.int]] = None,
                 retain: Optional[pulumi.Input[Union[_builtins.str, 'MqttRetainType']]] = None,
                 session_expiry_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 tls: Optional[pulumi.Input['TlsPropertiesArgs']] = None):
        """
        Broker endpoint properties
        :param pulumi.Input['DataflowEndpointMqttAuthenticationArgs'] authentication: authentication properties. DEFAULT: kubernetes.audience=aio-internal. NOTE - Enum field only property is allowed
        :param pulumi.Input[_builtins.str] client_id_prefix: Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        :param pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']] cloud_event_attributes: Cloud event mapping config.
        :param pulumi.Input[_builtins.str] host: Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        :param pulumi.Input[_builtins.int] keep_alive_seconds: Broker KeepAlive for connection in seconds.
        :param pulumi.Input[_builtins.int] max_inflight_messages: The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        :param pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']] protocol: Enable or disable websockets.
        :param pulumi.Input[_builtins.int] qos: Qos for Broker connection.
        :param pulumi.Input[Union[_builtins.str, 'MqttRetainType']] retain: Whether or not to keep the retain setting.
        :param pulumi.Input[_builtins.int] session_expiry_seconds: Session expiry in seconds.
        :param pulumi.Input['TlsPropertiesArgs'] tls: TLS configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        if client_id_prefix is not None:
            pulumi.set(__self__, "client_id_prefix", client_id_prefix)
        if cloud_event_attributes is not None:
            pulumi.set(__self__, "cloud_event_attributes", cloud_event_attributes)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_alive_seconds is None:
            keep_alive_seconds = 60
        if keep_alive_seconds is not None:
            pulumi.set(__self__, "keep_alive_seconds", keep_alive_seconds)
        if max_inflight_messages is None:
            max_inflight_messages = 100
        if max_inflight_messages is not None:
            pulumi.set(__self__, "max_inflight_messages", max_inflight_messages)
        if protocol is None:
            protocol = 'Mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if retain is None:
            retain = 'Keep'
        if retain is not None:
            pulumi.set(__self__, "retain", retain)
        if session_expiry_seconds is not None:
            pulumi.set(__self__, "session_expiry_seconds", session_expiry_seconds)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['DataflowEndpointMqttAuthenticationArgs']:
        """
        authentication properties. DEFAULT: kubernetes.audience=aio-internal. NOTE - Enum field only property is allowed
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['DataflowEndpointMqttAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter(name="clientIdPrefix")
    def client_id_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        """
        return pulumi.get(self, "client_id_prefix")

    @client_id_prefix.setter
    def client_id_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id_prefix", value)

    @_builtins.property
    @pulumi.getter(name="cloudEventAttributes")
    def cloud_event_attributes(self) -> Optional[pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']]]:
        """
        Cloud event mapping config.
        """
        return pulumi.get(self, "cloud_event_attributes")

    @cloud_event_attributes.setter
    def cloud_event_attributes(self, value: Optional[pulumi.Input[Union[_builtins.str, 'CloudEventAttributeType']]]):
        pulumi.set(self, "cloud_event_attributes", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="keepAliveSeconds")
    def keep_alive_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Broker KeepAlive for connection in seconds.
        """
        return pulumi.get(self, "keep_alive_seconds")

    @keep_alive_seconds.setter
    def keep_alive_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_alive_seconds", value)

    @_builtins.property
    @pulumi.getter(name="maxInflightMessages")
    def max_inflight_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        """
        return pulumi.get(self, "max_inflight_messages")

    @max_inflight_messages.setter
    def max_inflight_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_inflight_messages", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']]]:
        """
        Enable or disable websockets.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Qos for Broker connection.
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "qos", value)

    @_builtins.property
    @pulumi.getter
    def retain(self) -> Optional[pulumi.Input[Union[_builtins.str, 'MqttRetainType']]]:
        """
        Whether or not to keep the retain setting.
        """
        return pulumi.get(self, "retain")

    @retain.setter
    def retain(self, value: Optional[pulumi.Input[Union[_builtins.str, 'MqttRetainType']]]):
        pulumi.set(self, "retain", value)

    @_builtins.property
    @pulumi.getter(name="sessionExpirySeconds")
    def session_expiry_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Session expiry in seconds.
        """
        return pulumi.get(self, "session_expiry_seconds")

    @session_expiry_seconds.setter
    def session_expiry_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "session_expiry_seconds", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['TlsPropertiesArgs']]:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['TlsPropertiesArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class DataflowEndpointPropertiesArgsDict(TypedDict):
        """
        DataflowEndpoint Resource properties. NOTE - Only one type of endpoint is supported for one Resource
        """
        endpoint_type: pulumi.Input[Union[_builtins.str, 'EndpointType']]
        """
        Endpoint Type.
        """
        data_explorer_settings: NotRequired[pulumi.Input['DataflowEndpointDataExplorerArgsDict']]
        """
        Azure Data Explorer endpoint.
        """
        data_lake_storage_settings: NotRequired[pulumi.Input['DataflowEndpointDataLakeStorageArgsDict']]
        """
        Azure Data Lake endpoint.
        """
        fabric_one_lake_settings: NotRequired[pulumi.Input['DataflowEndpointFabricOneLakeArgsDict']]
        """
        Microsoft Fabric endpoint.
        """
        kafka_settings: NotRequired[pulumi.Input['DataflowEndpointKafkaArgsDict']]
        """
        Kafka endpoint.
        """
        local_storage_settings: NotRequired[pulumi.Input['DataflowEndpointLocalStorageArgsDict']]
        """
        Local persistent volume endpoint.
        """
        mqtt_settings: NotRequired[pulumi.Input['DataflowEndpointMqttArgsDict']]
        """
        Broker endpoint.
        """
elif False:
    DataflowEndpointPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowEndpointPropertiesArgs:
    def __init__(__self__, *,
                 endpoint_type: pulumi.Input[Union[_builtins.str, 'EndpointType']],
                 data_explorer_settings: Optional[pulumi.Input['DataflowEndpointDataExplorerArgs']] = None,
                 data_lake_storage_settings: Optional[pulumi.Input['DataflowEndpointDataLakeStorageArgs']] = None,
                 fabric_one_lake_settings: Optional[pulumi.Input['DataflowEndpointFabricOneLakeArgs']] = None,
                 kafka_settings: Optional[pulumi.Input['DataflowEndpointKafkaArgs']] = None,
                 local_storage_settings: Optional[pulumi.Input['DataflowEndpointLocalStorageArgs']] = None,
                 mqtt_settings: Optional[pulumi.Input['DataflowEndpointMqttArgs']] = None):
        """
        DataflowEndpoint Resource properties. NOTE - Only one type of endpoint is supported for one Resource
        :param pulumi.Input[Union[_builtins.str, 'EndpointType']] endpoint_type: Endpoint Type.
        :param pulumi.Input['DataflowEndpointDataExplorerArgs'] data_explorer_settings: Azure Data Explorer endpoint.
        :param pulumi.Input['DataflowEndpointDataLakeStorageArgs'] data_lake_storage_settings: Azure Data Lake endpoint.
        :param pulumi.Input['DataflowEndpointFabricOneLakeArgs'] fabric_one_lake_settings: Microsoft Fabric endpoint.
        :param pulumi.Input['DataflowEndpointKafkaArgs'] kafka_settings: Kafka endpoint.
        :param pulumi.Input['DataflowEndpointLocalStorageArgs'] local_storage_settings: Local persistent volume endpoint.
        :param pulumi.Input['DataflowEndpointMqttArgs'] mqtt_settings: Broker endpoint.
        """
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        if data_explorer_settings is not None:
            pulumi.set(__self__, "data_explorer_settings", data_explorer_settings)
        if data_lake_storage_settings is not None:
            pulumi.set(__self__, "data_lake_storage_settings", data_lake_storage_settings)
        if fabric_one_lake_settings is not None:
            pulumi.set(__self__, "fabric_one_lake_settings", fabric_one_lake_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if local_storage_settings is not None:
            pulumi.set(__self__, "local_storage_settings", local_storage_settings)
        if mqtt_settings is not None:
            pulumi.set(__self__, "mqtt_settings", mqtt_settings)

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[Union[_builtins.str, 'EndpointType']]:
        """
        Endpoint Type.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[Union[_builtins.str, 'EndpointType']]):
        pulumi.set(self, "endpoint_type", value)

    @_builtins.property
    @pulumi.getter(name="dataExplorerSettings")
    def data_explorer_settings(self) -> Optional[pulumi.Input['DataflowEndpointDataExplorerArgs']]:
        """
        Azure Data Explorer endpoint.
        """
        return pulumi.get(self, "data_explorer_settings")

    @data_explorer_settings.setter
    def data_explorer_settings(self, value: Optional[pulumi.Input['DataflowEndpointDataExplorerArgs']]):
        pulumi.set(self, "data_explorer_settings", value)

    @_builtins.property
    @pulumi.getter(name="dataLakeStorageSettings")
    def data_lake_storage_settings(self) -> Optional[pulumi.Input['DataflowEndpointDataLakeStorageArgs']]:
        """
        Azure Data Lake endpoint.
        """
        return pulumi.get(self, "data_lake_storage_settings")

    @data_lake_storage_settings.setter
    def data_lake_storage_settings(self, value: Optional[pulumi.Input['DataflowEndpointDataLakeStorageArgs']]):
        pulumi.set(self, "data_lake_storage_settings", value)

    @_builtins.property
    @pulumi.getter(name="fabricOneLakeSettings")
    def fabric_one_lake_settings(self) -> Optional[pulumi.Input['DataflowEndpointFabricOneLakeArgs']]:
        """
        Microsoft Fabric endpoint.
        """
        return pulumi.get(self, "fabric_one_lake_settings")

    @fabric_one_lake_settings.setter
    def fabric_one_lake_settings(self, value: Optional[pulumi.Input['DataflowEndpointFabricOneLakeArgs']]):
        pulumi.set(self, "fabric_one_lake_settings", value)

    @_builtins.property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[pulumi.Input['DataflowEndpointKafkaArgs']]:
        """
        Kafka endpoint.
        """
        return pulumi.get(self, "kafka_settings")

    @kafka_settings.setter
    def kafka_settings(self, value: Optional[pulumi.Input['DataflowEndpointKafkaArgs']]):
        pulumi.set(self, "kafka_settings", value)

    @_builtins.property
    @pulumi.getter(name="localStorageSettings")
    def local_storage_settings(self) -> Optional[pulumi.Input['DataflowEndpointLocalStorageArgs']]:
        """
        Local persistent volume endpoint.
        """
        return pulumi.get(self, "local_storage_settings")

    @local_storage_settings.setter
    def local_storage_settings(self, value: Optional[pulumi.Input['DataflowEndpointLocalStorageArgs']]):
        pulumi.set(self, "local_storage_settings", value)

    @_builtins.property
    @pulumi.getter(name="mqttSettings")
    def mqtt_settings(self) -> Optional[pulumi.Input['DataflowEndpointMqttArgs']]:
        """
        Broker endpoint.
        """
        return pulumi.get(self, "mqtt_settings")

    @mqtt_settings.setter
    def mqtt_settings(self, value: Optional[pulumi.Input['DataflowEndpointMqttArgs']]):
        pulumi.set(self, "mqtt_settings", value)


if not MYPY:
    class DataflowGraphConnectionInputArgsDict(TypedDict):
        """
        DataflowGraph DataflowGraphNode Connection Input.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the input node.
        """
        schema: NotRequired[pulumi.Input['DataflowGraphConnectionSchemaSettingsArgsDict']]
        """
        Schema settings for the input node.
        """
elif False:
    DataflowGraphConnectionInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphConnectionInputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 schema: Optional[pulumi.Input['DataflowGraphConnectionSchemaSettingsArgs']] = None):
        """
        DataflowGraph DataflowGraphNode Connection Input.
        :param pulumi.Input[_builtins.str] name: Name of the input node.
        :param pulumi.Input['DataflowGraphConnectionSchemaSettingsArgs'] schema: Schema settings for the input node.
        """
        pulumi.set(__self__, "name", name)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the input node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input['DataflowGraphConnectionSchemaSettingsArgs']]:
        """
        Schema settings for the input node.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input['DataflowGraphConnectionSchemaSettingsArgs']]):
        pulumi.set(self, "schema", value)


if not MYPY:
    class DataflowGraphConnectionOutputArgsDict(TypedDict):
        """
        DataflowGraph DataflowGraphNode Connection Output.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the destination node.
        """
elif False:
    DataflowGraphConnectionOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphConnectionOutputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        DataflowGraph DataflowGraphNode Connection Output.
        :param pulumi.Input[_builtins.str] name: Name of the destination node.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the destination node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DataflowGraphConnectionSchemaSettingsArgsDict(TypedDict):
        """
        DataflowGraph connection node output schema settings.
        """
        schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference to the schema that describes the output of the transformation.
        """
        serialization_format: NotRequired[pulumi.Input[Union[_builtins.str, 'DataflowGraphConnectionSchemaSerializationFormat']]]
        """
        Output serialization format.
        """
elif False:
    DataflowGraphConnectionSchemaSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphConnectionSchemaSettingsArgs:
    def __init__(__self__, *,
                 schema_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 serialization_format: Optional[pulumi.Input[Union[_builtins.str, 'DataflowGraphConnectionSchemaSerializationFormat']]] = None):
        """
        DataflowGraph connection node output schema settings.
        :param pulumi.Input[_builtins.str] schema_ref: Reference to the schema that describes the output of the transformation.
        :param pulumi.Input[Union[_builtins.str, 'DataflowGraphConnectionSchemaSerializationFormat']] serialization_format: Output serialization format.
        """
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to the schema that describes the output of the transformation.
        """
        return pulumi.get(self, "schema_ref")

    @schema_ref.setter
    def schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_ref", value)

    @_builtins.property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[pulumi.Input[Union[_builtins.str, 'DataflowGraphConnectionSchemaSerializationFormat']]]:
        """
        Output serialization format.
        """
        return pulumi.get(self, "serialization_format")

    @serialization_format.setter
    def serialization_format(self, value: Optional[pulumi.Input[Union[_builtins.str, 'DataflowGraphConnectionSchemaSerializationFormat']]]):
        pulumi.set(self, "serialization_format", value)


if not MYPY:
    class DataflowGraphDestinationNodeSettingsArgsDict(TypedDict):
        """
        DataflowGraph destination node settings.
        """
        data_destination: pulumi.Input[_builtins.str]
        """
        Data destination at the endpoint.
        """
        endpoint_ref: pulumi.Input[_builtins.str]
        """
        The name of the DataflowEndpoint resource .
        """
        output_schema_settings: NotRequired[pulumi.Input['DataflowGraphDestinationSchemaSettingsArgsDict']]
        """
        Output schema settings.
        """
elif False:
    DataflowGraphDestinationNodeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphDestinationNodeSettingsArgs:
    def __init__(__self__, *,
                 data_destination: pulumi.Input[_builtins.str],
                 endpoint_ref: pulumi.Input[_builtins.str],
                 output_schema_settings: Optional[pulumi.Input['DataflowGraphDestinationSchemaSettingsArgs']] = None):
        """
        DataflowGraph destination node settings.
        :param pulumi.Input[_builtins.str] data_destination: Data destination at the endpoint.
        :param pulumi.Input[_builtins.str] endpoint_ref: The name of the DataflowEndpoint resource .
        :param pulumi.Input['DataflowGraphDestinationSchemaSettingsArgs'] output_schema_settings: Output schema settings.
        """
        pulumi.set(__self__, "data_destination", data_destination)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)
        if output_schema_settings is not None:
            pulumi.set(__self__, "output_schema_settings", output_schema_settings)

    @_builtins.property
    @pulumi.getter(name="dataDestination")
    def data_destination(self) -> pulumi.Input[_builtins.str]:
        """
        Data destination at the endpoint.
        """
        return pulumi.get(self, "data_destination")

    @data_destination.setter
    def data_destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_destination", value)

    @_builtins.property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the DataflowEndpoint resource .
        """
        return pulumi.get(self, "endpoint_ref")

    @endpoint_ref.setter
    def endpoint_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint_ref", value)

    @_builtins.property
    @pulumi.getter(name="outputSchemaSettings")
    def output_schema_settings(self) -> Optional[pulumi.Input['DataflowGraphDestinationSchemaSettingsArgs']]:
        """
        Output schema settings.
        """
        return pulumi.get(self, "output_schema_settings")

    @output_schema_settings.setter
    def output_schema_settings(self, value: Optional[pulumi.Input['DataflowGraphDestinationSchemaSettingsArgs']]):
        pulumi.set(self, "output_schema_settings", value)


if not MYPY:
    class DataflowGraphDestinationNodeArgsDict(TypedDict):
        """
        DataflowGraph destination node properties.
        """
        destination_settings: pulumi.Input['DataflowGraphDestinationNodeSettingsArgsDict']
        """
        Destination configuration.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the node.
        """
        node_type: pulumi.Input[_builtins.str]
        """
        DataflowGraph node types.
        Expected value is 'Destination'.
        """
elif False:
    DataflowGraphDestinationNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphDestinationNodeArgs:
    def __init__(__self__, *,
                 destination_settings: pulumi.Input['DataflowGraphDestinationNodeSettingsArgs'],
                 name: pulumi.Input[_builtins.str],
                 node_type: pulumi.Input[_builtins.str]):
        """
        DataflowGraph destination node properties.
        :param pulumi.Input['DataflowGraphDestinationNodeSettingsArgs'] destination_settings: Destination configuration.
        :param pulumi.Input[_builtins.str] name: Name of the node.
        :param pulumi.Input[_builtins.str] node_type: DataflowGraph node types.
               Expected value is 'Destination'.
        """
        pulumi.set(__self__, "destination_settings", destination_settings)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_type", 'Destination')

    @_builtins.property
    @pulumi.getter(name="destinationSettings")
    def destination_settings(self) -> pulumi.Input['DataflowGraphDestinationNodeSettingsArgs']:
        """
        Destination configuration.
        """
        return pulumi.get(self, "destination_settings")

    @destination_settings.setter
    def destination_settings(self, value: pulumi.Input['DataflowGraphDestinationNodeSettingsArgs']):
        pulumi.set(self, "destination_settings", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> pulumi.Input[_builtins.str]:
        """
        DataflowGraph node types.
        Expected value is 'Destination'.
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_type", value)


if not MYPY:
    class DataflowGraphDestinationSchemaSettingsArgsDict(TypedDict):
        """
        DataflowGraph destination node output schema settings.
        """
        serialization_format: pulumi.Input[Union[_builtins.str, 'DataflowGraphDestinationSchemaSerializationFormat']]
        """
        The format of the output data.
        """
        schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference to the schema that describes the output of the transformation.
        """
elif False:
    DataflowGraphDestinationSchemaSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphDestinationSchemaSettingsArgs:
    def __init__(__self__, *,
                 serialization_format: pulumi.Input[Union[_builtins.str, 'DataflowGraphDestinationSchemaSerializationFormat']],
                 schema_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        DataflowGraph destination node output schema settings.
        :param pulumi.Input[Union[_builtins.str, 'DataflowGraphDestinationSchemaSerializationFormat']] serialization_format: The format of the output data.
        :param pulumi.Input[_builtins.str] schema_ref: Reference to the schema that describes the output of the transformation.
        """
        pulumi.set(__self__, "serialization_format", serialization_format)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)

    @_builtins.property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> pulumi.Input[Union[_builtins.str, 'DataflowGraphDestinationSchemaSerializationFormat']]:
        """
        The format of the output data.
        """
        return pulumi.get(self, "serialization_format")

    @serialization_format.setter
    def serialization_format(self, value: pulumi.Input[Union[_builtins.str, 'DataflowGraphDestinationSchemaSerializationFormat']]):
        pulumi.set(self, "serialization_format", value)

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to the schema that describes the output of the transformation.
        """
        return pulumi.get(self, "schema_ref")

    @schema_ref.setter
    def schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_ref", value)


if not MYPY:
    class DataflowGraphGraphNodeConfigurationArgsDict(TypedDict):
        """
        DataflowGraph graph node configuration.
        """
        key: pulumi.Input[_builtins.str]
        """
        Key of the configuration.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the configuration.
        """
elif False:
    DataflowGraphGraphNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphGraphNodeConfigurationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        DataflowGraph graph node configuration.
        :param pulumi.Input[_builtins.str] key: Key of the configuration.
        :param pulumi.Input[_builtins.str] value: Value of the configuration.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key of the configuration.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the configuration.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DataflowGraphGraphNodeArgsDict(TypedDict):
        """
        DataflowGraph graph node properties.
        """
        graph_settings: pulumi.Input['DataflowGraphNodeGraphSettingsArgsDict']
        """
        Graph configuration.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the node.
        """
        node_type: pulumi.Input[_builtins.str]
        """
        DataflowGraph node types.
        Expected value is 'Graph'.
        """
elif False:
    DataflowGraphGraphNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphGraphNodeArgs:
    def __init__(__self__, *,
                 graph_settings: pulumi.Input['DataflowGraphNodeGraphSettingsArgs'],
                 name: pulumi.Input[_builtins.str],
                 node_type: pulumi.Input[_builtins.str]):
        """
        DataflowGraph graph node properties.
        :param pulumi.Input['DataflowGraphNodeGraphSettingsArgs'] graph_settings: Graph configuration.
        :param pulumi.Input[_builtins.str] name: Name of the node.
        :param pulumi.Input[_builtins.str] node_type: DataflowGraph node types.
               Expected value is 'Graph'.
        """
        pulumi.set(__self__, "graph_settings", graph_settings)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_type", 'Graph')

    @_builtins.property
    @pulumi.getter(name="graphSettings")
    def graph_settings(self) -> pulumi.Input['DataflowGraphNodeGraphSettingsArgs']:
        """
        Graph configuration.
        """
        return pulumi.get(self, "graph_settings")

    @graph_settings.setter
    def graph_settings(self, value: pulumi.Input['DataflowGraphNodeGraphSettingsArgs']):
        pulumi.set(self, "graph_settings", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> pulumi.Input[_builtins.str]:
        """
        DataflowGraph node types.
        Expected value is 'Graph'.
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_type", value)


if not MYPY:
    class DataflowGraphNodeConnectionArgsDict(TypedDict):
        """
        DataflowGraph DataflowGraphNode Connection.
        """
        from_: pulumi.Input['DataflowGraphConnectionInputArgsDict']
        """
        Information about the source node.
        """
        to: pulumi.Input['DataflowGraphConnectionOutputArgsDict']
        """
        Information about the destination node.
        """
elif False:
    DataflowGraphNodeConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphNodeConnectionArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input['DataflowGraphConnectionInputArgs'],
                 to: pulumi.Input['DataflowGraphConnectionOutputArgs']):
        """
        DataflowGraph DataflowGraphNode Connection.
        :param pulumi.Input['DataflowGraphConnectionInputArgs'] from_: Information about the source node.
        :param pulumi.Input['DataflowGraphConnectionOutputArgs'] to: Information about the destination node.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input['DataflowGraphConnectionInputArgs']:
        """
        Information about the source node.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input['DataflowGraphConnectionInputArgs']):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input['DataflowGraphConnectionOutputArgs']:
        """
        Information about the destination node.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input['DataflowGraphConnectionOutputArgs']):
        pulumi.set(self, "to", value)


if not MYPY:
    class DataflowGraphNodeGraphSettingsArgsDict(TypedDict):
        """
        DataflowGraph graph node settings.
        """
        artifact: pulumi.Input[_builtins.str]
        """
        The artifact name and version to pull. This should be in the format `<artifact-name>:<version>`.
        """
        registry_endpoint_ref: pulumi.Input[_builtins.str]
        """
        Reference to the registry endpoint for pulling the artifact.
        """
        configuration: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataflowGraphGraphNodeConfigurationArgsDict']]]]
        """
        Configuration key-value pairs.
        """
elif False:
    DataflowGraphNodeGraphSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphNodeGraphSettingsArgs:
    def __init__(__self__, *,
                 artifact: pulumi.Input[_builtins.str],
                 registry_endpoint_ref: pulumi.Input[_builtins.str],
                 configuration: Optional[pulumi.Input[Sequence[pulumi.Input['DataflowGraphGraphNodeConfigurationArgs']]]] = None):
        """
        DataflowGraph graph node settings.
        :param pulumi.Input[_builtins.str] artifact: The artifact name and version to pull. This should be in the format `<artifact-name>:<version>`.
        :param pulumi.Input[_builtins.str] registry_endpoint_ref: Reference to the registry endpoint for pulling the artifact.
        :param pulumi.Input[Sequence[pulumi.Input['DataflowGraphGraphNodeConfigurationArgs']]] configuration: Configuration key-value pairs.
        """
        pulumi.set(__self__, "artifact", artifact)
        pulumi.set(__self__, "registry_endpoint_ref", registry_endpoint_ref)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @_builtins.property
    @pulumi.getter
    def artifact(self) -> pulumi.Input[_builtins.str]:
        """
        The artifact name and version to pull. This should be in the format `<artifact-name>:<version>`.
        """
        return pulumi.get(self, "artifact")

    @artifact.setter
    def artifact(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "artifact", value)

    @_builtins.property
    @pulumi.getter(name="registryEndpointRef")
    def registry_endpoint_ref(self) -> pulumi.Input[_builtins.str]:
        """
        Reference to the registry endpoint for pulling the artifact.
        """
        return pulumi.get(self, "registry_endpoint_ref")

    @registry_endpoint_ref.setter
    def registry_endpoint_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_endpoint_ref", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataflowGraphGraphNodeConfigurationArgs']]]]:
        """
        Configuration key-value pairs.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataflowGraphGraphNodeConfigurationArgs']]]]):
        pulumi.set(self, "configuration", value)


if not MYPY:
    class DataflowGraphPropertiesArgsDict(TypedDict):
        """
        DataflowGraph properties.
        """
        node_connections: pulumi.Input[Sequence[pulumi.Input['DataflowGraphNodeConnectionArgsDict']]]
        """
        List of connections between nodes in the dataflow graph.
        """
        nodes: pulumi.Input[Sequence[pulumi.Input[Union['DataflowGraphDestinationNodeArgsDict', 'DataflowGraphGraphNodeArgsDict', 'DataflowGraphSourceNodeArgsDict']]]]
        """
        List of nodes in the dataflow graph.
        """
        mode: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        The mode of the dataflow graph.
        """
        request_disk_persistence: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        Disk persistence mode.
        """
elif False:
    DataflowGraphPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphPropertiesArgs:
    def __init__(__self__, *,
                 node_connections: pulumi.Input[Sequence[pulumi.Input['DataflowGraphNodeConnectionArgs']]],
                 nodes: pulumi.Input[Sequence[pulumi.Input[Union['DataflowGraphDestinationNodeArgs', 'DataflowGraphGraphNodeArgs', 'DataflowGraphSourceNodeArgs']]]],
                 mode: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None,
                 request_disk_persistence: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None):
        """
        DataflowGraph properties.
        :param pulumi.Input[Sequence[pulumi.Input['DataflowGraphNodeConnectionArgs']]] node_connections: List of connections between nodes in the dataflow graph.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DataflowGraphDestinationNodeArgs', 'DataflowGraphGraphNodeArgs', 'DataflowGraphSourceNodeArgs']]]] nodes: List of nodes in the dataflow graph.
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] mode: The mode of the dataflow graph.
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] request_disk_persistence: Disk persistence mode.
        """
        pulumi.set(__self__, "node_connections", node_connections)
        pulumi.set(__self__, "nodes", nodes)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if request_disk_persistence is not None:
            pulumi.set(__self__, "request_disk_persistence", request_disk_persistence)

    @_builtins.property
    @pulumi.getter(name="nodeConnections")
    def node_connections(self) -> pulumi.Input[Sequence[pulumi.Input['DataflowGraphNodeConnectionArgs']]]:
        """
        List of connections between nodes in the dataflow graph.
        """
        return pulumi.get(self, "node_connections")

    @node_connections.setter
    def node_connections(self, value: pulumi.Input[Sequence[pulumi.Input['DataflowGraphNodeConnectionArgs']]]):
        pulumi.set(self, "node_connections", value)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input[Union['DataflowGraphDestinationNodeArgs', 'DataflowGraphGraphNodeArgs', 'DataflowGraphSourceNodeArgs']]]]:
        """
        List of nodes in the dataflow graph.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input[Union['DataflowGraphDestinationNodeArgs', 'DataflowGraphGraphNodeArgs', 'DataflowGraphSourceNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        The mode of the dataflow graph.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="requestDiskPersistence")
    def request_disk_persistence(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        Disk persistence mode.
        """
        return pulumi.get(self, "request_disk_persistence")

    @request_disk_persistence.setter
    def request_disk_persistence(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "request_disk_persistence", value)


if not MYPY:
    class DataflowGraphSourceNodeArgsDict(TypedDict):
        """
        DataflowGraph source node properties.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the node.
        """
        node_type: pulumi.Input[_builtins.str]
        """
        DataflowGraph node types.
        Expected value is 'Source'.
        """
        source_settings: pulumi.Input['DataflowGraphSourceSettingsArgsDict']
        """
        Source configuration.
        """
elif False:
    DataflowGraphSourceNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphSourceNodeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 node_type: pulumi.Input[_builtins.str],
                 source_settings: pulumi.Input['DataflowGraphSourceSettingsArgs']):
        """
        DataflowGraph source node properties.
        :param pulumi.Input[_builtins.str] name: Name of the node.
        :param pulumi.Input[_builtins.str] node_type: DataflowGraph node types.
               Expected value is 'Source'.
        :param pulumi.Input['DataflowGraphSourceSettingsArgs'] source_settings: Source configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_type", 'Source')
        pulumi.set(__self__, "source_settings", source_settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> pulumi.Input[_builtins.str]:
        """
        DataflowGraph node types.
        Expected value is 'Source'.
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_type", value)

    @_builtins.property
    @pulumi.getter(name="sourceSettings")
    def source_settings(self) -> pulumi.Input['DataflowGraphSourceSettingsArgs']:
        """
        Source configuration.
        """
        return pulumi.get(self, "source_settings")

    @source_settings.setter
    def source_settings(self, value: pulumi.Input['DataflowGraphSourceSettingsArgs']):
        pulumi.set(self, "source_settings", value)


if not MYPY:
    class DataflowGraphSourceSettingsArgsDict(TypedDict):
        """
        DataflowGraph source node settings.
        """
        data_sources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of data sources.
        """
        endpoint_ref: pulumi.Input[_builtins.str]
        """
        The endpoint reference for the source.
        """
        asset_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
elif False:
    DataflowGraphSourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowGraphSourceSettingsArgs:
    def __init__(__self__, *,
                 data_sources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 endpoint_ref: pulumi.Input[_builtins.str],
                 asset_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        DataflowGraph source node settings.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_sources: List of data sources.
        :param pulumi.Input[_builtins.str] endpoint_ref: The endpoint reference for the source.
        :param pulumi.Input[_builtins.str] asset_ref: Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)
        if asset_ref is not None:
            pulumi.set(__self__, "asset_ref", asset_ref)

    @_builtins.property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of data sources.
        """
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "data_sources", value)

    @_builtins.property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The endpoint reference for the source.
        """
        return pulumi.get(self, "endpoint_ref")

    @endpoint_ref.setter
    def endpoint_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint_ref", value)

    @_builtins.property
    @pulumi.getter(name="assetRef")
    def asset_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        return pulumi.get(self, "asset_ref")

    @asset_ref.setter
    def asset_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "asset_ref", value)


if not MYPY:
    class DataflowOperationArgsDict(TypedDict):
        """
        Dataflow Operation properties. NOTE - One only method is allowed to be used for one entry.
        """
        operation_type: pulumi.Input[Union[_builtins.str, 'OperationType']]
        """
        Type of operation.
        """
        built_in_transformation_settings: NotRequired[pulumi.Input['DataflowBuiltInTransformationSettingsArgsDict']]
        """
        Built In Transformation configuration.
        """
        destination_settings: NotRequired[pulumi.Input['DataflowDestinationOperationSettingsArgsDict']]
        """
        Destination configuration.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional user provided name of the transformation.
        """
        source_settings: NotRequired[pulumi.Input['DataflowSourceOperationSettingsArgsDict']]
        """
        Source configuration.
        """
elif False:
    DataflowOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowOperationArgs:
    def __init__(__self__, *,
                 operation_type: pulumi.Input[Union[_builtins.str, 'OperationType']],
                 built_in_transformation_settings: Optional[pulumi.Input['DataflowBuiltInTransformationSettingsArgs']] = None,
                 destination_settings: Optional[pulumi.Input['DataflowDestinationOperationSettingsArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 source_settings: Optional[pulumi.Input['DataflowSourceOperationSettingsArgs']] = None):
        """
        Dataflow Operation properties. NOTE - One only method is allowed to be used for one entry.
        :param pulumi.Input[Union[_builtins.str, 'OperationType']] operation_type: Type of operation.
        :param pulumi.Input['DataflowBuiltInTransformationSettingsArgs'] built_in_transformation_settings: Built In Transformation configuration.
        :param pulumi.Input['DataflowDestinationOperationSettingsArgs'] destination_settings: Destination configuration.
        :param pulumi.Input[_builtins.str] name: Optional user provided name of the transformation.
        :param pulumi.Input['DataflowSourceOperationSettingsArgs'] source_settings: Source configuration.
        """
        pulumi.set(__self__, "operation_type", operation_type)
        if built_in_transformation_settings is not None:
            pulumi.set(__self__, "built_in_transformation_settings", built_in_transformation_settings)
        if destination_settings is not None:
            pulumi.set(__self__, "destination_settings", destination_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_settings is not None:
            pulumi.set(__self__, "source_settings", source_settings)

    @_builtins.property
    @pulumi.getter(name="operationType")
    def operation_type(self) -> pulumi.Input[Union[_builtins.str, 'OperationType']]:
        """
        Type of operation.
        """
        return pulumi.get(self, "operation_type")

    @operation_type.setter
    def operation_type(self, value: pulumi.Input[Union[_builtins.str, 'OperationType']]):
        pulumi.set(self, "operation_type", value)

    @_builtins.property
    @pulumi.getter(name="builtInTransformationSettings")
    def built_in_transformation_settings(self) -> Optional[pulumi.Input['DataflowBuiltInTransformationSettingsArgs']]:
        """
        Built In Transformation configuration.
        """
        return pulumi.get(self, "built_in_transformation_settings")

    @built_in_transformation_settings.setter
    def built_in_transformation_settings(self, value: Optional[pulumi.Input['DataflowBuiltInTransformationSettingsArgs']]):
        pulumi.set(self, "built_in_transformation_settings", value)

    @_builtins.property
    @pulumi.getter(name="destinationSettings")
    def destination_settings(self) -> Optional[pulumi.Input['DataflowDestinationOperationSettingsArgs']]:
        """
        Destination configuration.
        """
        return pulumi.get(self, "destination_settings")

    @destination_settings.setter
    def destination_settings(self, value: Optional[pulumi.Input['DataflowDestinationOperationSettingsArgs']]):
        pulumi.set(self, "destination_settings", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional user provided name of the transformation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sourceSettings")
    def source_settings(self) -> Optional[pulumi.Input['DataflowSourceOperationSettingsArgs']]:
        """
        Source configuration.
        """
        return pulumi.get(self, "source_settings")

    @source_settings.setter
    def source_settings(self, value: Optional[pulumi.Input['DataflowSourceOperationSettingsArgs']]):
        pulumi.set(self, "source_settings", value)


if not MYPY:
    class DataflowProfilePropertiesArgsDict(TypedDict):
        """
        DataflowProfile Resource properties
        """
        diagnostics: NotRequired[pulumi.Input['ProfileDiagnosticsArgsDict']]
        """
        Spec defines the desired identities of NBC diagnostics settings.
        """
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
elif False:
    DataflowProfilePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowProfilePropertiesArgs:
    def __init__(__self__, *,
                 diagnostics: Optional[pulumi.Input['ProfileDiagnosticsArgs']] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        DataflowProfile Resource properties
        :param pulumi.Input['ProfileDiagnosticsArgs'] diagnostics: Spec defines the desired identities of NBC diagnostics settings.
        :param pulumi.Input[_builtins.int] instance_count: To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if instance_count is None:
            instance_count = 1
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)

    @_builtins.property
    @pulumi.getter
    def diagnostics(self) -> Optional[pulumi.Input['ProfileDiagnosticsArgs']]:
        """
        Spec defines the desired identities of NBC diagnostics settings.
        """
        return pulumi.get(self, "diagnostics")

    @diagnostics.setter
    def diagnostics(self, value: Optional[pulumi.Input['ProfileDiagnosticsArgs']]):
        pulumi.set(self, "diagnostics", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)


if not MYPY:
    class DataflowPropertiesArgsDict(TypedDict):
        """
        Dataflow Resource properties
        """
        operations: pulumi.Input[Sequence[pulumi.Input['DataflowOperationArgsDict']]]
        """
        List of operations including source and destination references as well as transformation.
        """
        mode: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        Mode for Dataflow. Optional; defaults to Enabled.
        """
elif False:
    DataflowPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowPropertiesArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input['DataflowOperationArgs']]],
                 mode: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None):
        """
        Dataflow Resource properties
        :param pulumi.Input[Sequence[pulumi.Input['DataflowOperationArgs']]] operations: List of operations including source and destination references as well as transformation.
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] mode: Mode for Dataflow. Optional; defaults to Enabled.
        """
        pulumi.set(__self__, "operations", operations)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input['DataflowOperationArgs']]]:
        """
        List of operations including source and destination references as well as transformation.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input['DataflowOperationArgs']]]):
        pulumi.set(self, "operations", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        Mode for Dataflow. Optional; defaults to Enabled.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class DataflowSourceOperationSettingsArgsDict(TypedDict):
        """
        Dataflow Source Operation properties
        """
        data_sources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        """
        endpoint_ref: pulumi.Input[_builtins.str]
        """
        Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        """
        asset_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        schema_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        """
        serialization_format: NotRequired[pulumi.Input[Union[_builtins.str, 'SourceSerializationFormat']]]
        """
        Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
elif False:
    DataflowSourceOperationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataflowSourceOperationSettingsArgs:
    def __init__(__self__, *,
                 data_sources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 endpoint_ref: pulumi.Input[_builtins.str],
                 asset_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 serialization_format: Optional[pulumi.Input[Union[_builtins.str, 'SourceSerializationFormat']]] = None):
        """
        Dataflow Source Operation properties
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_sources: List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        :param pulumi.Input[_builtins.str] endpoint_ref: Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        :param pulumi.Input[_builtins.str] asset_ref: Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        :param pulumi.Input[_builtins.str] schema_ref: Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        :param pulumi.Input[Union[_builtins.str, 'SourceSerializationFormat']] serialization_format: Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)
        if asset_ref is not None:
            pulumi.set(__self__, "asset_ref", asset_ref)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is None:
            serialization_format = 'Json'
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @_builtins.property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        """
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "data_sources", value)

    @_builtins.property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> pulumi.Input[_builtins.str]:
        """
        Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        """
        return pulumi.get(self, "endpoint_ref")

    @endpoint_ref.setter
    def endpoint_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint_ref", value)

    @_builtins.property
    @pulumi.getter(name="assetRef")
    def asset_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        return pulumi.get(self, "asset_ref")

    @asset_ref.setter
    def asset_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "asset_ref", value)

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        """
        return pulumi.get(self, "schema_ref")

    @schema_ref.setter
    def schema_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_ref", value)

    @_builtins.property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[pulumi.Input[Union[_builtins.str, 'SourceSerializationFormat']]]:
        """
        Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
        return pulumi.get(self, "serialization_format")

    @serialization_format.setter
    def serialization_format(self, value: Optional[pulumi.Input[Union[_builtins.str, 'SourceSerializationFormat']]]):
        pulumi.set(self, "serialization_format", value)


if not MYPY:
    class DiagnosticsLogsArgsDict(TypedDict):
        """
        Diagnostic Log properties
        """
        level: NotRequired[pulumi.Input[_builtins.str]]
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
elif False:
    DiagnosticsLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosticsLogsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Diagnostic Log properties
        :param pulumi.Input[_builtins.str] level: The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        if level is None:
            level = 'info'
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class DiskBackedMessageBufferArgsDict(TypedDict):
        """
        DiskBackedMessageBuffer properties
        """
        max_size: pulumi.Input[_builtins.str]
        """
        The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        """
        ephemeral_volume_claim_spec: NotRequired[pulumi.Input['VolumeClaimSpecArgsDict']]
        """
        Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        """
        persistent_volume_claim_spec: NotRequired[pulumi.Input['VolumeClaimSpecArgsDict']]
        """
        Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
elif False:
    DiskBackedMessageBufferArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiskBackedMessageBufferArgs:
    def __init__(__self__, *,
                 max_size: pulumi.Input[_builtins.str],
                 ephemeral_volume_claim_spec: Optional[pulumi.Input['VolumeClaimSpecArgs']] = None,
                 persistent_volume_claim_spec: Optional[pulumi.Input['VolumeClaimSpecArgs']] = None):
        """
        DiskBackedMessageBuffer properties
        :param pulumi.Input[_builtins.str] max_size: The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        :param pulumi.Input['VolumeClaimSpecArgs'] ephemeral_volume_claim_spec: Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        :param pulumi.Input['VolumeClaimSpecArgs'] persistent_volume_claim_spec: Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        pulumi.set(__self__, "max_size", max_size)
        if ephemeral_volume_claim_spec is not None:
            pulumi.set(__self__, "ephemeral_volume_claim_spec", ephemeral_volume_claim_spec)
        if persistent_volume_claim_spec is not None:
            pulumi.set(__self__, "persistent_volume_claim_spec", persistent_volume_claim_spec)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> pulumi.Input[_builtins.str]:
        """
        The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="ephemeralVolumeClaimSpec")
    def ephemeral_volume_claim_spec(self) -> Optional[pulumi.Input['VolumeClaimSpecArgs']]:
        """
        Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        """
        return pulumi.get(self, "ephemeral_volume_claim_spec")

    @ephemeral_volume_claim_spec.setter
    def ephemeral_volume_claim_spec(self, value: Optional[pulumi.Input['VolumeClaimSpecArgs']]):
        pulumi.set(self, "ephemeral_volume_claim_spec", value)

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaimSpec")
    def persistent_volume_claim_spec(self) -> Optional[pulumi.Input['VolumeClaimSpecArgs']]:
        """
        Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        return pulumi.get(self, "persistent_volume_claim_spec")

    @persistent_volume_claim_spec.setter
    def persistent_volume_claim_spec(self, value: Optional[pulumi.Input['VolumeClaimSpecArgs']]):
        pulumi.set(self, "persistent_volume_claim_spec", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        Extended location is an extension of Azure locations. They provide a way to use their Azure ARC enabled Kubernetes clusters as target locations for deploying Azure services instances.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the extended location.
        """
        type: pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']]
        """
        Type of ExtendedLocation.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']]):
        """
        Extended location is an extension of Azure locations. They provide a way to use their Azure ARC enabled Kubernetes clusters as target locations for deploying Azure services instances.
        :param pulumi.Input[_builtins.str] name: The name of the extended location.
        :param pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']] type: Type of ExtendedLocation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']]:
        """
        Type of ExtendedLocation.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ExtendedLocationType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FrontendArgsDict(TypedDict):
        """
        The desired properties of the frontend instances of the Broker
        """
        replicas: pulumi.Input[_builtins.int]
        """
        The desired number of frontend instances (pods).
        """
        workers: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of logical frontend workers per instance (pod).
        """
elif False:
    FrontendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontendArgs:
    def __init__(__self__, *,
                 replicas: pulumi.Input[_builtins.int],
                 workers: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The desired properties of the frontend instances of the Broker
        :param pulumi.Input[_builtins.int] replicas: The desired number of frontend instances (pods).
        :param pulumi.Input[_builtins.int] workers: Number of logical frontend workers per instance (pod).
        """
        pulumi.set(__self__, "replicas", replicas)
        if workers is None:
            workers = 2
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> pulumi.Input[_builtins.int]:
        """
        The desired number of frontend instances (pods).
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "replicas", value)

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of logical frontend workers per instance (pod).
        """
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "workers", value)


if not MYPY:
    class GenerateResourceLimitsArgsDict(TypedDict):
        """
        GenerateResourceLimits properties
        """
        cpu: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        The toggle to enable/disable cpu resource limits.
        """
elif False:
    GenerateResourceLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenerateResourceLimitsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None):
        """
        GenerateResourceLimits properties
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] cpu: The toggle to enable/disable cpu resource limits.
        """
        if cpu is None:
            cpu = 'Enabled'
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        The toggle to enable/disable cpu resource limits.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "cpu", value)


if not MYPY:
    class InstancePropertiesArgsDict(TypedDict):
        """
        The properties of the Instance resource.
        """
        schema_registry_ref: pulumi.Input['SchemaRegistryRefArgsDict']
        """
        The reference to the Schema Registry for this AIO Instance.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Detailed description of the Instance.
        """
elif False:
    InstancePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePropertiesArgs:
    def __init__(__self__, *,
                 schema_registry_ref: pulumi.Input['SchemaRegistryRefArgs'],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The properties of the Instance resource.
        :param pulumi.Input['SchemaRegistryRefArgs'] schema_registry_ref: The reference to the Schema Registry for this AIO Instance.
        :param pulumi.Input[_builtins.str] description: Detailed description of the Instance.
        """
        pulumi.set(__self__, "schema_registry_ref", schema_registry_ref)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryRef")
    def schema_registry_ref(self) -> pulumi.Input['SchemaRegistryRefArgs']:
        """
        The reference to the Schema Registry for this AIO Instance.
        """
        return pulumi.get(self, "schema_registry_ref")

    @schema_registry_ref.setter
    def schema_registry_ref(self, value: pulumi.Input['SchemaRegistryRefArgs']):
        pulumi.set(self, "schema_registry_ref", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Detailed description of the Instance.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class KubernetesReferenceArgsDict(TypedDict):
        """
        Kubernetes reference
        """
        kind: pulumi.Input[_builtins.str]
        """
        Kind is the type of resource being referenced
        """
        name: pulumi.Input[_builtins.str]
        """
        Name is the name of resource being referenced
        """
        api_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
elif False:
    KubernetesReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesReferenceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 api_group: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Kubernetes reference
        :param pulumi.Input[_builtins.str] kind: Kind is the type of resource being referenced
        :param pulumi.Input[_builtins.str] name: Name is the name of resource being referenced
        :param pulumi.Input[_builtins.str] api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        :param pulumi.Input[_builtins.str] namespace: Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")

    @api_group.setter
    def api_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_group", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ListenerPortArgsDict(TypedDict):
        """
        Defines a TCP port on which a `BrokerListener` listens.
        """
        port: pulumi.Input[_builtins.int]
        """
        TCP port for accepting client connections.
        """
        authentication_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference to client authentication settings. Omit to disable authentication.
        """
        authorization_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference to client authorization settings. Omit to disable authorization.
        """
        node_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        """
        protocol: NotRequired[pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']]]
        """
        Protocol to use for client connections.
        """
        tls: NotRequired[pulumi.Input['TlsCertMethodArgsDict']]
        """
        TLS server certificate settings for this port. Omit to disable TLS.
        """
elif False:
    ListenerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerPortArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 authentication_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 authorization_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 node_port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']]] = None,
                 tls: Optional[pulumi.Input['TlsCertMethodArgs']] = None):
        """
        Defines a TCP port on which a `BrokerListener` listens.
        :param pulumi.Input[_builtins.int] port: TCP port for accepting client connections.
        :param pulumi.Input[_builtins.str] authentication_ref: Reference to client authentication settings. Omit to disable authentication.
        :param pulumi.Input[_builtins.str] authorization_ref: Reference to client authorization settings. Omit to disable authorization.
        :param pulumi.Input[_builtins.int] node_port: Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        :param pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']] protocol: Protocol to use for client connections.
        :param pulumi.Input['TlsCertMethodArgs'] tls: TLS server certificate settings for this port. Omit to disable TLS.
        """
        pulumi.set(__self__, "port", port)
        if authentication_ref is not None:
            pulumi.set(__self__, "authentication_ref", authentication_ref)
        if authorization_ref is not None:
            pulumi.set(__self__, "authorization_ref", authorization_ref)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)
        if protocol is None:
            protocol = 'Mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        TCP port for accepting client connections.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="authenticationRef")
    def authentication_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to client authentication settings. Omit to disable authentication.
        """
        return pulumi.get(self, "authentication_ref")

    @authentication_ref.setter
    def authentication_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_ref", value)

    @_builtins.property
    @pulumi.getter(name="authorizationRef")
    def authorization_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to client authorization settings. Omit to disable authorization.
        """
        return pulumi.get(self, "authorization_ref")

    @authorization_ref.setter
    def authorization_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_ref", value)

    @_builtins.property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        """
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "node_port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']]]:
        """
        Protocol to use for client connections.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[_builtins.str, 'BrokerProtocolType']]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['TlsCertMethodArgs']]:
        """
        TLS server certificate settings for this port. Omit to disable TLS.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['TlsCertMethodArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class LocalKubernetesReferenceArgsDict(TypedDict):
        """
        Kubernetes reference
        """
        kind: pulumi.Input[_builtins.str]
        """
        Kind is the type of resource being referenced
        """
        name: pulumi.Input[_builtins.str]
        """
        Name is the name of resource being referenced
        """
        api_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
elif False:
    LocalKubernetesReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocalKubernetesReferenceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 api_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Kubernetes reference
        :param pulumi.Input[_builtins.str] kind: Kind is the type of resource being referenced
        :param pulumi.Input[_builtins.str] name: Name is the name of resource being referenced
        :param pulumi.Input[_builtins.str] api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")

    @api_group.setter
    def api_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_group", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[_builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MetricsArgsDict(TypedDict):
        """
        Diagnostic Metrics properties
        """
        prometheus_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The prometheus port to expose the metrics.
        """
elif False:
    MetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsArgs:
    def __init__(__self__, *,
                 prometheus_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Diagnostic Metrics properties
        :param pulumi.Input[_builtins.int] prometheus_port: The prometheus port to expose the metrics.
        """
        if prometheus_port is None:
            prometheus_port = 9600
        if prometheus_port is not None:
            pulumi.set(__self__, "prometheus_port", prometheus_port)

    @_builtins.property
    @pulumi.getter(name="prometheusPort")
    def prometheus_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The prometheus port to expose the metrics.
        """
        return pulumi.get(self, "prometheus_port")

    @prometheus_port.setter
    def prometheus_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "prometheus_port", value)


if not MYPY:
    class PrincipalDefinitionArgsDict(TypedDict):
        """
        PrincipalDefinition properties of Rule
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        """
        A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        """
        client_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        """
        usernames: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
elif False:
    PrincipalDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrincipalDefinitionArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 client_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 usernames: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        PrincipalDefinition properties of Rule
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] attributes: A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] client_ids: A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] usernames: A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if client_ids is not None:
            pulumi.set(__self__, "client_ids", client_ids)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        """
        A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        """
        return pulumi.get(self, "client_ids")

    @client_ids.setter
    def client_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "client_ids", value)

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "usernames", value)


if not MYPY:
    class ProfileDiagnosticsArgsDict(TypedDict):
        """
        DataflowProfile Diagnostics properties
        """
        logs: NotRequired[pulumi.Input['DiagnosticsLogsArgsDict']]
        """
        Diagnostic log settings for the resource.
        """
        metrics: NotRequired[pulumi.Input['MetricsArgsDict']]
        """
        The metrics settings for the resource.
        """
elif False:
    ProfileDiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileDiagnosticsArgs:
    def __init__(__self__, *,
                 logs: Optional[pulumi.Input['DiagnosticsLogsArgs']] = None,
                 metrics: Optional[pulumi.Input['MetricsArgs']] = None):
        """
        DataflowProfile Diagnostics properties
        :param pulumi.Input['DiagnosticsLogsArgs'] logs: Diagnostic log settings for the resource.
        :param pulumi.Input['MetricsArgs'] metrics: The metrics settings for the resource.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input['DiagnosticsLogsArgs']]:
        """
        Diagnostic log settings for the resource.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input['DiagnosticsLogsArgs']]):
        pulumi.set(self, "logs", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['MetricsArgs']]:
        """
        The metrics settings for the resource.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['MetricsArgs']]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class RegistryEndpointAnonymousAuthenticationArgsDict(TypedDict):
        """
        Anonymous authentication
        """
        anonymous_settings: Any
        """
        Anonymous authentication properties
        """
        method: pulumi.Input[_builtins.str]
        """
        The authentication method.
        Expected value is 'Anonymous'.
        """
elif False:
    RegistryEndpointAnonymousAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointAnonymousAuthenticationArgs:
    def __init__(__self__, *,
                 anonymous_settings: Any,
                 method: pulumi.Input[_builtins.str]):
        """
        Anonymous authentication
        :param Any anonymous_settings: Anonymous authentication properties
        :param pulumi.Input[_builtins.str] method: The authentication method.
               Expected value is 'Anonymous'.
        """
        pulumi.set(__self__, "anonymous_settings", anonymous_settings)
        pulumi.set(__self__, "method", 'Anonymous')

    @_builtins.property
    @pulumi.getter(name="anonymousSettings")
    def anonymous_settings(self) -> Any:
        """
        Anonymous authentication properties
        """
        return pulumi.get(self, "anonymous_settings")

    @anonymous_settings.setter
    def anonymous_settings(self, value: Any):
        pulumi.set(self, "anonymous_settings", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication method.
        Expected value is 'Anonymous'.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "method", value)


if not MYPY:
    class RegistryEndpointArtifactPullSecretAuthenticationArgsDict(TypedDict):
        """
        Artifact Pull Secret authentication
        """
        artifact_pull_secret_settings: pulumi.Input['RegistryEndpointArtifactPullSecretSettingsArgsDict']
        """
        Artifact Pull Secret authentication properties
        """
        method: pulumi.Input[_builtins.str]
        """
        The authentication method.
        Expected value is 'ArtifactPullSecret'.
        """
elif False:
    RegistryEndpointArtifactPullSecretAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointArtifactPullSecretAuthenticationArgs:
    def __init__(__self__, *,
                 artifact_pull_secret_settings: pulumi.Input['RegistryEndpointArtifactPullSecretSettingsArgs'],
                 method: pulumi.Input[_builtins.str]):
        """
        Artifact Pull Secret authentication
        :param pulumi.Input['RegistryEndpointArtifactPullSecretSettingsArgs'] artifact_pull_secret_settings: Artifact Pull Secret authentication properties
        :param pulumi.Input[_builtins.str] method: The authentication method.
               Expected value is 'ArtifactPullSecret'.
        """
        pulumi.set(__self__, "artifact_pull_secret_settings", artifact_pull_secret_settings)
        pulumi.set(__self__, "method", 'ArtifactPullSecret')

    @_builtins.property
    @pulumi.getter(name="artifactPullSecretSettings")
    def artifact_pull_secret_settings(self) -> pulumi.Input['RegistryEndpointArtifactPullSecretSettingsArgs']:
        """
        Artifact Pull Secret authentication properties
        """
        return pulumi.get(self, "artifact_pull_secret_settings")

    @artifact_pull_secret_settings.setter
    def artifact_pull_secret_settings(self, value: pulumi.Input['RegistryEndpointArtifactPullSecretSettingsArgs']):
        pulumi.set(self, "artifact_pull_secret_settings", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication method.
        Expected value is 'ArtifactPullSecret'.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "method", value)


if not MYPY:
    class RegistryEndpointArtifactPullSecretSettingsArgsDict(TypedDict):
        """
        RegistryEndpoint Artifact Pull Secret authentication properties
        """
        secret_ref: pulumi.Input[_builtins.str]
        """
        The name of the kubernetes secret that contains the artifact pull secret.
        """
elif False:
    RegistryEndpointArtifactPullSecretSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointArtifactPullSecretSettingsArgs:
    def __init__(__self__, *,
                 secret_ref: pulumi.Input[_builtins.str]):
        """
        RegistryEndpoint Artifact Pull Secret authentication properties
        :param pulumi.Input[_builtins.str] secret_ref: The name of the kubernetes secret that contains the artifact pull secret.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the kubernetes secret that contains the artifact pull secret.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class RegistryEndpointPropertiesArgsDict(TypedDict):
        """
        RegistryEndpoint properties
        """
        authentication: pulumi.Input[Union['RegistryEndpointAnonymousAuthenticationArgsDict', 'RegistryEndpointArtifactPullSecretAuthenticationArgsDict', 'RegistryEndpointSystemAssignedIdentityAuthenticationArgsDict', 'RegistryEndpointUserAssignedIdentityAuthenticationArgsDict']]
        """
        The authentication settings for the Azure Container Registry.
        """
        host: pulumi.Input[_builtins.str]
        """
        The Container Registry endpoint hostname.
        """
        trust_settings: NotRequired[pulumi.Input['RegistryEndpointTrustedSettingsArgsDict']]
        """
        Trust settings for the registry endpoint
        """
elif False:
    RegistryEndpointPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointPropertiesArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input[Union['RegistryEndpointAnonymousAuthenticationArgs', 'RegistryEndpointArtifactPullSecretAuthenticationArgs', 'RegistryEndpointSystemAssignedIdentityAuthenticationArgs', 'RegistryEndpointUserAssignedIdentityAuthenticationArgs']],
                 host: pulumi.Input[_builtins.str],
                 trust_settings: Optional[pulumi.Input['RegistryEndpointTrustedSettingsArgs']] = None):
        """
        RegistryEndpoint properties
        :param pulumi.Input[Union['RegistryEndpointAnonymousAuthenticationArgs', 'RegistryEndpointArtifactPullSecretAuthenticationArgs', 'RegistryEndpointSystemAssignedIdentityAuthenticationArgs', 'RegistryEndpointUserAssignedIdentityAuthenticationArgs']] authentication: The authentication settings for the Azure Container Registry.
        :param pulumi.Input[_builtins.str] host: The Container Registry endpoint hostname.
        :param pulumi.Input['RegistryEndpointTrustedSettingsArgs'] trust_settings: Trust settings for the registry endpoint
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        if trust_settings is not None:
            pulumi.set(__self__, "trust_settings", trust_settings)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input[Union['RegistryEndpointAnonymousAuthenticationArgs', 'RegistryEndpointArtifactPullSecretAuthenticationArgs', 'RegistryEndpointSystemAssignedIdentityAuthenticationArgs', 'RegistryEndpointUserAssignedIdentityAuthenticationArgs']]:
        """
        The authentication settings for the Azure Container Registry.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input[Union['RegistryEndpointAnonymousAuthenticationArgs', 'RegistryEndpointArtifactPullSecretAuthenticationArgs', 'RegistryEndpointSystemAssignedIdentityAuthenticationArgs', 'RegistryEndpointUserAssignedIdentityAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        The Container Registry endpoint hostname.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="trustSettings")
    def trust_settings(self) -> Optional[pulumi.Input['RegistryEndpointTrustedSettingsArgs']]:
        """
        Trust settings for the registry endpoint
        """
        return pulumi.get(self, "trust_settings")

    @trust_settings.setter
    def trust_settings(self, value: Optional[pulumi.Input['RegistryEndpointTrustedSettingsArgs']]):
        pulumi.set(self, "trust_settings", value)


if not MYPY:
    class RegistryEndpointSystemAssignedIdentityAuthenticationArgsDict(TypedDict):
        """
        System assigned identity authentication
        """
        method: pulumi.Input[_builtins.str]
        """
        The authentication method.
        Expected value is 'SystemAssignedManagedIdentity'.
        """
        system_assigned_managed_identity_settings: pulumi.Input['RegistryEndpointSystemAssignedManagedIdentitySettingsArgsDict']
        """
        System assigned managed identity properties
        """
elif False:
    RegistryEndpointSystemAssignedIdentityAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointSystemAssignedIdentityAuthenticationArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[_builtins.str],
                 system_assigned_managed_identity_settings: pulumi.Input['RegistryEndpointSystemAssignedManagedIdentitySettingsArgs']):
        """
        System assigned identity authentication
        :param pulumi.Input[_builtins.str] method: The authentication method.
               Expected value is 'SystemAssignedManagedIdentity'.
        :param pulumi.Input['RegistryEndpointSystemAssignedManagedIdentitySettingsArgs'] system_assigned_managed_identity_settings: System assigned managed identity properties
        """
        pulumi.set(__self__, "method", 'SystemAssignedManagedIdentity')
        pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication method.
        Expected value is 'SystemAssignedManagedIdentity'.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> pulumi.Input['RegistryEndpointSystemAssignedManagedIdentitySettingsArgs']:
        """
        System assigned managed identity properties
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @system_assigned_managed_identity_settings.setter
    def system_assigned_managed_identity_settings(self, value: pulumi.Input['RegistryEndpointSystemAssignedManagedIdentitySettingsArgs']):
        pulumi.set(self, "system_assigned_managed_identity_settings", value)


if not MYPY:
    class RegistryEndpointSystemAssignedManagedIdentitySettingsArgsDict(TypedDict):
        """
        System assigned managed identity properties
        """
        audience: NotRequired[pulumi.Input[_builtins.str]]
        """
        Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
elif False:
    RegistryEndpointSystemAssignedManagedIdentitySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointSystemAssignedManagedIdentitySettingsArgs:
    def __init__(__self__, *,
                 audience: Optional[pulumi.Input[_builtins.str]] = None):
        """
        System assigned managed identity properties
        :param pulumi.Input[_builtins.str] audience: Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audience", value)


if not MYPY:
    class RegistryEndpointTrustedSettingsArgsDict(TypedDict):
        """
        RegistryEndpointTrustedSettings properties
        """
        trusted_signing_keys: pulumi.Input[Union['RegistryEndpointTrustedSigningKeyConfigMapArgsDict', 'RegistryEndpointTrustedSigningKeySecretArgsDict']]
        """
        The trust properties for the registry endpoint.
        """
elif False:
    RegistryEndpointTrustedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointTrustedSettingsArgs:
    def __init__(__self__, *,
                 trusted_signing_keys: pulumi.Input[Union['RegistryEndpointTrustedSigningKeyConfigMapArgs', 'RegistryEndpointTrustedSigningKeySecretArgs']]):
        """
        RegistryEndpointTrustedSettings properties
        :param pulumi.Input[Union['RegistryEndpointTrustedSigningKeyConfigMapArgs', 'RegistryEndpointTrustedSigningKeySecretArgs']] trusted_signing_keys: The trust properties for the registry endpoint.
        """
        pulumi.set(__self__, "trusted_signing_keys", trusted_signing_keys)

    @_builtins.property
    @pulumi.getter(name="trustedSigningKeys")
    def trusted_signing_keys(self) -> pulumi.Input[Union['RegistryEndpointTrustedSigningKeyConfigMapArgs', 'RegistryEndpointTrustedSigningKeySecretArgs']]:
        """
        The trust properties for the registry endpoint.
        """
        return pulumi.get(self, "trusted_signing_keys")

    @trusted_signing_keys.setter
    def trusted_signing_keys(self, value: pulumi.Input[Union['RegistryEndpointTrustedSigningKeyConfigMapArgs', 'RegistryEndpointTrustedSigningKeySecretArgs']]):
        pulumi.set(self, "trusted_signing_keys", value)


if not MYPY:
    class RegistryEndpointTrustedSigningKeyConfigMapArgsDict(TypedDict):
        """
        Settings for RegistryEndpoint trust provided through a configmap.
        """
        config_map_ref: pulumi.Input[_builtins.str]
        """
        The name of the configmap.
        """
        type: pulumi.Input[_builtins.str]
        """
        RegistryEndpointTrustedSigningKeyType values
        Expected value is 'ConfigMap'.
        """
elif False:
    RegistryEndpointTrustedSigningKeyConfigMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointTrustedSigningKeyConfigMapArgs:
    def __init__(__self__, *,
                 config_map_ref: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        Settings for RegistryEndpoint trust provided through a configmap.
        :param pulumi.Input[_builtins.str] config_map_ref: The name of the configmap.
        :param pulumi.Input[_builtins.str] type: RegistryEndpointTrustedSigningKeyType values
               Expected value is 'ConfigMap'.
        """
        pulumi.set(__self__, "config_map_ref", config_map_ref)
        pulumi.set(__self__, "type", 'ConfigMap')

    @_builtins.property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the configmap.
        """
        return pulumi.get(self, "config_map_ref")

    @config_map_ref.setter
    def config_map_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "config_map_ref", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        RegistryEndpointTrustedSigningKeyType values
        Expected value is 'ConfigMap'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RegistryEndpointTrustedSigningKeySecretArgsDict(TypedDict):
        """
        Settings for RegistryEndpoint trust provided through a secret.
        """
        secret_ref: pulumi.Input[_builtins.str]
        """
        The name of the secret.
        """
        type: pulumi.Input[_builtins.str]
        """
        RegistryEndpointTrustedSigningKeyType values
        Expected value is 'Secret'.
        """
elif False:
    RegistryEndpointTrustedSigningKeySecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointTrustedSigningKeySecretArgs:
    def __init__(__self__, *,
                 secret_ref: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        Settings for RegistryEndpoint trust provided through a secret.
        :param pulumi.Input[_builtins.str] secret_ref: The name of the secret.
        :param pulumi.Input[_builtins.str] type: RegistryEndpointTrustedSigningKeyType values
               Expected value is 'Secret'.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)
        pulumi.set(__self__, "type", 'Secret')

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the secret.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_ref", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        RegistryEndpointTrustedSigningKeyType values
        Expected value is 'Secret'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RegistryEndpointUserAssignedIdentityAuthenticationArgsDict(TypedDict):
        """
        User assigned identity authentication
        """
        method: pulumi.Input[_builtins.str]
        """
        The authentication method.
        Expected value is 'UserAssignedManagedIdentity'.
        """
        user_assigned_managed_identity_settings: pulumi.Input['RegistryEndpointUserAssignedManagedIdentitySettingsArgsDict']
        """
        User assigned managed identity properties
        """
elif False:
    RegistryEndpointUserAssignedIdentityAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointUserAssignedIdentityAuthenticationArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[_builtins.str],
                 user_assigned_managed_identity_settings: pulumi.Input['RegistryEndpointUserAssignedManagedIdentitySettingsArgs']):
        """
        User assigned identity authentication
        :param pulumi.Input[_builtins.str] method: The authentication method.
               Expected value is 'UserAssignedManagedIdentity'.
        :param pulumi.Input['RegistryEndpointUserAssignedManagedIdentitySettingsArgs'] user_assigned_managed_identity_settings: User assigned managed identity properties
        """
        pulumi.set(__self__, "method", 'UserAssignedManagedIdentity')
        pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[_builtins.str]:
        """
        The authentication method.
        Expected value is 'UserAssignedManagedIdentity'.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> pulumi.Input['RegistryEndpointUserAssignedManagedIdentitySettingsArgs']:
        """
        User assigned managed identity properties
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @user_assigned_managed_identity_settings.setter
    def user_assigned_managed_identity_settings(self, value: pulumi.Input['RegistryEndpointUserAssignedManagedIdentitySettingsArgs']):
        pulumi.set(self, "user_assigned_managed_identity_settings", value)


if not MYPY:
    class RegistryEndpointUserAssignedManagedIdentitySettingsArgsDict(TypedDict):
        """
        User assigned managed identity properties
        """
        client_id: pulumi.Input[_builtins.str]
        """
        Client ID for the user-assigned managed identity.
        """
        tenant_id: pulumi.Input[_builtins.str]
        """
        Tenant ID.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
elif False:
    RegistryEndpointUserAssignedManagedIdentitySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryEndpointUserAssignedManagedIdentitySettingsArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 tenant_id: pulumi.Input[_builtins.str],
                 scope: Optional[pulumi.Input[_builtins.str]] = None):
        """
        User assigned managed identity properties
        :param pulumi.Input[_builtins.str] client_id: Client ID for the user-assigned managed identity.
        :param pulumi.Input[_builtins.str] tenant_id: Tenant ID.
        :param pulumi.Input[_builtins.str] scope: Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        Client ID for the user-assigned managed identity.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[_builtins.str]:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_id", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class SanForCertArgsDict(TypedDict):
        """
        Subject Alternative Names (SANs) for certificate.
        """
        dns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        DNS SANs.
        """
        ip: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        IP address SANs.
        """
elif False:
    SanForCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SanForCertArgs:
    def __init__(__self__, *,
                 dns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 ip: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Subject Alternative Names (SANs) for certificate.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dns: DNS SANs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip: IP address SANs.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        DNS SANs.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "dns", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        IP address SANs.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class SchemaRegistryRefArgsDict(TypedDict):
        """
        The reference to the Schema Registry for this AIO Instance.
        """
        resource_id: pulumi.Input[_builtins.str]
        """
        The resource ID of the Schema Registry.
        """
elif False:
    SchemaRegistryRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaRegistryRefArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[_builtins.str]):
        """
        The reference to the Schema Registry for this AIO Instance.
        :param pulumi.Input[_builtins.str] resource_id: The resource ID of the Schema Registry.
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        The resource ID of the Schema Registry.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class SelfCheckArgsDict(TypedDict):
        """
        Broker Diagnostic Self check properties
        """
        interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The self check interval.
        """
        mode: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        The toggle to enable/disable self check.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The timeout for self check.
        """
elif False:
    SelfCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelfCheckArgs:
    def __init__(__self__, *,
                 interval_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Broker Diagnostic Self check properties
        :param pulumi.Input[_builtins.int] interval_seconds: The self check interval.
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] mode: The toggle to enable/disable self check.
        :param pulumi.Input[_builtins.int] timeout_seconds: The timeout for self check.
        """
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if timeout_seconds is None:
            timeout_seconds = 15
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The self check interval.
        """
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval_seconds", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        The toggle to enable/disable self check.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The timeout for self check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class SelfTracingArgsDict(TypedDict):
        """
        Diagnostic Self tracing properties
        """
        interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The self tracing interval.
        """
        mode: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        The toggle to enable/disable self tracing.
        """
elif False:
    SelfTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelfTracingArgs:
    def __init__(__self__, *,
                 interval_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None):
        """
        Diagnostic Self tracing properties
        :param pulumi.Input[_builtins.int] interval_seconds: The self tracing interval.
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] mode: The toggle to enable/disable self tracing.
        """
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The self tracing interval.
        """
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval_seconds", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        The toggle to enable/disable self tracing.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class StateStoreResourceRuleArgsDict(TypedDict):
        """
        State Store Resource Rule properties.
        """
        key_type: pulumi.Input[Union[_builtins.str, 'StateStoreResourceKeyTypes']]
        """
        Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        """
        keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        """
        method: pulumi.Input[Union[_builtins.str, 'StateStoreResourceDefinitionMethods']]
        """
        Give access for `Read`, `Write` and `ReadWrite` access level.
        """
elif False:
    StateStoreResourceRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StateStoreResourceRuleArgs:
    def __init__(__self__, *,
                 key_type: pulumi.Input[Union[_builtins.str, 'StateStoreResourceKeyTypes']],
                 keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 method: pulumi.Input[Union[_builtins.str, 'StateStoreResourceDefinitionMethods']]):
        """
        State Store Resource Rule properties.
        :param pulumi.Input[Union[_builtins.str, 'StateStoreResourceKeyTypes']] key_type: Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] keys: Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        :param pulumi.Input[Union[_builtins.str, 'StateStoreResourceDefinitionMethods']] method: Give access for `Read`, `Write` and `ReadWrite` access level.
        """
        pulumi.set(__self__, "key_type", key_type)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "method", method)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[Union[_builtins.str, 'StateStoreResourceKeyTypes']]:
        """
        Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[Union[_builtins.str, 'StateStoreResourceKeyTypes']]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "keys", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[_builtins.str, 'StateStoreResourceDefinitionMethods']]:
        """
        Give access for `Read`, `Write` and `ReadWrite` access level.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[_builtins.str, 'StateStoreResourceDefinitionMethods']]):
        pulumi.set(self, "method", value)


if not MYPY:
    class SubscriberQueueLimitArgsDict(TypedDict):
        """
        The settings of Subscriber Queue Limit.
        """
        length: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum length of the queue before messages start getting dropped.
        """
        strategy: NotRequired[pulumi.Input[Union[_builtins.str, 'SubscriberMessageDropStrategy']]]
        """
        The strategy to use for dropping messages from the queue.
        """
elif False:
    SubscriberQueueLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberQueueLimitArgs:
    def __init__(__self__, *,
                 length: Optional[pulumi.Input[_builtins.float]] = None,
                 strategy: Optional[pulumi.Input[Union[_builtins.str, 'SubscriberMessageDropStrategy']]] = None):
        """
        The settings of Subscriber Queue Limit.
        :param pulumi.Input[_builtins.float] length: The maximum length of the queue before messages start getting dropped.
        :param pulumi.Input[Union[_builtins.str, 'SubscriberMessageDropStrategy']] strategy: The strategy to use for dropping messages from the queue.
        """
        if length is not None:
            pulumi.set(__self__, "length", length)
        if strategy is None:
            strategy = 'None'
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum length of the queue before messages start getting dropped.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "length", value)

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[Union[_builtins.str, 'SubscriberMessageDropStrategy']]]:
        """
        The strategy to use for dropping messages from the queue.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[Union[_builtins.str, 'SubscriberMessageDropStrategy']]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class TlsCertMethodArgsDict(TypedDict):
        """
        Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
        """
        mode: pulumi.Input[Union[_builtins.str, 'TlsCertMethodMode']]
        """
        Mode of TLS server certificate management.
        """
        cert_manager_certificate_spec: NotRequired[pulumi.Input['CertManagerCertificateSpecArgsDict']]
        """
        Option 1 - Automatic TLS server certificate management with cert-manager.
        """
        manual: NotRequired[pulumi.Input['X509ManualCertificateArgsDict']]
        """
        Option 2 - Manual TLS server certificate management through a defined secret.
        """
elif False:
    TlsCertMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsCertMethodArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[Union[_builtins.str, 'TlsCertMethodMode']],
                 cert_manager_certificate_spec: Optional[pulumi.Input['CertManagerCertificateSpecArgs']] = None,
                 manual: Optional[pulumi.Input['X509ManualCertificateArgs']] = None):
        """
        Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
        :param pulumi.Input[Union[_builtins.str, 'TlsCertMethodMode']] mode: Mode of TLS server certificate management.
        :param pulumi.Input['CertManagerCertificateSpecArgs'] cert_manager_certificate_spec: Option 1 - Automatic TLS server certificate management with cert-manager.
        :param pulumi.Input['X509ManualCertificateArgs'] manual: Option 2 - Manual TLS server certificate management through a defined secret.
        """
        pulumi.set(__self__, "mode", mode)
        if cert_manager_certificate_spec is not None:
            pulumi.set(__self__, "cert_manager_certificate_spec", cert_manager_certificate_spec)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[Union[_builtins.str, 'TlsCertMethodMode']]:
        """
        Mode of TLS server certificate management.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[Union[_builtins.str, 'TlsCertMethodMode']]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="certManagerCertificateSpec")
    def cert_manager_certificate_spec(self) -> Optional[pulumi.Input['CertManagerCertificateSpecArgs']]:
        """
        Option 1 - Automatic TLS server certificate management with cert-manager.
        """
        return pulumi.get(self, "cert_manager_certificate_spec")

    @cert_manager_certificate_spec.setter
    def cert_manager_certificate_spec(self, value: Optional[pulumi.Input['CertManagerCertificateSpecArgs']]):
        pulumi.set(self, "cert_manager_certificate_spec", value)

    @_builtins.property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['X509ManualCertificateArgs']]:
        """
        Option 2 - Manual TLS server certificate management through a defined secret.
        """
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['X509ManualCertificateArgs']]):
        pulumi.set(self, "manual", value)


if not MYPY:
    class TlsPropertiesArgsDict(TypedDict):
        """
        Tls properties
        """
        mode: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        Mode for TLS.
        """
        trusted_ca_certificate_config_map_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Trusted CA certificate config map.
        """
elif False:
    TlsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsPropertiesArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None,
                 trusted_ca_certificate_config_map_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Tls properties
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] mode: Mode for TLS.
        :param pulumi.Input[_builtins.str] trusted_ca_certificate_config_map_ref: Trusted CA certificate config map.
        """
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if trusted_ca_certificate_config_map_ref is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map_ref", trusted_ca_certificate_config_map_ref)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        Mode for TLS.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="trustedCaCertificateConfigMapRef")
    def trusted_ca_certificate_config_map_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Trusted CA certificate config map.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map_ref")

    @trusted_ca_certificate_config_map_ref.setter
    def trusted_ca_certificate_config_map_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trusted_ca_certificate_config_map_ref", value)


if not MYPY:
    class TracesArgsDict(TypedDict):
        """
        Broker Diagnostic Trace properties
        """
        cache_size_megabytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cache size in megabytes.
        """
        mode: NotRequired[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]
        """
        The toggle to enable/disable traces.
        """
        self_tracing: NotRequired[pulumi.Input['SelfTracingArgsDict']]
        """
        The self tracing properties.
        """
        span_channel_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The span channel capacity.
        """
elif False:
    TracesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TracesArgs:
    def __init__(__self__, *,
                 cache_size_megabytes: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]] = None,
                 self_tracing: Optional[pulumi.Input['SelfTracingArgs']] = None,
                 span_channel_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Broker Diagnostic Trace properties
        :param pulumi.Input[_builtins.int] cache_size_megabytes: The cache size in megabytes.
        :param pulumi.Input[Union[_builtins.str, 'OperationalMode']] mode: The toggle to enable/disable traces.
        :param pulumi.Input['SelfTracingArgs'] self_tracing: The self tracing properties.
        :param pulumi.Input[_builtins.int] span_channel_capacity: The span channel capacity.
        """
        if cache_size_megabytes is None:
            cache_size_megabytes = 16
        if cache_size_megabytes is not None:
            pulumi.set(__self__, "cache_size_megabytes", cache_size_megabytes)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if self_tracing is not None:
            pulumi.set(__self__, "self_tracing", self_tracing)
        if span_channel_capacity is None:
            span_channel_capacity = 1000
        if span_channel_capacity is not None:
            pulumi.set(__self__, "span_channel_capacity", span_channel_capacity)

    @_builtins.property
    @pulumi.getter(name="cacheSizeMegabytes")
    def cache_size_megabytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cache size in megabytes.
        """
        return pulumi.get(self, "cache_size_megabytes")

    @cache_size_megabytes.setter
    def cache_size_megabytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cache_size_megabytes", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]:
        """
        The toggle to enable/disable traces.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[_builtins.str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="selfTracing")
    def self_tracing(self) -> Optional[pulumi.Input['SelfTracingArgs']]:
        """
        The self tracing properties.
        """
        return pulumi.get(self, "self_tracing")

    @self_tracing.setter
    def self_tracing(self, value: Optional[pulumi.Input['SelfTracingArgs']]):
        pulumi.set(self, "self_tracing", value)

    @_builtins.property
    @pulumi.getter(name="spanChannelCapacity")
    def span_channel_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The span channel capacity.
        """
        return pulumi.get(self, "span_channel_capacity")

    @span_channel_capacity.setter
    def span_channel_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "span_channel_capacity", value)


if not MYPY:
    class VolumeClaimResourceRequirementsArgsDict(TypedDict):
        """
        VolumeClaimResourceRequirements properties
        """
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        requests: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
elif False:
    VolumeClaimResourceRequirementsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeClaimResourceRequirementsArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        VolumeClaimResourceRequirements properties
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class VolumeClaimSpecSelectorMatchExpressionsArgsDict(TypedDict):
        """
        VolumeClaimSpecSelectorMatchExpressions properties
        """
        key: pulumi.Input[_builtins.str]
        """
        key is the label key that the selector applies to.
        """
        operator: pulumi.Input[Union[_builtins.str, 'OperatorValues']]
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
elif False:
    VolumeClaimSpecSelectorMatchExpressionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeClaimSpecSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[Union[_builtins.str, 'OperatorValues']],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        VolumeClaimSpecSelectorMatchExpressions properties
        :param pulumi.Input[_builtins.str] key: key is the label key that the selector applies to.
        :param pulumi.Input[Union[_builtins.str, 'OperatorValues']] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[_builtins.str, 'OperatorValues']]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[_builtins.str, 'OperatorValues']]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class VolumeClaimSpecSelectorArgsDict(TypedDict):
        """
        VolumeClaimSpecSelector properties
        """
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgsDict']]]]
        """
        MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
elif False:
    VolumeClaimSpecSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeClaimSpecSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        VolumeClaimSpecSelector properties
        :param pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]] match_expressions: MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] match_labels: MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]]]:
        """
        MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class VolumeClaimSpecArgsDict(TypedDict):
        """
        VolumeClaimSpec properties
        """
        access_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        """
        data_source: NotRequired[pulumi.Input['LocalKubernetesReferenceArgsDict']]
        """
        This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        """
        data_source_ref: NotRequired[pulumi.Input['KubernetesReferenceArgsDict']]
        """
        Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        """
        resources: NotRequired[pulumi.Input['VolumeClaimResourceRequirementsArgsDict']]
        """
        Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        selector: NotRequired[pulumi.Input['VolumeClaimSpecSelectorArgsDict']]
        """
        A label query over volumes to consider for binding.
        """
        storage_class_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        """
        volume_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        """
        volume_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
elif False:
    VolumeClaimSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeClaimSpecArgs:
    def __init__(__self__, *,
                 access_modes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 data_source: Optional[pulumi.Input['LocalKubernetesReferenceArgs']] = None,
                 data_source_ref: Optional[pulumi.Input['KubernetesReferenceArgs']] = None,
                 resources: Optional[pulumi.Input['VolumeClaimResourceRequirementsArgs']] = None,
                 selector: Optional[pulumi.Input['VolumeClaimSpecSelectorArgs']] = None,
                 storage_class_name: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VolumeClaimSpec properties
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_modes: AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        :param pulumi.Input['LocalKubernetesReferenceArgs'] data_source: This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        :param pulumi.Input['KubernetesReferenceArgs'] data_source_ref: Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        :param pulumi.Input['VolumeClaimResourceRequirementsArgs'] resources: Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param pulumi.Input['VolumeClaimSpecSelectorArgs'] selector: A label query over volumes to consider for binding.
        :param pulumi.Input[_builtins.str] storage_class_name: Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        :param pulumi.Input[_builtins.str] volume_mode: volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        :param pulumi.Input[_builtins.str] volume_name: VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        if access_modes is not None:
            pulumi.set(__self__, "access_modes", access_modes)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if data_source_ref is not None:
            pulumi.set(__self__, "data_source_ref", data_source_ref)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)
        if volume_mode is not None:
            pulumi.set(__self__, "volume_mode", volume_mode)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @_builtins.property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @access_modes.setter
    def access_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_modes", value)

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input['LocalKubernetesReferenceArgs']]:
        """
        This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input['LocalKubernetesReferenceArgs']]):
        pulumi.set(self, "data_source", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceRef")
    def data_source_ref(self) -> Optional[pulumi.Input['KubernetesReferenceArgs']]:
        """
        Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        """
        return pulumi.get(self, "data_source_ref")

    @data_source_ref.setter
    def data_source_ref(self, value: Optional[pulumi.Input['KubernetesReferenceArgs']]):
        pulumi.set(self, "data_source_ref", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['VolumeClaimResourceRequirementsArgs']]:
        """
        Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['VolumeClaimResourceRequirementsArgs']]):
        pulumi.set(self, "resources", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['VolumeClaimSpecSelectorArgs']]:
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['VolumeClaimSpecSelectorArgs']]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        """
        return pulumi.get(self, "storage_class_name")

    @storage_class_name.setter
    def storage_class_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class_name", value)

    @_builtins.property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        """
        return pulumi.get(self, "volume_mode")

    @volume_mode.setter
    def volume_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_mode", value)

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_name", value)


if not MYPY:
    class X509ManualCertificateArgsDict(TypedDict):
        """
        X509 Certificate Authentication properties.
        """
        secret_ref: pulumi.Input[_builtins.str]
        """
        Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
elif False:
    X509ManualCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class X509ManualCertificateArgs:
    def __init__(__self__, *,
                 secret_ref: pulumi.Input[_builtins.str]):
        """
        X509 Certificate Authentication properties.
        :param pulumi.Input[_builtins.str] secret_ref: Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[_builtins.str]:
        """
        Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_ref", value)


