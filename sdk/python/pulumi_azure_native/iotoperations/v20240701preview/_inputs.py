# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AdvancedSettingsArgs',
    'AdvancedSettingsArgsDict',
    'AuthorizationConfigArgs',
    'AuthorizationConfigArgsDict',
    'AuthorizationRuleArgs',
    'AuthorizationRuleArgsDict',
    'AutomaticCertMethodArgs',
    'AutomaticCertMethodArgsDict',
    'BackendChainArgs',
    'BackendChainArgsDict',
    'BatchingConfigurationArgs',
    'BatchingConfigurationArgsDict',
    'BrokerAuthenticationPropertiesArgs',
    'BrokerAuthenticationPropertiesArgsDict',
    'BrokerAuthenticatorCustomAuthArgs',
    'BrokerAuthenticatorCustomAuthArgsDict',
    'BrokerAuthenticatorMethodCustomArgs',
    'BrokerAuthenticatorMethodCustomArgsDict',
    'BrokerAuthenticatorMethodSatArgs',
    'BrokerAuthenticatorMethodSatArgsDict',
    'BrokerAuthenticatorMethodX509AttributesArgs',
    'BrokerAuthenticatorMethodX509AttributesArgsDict',
    'BrokerAuthenticatorMethodX509Args',
    'BrokerAuthenticatorMethodX509ArgsDict',
    'BrokerAuthenticatorMethodsArgs',
    'BrokerAuthenticatorMethodsArgsDict',
    'BrokerAuthorizationPropertiesArgs',
    'BrokerAuthorizationPropertiesArgsDict',
    'BrokerDiagnosticsArgs',
    'BrokerDiagnosticsArgsDict',
    'BrokerListenerPropertiesArgs',
    'BrokerListenerPropertiesArgsDict',
    'BrokerPropertiesArgs',
    'BrokerPropertiesArgsDict',
    'BrokerResourceRuleArgs',
    'BrokerResourceRuleArgsDict',
    'CardinalityArgs',
    'CardinalityArgsDict',
    'CertManagerCertOptionsArgs',
    'CertManagerCertOptionsArgsDict',
    'CertManagerIssuerRefArgs',
    'CertManagerIssuerRefArgsDict',
    'CertManagerPrivateKeyArgs',
    'CertManagerPrivateKeyArgsDict',
    'ClientConfigArgs',
    'ClientConfigArgsDict',
    'DataFlowBuiltInTransformationDatasetArgs',
    'DataFlowBuiltInTransformationDatasetArgsDict',
    'DataFlowBuiltInTransformationFilterArgs',
    'DataFlowBuiltInTransformationFilterArgsDict',
    'DataFlowBuiltInTransformationMapArgs',
    'DataFlowBuiltInTransformationMapArgsDict',
    'DataFlowBuiltInTransformationArgs',
    'DataFlowBuiltInTransformationArgsDict',
    'DataFlowDestinationOperationArgs',
    'DataFlowDestinationOperationArgsDict',
    'DataFlowEndpointAuthenticationSaslArgs',
    'DataFlowEndpointAuthenticationSaslArgsDict',
    'DataFlowEndpointAuthenticationServiceAccountTokenArgs',
    'DataFlowEndpointAuthenticationServiceAccountTokenArgsDict',
    'DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgs',
    'DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict',
    'DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgs',
    'DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgsDict',
    'DataFlowEndpointAuthenticationX509Args',
    'DataFlowEndpointAuthenticationX509ArgsDict',
    'DataFlowEndpointAuthenticationArgs',
    'DataFlowEndpointAuthenticationArgsDict',
    'DataFlowEndpointDataExplorerArgs',
    'DataFlowEndpointDataExplorerArgsDict',
    'DataFlowEndpointDataLakeStorageArgs',
    'DataFlowEndpointDataLakeStorageArgsDict',
    'DataFlowEndpointFabricOneLakeNamesArgs',
    'DataFlowEndpointFabricOneLakeNamesArgsDict',
    'DataFlowEndpointFabricOneLakeArgs',
    'DataFlowEndpointFabricOneLakeArgsDict',
    'DataFlowEndpointKafkaBatchingArgs',
    'DataFlowEndpointKafkaBatchingArgsDict',
    'DataFlowEndpointKafkaArgs',
    'DataFlowEndpointKafkaArgsDict',
    'DataFlowEndpointLocalStorageArgs',
    'DataFlowEndpointLocalStorageArgsDict',
    'DataFlowEndpointMqttArgs',
    'DataFlowEndpointMqttArgsDict',
    'DataFlowEndpointPropertiesArgs',
    'DataFlowEndpointPropertiesArgsDict',
    'DataFlowOperationArgs',
    'DataFlowOperationArgsDict',
    'DataFlowProfilePropertiesArgs',
    'DataFlowProfilePropertiesArgsDict',
    'DataFlowPropertiesArgs',
    'DataFlowPropertiesArgsDict',
    'DataFlowSourceOperationArgs',
    'DataFlowSourceOperationArgsDict',
    'DiagnosticsLogsArgs',
    'DiagnosticsLogsArgsDict',
    'DiskBackedMessageBufferArgs',
    'DiskBackedMessageBufferArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'FrontendArgs',
    'FrontendArgsDict',
    'GenerateResourceLimitsArgs',
    'GenerateResourceLimitsArgsDict',
    'InstancePropertiesArgs',
    'InstancePropertiesArgsDict',
    'KubernetesReferenceArgs',
    'KubernetesReferenceArgsDict',
    'ListenerPortArgs',
    'ListenerPortArgsDict',
    'LocalKubernetesReferenceArgs',
    'LocalKubernetesReferenceArgsDict',
    'MetricsArgs',
    'MetricsArgsDict',
    'OpenTelemetryExportConfigArgs',
    'OpenTelemetryExportConfigArgsDict',
    'OpenTelemetryLogExportConfigArgs',
    'OpenTelemetryLogExportConfigArgsDict',
    'PrincipalDefinitionArgs',
    'PrincipalDefinitionArgsDict',
    'ProfileDiagnosticsArgs',
    'ProfileDiagnosticsArgsDict',
    'SanForCertArgs',
    'SanForCertArgsDict',
    'SelfCheckArgs',
    'SelfCheckArgsDict',
    'SelfTracingArgs',
    'SelfTracingArgsDict',
    'StateStoreResourceRuleArgs',
    'StateStoreResourceRuleArgsDict',
    'SubscriberQueueLimitArgs',
    'SubscriberQueueLimitArgsDict',
    'TlsCertMethodArgs',
    'TlsCertMethodArgsDict',
    'TlsPropertiesArgs',
    'TlsPropertiesArgsDict',
    'TracesArgs',
    'TracesArgsDict',
    'VolumeClaimResourceRequirementsArgs',
    'VolumeClaimResourceRequirementsArgsDict',
    'VolumeClaimSpecSelectorMatchExpressionsArgs',
    'VolumeClaimSpecSelectorMatchExpressionsArgsDict',
    'VolumeClaimSpecSelectorArgs',
    'VolumeClaimSpecSelectorArgsDict',
    'VolumeClaimSpecArgs',
    'VolumeClaimSpecArgsDict',
    'X509ManualCertificateArgs',
    'X509ManualCertificateArgsDict',
]

MYPY = False

if not MYPY:
    class AdvancedSettingsArgsDict(TypedDict):
        """
        Broker Advanced Settings
        """
        clients: NotRequired[pulumi.Input['ClientConfigArgsDict']]
        """
        Configurations related to All Clients.
        """
        encrypt_internal_traffic: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        The setting to enable or disable encryption of internal Traffic.
        """
        internal_certs: NotRequired[pulumi.Input['CertManagerCertOptionsArgsDict']]
        """
        Certificate rotation and private key configuration.
        """
elif False:
    AdvancedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedSettingsArgs:
    def __init__(__self__, *,
                 clients: Optional[pulumi.Input['ClientConfigArgs']] = None,
                 encrypt_internal_traffic: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None,
                 internal_certs: Optional[pulumi.Input['CertManagerCertOptionsArgs']] = None):
        """
        Broker Advanced Settings
        :param pulumi.Input['ClientConfigArgs'] clients: Configurations related to All Clients.
        :param pulumi.Input[Union[str, 'OperationalMode']] encrypt_internal_traffic: The setting to enable or disable encryption of internal Traffic.
        :param pulumi.Input['CertManagerCertOptionsArgs'] internal_certs: Certificate rotation and private key configuration.
        """
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if encrypt_internal_traffic is None:
            encrypt_internal_traffic = 'Enabled'
        if encrypt_internal_traffic is not None:
            pulumi.set(__self__, "encrypt_internal_traffic", encrypt_internal_traffic)
        if internal_certs is not None:
            pulumi.set(__self__, "internal_certs", internal_certs)

    @property
    @pulumi.getter
    def clients(self) -> Optional[pulumi.Input['ClientConfigArgs']]:
        """
        Configurations related to All Clients.
        """
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: Optional[pulumi.Input['ClientConfigArgs']]):
        pulumi.set(self, "clients", value)

    @property
    @pulumi.getter(name="encryptInternalTraffic")
    def encrypt_internal_traffic(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        The setting to enable or disable encryption of internal Traffic.
        """
        return pulumi.get(self, "encrypt_internal_traffic")

    @encrypt_internal_traffic.setter
    def encrypt_internal_traffic(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "encrypt_internal_traffic", value)

    @property
    @pulumi.getter(name="internalCerts")
    def internal_certs(self) -> Optional[pulumi.Input['CertManagerCertOptionsArgs']]:
        """
        Certificate rotation and private key configuration.
        """
        return pulumi.get(self, "internal_certs")

    @internal_certs.setter
    def internal_certs(self, value: Optional[pulumi.Input['CertManagerCertOptionsArgs']]):
        pulumi.set(self, "internal_certs", value)


if not MYPY:
    class AuthorizationConfigArgsDict(TypedDict):
        """
        Broker AuthorizationConfig properties
        """
        cache: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        Enable caching of the authorization rules.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgsDict']]]]
        """
        The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
elif False:
    AuthorizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationConfigArgs:
    def __init__(__self__, *,
                 cache: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgs']]]] = None):
        """
        Broker AuthorizationConfig properties
        :param pulumi.Input[Union[str, 'OperationalMode']] cache: Enable caching of the authorization rules.
        :param pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgs']]] rules: The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        if cache is None:
            cache = 'Enabled'
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        Enable caching of the authorization rules.
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "cache", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgs']]]]:
        """
        The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AuthorizationRuleArgsDict(TypedDict):
        """
        AuthorizationConfig Rule Properties
        """
        broker_resources: pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgsDict']]]
        """
        Give access to Broker methods and topics.
        """
        principals: pulumi.Input['PrincipalDefinitionArgsDict']
        """
        Give access to clients based on the following properties.
        """
        state_store_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgsDict']]]]
        """
        Give access to state store resources.
        """
elif False:
    AuthorizationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationRuleArgs:
    def __init__(__self__, *,
                 broker_resources: pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgs']]],
                 principals: pulumi.Input['PrincipalDefinitionArgs'],
                 state_store_resources: Optional[pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgs']]]] = None):
        """
        AuthorizationConfig Rule Properties
        :param pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgs']]] broker_resources: Give access to Broker methods and topics.
        :param pulumi.Input['PrincipalDefinitionArgs'] principals: Give access to clients based on the following properties.
        :param pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgs']]] state_store_resources: Give access to state store resources.
        """
        pulumi.set(__self__, "broker_resources", broker_resources)
        pulumi.set(__self__, "principals", principals)
        if state_store_resources is not None:
            pulumi.set(__self__, "state_store_resources", state_store_resources)

    @property
    @pulumi.getter(name="brokerResources")
    def broker_resources(self) -> pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgs']]]:
        """
        Give access to Broker methods and topics.
        """
        return pulumi.get(self, "broker_resources")

    @broker_resources.setter
    def broker_resources(self, value: pulumi.Input[Sequence[pulumi.Input['BrokerResourceRuleArgs']]]):
        pulumi.set(self, "broker_resources", value)

    @property
    @pulumi.getter
    def principals(self) -> pulumi.Input['PrincipalDefinitionArgs']:
        """
        Give access to clients based on the following properties.
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: pulumi.Input['PrincipalDefinitionArgs']):
        pulumi.set(self, "principals", value)

    @property
    @pulumi.getter(name="stateStoreResources")
    def state_store_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgs']]]]:
        """
        Give access to state store resources.
        """
        return pulumi.get(self, "state_store_resources")

    @state_store_resources.setter
    def state_store_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StateStoreResourceRuleArgs']]]]):
        pulumi.set(self, "state_store_resources", value)


if not MYPY:
    class AutomaticCertMethodArgsDict(TypedDict):
        """
        Automatic TLS server certificate management with cert-manager
        """
        issuer_ref: pulumi.Input['CertManagerIssuerRefArgsDict']
        """
        cert-manager issuerRef.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        private_key: NotRequired[pulumi.Input['CertManagerPrivateKeyArgsDict']]
        """
        Type of certificate private key.
        """
        renew_before: NotRequired[pulumi.Input[str]]
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        san: NotRequired[pulumi.Input['SanForCertArgsDict']]
        """
        Additional Subject Alternative Names (SANs) to include in the certificate.
        """
        secret_ref: NotRequired[pulumi.Input[str]]
        """
        Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
elif False:
    AutomaticCertMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomaticCertMethodArgs:
    def __init__(__self__, *,
                 issuer_ref: pulumi.Input['CertManagerIssuerRefArgs'],
                 duration: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input['CertManagerPrivateKeyArgs']] = None,
                 renew_before: Optional[pulumi.Input[str]] = None,
                 san: Optional[pulumi.Input['SanForCertArgs']] = None,
                 secret_ref: Optional[pulumi.Input[str]] = None):
        """
        Automatic TLS server certificate management with cert-manager
        :param pulumi.Input['CertManagerIssuerRefArgs'] issuer_ref: cert-manager issuerRef.
        :param pulumi.Input[str] duration: Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param pulumi.Input['CertManagerPrivateKeyArgs'] private_key: Type of certificate private key.
        :param pulumi.Input[str] renew_before: When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param pulumi.Input['SanForCertArgs'] san: Additional Subject Alternative Names (SANs) to include in the certificate.
        :param pulumi.Input[str] secret_ref: Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
        pulumi.set(__self__, "issuer_ref", issuer_ref)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if renew_before is not None:
            pulumi.set(__self__, "renew_before", renew_before)
        if san is not None:
            pulumi.set(__self__, "san", san)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> pulumi.Input['CertManagerIssuerRefArgs']:
        """
        cert-manager issuerRef.
        """
        return pulumi.get(self, "issuer_ref")

    @issuer_ref.setter
    def issuer_ref(self, value: pulumi.Input['CertManagerIssuerRefArgs']):
        pulumi.set(self, "issuer_ref", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input['CertManagerPrivateKeyArgs']]:
        """
        Type of certificate private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input['CertManagerPrivateKeyArgs']]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> Optional[pulumi.Input[str]]:
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "renew_before")

    @renew_before.setter
    def renew_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "renew_before", value)

    @property
    @pulumi.getter
    def san(self) -> Optional[pulumi.Input['SanForCertArgs']]:
        """
        Additional Subject Alternative Names (SANs) to include in the certificate.
        """
        return pulumi.get(self, "san")

    @san.setter
    def san(self, value: Optional[pulumi.Input['SanForCertArgs']]):
        pulumi.set(self, "san", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class BackendChainArgsDict(TypedDict):
        """
        Desired properties of the backend instances of the broker
        """
        partitions: pulumi.Input[int]
        """
        The desired number of physical backend partitions.
        """
        redundancy_factor: pulumi.Input[int]
        """
        The desired numbers of backend replicas (pods) in a physical partition.
        """
        workers: NotRequired[pulumi.Input[int]]
        """
        Number of logical backend workers per replica (pod).
        """
elif False:
    BackendChainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendChainArgs:
    def __init__(__self__, *,
                 partitions: pulumi.Input[int],
                 redundancy_factor: pulumi.Input[int],
                 workers: Optional[pulumi.Input[int]] = None):
        """
        Desired properties of the backend instances of the broker
        :param pulumi.Input[int] partitions: The desired number of physical backend partitions.
        :param pulumi.Input[int] redundancy_factor: The desired numbers of backend replicas (pods) in a physical partition.
        :param pulumi.Input[int] workers: Number of logical backend workers per replica (pod).
        """
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "redundancy_factor", redundancy_factor)
        if workers is None:
            workers = 1
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter
    def partitions(self) -> pulumi.Input[int]:
        """
        The desired number of physical backend partitions.
        """
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: pulumi.Input[int]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter(name="redundancyFactor")
    def redundancy_factor(self) -> pulumi.Input[int]:
        """
        The desired numbers of backend replicas (pods) in a physical partition.
        """
        return pulumi.get(self, "redundancy_factor")

    @redundancy_factor.setter
    def redundancy_factor(self, value: pulumi.Input[int]):
        pulumi.set(self, "redundancy_factor", value)

    @property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input[int]]:
        """
        Number of logical backend workers per replica (pod).
        """
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "workers", value)


if not MYPY:
    class BatchingConfigurationArgsDict(TypedDict):
        """
        Batching configuration
        """
        latency_seconds: NotRequired[pulumi.Input[int]]
        """
        Batching latency in seconds.
        """
        max_messages: NotRequired[pulumi.Input[int]]
        """
        Maximum number of messages in a batch.
        """
elif False:
    BatchingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchingConfigurationArgs:
    def __init__(__self__, *,
                 latency_seconds: Optional[pulumi.Input[int]] = None,
                 max_messages: Optional[pulumi.Input[int]] = None):
        """
        Batching configuration
        :param pulumi.Input[int] latency_seconds: Batching latency in seconds.
        :param pulumi.Input[int] max_messages: Maximum number of messages in a batch.
        """
        if latency_seconds is None:
            latency_seconds = 60
        if latency_seconds is not None:
            pulumi.set(__self__, "latency_seconds", latency_seconds)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)

    @property
    @pulumi.getter(name="latencySeconds")
    def latency_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Batching latency in seconds.
        """
        return pulumi.get(self, "latency_seconds")

    @latency_seconds.setter
    def latency_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "latency_seconds", value)

    @property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of messages in a batch.
        """
        return pulumi.get(self, "max_messages")

    @max_messages.setter
    def max_messages(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_messages", value)


if not MYPY:
    class BrokerAuthenticationPropertiesArgsDict(TypedDict):
        """
        BrokerAuthentication Resource properties
        """
        authentication_methods: pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgsDict']]]
        """
        Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        """
elif False:
    BrokerAuthenticationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticationPropertiesArgs:
    def __init__(__self__, *,
                 authentication_methods: pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgs']]]):
        """
        BrokerAuthentication Resource properties
        :param pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgs']]] authentication_methods: Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        """
        pulumi.set(__self__, "authentication_methods", authentication_methods)

    @property
    @pulumi.getter(name="authenticationMethods")
    def authentication_methods(self) -> pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgs']]]:
        """
        Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        """
        return pulumi.get(self, "authentication_methods")

    @authentication_methods.setter
    def authentication_methods(self, value: pulumi.Input[Sequence[pulumi.Input['BrokerAuthenticatorMethodsArgs']]]):
        pulumi.set(self, "authentication_methods", value)


if not MYPY:
    class BrokerAuthenticatorCustomAuthArgsDict(TypedDict):
        """
        Custom Authentication properties
        """
        x509: pulumi.Input['X509ManualCertificateArgsDict']
        """
        X509 Custom Auth type details.
        """
elif False:
    BrokerAuthenticatorCustomAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorCustomAuthArgs:
    def __init__(__self__, *,
                 x509: pulumi.Input['X509ManualCertificateArgs']):
        """
        Custom Authentication properties
        :param pulumi.Input['X509ManualCertificateArgs'] x509: X509 Custom Auth type details.
        """
        pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def x509(self) -> pulumi.Input['X509ManualCertificateArgs']:
        """
        X509 Custom Auth type details.
        """
        return pulumi.get(self, "x509")

    @x509.setter
    def x509(self, value: pulumi.Input['X509ManualCertificateArgs']):
        pulumi.set(self, "x509", value)


if not MYPY:
    class BrokerAuthenticatorMethodCustomArgsDict(TypedDict):
        """
        Custom method for BrokerAuthentication
        """
        endpoint: pulumi.Input[str]
        """
        Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        """
        auth: NotRequired[pulumi.Input['BrokerAuthenticatorCustomAuthArgsDict']]
        """
        Optional authentication needed for authenticating with the custom authentication server.
        """
        ca_cert_config_map: NotRequired[pulumi.Input[str]]
        """
        Optional CA certificate for validating the custom authentication server's certificate.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Additional HTTP headers to pass to the custom authentication server.
        """
elif False:
    BrokerAuthenticatorMethodCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodCustomArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 auth: Optional[pulumi.Input['BrokerAuthenticatorCustomAuthArgs']] = None,
                 ca_cert_config_map: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Custom method for BrokerAuthentication
        :param pulumi.Input[str] endpoint: Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        :param pulumi.Input['BrokerAuthenticatorCustomAuthArgs'] auth: Optional authentication needed for authenticating with the custom authentication server.
        :param pulumi.Input[str] ca_cert_config_map: Optional CA certificate for validating the custom authentication server's certificate.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: Additional HTTP headers to pass to the custom authentication server.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if ca_cert_config_map is not None:
            pulumi.set(__self__, "ca_cert_config_map", ca_cert_config_map)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['BrokerAuthenticatorCustomAuthArgs']]:
        """
        Optional authentication needed for authenticating with the custom authentication server.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['BrokerAuthenticatorCustomAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="caCertConfigMap")
    def ca_cert_config_map(self) -> Optional[pulumi.Input[str]]:
        """
        Optional CA certificate for validating the custom authentication server's certificate.
        """
        return pulumi.get(self, "ca_cert_config_map")

    @ca_cert_config_map.setter
    def ca_cert_config_map(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert_config_map", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional HTTP headers to pass to the custom authentication server.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class BrokerAuthenticatorMethodSatArgsDict(TypedDict):
        """
        Service Account Token for BrokerAuthentication
        """
        audiences: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of allowed audience.
        """
elif False:
    BrokerAuthenticatorMethodSatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodSatArgs:
    def __init__(__self__, *,
                 audiences: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Service Account Token for BrokerAuthentication
        :param pulumi.Input[Sequence[pulumi.Input[str]]] audiences: List of allowed audience.
        """
        pulumi.set(__self__, "audiences", audiences)

    @property
    @pulumi.getter
    def audiences(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of allowed audience.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "audiences", value)


if not MYPY:
    class BrokerAuthenticatorMethodX509AttributesArgsDict(TypedDict):
        """
        BrokerAuthenticatorMethodX509Attributes properties.
        """
        attributes: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        Attributes object.
        """
        subject: pulumi.Input[str]
        """
        Subject of the X509 attribute.
        """
elif False:
    BrokerAuthenticatorMethodX509AttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodX509AttributesArgs:
    def __init__(__self__, *,
                 attributes: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 subject: pulumi.Input[str]):
        """
        BrokerAuthenticatorMethodX509Attributes properties.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] attributes: Attributes object.
        :param pulumi.Input[str] subject: Subject of the X509 attribute.
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def attributes(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Attributes object.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[str]:
        """
        Subject of the X509 attribute.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class BrokerAuthenticatorMethodX509ArgsDict(TypedDict):
        """
        X509 for BrokerAuthentication.
        """
        authorization_attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgsDict']]]]
        """
        X509 authorization attributes properties.
        """
        trusted_client_ca_cert: NotRequired[pulumi.Input[str]]
        """
        Name of the trusted client ca cert resource.
        """
elif False:
    BrokerAuthenticatorMethodX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodX509Args:
    def __init__(__self__, *,
                 authorization_attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]]] = None,
                 trusted_client_ca_cert: Optional[pulumi.Input[str]] = None):
        """
        X509 for BrokerAuthentication.
        :param pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]] authorization_attributes: X509 authorization attributes properties.
        :param pulumi.Input[str] trusted_client_ca_cert: Name of the trusted client ca cert resource.
        """
        if authorization_attributes is not None:
            pulumi.set(__self__, "authorization_attributes", authorization_attributes)
        if trusted_client_ca_cert is None:
            trusted_client_ca_cert = 'client-ca'
        if trusted_client_ca_cert is not None:
            pulumi.set(__self__, "trusted_client_ca_cert", trusted_client_ca_cert)

    @property
    @pulumi.getter(name="authorizationAttributes")
    def authorization_attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]]]:
        """
        X509 authorization attributes properties.
        """
        return pulumi.get(self, "authorization_attributes")

    @authorization_attributes.setter
    def authorization_attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['BrokerAuthenticatorMethodX509AttributesArgs']]]]):
        pulumi.set(self, "authorization_attributes", value)

    @property
    @pulumi.getter(name="trustedClientCaCert")
    def trusted_client_ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the trusted client ca cert resource.
        """
        return pulumi.get(self, "trusted_client_ca_cert")

    @trusted_client_ca_cert.setter
    def trusted_client_ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_client_ca_cert", value)


if not MYPY:
    class BrokerAuthenticatorMethodsArgsDict(TypedDict):
        """
        Set of broker authentication policies. Only one method is supported for each entry.
        """
        method: pulumi.Input[Union[str, 'BrokerAuthenticationMethod']]
        """
        Custom authentication configuration.
        """
        custom: NotRequired[pulumi.Input['BrokerAuthenticatorMethodCustomArgsDict']]
        """
        Custom authentication configuration.
        """
        service_account_token: NotRequired[pulumi.Input['BrokerAuthenticatorMethodSatArgsDict']]
        """
        ServiceAccountToken authentication configuration.
        """
        x509_credentials: NotRequired[pulumi.Input['BrokerAuthenticatorMethodX509ArgsDict']]
        """
        X.509 authentication configuration.
        """
elif False:
    BrokerAuthenticatorMethodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthenticatorMethodsArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[str, 'BrokerAuthenticationMethod']],
                 custom: Optional[pulumi.Input['BrokerAuthenticatorMethodCustomArgs']] = None,
                 service_account_token: Optional[pulumi.Input['BrokerAuthenticatorMethodSatArgs']] = None,
                 x509_credentials: Optional[pulumi.Input['BrokerAuthenticatorMethodX509Args']] = None):
        """
        Set of broker authentication policies. Only one method is supported for each entry.
        :param pulumi.Input[Union[str, 'BrokerAuthenticationMethod']] method: Custom authentication configuration.
        :param pulumi.Input['BrokerAuthenticatorMethodCustomArgs'] custom: Custom authentication configuration.
        :param pulumi.Input['BrokerAuthenticatorMethodSatArgs'] service_account_token: ServiceAccountToken authentication configuration.
        :param pulumi.Input['BrokerAuthenticatorMethodX509Args'] x509_credentials: X.509 authentication configuration.
        """
        pulumi.set(__self__, "method", method)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if service_account_token is not None:
            pulumi.set(__self__, "service_account_token", service_account_token)
        if x509_credentials is not None:
            pulumi.set(__self__, "x509_credentials", x509_credentials)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[str, 'BrokerAuthenticationMethod']]:
        """
        Custom authentication configuration.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[str, 'BrokerAuthenticationMethod']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodCustomArgs']]:
        """
        Custom authentication configuration.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodCustomArgs']]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter(name="serviceAccountToken")
    def service_account_token(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodSatArgs']]:
        """
        ServiceAccountToken authentication configuration.
        """
        return pulumi.get(self, "service_account_token")

    @service_account_token.setter
    def service_account_token(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodSatArgs']]):
        pulumi.set(self, "service_account_token", value)

    @property
    @pulumi.getter(name="x509Credentials")
    def x509_credentials(self) -> Optional[pulumi.Input['BrokerAuthenticatorMethodX509Args']]:
        """
        X.509 authentication configuration.
        """
        return pulumi.get(self, "x509_credentials")

    @x509_credentials.setter
    def x509_credentials(self, value: Optional[pulumi.Input['BrokerAuthenticatorMethodX509Args']]):
        pulumi.set(self, "x509_credentials", value)


if not MYPY:
    class BrokerAuthorizationPropertiesArgsDict(TypedDict):
        """
        BrokerAuthorization Resource properties
        """
        authorization_policies: pulumi.Input['AuthorizationConfigArgsDict']
        """
        The list of authorization policies supported by the Authorization Resource.
        """
elif False:
    BrokerAuthorizationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerAuthorizationPropertiesArgs:
    def __init__(__self__, *,
                 authorization_policies: pulumi.Input['AuthorizationConfigArgs']):
        """
        BrokerAuthorization Resource properties
        :param pulumi.Input['AuthorizationConfigArgs'] authorization_policies: The list of authorization policies supported by the Authorization Resource.
        """
        pulumi.set(__self__, "authorization_policies", authorization_policies)

    @property
    @pulumi.getter(name="authorizationPolicies")
    def authorization_policies(self) -> pulumi.Input['AuthorizationConfigArgs']:
        """
        The list of authorization policies supported by the Authorization Resource.
        """
        return pulumi.get(self, "authorization_policies")

    @authorization_policies.setter
    def authorization_policies(self, value: pulumi.Input['AuthorizationConfigArgs']):
        pulumi.set(self, "authorization_policies", value)


if not MYPY:
    class BrokerDiagnosticsArgsDict(TypedDict):
        """
        Broker Diagnostic Setting properties
        """
        logs: NotRequired[pulumi.Input['DiagnosticsLogsArgsDict']]
        """
        Diagnostic log settings for the resource.
        """
        metrics: NotRequired[pulumi.Input['MetricsArgsDict']]
        """
        The metrics settings for the resource.
        """
        self_check: NotRequired[pulumi.Input['SelfCheckArgsDict']]
        """
        The self check properties.
        """
        traces: NotRequired[pulumi.Input['TracesArgsDict']]
        """
        The trace properties.
        """
elif False:
    BrokerDiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerDiagnosticsArgs:
    def __init__(__self__, *,
                 logs: Optional[pulumi.Input['DiagnosticsLogsArgs']] = None,
                 metrics: Optional[pulumi.Input['MetricsArgs']] = None,
                 self_check: Optional[pulumi.Input['SelfCheckArgs']] = None,
                 traces: Optional[pulumi.Input['TracesArgs']] = None):
        """
        Broker Diagnostic Setting properties
        :param pulumi.Input['DiagnosticsLogsArgs'] logs: Diagnostic log settings for the resource.
        :param pulumi.Input['MetricsArgs'] metrics: The metrics settings for the resource.
        :param pulumi.Input['SelfCheckArgs'] self_check: The self check properties.
        :param pulumi.Input['TracesArgs'] traces: The trace properties.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if self_check is not None:
            pulumi.set(__self__, "self_check", self_check)
        if traces is not None:
            pulumi.set(__self__, "traces", traces)

    @property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input['DiagnosticsLogsArgs']]:
        """
        Diagnostic log settings for the resource.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input['DiagnosticsLogsArgs']]):
        pulumi.set(self, "logs", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['MetricsArgs']]:
        """
        The metrics settings for the resource.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['MetricsArgs']]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="selfCheck")
    def self_check(self) -> Optional[pulumi.Input['SelfCheckArgs']]:
        """
        The self check properties.
        """
        return pulumi.get(self, "self_check")

    @self_check.setter
    def self_check(self, value: Optional[pulumi.Input['SelfCheckArgs']]):
        pulumi.set(self, "self_check", value)

    @property
    @pulumi.getter
    def traces(self) -> Optional[pulumi.Input['TracesArgs']]:
        """
        The trace properties.
        """
        return pulumi.get(self, "traces")

    @traces.setter
    def traces(self, value: Optional[pulumi.Input['TracesArgs']]):
        pulumi.set(self, "traces", value)


if not MYPY:
    class BrokerListenerPropertiesArgsDict(TypedDict):
        """
        Defines a Broker listener. A listener is a collection of ports on which the broker accepts connections from clients.
        """
        broker_ref: pulumi.Input[str]
        """
        Broker associated with this listener.
        """
        ports: pulumi.Input[Sequence[pulumi.Input['ListenerPortArgsDict']]]
        """
        Ports on which this listener accepts client connections.
        """
        service_name: NotRequired[pulumi.Input[str]]
        """
        Kubernetes Service name of this listener.
        """
        service_type: NotRequired[pulumi.Input[Union[str, 'ServiceType']]]
        """
        Kubernetes Service type of this listener.
        """
elif False:
    BrokerListenerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerListenerPropertiesArgs:
    def __init__(__self__, *,
                 broker_ref: pulumi.Input[str],
                 ports: pulumi.Input[Sequence[pulumi.Input['ListenerPortArgs']]],
                 service_name: Optional[pulumi.Input[str]] = None,
                 service_type: Optional[pulumi.Input[Union[str, 'ServiceType']]] = None):
        """
        Defines a Broker listener. A listener is a collection of ports on which the broker accepts connections from clients.
        :param pulumi.Input[str] broker_ref: Broker associated with this listener.
        :param pulumi.Input[Sequence[pulumi.Input['ListenerPortArgs']]] ports: Ports on which this listener accepts client connections.
        :param pulumi.Input[str] service_name: Kubernetes Service name of this listener.
        :param pulumi.Input[Union[str, 'ServiceType']] service_type: Kubernetes Service type of this listener.
        """
        pulumi.set(__self__, "broker_ref", broker_ref)
        pulumi.set(__self__, "ports", ports)
        if service_name is None:
            service_name = 'aio-mq-dmqtt-frontend'
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_type is None:
            service_type = 'ClusterIp'
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)

    @property
    @pulumi.getter(name="brokerRef")
    def broker_ref(self) -> pulumi.Input[str]:
        """
        Broker associated with this listener.
        """
        return pulumi.get(self, "broker_ref")

    @broker_ref.setter
    def broker_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "broker_ref", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input['ListenerPortArgs']]]:
        """
        Ports on which this listener accepts client connections.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input['ListenerPortArgs']]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Kubernetes Service name of this listener.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[Union[str, 'ServiceType']]]:
        """
        Kubernetes Service type of this listener.
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[Union[str, 'ServiceType']]]):
        pulumi.set(self, "service_type", value)


if not MYPY:
    class BrokerPropertiesArgsDict(TypedDict):
        """
        Broker Resource properties
        """
        advanced: NotRequired[pulumi.Input['AdvancedSettingsArgsDict']]
        """
        Advanced settings of Broker.
        """
        cardinality: NotRequired[pulumi.Input['CardinalityArgsDict']]
        """
        The cardinality details of the broker.
        """
        diagnostics: NotRequired[pulumi.Input['BrokerDiagnosticsArgsDict']]
        """
        Spec defines the desired identities of Broker diagnostics settings.
        """
        disk_backed_message_buffer: NotRequired[pulumi.Input['DiskBackedMessageBufferArgsDict']]
        """
        Settings of Disk Backed Message Buffer.
        """
        generate_resource_limits: NotRequired[pulumi.Input['GenerateResourceLimitsArgsDict']]
        """
        This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        """
        memory_profile: NotRequired[pulumi.Input[Union[str, 'BrokerMemoryProfile']]]
        """
        Memory profile of Broker.
        """
elif False:
    BrokerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerPropertiesArgs:
    def __init__(__self__, *,
                 advanced: Optional[pulumi.Input['AdvancedSettingsArgs']] = None,
                 cardinality: Optional[pulumi.Input['CardinalityArgs']] = None,
                 diagnostics: Optional[pulumi.Input['BrokerDiagnosticsArgs']] = None,
                 disk_backed_message_buffer: Optional[pulumi.Input['DiskBackedMessageBufferArgs']] = None,
                 generate_resource_limits: Optional[pulumi.Input['GenerateResourceLimitsArgs']] = None,
                 memory_profile: Optional[pulumi.Input[Union[str, 'BrokerMemoryProfile']]] = None):
        """
        Broker Resource properties
        :param pulumi.Input['AdvancedSettingsArgs'] advanced: Advanced settings of Broker.
        :param pulumi.Input['CardinalityArgs'] cardinality: The cardinality details of the broker.
        :param pulumi.Input['BrokerDiagnosticsArgs'] diagnostics: Spec defines the desired identities of Broker diagnostics settings.
        :param pulumi.Input['DiskBackedMessageBufferArgs'] disk_backed_message_buffer: Settings of Disk Backed Message Buffer.
        :param pulumi.Input['GenerateResourceLimitsArgs'] generate_resource_limits: This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        :param pulumi.Input[Union[str, 'BrokerMemoryProfile']] memory_profile: Memory profile of Broker.
        """
        if advanced is not None:
            pulumi.set(__self__, "advanced", advanced)
        if cardinality is not None:
            pulumi.set(__self__, "cardinality", cardinality)
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if disk_backed_message_buffer is not None:
            pulumi.set(__self__, "disk_backed_message_buffer", disk_backed_message_buffer)
        if generate_resource_limits is not None:
            pulumi.set(__self__, "generate_resource_limits", generate_resource_limits)
        if memory_profile is None:
            memory_profile = 'Medium'
        if memory_profile is not None:
            pulumi.set(__self__, "memory_profile", memory_profile)

    @property
    @pulumi.getter
    def advanced(self) -> Optional[pulumi.Input['AdvancedSettingsArgs']]:
        """
        Advanced settings of Broker.
        """
        return pulumi.get(self, "advanced")

    @advanced.setter
    def advanced(self, value: Optional[pulumi.Input['AdvancedSettingsArgs']]):
        pulumi.set(self, "advanced", value)

    @property
    @pulumi.getter
    def cardinality(self) -> Optional[pulumi.Input['CardinalityArgs']]:
        """
        The cardinality details of the broker.
        """
        return pulumi.get(self, "cardinality")

    @cardinality.setter
    def cardinality(self, value: Optional[pulumi.Input['CardinalityArgs']]):
        pulumi.set(self, "cardinality", value)

    @property
    @pulumi.getter
    def diagnostics(self) -> Optional[pulumi.Input['BrokerDiagnosticsArgs']]:
        """
        Spec defines the desired identities of Broker diagnostics settings.
        """
        return pulumi.get(self, "diagnostics")

    @diagnostics.setter
    def diagnostics(self, value: Optional[pulumi.Input['BrokerDiagnosticsArgs']]):
        pulumi.set(self, "diagnostics", value)

    @property
    @pulumi.getter(name="diskBackedMessageBuffer")
    def disk_backed_message_buffer(self) -> Optional[pulumi.Input['DiskBackedMessageBufferArgs']]:
        """
        Settings of Disk Backed Message Buffer.
        """
        return pulumi.get(self, "disk_backed_message_buffer")

    @disk_backed_message_buffer.setter
    def disk_backed_message_buffer(self, value: Optional[pulumi.Input['DiskBackedMessageBufferArgs']]):
        pulumi.set(self, "disk_backed_message_buffer", value)

    @property
    @pulumi.getter(name="generateResourceLimits")
    def generate_resource_limits(self) -> Optional[pulumi.Input['GenerateResourceLimitsArgs']]:
        """
        This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        """
        return pulumi.get(self, "generate_resource_limits")

    @generate_resource_limits.setter
    def generate_resource_limits(self, value: Optional[pulumi.Input['GenerateResourceLimitsArgs']]):
        pulumi.set(self, "generate_resource_limits", value)

    @property
    @pulumi.getter(name="memoryProfile")
    def memory_profile(self) -> Optional[pulumi.Input[Union[str, 'BrokerMemoryProfile']]]:
        """
        Memory profile of Broker.
        """
        return pulumi.get(self, "memory_profile")

    @memory_profile.setter
    def memory_profile(self, value: Optional[pulumi.Input[Union[str, 'BrokerMemoryProfile']]]):
        pulumi.set(self, "memory_profile", value)


if not MYPY:
    class BrokerResourceRuleArgsDict(TypedDict):
        """
        Broker Resource Rule properties. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
        """
        method: pulumi.Input[Union[str, 'BrokerResourceDefinitionMethods']]
        """
        Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        """
        topics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
elif False:
    BrokerResourceRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerResourceRuleArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[str, 'BrokerResourceDefinitionMethods']],
                 topics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Broker Resource Rule properties. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
        :param pulumi.Input[Union[str, 'BrokerResourceDefinitionMethods']] method: Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topics: A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        pulumi.set(__self__, "method", method)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[str, 'BrokerResourceDefinitionMethods']]:
        """
        Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[str, 'BrokerResourceDefinitionMethods']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "topics", value)


if not MYPY:
    class CardinalityArgsDict(TypedDict):
        """
        Cardinality properties
        """
        backend_chain: pulumi.Input['BackendChainArgsDict']
        """
        The backend broker desired properties
        """
        frontend: pulumi.Input['FrontendArgsDict']
        """
        The frontend desired properties
        """
elif False:
    CardinalityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CardinalityArgs:
    def __init__(__self__, *,
                 backend_chain: pulumi.Input['BackendChainArgs'],
                 frontend: pulumi.Input['FrontendArgs']):
        """
        Cardinality properties
        :param pulumi.Input['BackendChainArgs'] backend_chain: The backend broker desired properties
        :param pulumi.Input['FrontendArgs'] frontend: The frontend desired properties
        """
        pulumi.set(__self__, "backend_chain", backend_chain)
        pulumi.set(__self__, "frontend", frontend)

    @property
    @pulumi.getter(name="backendChain")
    def backend_chain(self) -> pulumi.Input['BackendChainArgs']:
        """
        The backend broker desired properties
        """
        return pulumi.get(self, "backend_chain")

    @backend_chain.setter
    def backend_chain(self, value: pulumi.Input['BackendChainArgs']):
        pulumi.set(self, "backend_chain", value)

    @property
    @pulumi.getter
    def frontend(self) -> pulumi.Input['FrontendArgs']:
        """
        The frontend desired properties
        """
        return pulumi.get(self, "frontend")

    @frontend.setter
    def frontend(self, value: pulumi.Input['FrontendArgs']):
        pulumi.set(self, "frontend", value)


if not MYPY:
    class CertManagerCertOptionsArgsDict(TypedDict):
        """
        Cert Manager Cert properties
        """
        duration: pulumi.Input[str]
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        private_key: pulumi.Input['CertManagerPrivateKeyArgsDict']
        """
        Configuration of certificate private key.
        """
        renew_before: pulumi.Input[str]
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
elif False:
    CertManagerCertOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertManagerCertOptionsArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 private_key: pulumi.Input['CertManagerPrivateKeyArgs'],
                 renew_before: pulumi.Input[str]):
        """
        Cert Manager Cert properties
        :param pulumi.Input[str] duration: Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param pulumi.Input['CertManagerPrivateKeyArgs'] private_key: Configuration of certificate private key.
        :param pulumi.Input[str] renew_before: When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "renew_before", renew_before)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input['CertManagerPrivateKeyArgs']:
        """
        Configuration of certificate private key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input['CertManagerPrivateKeyArgs']):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> pulumi.Input[str]:
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "renew_before")

    @renew_before.setter
    def renew_before(self, value: pulumi.Input[str]):
        pulumi.set(self, "renew_before", value)


if not MYPY:
    class CertManagerIssuerRefArgsDict(TypedDict):
        """
        Cert-Manager issuerRef properties
        """
        api_group: pulumi.Input[str]
        """
        group of issuer.
        """
        kind: pulumi.Input[Union[str, 'CertManagerIssuerKind']]
        """
        kind of issuer (Issuer or ClusterIssuer).
        """
        name: pulumi.Input[str]
        """
        name of issuer.
        """
elif False:
    CertManagerIssuerRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertManagerIssuerRefArgs:
    def __init__(__self__, *,
                 api_group: Optional[pulumi.Input[str]] = None,
                 kind: pulumi.Input[Union[str, 'CertManagerIssuerKind']],
                 name: pulumi.Input[str]):
        """
        Cert-Manager issuerRef properties
        :param pulumi.Input[str] api_group: group of issuer.
        :param pulumi.Input[Union[str, 'CertManagerIssuerKind']] kind: kind of issuer (Issuer or ClusterIssuer).
        :param pulumi.Input[str] name: name of issuer.
        """
        if api_group is None:
            api_group = 'cert-manager.io'
        pulumi.set(__self__, "api_group", api_group)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> pulumi.Input[str]:
        """
        group of issuer.
        """
        return pulumi.get(self, "api_group")

    @api_group.setter
    def api_group(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_group", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[Union[str, 'CertManagerIssuerKind']]:
        """
        kind of issuer (Issuer or ClusterIssuer).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[Union[str, 'CertManagerIssuerKind']]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        name of issuer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CertManagerPrivateKeyArgsDict(TypedDict):
        """
        Cert Manager private key properties
        """
        algorithm: pulumi.Input[Union[str, 'PrivateKeyAlgorithm']]
        """
        algorithm for private key.
        """
        rotation_policy: pulumi.Input[Union[str, 'PrivateKeyRotationPolicy']]
        """
        cert-manager private key rotationPolicy.
        """
elif False:
    CertManagerPrivateKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertManagerPrivateKeyArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[Union[str, 'PrivateKeyAlgorithm']],
                 rotation_policy: pulumi.Input[Union[str, 'PrivateKeyRotationPolicy']]):
        """
        Cert Manager private key properties
        :param pulumi.Input[Union[str, 'PrivateKeyAlgorithm']] algorithm: algorithm for private key.
        :param pulumi.Input[Union[str, 'PrivateKeyRotationPolicy']] rotation_policy: cert-manager private key rotationPolicy.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "rotation_policy", rotation_policy)

    @property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[Union[str, 'PrivateKeyAlgorithm']]:
        """
        algorithm for private key.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[Union[str, 'PrivateKeyAlgorithm']]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="rotationPolicy")
    def rotation_policy(self) -> pulumi.Input[Union[str, 'PrivateKeyRotationPolicy']]:
        """
        cert-manager private key rotationPolicy.
        """
        return pulumi.get(self, "rotation_policy")

    @rotation_policy.setter
    def rotation_policy(self, value: pulumi.Input[Union[str, 'PrivateKeyRotationPolicy']]):
        pulumi.set(self, "rotation_policy", value)


if not MYPY:
    class ClientConfigArgsDict(TypedDict):
        """
        The settings of Client Config.
        """
        max_keep_alive_seconds: NotRequired[pulumi.Input[int]]
        """
        Upper bound of a client's Keep Alive, in seconds.
        """
        max_message_expiry_seconds: NotRequired[pulumi.Input[int]]
        """
        Upper bound of Message Expiry Interval, in seconds.
        """
        max_packet_size_bytes: NotRequired[pulumi.Input[int]]
        """
        Max message size for a packet in Bytes.
        """
        max_receive_maximum: NotRequired[pulumi.Input[int]]
        """
        Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        """
        max_session_expiry_seconds: NotRequired[pulumi.Input[int]]
        """
        Upper bound of Session Expiry Interval, in seconds.
        """
        subscriber_queue_limit: NotRequired[pulumi.Input['SubscriberQueueLimitArgsDict']]
        """
        The limit on the number of queued messages for a subscriber.
        """
elif False:
    ClientConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientConfigArgs:
    def __init__(__self__, *,
                 max_keep_alive_seconds: Optional[pulumi.Input[int]] = None,
                 max_message_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 max_packet_size_bytes: Optional[pulumi.Input[int]] = None,
                 max_receive_maximum: Optional[pulumi.Input[int]] = None,
                 max_session_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 subscriber_queue_limit: Optional[pulumi.Input['SubscriberQueueLimitArgs']] = None):
        """
        The settings of Client Config.
        :param pulumi.Input[int] max_keep_alive_seconds: Upper bound of a client's Keep Alive, in seconds.
        :param pulumi.Input[int] max_message_expiry_seconds: Upper bound of Message Expiry Interval, in seconds.
        :param pulumi.Input[int] max_packet_size_bytes: Max message size for a packet in Bytes.
        :param pulumi.Input[int] max_receive_maximum: Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        :param pulumi.Input[int] max_session_expiry_seconds: Upper bound of Session Expiry Interval, in seconds.
        :param pulumi.Input['SubscriberQueueLimitArgs'] subscriber_queue_limit: The limit on the number of queued messages for a subscriber.
        """
        if max_keep_alive_seconds is not None:
            pulumi.set(__self__, "max_keep_alive_seconds", max_keep_alive_seconds)
        if max_message_expiry_seconds is not None:
            pulumi.set(__self__, "max_message_expiry_seconds", max_message_expiry_seconds)
        if max_packet_size_bytes is not None:
            pulumi.set(__self__, "max_packet_size_bytes", max_packet_size_bytes)
        if max_receive_maximum is not None:
            pulumi.set(__self__, "max_receive_maximum", max_receive_maximum)
        if max_session_expiry_seconds is not None:
            pulumi.set(__self__, "max_session_expiry_seconds", max_session_expiry_seconds)
        if subscriber_queue_limit is not None:
            pulumi.set(__self__, "subscriber_queue_limit", subscriber_queue_limit)

    @property
    @pulumi.getter(name="maxKeepAliveSeconds")
    def max_keep_alive_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Upper bound of a client's Keep Alive, in seconds.
        """
        return pulumi.get(self, "max_keep_alive_seconds")

    @max_keep_alive_seconds.setter
    def max_keep_alive_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_keep_alive_seconds", value)

    @property
    @pulumi.getter(name="maxMessageExpirySeconds")
    def max_message_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Upper bound of Message Expiry Interval, in seconds.
        """
        return pulumi.get(self, "max_message_expiry_seconds")

    @max_message_expiry_seconds.setter
    def max_message_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_message_expiry_seconds", value)

    @property
    @pulumi.getter(name="maxPacketSizeBytes")
    def max_packet_size_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Max message size for a packet in Bytes.
        """
        return pulumi.get(self, "max_packet_size_bytes")

    @max_packet_size_bytes.setter
    def max_packet_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_packet_size_bytes", value)

    @property
    @pulumi.getter(name="maxReceiveMaximum")
    def max_receive_maximum(self) -> Optional[pulumi.Input[int]]:
        """
        Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        """
        return pulumi.get(self, "max_receive_maximum")

    @max_receive_maximum.setter
    def max_receive_maximum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_receive_maximum", value)

    @property
    @pulumi.getter(name="maxSessionExpirySeconds")
    def max_session_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Upper bound of Session Expiry Interval, in seconds.
        """
        return pulumi.get(self, "max_session_expiry_seconds")

    @max_session_expiry_seconds.setter
    def max_session_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_session_expiry_seconds", value)

    @property
    @pulumi.getter(name="subscriberQueueLimit")
    def subscriber_queue_limit(self) -> Optional[pulumi.Input['SubscriberQueueLimitArgs']]:
        """
        The limit on the number of queued messages for a subscriber.
        """
        return pulumi.get(self, "subscriber_queue_limit")

    @subscriber_queue_limit.setter
    def subscriber_queue_limit(self, value: Optional[pulumi.Input['SubscriberQueueLimitArgs']]):
        pulumi.set(self, "subscriber_queue_limit", value)


if not MYPY:
    class DataFlowBuiltInTransformationDatasetArgsDict(TypedDict):
        """
        DataFlow BuiltIn Transformation dataset properties
        """
        inputs: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of fields for enriching from the Broker State Store.
        """
        key: pulumi.Input[str]
        """
        The key of the dataset.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A user provided optional description of the dataset.
        """
        expression: NotRequired[pulumi.Input[str]]
        """
        Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        schema_ref: NotRequired[pulumi.Input[str]]
        """
        The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
elif False:
    DataFlowBuiltInTransformationDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowBuiltInTransformationDatasetArgs:
    def __init__(__self__, *,
                 inputs: pulumi.Input[Sequence[pulumi.Input[str]]],
                 key: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 schema_ref: Optional[pulumi.Input[str]] = None):
        """
        DataFlow BuiltIn Transformation dataset properties
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inputs: List of fields for enriching from the Broker State Store.
        :param pulumi.Input[str] key: The key of the dataset.
        :param pulumi.Input[str] description: A user provided optional description of the dataset.
        :param pulumi.Input[str] expression: Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        :param pulumi.Input[str] schema_ref: The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "key", key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)

    @property
    @pulumi.getter
    def inputs(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of fields for enriching from the Broker State Store.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "inputs", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the dataset.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A user provided optional description of the dataset.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
        return pulumi.get(self, "schema_ref")

    @schema_ref.setter
    def schema_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_ref", value)


if not MYPY:
    class DataFlowBuiltInTransformationFilterArgsDict(TypedDict):
        """
        DataFlow BuiltIn Transformation filter properties
        """
        expression: pulumi.Input[str]
        """
        Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        inputs: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of fields for filtering in JSON path expression.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A user provided optional description of the filter.
        """
        type: NotRequired[pulumi.Input[Union[str, 'FilterType']]]
        """
        The type of dataflow operation.
        """
elif False:
    DataFlowBuiltInTransformationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowBuiltInTransformationFilterArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 inputs: pulumi.Input[Sequence[pulumi.Input[str]]],
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'FilterType']]] = None):
        """
        DataFlow BuiltIn Transformation filter properties
        :param pulumi.Input[str] expression: Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inputs: List of fields for filtering in JSON path expression.
        :param pulumi.Input[str] description: A user provided optional description of the filter.
        :param pulumi.Input[Union[str, 'FilterType']] type: The type of dataflow operation.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "inputs", inputs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is None:
            type = 'Filter'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def inputs(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of fields for filtering in JSON path expression.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "inputs", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A user provided optional description of the filter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'FilterType']]]:
        """
        The type of dataflow operation.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'FilterType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataFlowBuiltInTransformationMapArgsDict(TypedDict):
        """
        DataFlow BuiltIn Transformation map properties
        """
        inputs: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of fields for mapping in JSON path expression.
        """
        output: pulumi.Input[str]
        """
        Where and how the input fields to be organized in the output record.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A user provided optional description of the mapping function.
        """
        expression: NotRequired[pulumi.Input[str]]
        """
        Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        """
        type: NotRequired[pulumi.Input[Union[str, 'DataFlowMappingType']]]
        """
        Type of transformation.
        """
elif False:
    DataFlowBuiltInTransformationMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowBuiltInTransformationMapArgs:
    def __init__(__self__, *,
                 inputs: pulumi.Input[Sequence[pulumi.Input[str]]],
                 output: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'DataFlowMappingType']]] = None):
        """
        DataFlow BuiltIn Transformation map properties
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inputs: List of fields for mapping in JSON path expression.
        :param pulumi.Input[str] output: Where and how the input fields to be organized in the output record.
        :param pulumi.Input[str] description: A user provided optional description of the mapping function.
        :param pulumi.Input[str] expression: Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        :param pulumi.Input[Union[str, 'DataFlowMappingType']] type: Type of transformation.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "output", output)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def inputs(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of fields for mapping in JSON path expression.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "inputs", value)

    @property
    @pulumi.getter
    def output(self) -> pulumi.Input[str]:
        """
        Where and how the input fields to be organized in the output record.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: pulumi.Input[str]):
        pulumi.set(self, "output", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A user provided optional description of the mapping function.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'DataFlowMappingType']]]:
        """
        Type of transformation.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'DataFlowMappingType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataFlowBuiltInTransformationArgsDict(TypedDict):
        """
        DataFlow BuiltIn Transformation properties
        """
        datasets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationDatasetArgsDict']]]]
        """
        Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        """
        filter: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationFilterArgsDict']]]]
        """
        Filters input record or datapoints based on condition.
        """
        map: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationMapArgsDict']]]]
        """
        Maps input to output message.
        """
        schema_ref: NotRequired[pulumi.Input[str]]
        """
        Reference to the schema that describes the output of the transformation.
        """
        serialization_format: NotRequired[pulumi.Input[Union[str, 'TransformationSerializationFormat']]]
        """
        Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
elif False:
    DataFlowBuiltInTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowBuiltInTransformationArgs:
    def __init__(__self__, *,
                 datasets: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationDatasetArgs']]]] = None,
                 filter: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationFilterArgs']]]] = None,
                 map: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationMapArgs']]]] = None,
                 schema_ref: Optional[pulumi.Input[str]] = None,
                 serialization_format: Optional[pulumi.Input[Union[str, 'TransformationSerializationFormat']]] = None):
        """
        DataFlow BuiltIn Transformation properties
        :param pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationDatasetArgs']]] datasets: Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        :param pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationFilterArgs']]] filter: Filters input record or datapoints based on condition.
        :param pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationMapArgs']]] map: Maps input to output message.
        :param pulumi.Input[str] schema_ref: Reference to the schema that describes the output of the transformation.
        :param pulumi.Input[Union[str, 'TransformationSerializationFormat']] serialization_format: Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
        if datasets is not None:
            pulumi.set(__self__, "datasets", datasets)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if map is not None:
            pulumi.set(__self__, "map", map)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is None:
            serialization_format = 'Json'
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @property
    @pulumi.getter
    def datasets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationDatasetArgs']]]]:
        """
        Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        """
        return pulumi.get(self, "datasets")

    @datasets.setter
    def datasets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationDatasetArgs']]]]):
        pulumi.set(self, "datasets", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationFilterArgs']]]]:
        """
        Filters input record or datapoints based on condition.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationFilterArgs']]]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationMapArgs']]]]:
        """
        Maps input to output message.
        """
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataFlowBuiltInTransformationMapArgs']]]]):
        pulumi.set(self, "map", value)

    @property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Reference to the schema that describes the output of the transformation.
        """
        return pulumi.get(self, "schema_ref")

    @schema_ref.setter
    def schema_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_ref", value)

    @property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[pulumi.Input[Union[str, 'TransformationSerializationFormat']]]:
        """
        Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
        return pulumi.get(self, "serialization_format")

    @serialization_format.setter
    def serialization_format(self, value: Optional[pulumi.Input[Union[str, 'TransformationSerializationFormat']]]):
        pulumi.set(self, "serialization_format", value)


if not MYPY:
    class DataFlowDestinationOperationArgsDict(TypedDict):
        """
        DataFlow Destination Operation properties
        """
        data_destination: pulumi.Input[str]
        """
        Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        """
        endpoint_ref: pulumi.Input[str]
        """
        Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
elif False:
    DataFlowDestinationOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowDestinationOperationArgs:
    def __init__(__self__, *,
                 data_destination: pulumi.Input[str],
                 endpoint_ref: pulumi.Input[str]):
        """
        DataFlow Destination Operation properties
        :param pulumi.Input[str] data_destination: Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        :param pulumi.Input[str] endpoint_ref: Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
        pulumi.set(__self__, "data_destination", data_destination)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)

    @property
    @pulumi.getter(name="dataDestination")
    def data_destination(self) -> pulumi.Input[str]:
        """
        Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        """
        return pulumi.get(self, "data_destination")

    @data_destination.setter
    def data_destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_destination", value)

    @property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> pulumi.Input[str]:
        """
        Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
        return pulumi.get(self, "endpoint_ref")

    @endpoint_ref.setter
    def endpoint_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_ref", value)


if not MYPY:
    class DataFlowEndpointAuthenticationSaslArgsDict(TypedDict):
        """
        DataFlowEndpoint Authentication Sasl properties
        """
        sasl_type: pulumi.Input[Union[str, 'DataFlowEndpointAuthenticationSaslType']]
        """
        Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        """
        token_secret_ref: pulumi.Input[str]
        """
        Token secret name.
        """
elif False:
    DataFlowEndpointAuthenticationSaslArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointAuthenticationSaslArgs:
    def __init__(__self__, *,
                 sasl_type: pulumi.Input[Union[str, 'DataFlowEndpointAuthenticationSaslType']],
                 token_secret_ref: pulumi.Input[str]):
        """
        DataFlowEndpoint Authentication Sasl properties
        :param pulumi.Input[Union[str, 'DataFlowEndpointAuthenticationSaslType']] sasl_type: Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        :param pulumi.Input[str] token_secret_ref: Token secret name.
        """
        pulumi.set(__self__, "sasl_type", sasl_type)
        pulumi.set(__self__, "token_secret_ref", token_secret_ref)

    @property
    @pulumi.getter(name="saslType")
    def sasl_type(self) -> pulumi.Input[Union[str, 'DataFlowEndpointAuthenticationSaslType']]:
        """
        Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        """
        return pulumi.get(self, "sasl_type")

    @sasl_type.setter
    def sasl_type(self, value: pulumi.Input[Union[str, 'DataFlowEndpointAuthenticationSaslType']]):
        pulumi.set(self, "sasl_type", value)

    @property
    @pulumi.getter(name="tokenSecretRef")
    def token_secret_ref(self) -> pulumi.Input[str]:
        """
        Token secret name.
        """
        return pulumi.get(self, "token_secret_ref")

    @token_secret_ref.setter
    def token_secret_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_secret_ref", value)


if not MYPY:
    class DataFlowEndpointAuthenticationServiceAccountTokenArgsDict(TypedDict):
        """
        Service Account Token for BrokerAuthentication
        """
        audience: pulumi.Input[str]
        """
        Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
elif False:
    DataFlowEndpointAuthenticationServiceAccountTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointAuthenticationServiceAccountTokenArgs:
    def __init__(__self__, *,
                 audience: pulumi.Input[str]):
        """
        Service Account Token for BrokerAuthentication
        :param pulumi.Input[str] audience: Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
        pulumi.set(__self__, "audience", audience)

    @property
    @pulumi.getter
    def audience(self) -> pulumi.Input[str]:
        """
        Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: pulumi.Input[str]):
        pulumi.set(self, "audience", value)


if not MYPY:
    class DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict(TypedDict):
        """
        DataFlowEndpoint Authentication SystemAssignedManagedIdentity properties
        """
        audience: pulumi.Input[str]
        """
        Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
elif False:
    DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgs:
    def __init__(__self__, *,
                 audience: pulumi.Input[str]):
        """
        DataFlowEndpoint Authentication SystemAssignedManagedIdentity properties
        :param pulumi.Input[str] audience: Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        pulumi.set(__self__, "audience", audience)

    @property
    @pulumi.getter
    def audience(self) -> pulumi.Input[str]:
        """
        Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: pulumi.Input[str]):
        pulumi.set(self, "audience", value)


if not MYPY:
    class DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgsDict(TypedDict):
        """
        DataFlowEndpoint Authentication UserAssignedManagedIdentity properties
        """
        audience: pulumi.Input[str]
        """
        Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        client_id: pulumi.Input[str]
        """
        Client ID for the user-assigned managed identity.
        """
        tenant_id: pulumi.Input[str]
        """
        Tenant ID.
        """
elif False:
    DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgs:
    def __init__(__self__, *,
                 audience: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 tenant_id: pulumi.Input[str]):
        """
        DataFlowEndpoint Authentication UserAssignedManagedIdentity properties
        :param pulumi.Input[str] audience: Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        :param pulumi.Input[str] client_id: Client ID for the user-assigned managed identity.
        :param pulumi.Input[str] tenant_id: Tenant ID.
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def audience(self) -> pulumi.Input[str]:
        """
        Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: pulumi.Input[str]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID for the user-assigned managed identity.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class DataFlowEndpointAuthenticationX509ArgsDict(TypedDict):
        """
        DataFlowEndpoint Authentication X509 properties
        """
        secret_ref: pulumi.Input[str]
        """
        Secret reference of the X.509 certificate.
        """
elif False:
    DataFlowEndpointAuthenticationX509ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointAuthenticationX509Args:
    def __init__(__self__, *,
                 secret_ref: pulumi.Input[str]):
        """
        DataFlowEndpoint Authentication X509 properties
        :param pulumi.Input[str] secret_ref: Secret reference of the X.509 certificate.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[str]:
        """
        Secret reference of the X.509 certificate.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class DataFlowEndpointAuthenticationArgsDict(TypedDict):
        """
        Azure Data Explorer Authentication properties. NOTE - only authentication property is allowed per entry.
        """
        method: pulumi.Input[Union[str, 'AuthenticationMethod']]
        """
        Mode of Authentication.
        """
        access_token_secret_ref: NotRequired[pulumi.Input[str]]
        """
        SAS token authentication.
        """
        sasl_settings: NotRequired[pulumi.Input['DataFlowEndpointAuthenticationSaslArgsDict']]
        """
        SASL authentication.
        """
        service_account_token_settings: NotRequired[pulumi.Input['DataFlowEndpointAuthenticationServiceAccountTokenArgsDict']]
        """
        Service Account Token authentication.
        """
        system_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgsDict']]
        """
        System-assigned managed identity authentication.
        """
        user_assigned_managed_identity_settings: NotRequired[pulumi.Input['DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgsDict']]
        """
        User-assigned managed identity authentication.
        """
        x509_credentials_settings: NotRequired[pulumi.Input['DataFlowEndpointAuthenticationX509ArgsDict']]
        """
        X.509 certificate authentication.
        """
elif False:
    DataFlowEndpointAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointAuthenticationArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[Union[str, 'AuthenticationMethod']],
                 access_token_secret_ref: Optional[pulumi.Input[str]] = None,
                 sasl_settings: Optional[pulumi.Input['DataFlowEndpointAuthenticationSaslArgs']] = None,
                 service_account_token_settings: Optional[pulumi.Input['DataFlowEndpointAuthenticationServiceAccountTokenArgs']] = None,
                 system_assigned_managed_identity_settings: Optional[pulumi.Input['DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgs']] = None,
                 user_assigned_managed_identity_settings: Optional[pulumi.Input['DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgs']] = None,
                 x509_credentials_settings: Optional[pulumi.Input['DataFlowEndpointAuthenticationX509Args']] = None):
        """
        Azure Data Explorer Authentication properties. NOTE - only authentication property is allowed per entry.
        :param pulumi.Input[Union[str, 'AuthenticationMethod']] method: Mode of Authentication.
        :param pulumi.Input[str] access_token_secret_ref: SAS token authentication.
        :param pulumi.Input['DataFlowEndpointAuthenticationSaslArgs'] sasl_settings: SASL authentication.
        :param pulumi.Input['DataFlowEndpointAuthenticationServiceAccountTokenArgs'] service_account_token_settings: Service Account Token authentication.
        :param pulumi.Input['DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgs'] system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param pulumi.Input['DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgs'] user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        :param pulumi.Input['DataFlowEndpointAuthenticationX509Args'] x509_credentials_settings: X.509 certificate authentication.
        """
        pulumi.set(__self__, "method", method)
        if access_token_secret_ref is not None:
            pulumi.set(__self__, "access_token_secret_ref", access_token_secret_ref)
        if sasl_settings is not None:
            pulumi.set(__self__, "sasl_settings", sasl_settings)
        if service_account_token_settings is not None:
            pulumi.set(__self__, "service_account_token_settings", service_account_token_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)
        if x509_credentials_settings is not None:
            pulumi.set(__self__, "x509_credentials_settings", x509_credentials_settings)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[str, 'AuthenticationMethod']]:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[str, 'AuthenticationMethod']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="accessTokenSecretRef")
    def access_token_secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        SAS token authentication.
        """
        return pulumi.get(self, "access_token_secret_ref")

    @access_token_secret_ref.setter
    def access_token_secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_secret_ref", value)

    @property
    @pulumi.getter(name="saslSettings")
    def sasl_settings(self) -> Optional[pulumi.Input['DataFlowEndpointAuthenticationSaslArgs']]:
        """
        SASL authentication.
        """
        return pulumi.get(self, "sasl_settings")

    @sasl_settings.setter
    def sasl_settings(self, value: Optional[pulumi.Input['DataFlowEndpointAuthenticationSaslArgs']]):
        pulumi.set(self, "sasl_settings", value)

    @property
    @pulumi.getter(name="serviceAccountTokenSettings")
    def service_account_token_settings(self) -> Optional[pulumi.Input['DataFlowEndpointAuthenticationServiceAccountTokenArgs']]:
        """
        Service Account Token authentication.
        """
        return pulumi.get(self, "service_account_token_settings")

    @service_account_token_settings.setter
    def service_account_token_settings(self, value: Optional[pulumi.Input['DataFlowEndpointAuthenticationServiceAccountTokenArgs']]):
        pulumi.set(self, "service_account_token_settings", value)

    @property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @system_assigned_managed_identity_settings.setter
    def system_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataFlowEndpointAuthenticationSystemAssignedManagedIdentityArgs']]):
        pulumi.set(self, "system_assigned_managed_identity_settings", value)

    @property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional[pulumi.Input['DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgs']]:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @user_assigned_managed_identity_settings.setter
    def user_assigned_managed_identity_settings(self, value: Optional[pulumi.Input['DataFlowEndpointAuthenticationUserAssignedManagedIdentityArgs']]):
        pulumi.set(self, "user_assigned_managed_identity_settings", value)

    @property
    @pulumi.getter(name="x509CredentialsSettings")
    def x509_credentials_settings(self) -> Optional[pulumi.Input['DataFlowEndpointAuthenticationX509Args']]:
        """
        X.509 certificate authentication.
        """
        return pulumi.get(self, "x509_credentials_settings")

    @x509_credentials_settings.setter
    def x509_credentials_settings(self, value: Optional[pulumi.Input['DataFlowEndpointAuthenticationX509Args']]):
        pulumi.set(self, "x509_credentials_settings", value)


if not MYPY:
    class DataFlowEndpointDataExplorerArgsDict(TypedDict):
        """
        Azure Data Explorer endpoint properties
        """
        database: pulumi.Input[str]
        """
        Database name.
        """
        host: pulumi.Input[str]
        """
        Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        """
        batching: NotRequired[pulumi.Input['BatchingConfigurationArgsDict']]
        """
        Azure Data Explorer endpoint batching configuration.
        """
elif False:
    DataFlowEndpointDataExplorerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointDataExplorerArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 batching: Optional[pulumi.Input['BatchingConfigurationArgs']] = None):
        """
        Azure Data Explorer endpoint properties
        :param pulumi.Input[str] database: Database name.
        :param pulumi.Input[str] host: Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        :param pulumi.Input['BatchingConfigurationArgs'] batching: Azure Data Explorer endpoint batching configuration.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def batching(self) -> Optional[pulumi.Input['BatchingConfigurationArgs']]:
        """
        Azure Data Explorer endpoint batching configuration.
        """
        return pulumi.get(self, "batching")

    @batching.setter
    def batching(self, value: Optional[pulumi.Input['BatchingConfigurationArgs']]):
        pulumi.set(self, "batching", value)


if not MYPY:
    class DataFlowEndpointDataLakeStorageArgsDict(TypedDict):
        """
        Azure Data Lake endpoint properties
        """
        host: pulumi.Input[str]
        """
        Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        """
        batching: NotRequired[pulumi.Input['BatchingConfigurationArgsDict']]
        """
        Azure Data Lake endpoint batching configuration.
        """
elif False:
    DataFlowEndpointDataLakeStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointDataLakeStorageArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 batching: Optional[pulumi.Input['BatchingConfigurationArgs']] = None):
        """
        Azure Data Lake endpoint properties
        :param pulumi.Input[str] host: Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        :param pulumi.Input['BatchingConfigurationArgs'] batching: Azure Data Lake endpoint batching configuration.
        """
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def batching(self) -> Optional[pulumi.Input['BatchingConfigurationArgs']]:
        """
        Azure Data Lake endpoint batching configuration.
        """
        return pulumi.get(self, "batching")

    @batching.setter
    def batching(self, value: Optional[pulumi.Input['BatchingConfigurationArgs']]):
        pulumi.set(self, "batching", value)


if not MYPY:
    class DataFlowEndpointFabricOneLakeNamesArgsDict(TypedDict):
        """
        Microsoft Fabric endpoint Names properties
        """
        lakehouse_name: pulumi.Input[str]
        """
        Lakehouse name.
        """
        workspace_name: pulumi.Input[str]
        """
        Workspace name.
        """
elif False:
    DataFlowEndpointFabricOneLakeNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointFabricOneLakeNamesArgs:
    def __init__(__self__, *,
                 lakehouse_name: pulumi.Input[str],
                 workspace_name: pulumi.Input[str]):
        """
        Microsoft Fabric endpoint Names properties
        :param pulumi.Input[str] lakehouse_name: Lakehouse name.
        :param pulumi.Input[str] workspace_name: Workspace name.
        """
        pulumi.set(__self__, "lakehouse_name", lakehouse_name)
        pulumi.set(__self__, "workspace_name", workspace_name)

    @property
    @pulumi.getter(name="lakehouseName")
    def lakehouse_name(self) -> pulumi.Input[str]:
        """
        Lakehouse name.
        """
        return pulumi.get(self, "lakehouse_name")

    @lakehouse_name.setter
    def lakehouse_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "lakehouse_name", value)

    @property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> pulumi.Input[str]:
        """
        Workspace name.
        """
        return pulumi.get(self, "workspace_name")

    @workspace_name.setter
    def workspace_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_name", value)


if not MYPY:
    class DataFlowEndpointFabricOneLakeArgsDict(TypedDict):
        """
        Microsoft Fabric endpoint properties
        """
        host: pulumi.Input[str]
        """
        Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        """
        names: pulumi.Input['DataFlowEndpointFabricOneLakeNamesArgsDict']
        """
        Names of the workspace and lakehouse.
        """
        one_lake_path_type: pulumi.Input[Union[str, 'DataFlowEndpointFabricPathType']]
        """
        Type of location of the data in the workspace. Can be either tables or files.
        """
        batching: NotRequired[pulumi.Input['BatchingConfigurationArgsDict']]
        """
        Batching configuration.
        """
elif False:
    DataFlowEndpointFabricOneLakeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointFabricOneLakeArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 names: pulumi.Input['DataFlowEndpointFabricOneLakeNamesArgs'],
                 one_lake_path_type: pulumi.Input[Union[str, 'DataFlowEndpointFabricPathType']],
                 batching: Optional[pulumi.Input['BatchingConfigurationArgs']] = None):
        """
        Microsoft Fabric endpoint properties
        :param pulumi.Input[str] host: Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        :param pulumi.Input['DataFlowEndpointFabricOneLakeNamesArgs'] names: Names of the workspace and lakehouse.
        :param pulumi.Input[Union[str, 'DataFlowEndpointFabricPathType']] one_lake_path_type: Type of location of the data in the workspace. Can be either tables or files.
        :param pulumi.Input['BatchingConfigurationArgs'] batching: Batching configuration.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "one_lake_path_type", one_lake_path_type)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def names(self) -> pulumi.Input['DataFlowEndpointFabricOneLakeNamesArgs']:
        """
        Names of the workspace and lakehouse.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: pulumi.Input['DataFlowEndpointFabricOneLakeNamesArgs']):
        pulumi.set(self, "names", value)

    @property
    @pulumi.getter(name="oneLakePathType")
    def one_lake_path_type(self) -> pulumi.Input[Union[str, 'DataFlowEndpointFabricPathType']]:
        """
        Type of location of the data in the workspace. Can be either tables or files.
        """
        return pulumi.get(self, "one_lake_path_type")

    @one_lake_path_type.setter
    def one_lake_path_type(self, value: pulumi.Input[Union[str, 'DataFlowEndpointFabricPathType']]):
        pulumi.set(self, "one_lake_path_type", value)

    @property
    @pulumi.getter
    def batching(self) -> Optional[pulumi.Input['BatchingConfigurationArgs']]:
        """
        Batching configuration.
        """
        return pulumi.get(self, "batching")

    @batching.setter
    def batching(self, value: Optional[pulumi.Input['BatchingConfigurationArgs']]):
        pulumi.set(self, "batching", value)


if not MYPY:
    class DataFlowEndpointKafkaBatchingArgsDict(TypedDict):
        """
        Kafka endpoint Batching properties
        """
        latency_ms: NotRequired[pulumi.Input[int]]
        """
        Batching latency in milliseconds.
        """
        max_bytes: NotRequired[pulumi.Input[int]]
        """
        Maximum number of bytes in a batch.
        """
        max_messages: NotRequired[pulumi.Input[int]]
        """
        Maximum number of messages in a batch.
        """
        mode: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        Mode for batching.
        """
elif False:
    DataFlowEndpointKafkaBatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointKafkaBatchingArgs:
    def __init__(__self__, *,
                 latency_ms: Optional[pulumi.Input[int]] = None,
                 max_bytes: Optional[pulumi.Input[int]] = None,
                 max_messages: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None):
        """
        Kafka endpoint Batching properties
        :param pulumi.Input[int] latency_ms: Batching latency in milliseconds.
        :param pulumi.Input[int] max_bytes: Maximum number of bytes in a batch.
        :param pulumi.Input[int] max_messages: Maximum number of messages in a batch.
        :param pulumi.Input[Union[str, 'OperationalMode']] mode: Mode for batching.
        """
        if latency_ms is None:
            latency_ms = 5
        if latency_ms is not None:
            pulumi.set(__self__, "latency_ms", latency_ms)
        if max_bytes is None:
            max_bytes = 1000000
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="latencyMs")
    def latency_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Batching latency in milliseconds.
        """
        return pulumi.get(self, "latency_ms")

    @latency_ms.setter
    def latency_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "latency_ms", value)

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of bytes in a batch.
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes", value)

    @property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of messages in a batch.
        """
        return pulumi.get(self, "max_messages")

    @max_messages.setter
    def max_messages(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_messages", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        Mode for batching.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class DataFlowEndpointKafkaArgsDict(TypedDict):
        """
        Kafka endpoint properties
        """
        tls: pulumi.Input['TlsPropertiesArgsDict']
        """
        TLS configuration.
        """
        batching: NotRequired[pulumi.Input['DataFlowEndpointKafkaBatchingArgsDict']]
        """
        Batching configuration.
        """
        compression: NotRequired[pulumi.Input[Union[str, 'DataFlowEndpointKafkaCompression']]]
        """
        Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        """
        consumer_group_id: NotRequired[pulumi.Input[str]]
        """
        Consumer group ID.
        """
        copy_mqtt_properties: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Kafka endpoint host.
        """
        kafka_acks: NotRequired[pulumi.Input[Union[str, 'DataFlowEndpointKafkaAcks']]]
        """
        Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        """
        partition_strategy: NotRequired[pulumi.Input[Union[str, 'DataFlowEndpointKafkaPartitionStrategy']]]
        """
        Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        """
elif False:
    DataFlowEndpointKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointKafkaArgs:
    def __init__(__self__, *,
                 tls: pulumi.Input['TlsPropertiesArgs'],
                 batching: Optional[pulumi.Input['DataFlowEndpointKafkaBatchingArgs']] = None,
                 compression: Optional[pulumi.Input[Union[str, 'DataFlowEndpointKafkaCompression']]] = None,
                 consumer_group_id: Optional[pulumi.Input[str]] = None,
                 copy_mqtt_properties: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 kafka_acks: Optional[pulumi.Input[Union[str, 'DataFlowEndpointKafkaAcks']]] = None,
                 partition_strategy: Optional[pulumi.Input[Union[str, 'DataFlowEndpointKafkaPartitionStrategy']]] = None):
        """
        Kafka endpoint properties
        :param pulumi.Input['TlsPropertiesArgs'] tls: TLS configuration.
        :param pulumi.Input['DataFlowEndpointKafkaBatchingArgs'] batching: Batching configuration.
        :param pulumi.Input[Union[str, 'DataFlowEndpointKafkaCompression']] compression: Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        :param pulumi.Input[str] consumer_group_id: Consumer group ID.
        :param pulumi.Input[Union[str, 'OperationalMode']] copy_mqtt_properties: Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        :param pulumi.Input[str] host: Kafka endpoint host.
        :param pulumi.Input[Union[str, 'DataFlowEndpointKafkaAcks']] kafka_acks: Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        :param pulumi.Input[Union[str, 'DataFlowEndpointKafkaPartitionStrategy']] partition_strategy: Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        """
        pulumi.set(__self__, "tls", tls)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)
        if compression is None:
            compression = 'None'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if copy_mqtt_properties is None:
            copy_mqtt_properties = 'Disabled'
        if copy_mqtt_properties is not None:
            pulumi.set(__self__, "copy_mqtt_properties", copy_mqtt_properties)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if kafka_acks is None:
            kafka_acks = 'All'
        if kafka_acks is not None:
            pulumi.set(__self__, "kafka_acks", kafka_acks)
        if partition_strategy is None:
            partition_strategy = 'Default'
        if partition_strategy is not None:
            pulumi.set(__self__, "partition_strategy", partition_strategy)

    @property
    @pulumi.getter
    def tls(self) -> pulumi.Input['TlsPropertiesArgs']:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: pulumi.Input['TlsPropertiesArgs']):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def batching(self) -> Optional[pulumi.Input['DataFlowEndpointKafkaBatchingArgs']]:
        """
        Batching configuration.
        """
        return pulumi.get(self, "batching")

    @batching.setter
    def batching(self, value: Optional[pulumi.Input['DataFlowEndpointKafkaBatchingArgs']]):
        pulumi.set(self, "batching", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[Union[str, 'DataFlowEndpointKafkaCompression']]]:
        """
        Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[Union[str, 'DataFlowEndpointKafkaCompression']]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Consumer group ID.
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)

    @property
    @pulumi.getter(name="copyMqttProperties")
    def copy_mqtt_properties(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        """
        return pulumi.get(self, "copy_mqtt_properties")

    @copy_mqtt_properties.setter
    def copy_mqtt_properties(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "copy_mqtt_properties", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka endpoint host.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="kafkaAcks")
    def kafka_acks(self) -> Optional[pulumi.Input[Union[str, 'DataFlowEndpointKafkaAcks']]]:
        """
        Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "kafka_acks")

    @kafka_acks.setter
    def kafka_acks(self, value: Optional[pulumi.Input[Union[str, 'DataFlowEndpointKafkaAcks']]]):
        pulumi.set(self, "kafka_acks", value)

    @property
    @pulumi.getter(name="partitionStrategy")
    def partition_strategy(self) -> Optional[pulumi.Input[Union[str, 'DataFlowEndpointKafkaPartitionStrategy']]]:
        """
        Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "partition_strategy")

    @partition_strategy.setter
    def partition_strategy(self, value: Optional[pulumi.Input[Union[str, 'DataFlowEndpointKafkaPartitionStrategy']]]):
        pulumi.set(self, "partition_strategy", value)


if not MYPY:
    class DataFlowEndpointLocalStorageArgsDict(TypedDict):
        """
        Local persistent volume endpoint properties
        """
        persistent_volume_claim_ref: pulumi.Input[str]
        """
        Persistent volume claim name.
        """
elif False:
    DataFlowEndpointLocalStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointLocalStorageArgs:
    def __init__(__self__, *,
                 persistent_volume_claim_ref: pulumi.Input[str]):
        """
        Local persistent volume endpoint properties
        :param pulumi.Input[str] persistent_volume_claim_ref: Persistent volume claim name.
        """
        pulumi.set(__self__, "persistent_volume_claim_ref", persistent_volume_claim_ref)

    @property
    @pulumi.getter(name="persistentVolumeClaimRef")
    def persistent_volume_claim_ref(self) -> pulumi.Input[str]:
        """
        Persistent volume claim name.
        """
        return pulumi.get(self, "persistent_volume_claim_ref")

    @persistent_volume_claim_ref.setter
    def persistent_volume_claim_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "persistent_volume_claim_ref", value)


if not MYPY:
    class DataFlowEndpointMqttArgsDict(TypedDict):
        """
        Broker endpoint properties
        """
        client_id_prefix: NotRequired[pulumi.Input[str]]
        """
        Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        """
        keep_alive_seconds: NotRequired[pulumi.Input[int]]
        """
        Broker KeepAlive for connection in seconds.
        """
        max_inflight_messages: NotRequired[pulumi.Input[int]]
        """
        The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        """
        protocol: NotRequired[pulumi.Input[Union[str, 'BrokerProtocolType']]]
        """
        Enable or disable websockets.
        """
        qos: NotRequired[pulumi.Input[int]]
        """
        Qos for Broker connection.
        """
        retain: NotRequired[pulumi.Input[Union[str, 'MqttRetainType']]]
        """
        Whether or not to keep the retain setting.
        """
        session_expiry_seconds: NotRequired[pulumi.Input[int]]
        """
        Session expiry in seconds.
        """
        tls: NotRequired[pulumi.Input['TlsPropertiesArgsDict']]
        """
        TLS configuration.
        """
elif False:
    DataFlowEndpointMqttArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointMqttArgs:
    def __init__(__self__, *,
                 client_id_prefix: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 keep_alive_seconds: Optional[pulumi.Input[int]] = None,
                 max_inflight_messages: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[Union[str, 'BrokerProtocolType']]] = None,
                 qos: Optional[pulumi.Input[int]] = None,
                 retain: Optional[pulumi.Input[Union[str, 'MqttRetainType']]] = None,
                 session_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 tls: Optional[pulumi.Input['TlsPropertiesArgs']] = None):
        """
        Broker endpoint properties
        :param pulumi.Input[str] client_id_prefix: Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        :param pulumi.Input[str] host: Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        :param pulumi.Input[int] keep_alive_seconds: Broker KeepAlive for connection in seconds.
        :param pulumi.Input[int] max_inflight_messages: The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        :param pulumi.Input[Union[str, 'BrokerProtocolType']] protocol: Enable or disable websockets.
        :param pulumi.Input[int] qos: Qos for Broker connection.
        :param pulumi.Input[Union[str, 'MqttRetainType']] retain: Whether or not to keep the retain setting.
        :param pulumi.Input[int] session_expiry_seconds: Session expiry in seconds.
        :param pulumi.Input['TlsPropertiesArgs'] tls: TLS configuration.
        """
        if client_id_prefix is not None:
            pulumi.set(__self__, "client_id_prefix", client_id_prefix)
        if host is None:
            host = 'aio-mq-dmqtt-frontend:1883'
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_alive_seconds is None:
            keep_alive_seconds = 60
        if keep_alive_seconds is not None:
            pulumi.set(__self__, "keep_alive_seconds", keep_alive_seconds)
        if max_inflight_messages is None:
            max_inflight_messages = 100
        if max_inflight_messages is not None:
            pulumi.set(__self__, "max_inflight_messages", max_inflight_messages)
        if protocol is None:
            protocol = 'Mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if retain is None:
            retain = 'Keep'
        if retain is not None:
            pulumi.set(__self__, "retain", retain)
        if session_expiry_seconds is None:
            session_expiry_seconds = 3600
        if session_expiry_seconds is not None:
            pulumi.set(__self__, "session_expiry_seconds", session_expiry_seconds)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="clientIdPrefix")
    def client_id_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        """
        return pulumi.get(self, "client_id_prefix")

    @client_id_prefix.setter
    def client_id_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id_prefix", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="keepAliveSeconds")
    def keep_alive_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Broker KeepAlive for connection in seconds.
        """
        return pulumi.get(self, "keep_alive_seconds")

    @keep_alive_seconds.setter
    def keep_alive_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive_seconds", value)

    @property
    @pulumi.getter(name="maxInflightMessages")
    def max_inflight_messages(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        """
        return pulumi.get(self, "max_inflight_messages")

    @max_inflight_messages.setter
    def max_inflight_messages(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_inflight_messages", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[str, 'BrokerProtocolType']]]:
        """
        Enable or disable websockets.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[str, 'BrokerProtocolType']]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[int]]:
        """
        Qos for Broker connection.
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qos", value)

    @property
    @pulumi.getter
    def retain(self) -> Optional[pulumi.Input[Union[str, 'MqttRetainType']]]:
        """
        Whether or not to keep the retain setting.
        """
        return pulumi.get(self, "retain")

    @retain.setter
    def retain(self, value: Optional[pulumi.Input[Union[str, 'MqttRetainType']]]):
        pulumi.set(self, "retain", value)

    @property
    @pulumi.getter(name="sessionExpirySeconds")
    def session_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Session expiry in seconds.
        """
        return pulumi.get(self, "session_expiry_seconds")

    @session_expiry_seconds.setter
    def session_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_expiry_seconds", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['TlsPropertiesArgs']]:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['TlsPropertiesArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class DataFlowEndpointPropertiesArgsDict(TypedDict):
        """
        DataFlowEndpoint Resource properties. NOTE - Only one type of endpoint is supported for one Resource
        """
        authentication: pulumi.Input['DataFlowEndpointAuthenticationArgsDict']
        """
        Authentication configuration.
        """
        endpoint_type: pulumi.Input[Union[str, 'EndpointType']]
        """
        Endpoint Type.
        """
        data_explorer_settings: NotRequired[pulumi.Input['DataFlowEndpointDataExplorerArgsDict']]
        """
        Azure Data Explorer endpoint.
        """
        data_lake_storage_settings: NotRequired[pulumi.Input['DataFlowEndpointDataLakeStorageArgsDict']]
        """
        Azure Data Lake endpoint.
        """
        fabric_one_lake_settings: NotRequired[pulumi.Input['DataFlowEndpointFabricOneLakeArgsDict']]
        """
        Microsoft Fabric endpoint.
        """
        kafka_settings: NotRequired[pulumi.Input['DataFlowEndpointKafkaArgsDict']]
        """
        Kafka endpoint.
        """
        local_storage_settings: NotRequired[pulumi.Input['DataFlowEndpointLocalStorageArgsDict']]
        """
        Local persistent volume endpoint.
        """
        mqtt_settings: NotRequired[pulumi.Input['DataFlowEndpointMqttArgsDict']]
        """
        Broker endpoint.
        """
elif False:
    DataFlowEndpointPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowEndpointPropertiesArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['DataFlowEndpointAuthenticationArgs'],
                 endpoint_type: pulumi.Input[Union[str, 'EndpointType']],
                 data_explorer_settings: Optional[pulumi.Input['DataFlowEndpointDataExplorerArgs']] = None,
                 data_lake_storage_settings: Optional[pulumi.Input['DataFlowEndpointDataLakeStorageArgs']] = None,
                 fabric_one_lake_settings: Optional[pulumi.Input['DataFlowEndpointFabricOneLakeArgs']] = None,
                 kafka_settings: Optional[pulumi.Input['DataFlowEndpointKafkaArgs']] = None,
                 local_storage_settings: Optional[pulumi.Input['DataFlowEndpointLocalStorageArgs']] = None,
                 mqtt_settings: Optional[pulumi.Input['DataFlowEndpointMqttArgs']] = None):
        """
        DataFlowEndpoint Resource properties. NOTE - Only one type of endpoint is supported for one Resource
        :param pulumi.Input['DataFlowEndpointAuthenticationArgs'] authentication: Authentication configuration.
        :param pulumi.Input[Union[str, 'EndpointType']] endpoint_type: Endpoint Type.
        :param pulumi.Input['DataFlowEndpointDataExplorerArgs'] data_explorer_settings: Azure Data Explorer endpoint.
        :param pulumi.Input['DataFlowEndpointDataLakeStorageArgs'] data_lake_storage_settings: Azure Data Lake endpoint.
        :param pulumi.Input['DataFlowEndpointFabricOneLakeArgs'] fabric_one_lake_settings: Microsoft Fabric endpoint.
        :param pulumi.Input['DataFlowEndpointKafkaArgs'] kafka_settings: Kafka endpoint.
        :param pulumi.Input['DataFlowEndpointLocalStorageArgs'] local_storage_settings: Local persistent volume endpoint.
        :param pulumi.Input['DataFlowEndpointMqttArgs'] mqtt_settings: Broker endpoint.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        if data_explorer_settings is not None:
            pulumi.set(__self__, "data_explorer_settings", data_explorer_settings)
        if data_lake_storage_settings is not None:
            pulumi.set(__self__, "data_lake_storage_settings", data_lake_storage_settings)
        if fabric_one_lake_settings is not None:
            pulumi.set(__self__, "fabric_one_lake_settings", fabric_one_lake_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if local_storage_settings is not None:
            pulumi.set(__self__, "local_storage_settings", local_storage_settings)
        if mqtt_settings is not None:
            pulumi.set(__self__, "mqtt_settings", mqtt_settings)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['DataFlowEndpointAuthenticationArgs']:
        """
        Authentication configuration.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['DataFlowEndpointAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[Union[str, 'EndpointType']]:
        """
        Endpoint Type.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[Union[str, 'EndpointType']]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="dataExplorerSettings")
    def data_explorer_settings(self) -> Optional[pulumi.Input['DataFlowEndpointDataExplorerArgs']]:
        """
        Azure Data Explorer endpoint.
        """
        return pulumi.get(self, "data_explorer_settings")

    @data_explorer_settings.setter
    def data_explorer_settings(self, value: Optional[pulumi.Input['DataFlowEndpointDataExplorerArgs']]):
        pulumi.set(self, "data_explorer_settings", value)

    @property
    @pulumi.getter(name="dataLakeStorageSettings")
    def data_lake_storage_settings(self) -> Optional[pulumi.Input['DataFlowEndpointDataLakeStorageArgs']]:
        """
        Azure Data Lake endpoint.
        """
        return pulumi.get(self, "data_lake_storage_settings")

    @data_lake_storage_settings.setter
    def data_lake_storage_settings(self, value: Optional[pulumi.Input['DataFlowEndpointDataLakeStorageArgs']]):
        pulumi.set(self, "data_lake_storage_settings", value)

    @property
    @pulumi.getter(name="fabricOneLakeSettings")
    def fabric_one_lake_settings(self) -> Optional[pulumi.Input['DataFlowEndpointFabricOneLakeArgs']]:
        """
        Microsoft Fabric endpoint.
        """
        return pulumi.get(self, "fabric_one_lake_settings")

    @fabric_one_lake_settings.setter
    def fabric_one_lake_settings(self, value: Optional[pulumi.Input['DataFlowEndpointFabricOneLakeArgs']]):
        pulumi.set(self, "fabric_one_lake_settings", value)

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[pulumi.Input['DataFlowEndpointKafkaArgs']]:
        """
        Kafka endpoint.
        """
        return pulumi.get(self, "kafka_settings")

    @kafka_settings.setter
    def kafka_settings(self, value: Optional[pulumi.Input['DataFlowEndpointKafkaArgs']]):
        pulumi.set(self, "kafka_settings", value)

    @property
    @pulumi.getter(name="localStorageSettings")
    def local_storage_settings(self) -> Optional[pulumi.Input['DataFlowEndpointLocalStorageArgs']]:
        """
        Local persistent volume endpoint.
        """
        return pulumi.get(self, "local_storage_settings")

    @local_storage_settings.setter
    def local_storage_settings(self, value: Optional[pulumi.Input['DataFlowEndpointLocalStorageArgs']]):
        pulumi.set(self, "local_storage_settings", value)

    @property
    @pulumi.getter(name="mqttSettings")
    def mqtt_settings(self) -> Optional[pulumi.Input['DataFlowEndpointMqttArgs']]:
        """
        Broker endpoint.
        """
        return pulumi.get(self, "mqtt_settings")

    @mqtt_settings.setter
    def mqtt_settings(self, value: Optional[pulumi.Input['DataFlowEndpointMqttArgs']]):
        pulumi.set(self, "mqtt_settings", value)


if not MYPY:
    class DataFlowOperationArgsDict(TypedDict):
        """
        DataFlow Operation properties. NOTE - One only method is allowed to be used for one entry.
        """
        destination_settings: pulumi.Input['DataFlowDestinationOperationArgsDict']
        """
        Destination configuration.
        """
        operation_type: pulumi.Input[Union[str, 'OperationType']]
        """
        Type of operation.
        """
        source_settings: pulumi.Input['DataFlowSourceOperationArgsDict']
        """
        Source configuration.
        """
        built_in_transformation_settings: NotRequired[pulumi.Input['DataFlowBuiltInTransformationArgsDict']]
        """
        Transformation configuration.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Optional user provided name of the transformation.
        """
elif False:
    DataFlowOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowOperationArgs:
    def __init__(__self__, *,
                 destination_settings: pulumi.Input['DataFlowDestinationOperationArgs'],
                 operation_type: pulumi.Input[Union[str, 'OperationType']],
                 source_settings: pulumi.Input['DataFlowSourceOperationArgs'],
                 built_in_transformation_settings: Optional[pulumi.Input['DataFlowBuiltInTransformationArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        DataFlow Operation properties. NOTE - One only method is allowed to be used for one entry.
        :param pulumi.Input['DataFlowDestinationOperationArgs'] destination_settings: Destination configuration.
        :param pulumi.Input[Union[str, 'OperationType']] operation_type: Type of operation.
        :param pulumi.Input['DataFlowSourceOperationArgs'] source_settings: Source configuration.
        :param pulumi.Input['DataFlowBuiltInTransformationArgs'] built_in_transformation_settings: Transformation configuration.
        :param pulumi.Input[str] name: Optional user provided name of the transformation.
        """
        pulumi.set(__self__, "destination_settings", destination_settings)
        pulumi.set(__self__, "operation_type", operation_type)
        pulumi.set(__self__, "source_settings", source_settings)
        if built_in_transformation_settings is not None:
            pulumi.set(__self__, "built_in_transformation_settings", built_in_transformation_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="destinationSettings")
    def destination_settings(self) -> pulumi.Input['DataFlowDestinationOperationArgs']:
        """
        Destination configuration.
        """
        return pulumi.get(self, "destination_settings")

    @destination_settings.setter
    def destination_settings(self, value: pulumi.Input['DataFlowDestinationOperationArgs']):
        pulumi.set(self, "destination_settings", value)

    @property
    @pulumi.getter(name="operationType")
    def operation_type(self) -> pulumi.Input[Union[str, 'OperationType']]:
        """
        Type of operation.
        """
        return pulumi.get(self, "operation_type")

    @operation_type.setter
    def operation_type(self, value: pulumi.Input[Union[str, 'OperationType']]):
        pulumi.set(self, "operation_type", value)

    @property
    @pulumi.getter(name="sourceSettings")
    def source_settings(self) -> pulumi.Input['DataFlowSourceOperationArgs']:
        """
        Source configuration.
        """
        return pulumi.get(self, "source_settings")

    @source_settings.setter
    def source_settings(self, value: pulumi.Input['DataFlowSourceOperationArgs']):
        pulumi.set(self, "source_settings", value)

    @property
    @pulumi.getter(name="builtInTransformationSettings")
    def built_in_transformation_settings(self) -> Optional[pulumi.Input['DataFlowBuiltInTransformationArgs']]:
        """
        Transformation configuration.
        """
        return pulumi.get(self, "built_in_transformation_settings")

    @built_in_transformation_settings.setter
    def built_in_transformation_settings(self, value: Optional[pulumi.Input['DataFlowBuiltInTransformationArgs']]):
        pulumi.set(self, "built_in_transformation_settings", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Optional user provided name of the transformation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DataFlowProfilePropertiesArgsDict(TypedDict):
        """
        DataFlowProfile Resource properties
        """
        diagnostics: NotRequired[pulumi.Input['ProfileDiagnosticsArgsDict']]
        """
        Spec defines the desired identities of NBC diagnostics settings.
        """
        instance_count: NotRequired[pulumi.Input[int]]
        """
        To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
elif False:
    DataFlowProfilePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowProfilePropertiesArgs:
    def __init__(__self__, *,
                 diagnostics: Optional[pulumi.Input['ProfileDiagnosticsArgs']] = None,
                 instance_count: Optional[pulumi.Input[int]] = None):
        """
        DataFlowProfile Resource properties
        :param pulumi.Input['ProfileDiagnosticsArgs'] diagnostics: Spec defines the desired identities of NBC diagnostics settings.
        :param pulumi.Input[int] instance_count: To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)

    @property
    @pulumi.getter
    def diagnostics(self) -> Optional[pulumi.Input['ProfileDiagnosticsArgs']]:
        """
        Spec defines the desired identities of NBC diagnostics settings.
        """
        return pulumi.get(self, "diagnostics")

    @diagnostics.setter
    def diagnostics(self, value: Optional[pulumi.Input['ProfileDiagnosticsArgs']]):
        pulumi.set(self, "diagnostics", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)


if not MYPY:
    class DataFlowPropertiesArgsDict(TypedDict):
        """
        DataFlow Resource properties
        """
        operations: pulumi.Input[Sequence[pulumi.Input['DataFlowOperationArgsDict']]]
        """
        List of operations including source and destination references as well as transformation.
        """
        profile_ref: pulumi.Input[str]
        """
        Reference to the DataflowProfile CR.
        """
        mode: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        Mode for DataFlow. Optional; defaults to Enabled.
        """
elif False:
    DataFlowPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowPropertiesArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input['DataFlowOperationArgs']]],
                 profile_ref: pulumi.Input[str],
                 mode: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None):
        """
        DataFlow Resource properties
        :param pulumi.Input[Sequence[pulumi.Input['DataFlowOperationArgs']]] operations: List of operations including source and destination references as well as transformation.
        :param pulumi.Input[str] profile_ref: Reference to the DataflowProfile CR.
        :param pulumi.Input[Union[str, 'OperationalMode']] mode: Mode for DataFlow. Optional; defaults to Enabled.
        """
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "profile_ref", profile_ref)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input['DataFlowOperationArgs']]]:
        """
        List of operations including source and destination references as well as transformation.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input['DataFlowOperationArgs']]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter(name="profileRef")
    def profile_ref(self) -> pulumi.Input[str]:
        """
        Reference to the DataflowProfile CR.
        """
        return pulumi.get(self, "profile_ref")

    @profile_ref.setter
    def profile_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "profile_ref", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        Mode for DataFlow. Optional; defaults to Enabled.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class DataFlowSourceOperationArgsDict(TypedDict):
        """
        DataFlow Source Operation properties
        """
        data_sources: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        """
        endpoint_ref: pulumi.Input[str]
        """
        Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        """
        asset_ref: NotRequired[pulumi.Input[str]]
        """
        Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        schema_ref: NotRequired[pulumi.Input[str]]
        """
        Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        """
        serialization_format: NotRequired[pulumi.Input[Union[str, 'SourceSerializationFormat']]]
        """
        Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
elif False:
    DataFlowSourceOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataFlowSourceOperationArgs:
    def __init__(__self__, *,
                 data_sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 endpoint_ref: pulumi.Input[str],
                 asset_ref: Optional[pulumi.Input[str]] = None,
                 schema_ref: Optional[pulumi.Input[str]] = None,
                 serialization_format: Optional[pulumi.Input[Union[str, 'SourceSerializationFormat']]] = None):
        """
        DataFlow Source Operation properties
        :param pulumi.Input[Sequence[pulumi.Input[str]]] data_sources: List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        :param pulumi.Input[str] endpoint_ref: Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        :param pulumi.Input[str] asset_ref: Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        :param pulumi.Input[str] schema_ref: Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        :param pulumi.Input[Union[str, 'SourceSerializationFormat']] serialization_format: Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)
        if asset_ref is not None:
            pulumi.set(__self__, "asset_ref", asset_ref)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is None:
            serialization_format = 'Json'
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        """
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> pulumi.Input[str]:
        """
        Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        """
        return pulumi.get(self, "endpoint_ref")

    @endpoint_ref.setter
    def endpoint_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_ref", value)

    @property
    @pulumi.getter(name="assetRef")
    def asset_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        return pulumi.get(self, "asset_ref")

    @asset_ref.setter
    def asset_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "asset_ref", value)

    @property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        """
        return pulumi.get(self, "schema_ref")

    @schema_ref.setter
    def schema_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_ref", value)

    @property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[pulumi.Input[Union[str, 'SourceSerializationFormat']]]:
        """
        Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
        return pulumi.get(self, "serialization_format")

    @serialization_format.setter
    def serialization_format(self, value: Optional[pulumi.Input[Union[str, 'SourceSerializationFormat']]]):
        pulumi.set(self, "serialization_format", value)


if not MYPY:
    class DiagnosticsLogsArgsDict(TypedDict):
        """
        Diagnostic Log properties
        """
        level: NotRequired[pulumi.Input[str]]
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        opentelemetry_export_config: NotRequired[pulumi.Input['OpenTelemetryLogExportConfigArgsDict']]
        """
        The open telemetry export configuration.
        """
elif False:
    DiagnosticsLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosticsLogsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 opentelemetry_export_config: Optional[pulumi.Input['OpenTelemetryLogExportConfigArgs']] = None):
        """
        Diagnostic Log properties
        :param pulumi.Input[str] level: The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        :param pulumi.Input['OpenTelemetryLogExportConfigArgs'] opentelemetry_export_config: The open telemetry export configuration.
        """
        if level is None:
            level = 'info'
        if level is not None:
            pulumi.set(__self__, "level", level)
        if opentelemetry_export_config is not None:
            pulumi.set(__self__, "opentelemetry_export_config", opentelemetry_export_config)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="opentelemetryExportConfig")
    def opentelemetry_export_config(self) -> Optional[pulumi.Input['OpenTelemetryLogExportConfigArgs']]:
        """
        The open telemetry export configuration.
        """
        return pulumi.get(self, "opentelemetry_export_config")

    @opentelemetry_export_config.setter
    def opentelemetry_export_config(self, value: Optional[pulumi.Input['OpenTelemetryLogExportConfigArgs']]):
        pulumi.set(self, "opentelemetry_export_config", value)


if not MYPY:
    class DiskBackedMessageBufferArgsDict(TypedDict):
        """
        DiskBackedMessageBuffer properties
        """
        max_size: pulumi.Input[str]
        """
        The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        """
        ephemeral_volume_claim_spec: NotRequired[pulumi.Input['VolumeClaimSpecArgsDict']]
        """
        Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        """
        persistent_volume_claim_spec: NotRequired[pulumi.Input['VolumeClaimSpecArgsDict']]
        """
        Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
elif False:
    DiskBackedMessageBufferArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiskBackedMessageBufferArgs:
    def __init__(__self__, *,
                 max_size: pulumi.Input[str],
                 ephemeral_volume_claim_spec: Optional[pulumi.Input['VolumeClaimSpecArgs']] = None,
                 persistent_volume_claim_spec: Optional[pulumi.Input['VolumeClaimSpecArgs']] = None):
        """
        DiskBackedMessageBuffer properties
        :param pulumi.Input[str] max_size: The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        :param pulumi.Input['VolumeClaimSpecArgs'] ephemeral_volume_claim_spec: Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        :param pulumi.Input['VolumeClaimSpecArgs'] persistent_volume_claim_spec: Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        pulumi.set(__self__, "max_size", max_size)
        if ephemeral_volume_claim_spec is not None:
            pulumi.set(__self__, "ephemeral_volume_claim_spec", ephemeral_volume_claim_spec)
        if persistent_volume_claim_spec is not None:
            pulumi.set(__self__, "persistent_volume_claim_spec", persistent_volume_claim_spec)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> pulumi.Input[str]:
        """
        The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter(name="ephemeralVolumeClaimSpec")
    def ephemeral_volume_claim_spec(self) -> Optional[pulumi.Input['VolumeClaimSpecArgs']]:
        """
        Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        """
        return pulumi.get(self, "ephemeral_volume_claim_spec")

    @ephemeral_volume_claim_spec.setter
    def ephemeral_volume_claim_spec(self, value: Optional[pulumi.Input['VolumeClaimSpecArgs']]):
        pulumi.set(self, "ephemeral_volume_claim_spec", value)

    @property
    @pulumi.getter(name="persistentVolumeClaimSpec")
    def persistent_volume_claim_spec(self) -> Optional[pulumi.Input['VolumeClaimSpecArgs']]:
        """
        Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        return pulumi.get(self, "persistent_volume_claim_spec")

    @persistent_volume_claim_spec.setter
    def persistent_volume_claim_spec(self, value: Optional[pulumi.Input['VolumeClaimSpecArgs']]):
        pulumi.set(self, "persistent_volume_claim_spec", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        Extended location is an extension of Azure locations. They provide a way to use their Azure ARC enabled Kubernetes clusters as target locations for deploying Azure services instances.
        """
        name: pulumi.Input[str]
        """
        The name of the extended location.
        """
        type: pulumi.Input[Union[str, 'ExtendedLocationType']]
        """
        Type of ExtendedLocation.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[Union[str, 'ExtendedLocationType']]):
        """
        Extended location is an extension of Azure locations. They provide a way to use their Azure ARC enabled Kubernetes clusters as target locations for deploying Azure services instances.
        :param pulumi.Input[str] name: The name of the extended location.
        :param pulumi.Input[Union[str, 'ExtendedLocationType']] type: Type of ExtendedLocation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ExtendedLocationType']]:
        """
        Type of ExtendedLocation.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ExtendedLocationType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FrontendArgsDict(TypedDict):
        """
        The desired properties of the frontend instances of the Broker
        """
        replicas: pulumi.Input[int]
        """
        The desired number of frontend instances (pods).
        """
        workers: NotRequired[pulumi.Input[int]]
        """
        Number of logical frontend workers per instance (pod).
        """
elif False:
    FrontendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontendArgs:
    def __init__(__self__, *,
                 replicas: pulumi.Input[int],
                 workers: Optional[pulumi.Input[int]] = None):
        """
        The desired properties of the frontend instances of the Broker
        :param pulumi.Input[int] replicas: The desired number of frontend instances (pods).
        :param pulumi.Input[int] workers: Number of logical frontend workers per instance (pod).
        """
        pulumi.set(__self__, "replicas", replicas)
        if workers is None:
            workers = 2
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter
    def replicas(self) -> pulumi.Input[int]:
        """
        The desired number of frontend instances (pods).
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: pulumi.Input[int]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input[int]]:
        """
        Number of logical frontend workers per instance (pod).
        """
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "workers", value)


if not MYPY:
    class GenerateResourceLimitsArgsDict(TypedDict):
        """
        GenerateResourceLimits properties
        """
        cpu: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        The toggle to enable/disable cpu resource limits.
        """
elif False:
    GenerateResourceLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenerateResourceLimitsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None):
        """
        GenerateResourceLimits properties
        :param pulumi.Input[Union[str, 'OperationalMode']] cpu: The toggle to enable/disable cpu resource limits.
        """
        if cpu is None:
            cpu = 'Enabled'
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        The toggle to enable/disable cpu resource limits.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "cpu", value)


if not MYPY:
    class InstancePropertiesArgsDict(TypedDict):
        """
        The properties of a Instance resource.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Detailed description of the Instance.
        """
elif False:
    InstancePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePropertiesArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None):
        """
        The properties of a Instance resource.
        :param pulumi.Input[str] description: Detailed description of the Instance.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Detailed description of the Instance.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class KubernetesReferenceArgsDict(TypedDict):
        """
        Kubernetes reference
        """
        kind: pulumi.Input[str]
        """
        Kind is the type of resource being referenced
        """
        name: pulumi.Input[str]
        """
        Name is the name of resource being referenced
        """
        api_group: NotRequired[pulumi.Input[str]]
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
elif False:
    KubernetesReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesReferenceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 name: pulumi.Input[str],
                 api_group: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        Kubernetes reference
        :param pulumi.Input[str] kind: Kind is the type of resource being referenced
        :param pulumi.Input[str] name: Name is the name of resource being referenced
        :param pulumi.Input[str] api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        :param pulumi.Input[str] namespace: Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[pulumi.Input[str]]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")

    @api_group.setter
    def api_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_group", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ListenerPortArgsDict(TypedDict):
        """
        Defines a TCP port on which a `BrokerListener` listens.
        """
        port: pulumi.Input[int]
        """
        TCP port for accepting client connections.
        """
        authentication_ref: NotRequired[pulumi.Input[str]]
        """
        Reference to client authentication settings. Omit to disable authentication.
        """
        authorization_ref: NotRequired[pulumi.Input[str]]
        """
        Reference to client authorization settings. Omit to disable authorization.
        """
        node_port: NotRequired[pulumi.Input[int]]
        """
        Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        """
        protocol: NotRequired[pulumi.Input[Union[str, 'BrokerProtocolType']]]
        """
        Protocol to use for client connections.
        """
        tls: NotRequired[pulumi.Input['TlsCertMethodArgsDict']]
        """
        TLS server certificate settings for this port. Omit to disable TLS.
        """
elif False:
    ListenerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerPortArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 authentication_ref: Optional[pulumi.Input[str]] = None,
                 authorization_ref: Optional[pulumi.Input[str]] = None,
                 node_port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[Union[str, 'BrokerProtocolType']]] = None,
                 tls: Optional[pulumi.Input['TlsCertMethodArgs']] = None):
        """
        Defines a TCP port on which a `BrokerListener` listens.
        :param pulumi.Input[int] port: TCP port for accepting client connections.
        :param pulumi.Input[str] authentication_ref: Reference to client authentication settings. Omit to disable authentication.
        :param pulumi.Input[str] authorization_ref: Reference to client authorization settings. Omit to disable authorization.
        :param pulumi.Input[int] node_port: Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        :param pulumi.Input[Union[str, 'BrokerProtocolType']] protocol: Protocol to use for client connections.
        :param pulumi.Input['TlsCertMethodArgs'] tls: TLS server certificate settings for this port. Omit to disable TLS.
        """
        pulumi.set(__self__, "port", port)
        if authentication_ref is not None:
            pulumi.set(__self__, "authentication_ref", authentication_ref)
        if authorization_ref is not None:
            pulumi.set(__self__, "authorization_ref", authorization_ref)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)
        if protocol is None:
            protocol = 'Mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        TCP port for accepting client connections.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="authenticationRef")
    def authentication_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Reference to client authentication settings. Omit to disable authentication.
        """
        return pulumi.get(self, "authentication_ref")

    @authentication_ref.setter
    def authentication_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_ref", value)

    @property
    @pulumi.getter(name="authorizationRef")
    def authorization_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Reference to client authorization settings. Omit to disable authorization.
        """
        return pulumi.get(self, "authorization_ref")

    @authorization_ref.setter
    def authorization_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_ref", value)

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[int]]:
        """
        Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        """
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[str, 'BrokerProtocolType']]]:
        """
        Protocol to use for client connections.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[str, 'BrokerProtocolType']]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['TlsCertMethodArgs']]:
        """
        TLS server certificate settings for this port. Omit to disable TLS.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['TlsCertMethodArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class LocalKubernetesReferenceArgsDict(TypedDict):
        """
        Kubernetes reference
        """
        kind: pulumi.Input[str]
        """
        Kind is the type of resource being referenced
        """
        name: pulumi.Input[str]
        """
        Name is the name of resource being referenced
        """
        api_group: NotRequired[pulumi.Input[str]]
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
elif False:
    LocalKubernetesReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocalKubernetesReferenceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 name: pulumi.Input[str],
                 api_group: Optional[pulumi.Input[str]] = None):
        """
        Kubernetes reference
        :param pulumi.Input[str] kind: Kind is the type of resource being referenced
        :param pulumi.Input[str] name: Name is the name of resource being referenced
        :param pulumi.Input[str] api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[pulumi.Input[str]]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")

    @api_group.setter
    def api_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_group", value)


if not MYPY:
    class MetricsArgsDict(TypedDict):
        """
        Diagnostic Metrics properties
        """
        opentelemetry_export_config: NotRequired[pulumi.Input['OpenTelemetryExportConfigArgsDict']]
        """
        The open telemetry export configuration.
        """
        prometheus_port: NotRequired[pulumi.Input[int]]
        """
        The prometheus port to expose the metrics.
        """
elif False:
    MetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsArgs:
    def __init__(__self__, *,
                 opentelemetry_export_config: Optional[pulumi.Input['OpenTelemetryExportConfigArgs']] = None,
                 prometheus_port: Optional[pulumi.Input[int]] = None):
        """
        Diagnostic Metrics properties
        :param pulumi.Input['OpenTelemetryExportConfigArgs'] opentelemetry_export_config: The open telemetry export configuration.
        :param pulumi.Input[int] prometheus_port: The prometheus port to expose the metrics.
        """
        if opentelemetry_export_config is not None:
            pulumi.set(__self__, "opentelemetry_export_config", opentelemetry_export_config)
        if prometheus_port is None:
            prometheus_port = 9600
        if prometheus_port is not None:
            pulumi.set(__self__, "prometheus_port", prometheus_port)

    @property
    @pulumi.getter(name="opentelemetryExportConfig")
    def opentelemetry_export_config(self) -> Optional[pulumi.Input['OpenTelemetryExportConfigArgs']]:
        """
        The open telemetry export configuration.
        """
        return pulumi.get(self, "opentelemetry_export_config")

    @opentelemetry_export_config.setter
    def opentelemetry_export_config(self, value: Optional[pulumi.Input['OpenTelemetryExportConfigArgs']]):
        pulumi.set(self, "opentelemetry_export_config", value)

    @property
    @pulumi.getter(name="prometheusPort")
    def prometheus_port(self) -> Optional[pulumi.Input[int]]:
        """
        The prometheus port to expose the metrics.
        """
        return pulumi.get(self, "prometheus_port")

    @prometheus_port.setter
    def prometheus_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prometheus_port", value)


if not MYPY:
    class OpenTelemetryExportConfigArgsDict(TypedDict):
        """
        OpenTelemetry Export Configuration properties
        """
        otlp_grpc_endpoint: pulumi.Input[str]
        """
        The open telemetry collector endpoint to export to.
        """
        interval_seconds: NotRequired[pulumi.Input[int]]
        """
        How often to export the metrics to the open telemetry collector.
        """
elif False:
    OpenTelemetryExportConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenTelemetryExportConfigArgs:
    def __init__(__self__, *,
                 otlp_grpc_endpoint: pulumi.Input[str],
                 interval_seconds: Optional[pulumi.Input[int]] = None):
        """
        OpenTelemetry Export Configuration properties
        :param pulumi.Input[str] otlp_grpc_endpoint: The open telemetry collector endpoint to export to.
        :param pulumi.Input[int] interval_seconds: How often to export the metrics to the open telemetry collector.
        """
        pulumi.set(__self__, "otlp_grpc_endpoint", otlp_grpc_endpoint)
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)

    @property
    @pulumi.getter(name="otlpGrpcEndpoint")
    def otlp_grpc_endpoint(self) -> pulumi.Input[str]:
        """
        The open telemetry collector endpoint to export to.
        """
        return pulumi.get(self, "otlp_grpc_endpoint")

    @otlp_grpc_endpoint.setter
    def otlp_grpc_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "otlp_grpc_endpoint", value)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often to export the metrics to the open telemetry collector.
        """
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_seconds", value)


if not MYPY:
    class OpenTelemetryLogExportConfigArgsDict(TypedDict):
        """
        OpenTelemetry Log Export Configuration properties
        """
        otlp_grpc_endpoint: pulumi.Input[str]
        """
        The open telemetry collector endpoint to export to.
        """
        interval_seconds: NotRequired[pulumi.Input[int]]
        """
        How often to export the metrics to the open telemetry collector.
        """
        level: NotRequired[pulumi.Input[str]]
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
elif False:
    OpenTelemetryLogExportConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenTelemetryLogExportConfigArgs:
    def __init__(__self__, *,
                 otlp_grpc_endpoint: pulumi.Input[str],
                 interval_seconds: Optional[pulumi.Input[int]] = None,
                 level: Optional[pulumi.Input[str]] = None):
        """
        OpenTelemetry Log Export Configuration properties
        :param pulumi.Input[str] otlp_grpc_endpoint: The open telemetry collector endpoint to export to.
        :param pulumi.Input[int] interval_seconds: How often to export the metrics to the open telemetry collector.
        :param pulumi.Input[str] level: The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        pulumi.set(__self__, "otlp_grpc_endpoint", otlp_grpc_endpoint)
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if level is None:
            level = 'error'
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter(name="otlpGrpcEndpoint")
    def otlp_grpc_endpoint(self) -> pulumi.Input[str]:
        """
        The open telemetry collector endpoint to export to.
        """
        return pulumi.get(self, "otlp_grpc_endpoint")

    @otlp_grpc_endpoint.setter
    def otlp_grpc_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "otlp_grpc_endpoint", value)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often to export the metrics to the open telemetry collector.
        """
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_seconds", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class PrincipalDefinitionArgsDict(TypedDict):
        """
        PrincipalDefinition properties of Rule
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]
        """
        A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        """
        client_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        """
        usernames: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
elif False:
    PrincipalDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrincipalDefinitionArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]] = None,
                 client_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 usernames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        PrincipalDefinition properties of Rule
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]] attributes: A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] client_ids: A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] usernames: A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if client_ids is not None:
            pulumi.set(__self__, "client_ids", client_ids)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]:
        """
        A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        """
        return pulumi.get(self, "client_ids")

    @client_ids.setter
    def client_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "client_ids", value)

    @property
    @pulumi.getter
    def usernames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "usernames", value)


if not MYPY:
    class ProfileDiagnosticsArgsDict(TypedDict):
        """
        DataFlowProfile Diagnostics properties
        """
        logs: NotRequired[pulumi.Input['DiagnosticsLogsArgsDict']]
        """
        Diagnostic log settings for the resource.
        """
        metrics: NotRequired[pulumi.Input['MetricsArgsDict']]
        """
        The metrics settings for the resource.
        """
elif False:
    ProfileDiagnosticsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProfileDiagnosticsArgs:
    def __init__(__self__, *,
                 logs: Optional[pulumi.Input['DiagnosticsLogsArgs']] = None,
                 metrics: Optional[pulumi.Input['MetricsArgs']] = None):
        """
        DataFlowProfile Diagnostics properties
        :param pulumi.Input['DiagnosticsLogsArgs'] logs: Diagnostic log settings for the resource.
        :param pulumi.Input['MetricsArgs'] metrics: The metrics settings for the resource.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input['DiagnosticsLogsArgs']]:
        """
        Diagnostic log settings for the resource.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input['DiagnosticsLogsArgs']]):
        pulumi.set(self, "logs", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['MetricsArgs']]:
        """
        The metrics settings for the resource.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['MetricsArgs']]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class SanForCertArgsDict(TypedDict):
        """
        Subject Alternative Names (SANs) for certificate.
        """
        dns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        DNS SANs.
        """
        ip: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        IP address SANs.
        """
elif False:
    SanForCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SanForCertArgs:
    def __init__(__self__, *,
                 dns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 ip: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Subject Alternative Names (SANs) for certificate.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns: DNS SANs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip: IP address SANs.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def dns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        DNS SANs.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        IP address SANs.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class SelfCheckArgsDict(TypedDict):
        """
        Broker Diagnostic Self check properties
        """
        interval_seconds: NotRequired[pulumi.Input[int]]
        """
        The self check interval.
        """
        mode: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        The toggle to enable/disable self check.
        """
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        The timeout for self check.
        """
elif False:
    SelfCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelfCheckArgs:
    def __init__(__self__, *,
                 interval_seconds: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Broker Diagnostic Self check properties
        :param pulumi.Input[int] interval_seconds: The self check interval.
        :param pulumi.Input[Union[str, 'OperationalMode']] mode: The toggle to enable/disable self check.
        :param pulumi.Input[int] timeout_seconds: The timeout for self check.
        """
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if timeout_seconds is None:
            timeout_seconds = 15
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The self check interval.
        """
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_seconds", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        The toggle to enable/disable self check.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for self check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class SelfTracingArgsDict(TypedDict):
        """
        Diagnostic Self tracing properties
        """
        interval_seconds: NotRequired[pulumi.Input[int]]
        """
        The self tracing interval.
        """
        mode: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        The toggle to enable/disable self tracing.
        """
elif False:
    SelfTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SelfTracingArgs:
    def __init__(__self__, *,
                 interval_seconds: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None):
        """
        Diagnostic Self tracing properties
        :param pulumi.Input[int] interval_seconds: The self tracing interval.
        :param pulumi.Input[Union[str, 'OperationalMode']] mode: The toggle to enable/disable self tracing.
        """
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The self tracing interval.
        """
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_seconds", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        The toggle to enable/disable self tracing.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class StateStoreResourceRuleArgsDict(TypedDict):
        """
        State Store Resource Rule properties.
        """
        key_type: pulumi.Input[Union[str, 'StateStoreResourceKeyTypes']]
        """
        Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        """
        keys: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        """
        method: pulumi.Input[Union[str, 'StateStoreResourceDefinitionMethods']]
        """
        Give access for `Read`, `Write` and `ReadWrite` access level.
        """
elif False:
    StateStoreResourceRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StateStoreResourceRuleArgs:
    def __init__(__self__, *,
                 key_type: pulumi.Input[Union[str, 'StateStoreResourceKeyTypes']],
                 keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 method: pulumi.Input[Union[str, 'StateStoreResourceDefinitionMethods']]):
        """
        State Store Resource Rule properties.
        :param pulumi.Input[Union[str, 'StateStoreResourceKeyTypes']] key_type: Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        :param pulumi.Input[Union[str, 'StateStoreResourceDefinitionMethods']] method: Give access for `Read`, `Write` and `ReadWrite` access level.
        """
        pulumi.set(__self__, "key_type", key_type)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[Union[str, 'StateStoreResourceKeyTypes']]:
        """
        Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[Union[str, 'StateStoreResourceKeyTypes']]):
        pulumi.set(self, "key_type", value)

    @property
    @pulumi.getter
    def keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[str, 'StateStoreResourceDefinitionMethods']]:
        """
        Give access for `Read`, `Write` and `ReadWrite` access level.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[str, 'StateStoreResourceDefinitionMethods']]):
        pulumi.set(self, "method", value)


if not MYPY:
    class SubscriberQueueLimitArgsDict(TypedDict):
        """
        The settings of Subscriber Queue Limit.
        """
        length: NotRequired[pulumi.Input[float]]
        """
        The maximum length of the queue before messages start getting dropped.
        """
        strategy: NotRequired[pulumi.Input[Union[str, 'SubscriberMessageDropStrategy']]]
        """
        The strategy to use for dropping messages from the queue.
        """
elif False:
    SubscriberQueueLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriberQueueLimitArgs:
    def __init__(__self__, *,
                 length: Optional[pulumi.Input[float]] = None,
                 strategy: Optional[pulumi.Input[Union[str, 'SubscriberMessageDropStrategy']]] = None):
        """
        The settings of Subscriber Queue Limit.
        :param pulumi.Input[float] length: The maximum length of the queue before messages start getting dropped.
        :param pulumi.Input[Union[str, 'SubscriberMessageDropStrategy']] strategy: The strategy to use for dropping messages from the queue.
        """
        if length is not None:
            pulumi.set(__self__, "length", length)
        if strategy is None:
            strategy = 'None'
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum length of the queue before messages start getting dropped.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[Union[str, 'SubscriberMessageDropStrategy']]]:
        """
        The strategy to use for dropping messages from the queue.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[Union[str, 'SubscriberMessageDropStrategy']]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class TlsCertMethodArgsDict(TypedDict):
        """
        Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
        """
        mode: pulumi.Input[Union[str, 'TlsCertMethodMode']]
        """
        Mode of TLS server certificate management.
        """
        automatic: NotRequired[pulumi.Input['AutomaticCertMethodArgsDict']]
        """
        Option 1 - Automatic TLS server certificate management with cert-manager.
        """
        manual: NotRequired[pulumi.Input['X509ManualCertificateArgsDict']]
        """
        Option 2 - Manual TLS server certificate management through a defined secret.
        """
elif False:
    TlsCertMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsCertMethodArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[Union[str, 'TlsCertMethodMode']],
                 automatic: Optional[pulumi.Input['AutomaticCertMethodArgs']] = None,
                 manual: Optional[pulumi.Input['X509ManualCertificateArgs']] = None):
        """
        Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
        :param pulumi.Input[Union[str, 'TlsCertMethodMode']] mode: Mode of TLS server certificate management.
        :param pulumi.Input['AutomaticCertMethodArgs'] automatic: Option 1 - Automatic TLS server certificate management with cert-manager.
        :param pulumi.Input['X509ManualCertificateArgs'] manual: Option 2 - Manual TLS server certificate management through a defined secret.
        """
        pulumi.set(__self__, "mode", mode)
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[Union[str, 'TlsCertMethodMode']]:
        """
        Mode of TLS server certificate management.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[Union[str, 'TlsCertMethodMode']]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def automatic(self) -> Optional[pulumi.Input['AutomaticCertMethodArgs']]:
        """
        Option 1 - Automatic TLS server certificate management with cert-manager.
        """
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: Optional[pulumi.Input['AutomaticCertMethodArgs']]):
        pulumi.set(self, "automatic", value)

    @property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['X509ManualCertificateArgs']]:
        """
        Option 2 - Manual TLS server certificate management through a defined secret.
        """
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['X509ManualCertificateArgs']]):
        pulumi.set(self, "manual", value)


if not MYPY:
    class TlsPropertiesArgsDict(TypedDict):
        """
        Tls properties
        """
        mode: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        Mode for TLS.
        """
        trusted_ca_certificate_config_map_ref: NotRequired[pulumi.Input[str]]
        """
        Trusted CA certificate config map.
        """
elif False:
    TlsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsPropertiesArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None,
                 trusted_ca_certificate_config_map_ref: Optional[pulumi.Input[str]] = None):
        """
        Tls properties
        :param pulumi.Input[Union[str, 'OperationalMode']] mode: Mode for TLS.
        :param pulumi.Input[str] trusted_ca_certificate_config_map_ref: Trusted CA certificate config map.
        """
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if trusted_ca_certificate_config_map_ref is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map_ref", trusted_ca_certificate_config_map_ref)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        Mode for TLS.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="trustedCaCertificateConfigMapRef")
    def trusted_ca_certificate_config_map_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Trusted CA certificate config map.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map_ref")

    @trusted_ca_certificate_config_map_ref.setter
    def trusted_ca_certificate_config_map_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trusted_ca_certificate_config_map_ref", value)


if not MYPY:
    class TracesArgsDict(TypedDict):
        """
        Broker Diagnostic Trace properties
        """
        cache_size_megabytes: NotRequired[pulumi.Input[int]]
        """
        The cache size in megabytes.
        """
        mode: NotRequired[pulumi.Input[Union[str, 'OperationalMode']]]
        """
        The toggle to enable/disable traces.
        """
        opentelemetry_export_config: NotRequired[pulumi.Input['OpenTelemetryExportConfigArgsDict']]
        """
        The open telemetry export configuration.
        """
        self_tracing: NotRequired[pulumi.Input['SelfTracingArgsDict']]
        """
        The self tracing properties.
        """
        span_channel_capacity: NotRequired[pulumi.Input[int]]
        """
        The span channel capacity.
        """
elif False:
    TracesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TracesArgs:
    def __init__(__self__, *,
                 cache_size_megabytes: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[Union[str, 'OperationalMode']]] = None,
                 opentelemetry_export_config: Optional[pulumi.Input['OpenTelemetryExportConfigArgs']] = None,
                 self_tracing: Optional[pulumi.Input['SelfTracingArgs']] = None,
                 span_channel_capacity: Optional[pulumi.Input[int]] = None):
        """
        Broker Diagnostic Trace properties
        :param pulumi.Input[int] cache_size_megabytes: The cache size in megabytes.
        :param pulumi.Input[Union[str, 'OperationalMode']] mode: The toggle to enable/disable traces.
        :param pulumi.Input['OpenTelemetryExportConfigArgs'] opentelemetry_export_config: The open telemetry export configuration.
        :param pulumi.Input['SelfTracingArgs'] self_tracing: The self tracing properties.
        :param pulumi.Input[int] span_channel_capacity: The span channel capacity.
        """
        if cache_size_megabytes is None:
            cache_size_megabytes = 16
        if cache_size_megabytes is not None:
            pulumi.set(__self__, "cache_size_megabytes", cache_size_megabytes)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if opentelemetry_export_config is not None:
            pulumi.set(__self__, "opentelemetry_export_config", opentelemetry_export_config)
        if self_tracing is not None:
            pulumi.set(__self__, "self_tracing", self_tracing)
        if span_channel_capacity is None:
            span_channel_capacity = 1000
        if span_channel_capacity is not None:
            pulumi.set(__self__, "span_channel_capacity", span_channel_capacity)

    @property
    @pulumi.getter(name="cacheSizeMegabytes")
    def cache_size_megabytes(self) -> Optional[pulumi.Input[int]]:
        """
        The cache size in megabytes.
        """
        return pulumi.get(self, "cache_size_megabytes")

    @cache_size_megabytes.setter
    def cache_size_megabytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cache_size_megabytes", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'OperationalMode']]]:
        """
        The toggle to enable/disable traces.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'OperationalMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="opentelemetryExportConfig")
    def opentelemetry_export_config(self) -> Optional[pulumi.Input['OpenTelemetryExportConfigArgs']]:
        """
        The open telemetry export configuration.
        """
        return pulumi.get(self, "opentelemetry_export_config")

    @opentelemetry_export_config.setter
    def opentelemetry_export_config(self, value: Optional[pulumi.Input['OpenTelemetryExportConfigArgs']]):
        pulumi.set(self, "opentelemetry_export_config", value)

    @property
    @pulumi.getter(name="selfTracing")
    def self_tracing(self) -> Optional[pulumi.Input['SelfTracingArgs']]:
        """
        The self tracing properties.
        """
        return pulumi.get(self, "self_tracing")

    @self_tracing.setter
    def self_tracing(self, value: Optional[pulumi.Input['SelfTracingArgs']]):
        pulumi.set(self, "self_tracing", value)

    @property
    @pulumi.getter(name="spanChannelCapacity")
    def span_channel_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        The span channel capacity.
        """
        return pulumi.get(self, "span_channel_capacity")

    @span_channel_capacity.setter
    def span_channel_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "span_channel_capacity", value)


if not MYPY:
    class VolumeClaimResourceRequirementsArgsDict(TypedDict):
        """
        VolumeClaimResourceRequirements properties
        """
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        requests: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
elif False:
    VolumeClaimResourceRequirementsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeClaimResourceRequirementsArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        VolumeClaimResourceRequirements properties
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class VolumeClaimSpecSelectorMatchExpressionsArgsDict(TypedDict):
        """
        VolumeClaimSpecSelectorMatchExpressions properties
        """
        key: pulumi.Input[str]
        """
        key is the label key that the selector applies to.
        """
        operator: pulumi.Input[Union[str, 'OperatorValues']]
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
elif False:
    VolumeClaimSpecSelectorMatchExpressionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeClaimSpecSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[Union[str, 'OperatorValues']],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        VolumeClaimSpecSelectorMatchExpressions properties
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[Union[str, 'OperatorValues']] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'OperatorValues']]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'OperatorValues']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class VolumeClaimSpecSelectorArgsDict(TypedDict):
        """
        VolumeClaimSpecSelector properties
        """
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgsDict']]]]
        """
        MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
elif False:
    VolumeClaimSpecSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeClaimSpecSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        VolumeClaimSpecSelector properties
        :param pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]] match_expressions: MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]]]:
        """
        MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeClaimSpecSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class VolumeClaimSpecArgsDict(TypedDict):
        """
        VolumeClaimSpec properties
        """
        access_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        """
        data_source: NotRequired[pulumi.Input['LocalKubernetesReferenceArgsDict']]
        """
        This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        """
        data_source_ref: NotRequired[pulumi.Input['KubernetesReferenceArgsDict']]
        """
        Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        """
        resources: NotRequired[pulumi.Input['VolumeClaimResourceRequirementsArgsDict']]
        """
        Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        selector: NotRequired[pulumi.Input['VolumeClaimSpecSelectorArgsDict']]
        """
        A label query over volumes to consider for binding.
        """
        storage_class_name: NotRequired[pulumi.Input[str]]
        """
        Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        """
        volume_mode: NotRequired[pulumi.Input[str]]
        """
        volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        """
        volume_name: NotRequired[pulumi.Input[str]]
        """
        VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
elif False:
    VolumeClaimSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeClaimSpecArgs:
    def __init__(__self__, *,
                 access_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 data_source: Optional[pulumi.Input['LocalKubernetesReferenceArgs']] = None,
                 data_source_ref: Optional[pulumi.Input['KubernetesReferenceArgs']] = None,
                 resources: Optional[pulumi.Input['VolumeClaimResourceRequirementsArgs']] = None,
                 selector: Optional[pulumi.Input['VolumeClaimSpecSelectorArgs']] = None,
                 storage_class_name: Optional[pulumi.Input[str]] = None,
                 volume_mode: Optional[pulumi.Input[str]] = None,
                 volume_name: Optional[pulumi.Input[str]] = None):
        """
        VolumeClaimSpec properties
        :param pulumi.Input[Sequence[pulumi.Input[str]]] access_modes: AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        :param pulumi.Input['LocalKubernetesReferenceArgs'] data_source: This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        :param pulumi.Input['KubernetesReferenceArgs'] data_source_ref: Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        :param pulumi.Input['VolumeClaimResourceRequirementsArgs'] resources: Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param pulumi.Input['VolumeClaimSpecSelectorArgs'] selector: A label query over volumes to consider for binding.
        :param pulumi.Input[str] storage_class_name: Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        :param pulumi.Input[str] volume_mode: volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        :param pulumi.Input[str] volume_name: VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        if access_modes is not None:
            pulumi.set(__self__, "access_modes", access_modes)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if data_source_ref is not None:
            pulumi.set(__self__, "data_source_ref", data_source_ref)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)
        if volume_mode is not None:
            pulumi.set(__self__, "volume_mode", volume_mode)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @access_modes.setter
    def access_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "access_modes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input['LocalKubernetesReferenceArgs']]:
        """
        This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input['LocalKubernetesReferenceArgs']]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter(name="dataSourceRef")
    def data_source_ref(self) -> Optional[pulumi.Input['KubernetesReferenceArgs']]:
        """
        Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        """
        return pulumi.get(self, "data_source_ref")

    @data_source_ref.setter
    def data_source_ref(self, value: Optional[pulumi.Input['KubernetesReferenceArgs']]):
        pulumi.set(self, "data_source_ref", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['VolumeClaimResourceRequirementsArgs']]:
        """
        Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['VolumeClaimResourceRequirementsArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['VolumeClaimSpecSelectorArgs']]:
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['VolumeClaimSpecSelectorArgs']]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        """
        return pulumi.get(self, "storage_class_name")

    @storage_class_name.setter
    def storage_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_class_name", value)

    @property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> Optional[pulumi.Input[str]]:
        """
        volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        """
        return pulumi.get(self, "volume_mode")

    @volume_mode.setter
    def volume_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_mode", value)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[pulumi.Input[str]]:
        """
        VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_name", value)


if not MYPY:
    class X509ManualCertificateArgsDict(TypedDict):
        """
        X509 Certificate Authentication properties.
        """
        secret_ref: pulumi.Input[str]
        """
        Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
elif False:
    X509ManualCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class X509ManualCertificateArgs:
    def __init__(__self__, *,
                 secret_ref: pulumi.Input[str]):
        """
        X509 Certificate Authentication properties.
        :param pulumi.Input[str] secret_ref: Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input[str]:
        """
        Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_ref", value)


