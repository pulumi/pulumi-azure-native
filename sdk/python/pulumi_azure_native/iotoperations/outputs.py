# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AdvancedSettingsResponse',
    'AkriConnectorPropertiesResponse',
    'AkriConnectorTemplateAioMetadataResponse',
    'AkriConnectorTemplateBucketizedAllocationResponse',
    'AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsResponse',
    'AkriConnectorTemplateDeviceInboundEndpointTypeResponse',
    'AkriConnectorTemplateDiagnosticsResponse',
    'AkriConnectorTemplateHelmAdvancedConfigurationResponse',
    'AkriConnectorTemplateHelmAuthSecretRefResponse',
    'AkriConnectorTemplateHelmConfigurationResponse',
    'AkriConnectorTemplateHelmConfigurationSettingsResponse',
    'AkriConnectorTemplateHelmContainerRegistryResponse',
    'AkriConnectorTemplateHelmContainerRegistrySettingsResponse',
    'AkriConnectorTemplateHelmDeleteConfigurationResponse',
    'AkriConnectorTemplateHelmInstallConfigurationResponse',
    'AkriConnectorTemplateHelmRegistryEndpointRefResponse',
    'AkriConnectorTemplateHelmUpgradeConfigurationResponse',
    'AkriConnectorTemplateManagedConfigurationResponse',
    'AkriConnectorTemplatePersistentVolumeClaimResponse',
    'AkriConnectorTemplatePropertiesResponse',
    'AkriConnectorTemplateRuntimeImageConfigurationResponse',
    'AkriConnectorTemplateRuntimeImageConfigurationSettingsResponse',
    'AkriConnectorTemplateRuntimeStatefulSetConfigurationResponse',
    'AkriConnectorTemplateTrustListResponse',
    'AkriConnectorsContainerRegistryResponse',
    'AkriConnectorsContainerRegistrySettingsResponse',
    'AkriConnectorsDiagnosticsLogsResponse',
    'AkriConnectorsDigestResponse',
    'AkriConnectorsImagePullSecretResponse',
    'AkriConnectorsMqttConnectionConfigurationResponse',
    'AkriConnectorsRegistryEndpointRefResponse',
    'AkriConnectorsSecretResponse',
    'AkriConnectorsServiceAccountAuthenticationResponse',
    'AkriConnectorsServiceAccountTokenSettingsResponse',
    'AkriConnectorsTagResponse',
    'AuthorizationConfigResponse',
    'AuthorizationRuleResponse',
    'BackendChainResponse',
    'BatchingConfigurationResponse',
    'BrokerAuthenticationPropertiesResponse',
    'BrokerAuthenticatorCustomAuthResponse',
    'BrokerAuthenticatorMethodCustomResponse',
    'BrokerAuthenticatorMethodSatResponse',
    'BrokerAuthenticatorMethodX509AttributesResponse',
    'BrokerAuthenticatorMethodX509Response',
    'BrokerAuthenticatorMethodsResponse',
    'BrokerAuthorizationPropertiesResponse',
    'BrokerDiagnosticsResponse',
    'BrokerListenerPropertiesResponse',
    'BrokerPropertiesResponse',
    'BrokerResourceRuleResponse',
    'CardinalityResponse',
    'CertManagerCertOptionsResponse',
    'CertManagerCertificateSpecResponse',
    'CertManagerIssuerRefResponse',
    'CertManagerPrivateKeyResponse',
    'ClientConfigResponse',
    'DataflowBuiltInTransformationDatasetResponse',
    'DataflowBuiltInTransformationFilterResponse',
    'DataflowBuiltInTransformationMapResponse',
    'DataflowBuiltInTransformationSettingsResponse',
    'DataflowDestinationOperationSettingsResponse',
    'DataflowEndpointAuthenticationAccessTokenResponse',
    'DataflowEndpointAuthenticationSaslResponse',
    'DataflowEndpointAuthenticationServiceAccountTokenResponse',
    'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse',
    'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse',
    'DataflowEndpointAuthenticationX509Response',
    'DataflowEndpointDataExplorerAuthenticationResponse',
    'DataflowEndpointDataExplorerResponse',
    'DataflowEndpointDataLakeStorageAuthenticationResponse',
    'DataflowEndpointDataLakeStorageResponse',
    'DataflowEndpointFabricOneLakeAuthenticationResponse',
    'DataflowEndpointFabricOneLakeNamesResponse',
    'DataflowEndpointFabricOneLakeResponse',
    'DataflowEndpointKafkaAuthenticationResponse',
    'DataflowEndpointKafkaBatchingResponse',
    'DataflowEndpointKafkaResponse',
    'DataflowEndpointLocalStorageResponse',
    'DataflowEndpointMqttAuthenticationResponse',
    'DataflowEndpointMqttResponse',
    'DataflowEndpointPropertiesResponse',
    'DataflowGraphConnectionInputResponse',
    'DataflowGraphConnectionOutputResponse',
    'DataflowGraphConnectionSchemaSettingsResponse',
    'DataflowGraphDestinationNodeResponse',
    'DataflowGraphDestinationNodeSettingsResponse',
    'DataflowGraphDestinationSchemaSettingsResponse',
    'DataflowGraphGraphNodeConfigurationResponse',
    'DataflowGraphGraphNodeResponse',
    'DataflowGraphNodeConnectionResponse',
    'DataflowGraphNodeGraphSettingsResponse',
    'DataflowGraphPropertiesResponse',
    'DataflowGraphSourceNodeResponse',
    'DataflowGraphSourceSettingsResponse',
    'DataflowOperationResponse',
    'DataflowProfilePropertiesResponse',
    'DataflowPropertiesResponse',
    'DataflowSourceOperationSettingsResponse',
    'DiagnosticsLogsResponse',
    'DiskBackedMessageBufferResponse',
    'ExtendedLocationResponse',
    'FrontendResponse',
    'GenerateResourceLimitsResponse',
    'InstancePropertiesResponse',
    'KubernetesReferenceResponse',
    'ListenerPortResponse',
    'LocalKubernetesReferenceResponse',
    'ManagedServiceIdentityResponse',
    'MetricsResponse',
    'PrincipalDefinitionResponse',
    'ProfileDiagnosticsResponse',
    'RegistryEndpointAnonymousAuthenticationResponse',
    'RegistryEndpointArtifactPullSecretAuthenticationResponse',
    'RegistryEndpointArtifactPullSecretSettingsResponse',
    'RegistryEndpointPropertiesResponse',
    'RegistryEndpointSystemAssignedIdentityAuthenticationResponse',
    'RegistryEndpointSystemAssignedManagedIdentitySettingsResponse',
    'RegistryEndpointTrustedSettingsResponse',
    'RegistryEndpointTrustedSigningKeyConfigMapResponse',
    'RegistryEndpointTrustedSigningKeySecretResponse',
    'RegistryEndpointUserAssignedIdentityAuthenticationResponse',
    'RegistryEndpointUserAssignedManagedIdentitySettingsResponse',
    'SanForCertResponse',
    'SchemaRegistryRefResponse',
    'SelfCheckResponse',
    'SelfTracingResponse',
    'StateStoreResourceRuleResponse',
    'SubscriberQueueLimitResponse',
    'SystemDataResponse',
    'TlsCertMethodResponse',
    'TlsPropertiesResponse',
    'TracesResponse',
    'UserAssignedIdentityResponse',
    'VolumeClaimResourceRequirementsResponse',
    'VolumeClaimSpecResponse',
    'VolumeClaimSpecSelectorMatchExpressionsResponse',
    'VolumeClaimSpecSelectorResponse',
    'X509ManualCertificateResponse',
]

@pulumi.output_type
class AdvancedSettingsResponse(dict):
    """
    Broker Advanced Settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptInternalTraffic":
            suggest = "encrypt_internal_traffic"
        elif key == "internalCerts":
            suggest = "internal_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clients: Optional['outputs.ClientConfigResponse'] = None,
                 encrypt_internal_traffic: Optional[_builtins.str] = None,
                 internal_certs: Optional['outputs.CertManagerCertOptionsResponse'] = None):
        """
        Broker Advanced Settings
        :param 'ClientConfigResponse' clients: Configurations related to All Clients.
        :param _builtins.str encrypt_internal_traffic: The setting to enable or disable encryption of internal Traffic.
        :param 'CertManagerCertOptionsResponse' internal_certs: Certificate rotation and private key configuration.
        """
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if encrypt_internal_traffic is None:
            encrypt_internal_traffic = 'Enabled'
        if encrypt_internal_traffic is not None:
            pulumi.set(__self__, "encrypt_internal_traffic", encrypt_internal_traffic)
        if internal_certs is not None:
            pulumi.set(__self__, "internal_certs", internal_certs)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> Optional['outputs.ClientConfigResponse']:
        """
        Configurations related to All Clients.
        """
        return pulumi.get(self, "clients")

    @_builtins.property
    @pulumi.getter(name="encryptInternalTraffic")
    def encrypt_internal_traffic(self) -> Optional[_builtins.str]:
        """
        The setting to enable or disable encryption of internal Traffic.
        """
        return pulumi.get(self, "encrypt_internal_traffic")

    @_builtins.property
    @pulumi.getter(name="internalCerts")
    def internal_certs(self) -> Optional['outputs.CertManagerCertOptionsResponse']:
        """
        Certificate rotation and private key configuration.
        """
        return pulumi.get(self, "internal_certs")


@pulumi.output_type
class AkriConnectorPropertiesResponse(dict):
    """
    AkriConnector properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str):
        """
        AkriConnector properties.
        :param _builtins.str provisioning_state: The status of the last operation.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class AkriConnectorTemplateAioMetadataResponse(dict):
    """
    AkriConnectorTemplateAioMetadata properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aioMaxVersion":
            suggest = "aio_max_version"
        elif key == "aioMinVersion":
            suggest = "aio_min_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateAioMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateAioMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateAioMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aio_max_version: Optional[_builtins.str] = None,
                 aio_min_version: Optional[_builtins.str] = None):
        """
        AkriConnectorTemplateAioMetadata properties.
        :param _builtins.str aio_max_version: The maximum version of AIO required for the connector.
        :param _builtins.str aio_min_version: The minimum version of AIO required for the connector.
        """
        if aio_max_version is not None:
            pulumi.set(__self__, "aio_max_version", aio_max_version)
        if aio_min_version is not None:
            pulumi.set(__self__, "aio_min_version", aio_min_version)

    @_builtins.property
    @pulumi.getter(name="aioMaxVersion")
    def aio_max_version(self) -> Optional[_builtins.str]:
        """
        The maximum version of AIO required for the connector.
        """
        return pulumi.get(self, "aio_max_version")

    @_builtins.property
    @pulumi.getter(name="aioMinVersion")
    def aio_min_version(self) -> Optional[_builtins.str]:
        """
        The minimum version of AIO required for the connector.
        """
        return pulumi.get(self, "aio_min_version")


@pulumi.output_type
class AkriConnectorTemplateBucketizedAllocationResponse(dict):
    """
    AkriConnectorTemplateBucketizedAllocation properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketSize":
            suggest = "bucket_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateBucketizedAllocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateBucketizedAllocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateBucketizedAllocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_size: _builtins.int,
                 policy: _builtins.str):
        """
        AkriConnectorTemplateBucketizedAllocation properties.
        :param _builtins.int bucket_size: The bucketized allocation of AEPs for connectors.
        :param _builtins.str policy: AkriConnectorTemplateAllocationPolicy properties.
               Expected value is 'Bucketized'.
        """
        pulumi.set(__self__, "bucket_size", bucket_size)
        pulumi.set(__self__, "policy", 'Bucketized')

    @_builtins.property
    @pulumi.getter(name="bucketSize")
    def bucket_size(self) -> _builtins.int:
        """
        The bucketized allocation of AEPs for connectors.
        """
        return pulumi.get(self, "bucket_size")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        AkriConnectorTemplateAllocationPolicy properties.
        Expected value is 'Bucketized'.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsResponse(dict):
    """
    AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefs properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalConfigSchemaRef":
            suggest = "additional_config_schema_ref"
        elif key == "defaultDatasetConfigSchemaRef":
            suggest = "default_dataset_config_schema_ref"
        elif key == "defaultEventsConfigSchemaRef":
            suggest = "default_events_config_schema_ref"
        elif key == "defaultProcessControlConfigSchemaRef":
            suggest = "default_process_control_config_schema_ref"
        elif key == "defaultStreamsConfigSchemaRef":
            suggest = "default_streams_config_schema_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_config_schema_ref: Optional[_builtins.str] = None,
                 default_dataset_config_schema_ref: Optional[_builtins.str] = None,
                 default_events_config_schema_ref: Optional[_builtins.str] = None,
                 default_process_control_config_schema_ref: Optional[_builtins.str] = None,
                 default_streams_config_schema_ref: Optional[_builtins.str] = None):
        """
        AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefs properties.
        :param _builtins.str additional_config_schema_ref: The additional configuration schema reference.
        :param _builtins.str default_dataset_config_schema_ref: The default configuration schema reference for datasets.
        :param _builtins.str default_events_config_schema_ref: The default configuration schema reference for events.
        :param _builtins.str default_process_control_config_schema_ref: The default configuration schema reference for process control.
        :param _builtins.str default_streams_config_schema_ref: The default configuration schema reference for streams.
        """
        if additional_config_schema_ref is not None:
            pulumi.set(__self__, "additional_config_schema_ref", additional_config_schema_ref)
        if default_dataset_config_schema_ref is not None:
            pulumi.set(__self__, "default_dataset_config_schema_ref", default_dataset_config_schema_ref)
        if default_events_config_schema_ref is not None:
            pulumi.set(__self__, "default_events_config_schema_ref", default_events_config_schema_ref)
        if default_process_control_config_schema_ref is not None:
            pulumi.set(__self__, "default_process_control_config_schema_ref", default_process_control_config_schema_ref)
        if default_streams_config_schema_ref is not None:
            pulumi.set(__self__, "default_streams_config_schema_ref", default_streams_config_schema_ref)

    @_builtins.property
    @pulumi.getter(name="additionalConfigSchemaRef")
    def additional_config_schema_ref(self) -> Optional[_builtins.str]:
        """
        The additional configuration schema reference.
        """
        return pulumi.get(self, "additional_config_schema_ref")

    @_builtins.property
    @pulumi.getter(name="defaultDatasetConfigSchemaRef")
    def default_dataset_config_schema_ref(self) -> Optional[_builtins.str]:
        """
        The default configuration schema reference for datasets.
        """
        return pulumi.get(self, "default_dataset_config_schema_ref")

    @_builtins.property
    @pulumi.getter(name="defaultEventsConfigSchemaRef")
    def default_events_config_schema_ref(self) -> Optional[_builtins.str]:
        """
        The default configuration schema reference for events.
        """
        return pulumi.get(self, "default_events_config_schema_ref")

    @_builtins.property
    @pulumi.getter(name="defaultProcessControlConfigSchemaRef")
    def default_process_control_config_schema_ref(self) -> Optional[_builtins.str]:
        """
        The default configuration schema reference for process control.
        """
        return pulumi.get(self, "default_process_control_config_schema_ref")

    @_builtins.property
    @pulumi.getter(name="defaultStreamsConfigSchemaRef")
    def default_streams_config_schema_ref(self) -> Optional[_builtins.str]:
        """
        The default configuration schema reference for streams.
        """
        return pulumi.get(self, "default_streams_config_schema_ref")


@pulumi.output_type
class AkriConnectorTemplateDeviceInboundEndpointTypeResponse(dict):
    """
    AkriConnectorTemplateDeviceInboundEndpointType properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "configurationSchemaRefs":
            suggest = "configuration_schema_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateDeviceInboundEndpointTypeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateDeviceInboundEndpointTypeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateDeviceInboundEndpointTypeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: _builtins.str,
                 configuration_schema_refs: Optional['outputs.AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsResponse'] = None,
                 description: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        AkriConnectorTemplateDeviceInboundEndpointType properties.
        :param _builtins.str endpoint_type: The type of the device inbound endpoint.
        :param 'AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsResponse' configuration_schema_refs: The configuration schema references for the device inbound endpoint.
        :param _builtins.str description: A description of the device inbound endpoint.
        :param _builtins.str version: The version of the device inbound endpoint.
        """
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        if configuration_schema_refs is not None:
            pulumi.set(__self__, "configuration_schema_refs", configuration_schema_refs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> _builtins.str:
        """
        The type of the device inbound endpoint.
        """
        return pulumi.get(self, "endpoint_type")

    @_builtins.property
    @pulumi.getter(name="configurationSchemaRefs")
    def configuration_schema_refs(self) -> Optional['outputs.AkriConnectorTemplateDeviceInboundEndpointConfigurationSchemaRefsResponse']:
        """
        The configuration schema references for the device inbound endpoint.
        """
        return pulumi.get(self, "configuration_schema_refs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the device inbound endpoint.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the device inbound endpoint.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AkriConnectorTemplateDiagnosticsResponse(dict):
    """
    AkriConnectorTemplateDiagnostics properties.
    """
    def __init__(__self__, *,
                 logs: 'outputs.AkriConnectorsDiagnosticsLogsResponse'):
        """
        AkriConnectorTemplateDiagnostics properties.
        :param 'AkriConnectorsDiagnosticsLogsResponse' logs: The log settings for the Connector template.
        """
        pulumi.set(__self__, "logs", logs)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> 'outputs.AkriConnectorsDiagnosticsLogsResponse':
        """
        The log settings for the Connector template.
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class AkriConnectorTemplateHelmAdvancedConfigurationResponse(dict):
    """
    AkriConnectorTemplateHelmAdvancedConfiguration properties.
    """
    def __init__(__self__, *,
                 delete: Optional['outputs.AkriConnectorTemplateHelmDeleteConfigurationResponse'] = None,
                 install: Optional['outputs.AkriConnectorTemplateHelmInstallConfigurationResponse'] = None,
                 upgrade: Optional['outputs.AkriConnectorTemplateHelmUpgradeConfigurationResponse'] = None):
        """
        AkriConnectorTemplateHelmAdvancedConfiguration properties.
        :param 'AkriConnectorTemplateHelmDeleteConfigurationResponse' delete: Delete operation configuration for the Helm chart.
        :param 'AkriConnectorTemplateHelmInstallConfigurationResponse' install: Install operation configuration for the Helm chart.
        :param 'AkriConnectorTemplateHelmUpgradeConfigurationResponse' upgrade: Upgrade operation configuration for the Helm chart.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if install is not None:
            pulumi.set(__self__, "install", install)
        if upgrade is not None:
            pulumi.set(__self__, "upgrade", upgrade)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional['outputs.AkriConnectorTemplateHelmDeleteConfigurationResponse']:
        """
        Delete operation configuration for the Helm chart.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def install(self) -> Optional['outputs.AkriConnectorTemplateHelmInstallConfigurationResponse']:
        """
        Install operation configuration for the Helm chart.
        """
        return pulumi.get(self, "install")

    @_builtins.property
    @pulumi.getter
    def upgrade(self) -> Optional['outputs.AkriConnectorTemplateHelmUpgradeConfigurationResponse']:
        """
        Upgrade operation configuration for the Helm chart.
        """
        return pulumi.get(self, "upgrade")


@pulumi.output_type
class AkriConnectorTemplateHelmAuthSecretRefResponse(dict):
    """
    AkriConnectorTemplateHelmAuthSecretRef properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordKey":
            suggest = "password_key"
        elif key == "secretRef":
            suggest = "secret_ref"
        elif key == "usernameKey":
            suggest = "username_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateHelmAuthSecretRefResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateHelmAuthSecretRefResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateHelmAuthSecretRefResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_key: _builtins.str,
                 secret_ref: _builtins.str,
                 username_key: _builtins.str):
        """
        AkriConnectorTemplateHelmAuthSecretRef properties.
        :param _builtins.str password_key: The key of the password in the secret.
        :param _builtins.str secret_ref: The name of the secret.
        :param _builtins.str username_key: The key of the username in the secret.
        """
        pulumi.set(__self__, "password_key", password_key)
        pulumi.set(__self__, "secret_ref", secret_ref)
        pulumi.set(__self__, "username_key", username_key)

    @_builtins.property
    @pulumi.getter(name="passwordKey")
    def password_key(self) -> _builtins.str:
        """
        The key of the password in the secret.
        """
        return pulumi.get(self, "password_key")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> _builtins.str:
        """
        The name of the secret.
        """
        return pulumi.get(self, "secret_ref")

    @_builtins.property
    @pulumi.getter(name="usernameKey")
    def username_key(self) -> _builtins.str:
        """
        The key of the username in the secret.
        """
        return pulumi.get(self, "username_key")


@pulumi.output_type
class AkriConnectorTemplateHelmConfigurationResponse(dict):
    """
    AkriConnectorTemplateHelmConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "helmConfigurationSettings":
            suggest = "helm_configuration_settings"
        elif key == "runtimeConfigurationType":
            suggest = "runtime_configuration_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateHelmConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateHelmConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateHelmConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 helm_configuration_settings: 'outputs.AkriConnectorTemplateHelmConfigurationSettingsResponse',
                 runtime_configuration_type: _builtins.str):
        """
        AkriConnectorTemplateHelmConfiguration properties.
        :param 'AkriConnectorTemplateHelmConfigurationSettingsResponse' helm_configuration_settings: The Helm configuration settings.
        :param _builtins.str runtime_configuration_type: Runtime configuration types.
               Expected value is 'HelmConfiguration'.
        """
        pulumi.set(__self__, "helm_configuration_settings", helm_configuration_settings)
        pulumi.set(__self__, "runtime_configuration_type", 'HelmConfiguration')

    @_builtins.property
    @pulumi.getter(name="helmConfigurationSettings")
    def helm_configuration_settings(self) -> 'outputs.AkriConnectorTemplateHelmConfigurationSettingsResponse':
        """
        The Helm configuration settings.
        """
        return pulumi.get(self, "helm_configuration_settings")

    @_builtins.property
    @pulumi.getter(name="runtimeConfigurationType")
    def runtime_configuration_type(self) -> _builtins.str:
        """
        Runtime configuration types.
        Expected value is 'HelmConfiguration'.
        """
        return pulumi.get(self, "runtime_configuration_type")


@pulumi.output_type
class AkriConnectorTemplateHelmConfigurationSettingsResponse(dict):
    """
    AkriConnectorTemplateHelmConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseName":
            suggest = "release_name"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "advancedConfiguration":
            suggest = "advanced_configuration"
        elif key == "registrySettings":
            suggest = "registry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateHelmConfigurationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateHelmConfigurationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateHelmConfigurationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 release_name: _builtins.str,
                 repository_name: _builtins.str,
                 version: _builtins.str,
                 advanced_configuration: Optional['outputs.AkriConnectorTemplateHelmAdvancedConfigurationResponse'] = None,
                 registry_settings: Optional[Any] = None,
                 values: Optional[Mapping[str, _builtins.str]] = None):
        """
        AkriConnectorTemplateHelmConfiguration properties.
        :param _builtins.str release_name: The release name of the Helm chart.
        :param _builtins.str repository_name: The name of the repository
        :param _builtins.str version: The version of the Helm chart.
        :param 'AkriConnectorTemplateHelmAdvancedConfigurationResponse' advanced_configuration: Advanced configuration for the Helm chart.
               Install, upgrade, and uninstall options for the helm chart such as atomic, wait, timeout, `wait_for_jobs`, and `disable_hooks`.
        :param Union['AkriConnectorTemplateHelmContainerRegistryResponse', 'AkriConnectorTemplateHelmRegistryEndpointRefResponse'] registry_settings: The registry settings for the helm chart to be used.
        :param Mapping[str, _builtins.str] values: A map of values to pass to the helm chart.
        """
        pulumi.set(__self__, "release_name", release_name)
        pulumi.set(__self__, "repository_name", repository_name)
        pulumi.set(__self__, "version", version)
        if advanced_configuration is not None:
            pulumi.set(__self__, "advanced_configuration", advanced_configuration)
        if registry_settings is not None:
            pulumi.set(__self__, "registry_settings", registry_settings)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="releaseName")
    def release_name(self) -> _builtins.str:
        """
        The release name of the Helm chart.
        """
        return pulumi.get(self, "release_name")

    @_builtins.property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> _builtins.str:
        """
        The name of the repository
        """
        return pulumi.get(self, "repository_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the Helm chart.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="advancedConfiguration")
    def advanced_configuration(self) -> Optional['outputs.AkriConnectorTemplateHelmAdvancedConfigurationResponse']:
        """
        Advanced configuration for the Helm chart.
        Install, upgrade, and uninstall options for the helm chart such as atomic, wait, timeout, `wait_for_jobs`, and `disable_hooks`.
        """
        return pulumi.get(self, "advanced_configuration")

    @_builtins.property
    @pulumi.getter(name="registrySettings")
    def registry_settings(self) -> Optional[Any]:
        """
        The registry settings for the helm chart to be used.
        """
        return pulumi.get(self, "registry_settings")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of values to pass to the helm chart.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AkriConnectorTemplateHelmContainerRegistryResponse(dict):
    """
    AkriConnectorTemplateHelmContainerRegistry properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerRegistrySettings":
            suggest = "container_registry_settings"
        elif key == "registrySettingsType":
            suggest = "registry_settings_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateHelmContainerRegistryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateHelmContainerRegistryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateHelmContainerRegistryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_registry_settings: 'outputs.AkriConnectorTemplateHelmContainerRegistrySettingsResponse',
                 registry_settings_type: _builtins.str):
        """
        AkriConnectorTemplateHelmContainerRegistry properties.
        :param 'AkriConnectorTemplateHelmContainerRegistrySettingsResponse' container_registry_settings: The registry settings for the container registry.
        :param _builtins.str registry_settings_type: AkriConnectorTemplateHelmRegistrySettingsType values.
               Expected value is 'ContainerRegistry'.
        """
        pulumi.set(__self__, "container_registry_settings", container_registry_settings)
        pulumi.set(__self__, "registry_settings_type", 'ContainerRegistry')

    @_builtins.property
    @pulumi.getter(name="containerRegistrySettings")
    def container_registry_settings(self) -> 'outputs.AkriConnectorTemplateHelmContainerRegistrySettingsResponse':
        """
        The registry settings for the container registry.
        """
        return pulumi.get(self, "container_registry_settings")

    @_builtins.property
    @pulumi.getter(name="registrySettingsType")
    def registry_settings_type(self) -> _builtins.str:
        """
        AkriConnectorTemplateHelmRegistrySettingsType values.
        Expected value is 'ContainerRegistry'.
        """
        return pulumi.get(self, "registry_settings_type")


@pulumi.output_type
class AkriConnectorTemplateHelmContainerRegistrySettingsResponse(dict):
    """
    AkriConnectorTemplateHelmContainerRegistrySettings properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authSecretRef":
            suggest = "auth_secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateHelmContainerRegistrySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateHelmContainerRegistrySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateHelmContainerRegistrySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry: _builtins.str,
                 auth_secret_ref: Optional['outputs.AkriConnectorTemplateHelmAuthSecretRefResponse'] = None):
        """
        AkriConnectorTemplateHelmContainerRegistrySettings properties.
        :param _builtins.str registry: The registry to use for the Helm chart.
        :param 'AkriConnectorTemplateHelmAuthSecretRefResponse' auth_secret_ref: Optional reference to a secret in the same namespace to use for pulling the Helm chart.
        """
        pulumi.set(__self__, "registry", registry)
        if auth_secret_ref is not None:
            pulumi.set(__self__, "auth_secret_ref", auth_secret_ref)

    @_builtins.property
    @pulumi.getter
    def registry(self) -> _builtins.str:
        """
        The registry to use for the Helm chart.
        """
        return pulumi.get(self, "registry")

    @_builtins.property
    @pulumi.getter(name="authSecretRef")
    def auth_secret_ref(self) -> Optional['outputs.AkriConnectorTemplateHelmAuthSecretRefResponse']:
        """
        Optional reference to a secret in the same namespace to use for pulling the Helm chart.
        """
        return pulumi.get(self, "auth_secret_ref")


@pulumi.output_type
class AkriConnectorTemplateHelmDeleteConfigurationResponse(dict):
    """
    AkriConnectorTemplateHelmDeleteConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableHooks":
            suggest = "disable_hooks"
        elif key == "waitForJobs":
            suggest = "wait_for_jobs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateHelmDeleteConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateHelmDeleteConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateHelmDeleteConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atomic: Optional[_builtins.bool] = None,
                 disable_hooks: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None,
                 wait: Optional[_builtins.bool] = None,
                 wait_for_jobs: Optional[_builtins.bool] = None):
        """
        AkriConnectorTemplateHelmDeleteConfiguration properties.
        :param _builtins.bool atomic: If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        :param _builtins.bool disable_hooks: Disable pre/post upgrade hooks for the operation.
        :param _builtins.int timeout: Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        :param _builtins.bool wait: If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        :param _builtins.bool wait_for_jobs: If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        if atomic is not None:
            pulumi.set(__self__, "atomic", atomic)
        if disable_hooks is not None:
            pulumi.set(__self__, "disable_hooks", disable_hooks)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)
        if wait_for_jobs is not None:
            pulumi.set(__self__, "wait_for_jobs", wait_for_jobs)

    @_builtins.property
    @pulumi.getter
    def atomic(self) -> Optional[_builtins.bool]:
        """
        If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        """
        return pulumi.get(self, "atomic")

    @_builtins.property
    @pulumi.getter(name="disableHooks")
    def disable_hooks(self) -> Optional[_builtins.bool]:
        """
        Disable pre/post upgrade hooks for the operation.
        """
        return pulumi.get(self, "disable_hooks")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def wait(self) -> Optional[_builtins.bool]:
        """
        If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        """
        return pulumi.get(self, "wait")

    @_builtins.property
    @pulumi.getter(name="waitForJobs")
    def wait_for_jobs(self) -> Optional[_builtins.bool]:
        """
        If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        return pulumi.get(self, "wait_for_jobs")


@pulumi.output_type
class AkriConnectorTemplateHelmInstallConfigurationResponse(dict):
    """
    AkriConnectorTemplateHelmInstallConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableHooks":
            suggest = "disable_hooks"
        elif key == "waitForJobs":
            suggest = "wait_for_jobs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateHelmInstallConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateHelmInstallConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateHelmInstallConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atomic: Optional[_builtins.bool] = None,
                 disable_hooks: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None,
                 wait: Optional[_builtins.bool] = None,
                 wait_for_jobs: Optional[_builtins.bool] = None):
        """
        AkriConnectorTemplateHelmInstallConfiguration properties.
        :param _builtins.bool atomic: If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        :param _builtins.bool disable_hooks: Disable pre/post upgrade hooks for the operation.
        :param _builtins.int timeout: Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        :param _builtins.bool wait: If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        :param _builtins.bool wait_for_jobs: If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        if atomic is not None:
            pulumi.set(__self__, "atomic", atomic)
        if disable_hooks is not None:
            pulumi.set(__self__, "disable_hooks", disable_hooks)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)
        if wait_for_jobs is not None:
            pulumi.set(__self__, "wait_for_jobs", wait_for_jobs)

    @_builtins.property
    @pulumi.getter
    def atomic(self) -> Optional[_builtins.bool]:
        """
        If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        """
        return pulumi.get(self, "atomic")

    @_builtins.property
    @pulumi.getter(name="disableHooks")
    def disable_hooks(self) -> Optional[_builtins.bool]:
        """
        Disable pre/post upgrade hooks for the operation.
        """
        return pulumi.get(self, "disable_hooks")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def wait(self) -> Optional[_builtins.bool]:
        """
        If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        """
        return pulumi.get(self, "wait")

    @_builtins.property
    @pulumi.getter(name="waitForJobs")
    def wait_for_jobs(self) -> Optional[_builtins.bool]:
        """
        If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        return pulumi.get(self, "wait_for_jobs")


@pulumi.output_type
class AkriConnectorTemplateHelmRegistryEndpointRefResponse(dict):
    """
    AkriConnectorTemplateHelmRegistryEndpointRef properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryEndpointRef":
            suggest = "registry_endpoint_ref"
        elif key == "registrySettingsType":
            suggest = "registry_settings_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateHelmRegistryEndpointRefResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateHelmRegistryEndpointRefResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateHelmRegistryEndpointRefResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_endpoint_ref: _builtins.str,
                 registry_settings_type: _builtins.str):
        """
        AkriConnectorTemplateHelmRegistryEndpointRef properties.
        :param _builtins.str registry_endpoint_ref: The name of the registry endpoint.
        :param _builtins.str registry_settings_type: AkriConnectorTemplateHelmRegistrySettingsType values.
               Expected value is 'RegistryEndpointRef'.
        """
        pulumi.set(__self__, "registry_endpoint_ref", registry_endpoint_ref)
        pulumi.set(__self__, "registry_settings_type", 'RegistryEndpointRef')

    @_builtins.property
    @pulumi.getter(name="registryEndpointRef")
    def registry_endpoint_ref(self) -> _builtins.str:
        """
        The name of the registry endpoint.
        """
        return pulumi.get(self, "registry_endpoint_ref")

    @_builtins.property
    @pulumi.getter(name="registrySettingsType")
    def registry_settings_type(self) -> _builtins.str:
        """
        AkriConnectorTemplateHelmRegistrySettingsType values.
        Expected value is 'RegistryEndpointRef'.
        """
        return pulumi.get(self, "registry_settings_type")


@pulumi.output_type
class AkriConnectorTemplateHelmUpgradeConfigurationResponse(dict):
    """
    AkriConnectorTemplateHelmUpgradeConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableHooks":
            suggest = "disable_hooks"
        elif key == "waitForJobs":
            suggest = "wait_for_jobs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateHelmUpgradeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateHelmUpgradeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateHelmUpgradeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atomic: Optional[_builtins.bool] = None,
                 disable_hooks: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None,
                 wait: Optional[_builtins.bool] = None,
                 wait_for_jobs: Optional[_builtins.bool] = None):
        """
        AkriConnectorTemplateHelmUpgradeConfiguration properties.
        :param _builtins.bool atomic: If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        :param _builtins.bool disable_hooks: Disable pre/post upgrade hooks for the operation.
        :param _builtins.int timeout: Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        :param _builtins.bool wait: If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        :param _builtins.bool wait_for_jobs: If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        if atomic is not None:
            pulumi.set(__self__, "atomic", atomic)
        if disable_hooks is not None:
            pulumi.set(__self__, "disable_hooks", disable_hooks)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if wait is not None:
            pulumi.set(__self__, "wait", wait)
        if wait_for_jobs is not None:
            pulumi.set(__self__, "wait_for_jobs", wait_for_jobs)

    @_builtins.property
    @pulumi.getter
    def atomic(self) -> Optional[_builtins.bool]:
        """
        If set, the operation will be atomic. If the operation fails, all changes will be rolled back.
        """
        return pulumi.get(self, "atomic")

    @_builtins.property
    @pulumi.getter(name="disableHooks")
    def disable_hooks(self) -> Optional[_builtins.bool]:
        """
        Disable pre/post upgrade hooks for the operation.
        """
        return pulumi.get(self, "disable_hooks")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Time to wait for any individual Kubernetes operation (like `Jobs` for hooks).
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def wait(self) -> Optional[_builtins.bool]:
        """
        If set, the operation will wait until all Pods, PVCs, Services, and minimum number of Pods of a `Deployment`, `StatefulSet`, or `ReplicaSet` are in a ready state before marking the release as successful.
        """
        return pulumi.get(self, "wait")

    @_builtins.property
    @pulumi.getter(name="waitForJobs")
    def wait_for_jobs(self) -> Optional[_builtins.bool]:
        """
        If set, the operation will wait for jobs to complete before marking the release as successful.
        """
        return pulumi.get(self, "wait_for_jobs")


@pulumi.output_type
class AkriConnectorTemplateManagedConfigurationResponse(dict):
    """
    AkriConnectorTemplateManagedConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedConfigurationSettings":
            suggest = "managed_configuration_settings"
        elif key == "runtimeConfigurationType":
            suggest = "runtime_configuration_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateManagedConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateManagedConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateManagedConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_configuration_settings: Any,
                 runtime_configuration_type: _builtins.str):
        """
        AkriConnectorTemplateManagedConfiguration properties.
        :param Union['AkriConnectorTemplateRuntimeImageConfigurationResponse', 'AkriConnectorTemplateRuntimeStatefulSetConfigurationResponse'] managed_configuration_settings: The managed configuration settings.
        :param _builtins.str runtime_configuration_type: Runtime configuration types.
               Expected value is 'ManagedConfiguration'.
        """
        pulumi.set(__self__, "managed_configuration_settings", managed_configuration_settings)
        pulumi.set(__self__, "runtime_configuration_type", 'ManagedConfiguration')

    @_builtins.property
    @pulumi.getter(name="managedConfigurationSettings")
    def managed_configuration_settings(self) -> Any:
        """
        The managed configuration settings.
        """
        return pulumi.get(self, "managed_configuration_settings")

    @_builtins.property
    @pulumi.getter(name="runtimeConfigurationType")
    def runtime_configuration_type(self) -> _builtins.str:
        """
        Runtime configuration types.
        Expected value is 'ManagedConfiguration'.
        """
        return pulumi.get(self, "runtime_configuration_type")


@pulumi.output_type
class AkriConnectorTemplatePersistentVolumeClaimResponse(dict):
    """
    AkriConnectorTemplatePersistentVolumeClaim properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "claimName":
            suggest = "claim_name"
        elif key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplatePersistentVolumeClaimResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplatePersistentVolumeClaimResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplatePersistentVolumeClaimResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 claim_name: _builtins.str,
                 mount_path: _builtins.str):
        """
        AkriConnectorTemplatePersistentVolumeClaim properties.
        :param _builtins.str claim_name: The name of the persistent volume claim.
        :param _builtins.str mount_path: The mount path for the persistent volume claim.
        """
        pulumi.set(__self__, "claim_name", claim_name)
        pulumi.set(__self__, "mount_path", mount_path)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> _builtins.str:
        """
        The name of the persistent volume claim.
        """
        return pulumi.get(self, "claim_name")

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> _builtins.str:
        """
        The mount path for the persistent volume claim.
        """
        return pulumi.get(self, "mount_path")


@pulumi.output_type
class AkriConnectorTemplatePropertiesResponse(dict):
    """
    AkriConnectorTemplate properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceInboundEndpointTypes":
            suggest = "device_inbound_endpoint_types"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "runtimeConfiguration":
            suggest = "runtime_configuration"
        elif key == "aioMetadata":
            suggest = "aio_metadata"
        elif key == "mqttConnectionConfiguration":
            suggest = "mqtt_connection_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_inbound_endpoint_types: Sequence['outputs.AkriConnectorTemplateDeviceInboundEndpointTypeResponse'],
                 provisioning_state: _builtins.str,
                 runtime_configuration: Any,
                 aio_metadata: Optional['outputs.AkriConnectorTemplateAioMetadataResponse'] = None,
                 diagnostics: Optional['outputs.AkriConnectorTemplateDiagnosticsResponse'] = None,
                 mqtt_connection_configuration: Optional['outputs.AkriConnectorsMqttConnectionConfigurationResponse'] = None):
        """
        AkriConnectorTemplate properties.
        :param Sequence['AkriConnectorTemplateDeviceInboundEndpointTypeResponse'] device_inbound_endpoint_types: Device inbound endpoint types.
        :param _builtins.str provisioning_state: The status of the last operation.
        :param Union['AkriConnectorTemplateHelmConfigurationResponse', 'AkriConnectorTemplateManagedConfigurationResponse'] runtime_configuration: The runtime configuration for the Connector template.
        :param 'AkriConnectorTemplateAioMetadataResponse' aio_metadata: Metadata about AIO.
        :param 'AkriConnectorTemplateDiagnosticsResponse' diagnostics: Diagnostics settings for the Connector template.
        :param 'AkriConnectorsMqttConnectionConfigurationResponse' mqtt_connection_configuration: Mqtt connection configuration settings.
        """
        pulumi.set(__self__, "device_inbound_endpoint_types", device_inbound_endpoint_types)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "runtime_configuration", runtime_configuration)
        if aio_metadata is not None:
            pulumi.set(__self__, "aio_metadata", aio_metadata)
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if mqtt_connection_configuration is not None:
            pulumi.set(__self__, "mqtt_connection_configuration", mqtt_connection_configuration)

    @_builtins.property
    @pulumi.getter(name="deviceInboundEndpointTypes")
    def device_inbound_endpoint_types(self) -> Sequence['outputs.AkriConnectorTemplateDeviceInboundEndpointTypeResponse']:
        """
        Device inbound endpoint types.
        """
        return pulumi.get(self, "device_inbound_endpoint_types")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="runtimeConfiguration")
    def runtime_configuration(self) -> Any:
        """
        The runtime configuration for the Connector template.
        """
        return pulumi.get(self, "runtime_configuration")

    @_builtins.property
    @pulumi.getter(name="aioMetadata")
    def aio_metadata(self) -> Optional['outputs.AkriConnectorTemplateAioMetadataResponse']:
        """
        Metadata about AIO.
        """
        return pulumi.get(self, "aio_metadata")

    @_builtins.property
    @pulumi.getter
    def diagnostics(self) -> Optional['outputs.AkriConnectorTemplateDiagnosticsResponse']:
        """
        Diagnostics settings for the Connector template.
        """
        return pulumi.get(self, "diagnostics")

    @_builtins.property
    @pulumi.getter(name="mqttConnectionConfiguration")
    def mqtt_connection_configuration(self) -> Optional['outputs.AkriConnectorsMqttConnectionConfigurationResponse']:
        """
        Mqtt connection configuration settings.
        """
        return pulumi.get(self, "mqtt_connection_configuration")


@pulumi.output_type
class AkriConnectorTemplateRuntimeImageConfigurationResponse(dict):
    """
    AkriConnectorTemplateRuntimeImageConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageConfigurationSettings":
            suggest = "image_configuration_settings"
        elif key == "managedConfigurationType":
            suggest = "managed_configuration_type"
        elif key == "additionalConfiguration":
            suggest = "additional_configuration"
        elif key == "persistentVolumeClaimTemplates":
            suggest = "persistent_volume_claim_templates"
        elif key == "persistentVolumeClaims":
            suggest = "persistent_volume_claims"
        elif key == "trustSettings":
            suggest = "trust_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateRuntimeImageConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateRuntimeImageConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateRuntimeImageConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_configuration_settings: 'outputs.AkriConnectorTemplateRuntimeImageConfigurationSettingsResponse',
                 managed_configuration_type: _builtins.str,
                 additional_configuration: Optional[Mapping[str, _builtins.str]] = None,
                 allocation: Optional['outputs.AkriConnectorTemplateBucketizedAllocationResponse'] = None,
                 persistent_volume_claim_templates: Optional[Sequence[Any]] = None,
                 persistent_volume_claims: Optional[Sequence['outputs.AkriConnectorTemplatePersistentVolumeClaimResponse']] = None,
                 secrets: Optional[Sequence['outputs.AkriConnectorsSecretResponse']] = None,
                 trust_settings: Optional['outputs.AkriConnectorTemplateTrustListResponse'] = None):
        """
        AkriConnectorTemplateRuntimeImageConfiguration properties.
        :param 'AkriConnectorTemplateRuntimeImageConfigurationSettingsResponse' image_configuration_settings: The image configuration settings.
        :param _builtins.str managed_configuration_type: Managed configuration types.
               Expected value is 'ImageConfiguration'.
        :param Mapping[str, _builtins.str] additional_configuration: Additional configuration for the image of the managed configuration.
        :param 'AkriConnectorTemplateBucketizedAllocationResponse' allocation: Allocation settings for the managed configuration.
        :param Sequence[Any] persistent_volume_claim_templates: The persistent volume claim templates for the managed configuration.
               See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        :param Sequence['AkriConnectorTemplatePersistentVolumeClaimResponse'] persistent_volume_claims: The persistent volume claims for the managed configuration.
        :param Sequence['AkriConnectorsSecretResponse'] secrets: Connector secrets that will be mounted onto all connector instances.
        :param 'AkriConnectorTemplateTrustListResponse' trust_settings: Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
        pulumi.set(__self__, "image_configuration_settings", image_configuration_settings)
        pulumi.set(__self__, "managed_configuration_type", 'ImageConfiguration')
        if additional_configuration is not None:
            pulumi.set(__self__, "additional_configuration", additional_configuration)
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if persistent_volume_claim_templates is not None:
            pulumi.set(__self__, "persistent_volume_claim_templates", persistent_volume_claim_templates)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if trust_settings is not None:
            pulumi.set(__self__, "trust_settings", trust_settings)

    @_builtins.property
    @pulumi.getter(name="imageConfigurationSettings")
    def image_configuration_settings(self) -> 'outputs.AkriConnectorTemplateRuntimeImageConfigurationSettingsResponse':
        """
        The image configuration settings.
        """
        return pulumi.get(self, "image_configuration_settings")

    @_builtins.property
    @pulumi.getter(name="managedConfigurationType")
    def managed_configuration_type(self) -> _builtins.str:
        """
        Managed configuration types.
        Expected value is 'ImageConfiguration'.
        """
        return pulumi.get(self, "managed_configuration_type")

    @_builtins.property
    @pulumi.getter(name="additionalConfiguration")
    def additional_configuration(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional configuration for the image of the managed configuration.
        """
        return pulumi.get(self, "additional_configuration")

    @_builtins.property
    @pulumi.getter
    def allocation(self) -> Optional['outputs.AkriConnectorTemplateBucketizedAllocationResponse']:
        """
        Allocation settings for the managed configuration.
        """
        return pulumi.get(self, "allocation")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaimTemplates")
    def persistent_volume_claim_templates(self) -> Optional[Sequence[Any]]:
        """
        The persistent volume claim templates for the managed configuration.
        See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        """
        return pulumi.get(self, "persistent_volume_claim_templates")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[Sequence['outputs.AkriConnectorTemplatePersistentVolumeClaimResponse']]:
        """
        The persistent volume claims for the managed configuration.
        """
        return pulumi.get(self, "persistent_volume_claims")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.AkriConnectorsSecretResponse']]:
        """
        Connector secrets that will be mounted onto all connector instances.
        """
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter(name="trustSettings")
    def trust_settings(self) -> Optional['outputs.AkriConnectorTemplateTrustListResponse']:
        """
        Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
        return pulumi.get(self, "trust_settings")


@pulumi.output_type
class AkriConnectorTemplateRuntimeImageConfigurationSettingsResponse(dict):
    """
    AkriConnectorTemplateRuntimeImageConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "imagePullPolicy":
            suggest = "image_pull_policy"
        elif key == "registrySettings":
            suggest = "registry_settings"
        elif key == "tagDigestSettings":
            suggest = "tag_digest_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateRuntimeImageConfigurationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateRuntimeImageConfigurationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateRuntimeImageConfigurationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: _builtins.str,
                 image_pull_policy: Optional[_builtins.str] = None,
                 registry_settings: Optional[Any] = None,
                 replicas: Optional[_builtins.int] = None,
                 tag_digest_settings: Optional[Any] = None):
        """
        AkriConnectorTemplateRuntimeImageConfiguration properties.
        :param _builtins.str image_name: The image name without any registry reference, tag or digest.
        :param _builtins.str image_pull_policy: The pull policy of the image.
        :param Union['AkriConnectorsContainerRegistryResponse', 'AkriConnectorsRegistryEndpointRefResponse'] registry_settings: The registry settings for the image. You can omit this field if using the default docker hub repository or using a local image.
        :param _builtins.int replicas: The number of replicas to be set up.
        :param Union['AkriConnectorsDigestResponse', 'AkriConnectorsTagResponse'] tag_digest_settings: Optional image tag or digest. If not specified, the default tag is `latest`.
        """
        pulumi.set(__self__, "image_name", image_name)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if registry_settings is not None:
            pulumi.set(__self__, "registry_settings", registry_settings)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if tag_digest_settings is not None:
            pulumi.set(__self__, "tag_digest_settings", tag_digest_settings)

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> _builtins.str:
        """
        The image name without any registry reference, tag or digest.
        """
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[_builtins.str]:
        """
        The pull policy of the image.
        """
        return pulumi.get(self, "image_pull_policy")

    @_builtins.property
    @pulumi.getter(name="registrySettings")
    def registry_settings(self) -> Optional[Any]:
        """
        The registry settings for the image. You can omit this field if using the default docker hub repository or using a local image.
        """
        return pulumi.get(self, "registry_settings")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[_builtins.int]:
        """
        The number of replicas to be set up.
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter(name="tagDigestSettings")
    def tag_digest_settings(self) -> Optional[Any]:
        """
        Optional image tag or digest. If not specified, the default tag is `latest`.
        """
        return pulumi.get(self, "tag_digest_settings")


@pulumi.output_type
class AkriConnectorTemplateRuntimeStatefulSetConfigurationResponse(dict):
    """
    AkriConnectorTemplateRuntimeStatefulSetConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedConfigurationType":
            suggest = "managed_configuration_type"
        elif key == "statefulSetConfigurationSettings":
            suggest = "stateful_set_configuration_settings"
        elif key == "additionalConfiguration":
            suggest = "additional_configuration"
        elif key == "persistentVolumeClaimTemplates":
            suggest = "persistent_volume_claim_templates"
        elif key == "persistentVolumeClaims":
            suggest = "persistent_volume_claims"
        elif key == "trustSettings":
            suggest = "trust_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateRuntimeStatefulSetConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateRuntimeStatefulSetConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateRuntimeStatefulSetConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_configuration_type: _builtins.str,
                 stateful_set_configuration_settings: Any,
                 additional_configuration: Optional[Mapping[str, _builtins.str]] = None,
                 allocation: Optional['outputs.AkriConnectorTemplateBucketizedAllocationResponse'] = None,
                 persistent_volume_claim_templates: Optional[Sequence[Any]] = None,
                 persistent_volume_claims: Optional[Sequence['outputs.AkriConnectorTemplatePersistentVolumeClaimResponse']] = None,
                 secrets: Optional[Sequence['outputs.AkriConnectorsSecretResponse']] = None,
                 trust_settings: Optional['outputs.AkriConnectorTemplateTrustListResponse'] = None):
        """
        AkriConnectorTemplateRuntimeStatefulSetConfiguration properties.
        :param _builtins.str managed_configuration_type: Managed configuration types.
               Expected value is 'StatefulSetConfiguration'.
        :param Any stateful_set_configuration_settings: The stateful set configuration settings. This corresponds to the Kubernetes StatefulSet resource.
               See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json#/components/schemas/io.k8s.api.apps.v1.StatefulSetSpec
        :param Mapping[str, _builtins.str] additional_configuration: Additional configuration for the image of the managed configuration.
        :param 'AkriConnectorTemplateBucketizedAllocationResponse' allocation: Allocation settings for the managed configuration.
        :param Sequence[Any] persistent_volume_claim_templates: The persistent volume claim templates for the managed configuration.
               See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        :param Sequence['AkriConnectorTemplatePersistentVolumeClaimResponse'] persistent_volume_claims: The persistent volume claims for the managed configuration.
        :param Sequence['AkriConnectorsSecretResponse'] secrets: Connector secrets that will be mounted onto all connector instances.
        :param 'AkriConnectorTemplateTrustListResponse' trust_settings: Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
        pulumi.set(__self__, "managed_configuration_type", 'StatefulSetConfiguration')
        pulumi.set(__self__, "stateful_set_configuration_settings", stateful_set_configuration_settings)
        if additional_configuration is not None:
            pulumi.set(__self__, "additional_configuration", additional_configuration)
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if persistent_volume_claim_templates is not None:
            pulumi.set(__self__, "persistent_volume_claim_templates", persistent_volume_claim_templates)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if trust_settings is not None:
            pulumi.set(__self__, "trust_settings", trust_settings)

    @_builtins.property
    @pulumi.getter(name="managedConfigurationType")
    def managed_configuration_type(self) -> _builtins.str:
        """
        Managed configuration types.
        Expected value is 'StatefulSetConfiguration'.
        """
        return pulumi.get(self, "managed_configuration_type")

    @_builtins.property
    @pulumi.getter(name="statefulSetConfigurationSettings")
    def stateful_set_configuration_settings(self) -> Any:
        """
        The stateful set configuration settings. This corresponds to the Kubernetes StatefulSet resource.
        See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json#/components/schemas/io.k8s.api.apps.v1.StatefulSetSpec
        """
        return pulumi.get(self, "stateful_set_configuration_settings")

    @_builtins.property
    @pulumi.getter(name="additionalConfiguration")
    def additional_configuration(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional configuration for the image of the managed configuration.
        """
        return pulumi.get(self, "additional_configuration")

    @_builtins.property
    @pulumi.getter
    def allocation(self) -> Optional['outputs.AkriConnectorTemplateBucketizedAllocationResponse']:
        """
        Allocation settings for the managed configuration.
        """
        return pulumi.get(self, "allocation")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaimTemplates")
    def persistent_volume_claim_templates(self) -> Optional[Sequence[Any]]:
        """
        The persistent volume claim templates for the managed configuration.
        See https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
        """
        return pulumi.get(self, "persistent_volume_claim_templates")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[Sequence['outputs.AkriConnectorTemplatePersistentVolumeClaimResponse']]:
        """
        The persistent volume claims for the managed configuration.
        """
        return pulumi.get(self, "persistent_volume_claims")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.AkriConnectorsSecretResponse']]:
        """
        Connector secrets that will be mounted onto all connector instances.
        """
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter(name="trustSettings")
    def trust_settings(self) -> Optional['outputs.AkriConnectorTemplateTrustListResponse']:
        """
        Trust list for the connector. This is used to specify the certificates that all connector instances should trust.
        """
        return pulumi.get(self, "trust_settings")


@pulumi.output_type
class AkriConnectorTemplateTrustListResponse(dict):
    """
    AkriConnectorTemplateTrustList properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustListSecretRef":
            suggest = "trust_list_secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorTemplateTrustListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorTemplateTrustListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorTemplateTrustListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust_list_secret_ref: _builtins.str):
        """
        AkriConnectorTemplateTrustList properties.
        :param _builtins.str trust_list_secret_ref: The secret reference for certificates to trust.
        """
        pulumi.set(__self__, "trust_list_secret_ref", trust_list_secret_ref)

    @_builtins.property
    @pulumi.getter(name="trustListSecretRef")
    def trust_list_secret_ref(self) -> _builtins.str:
        """
        The secret reference for certificates to trust.
        """
        return pulumi.get(self, "trust_list_secret_ref")


@pulumi.output_type
class AkriConnectorsContainerRegistryResponse(dict):
    """
    AkriConnectorsContainerRegistry properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerRegistrySettings":
            suggest = "container_registry_settings"
        elif key == "registrySettingsType":
            suggest = "registry_settings_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorsContainerRegistryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorsContainerRegistryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorsContainerRegistryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_registry_settings: 'outputs.AkriConnectorsContainerRegistrySettingsResponse',
                 registry_settings_type: _builtins.str):
        """
        AkriConnectorsContainerRegistry properties.
        :param 'AkriConnectorsContainerRegistrySettingsResponse' container_registry_settings: The registry settings for the container registry.
        :param _builtins.str registry_settings_type: AkriConnectorsRegistrySettings properties.
               Expected value is 'ContainerRegistry'.
        """
        pulumi.set(__self__, "container_registry_settings", container_registry_settings)
        pulumi.set(__self__, "registry_settings_type", 'ContainerRegistry')

    @_builtins.property
    @pulumi.getter(name="containerRegistrySettings")
    def container_registry_settings(self) -> 'outputs.AkriConnectorsContainerRegistrySettingsResponse':
        """
        The registry settings for the container registry.
        """
        return pulumi.get(self, "container_registry_settings")

    @_builtins.property
    @pulumi.getter(name="registrySettingsType")
    def registry_settings_type(self) -> _builtins.str:
        """
        AkriConnectorsRegistrySettings properties.
        Expected value is 'ContainerRegistry'.
        """
        return pulumi.get(self, "registry_settings_type")


@pulumi.output_type
class AkriConnectorsContainerRegistrySettingsResponse(dict):
    """
    AkriConnectorsContainerRegistry properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imagePullSecrets":
            suggest = "image_pull_secrets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorsContainerRegistrySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorsContainerRegistrySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorsContainerRegistrySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry: _builtins.str,
                 image_pull_secrets: Optional[Sequence['outputs.AkriConnectorsImagePullSecretResponse']] = None):
        """
        AkriConnectorsContainerRegistry properties.
        :param _builtins.str registry: The container registry to use for the artifact.
        :param Sequence['AkriConnectorsImagePullSecretResponse'] image_pull_secrets: Optional list of references to secrets in the same namespace to use for pulling the connector image.
        """
        pulumi.set(__self__, "registry", registry)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)

    @_builtins.property
    @pulumi.getter
    def registry(self) -> _builtins.str:
        """
        The container registry to use for the artifact.
        """
        return pulumi.get(self, "registry")

    @_builtins.property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.AkriConnectorsImagePullSecretResponse']]:
        """
        Optional list of references to secrets in the same namespace to use for pulling the connector image.
        """
        return pulumi.get(self, "image_pull_secrets")


@pulumi.output_type
class AkriConnectorsDiagnosticsLogsResponse(dict):
    """
    AkriConnectorsDiagnostic Log properties.
    """
    def __init__(__self__, *,
                 level: Optional[_builtins.str] = None):
        """
        AkriConnectorsDiagnostic Log properties.
        :param _builtins.str level: The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        if level is None:
            level = 'info'
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class AkriConnectorsDigestResponse(dict):
    """
    AkriConnectorsDigest properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagDigestType":
            suggest = "tag_digest_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorsDigestResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorsDigestResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorsDigestResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digest: _builtins.str,
                 tag_digest_type: _builtins.str):
        """
        AkriConnectorsDigest properties.
        :param _builtins.str digest: The digest of the image.
        :param _builtins.str tag_digest_type: AkriConnectorsTagDigestType values.
               Expected value is 'Digest'.
        """
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "tag_digest_type", 'Digest')

    @_builtins.property
    @pulumi.getter
    def digest(self) -> _builtins.str:
        """
        The digest of the image.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter(name="tagDigestType")
    def tag_digest_type(self) -> _builtins.str:
        """
        AkriConnectorsTagDigestType values.
        Expected value is 'Digest'.
        """
        return pulumi.get(self, "tag_digest_type")


@pulumi.output_type
class AkriConnectorsImagePullSecretResponse(dict):
    """
    AkriConnectorsImagePullSecret properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorsImagePullSecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorsImagePullSecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorsImagePullSecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: _builtins.str):
        """
        AkriConnectorsImagePullSecret properties.
        :param _builtins.str secret_ref: The name of the image pull secret.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> _builtins.str:
        """
        The name of the image pull secret.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class AkriConnectorsMqttConnectionConfigurationResponse(dict):
    """
    AkriConnectorsMqttConnectionConfiguration properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepAliveSeconds":
            suggest = "keep_alive_seconds"
        elif key == "maxInflightMessages":
            suggest = "max_inflight_messages"
        elif key == "sessionExpirySeconds":
            suggest = "session_expiry_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorsMqttConnectionConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorsMqttConnectionConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorsMqttConnectionConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: Optional['outputs.AkriConnectorsServiceAccountAuthenticationResponse'] = None,
                 host: Optional[_builtins.str] = None,
                 keep_alive_seconds: Optional[_builtins.int] = None,
                 max_inflight_messages: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 session_expiry_seconds: Optional[_builtins.int] = None,
                 tls: Optional['outputs.TlsPropertiesResponse'] = None):
        """
        AkriConnectorsMqttConnectionConfiguration properties.
        :param 'AkriConnectorsServiceAccountAuthenticationResponse' authentication: Authentication properties.
        :param _builtins.str host: Host of the Broker in the form of <hostname>:<port>.
        :param _builtins.int keep_alive_seconds: KeepAlive for connection in seconds.
        :param _builtins.int max_inflight_messages: The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        :param _builtins.str protocol: The protocol to use for the connection. Currently only `mqtt` is supported.
        :param _builtins.int session_expiry_seconds: Session expiry in seconds.
        :param 'TlsPropertiesResponse' tls: TLS configuration.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_alive_seconds is not None:
            pulumi.set(__self__, "keep_alive_seconds", keep_alive_seconds)
        if max_inflight_messages is not None:
            pulumi.set(__self__, "max_inflight_messages", max_inflight_messages)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if session_expiry_seconds is not None:
            pulumi.set(__self__, "session_expiry_seconds", session_expiry_seconds)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.AkriConnectorsServiceAccountAuthenticationResponse']:
        """
        Authentication properties.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Host of the Broker in the form of <hostname>:<port>.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="keepAliveSeconds")
    def keep_alive_seconds(self) -> Optional[_builtins.int]:
        """
        KeepAlive for connection in seconds.
        """
        return pulumi.get(self, "keep_alive_seconds")

    @_builtins.property
    @pulumi.getter(name="maxInflightMessages")
    def max_inflight_messages(self) -> Optional[_builtins.int]:
        """
        The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        """
        return pulumi.get(self, "max_inflight_messages")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The protocol to use for the connection. Currently only `mqtt` is supported.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sessionExpirySeconds")
    def session_expiry_seconds(self) -> Optional[_builtins.int]:
        """
        Session expiry in seconds.
        """
        return pulumi.get(self, "session_expiry_seconds")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.TlsPropertiesResponse']:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class AkriConnectorsRegistryEndpointRefResponse(dict):
    """
    AkriConnectorsRegistryEndpointRef properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryEndpointRef":
            suggest = "registry_endpoint_ref"
        elif key == "registrySettingsType":
            suggest = "registry_settings_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorsRegistryEndpointRefResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorsRegistryEndpointRefResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorsRegistryEndpointRefResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_endpoint_ref: _builtins.str,
                 registry_settings_type: _builtins.str):
        """
        AkriConnectorsRegistryEndpointRef properties.
        :param _builtins.str registry_endpoint_ref: The name of the registry endpoint.
        :param _builtins.str registry_settings_type: AkriConnectorsRegistrySettings properties.
               Expected value is 'RegistryEndpointRef'.
        """
        pulumi.set(__self__, "registry_endpoint_ref", registry_endpoint_ref)
        pulumi.set(__self__, "registry_settings_type", 'RegistryEndpointRef')

    @_builtins.property
    @pulumi.getter(name="registryEndpointRef")
    def registry_endpoint_ref(self) -> _builtins.str:
        """
        The name of the registry endpoint.
        """
        return pulumi.get(self, "registry_endpoint_ref")

    @_builtins.property
    @pulumi.getter(name="registrySettingsType")
    def registry_settings_type(self) -> _builtins.str:
        """
        AkriConnectorsRegistrySettings properties.
        Expected value is 'RegistryEndpointRef'.
        """
        return pulumi.get(self, "registry_settings_type")


@pulumi.output_type
class AkriConnectorsSecretResponse(dict):
    """
    AkriConnectorsSecret properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretAlias":
            suggest = "secret_alias"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorsSecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorsSecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorsSecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_alias: _builtins.str,
                 secret_key: _builtins.str,
                 secret_ref: _builtins.str):
        """
        AkriConnectorsSecret properties.
        :param _builtins.str secret_alias: The application-defined alias for the secret.
        :param _builtins.str secret_key: The key in the secret to be mounted.
        :param _builtins.str secret_ref: The name of the secret to be mounted.
        """
        pulumi.set(__self__, "secret_alias", secret_alias)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretAlias")
    def secret_alias(self) -> _builtins.str:
        """
        The application-defined alias for the secret.
        """
        return pulumi.get(self, "secret_alias")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        The key in the secret to be mounted.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> _builtins.str:
        """
        The name of the secret to be mounted.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class AkriConnectorsServiceAccountAuthenticationResponse(dict):
    """
    AkriConnectorsServiceAccountAuthentication properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountTokenSettings":
            suggest = "service_account_token_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorsServiceAccountAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorsServiceAccountAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorsServiceAccountAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 service_account_token_settings: 'outputs.AkriConnectorsServiceAccountTokenSettingsResponse'):
        """
        AkriConnectorsServiceAccountAuthentication properties.
        :param _builtins.str method: AkriConnectorsMqttAuthenticationMethod properties.
               Expected value is 'ServiceAccountToken'.
        :param 'AkriConnectorsServiceAccountTokenSettingsResponse' service_account_token_settings: The service account token for the MQTT connection.
        """
        pulumi.set(__self__, "method", 'ServiceAccountToken')
        pulumi.set(__self__, "service_account_token_settings", service_account_token_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        AkriConnectorsMqttAuthenticationMethod properties.
        Expected value is 'ServiceAccountToken'.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="serviceAccountTokenSettings")
    def service_account_token_settings(self) -> 'outputs.AkriConnectorsServiceAccountTokenSettingsResponse':
        """
        The service account token for the MQTT connection.
        """
        return pulumi.get(self, "service_account_token_settings")


@pulumi.output_type
class AkriConnectorsServiceAccountTokenSettingsResponse(dict):
    """
    AkriConnectorsServiceAccountTokenSettings properties.
    """
    def __init__(__self__, *,
                 audience: _builtins.str):
        """
        AkriConnectorsServiceAccountTokenSettings properties.
        :param _builtins.str audience: The audience for the service account token.
        """
        pulumi.set(__self__, "audience", audience)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> _builtins.str:
        """
        The audience for the service account token.
        """
        return pulumi.get(self, "audience")


@pulumi.output_type
class AkriConnectorsTagResponse(dict):
    """
    AkriConnectorsTag properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagDigestType":
            suggest = "tag_digest_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AkriConnectorsTagResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AkriConnectorsTagResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AkriConnectorsTagResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag: _builtins.str,
                 tag_digest_type: _builtins.str):
        """
        AkriConnectorsTag properties.
        :param _builtins.str tag: The tag of the image.
        :param _builtins.str tag_digest_type: AkriConnectorsTagDigestType values.
               Expected value is 'Tag'.
        """
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tag_digest_type", 'Tag')

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        The tag of the image.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter(name="tagDigestType")
    def tag_digest_type(self) -> _builtins.str:
        """
        AkriConnectorsTagDigestType values.
        Expected value is 'Tag'.
        """
        return pulumi.get(self, "tag_digest_type")


@pulumi.output_type
class AuthorizationConfigResponse(dict):
    """
    Broker AuthorizationConfig properties
    """
    def __init__(__self__, *,
                 cache: Optional[_builtins.str] = None,
                 rules: Optional[Sequence['outputs.AuthorizationRuleResponse']] = None):
        """
        Broker AuthorizationConfig properties
        :param _builtins.str cache: Enable caching of the authorization rules.
        :param Sequence['AuthorizationRuleResponse'] rules: The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        if cache is None:
            cache = 'Enabled'
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def cache(self) -> Optional[_builtins.str]:
        """
        Enable caching of the authorization rules.
        """
        return pulumi.get(self, "cache")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AuthorizationRuleResponse']]:
        """
        The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AuthorizationRuleResponse(dict):
    """
    AuthorizationConfig Rule Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brokerResources":
            suggest = "broker_resources"
        elif key == "stateStoreResources":
            suggest = "state_store_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker_resources: Sequence['outputs.BrokerResourceRuleResponse'],
                 principals: 'outputs.PrincipalDefinitionResponse',
                 state_store_resources: Optional[Sequence['outputs.StateStoreResourceRuleResponse']] = None):
        """
        AuthorizationConfig Rule Properties
        :param Sequence['BrokerResourceRuleResponse'] broker_resources: Give access to Broker methods and topics.
        :param 'PrincipalDefinitionResponse' principals: Give access to clients based on the following properties.
        :param Sequence['StateStoreResourceRuleResponse'] state_store_resources: Give access to state store resources.
        """
        pulumi.set(__self__, "broker_resources", broker_resources)
        pulumi.set(__self__, "principals", principals)
        if state_store_resources is not None:
            pulumi.set(__self__, "state_store_resources", state_store_resources)

    @_builtins.property
    @pulumi.getter(name="brokerResources")
    def broker_resources(self) -> Sequence['outputs.BrokerResourceRuleResponse']:
        """
        Give access to Broker methods and topics.
        """
        return pulumi.get(self, "broker_resources")

    @_builtins.property
    @pulumi.getter
    def principals(self) -> 'outputs.PrincipalDefinitionResponse':
        """
        Give access to clients based on the following properties.
        """
        return pulumi.get(self, "principals")

    @_builtins.property
    @pulumi.getter(name="stateStoreResources")
    def state_store_resources(self) -> Optional[Sequence['outputs.StateStoreResourceRuleResponse']]:
        """
        Give access to state store resources.
        """
        return pulumi.get(self, "state_store_resources")


@pulumi.output_type
class BackendChainResponse(dict):
    """
    Desired properties of the backend instances of the broker
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redundancyFactor":
            suggest = "redundancy_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendChainResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendChainResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendChainResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partitions: _builtins.int,
                 redundancy_factor: _builtins.int,
                 workers: Optional[_builtins.int] = None):
        """
        Desired properties of the backend instances of the broker
        :param _builtins.int partitions: The desired number of physical backend partitions.
        :param _builtins.int redundancy_factor: The desired numbers of backend replicas (pods) in a physical partition.
        :param _builtins.int workers: Number of logical backend workers per replica (pod).
        """
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "redundancy_factor", redundancy_factor)
        if workers is None:
            workers = 1
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> _builtins.int:
        """
        The desired number of physical backend partitions.
        """
        return pulumi.get(self, "partitions")

    @_builtins.property
    @pulumi.getter(name="redundancyFactor")
    def redundancy_factor(self) -> _builtins.int:
        """
        The desired numbers of backend replicas (pods) in a physical partition.
        """
        return pulumi.get(self, "redundancy_factor")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[_builtins.int]:
        """
        Number of logical backend workers per replica (pod).
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class BatchingConfigurationResponse(dict):
    """
    Batching configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latencySeconds":
            suggest = "latency_seconds"
        elif key == "maxMessages":
            suggest = "max_messages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latency_seconds: Optional[_builtins.int] = None,
                 max_messages: Optional[_builtins.int] = None):
        """
        Batching configuration
        :param _builtins.int latency_seconds: Batching latency in seconds.
        :param _builtins.int max_messages: Maximum number of messages in a batch.
        """
        if latency_seconds is None:
            latency_seconds = 60
        if latency_seconds is not None:
            pulumi.set(__self__, "latency_seconds", latency_seconds)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)

    @_builtins.property
    @pulumi.getter(name="latencySeconds")
    def latency_seconds(self) -> Optional[_builtins.int]:
        """
        Batching latency in seconds.
        """
        return pulumi.get(self, "latency_seconds")

    @_builtins.property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[_builtins.int]:
        """
        Maximum number of messages in a batch.
        """
        return pulumi.get(self, "max_messages")


@pulumi.output_type
class BrokerAuthenticationPropertiesResponse(dict):
    """
    BrokerAuthentication Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethods":
            suggest = "authentication_methods"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_methods: Sequence['outputs.BrokerAuthenticatorMethodsResponse'],
                 provisioning_state: _builtins.str):
        """
        BrokerAuthentication Resource properties
        :param Sequence['BrokerAuthenticatorMethodsResponse'] authentication_methods: Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        :param _builtins.str provisioning_state: The status of the last operation.
        """
        pulumi.set(__self__, "authentication_methods", authentication_methods)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @_builtins.property
    @pulumi.getter(name="authenticationMethods")
    def authentication_methods(self) -> Sequence['outputs.BrokerAuthenticatorMethodsResponse']:
        """
        Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        """
        return pulumi.get(self, "authentication_methods")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class BrokerAuthenticatorCustomAuthResponse(dict):
    """
    Custom Authentication properties
    """
    def __init__(__self__, *,
                 x509: 'outputs.X509ManualCertificateResponse'):
        """
        Custom Authentication properties
        :param 'X509ManualCertificateResponse' x509: X509 Custom Auth type details.
        """
        pulumi.set(__self__, "x509", x509)

    @_builtins.property
    @pulumi.getter
    def x509(self) -> 'outputs.X509ManualCertificateResponse':
        """
        X509 Custom Auth type details.
        """
        return pulumi.get(self, "x509")


@pulumi.output_type
class BrokerAuthenticatorMethodCustomResponse(dict):
    """
    Custom method for BrokerAuthentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertConfigMap":
            suggest = "ca_cert_config_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 auth: Optional['outputs.BrokerAuthenticatorCustomAuthResponse'] = None,
                 ca_cert_config_map: Optional[_builtins.str] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None):
        """
        Custom method for BrokerAuthentication
        :param _builtins.str endpoint: Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        :param 'BrokerAuthenticatorCustomAuthResponse' auth: Optional authentication needed for authenticating with the custom authentication server.
        :param _builtins.str ca_cert_config_map: Optional CA certificate for validating the custom authentication server's certificate.
        :param Mapping[str, _builtins.str] headers: Additional HTTP headers to pass to the custom authentication server.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if ca_cert_config_map is not None:
            pulumi.set(__self__, "ca_cert_config_map", ca_cert_config_map)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.BrokerAuthenticatorCustomAuthResponse']:
        """
        Optional authentication needed for authenticating with the custom authentication server.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter(name="caCertConfigMap")
    def ca_cert_config_map(self) -> Optional[_builtins.str]:
        """
        Optional CA certificate for validating the custom authentication server's certificate.
        """
        return pulumi.get(self, "ca_cert_config_map")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional HTTP headers to pass to the custom authentication server.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class BrokerAuthenticatorMethodSatResponse(dict):
    """
    Service Account Token for BrokerAuthentication
    """
    def __init__(__self__, *,
                 audiences: Sequence[_builtins.str]):
        """
        Service Account Token for BrokerAuthentication
        :param Sequence[_builtins.str] audiences: List of allowed audience.
        """
        pulumi.set(__self__, "audiences", audiences)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Sequence[_builtins.str]:
        """
        List of allowed audience.
        """
        return pulumi.get(self, "audiences")


@pulumi.output_type
class BrokerAuthenticatorMethodX509AttributesResponse(dict):
    """
    BrokerAuthenticatorMethodX509Attributes properties.
    """
    def __init__(__self__, *,
                 attributes: Mapping[str, _builtins.str],
                 subject: _builtins.str):
        """
        BrokerAuthenticatorMethodX509Attributes properties.
        :param Mapping[str, _builtins.str] attributes: Attributes object.
        :param _builtins.str subject: Subject of the X509 attribute.
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Mapping[str, _builtins.str]:
        """
        Attributes object.
        """
        return pulumi.get(self, "attributes")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        Subject of the X509 attribute.
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class BrokerAuthenticatorMethodX509Response(dict):
    """
    X509 for BrokerAuthentication.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationAttributes":
            suggest = "authorization_attributes"
        elif key == "trustedClientCaCert":
            suggest = "trusted_client_ca_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodX509Response. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodX509Response.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodX509Response.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_attributes: Optional[Mapping[str, 'outputs.BrokerAuthenticatorMethodX509AttributesResponse']] = None,
                 trusted_client_ca_cert: Optional[_builtins.str] = None):
        """
        X509 for BrokerAuthentication.
        :param Mapping[str, 'BrokerAuthenticatorMethodX509AttributesResponse'] authorization_attributes: X509 authorization attributes properties.
        :param _builtins.str trusted_client_ca_cert: Name of the trusted client ca cert resource.
        """
        if authorization_attributes is not None:
            pulumi.set(__self__, "authorization_attributes", authorization_attributes)
        if trusted_client_ca_cert is None:
            trusted_client_ca_cert = 'client-ca'
        if trusted_client_ca_cert is not None:
            pulumi.set(__self__, "trusted_client_ca_cert", trusted_client_ca_cert)

    @_builtins.property
    @pulumi.getter(name="authorizationAttributes")
    def authorization_attributes(self) -> Optional[Mapping[str, 'outputs.BrokerAuthenticatorMethodX509AttributesResponse']]:
        """
        X509 authorization attributes properties.
        """
        return pulumi.get(self, "authorization_attributes")

    @_builtins.property
    @pulumi.getter(name="trustedClientCaCert")
    def trusted_client_ca_cert(self) -> Optional[_builtins.str]:
        """
        Name of the trusted client ca cert resource.
        """
        return pulumi.get(self, "trusted_client_ca_cert")


@pulumi.output_type
class BrokerAuthenticatorMethodsResponse(dict):
    """
    Set of broker authentication policies. Only one method is supported for each entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customSettings":
            suggest = "custom_settings"
        elif key == "serviceAccountTokenSettings":
            suggest = "service_account_token_settings"
        elif key == "x509Settings":
            suggest = "x509_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 custom_settings: Optional['outputs.BrokerAuthenticatorMethodCustomResponse'] = None,
                 service_account_token_settings: Optional['outputs.BrokerAuthenticatorMethodSatResponse'] = None,
                 x509_settings: Optional['outputs.BrokerAuthenticatorMethodX509Response'] = None):
        """
        Set of broker authentication policies. Only one method is supported for each entry.
        :param _builtins.str method: Custom authentication configuration.
        :param 'BrokerAuthenticatorMethodCustomResponse' custom_settings: Custom authentication configuration.
        :param 'BrokerAuthenticatorMethodSatResponse' service_account_token_settings: ServiceAccountToken authentication configuration.
        :param 'BrokerAuthenticatorMethodX509Response' x509_settings: X.509 authentication configuration.
        """
        pulumi.set(__self__, "method", method)
        if custom_settings is not None:
            pulumi.set(__self__, "custom_settings", custom_settings)
        if service_account_token_settings is not None:
            pulumi.set(__self__, "service_account_token_settings", service_account_token_settings)
        if x509_settings is not None:
            pulumi.set(__self__, "x509_settings", x509_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Custom authentication configuration.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="customSettings")
    def custom_settings(self) -> Optional['outputs.BrokerAuthenticatorMethodCustomResponse']:
        """
        Custom authentication configuration.
        """
        return pulumi.get(self, "custom_settings")

    @_builtins.property
    @pulumi.getter(name="serviceAccountTokenSettings")
    def service_account_token_settings(self) -> Optional['outputs.BrokerAuthenticatorMethodSatResponse']:
        """
        ServiceAccountToken authentication configuration.
        """
        return pulumi.get(self, "service_account_token_settings")

    @_builtins.property
    @pulumi.getter(name="x509Settings")
    def x509_settings(self) -> Optional['outputs.BrokerAuthenticatorMethodX509Response']:
        """
        X.509 authentication configuration.
        """
        return pulumi.get(self, "x509_settings")


@pulumi.output_type
class BrokerAuthorizationPropertiesResponse(dict):
    """
    BrokerAuthorization Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationPolicies":
            suggest = "authorization_policies"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthorizationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthorizationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthorizationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_policies: 'outputs.AuthorizationConfigResponse',
                 provisioning_state: _builtins.str):
        """
        BrokerAuthorization Resource properties
        :param 'AuthorizationConfigResponse' authorization_policies: The list of authorization policies supported by the Authorization Resource.
        :param _builtins.str provisioning_state: The status of the last operation.
        """
        pulumi.set(__self__, "authorization_policies", authorization_policies)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @_builtins.property
    @pulumi.getter(name="authorizationPolicies")
    def authorization_policies(self) -> 'outputs.AuthorizationConfigResponse':
        """
        The list of authorization policies supported by the Authorization Resource.
        """
        return pulumi.get(self, "authorization_policies")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class BrokerDiagnosticsResponse(dict):
    """
    Broker Diagnostic Setting properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selfCheck":
            suggest = "self_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerDiagnosticsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerDiagnosticsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerDiagnosticsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs: Optional['outputs.DiagnosticsLogsResponse'] = None,
                 metrics: Optional['outputs.MetricsResponse'] = None,
                 self_check: Optional['outputs.SelfCheckResponse'] = None,
                 traces: Optional['outputs.TracesResponse'] = None):
        """
        Broker Diagnostic Setting properties
        :param 'DiagnosticsLogsResponse' logs: Diagnostic log settings for the resource.
        :param 'MetricsResponse' metrics: The metrics settings for the resource.
        :param 'SelfCheckResponse' self_check: The self check properties.
        :param 'TracesResponse' traces: The trace properties.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if self_check is not None:
            pulumi.set(__self__, "self_check", self_check)
        if traces is not None:
            pulumi.set(__self__, "traces", traces)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional['outputs.DiagnosticsLogsResponse']:
        """
        Diagnostic log settings for the resource.
        """
        return pulumi.get(self, "logs")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.MetricsResponse']:
        """
        The metrics settings for the resource.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="selfCheck")
    def self_check(self) -> Optional['outputs.SelfCheckResponse']:
        """
        The self check properties.
        """
        return pulumi.get(self, "self_check")

    @_builtins.property
    @pulumi.getter
    def traces(self) -> Optional['outputs.TracesResponse']:
        """
        The trace properties.
        """
        return pulumi.get(self, "traces")


@pulumi.output_type
class BrokerListenerPropertiesResponse(dict):
    """
    Defines a Broker listener. A listener is a collection of ports on which the broker accepts connections from clients.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceType":
            suggest = "service_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerListenerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerListenerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerListenerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ports: Sequence['outputs.ListenerPortResponse'],
                 provisioning_state: _builtins.str,
                 service_name: Optional[_builtins.str] = None,
                 service_type: Optional[_builtins.str] = None):
        """
        Defines a Broker listener. A listener is a collection of ports on which the broker accepts connections from clients.
        :param Sequence['ListenerPortResponse'] ports: Ports on which this listener accepts client connections.
        :param _builtins.str provisioning_state: The status of the last operation.
        :param _builtins.str service_name: Kubernetes Service name of this listener.
        :param _builtins.str service_type: Kubernetes Service type of this listener.
        """
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_type is None:
            service_type = 'ClusterIp'
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.ListenerPortResponse']:
        """
        Ports on which this listener accepts client connections.
        """
        return pulumi.get(self, "ports")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        Kubernetes Service name of this listener.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[_builtins.str]:
        """
        Kubernetes Service type of this listener.
        """
        return pulumi.get(self, "service_type")


@pulumi.output_type
class BrokerPropertiesResponse(dict):
    """
    Broker Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "diskBackedMessageBuffer":
            suggest = "disk_backed_message_buffer"
        elif key == "generateResourceLimits":
            suggest = "generate_resource_limits"
        elif key == "memoryProfile":
            suggest = "memory_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 advanced: Optional['outputs.AdvancedSettingsResponse'] = None,
                 cardinality: Optional['outputs.CardinalityResponse'] = None,
                 diagnostics: Optional['outputs.BrokerDiagnosticsResponse'] = None,
                 disk_backed_message_buffer: Optional['outputs.DiskBackedMessageBufferResponse'] = None,
                 generate_resource_limits: Optional['outputs.GenerateResourceLimitsResponse'] = None,
                 memory_profile: Optional[_builtins.str] = None):
        """
        Broker Resource properties
        :param _builtins.str provisioning_state: The status of the last operation.
        :param 'AdvancedSettingsResponse' advanced: Advanced settings of Broker.
        :param 'CardinalityResponse' cardinality: The cardinality details of the broker.
        :param 'BrokerDiagnosticsResponse' diagnostics: Spec defines the desired identities of Broker diagnostics settings.
        :param 'DiskBackedMessageBufferResponse' disk_backed_message_buffer: Settings of Disk Backed Message Buffer.
        :param 'GenerateResourceLimitsResponse' generate_resource_limits: This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        :param _builtins.str memory_profile: Memory profile of Broker.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if advanced is not None:
            pulumi.set(__self__, "advanced", advanced)
        if cardinality is not None:
            pulumi.set(__self__, "cardinality", cardinality)
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if disk_backed_message_buffer is not None:
            pulumi.set(__self__, "disk_backed_message_buffer", disk_backed_message_buffer)
        if generate_resource_limits is not None:
            pulumi.set(__self__, "generate_resource_limits", generate_resource_limits)
        if memory_profile is None:
            memory_profile = 'Medium'
        if memory_profile is not None:
            pulumi.set(__self__, "memory_profile", memory_profile)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def advanced(self) -> Optional['outputs.AdvancedSettingsResponse']:
        """
        Advanced settings of Broker.
        """
        return pulumi.get(self, "advanced")

    @_builtins.property
    @pulumi.getter
    def cardinality(self) -> Optional['outputs.CardinalityResponse']:
        """
        The cardinality details of the broker.
        """
        return pulumi.get(self, "cardinality")

    @_builtins.property
    @pulumi.getter
    def diagnostics(self) -> Optional['outputs.BrokerDiagnosticsResponse']:
        """
        Spec defines the desired identities of Broker diagnostics settings.
        """
        return pulumi.get(self, "diagnostics")

    @_builtins.property
    @pulumi.getter(name="diskBackedMessageBuffer")
    def disk_backed_message_buffer(self) -> Optional['outputs.DiskBackedMessageBufferResponse']:
        """
        Settings of Disk Backed Message Buffer.
        """
        return pulumi.get(self, "disk_backed_message_buffer")

    @_builtins.property
    @pulumi.getter(name="generateResourceLimits")
    def generate_resource_limits(self) -> Optional['outputs.GenerateResourceLimitsResponse']:
        """
        This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        """
        return pulumi.get(self, "generate_resource_limits")

    @_builtins.property
    @pulumi.getter(name="memoryProfile")
    def memory_profile(self) -> Optional[_builtins.str]:
        """
        Memory profile of Broker.
        """
        return pulumi.get(self, "memory_profile")


@pulumi.output_type
class BrokerResourceRuleResponse(dict):
    """
    Broker Resource Rule properties. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIds":
            suggest = "client_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerResourceRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerResourceRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerResourceRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 client_ids: Optional[Sequence[_builtins.str]] = None,
                 topics: Optional[Sequence[_builtins.str]] = None):
        """
        Broker Resource Rule properties. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
        :param _builtins.str method: Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        :param Sequence[_builtins.str] client_ids: A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection. This subfield may be set if the method is Connect.
        :param Sequence[_builtins.str] topics: A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        pulumi.set(__self__, "method", method)
        if client_ids is not None:
            pulumi.set(__self__, "client_ids", client_ids)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection. This subfield may be set if the method is Connect.
        """
        return pulumi.get(self, "client_ids")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class CardinalityResponse(dict):
    """
    Cardinality properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendChain":
            suggest = "backend_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CardinalityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CardinalityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CardinalityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_chain: 'outputs.BackendChainResponse',
                 frontend: 'outputs.FrontendResponse'):
        """
        Cardinality properties
        :param 'BackendChainResponse' backend_chain: The backend broker desired properties
        :param 'FrontendResponse' frontend: The frontend desired properties
        """
        pulumi.set(__self__, "backend_chain", backend_chain)
        pulumi.set(__self__, "frontend", frontend)

    @_builtins.property
    @pulumi.getter(name="backendChain")
    def backend_chain(self) -> 'outputs.BackendChainResponse':
        """
        The backend broker desired properties
        """
        return pulumi.get(self, "backend_chain")

    @_builtins.property
    @pulumi.getter
    def frontend(self) -> 'outputs.FrontendResponse':
        """
        The frontend desired properties
        """
        return pulumi.get(self, "frontend")


@pulumi.output_type
class CertManagerCertOptionsResponse(dict):
    """
    Cert Manager Cert properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "renewBefore":
            suggest = "renew_before"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertManagerCertOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertManagerCertOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertManagerCertOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: _builtins.str,
                 private_key: 'outputs.CertManagerPrivateKeyResponse',
                 renew_before: _builtins.str):
        """
        Cert Manager Cert properties
        :param _builtins.str duration: Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param 'CertManagerPrivateKeyResponse' private_key: Configuration of certificate private key.
        :param _builtins.str renew_before: When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "renew_before", renew_before)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> 'outputs.CertManagerPrivateKeyResponse':
        """
        Configuration of certificate private key.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> _builtins.str:
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "renew_before")


@pulumi.output_type
class CertManagerCertificateSpecResponse(dict):
    """
    Automatic TLS server certificate management with cert-manager
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuerRef":
            suggest = "issuer_ref"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "renewBefore":
            suggest = "renew_before"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertManagerCertificateSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertManagerCertificateSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertManagerCertificateSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issuer_ref: 'outputs.CertManagerIssuerRefResponse',
                 duration: Optional[_builtins.str] = None,
                 private_key: Optional['outputs.CertManagerPrivateKeyResponse'] = None,
                 renew_before: Optional[_builtins.str] = None,
                 san: Optional['outputs.SanForCertResponse'] = None,
                 secret_name: Optional[_builtins.str] = None):
        """
        Automatic TLS server certificate management with cert-manager
        :param 'CertManagerIssuerRefResponse' issuer_ref: cert-manager issuerRef.
        :param _builtins.str duration: Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param 'CertManagerPrivateKeyResponse' private_key: Type of certificate private key.
        :param _builtins.str renew_before: When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param 'SanForCertResponse' san: Additional Subject Alternative Names (SANs) to include in the certificate.
        :param _builtins.str secret_name: Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
        pulumi.set(__self__, "issuer_ref", issuer_ref)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if renew_before is not None:
            pulumi.set(__self__, "renew_before", renew_before)
        if san is not None:
            pulumi.set(__self__, "san", san)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> 'outputs.CertManagerIssuerRefResponse':
        """
        cert-manager issuerRef.
        """
        return pulumi.get(self, "issuer_ref")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.str]:
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional['outputs.CertManagerPrivateKeyResponse']:
        """
        Type of certificate private key.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> Optional[_builtins.str]:
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "renew_before")

    @_builtins.property
    @pulumi.getter
    def san(self) -> Optional['outputs.SanForCertResponse']:
        """
        Additional Subject Alternative Names (SANs) to include in the certificate.
        """
        return pulumi.get(self, "san")

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[_builtins.str]:
        """
        Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class CertManagerIssuerRefResponse(dict):
    """
    Cert-Manager issuerRef properties
    """
    def __init__(__self__, *,
                 group: Optional[_builtins.str] = None,
                 kind: _builtins.str,
                 name: _builtins.str):
        """
        Cert-Manager issuerRef properties
        :param _builtins.str group: group of issuer.
        :param _builtins.str kind: kind of issuer (Issuer or ClusterIssuer).
        :param _builtins.str name: name of issuer.
        """
        if group is None:
            group = 'cert-manager.io'
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        """
        group of issuer.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        kind of issuer (Issuer or ClusterIssuer).
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        name of issuer.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CertManagerPrivateKeyResponse(dict):
    """
    Cert Manager private key properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rotationPolicy":
            suggest = "rotation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertManagerPrivateKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertManagerPrivateKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertManagerPrivateKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: _builtins.str,
                 rotation_policy: _builtins.str):
        """
        Cert Manager private key properties
        :param _builtins.str algorithm: algorithm for private key.
        :param _builtins.str rotation_policy: cert-manager private key rotationPolicy.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "rotation_policy", rotation_policy)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> _builtins.str:
        """
        algorithm for private key.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="rotationPolicy")
    def rotation_policy(self) -> _builtins.str:
        """
        cert-manager private key rotationPolicy.
        """
        return pulumi.get(self, "rotation_policy")


@pulumi.output_type
class ClientConfigResponse(dict):
    """
    The settings of Client Config.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxKeepAliveSeconds":
            suggest = "max_keep_alive_seconds"
        elif key == "maxMessageExpirySeconds":
            suggest = "max_message_expiry_seconds"
        elif key == "maxPacketSizeBytes":
            suggest = "max_packet_size_bytes"
        elif key == "maxReceiveMaximum":
            suggest = "max_receive_maximum"
        elif key == "maxSessionExpirySeconds":
            suggest = "max_session_expiry_seconds"
        elif key == "subscriberQueueLimit":
            suggest = "subscriber_queue_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_keep_alive_seconds: Optional[_builtins.int] = None,
                 max_message_expiry_seconds: Optional[_builtins.int] = None,
                 max_packet_size_bytes: Optional[_builtins.int] = None,
                 max_receive_maximum: Optional[_builtins.int] = None,
                 max_session_expiry_seconds: Optional[_builtins.int] = None,
                 subscriber_queue_limit: Optional['outputs.SubscriberQueueLimitResponse'] = None):
        """
        The settings of Client Config.
        :param _builtins.int max_keep_alive_seconds: Upper bound of a client's Keep Alive, in seconds.
        :param _builtins.int max_message_expiry_seconds: Upper bound of Message Expiry Interval, in seconds.
        :param _builtins.int max_packet_size_bytes: Max message size for a packet in Bytes.
        :param _builtins.int max_receive_maximum: Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        :param _builtins.int max_session_expiry_seconds: Upper bound of Session Expiry Interval, in seconds.
        :param 'SubscriberQueueLimitResponse' subscriber_queue_limit: The limit on the number of queued messages for a subscriber.
        """
        if max_keep_alive_seconds is not None:
            pulumi.set(__self__, "max_keep_alive_seconds", max_keep_alive_seconds)
        if max_message_expiry_seconds is not None:
            pulumi.set(__self__, "max_message_expiry_seconds", max_message_expiry_seconds)
        if max_packet_size_bytes is not None:
            pulumi.set(__self__, "max_packet_size_bytes", max_packet_size_bytes)
        if max_receive_maximum is not None:
            pulumi.set(__self__, "max_receive_maximum", max_receive_maximum)
        if max_session_expiry_seconds is not None:
            pulumi.set(__self__, "max_session_expiry_seconds", max_session_expiry_seconds)
        if subscriber_queue_limit is not None:
            pulumi.set(__self__, "subscriber_queue_limit", subscriber_queue_limit)

    @_builtins.property
    @pulumi.getter(name="maxKeepAliveSeconds")
    def max_keep_alive_seconds(self) -> Optional[_builtins.int]:
        """
        Upper bound of a client's Keep Alive, in seconds.
        """
        return pulumi.get(self, "max_keep_alive_seconds")

    @_builtins.property
    @pulumi.getter(name="maxMessageExpirySeconds")
    def max_message_expiry_seconds(self) -> Optional[_builtins.int]:
        """
        Upper bound of Message Expiry Interval, in seconds.
        """
        return pulumi.get(self, "max_message_expiry_seconds")

    @_builtins.property
    @pulumi.getter(name="maxPacketSizeBytes")
    def max_packet_size_bytes(self) -> Optional[_builtins.int]:
        """
        Max message size for a packet in Bytes.
        """
        return pulumi.get(self, "max_packet_size_bytes")

    @_builtins.property
    @pulumi.getter(name="maxReceiveMaximum")
    def max_receive_maximum(self) -> Optional[_builtins.int]:
        """
        Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        """
        return pulumi.get(self, "max_receive_maximum")

    @_builtins.property
    @pulumi.getter(name="maxSessionExpirySeconds")
    def max_session_expiry_seconds(self) -> Optional[_builtins.int]:
        """
        Upper bound of Session Expiry Interval, in seconds.
        """
        return pulumi.get(self, "max_session_expiry_seconds")

    @_builtins.property
    @pulumi.getter(name="subscriberQueueLimit")
    def subscriber_queue_limit(self) -> Optional['outputs.SubscriberQueueLimitResponse']:
        """
        The limit on the number of queued messages for a subscriber.
        """
        return pulumi.get(self, "subscriber_queue_limit")


@pulumi.output_type
class DataflowBuiltInTransformationDatasetResponse(dict):
    """
    Dataflow BuiltIn Transformation dataset properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRef":
            suggest = "schema_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowBuiltInTransformationDatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowBuiltInTransformationDatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowBuiltInTransformationDatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inputs: Sequence[_builtins.str],
                 key: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 expression: Optional[_builtins.str] = None,
                 schema_ref: Optional[_builtins.str] = None):
        """
        Dataflow BuiltIn Transformation dataset properties
        :param Sequence[_builtins.str] inputs: List of fields for enriching from the Broker State Store.
        :param _builtins.str key: The key of the dataset.
        :param _builtins.str description: A user provided optional description of the dataset.
        :param _builtins.str expression: Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        :param _builtins.str schema_ref: The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "key", key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Sequence[_builtins.str]:
        """
        List of fields for enriching from the Broker State Store.
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the dataset.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A user provided optional description of the dataset.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[_builtins.str]:
        """
        The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
        return pulumi.get(self, "schema_ref")


@pulumi.output_type
class DataflowBuiltInTransformationFilterResponse(dict):
    """
    Dataflow BuiltIn Transformation filter properties
    """
    def __init__(__self__, *,
                 expression: _builtins.str,
                 inputs: Sequence[_builtins.str],
                 description: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Dataflow BuiltIn Transformation filter properties
        :param _builtins.str expression: Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        :param Sequence[_builtins.str] inputs: List of fields for filtering in JSON path expression.
        :param _builtins.str description: A user provided optional description of the filter.
        :param _builtins.str type: The type of dataflow operation.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "inputs", inputs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is None:
            type = 'Filter'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Sequence[_builtins.str]:
        """
        List of fields for filtering in JSON path expression.
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A user provided optional description of the filter.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of dataflow operation.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataflowBuiltInTransformationMapResponse(dict):
    """
    Dataflow BuiltIn Transformation map properties
    """
    def __init__(__self__, *,
                 inputs: Sequence[_builtins.str],
                 output: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 expression: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Dataflow BuiltIn Transformation map properties
        :param Sequence[_builtins.str] inputs: List of fields for mapping in JSON path expression.
        :param _builtins.str output: Where and how the input fields to be organized in the output record.
        :param _builtins.str description: A user provided optional description of the mapping function.
        :param _builtins.str expression: Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        :param _builtins.str type: Type of transformation.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "output", output)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Sequence[_builtins.str]:
        """
        List of fields for mapping in JSON path expression.
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def output(self) -> _builtins.str:
        """
        Where and how the input fields to be organized in the output record.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A user provided optional description of the mapping function.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of transformation.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataflowBuiltInTransformationSettingsResponse(dict):
    """
    Dataflow BuiltIn Transformation properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRef":
            suggest = "schema_ref"
        elif key == "serializationFormat":
            suggest = "serialization_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowBuiltInTransformationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowBuiltInTransformationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowBuiltInTransformationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datasets: Optional[Sequence['outputs.DataflowBuiltInTransformationDatasetResponse']] = None,
                 filter: Optional[Sequence['outputs.DataflowBuiltInTransformationFilterResponse']] = None,
                 map: Optional[Sequence['outputs.DataflowBuiltInTransformationMapResponse']] = None,
                 schema_ref: Optional[_builtins.str] = None,
                 serialization_format: Optional[_builtins.str] = None):
        """
        Dataflow BuiltIn Transformation properties
        :param Sequence['DataflowBuiltInTransformationDatasetResponse'] datasets: Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        :param Sequence['DataflowBuiltInTransformationFilterResponse'] filter: Filters input record or datapoints based on condition.
        :param Sequence['DataflowBuiltInTransformationMapResponse'] map: Maps input to output message.
        :param _builtins.str schema_ref: Reference to the schema that describes the output of the transformation.
        :param _builtins.str serialization_format: Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
        if datasets is not None:
            pulumi.set(__self__, "datasets", datasets)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if map is not None:
            pulumi.set(__self__, "map", map)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is None:
            serialization_format = 'Json'
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @_builtins.property
    @pulumi.getter
    def datasets(self) -> Optional[Sequence['outputs.DataflowBuiltInTransformationDatasetResponse']]:
        """
        Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        """
        return pulumi.get(self, "datasets")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[Sequence['outputs.DataflowBuiltInTransformationFilterResponse']]:
        """
        Filters input record or datapoints based on condition.
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter
    def map(self) -> Optional[Sequence['outputs.DataflowBuiltInTransformationMapResponse']]:
        """
        Maps input to output message.
        """
        return pulumi.get(self, "map")

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[_builtins.str]:
        """
        Reference to the schema that describes the output of the transformation.
        """
        return pulumi.get(self, "schema_ref")

    @_builtins.property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[_builtins.str]:
        """
        Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
        return pulumi.get(self, "serialization_format")


@pulumi.output_type
class DataflowDestinationOperationSettingsResponse(dict):
    """
    Dataflow Destination Operation properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDestination":
            suggest = "data_destination"
        elif key == "endpointRef":
            suggest = "endpoint_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowDestinationOperationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowDestinationOperationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowDestinationOperationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_destination: _builtins.str,
                 endpoint_ref: _builtins.str):
        """
        Dataflow Destination Operation properties
        :param _builtins.str data_destination: Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        :param _builtins.str endpoint_ref: Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
        pulumi.set(__self__, "data_destination", data_destination)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)

    @_builtins.property
    @pulumi.getter(name="dataDestination")
    def data_destination(self) -> _builtins.str:
        """
        Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        """
        return pulumi.get(self, "data_destination")

    @_builtins.property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> _builtins.str:
        """
        Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
        return pulumi.get(self, "endpoint_ref")


@pulumi.output_type
class DataflowEndpointAuthenticationAccessTokenResponse(dict):
    """
    DataflowEndpoint Authentication Access Token properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointAuthenticationAccessTokenResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointAuthenticationAccessTokenResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointAuthenticationAccessTokenResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: _builtins.str):
        """
        DataflowEndpoint Authentication Access Token properties
        :param _builtins.str secret_ref: Token secret name.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> _builtins.str:
        """
        Token secret name.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class DataflowEndpointAuthenticationSaslResponse(dict):
    """
    DataflowEndpoint Authentication Sasl properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "saslType":
            suggest = "sasl_type"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointAuthenticationSaslResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointAuthenticationSaslResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointAuthenticationSaslResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sasl_type: _builtins.str,
                 secret_ref: _builtins.str):
        """
        DataflowEndpoint Authentication Sasl properties
        :param _builtins.str sasl_type: Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        :param _builtins.str secret_ref: Token secret name.
        """
        pulumi.set(__self__, "sasl_type", sasl_type)
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="saslType")
    def sasl_type(self) -> _builtins.str:
        """
        Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        """
        return pulumi.get(self, "sasl_type")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> _builtins.str:
        """
        Token secret name.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class DataflowEndpointAuthenticationServiceAccountTokenResponse(dict):
    """
    Service Account Token for BrokerAuthentication
    """
    def __init__(__self__, *,
                 audience: _builtins.str):
        """
        Service Account Token for BrokerAuthentication
        :param _builtins.str audience: Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
        pulumi.set(__self__, "audience", audience)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> _builtins.str:
        """
        Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
        return pulumi.get(self, "audience")


@pulumi.output_type
class DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse(dict):
    """
    DataflowEndpoint Authentication SystemAssignedManagedIdentity properties
    """
    def __init__(__self__, *,
                 audience: Optional[_builtins.str] = None):
        """
        DataflowEndpoint Authentication SystemAssignedManagedIdentity properties
        :param _builtins.str audience: Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> Optional[_builtins.str]:
        """
        Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        return pulumi.get(self, "audience")


@pulumi.output_type
class DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse(dict):
    """
    DataflowEndpoint Authentication UserAssignedManagedIdentity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 tenant_id: _builtins.str,
                 scope: Optional[_builtins.str] = None):
        """
        DataflowEndpoint Authentication UserAssignedManagedIdentity properties
        :param _builtins.str client_id: Client ID for the user-assigned managed identity.
        :param _builtins.str tenant_id: Tenant ID.
        :param _builtins.str scope: Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Client ID for the user-assigned managed identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class DataflowEndpointAuthenticationX509Response(dict):
    """
    DataflowEndpoint Authentication X509 properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointAuthenticationX509Response. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointAuthenticationX509Response.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointAuthenticationX509Response.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: _builtins.str):
        """
        DataflowEndpoint Authentication X509 properties
        :param _builtins.str secret_ref: Secret reference of the X.509 certificate.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> _builtins.str:
        """
        Secret reference of the X.509 certificate.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class DataflowEndpointDataExplorerAuthenticationResponse(dict):
    """
    Azure Data Explorer Authentication properties. NOTE - only authentication property is allowed per entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointDataExplorerAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointDataExplorerAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointDataExplorerAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Any,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None):
        """
        Azure Data Explorer Authentication properties. NOTE - only authentication property is allowed per entry.
        :param Any method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        """
        pulumi.set(__self__, "method", method)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Any:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")


@pulumi.output_type
class DataflowEndpointDataExplorerResponse(dict):
    """
    Azure Data Explorer endpoint properties
    """
    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointDataExplorerAuthenticationResponse',
                 database: _builtins.str,
                 host: _builtins.str,
                 batching: Optional['outputs.BatchingConfigurationResponse'] = None):
        """
        Azure Data Explorer endpoint properties
        :param 'DataflowEndpointDataExplorerAuthenticationResponse' authentication: Authentication configuration. NOTE - only authentication property is allowed per entry.
        :param _builtins.str database: Database name.
        :param _builtins.str host: Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        :param 'BatchingConfigurationResponse' batching: Azure Data Explorer endpoint batching configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointDataExplorerAuthenticationResponse':
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def batching(self) -> Optional['outputs.BatchingConfigurationResponse']:
        """
        Azure Data Explorer endpoint batching configuration.
        """
        return pulumi.get(self, "batching")


@pulumi.output_type
class DataflowEndpointDataLakeStorageAuthenticationResponse(dict):
    """
    Azure Data Lake endpoint Authentication properties.  NOTE Enum - Only one method is supported for one entry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenSettings":
            suggest = "access_token_settings"
        elif key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointDataLakeStorageAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointDataLakeStorageAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointDataLakeStorageAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 access_token_settings: Optional['outputs.DataflowEndpointAuthenticationAccessTokenResponse'] = None,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None):
        """
        Azure Data Lake endpoint Authentication properties.  NOTE Enum - Only one method is supported for one entry
        :param _builtins.str method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationAccessTokenResponse' access_token_settings: SAS token authentication.
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        """
        pulumi.set(__self__, "method", method)
        if access_token_settings is not None:
            pulumi.set(__self__, "access_token_settings", access_token_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="accessTokenSettings")
    def access_token_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationAccessTokenResponse']:
        """
        SAS token authentication.
        """
        return pulumi.get(self, "access_token_settings")

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")


@pulumi.output_type
class DataflowEndpointDataLakeStorageResponse(dict):
    """
    Azure Data Lake endpoint properties
    """
    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointDataLakeStorageAuthenticationResponse',
                 host: _builtins.str,
                 batching: Optional['outputs.BatchingConfigurationResponse'] = None):
        """
        Azure Data Lake endpoint properties
        :param 'DataflowEndpointDataLakeStorageAuthenticationResponse' authentication: Authentication configuration. NOTE - only authentication property is allowed per entry.
        :param _builtins.str host: Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        :param 'BatchingConfigurationResponse' batching: Azure Data Lake endpoint batching configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointDataLakeStorageAuthenticationResponse':
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def batching(self) -> Optional['outputs.BatchingConfigurationResponse']:
        """
        Azure Data Lake endpoint batching configuration.
        """
        return pulumi.get(self, "batching")


@pulumi.output_type
class DataflowEndpointFabricOneLakeAuthenticationResponse(dict):
    """
    Microsoft Fabric endpoint. Authentication properties. NOTE - Only one method is supported for one entry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointFabricOneLakeAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointFabricOneLakeAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointFabricOneLakeAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Any,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None):
        """
        Microsoft Fabric endpoint. Authentication properties. NOTE - Only one method is supported for one entry
        :param Any method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        """
        pulumi.set(__self__, "method", method)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Any:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")


@pulumi.output_type
class DataflowEndpointFabricOneLakeNamesResponse(dict):
    """
    Microsoft Fabric endpoint Names properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lakehouseName":
            suggest = "lakehouse_name"
        elif key == "workspaceName":
            suggest = "workspace_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointFabricOneLakeNamesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointFabricOneLakeNamesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointFabricOneLakeNamesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lakehouse_name: _builtins.str,
                 workspace_name: _builtins.str):
        """
        Microsoft Fabric endpoint Names properties
        :param _builtins.str lakehouse_name: Lakehouse name.
        :param _builtins.str workspace_name: Workspace name.
        """
        pulumi.set(__self__, "lakehouse_name", lakehouse_name)
        pulumi.set(__self__, "workspace_name", workspace_name)

    @_builtins.property
    @pulumi.getter(name="lakehouseName")
    def lakehouse_name(self) -> _builtins.str:
        """
        Lakehouse name.
        """
        return pulumi.get(self, "lakehouse_name")

    @_builtins.property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> _builtins.str:
        """
        Workspace name.
        """
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class DataflowEndpointFabricOneLakeResponse(dict):
    """
    Microsoft Fabric endpoint properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oneLakePathType":
            suggest = "one_lake_path_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointFabricOneLakeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointFabricOneLakeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointFabricOneLakeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointFabricOneLakeAuthenticationResponse',
                 host: _builtins.str,
                 names: 'outputs.DataflowEndpointFabricOneLakeNamesResponse',
                 one_lake_path_type: _builtins.str,
                 batching: Optional['outputs.BatchingConfigurationResponse'] = None):
        """
        Microsoft Fabric endpoint properties
        :param 'DataflowEndpointFabricOneLakeAuthenticationResponse' authentication: Authentication configuration. NOTE - only one authentication property is allowed per entry.
        :param _builtins.str host: Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        :param 'DataflowEndpointFabricOneLakeNamesResponse' names: Names of the workspace and lakehouse.
        :param _builtins.str one_lake_path_type: Type of location of the data in the workspace. Can be either tables or files.
        :param 'BatchingConfigurationResponse' batching: Batching configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "one_lake_path_type", one_lake_path_type)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointFabricOneLakeAuthenticationResponse':
        """
        Authentication configuration. NOTE - only one authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def names(self) -> 'outputs.DataflowEndpointFabricOneLakeNamesResponse':
        """
        Names of the workspace and lakehouse.
        """
        return pulumi.get(self, "names")

    @_builtins.property
    @pulumi.getter(name="oneLakePathType")
    def one_lake_path_type(self) -> _builtins.str:
        """
        Type of location of the data in the workspace. Can be either tables or files.
        """
        return pulumi.get(self, "one_lake_path_type")

    @_builtins.property
    @pulumi.getter
    def batching(self) -> Optional['outputs.BatchingConfigurationResponse']:
        """
        Batching configuration.
        """
        return pulumi.get(self, "batching")


@pulumi.output_type
class DataflowEndpointKafkaAuthenticationResponse(dict):
    """
    Kafka endpoint Authentication properties. NOTE - only authentication property is allowed per entry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "saslSettings":
            suggest = "sasl_settings"
        elif key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"
        elif key == "x509CertificateSettings":
            suggest = "x509_certificate_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointKafkaAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointKafkaAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointKafkaAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 sasl_settings: Optional['outputs.DataflowEndpointAuthenticationSaslResponse'] = None,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None,
                 x509_certificate_settings: Optional['outputs.DataflowEndpointAuthenticationX509Response'] = None):
        """
        Kafka endpoint Authentication properties. NOTE - only authentication property is allowed per entry
        :param _builtins.str method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationSaslResponse' sasl_settings: SASL authentication.
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationX509Response' x509_certificate_settings: X.509 certificate authentication.
        """
        pulumi.set(__self__, "method", method)
        if sasl_settings is not None:
            pulumi.set(__self__, "sasl_settings", sasl_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)
        if x509_certificate_settings is not None:
            pulumi.set(__self__, "x509_certificate_settings", x509_certificate_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="saslSettings")
    def sasl_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSaslResponse']:
        """
        SASL authentication.
        """
        return pulumi.get(self, "sasl_settings")

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @_builtins.property
    @pulumi.getter(name="x509CertificateSettings")
    def x509_certificate_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationX509Response']:
        """
        X.509 certificate authentication.
        """
        return pulumi.get(self, "x509_certificate_settings")


@pulumi.output_type
class DataflowEndpointKafkaBatchingResponse(dict):
    """
    Kafka endpoint Batching properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latencyMs":
            suggest = "latency_ms"
        elif key == "maxBytes":
            suggest = "max_bytes"
        elif key == "maxMessages":
            suggest = "max_messages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointKafkaBatchingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointKafkaBatchingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointKafkaBatchingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latency_ms: Optional[_builtins.int] = None,
                 max_bytes: Optional[_builtins.int] = None,
                 max_messages: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None):
        """
        Kafka endpoint Batching properties
        :param _builtins.int latency_ms: Batching latency in milliseconds.
        :param _builtins.int max_bytes: Maximum number of bytes in a batch.
        :param _builtins.int max_messages: Maximum number of messages in a batch.
        :param _builtins.str mode: Mode for batching.
        """
        if latency_ms is None:
            latency_ms = 5
        if latency_ms is not None:
            pulumi.set(__self__, "latency_ms", latency_ms)
        if max_bytes is None:
            max_bytes = 1000000
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="latencyMs")
    def latency_ms(self) -> Optional[_builtins.int]:
        """
        Batching latency in milliseconds.
        """
        return pulumi.get(self, "latency_ms")

    @_builtins.property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[_builtins.int]:
        """
        Maximum number of bytes in a batch.
        """
        return pulumi.get(self, "max_bytes")

    @_builtins.property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[_builtins.int]:
        """
        Maximum number of messages in a batch.
        """
        return pulumi.get(self, "max_messages")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mode for batching.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DataflowEndpointKafkaResponse(dict):
    """
    Kafka endpoint properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudEventAttributes":
            suggest = "cloud_event_attributes"
        elif key == "consumerGroupId":
            suggest = "consumer_group_id"
        elif key == "copyMqttProperties":
            suggest = "copy_mqtt_properties"
        elif key == "kafkaAcks":
            suggest = "kafka_acks"
        elif key == "partitionStrategy":
            suggest = "partition_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointKafkaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointKafkaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointKafkaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointKafkaAuthenticationResponse',
                 host: _builtins.str,
                 batching: Optional['outputs.DataflowEndpointKafkaBatchingResponse'] = None,
                 cloud_event_attributes: Optional[_builtins.str] = None,
                 compression: Optional[_builtins.str] = None,
                 consumer_group_id: Optional[_builtins.str] = None,
                 copy_mqtt_properties: Optional[_builtins.str] = None,
                 kafka_acks: Optional[_builtins.str] = None,
                 partition_strategy: Optional[_builtins.str] = None,
                 tls: Optional['outputs.TlsPropertiesResponse'] = None):
        """
        Kafka endpoint properties
        :param 'DataflowEndpointKafkaAuthenticationResponse' authentication: Authentication configuration. NOTE - only authentication property is allowed per entry.
        :param _builtins.str host: Kafka endpoint host.
        :param 'DataflowEndpointKafkaBatchingResponse' batching: Batching configuration.
        :param _builtins.str cloud_event_attributes: Cloud event mapping config.
        :param _builtins.str compression: Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        :param _builtins.str consumer_group_id: Consumer group ID.
        :param _builtins.str copy_mqtt_properties: Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        :param _builtins.str kafka_acks: Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        :param _builtins.str partition_strategy: Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        :param 'TlsPropertiesResponse' tls: TLS configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)
        if cloud_event_attributes is not None:
            pulumi.set(__self__, "cloud_event_attributes", cloud_event_attributes)
        if compression is None:
            compression = 'None'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if copy_mqtt_properties is None:
            copy_mqtt_properties = 'Enabled'
        if copy_mqtt_properties is not None:
            pulumi.set(__self__, "copy_mqtt_properties", copy_mqtt_properties)
        if kafka_acks is None:
            kafka_acks = 'All'
        if kafka_acks is not None:
            pulumi.set(__self__, "kafka_acks", kafka_acks)
        if partition_strategy is None:
            partition_strategy = 'Default'
        if partition_strategy is not None:
            pulumi.set(__self__, "partition_strategy", partition_strategy)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointKafkaAuthenticationResponse':
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Kafka endpoint host.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def batching(self) -> Optional['outputs.DataflowEndpointKafkaBatchingResponse']:
        """
        Batching configuration.
        """
        return pulumi.get(self, "batching")

    @_builtins.property
    @pulumi.getter(name="cloudEventAttributes")
    def cloud_event_attributes(self) -> Optional[_builtins.str]:
        """
        Cloud event mapping config.
        """
        return pulumi.get(self, "cloud_event_attributes")

    @_builtins.property
    @pulumi.getter
    def compression(self) -> Optional[_builtins.str]:
        """
        Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "compression")

    @_builtins.property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[_builtins.str]:
        """
        Consumer group ID.
        """
        return pulumi.get(self, "consumer_group_id")

    @_builtins.property
    @pulumi.getter(name="copyMqttProperties")
    def copy_mqtt_properties(self) -> Optional[_builtins.str]:
        """
        Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        """
        return pulumi.get(self, "copy_mqtt_properties")

    @_builtins.property
    @pulumi.getter(name="kafkaAcks")
    def kafka_acks(self) -> Optional[_builtins.str]:
        """
        Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "kafka_acks")

    @_builtins.property
    @pulumi.getter(name="partitionStrategy")
    def partition_strategy(self) -> Optional[_builtins.str]:
        """
        Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "partition_strategy")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.TlsPropertiesResponse']:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DataflowEndpointLocalStorageResponse(dict):
    """
    Local persistent volume endpoint properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "persistentVolumeClaimRef":
            suggest = "persistent_volume_claim_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointLocalStorageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointLocalStorageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointLocalStorageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 persistent_volume_claim_ref: _builtins.str):
        """
        Local persistent volume endpoint properties
        :param _builtins.str persistent_volume_claim_ref: Persistent volume claim name.
        """
        pulumi.set(__self__, "persistent_volume_claim_ref", persistent_volume_claim_ref)

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaimRef")
    def persistent_volume_claim_ref(self) -> _builtins.str:
        """
        Persistent volume claim name.
        """
        return pulumi.get(self, "persistent_volume_claim_ref")


@pulumi.output_type
class DataflowEndpointMqttAuthenticationResponse(dict):
    """
    Mqtt endpoint Authentication properties. NOTE - only authentication property is allowed per entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountTokenSettings":
            suggest = "service_account_token_settings"
        elif key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"
        elif key == "x509CertificateSettings":
            suggest = "x509_certificate_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointMqttAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointMqttAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointMqttAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 service_account_token_settings: Optional['outputs.DataflowEndpointAuthenticationServiceAccountTokenResponse'] = None,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None,
                 x509_certificate_settings: Optional['outputs.DataflowEndpointAuthenticationX509Response'] = None):
        """
        Mqtt endpoint Authentication properties. NOTE - only authentication property is allowed per entry.
        :param _builtins.str method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationServiceAccountTokenResponse' service_account_token_settings: Kubernetes service account token authentication. Default audience if not set is aio-internal
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationX509Response' x509_certificate_settings: X.509 certificate authentication.
        """
        pulumi.set(__self__, "method", method)
        if service_account_token_settings is not None:
            pulumi.set(__self__, "service_account_token_settings", service_account_token_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)
        if x509_certificate_settings is not None:
            pulumi.set(__self__, "x509_certificate_settings", x509_certificate_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="serviceAccountTokenSettings")
    def service_account_token_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationServiceAccountTokenResponse']:
        """
        Kubernetes service account token authentication. Default audience if not set is aio-internal
        """
        return pulumi.get(self, "service_account_token_settings")

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @_builtins.property
    @pulumi.getter(name="x509CertificateSettings")
    def x509_certificate_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationX509Response']:
        """
        X.509 certificate authentication.
        """
        return pulumi.get(self, "x509_certificate_settings")


@pulumi.output_type
class DataflowEndpointMqttResponse(dict):
    """
    Broker endpoint properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIdPrefix":
            suggest = "client_id_prefix"
        elif key == "cloudEventAttributes":
            suggest = "cloud_event_attributes"
        elif key == "keepAliveSeconds":
            suggest = "keep_alive_seconds"
        elif key == "maxInflightMessages":
            suggest = "max_inflight_messages"
        elif key == "sessionExpirySeconds":
            suggest = "session_expiry_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointMqttResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointMqttResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointMqttResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointMqttAuthenticationResponse',
                 client_id_prefix: Optional[_builtins.str] = None,
                 cloud_event_attributes: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 keep_alive_seconds: Optional[_builtins.int] = None,
                 max_inflight_messages: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 qos: Optional[_builtins.int] = None,
                 retain: Optional[_builtins.str] = None,
                 session_expiry_seconds: Optional[_builtins.int] = None,
                 tls: Optional['outputs.TlsPropertiesResponse'] = None):
        """
        Broker endpoint properties
        :param 'DataflowEndpointMqttAuthenticationResponse' authentication: authentication properties. DEFAULT: kubernetes.audience=aio-internal. NOTE - Enum field only property is allowed
        :param _builtins.str client_id_prefix: Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        :param _builtins.str cloud_event_attributes: Cloud event mapping config.
        :param _builtins.str host: Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        :param _builtins.int keep_alive_seconds: Broker KeepAlive for connection in seconds.
        :param _builtins.int max_inflight_messages: The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        :param _builtins.str protocol: Enable or disable websockets.
        :param _builtins.int qos: Qos for Broker connection.
        :param _builtins.str retain: Whether or not to keep the retain setting.
        :param _builtins.int session_expiry_seconds: Session expiry in seconds.
        :param 'TlsPropertiesResponse' tls: TLS configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        if client_id_prefix is not None:
            pulumi.set(__self__, "client_id_prefix", client_id_prefix)
        if cloud_event_attributes is not None:
            pulumi.set(__self__, "cloud_event_attributes", cloud_event_attributes)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_alive_seconds is None:
            keep_alive_seconds = 60
        if keep_alive_seconds is not None:
            pulumi.set(__self__, "keep_alive_seconds", keep_alive_seconds)
        if max_inflight_messages is None:
            max_inflight_messages = 100
        if max_inflight_messages is not None:
            pulumi.set(__self__, "max_inflight_messages", max_inflight_messages)
        if protocol is None:
            protocol = 'Mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if retain is None:
            retain = 'Keep'
        if retain is not None:
            pulumi.set(__self__, "retain", retain)
        if session_expiry_seconds is not None:
            pulumi.set(__self__, "session_expiry_seconds", session_expiry_seconds)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointMqttAuthenticationResponse':
        """
        authentication properties. DEFAULT: kubernetes.audience=aio-internal. NOTE - Enum field only property is allowed
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter(name="clientIdPrefix")
    def client_id_prefix(self) -> Optional[_builtins.str]:
        """
        Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        """
        return pulumi.get(self, "client_id_prefix")

    @_builtins.property
    @pulumi.getter(name="cloudEventAttributes")
    def cloud_event_attributes(self) -> Optional[_builtins.str]:
        """
        Cloud event mapping config.
        """
        return pulumi.get(self, "cloud_event_attributes")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="keepAliveSeconds")
    def keep_alive_seconds(self) -> Optional[_builtins.int]:
        """
        Broker KeepAlive for connection in seconds.
        """
        return pulumi.get(self, "keep_alive_seconds")

    @_builtins.property
    @pulumi.getter(name="maxInflightMessages")
    def max_inflight_messages(self) -> Optional[_builtins.int]:
        """
        The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        """
        return pulumi.get(self, "max_inflight_messages")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Enable or disable websockets.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def qos(self) -> Optional[_builtins.int]:
        """
        Qos for Broker connection.
        """
        return pulumi.get(self, "qos")

    @_builtins.property
    @pulumi.getter
    def retain(self) -> Optional[_builtins.str]:
        """
        Whether or not to keep the retain setting.
        """
        return pulumi.get(self, "retain")

    @_builtins.property
    @pulumi.getter(name="sessionExpirySeconds")
    def session_expiry_seconds(self) -> Optional[_builtins.int]:
        """
        Session expiry in seconds.
        """
        return pulumi.get(self, "session_expiry_seconds")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.TlsPropertiesResponse']:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DataflowEndpointPropertiesResponse(dict):
    """
    DataflowEndpoint Resource properties. NOTE - Only one type of endpoint is supported for one Resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "dataExplorerSettings":
            suggest = "data_explorer_settings"
        elif key == "dataLakeStorageSettings":
            suggest = "data_lake_storage_settings"
        elif key == "fabricOneLakeSettings":
            suggest = "fabric_one_lake_settings"
        elif key == "kafkaSettings":
            suggest = "kafka_settings"
        elif key == "localStorageSettings":
            suggest = "local_storage_settings"
        elif key == "mqttSettings":
            suggest = "mqtt_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: _builtins.str,
                 provisioning_state: _builtins.str,
                 data_explorer_settings: Optional['outputs.DataflowEndpointDataExplorerResponse'] = None,
                 data_lake_storage_settings: Optional['outputs.DataflowEndpointDataLakeStorageResponse'] = None,
                 fabric_one_lake_settings: Optional['outputs.DataflowEndpointFabricOneLakeResponse'] = None,
                 kafka_settings: Optional['outputs.DataflowEndpointKafkaResponse'] = None,
                 local_storage_settings: Optional['outputs.DataflowEndpointLocalStorageResponse'] = None,
                 mqtt_settings: Optional['outputs.DataflowEndpointMqttResponse'] = None):
        """
        DataflowEndpoint Resource properties. NOTE - Only one type of endpoint is supported for one Resource
        :param _builtins.str endpoint_type: Endpoint Type.
        :param _builtins.str provisioning_state: The status of the last operation.
        :param 'DataflowEndpointDataExplorerResponse' data_explorer_settings: Azure Data Explorer endpoint.
        :param 'DataflowEndpointDataLakeStorageResponse' data_lake_storage_settings: Azure Data Lake endpoint.
        :param 'DataflowEndpointFabricOneLakeResponse' fabric_one_lake_settings: Microsoft Fabric endpoint.
        :param 'DataflowEndpointKafkaResponse' kafka_settings: Kafka endpoint.
        :param 'DataflowEndpointLocalStorageResponse' local_storage_settings: Local persistent volume endpoint.
        :param 'DataflowEndpointMqttResponse' mqtt_settings: Broker endpoint.
        """
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if data_explorer_settings is not None:
            pulumi.set(__self__, "data_explorer_settings", data_explorer_settings)
        if data_lake_storage_settings is not None:
            pulumi.set(__self__, "data_lake_storage_settings", data_lake_storage_settings)
        if fabric_one_lake_settings is not None:
            pulumi.set(__self__, "fabric_one_lake_settings", fabric_one_lake_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if local_storage_settings is not None:
            pulumi.set(__self__, "local_storage_settings", local_storage_settings)
        if mqtt_settings is not None:
            pulumi.set(__self__, "mqtt_settings", mqtt_settings)

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> _builtins.str:
        """
        Endpoint Type.
        """
        return pulumi.get(self, "endpoint_type")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="dataExplorerSettings")
    def data_explorer_settings(self) -> Optional['outputs.DataflowEndpointDataExplorerResponse']:
        """
        Azure Data Explorer endpoint.
        """
        return pulumi.get(self, "data_explorer_settings")

    @_builtins.property
    @pulumi.getter(name="dataLakeStorageSettings")
    def data_lake_storage_settings(self) -> Optional['outputs.DataflowEndpointDataLakeStorageResponse']:
        """
        Azure Data Lake endpoint.
        """
        return pulumi.get(self, "data_lake_storage_settings")

    @_builtins.property
    @pulumi.getter(name="fabricOneLakeSettings")
    def fabric_one_lake_settings(self) -> Optional['outputs.DataflowEndpointFabricOneLakeResponse']:
        """
        Microsoft Fabric endpoint.
        """
        return pulumi.get(self, "fabric_one_lake_settings")

    @_builtins.property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional['outputs.DataflowEndpointKafkaResponse']:
        """
        Kafka endpoint.
        """
        return pulumi.get(self, "kafka_settings")

    @_builtins.property
    @pulumi.getter(name="localStorageSettings")
    def local_storage_settings(self) -> Optional['outputs.DataflowEndpointLocalStorageResponse']:
        """
        Local persistent volume endpoint.
        """
        return pulumi.get(self, "local_storage_settings")

    @_builtins.property
    @pulumi.getter(name="mqttSettings")
    def mqtt_settings(self) -> Optional['outputs.DataflowEndpointMqttResponse']:
        """
        Broker endpoint.
        """
        return pulumi.get(self, "mqtt_settings")


@pulumi.output_type
class DataflowGraphConnectionInputResponse(dict):
    """
    DataflowGraph DataflowGraphNode Connection Input.
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 schema: Optional['outputs.DataflowGraphConnectionSchemaSettingsResponse'] = None):
        """
        DataflowGraph DataflowGraphNode Connection Input.
        :param _builtins.str name: Name of the input node.
        :param 'DataflowGraphConnectionSchemaSettingsResponse' schema: Schema settings for the input node.
        """
        pulumi.set(__self__, "name", name)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the input node.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional['outputs.DataflowGraphConnectionSchemaSettingsResponse']:
        """
        Schema settings for the input node.
        """
        return pulumi.get(self, "schema")


@pulumi.output_type
class DataflowGraphConnectionOutputResponse(dict):
    """
    DataflowGraph DataflowGraphNode Connection Output.
    """
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        DataflowGraph DataflowGraphNode Connection Output.
        :param _builtins.str name: Name of the destination node.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the destination node.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DataflowGraphConnectionSchemaSettingsResponse(dict):
    """
    DataflowGraph connection node output schema settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRef":
            suggest = "schema_ref"
        elif key == "serializationFormat":
            suggest = "serialization_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphConnectionSchemaSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphConnectionSchemaSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphConnectionSchemaSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_ref: Optional[_builtins.str] = None,
                 serialization_format: Optional[_builtins.str] = None):
        """
        DataflowGraph connection node output schema settings.
        :param _builtins.str schema_ref: Reference to the schema that describes the output of the transformation.
        :param _builtins.str serialization_format: Output serialization format.
        """
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[_builtins.str]:
        """
        Reference to the schema that describes the output of the transformation.
        """
        return pulumi.get(self, "schema_ref")

    @_builtins.property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[_builtins.str]:
        """
        Output serialization format.
        """
        return pulumi.get(self, "serialization_format")


@pulumi.output_type
class DataflowGraphDestinationNodeResponse(dict):
    """
    DataflowGraph destination node properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationSettings":
            suggest = "destination_settings"
        elif key == "nodeType":
            suggest = "node_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphDestinationNodeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphDestinationNodeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphDestinationNodeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_settings: 'outputs.DataflowGraphDestinationNodeSettingsResponse',
                 name: _builtins.str,
                 node_type: _builtins.str):
        """
        DataflowGraph destination node properties.
        :param 'DataflowGraphDestinationNodeSettingsResponse' destination_settings: Destination configuration.
        :param _builtins.str name: Name of the node.
        :param _builtins.str node_type: DataflowGraph node types.
               Expected value is 'Destination'.
        """
        pulumi.set(__self__, "destination_settings", destination_settings)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_type", 'Destination')

    @_builtins.property
    @pulumi.getter(name="destinationSettings")
    def destination_settings(self) -> 'outputs.DataflowGraphDestinationNodeSettingsResponse':
        """
        Destination configuration.
        """
        return pulumi.get(self, "destination_settings")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the node.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        DataflowGraph node types.
        Expected value is 'Destination'.
        """
        return pulumi.get(self, "node_type")


@pulumi.output_type
class DataflowGraphDestinationNodeSettingsResponse(dict):
    """
    DataflowGraph destination node settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDestination":
            suggest = "data_destination"
        elif key == "endpointRef":
            suggest = "endpoint_ref"
        elif key == "outputSchemaSettings":
            suggest = "output_schema_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphDestinationNodeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphDestinationNodeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphDestinationNodeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_destination: _builtins.str,
                 endpoint_ref: _builtins.str,
                 output_schema_settings: Optional['outputs.DataflowGraphDestinationSchemaSettingsResponse'] = None):
        """
        DataflowGraph destination node settings.
        :param _builtins.str data_destination: Data destination at the endpoint.
        :param _builtins.str endpoint_ref: The name of the DataflowEndpoint resource .
        :param 'DataflowGraphDestinationSchemaSettingsResponse' output_schema_settings: Output schema settings.
        """
        pulumi.set(__self__, "data_destination", data_destination)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)
        if output_schema_settings is not None:
            pulumi.set(__self__, "output_schema_settings", output_schema_settings)

    @_builtins.property
    @pulumi.getter(name="dataDestination")
    def data_destination(self) -> _builtins.str:
        """
        Data destination at the endpoint.
        """
        return pulumi.get(self, "data_destination")

    @_builtins.property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> _builtins.str:
        """
        The name of the DataflowEndpoint resource .
        """
        return pulumi.get(self, "endpoint_ref")

    @_builtins.property
    @pulumi.getter(name="outputSchemaSettings")
    def output_schema_settings(self) -> Optional['outputs.DataflowGraphDestinationSchemaSettingsResponse']:
        """
        Output schema settings.
        """
        return pulumi.get(self, "output_schema_settings")


@pulumi.output_type
class DataflowGraphDestinationSchemaSettingsResponse(dict):
    """
    DataflowGraph destination node output schema settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializationFormat":
            suggest = "serialization_format"
        elif key == "schemaRef":
            suggest = "schema_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphDestinationSchemaSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphDestinationSchemaSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphDestinationSchemaSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 serialization_format: _builtins.str,
                 schema_ref: Optional[_builtins.str] = None):
        """
        DataflowGraph destination node output schema settings.
        :param _builtins.str serialization_format: The format of the output data.
        :param _builtins.str schema_ref: Reference to the schema that describes the output of the transformation.
        """
        pulumi.set(__self__, "serialization_format", serialization_format)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)

    @_builtins.property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> _builtins.str:
        """
        The format of the output data.
        """
        return pulumi.get(self, "serialization_format")

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[_builtins.str]:
        """
        Reference to the schema that describes the output of the transformation.
        """
        return pulumi.get(self, "schema_ref")


@pulumi.output_type
class DataflowGraphGraphNodeConfigurationResponse(dict):
    """
    DataflowGraph graph node configuration.
    """
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        DataflowGraph graph node configuration.
        :param _builtins.str key: Key of the configuration.
        :param _builtins.str value: Value of the configuration.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the configuration.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the configuration.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataflowGraphGraphNodeResponse(dict):
    """
    DataflowGraph graph node properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "graphSettings":
            suggest = "graph_settings"
        elif key == "nodeType":
            suggest = "node_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphGraphNodeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphGraphNodeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphGraphNodeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 graph_settings: 'outputs.DataflowGraphNodeGraphSettingsResponse',
                 name: _builtins.str,
                 node_type: _builtins.str):
        """
        DataflowGraph graph node properties.
        :param 'DataflowGraphNodeGraphSettingsResponse' graph_settings: Graph configuration.
        :param _builtins.str name: Name of the node.
        :param _builtins.str node_type: DataflowGraph node types.
               Expected value is 'Graph'.
        """
        pulumi.set(__self__, "graph_settings", graph_settings)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_type", 'Graph')

    @_builtins.property
    @pulumi.getter(name="graphSettings")
    def graph_settings(self) -> 'outputs.DataflowGraphNodeGraphSettingsResponse':
        """
        Graph configuration.
        """
        return pulumi.get(self, "graph_settings")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the node.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        DataflowGraph node types.
        Expected value is 'Graph'.
        """
        return pulumi.get(self, "node_type")


@pulumi.output_type
class DataflowGraphNodeConnectionResponse(dict):
    """
    DataflowGraph DataflowGraphNode Connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphNodeConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphNodeConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphNodeConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.DataflowGraphConnectionInputResponse',
                 to: 'outputs.DataflowGraphConnectionOutputResponse'):
        """
        DataflowGraph DataflowGraphNode Connection.
        :param 'DataflowGraphConnectionInputResponse' from_: Information about the source node.
        :param 'DataflowGraphConnectionOutputResponse' to: Information about the destination node.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.DataflowGraphConnectionInputResponse':
        """
        Information about the source node.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> 'outputs.DataflowGraphConnectionOutputResponse':
        """
        Information about the destination node.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class DataflowGraphNodeGraphSettingsResponse(dict):
    """
    DataflowGraph graph node settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryEndpointRef":
            suggest = "registry_endpoint_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphNodeGraphSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphNodeGraphSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphNodeGraphSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact: _builtins.str,
                 registry_endpoint_ref: _builtins.str,
                 configuration: Optional[Sequence['outputs.DataflowGraphGraphNodeConfigurationResponse']] = None):
        """
        DataflowGraph graph node settings.
        :param _builtins.str artifact: The artifact name and version to pull. This should be in the format `<artifact-name>:<version>`.
        :param _builtins.str registry_endpoint_ref: Reference to the registry endpoint for pulling the artifact.
        :param Sequence['DataflowGraphGraphNodeConfigurationResponse'] configuration: Configuration key-value pairs.
        """
        pulumi.set(__self__, "artifact", artifact)
        pulumi.set(__self__, "registry_endpoint_ref", registry_endpoint_ref)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @_builtins.property
    @pulumi.getter
    def artifact(self) -> _builtins.str:
        """
        The artifact name and version to pull. This should be in the format `<artifact-name>:<version>`.
        """
        return pulumi.get(self, "artifact")

    @_builtins.property
    @pulumi.getter(name="registryEndpointRef")
    def registry_endpoint_ref(self) -> _builtins.str:
        """
        Reference to the registry endpoint for pulling the artifact.
        """
        return pulumi.get(self, "registry_endpoint_ref")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Sequence['outputs.DataflowGraphGraphNodeConfigurationResponse']]:
        """
        Configuration key-value pairs.
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class DataflowGraphPropertiesResponse(dict):
    """
    DataflowGraph properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConnections":
            suggest = "node_connections"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "requestDiskPersistence":
            suggest = "request_disk_persistence"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_connections: Sequence['outputs.DataflowGraphNodeConnectionResponse'],
                 nodes: Sequence[Any],
                 provisioning_state: _builtins.str,
                 mode: Optional[_builtins.str] = None,
                 request_disk_persistence: Optional[_builtins.str] = None):
        """
        DataflowGraph properties.
        :param Sequence['DataflowGraphNodeConnectionResponse'] node_connections: List of connections between nodes in the dataflow graph.
        :param Sequence[Union['DataflowGraphDestinationNodeResponse', 'DataflowGraphGraphNodeResponse', 'DataflowGraphSourceNodeResponse']] nodes: List of nodes in the dataflow graph.
        :param _builtins.str provisioning_state: The provisioning state of the dataflow graph.
        :param _builtins.str mode: The mode of the dataflow graph.
        :param _builtins.str request_disk_persistence: Disk persistence mode.
        """
        pulumi.set(__self__, "node_connections", node_connections)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if request_disk_persistence is not None:
            pulumi.set(__self__, "request_disk_persistence", request_disk_persistence)

    @_builtins.property
    @pulumi.getter(name="nodeConnections")
    def node_connections(self) -> Sequence['outputs.DataflowGraphNodeConnectionResponse']:
        """
        List of connections between nodes in the dataflow graph.
        """
        return pulumi.get(self, "node_connections")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence[Any]:
        """
        List of nodes in the dataflow graph.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the dataflow graph.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The mode of the dataflow graph.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="requestDiskPersistence")
    def request_disk_persistence(self) -> Optional[_builtins.str]:
        """
        Disk persistence mode.
        """
        return pulumi.get(self, "request_disk_persistence")


@pulumi.output_type
class DataflowGraphSourceNodeResponse(dict):
    """
    DataflowGraph source node properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeType":
            suggest = "node_type"
        elif key == "sourceSettings":
            suggest = "source_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphSourceNodeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphSourceNodeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphSourceNodeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 node_type: _builtins.str,
                 source_settings: 'outputs.DataflowGraphSourceSettingsResponse'):
        """
        DataflowGraph source node properties.
        :param _builtins.str name: Name of the node.
        :param _builtins.str node_type: DataflowGraph node types.
               Expected value is 'Source'.
        :param 'DataflowGraphSourceSettingsResponse' source_settings: Source configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_type", 'Source')
        pulumi.set(__self__, "source_settings", source_settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the node.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        DataflowGraph node types.
        Expected value is 'Source'.
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter(name="sourceSettings")
    def source_settings(self) -> 'outputs.DataflowGraphSourceSettingsResponse':
        """
        Source configuration.
        """
        return pulumi.get(self, "source_settings")


@pulumi.output_type
class DataflowGraphSourceSettingsResponse(dict):
    """
    DataflowGraph source node settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSources":
            suggest = "data_sources"
        elif key == "endpointRef":
            suggest = "endpoint_ref"
        elif key == "assetRef":
            suggest = "asset_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowGraphSourceSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowGraphSourceSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowGraphSourceSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_sources: Sequence[_builtins.str],
                 endpoint_ref: _builtins.str,
                 asset_ref: Optional[_builtins.str] = None):
        """
        DataflowGraph source node settings.
        :param Sequence[_builtins.str] data_sources: List of data sources.
        :param _builtins.str endpoint_ref: The endpoint reference for the source.
        :param _builtins.str asset_ref: Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)
        if asset_ref is not None:
            pulumi.set(__self__, "asset_ref", asset_ref)

    @_builtins.property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence[_builtins.str]:
        """
        List of data sources.
        """
        return pulumi.get(self, "data_sources")

    @_builtins.property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> _builtins.str:
        """
        The endpoint reference for the source.
        """
        return pulumi.get(self, "endpoint_ref")

    @_builtins.property
    @pulumi.getter(name="assetRef")
    def asset_ref(self) -> Optional[_builtins.str]:
        """
        Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        return pulumi.get(self, "asset_ref")


@pulumi.output_type
class DataflowOperationResponse(dict):
    """
    Dataflow Operation properties. NOTE - One only method is allowed to be used for one entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationType":
            suggest = "operation_type"
        elif key == "builtInTransformationSettings":
            suggest = "built_in_transformation_settings"
        elif key == "destinationSettings":
            suggest = "destination_settings"
        elif key == "sourceSettings":
            suggest = "source_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowOperationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowOperationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowOperationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operation_type: _builtins.str,
                 built_in_transformation_settings: Optional['outputs.DataflowBuiltInTransformationSettingsResponse'] = None,
                 destination_settings: Optional['outputs.DataflowDestinationOperationSettingsResponse'] = None,
                 name: Optional[_builtins.str] = None,
                 source_settings: Optional['outputs.DataflowSourceOperationSettingsResponse'] = None):
        """
        Dataflow Operation properties. NOTE - One only method is allowed to be used for one entry.
        :param _builtins.str operation_type: Type of operation.
        :param 'DataflowBuiltInTransformationSettingsResponse' built_in_transformation_settings: Built In Transformation configuration.
        :param 'DataflowDestinationOperationSettingsResponse' destination_settings: Destination configuration.
        :param _builtins.str name: Optional user provided name of the transformation.
        :param 'DataflowSourceOperationSettingsResponse' source_settings: Source configuration.
        """
        pulumi.set(__self__, "operation_type", operation_type)
        if built_in_transformation_settings is not None:
            pulumi.set(__self__, "built_in_transformation_settings", built_in_transformation_settings)
        if destination_settings is not None:
            pulumi.set(__self__, "destination_settings", destination_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_settings is not None:
            pulumi.set(__self__, "source_settings", source_settings)

    @_builtins.property
    @pulumi.getter(name="operationType")
    def operation_type(self) -> _builtins.str:
        """
        Type of operation.
        """
        return pulumi.get(self, "operation_type")

    @_builtins.property
    @pulumi.getter(name="builtInTransformationSettings")
    def built_in_transformation_settings(self) -> Optional['outputs.DataflowBuiltInTransformationSettingsResponse']:
        """
        Built In Transformation configuration.
        """
        return pulumi.get(self, "built_in_transformation_settings")

    @_builtins.property
    @pulumi.getter(name="destinationSettings")
    def destination_settings(self) -> Optional['outputs.DataflowDestinationOperationSettingsResponse']:
        """
        Destination configuration.
        """
        return pulumi.get(self, "destination_settings")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Optional user provided name of the transformation.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceSettings")
    def source_settings(self) -> Optional['outputs.DataflowSourceOperationSettingsResponse']:
        """
        Source configuration.
        """
        return pulumi.get(self, "source_settings")


@pulumi.output_type
class DataflowProfilePropertiesResponse(dict):
    """
    DataflowProfile Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "instanceCount":
            suggest = "instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowProfilePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowProfilePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowProfilePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 diagnostics: Optional['outputs.ProfileDiagnosticsResponse'] = None,
                 instance_count: Optional[_builtins.int] = None):
        """
        DataflowProfile Resource properties
        :param _builtins.str provisioning_state: The status of the last operation.
        :param 'ProfileDiagnosticsResponse' diagnostics: Spec defines the desired identities of NBC diagnostics settings.
        :param _builtins.int instance_count: To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if instance_count is None:
            instance_count = 1
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def diagnostics(self) -> Optional['outputs.ProfileDiagnosticsResponse']:
        """
        Spec defines the desired identities of NBC diagnostics settings.
        """
        return pulumi.get(self, "diagnostics")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
        return pulumi.get(self, "instance_count")


@pulumi.output_type
class DataflowPropertiesResponse(dict):
    """
    Dataflow Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operations: Sequence['outputs.DataflowOperationResponse'],
                 provisioning_state: _builtins.str,
                 mode: Optional[_builtins.str] = None):
        """
        Dataflow Resource properties
        :param Sequence['DataflowOperationResponse'] operations: List of operations including source and destination references as well as transformation.
        :param _builtins.str provisioning_state: The status of the last operation.
        :param _builtins.str mode: Mode for Dataflow. Optional; defaults to Enabled.
        """
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def operations(self) -> Sequence['outputs.DataflowOperationResponse']:
        """
        List of operations including source and destination references as well as transformation.
        """
        return pulumi.get(self, "operations")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mode for Dataflow. Optional; defaults to Enabled.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DataflowSourceOperationSettingsResponse(dict):
    """
    Dataflow Source Operation properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSources":
            suggest = "data_sources"
        elif key == "endpointRef":
            suggest = "endpoint_ref"
        elif key == "assetRef":
            suggest = "asset_ref"
        elif key == "schemaRef":
            suggest = "schema_ref"
        elif key == "serializationFormat":
            suggest = "serialization_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowSourceOperationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowSourceOperationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowSourceOperationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_sources: Sequence[_builtins.str],
                 endpoint_ref: _builtins.str,
                 asset_ref: Optional[_builtins.str] = None,
                 schema_ref: Optional[_builtins.str] = None,
                 serialization_format: Optional[_builtins.str] = None):
        """
        Dataflow Source Operation properties
        :param Sequence[_builtins.str] data_sources: List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        :param _builtins.str endpoint_ref: Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        :param _builtins.str asset_ref: Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        :param _builtins.str schema_ref: Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        :param _builtins.str serialization_format: Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)
        if asset_ref is not None:
            pulumi.set(__self__, "asset_ref", asset_ref)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is None:
            serialization_format = 'Json'
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @_builtins.property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence[_builtins.str]:
        """
        List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        """
        return pulumi.get(self, "data_sources")

    @_builtins.property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> _builtins.str:
        """
        Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        """
        return pulumi.get(self, "endpoint_ref")

    @_builtins.property
    @pulumi.getter(name="assetRef")
    def asset_ref(self) -> Optional[_builtins.str]:
        """
        Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        return pulumi.get(self, "asset_ref")

    @_builtins.property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[_builtins.str]:
        """
        Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        """
        return pulumi.get(self, "schema_ref")

    @_builtins.property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[_builtins.str]:
        """
        Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
        return pulumi.get(self, "serialization_format")


@pulumi.output_type
class DiagnosticsLogsResponse(dict):
    """
    Diagnostic Log properties
    """
    def __init__(__self__, *,
                 level: Optional[_builtins.str] = None):
        """
        Diagnostic Log properties
        :param _builtins.str level: The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        if level is None:
            level = 'info'
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class DiskBackedMessageBufferResponse(dict):
    """
    DiskBackedMessageBuffer properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "ephemeralVolumeClaimSpec":
            suggest = "ephemeral_volume_claim_spec"
        elif key == "persistentVolumeClaimSpec":
            suggest = "persistent_volume_claim_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskBackedMessageBufferResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskBackedMessageBufferResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskBackedMessageBufferResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: _builtins.str,
                 ephemeral_volume_claim_spec: Optional['outputs.VolumeClaimSpecResponse'] = None,
                 persistent_volume_claim_spec: Optional['outputs.VolumeClaimSpecResponse'] = None):
        """
        DiskBackedMessageBuffer properties
        :param _builtins.str max_size: The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        :param 'VolumeClaimSpecResponse' ephemeral_volume_claim_spec: Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        :param 'VolumeClaimSpecResponse' persistent_volume_claim_spec: Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        pulumi.set(__self__, "max_size", max_size)
        if ephemeral_volume_claim_spec is not None:
            pulumi.set(__self__, "ephemeral_volume_claim_spec", ephemeral_volume_claim_spec)
        if persistent_volume_claim_spec is not None:
            pulumi.set(__self__, "persistent_volume_claim_spec", persistent_volume_claim_spec)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> _builtins.str:
        """
        The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="ephemeralVolumeClaimSpec")
    def ephemeral_volume_claim_spec(self) -> Optional['outputs.VolumeClaimSpecResponse']:
        """
        Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        """
        return pulumi.get(self, "ephemeral_volume_claim_spec")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaimSpec")
    def persistent_volume_claim_spec(self) -> Optional['outputs.VolumeClaimSpecResponse']:
        """
        Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        return pulumi.get(self, "persistent_volume_claim_spec")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    """
    Extended location is an extension of Azure locations. They provide a way to use their Azure ARC enabled Kubernetes clusters as target locations for deploying Azure services instances.
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        Extended location is an extension of Azure locations. They provide a way to use their Azure ARC enabled Kubernetes clusters as target locations for deploying Azure services instances.
        :param _builtins.str name: The name of the extended location.
        :param _builtins.str type: Type of ExtendedLocation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of ExtendedLocation.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FrontendResponse(dict):
    """
    The desired properties of the frontend instances of the Broker
    """
    def __init__(__self__, *,
                 replicas: _builtins.int,
                 workers: Optional[_builtins.int] = None):
        """
        The desired properties of the frontend instances of the Broker
        :param _builtins.int replicas: The desired number of frontend instances (pods).
        :param _builtins.int workers: Number of logical frontend workers per instance (pod).
        """
        pulumi.set(__self__, "replicas", replicas)
        if workers is None:
            workers = 2
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> _builtins.int:
        """
        The desired number of frontend instances (pods).
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[_builtins.int]:
        """
        Number of logical frontend workers per instance (pod).
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class GenerateResourceLimitsResponse(dict):
    """
    GenerateResourceLimits properties
    """
    def __init__(__self__, *,
                 cpu: Optional[_builtins.str] = None):
        """
        GenerateResourceLimits properties
        :param _builtins.str cpu: The toggle to enable/disable cpu resource limits.
        """
        if cpu is None:
            cpu = 'Enabled'
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.str]:
        """
        The toggle to enable/disable cpu resource limits.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class InstancePropertiesResponse(dict):
    """
    The properties of the Instance resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "schemaRegistryRef":
            suggest = "schema_registry_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 schema_registry_ref: 'outputs.SchemaRegistryRefResponse',
                 version: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        The properties of the Instance resource.
        :param _builtins.str provisioning_state: The status of the last operation.
        :param 'SchemaRegistryRefResponse' schema_registry_ref: The reference to the Schema Registry for this AIO Instance.
        :param _builtins.str version: The Azure IoT Operations version.
        :param _builtins.str description: Detailed description of the Instance.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "schema_registry_ref", schema_registry_ref)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryRef")
    def schema_registry_ref(self) -> 'outputs.SchemaRegistryRefResponse':
        """
        The reference to the Schema Registry for this AIO Instance.
        """
        return pulumi.get(self, "schema_registry_ref")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The Azure IoT Operations version.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Detailed description of the Instance.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class KubernetesReferenceResponse(dict):
    """
    Kubernetes reference
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGroup":
            suggest = "api_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: _builtins.str,
                 name: _builtins.str,
                 api_group: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None):
        """
        Kubernetes reference
        :param _builtins.str kind: Kind is the type of resource being referenced
        :param _builtins.str name: Name is the name of resource being referenced
        :param _builtins.str api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        :param _builtins.str namespace: Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[_builtins.str]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ListenerPortResponse(dict):
    """
    Defines a TCP port on which a `BrokerListener` listens.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationRef":
            suggest = "authentication_ref"
        elif key == "authorizationRef":
            suggest = "authorization_ref"
        elif key == "nodePort":
            suggest = "node_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerPortResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerPortResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerPortResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: _builtins.int,
                 authentication_ref: Optional[_builtins.str] = None,
                 authorization_ref: Optional[_builtins.str] = None,
                 node_port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 tls: Optional['outputs.TlsCertMethodResponse'] = None):
        """
        Defines a TCP port on which a `BrokerListener` listens.
        :param _builtins.int port: TCP port for accepting client connections.
        :param _builtins.str authentication_ref: Reference to client authentication settings. Omit to disable authentication.
        :param _builtins.str authorization_ref: Reference to client authorization settings. Omit to disable authorization.
        :param _builtins.int node_port: Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        :param _builtins.str protocol: Protocol to use for client connections.
        :param 'TlsCertMethodResponse' tls: TLS server certificate settings for this port. Omit to disable TLS.
        """
        pulumi.set(__self__, "port", port)
        if authentication_ref is not None:
            pulumi.set(__self__, "authentication_ref", authentication_ref)
        if authorization_ref is not None:
            pulumi.set(__self__, "authorization_ref", authorization_ref)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)
        if protocol is None:
            protocol = 'Mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        TCP port for accepting client connections.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="authenticationRef")
    def authentication_ref(self) -> Optional[_builtins.str]:
        """
        Reference to client authentication settings. Omit to disable authentication.
        """
        return pulumi.get(self, "authentication_ref")

    @_builtins.property
    @pulumi.getter(name="authorizationRef")
    def authorization_ref(self) -> Optional[_builtins.str]:
        """
        Reference to client authorization settings. Omit to disable authorization.
        """
        return pulumi.get(self, "authorization_ref")

    @_builtins.property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[_builtins.int]:
        """
        Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        """
        return pulumi.get(self, "node_port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Protocol to use for client connections.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional['outputs.TlsCertMethodResponse']:
        """
        TLS server certificate settings for this port. Omit to disable TLS.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class LocalKubernetesReferenceResponse(dict):
    """
    Kubernetes reference
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGroup":
            suggest = "api_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalKubernetesReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalKubernetesReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalKubernetesReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: _builtins.str,
                 name: _builtins.str,
                 api_group: Optional[_builtins.str] = None):
        """
        Kubernetes reference
        :param _builtins.str kind: Kind is the type of resource being referenced
        :param _builtins.str name: Name is the name of resource being referenced
        :param _builtins.str api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[_builtins.str]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param _builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MetricsResponse(dict):
    """
    Diagnostic Metrics properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prometheusPort":
            suggest = "prometheus_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prometheus_port: Optional[_builtins.int] = None):
        """
        Diagnostic Metrics properties
        :param _builtins.int prometheus_port: The prometheus port to expose the metrics.
        """
        if prometheus_port is None:
            prometheus_port = 9600
        if prometheus_port is not None:
            pulumi.set(__self__, "prometheus_port", prometheus_port)

    @_builtins.property
    @pulumi.getter(name="prometheusPort")
    def prometheus_port(self) -> Optional[_builtins.int]:
        """
        The prometheus port to expose the metrics.
        """
        return pulumi.get(self, "prometheus_port")


@pulumi.output_type
class PrincipalDefinitionResponse(dict):
    """
    PrincipalDefinition properties of Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIds":
            suggest = "client_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrincipalDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrincipalDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrincipalDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attributes: Optional[Sequence[Mapping[str, _builtins.str]]] = None,
                 client_ids: Optional[Sequence[_builtins.str]] = None,
                 usernames: Optional[Sequence[_builtins.str]] = None):
        """
        PrincipalDefinition properties of Rule
        :param Sequence[Mapping[str, _builtins.str]] attributes: A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        :param Sequence[_builtins.str] client_ids: A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        :param Sequence[_builtins.str] usernames: A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if client_ids is not None:
            pulumi.set(__self__, "client_ids", client_ids)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence[Mapping[str, _builtins.str]]]:
        """
        A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        """
        return pulumi.get(self, "attributes")

    @_builtins.property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        """
        return pulumi.get(self, "client_ids")

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class ProfileDiagnosticsResponse(dict):
    """
    DataflowProfile Diagnostics properties
    """
    def __init__(__self__, *,
                 logs: Optional['outputs.DiagnosticsLogsResponse'] = None,
                 metrics: Optional['outputs.MetricsResponse'] = None):
        """
        DataflowProfile Diagnostics properties
        :param 'DiagnosticsLogsResponse' logs: Diagnostic log settings for the resource.
        :param 'MetricsResponse' metrics: The metrics settings for the resource.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional['outputs.DiagnosticsLogsResponse']:
        """
        Diagnostic log settings for the resource.
        """
        return pulumi.get(self, "logs")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.MetricsResponse']:
        """
        The metrics settings for the resource.
        """
        return pulumi.get(self, "metrics")


@pulumi.output_type
class RegistryEndpointAnonymousAuthenticationResponse(dict):
    """
    Anonymous authentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousSettings":
            suggest = "anonymous_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointAnonymousAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointAnonymousAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointAnonymousAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous_settings: Any,
                 method: _builtins.str):
        """
        Anonymous authentication
        :param Any anonymous_settings: Anonymous authentication properties
        :param _builtins.str method: The authentication method.
               Expected value is 'Anonymous'.
        """
        pulumi.set(__self__, "anonymous_settings", anonymous_settings)
        pulumi.set(__self__, "method", 'Anonymous')

    @_builtins.property
    @pulumi.getter(name="anonymousSettings")
    def anonymous_settings(self) -> Any:
        """
        Anonymous authentication properties
        """
        return pulumi.get(self, "anonymous_settings")

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        The authentication method.
        Expected value is 'Anonymous'.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class RegistryEndpointArtifactPullSecretAuthenticationResponse(dict):
    """
    Artifact Pull Secret authentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactPullSecretSettings":
            suggest = "artifact_pull_secret_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointArtifactPullSecretAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointArtifactPullSecretAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointArtifactPullSecretAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_pull_secret_settings: 'outputs.RegistryEndpointArtifactPullSecretSettingsResponse',
                 method: _builtins.str):
        """
        Artifact Pull Secret authentication
        :param 'RegistryEndpointArtifactPullSecretSettingsResponse' artifact_pull_secret_settings: Artifact Pull Secret authentication properties
        :param _builtins.str method: The authentication method.
               Expected value is 'ArtifactPullSecret'.
        """
        pulumi.set(__self__, "artifact_pull_secret_settings", artifact_pull_secret_settings)
        pulumi.set(__self__, "method", 'ArtifactPullSecret')

    @_builtins.property
    @pulumi.getter(name="artifactPullSecretSettings")
    def artifact_pull_secret_settings(self) -> 'outputs.RegistryEndpointArtifactPullSecretSettingsResponse':
        """
        Artifact Pull Secret authentication properties
        """
        return pulumi.get(self, "artifact_pull_secret_settings")

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        The authentication method.
        Expected value is 'ArtifactPullSecret'.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class RegistryEndpointArtifactPullSecretSettingsResponse(dict):
    """
    RegistryEndpoint Artifact Pull Secret authentication properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointArtifactPullSecretSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointArtifactPullSecretSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointArtifactPullSecretSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: _builtins.str):
        """
        RegistryEndpoint Artifact Pull Secret authentication properties
        :param _builtins.str secret_ref: The name of the kubernetes secret that contains the artifact pull secret.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> _builtins.str:
        """
        The name of the kubernetes secret that contains the artifact pull secret.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class RegistryEndpointPropertiesResponse(dict):
    """
    RegistryEndpoint properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "trustSettings":
            suggest = "trust_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: Any,
                 host: _builtins.str,
                 provisioning_state: _builtins.str,
                 trust_settings: Optional['outputs.RegistryEndpointTrustedSettingsResponse'] = None):
        """
        RegistryEndpoint properties
        :param Union['RegistryEndpointAnonymousAuthenticationResponse', 'RegistryEndpointArtifactPullSecretAuthenticationResponse', 'RegistryEndpointSystemAssignedIdentityAuthenticationResponse', 'RegistryEndpointUserAssignedIdentityAuthenticationResponse'] authentication: The authentication settings for the Azure Container Registry.
        :param _builtins.str host: The Container Registry endpoint hostname.
        :param _builtins.str provisioning_state: The status of the last operation.
        :param 'RegistryEndpointTrustedSettingsResponse' trust_settings: Trust settings for the registry endpoint
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if trust_settings is not None:
            pulumi.set(__self__, "trust_settings", trust_settings)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Any:
        """
        The authentication settings for the Azure Container Registry.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The Container Registry endpoint hostname.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="trustSettings")
    def trust_settings(self) -> Optional['outputs.RegistryEndpointTrustedSettingsResponse']:
        """
        Trust settings for the registry endpoint
        """
        return pulumi.get(self, "trust_settings")


@pulumi.output_type
class RegistryEndpointSystemAssignedIdentityAuthenticationResponse(dict):
    """
    System assigned identity authentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointSystemAssignedIdentityAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointSystemAssignedIdentityAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointSystemAssignedIdentityAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 system_assigned_managed_identity_settings: 'outputs.RegistryEndpointSystemAssignedManagedIdentitySettingsResponse'):
        """
        System assigned identity authentication
        :param _builtins.str method: The authentication method.
               Expected value is 'SystemAssignedManagedIdentity'.
        :param 'RegistryEndpointSystemAssignedManagedIdentitySettingsResponse' system_assigned_managed_identity_settings: System assigned managed identity properties
        """
        pulumi.set(__self__, "method", 'SystemAssignedManagedIdentity')
        pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        The authentication method.
        Expected value is 'SystemAssignedManagedIdentity'.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> 'outputs.RegistryEndpointSystemAssignedManagedIdentitySettingsResponse':
        """
        System assigned managed identity properties
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")


@pulumi.output_type
class RegistryEndpointSystemAssignedManagedIdentitySettingsResponse(dict):
    """
    System assigned managed identity properties
    """
    def __init__(__self__, *,
                 audience: Optional[_builtins.str] = None):
        """
        System assigned managed identity properties
        :param _builtins.str audience: Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> Optional[_builtins.str]:
        """
        Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        return pulumi.get(self, "audience")


@pulumi.output_type
class RegistryEndpointTrustedSettingsResponse(dict):
    """
    RegistryEndpointTrustedSettings properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedSigningKeys":
            suggest = "trusted_signing_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointTrustedSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointTrustedSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointTrustedSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trusted_signing_keys: Any):
        """
        RegistryEndpointTrustedSettings properties
        :param Union['RegistryEndpointTrustedSigningKeyConfigMapResponse', 'RegistryEndpointTrustedSigningKeySecretResponse'] trusted_signing_keys: The trust properties for the registry endpoint.
        """
        pulumi.set(__self__, "trusted_signing_keys", trusted_signing_keys)

    @_builtins.property
    @pulumi.getter(name="trustedSigningKeys")
    def trusted_signing_keys(self) -> Any:
        """
        The trust properties for the registry endpoint.
        """
        return pulumi.get(self, "trusted_signing_keys")


@pulumi.output_type
class RegistryEndpointTrustedSigningKeyConfigMapResponse(dict):
    """
    Settings for RegistryEndpoint trust provided through a configmap.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapRef":
            suggest = "config_map_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointTrustedSigningKeyConfigMapResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointTrustedSigningKeyConfigMapResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointTrustedSigningKeyConfigMapResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_ref: _builtins.str,
                 type: _builtins.str):
        """
        Settings for RegistryEndpoint trust provided through a configmap.
        :param _builtins.str config_map_ref: The name of the configmap.
        :param _builtins.str type: RegistryEndpointTrustedSigningKeyType values
               Expected value is 'ConfigMap'.
        """
        pulumi.set(__self__, "config_map_ref", config_map_ref)
        pulumi.set(__self__, "type", 'ConfigMap')

    @_builtins.property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> _builtins.str:
        """
        The name of the configmap.
        """
        return pulumi.get(self, "config_map_ref")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        RegistryEndpointTrustedSigningKeyType values
        Expected value is 'ConfigMap'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RegistryEndpointTrustedSigningKeySecretResponse(dict):
    """
    Settings for RegistryEndpoint trust provided through a secret.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointTrustedSigningKeySecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointTrustedSigningKeySecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointTrustedSigningKeySecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: _builtins.str,
                 type: _builtins.str):
        """
        Settings for RegistryEndpoint trust provided through a secret.
        :param _builtins.str secret_ref: The name of the secret.
        :param _builtins.str type: RegistryEndpointTrustedSigningKeyType values
               Expected value is 'Secret'.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)
        pulumi.set(__self__, "type", 'Secret')

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> _builtins.str:
        """
        The name of the secret.
        """
        return pulumi.get(self, "secret_ref")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        RegistryEndpointTrustedSigningKeyType values
        Expected value is 'Secret'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RegistryEndpointUserAssignedIdentityAuthenticationResponse(dict):
    """
    User assigned identity authentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointUserAssignedIdentityAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointUserAssignedIdentityAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointUserAssignedIdentityAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 user_assigned_managed_identity_settings: 'outputs.RegistryEndpointUserAssignedManagedIdentitySettingsResponse'):
        """
        User assigned identity authentication
        :param _builtins.str method: The authentication method.
               Expected value is 'UserAssignedManagedIdentity'.
        :param 'RegistryEndpointUserAssignedManagedIdentitySettingsResponse' user_assigned_managed_identity_settings: User assigned managed identity properties
        """
        pulumi.set(__self__, "method", 'UserAssignedManagedIdentity')
        pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        The authentication method.
        Expected value is 'UserAssignedManagedIdentity'.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> 'outputs.RegistryEndpointUserAssignedManagedIdentitySettingsResponse':
        """
        User assigned managed identity properties
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")


@pulumi.output_type
class RegistryEndpointUserAssignedManagedIdentitySettingsResponse(dict):
    """
    User assigned managed identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryEndpointUserAssignedManagedIdentitySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryEndpointUserAssignedManagedIdentitySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryEndpointUserAssignedManagedIdentitySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 tenant_id: _builtins.str,
                 scope: Optional[_builtins.str] = None):
        """
        User assigned managed identity properties
        :param _builtins.str client_id: Client ID for the user-assigned managed identity.
        :param _builtins.str tenant_id: Tenant ID.
        :param _builtins.str scope: Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Client ID for the user-assigned managed identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class SanForCertResponse(dict):
    """
    Subject Alternative Names (SANs) for certificate.
    """
    def __init__(__self__, *,
                 dns: Sequence[_builtins.str],
                 ip: Sequence[_builtins.str]):
        """
        Subject Alternative Names (SANs) for certificate.
        :param Sequence[_builtins.str] dns: DNS SANs.
        :param Sequence[_builtins.str] ip: IP address SANs.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Sequence[_builtins.str]:
        """
        DNS SANs.
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Sequence[_builtins.str]:
        """
        IP address SANs.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class SchemaRegistryRefResponse(dict):
    """
    The reference to the Schema Registry for this AIO Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaRegistryRefResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaRegistryRefResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaRegistryRefResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str):
        """
        The reference to the Schema Registry for this AIO Instance.
        :param _builtins.str resource_id: The resource ID of the Schema Registry.
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The resource ID of the Schema Registry.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class SelfCheckResponse(dict):
    """
    Broker Diagnostic Self check properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSeconds":
            suggest = "interval_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelfCheckResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelfCheckResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelfCheckResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_seconds: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        Broker Diagnostic Self check properties
        :param _builtins.int interval_seconds: The self check interval.
        :param _builtins.str mode: The toggle to enable/disable self check.
        :param _builtins.int timeout_seconds: The timeout for self check.
        """
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if timeout_seconds is None:
            timeout_seconds = 15
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[_builtins.int]:
        """
        The self check interval.
        """
        return pulumi.get(self, "interval_seconds")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The toggle to enable/disable self check.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        The timeout for self check.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class SelfTracingResponse(dict):
    """
    Diagnostic Self tracing properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSeconds":
            suggest = "interval_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelfTracingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelfTracingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelfTracingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_seconds: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None):
        """
        Diagnostic Self tracing properties
        :param _builtins.int interval_seconds: The self tracing interval.
        :param _builtins.str mode: The toggle to enable/disable self tracing.
        """
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[_builtins.int]:
        """
        The self tracing interval.
        """
        return pulumi.get(self, "interval_seconds")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The toggle to enable/disable self tracing.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class StateStoreResourceRuleResponse(dict):
    """
    State Store Resource Rule properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyType":
            suggest = "key_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StateStoreResourceRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StateStoreResourceRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StateStoreResourceRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_type: _builtins.str,
                 keys: Sequence[_builtins.str],
                 method: _builtins.str):
        """
        State Store Resource Rule properties.
        :param _builtins.str key_type: Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        :param Sequence[_builtins.str] keys: Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        :param _builtins.str method: Give access for `Read`, `Write` and `ReadWrite` access level.
        """
        pulumi.set(__self__, "key_type", key_type)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "method", method)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> _builtins.str:
        """
        Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        """
        return pulumi.get(self, "key_type")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Sequence[_builtins.str]:
        """
        Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Give access for `Read`, `Write` and `ReadWrite` access level.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class SubscriberQueueLimitResponse(dict):
    """
    The settings of Subscriber Queue Limit.
    """
    def __init__(__self__, *,
                 length: Optional[_builtins.float] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        The settings of Subscriber Queue Limit.
        :param _builtins.float length: The maximum length of the queue before messages start getting dropped.
        :param _builtins.str strategy: The strategy to use for dropping messages from the queue.
        """
        if length is not None:
            pulumi.set(__self__, "length", length)
        if strategy is None:
            strategy = 'None'
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.float]:
        """
        The maximum length of the queue before messages start getting dropped.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        The strategy to use for dropping messages from the queue.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TlsCertMethodResponse(dict):
    """
    Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certManagerCertificateSpec":
            suggest = "cert_manager_certificate_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TlsCertMethodResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TlsCertMethodResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TlsCertMethodResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: _builtins.str,
                 cert_manager_certificate_spec: Optional['outputs.CertManagerCertificateSpecResponse'] = None,
                 manual: Optional['outputs.X509ManualCertificateResponse'] = None):
        """
        Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
        :param _builtins.str mode: Mode of TLS server certificate management.
        :param 'CertManagerCertificateSpecResponse' cert_manager_certificate_spec: Option 1 - Automatic TLS server certificate management with cert-manager.
        :param 'X509ManualCertificateResponse' manual: Option 2 - Manual TLS server certificate management through a defined secret.
        """
        pulumi.set(__self__, "mode", mode)
        if cert_manager_certificate_spec is not None:
            pulumi.set(__self__, "cert_manager_certificate_spec", cert_manager_certificate_spec)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Mode of TLS server certificate management.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="certManagerCertificateSpec")
    def cert_manager_certificate_spec(self) -> Optional['outputs.CertManagerCertificateSpecResponse']:
        """
        Option 1 - Automatic TLS server certificate management with cert-manager.
        """
        return pulumi.get(self, "cert_manager_certificate_spec")

    @_builtins.property
    @pulumi.getter
    def manual(self) -> Optional['outputs.X509ManualCertificateResponse']:
        """
        Option 2 - Manual TLS server certificate management through a defined secret.
        """
        return pulumi.get(self, "manual")


@pulumi.output_type
class TlsPropertiesResponse(dict):
    """
    Tls properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCaCertificateConfigMapRef":
            suggest = "trusted_ca_certificate_config_map_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TlsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TlsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TlsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 trusted_ca_certificate_config_map_ref: Optional[_builtins.str] = None):
        """
        Tls properties
        :param _builtins.str mode: Mode for TLS.
        :param _builtins.str trusted_ca_certificate_config_map_ref: Trusted CA certificate config map.
        """
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if trusted_ca_certificate_config_map_ref is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map_ref", trusted_ca_certificate_config_map_ref)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Mode for TLS.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="trustedCaCertificateConfigMapRef")
    def trusted_ca_certificate_config_map_ref(self) -> Optional[_builtins.str]:
        """
        Trusted CA certificate config map.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map_ref")


@pulumi.output_type
class TracesResponse(dict):
    """
    Broker Diagnostic Trace properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheSizeMegabytes":
            suggest = "cache_size_megabytes"
        elif key == "selfTracing":
            suggest = "self_tracing"
        elif key == "spanChannelCapacity":
            suggest = "span_channel_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TracesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TracesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TracesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_size_megabytes: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 self_tracing: Optional['outputs.SelfTracingResponse'] = None,
                 span_channel_capacity: Optional[_builtins.int] = None):
        """
        Broker Diagnostic Trace properties
        :param _builtins.int cache_size_megabytes: The cache size in megabytes.
        :param _builtins.str mode: The toggle to enable/disable traces.
        :param 'SelfTracingResponse' self_tracing: The self tracing properties.
        :param _builtins.int span_channel_capacity: The span channel capacity.
        """
        if cache_size_megabytes is None:
            cache_size_megabytes = 16
        if cache_size_megabytes is not None:
            pulumi.set(__self__, "cache_size_megabytes", cache_size_megabytes)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if self_tracing is not None:
            pulumi.set(__self__, "self_tracing", self_tracing)
        if span_channel_capacity is None:
            span_channel_capacity = 1000
        if span_channel_capacity is not None:
            pulumi.set(__self__, "span_channel_capacity", span_channel_capacity)

    @_builtins.property
    @pulumi.getter(name="cacheSizeMegabytes")
    def cache_size_megabytes(self) -> Optional[_builtins.int]:
        """
        The cache size in megabytes.
        """
        return pulumi.get(self, "cache_size_megabytes")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The toggle to enable/disable traces.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="selfTracing")
    def self_tracing(self) -> Optional['outputs.SelfTracingResponse']:
        """
        The self tracing properties.
        """
        return pulumi.get(self, "self_tracing")

    @_builtins.property
    @pulumi.getter(name="spanChannelCapacity")
    def span_channel_capacity(self) -> Optional[_builtins.int]:
        """
        The span channel capacity.
        """
        return pulumi.get(self, "span_channel_capacity")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VolumeClaimResourceRequirementsResponse(dict):
    """
    VolumeClaimResourceRequirements properties
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, _builtins.str]] = None,
                 requests: Optional[Mapping[str, _builtins.str]] = None):
        """
        VolumeClaimResourceRequirements properties
        :param Mapping[str, _builtins.str] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, _builtins.str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class VolumeClaimSpecResponse(dict):
    """
    VolumeClaimSpec properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessModes":
            suggest = "access_modes"
        elif key == "dataSource":
            suggest = "data_source"
        elif key == "dataSourceRef":
            suggest = "data_source_ref"
        elif key == "storageClassName":
            suggest = "storage_class_name"
        elif key == "volumeMode":
            suggest = "volume_mode"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeClaimSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeClaimSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeClaimSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_modes: Optional[Sequence[_builtins.str]] = None,
                 data_source: Optional['outputs.LocalKubernetesReferenceResponse'] = None,
                 data_source_ref: Optional['outputs.KubernetesReferenceResponse'] = None,
                 resources: Optional['outputs.VolumeClaimResourceRequirementsResponse'] = None,
                 selector: Optional['outputs.VolumeClaimSpecSelectorResponse'] = None,
                 storage_class_name: Optional[_builtins.str] = None,
                 volume_mode: Optional[_builtins.str] = None,
                 volume_name: Optional[_builtins.str] = None):
        """
        VolumeClaimSpec properties
        :param Sequence[_builtins.str] access_modes: AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        :param 'LocalKubernetesReferenceResponse' data_source: This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        :param 'KubernetesReferenceResponse' data_source_ref: Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        :param 'VolumeClaimResourceRequirementsResponse' resources: Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param 'VolumeClaimSpecSelectorResponse' selector: A label query over volumes to consider for binding.
        :param _builtins.str storage_class_name: Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        :param _builtins.str volume_mode: volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        :param _builtins.str volume_name: VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        if access_modes is not None:
            pulumi.set(__self__, "access_modes", access_modes)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if data_source_ref is not None:
            pulumi.set(__self__, "data_source_ref", data_source_ref)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)
        if volume_mode is not None:
            pulumi.set(__self__, "volume_mode", volume_mode)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @_builtins.property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Optional[Sequence[_builtins.str]]:
        """
        AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional['outputs.LocalKubernetesReferenceResponse']:
        """
        This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        """
        return pulumi.get(self, "data_source")

    @_builtins.property
    @pulumi.getter(name="dataSourceRef")
    def data_source_ref(self) -> Optional['outputs.KubernetesReferenceResponse']:
        """
        Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        """
        return pulumi.get(self, "data_source_ref")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.VolumeClaimResourceRequirementsResponse']:
        """
        Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional['outputs.VolumeClaimSpecSelectorResponse']:
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @_builtins.property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[_builtins.str]:
        """
        Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        """
        return pulumi.get(self, "storage_class_name")

    @_builtins.property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> Optional[_builtins.str]:
        """
        volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        """
        return pulumi.get(self, "volume_mode")

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[_builtins.str]:
        """
        VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class VolumeClaimSpecSelectorMatchExpressionsResponse(dict):
    """
    VolumeClaimSpecSelectorMatchExpressions properties
    """
    def __init__(__self__, *,
                 key: _builtins.str,
                 operator: _builtins.str,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        VolumeClaimSpecSelectorMatchExpressions properties
        :param _builtins.str key: key is the label key that the selector applies to.
        :param _builtins.str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[_builtins.str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class VolumeClaimSpecSelectorResponse(dict):
    """
    VolumeClaimSpecSelector properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeClaimSpecSelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeClaimSpecSelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeClaimSpecSelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.VolumeClaimSpecSelectorMatchExpressionsResponse']] = None,
                 match_labels: Optional[Mapping[str, _builtins.str]] = None):
        """
        VolumeClaimSpecSelector properties
        :param Sequence['VolumeClaimSpecSelectorMatchExpressionsResponse'] match_expressions: MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, _builtins.str] match_labels: MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.VolumeClaimSpecSelectorMatchExpressionsResponse']]:
        """
        MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class X509ManualCertificateResponse(dict):
    """
    X509 Certificate Authentication properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in X509ManualCertificateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        X509ManualCertificateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        X509ManualCertificateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: _builtins.str):
        """
        X509 Certificate Authentication properties.
        :param _builtins.str secret_ref: Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> _builtins.str:
        """
        Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
        return pulumi.get(self, "secret_ref")


