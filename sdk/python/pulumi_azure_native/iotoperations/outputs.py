# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AdvancedSettingsResponse',
    'AuthorizationConfigResponse',
    'AuthorizationRuleResponse',
    'BackendChainResponse',
    'BatchingConfigurationResponse',
    'BrokerAuthenticationPropertiesResponse',
    'BrokerAuthenticatorCustomAuthResponse',
    'BrokerAuthenticatorMethodCustomResponse',
    'BrokerAuthenticatorMethodSatResponse',
    'BrokerAuthenticatorMethodX509AttributesResponse',
    'BrokerAuthenticatorMethodX509Response',
    'BrokerAuthenticatorMethodsResponse',
    'BrokerAuthorizationPropertiesResponse',
    'BrokerDiagnosticsResponse',
    'BrokerListenerPropertiesResponse',
    'BrokerPropertiesResponse',
    'BrokerResourceRuleResponse',
    'CardinalityResponse',
    'CertManagerCertOptionsResponse',
    'CertManagerCertificateSpecResponse',
    'CertManagerIssuerRefResponse',
    'CertManagerPrivateKeyResponse',
    'ClientConfigResponse',
    'DataflowBuiltInTransformationDatasetResponse',
    'DataflowBuiltInTransformationFilterResponse',
    'DataflowBuiltInTransformationMapResponse',
    'DataflowBuiltInTransformationSettingsResponse',
    'DataflowDestinationOperationSettingsResponse',
    'DataflowEndpointAuthenticationAccessTokenResponse',
    'DataflowEndpointAuthenticationSaslResponse',
    'DataflowEndpointAuthenticationServiceAccountTokenResponse',
    'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse',
    'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse',
    'DataflowEndpointAuthenticationX509Response',
    'DataflowEndpointDataExplorerAuthenticationResponse',
    'DataflowEndpointDataExplorerResponse',
    'DataflowEndpointDataLakeStorageAuthenticationResponse',
    'DataflowEndpointDataLakeStorageResponse',
    'DataflowEndpointFabricOneLakeAuthenticationResponse',
    'DataflowEndpointFabricOneLakeNamesResponse',
    'DataflowEndpointFabricOneLakeResponse',
    'DataflowEndpointKafkaAuthenticationResponse',
    'DataflowEndpointKafkaBatchingResponse',
    'DataflowEndpointKafkaResponse',
    'DataflowEndpointLocalStorageResponse',
    'DataflowEndpointMqttAuthenticationResponse',
    'DataflowEndpointMqttResponse',
    'DataflowEndpointPropertiesResponse',
    'DataflowOperationResponse',
    'DataflowProfilePropertiesResponse',
    'DataflowPropertiesResponse',
    'DataflowSourceOperationSettingsResponse',
    'DiagnosticsLogsResponse',
    'DiskBackedMessageBufferResponse',
    'ExtendedLocationResponse',
    'FrontendResponse',
    'GenerateResourceLimitsResponse',
    'InstancePropertiesResponse',
    'KubernetesReferenceResponse',
    'ListenerPortResponse',
    'LocalKubernetesReferenceResponse',
    'ManagedServiceIdentityResponse',
    'MetricsResponse',
    'PrincipalDefinitionResponse',
    'ProfileDiagnosticsResponse',
    'SanForCertResponse',
    'SchemaRegistryRefResponse',
    'SelfCheckResponse',
    'SelfTracingResponse',
    'StateStoreResourceRuleResponse',
    'SubscriberQueueLimitResponse',
    'SystemDataResponse',
    'TlsCertMethodResponse',
    'TlsPropertiesResponse',
    'TracesResponse',
    'UserAssignedIdentityResponse',
    'VolumeClaimResourceRequirementsResponse',
    'VolumeClaimSpecResponse',
    'VolumeClaimSpecSelectorMatchExpressionsResponse',
    'VolumeClaimSpecSelectorResponse',
    'X509ManualCertificateResponse',
]

@pulumi.output_type
class AdvancedSettingsResponse(dict):
    """
    Broker Advanced Settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptInternalTraffic":
            suggest = "encrypt_internal_traffic"
        elif key == "internalCerts":
            suggest = "internal_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clients: Optional['outputs.ClientConfigResponse'] = None,
                 encrypt_internal_traffic: Optional[builtins.str] = None,
                 internal_certs: Optional['outputs.CertManagerCertOptionsResponse'] = None):
        """
        Broker Advanced Settings
        :param 'ClientConfigResponse' clients: Configurations related to All Clients.
        :param builtins.str encrypt_internal_traffic: The setting to enable or disable encryption of internal Traffic.
        :param 'CertManagerCertOptionsResponse' internal_certs: Certificate rotation and private key configuration.
        """
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if encrypt_internal_traffic is None:
            encrypt_internal_traffic = 'Enabled'
        if encrypt_internal_traffic is not None:
            pulumi.set(__self__, "encrypt_internal_traffic", encrypt_internal_traffic)
        if internal_certs is not None:
            pulumi.set(__self__, "internal_certs", internal_certs)

    @property
    @pulumi.getter
    def clients(self) -> Optional['outputs.ClientConfigResponse']:
        """
        Configurations related to All Clients.
        """
        return pulumi.get(self, "clients")

    @property
    @pulumi.getter(name="encryptInternalTraffic")
    def encrypt_internal_traffic(self) -> Optional[builtins.str]:
        """
        The setting to enable or disable encryption of internal Traffic.
        """
        return pulumi.get(self, "encrypt_internal_traffic")

    @property
    @pulumi.getter(name="internalCerts")
    def internal_certs(self) -> Optional['outputs.CertManagerCertOptionsResponse']:
        """
        Certificate rotation and private key configuration.
        """
        return pulumi.get(self, "internal_certs")


@pulumi.output_type
class AuthorizationConfigResponse(dict):
    """
    Broker AuthorizationConfig properties
    """
    def __init__(__self__, *,
                 cache: Optional[builtins.str] = None,
                 rules: Optional[Sequence['outputs.AuthorizationRuleResponse']] = None):
        """
        Broker AuthorizationConfig properties
        :param builtins.str cache: Enable caching of the authorization rules.
        :param Sequence['AuthorizationRuleResponse'] rules: The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        if cache is None:
            cache = 'Enabled'
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def cache(self) -> Optional[builtins.str]:
        """
        Enable caching of the authorization rules.
        """
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AuthorizationRuleResponse']]:
        """
        The authorization rules to follow. If no rule is set, but Authorization Resource is used that would mean DenyAll.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AuthorizationRuleResponse(dict):
    """
    AuthorizationConfig Rule Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brokerResources":
            suggest = "broker_resources"
        elif key == "stateStoreResources":
            suggest = "state_store_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker_resources: Sequence['outputs.BrokerResourceRuleResponse'],
                 principals: 'outputs.PrincipalDefinitionResponse',
                 state_store_resources: Optional[Sequence['outputs.StateStoreResourceRuleResponse']] = None):
        """
        AuthorizationConfig Rule Properties
        :param Sequence['BrokerResourceRuleResponse'] broker_resources: Give access to Broker methods and topics.
        :param 'PrincipalDefinitionResponse' principals: Give access to clients based on the following properties.
        :param Sequence['StateStoreResourceRuleResponse'] state_store_resources: Give access to state store resources.
        """
        pulumi.set(__self__, "broker_resources", broker_resources)
        pulumi.set(__self__, "principals", principals)
        if state_store_resources is not None:
            pulumi.set(__self__, "state_store_resources", state_store_resources)

    @property
    @pulumi.getter(name="brokerResources")
    def broker_resources(self) -> Sequence['outputs.BrokerResourceRuleResponse']:
        """
        Give access to Broker methods and topics.
        """
        return pulumi.get(self, "broker_resources")

    @property
    @pulumi.getter
    def principals(self) -> 'outputs.PrincipalDefinitionResponse':
        """
        Give access to clients based on the following properties.
        """
        return pulumi.get(self, "principals")

    @property
    @pulumi.getter(name="stateStoreResources")
    def state_store_resources(self) -> Optional[Sequence['outputs.StateStoreResourceRuleResponse']]:
        """
        Give access to state store resources.
        """
        return pulumi.get(self, "state_store_resources")


@pulumi.output_type
class BackendChainResponse(dict):
    """
    Desired properties of the backend instances of the broker
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redundancyFactor":
            suggest = "redundancy_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendChainResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendChainResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendChainResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partitions: builtins.int,
                 redundancy_factor: builtins.int,
                 workers: Optional[builtins.int] = None):
        """
        Desired properties of the backend instances of the broker
        :param builtins.int partitions: The desired number of physical backend partitions.
        :param builtins.int redundancy_factor: The desired numbers of backend replicas (pods) in a physical partition.
        :param builtins.int workers: Number of logical backend workers per replica (pod).
        """
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "redundancy_factor", redundancy_factor)
        if workers is None:
            workers = 1
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter
    def partitions(self) -> builtins.int:
        """
        The desired number of physical backend partitions.
        """
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter(name="redundancyFactor")
    def redundancy_factor(self) -> builtins.int:
        """
        The desired numbers of backend replicas (pods) in a physical partition.
        """
        return pulumi.get(self, "redundancy_factor")

    @property
    @pulumi.getter
    def workers(self) -> Optional[builtins.int]:
        """
        Number of logical backend workers per replica (pod).
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class BatchingConfigurationResponse(dict):
    """
    Batching configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latencySeconds":
            suggest = "latency_seconds"
        elif key == "maxMessages":
            suggest = "max_messages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latency_seconds: Optional[builtins.int] = None,
                 max_messages: Optional[builtins.int] = None):
        """
        Batching configuration
        :param builtins.int latency_seconds: Batching latency in seconds.
        :param builtins.int max_messages: Maximum number of messages in a batch.
        """
        if latency_seconds is None:
            latency_seconds = 60
        if latency_seconds is not None:
            pulumi.set(__self__, "latency_seconds", latency_seconds)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)

    @property
    @pulumi.getter(name="latencySeconds")
    def latency_seconds(self) -> Optional[builtins.int]:
        """
        Batching latency in seconds.
        """
        return pulumi.get(self, "latency_seconds")

    @property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[builtins.int]:
        """
        Maximum number of messages in a batch.
        """
        return pulumi.get(self, "max_messages")


@pulumi.output_type
class BrokerAuthenticationPropertiesResponse(dict):
    """
    BrokerAuthentication Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethods":
            suggest = "authentication_methods"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_methods: Sequence['outputs.BrokerAuthenticatorMethodsResponse'],
                 provisioning_state: builtins.str):
        """
        BrokerAuthentication Resource properties
        :param Sequence['BrokerAuthenticatorMethodsResponse'] authentication_methods: Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        :param builtins.str provisioning_state: The status of the last operation.
        """
        pulumi.set(__self__, "authentication_methods", authentication_methods)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="authenticationMethods")
    def authentication_methods(self) -> Sequence['outputs.BrokerAuthenticatorMethodsResponse']:
        """
        Defines a set of Broker authentication methods to be used on `BrokerListeners`. For each array element one authenticator type supported.
        """
        return pulumi.get(self, "authentication_methods")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class BrokerAuthenticatorCustomAuthResponse(dict):
    """
    Custom Authentication properties
    """
    def __init__(__self__, *,
                 x509: 'outputs.X509ManualCertificateResponse'):
        """
        Custom Authentication properties
        :param 'X509ManualCertificateResponse' x509: X509 Custom Auth type details.
        """
        pulumi.set(__self__, "x509", x509)

    @property
    @pulumi.getter
    def x509(self) -> 'outputs.X509ManualCertificateResponse':
        """
        X509 Custom Auth type details.
        """
        return pulumi.get(self, "x509")


@pulumi.output_type
class BrokerAuthenticatorMethodCustomResponse(dict):
    """
    Custom method for BrokerAuthentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertConfigMap":
            suggest = "ca_cert_config_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodCustomResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodCustomResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodCustomResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: builtins.str,
                 auth: Optional['outputs.BrokerAuthenticatorCustomAuthResponse'] = None,
                 ca_cert_config_map: Optional[builtins.str] = None,
                 headers: Optional[Mapping[str, builtins.str]] = None):
        """
        Custom method for BrokerAuthentication
        :param builtins.str endpoint: Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        :param 'BrokerAuthenticatorCustomAuthResponse' auth: Optional authentication needed for authenticating with the custom authentication server.
        :param builtins.str ca_cert_config_map: Optional CA certificate for validating the custom authentication server's certificate.
        :param Mapping[str, builtins.str] headers: Additional HTTP headers to pass to the custom authentication server.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if ca_cert_config_map is not None:
            pulumi.set(__self__, "ca_cert_config_map", ca_cert_config_map)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def endpoint(self) -> builtins.str:
        """
        Endpoint of the custom authentication server. Must be an HTTPS endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.BrokerAuthenticatorCustomAuthResponse']:
        """
        Optional authentication needed for authenticating with the custom authentication server.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="caCertConfigMap")
    def ca_cert_config_map(self) -> Optional[builtins.str]:
        """
        Optional CA certificate for validating the custom authentication server's certificate.
        """
        return pulumi.get(self, "ca_cert_config_map")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Additional HTTP headers to pass to the custom authentication server.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class BrokerAuthenticatorMethodSatResponse(dict):
    """
    Service Account Token for BrokerAuthentication
    """
    def __init__(__self__, *,
                 audiences: Sequence[builtins.str]):
        """
        Service Account Token for BrokerAuthentication
        :param Sequence[builtins.str] audiences: List of allowed audience.
        """
        pulumi.set(__self__, "audiences", audiences)

    @property
    @pulumi.getter
    def audiences(self) -> Sequence[builtins.str]:
        """
        List of allowed audience.
        """
        return pulumi.get(self, "audiences")


@pulumi.output_type
class BrokerAuthenticatorMethodX509AttributesResponse(dict):
    """
    BrokerAuthenticatorMethodX509Attributes properties.
    """
    def __init__(__self__, *,
                 attributes: Mapping[str, builtins.str],
                 subject: builtins.str):
        """
        BrokerAuthenticatorMethodX509Attributes properties.
        :param Mapping[str, builtins.str] attributes: Attributes object.
        :param builtins.str subject: Subject of the X509 attribute.
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def attributes(self) -> Mapping[str, builtins.str]:
        """
        Attributes object.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter
    def subject(self) -> builtins.str:
        """
        Subject of the X509 attribute.
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class BrokerAuthenticatorMethodX509Response(dict):
    """
    X509 for BrokerAuthentication.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationAttributes":
            suggest = "authorization_attributes"
        elif key == "trustedClientCaCert":
            suggest = "trusted_client_ca_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodX509Response. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodX509Response.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodX509Response.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_attributes: Optional[Mapping[str, 'outputs.BrokerAuthenticatorMethodX509AttributesResponse']] = None,
                 trusted_client_ca_cert: Optional[builtins.str] = None):
        """
        X509 for BrokerAuthentication.
        :param Mapping[str, 'BrokerAuthenticatorMethodX509AttributesResponse'] authorization_attributes: X509 authorization attributes properties.
        :param builtins.str trusted_client_ca_cert: Name of the trusted client ca cert resource.
        """
        if authorization_attributes is not None:
            pulumi.set(__self__, "authorization_attributes", authorization_attributes)
        if trusted_client_ca_cert is None:
            trusted_client_ca_cert = 'client-ca'
        if trusted_client_ca_cert is not None:
            pulumi.set(__self__, "trusted_client_ca_cert", trusted_client_ca_cert)

    @property
    @pulumi.getter(name="authorizationAttributes")
    def authorization_attributes(self) -> Optional[Mapping[str, 'outputs.BrokerAuthenticatorMethodX509AttributesResponse']]:
        """
        X509 authorization attributes properties.
        """
        return pulumi.get(self, "authorization_attributes")

    @property
    @pulumi.getter(name="trustedClientCaCert")
    def trusted_client_ca_cert(self) -> Optional[builtins.str]:
        """
        Name of the trusted client ca cert resource.
        """
        return pulumi.get(self, "trusted_client_ca_cert")


@pulumi.output_type
class BrokerAuthenticatorMethodsResponse(dict):
    """
    Set of broker authentication policies. Only one method is supported for each entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customSettings":
            suggest = "custom_settings"
        elif key == "serviceAccountTokenSettings":
            suggest = "service_account_token_settings"
        elif key == "x509Settings":
            suggest = "x509_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthenticatorMethodsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthenticatorMethodsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthenticatorMethodsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: builtins.str,
                 custom_settings: Optional['outputs.BrokerAuthenticatorMethodCustomResponse'] = None,
                 service_account_token_settings: Optional['outputs.BrokerAuthenticatorMethodSatResponse'] = None,
                 x509_settings: Optional['outputs.BrokerAuthenticatorMethodX509Response'] = None):
        """
        Set of broker authentication policies. Only one method is supported for each entry.
        :param builtins.str method: Custom authentication configuration.
        :param 'BrokerAuthenticatorMethodCustomResponse' custom_settings: Custom authentication configuration.
        :param 'BrokerAuthenticatorMethodSatResponse' service_account_token_settings: ServiceAccountToken authentication configuration.
        :param 'BrokerAuthenticatorMethodX509Response' x509_settings: X.509 authentication configuration.
        """
        pulumi.set(__self__, "method", method)
        if custom_settings is not None:
            pulumi.set(__self__, "custom_settings", custom_settings)
        if service_account_token_settings is not None:
            pulumi.set(__self__, "service_account_token_settings", service_account_token_settings)
        if x509_settings is not None:
            pulumi.set(__self__, "x509_settings", x509_settings)

    @property
    @pulumi.getter
    def method(self) -> builtins.str:
        """
        Custom authentication configuration.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="customSettings")
    def custom_settings(self) -> Optional['outputs.BrokerAuthenticatorMethodCustomResponse']:
        """
        Custom authentication configuration.
        """
        return pulumi.get(self, "custom_settings")

    @property
    @pulumi.getter(name="serviceAccountTokenSettings")
    def service_account_token_settings(self) -> Optional['outputs.BrokerAuthenticatorMethodSatResponse']:
        """
        ServiceAccountToken authentication configuration.
        """
        return pulumi.get(self, "service_account_token_settings")

    @property
    @pulumi.getter(name="x509Settings")
    def x509_settings(self) -> Optional['outputs.BrokerAuthenticatorMethodX509Response']:
        """
        X.509 authentication configuration.
        """
        return pulumi.get(self, "x509_settings")


@pulumi.output_type
class BrokerAuthorizationPropertiesResponse(dict):
    """
    BrokerAuthorization Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationPolicies":
            suggest = "authorization_policies"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerAuthorizationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerAuthorizationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerAuthorizationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_policies: 'outputs.AuthorizationConfigResponse',
                 provisioning_state: builtins.str):
        """
        BrokerAuthorization Resource properties
        :param 'AuthorizationConfigResponse' authorization_policies: The list of authorization policies supported by the Authorization Resource.
        :param builtins.str provisioning_state: The status of the last operation.
        """
        pulumi.set(__self__, "authorization_policies", authorization_policies)
        pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="authorizationPolicies")
    def authorization_policies(self) -> 'outputs.AuthorizationConfigResponse':
        """
        The list of authorization policies supported by the Authorization Resource.
        """
        return pulumi.get(self, "authorization_policies")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class BrokerDiagnosticsResponse(dict):
    """
    Broker Diagnostic Setting properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selfCheck":
            suggest = "self_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerDiagnosticsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerDiagnosticsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerDiagnosticsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs: Optional['outputs.DiagnosticsLogsResponse'] = None,
                 metrics: Optional['outputs.MetricsResponse'] = None,
                 self_check: Optional['outputs.SelfCheckResponse'] = None,
                 traces: Optional['outputs.TracesResponse'] = None):
        """
        Broker Diagnostic Setting properties
        :param 'DiagnosticsLogsResponse' logs: Diagnostic log settings for the resource.
        :param 'MetricsResponse' metrics: The metrics settings for the resource.
        :param 'SelfCheckResponse' self_check: The self check properties.
        :param 'TracesResponse' traces: The trace properties.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if self_check is not None:
            pulumi.set(__self__, "self_check", self_check)
        if traces is not None:
            pulumi.set(__self__, "traces", traces)

    @property
    @pulumi.getter
    def logs(self) -> Optional['outputs.DiagnosticsLogsResponse']:
        """
        Diagnostic log settings for the resource.
        """
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.MetricsResponse']:
        """
        The metrics settings for the resource.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="selfCheck")
    def self_check(self) -> Optional['outputs.SelfCheckResponse']:
        """
        The self check properties.
        """
        return pulumi.get(self, "self_check")

    @property
    @pulumi.getter
    def traces(self) -> Optional['outputs.TracesResponse']:
        """
        The trace properties.
        """
        return pulumi.get(self, "traces")


@pulumi.output_type
class BrokerListenerPropertiesResponse(dict):
    """
    Defines a Broker listener. A listener is a collection of ports on which the broker accepts connections from clients.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceType":
            suggest = "service_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerListenerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerListenerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerListenerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ports: Sequence['outputs.ListenerPortResponse'],
                 provisioning_state: builtins.str,
                 service_name: Optional[builtins.str] = None,
                 service_type: Optional[builtins.str] = None):
        """
        Defines a Broker listener. A listener is a collection of ports on which the broker accepts connections from clients.
        :param Sequence['ListenerPortResponse'] ports: Ports on which this listener accepts client connections.
        :param builtins.str provisioning_state: The status of the last operation.
        :param builtins.str service_name: Kubernetes Service name of this listener.
        :param builtins.str service_type: Kubernetes Service type of this listener.
        """
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_type is None:
            service_type = 'ClusterIp'
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.ListenerPortResponse']:
        """
        Ports on which this listener accepts client connections.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        """
        Kubernetes Service name of this listener.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[builtins.str]:
        """
        Kubernetes Service type of this listener.
        """
        return pulumi.get(self, "service_type")


@pulumi.output_type
class BrokerPropertiesResponse(dict):
    """
    Broker Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "diskBackedMessageBuffer":
            suggest = "disk_backed_message_buffer"
        elif key == "generateResourceLimits":
            suggest = "generate_resource_limits"
        elif key == "memoryProfile":
            suggest = "memory_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 advanced: Optional['outputs.AdvancedSettingsResponse'] = None,
                 cardinality: Optional['outputs.CardinalityResponse'] = None,
                 diagnostics: Optional['outputs.BrokerDiagnosticsResponse'] = None,
                 disk_backed_message_buffer: Optional['outputs.DiskBackedMessageBufferResponse'] = None,
                 generate_resource_limits: Optional['outputs.GenerateResourceLimitsResponse'] = None,
                 memory_profile: Optional[builtins.str] = None):
        """
        Broker Resource properties
        :param builtins.str provisioning_state: The status of the last operation.
        :param 'AdvancedSettingsResponse' advanced: Advanced settings of Broker.
        :param 'CardinalityResponse' cardinality: The cardinality details of the broker.
        :param 'BrokerDiagnosticsResponse' diagnostics: Spec defines the desired identities of Broker diagnostics settings.
        :param 'DiskBackedMessageBufferResponse' disk_backed_message_buffer: Settings of Disk Backed Message Buffer.
        :param 'GenerateResourceLimitsResponse' generate_resource_limits: This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        :param builtins.str memory_profile: Memory profile of Broker.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if advanced is not None:
            pulumi.set(__self__, "advanced", advanced)
        if cardinality is not None:
            pulumi.set(__self__, "cardinality", cardinality)
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if disk_backed_message_buffer is not None:
            pulumi.set(__self__, "disk_backed_message_buffer", disk_backed_message_buffer)
        if generate_resource_limits is not None:
            pulumi.set(__self__, "generate_resource_limits", generate_resource_limits)
        if memory_profile is None:
            memory_profile = 'Medium'
        if memory_profile is not None:
            pulumi.set(__self__, "memory_profile", memory_profile)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def advanced(self) -> Optional['outputs.AdvancedSettingsResponse']:
        """
        Advanced settings of Broker.
        """
        return pulumi.get(self, "advanced")

    @property
    @pulumi.getter
    def cardinality(self) -> Optional['outputs.CardinalityResponse']:
        """
        The cardinality details of the broker.
        """
        return pulumi.get(self, "cardinality")

    @property
    @pulumi.getter
    def diagnostics(self) -> Optional['outputs.BrokerDiagnosticsResponse']:
        """
        Spec defines the desired identities of Broker diagnostics settings.
        """
        return pulumi.get(self, "diagnostics")

    @property
    @pulumi.getter(name="diskBackedMessageBuffer")
    def disk_backed_message_buffer(self) -> Optional['outputs.DiskBackedMessageBufferResponse']:
        """
        Settings of Disk Backed Message Buffer.
        """
        return pulumi.get(self, "disk_backed_message_buffer")

    @property
    @pulumi.getter(name="generateResourceLimits")
    def generate_resource_limits(self) -> Optional['outputs.GenerateResourceLimitsResponse']:
        """
        This setting controls whether Kubernetes CPU resource limits are requested. Increasing the number of replicas or workers proportionally increases the amount of CPU resources requested. If this setting is enabled and there are insufficient CPU resources, an error will be emitted.
        """
        return pulumi.get(self, "generate_resource_limits")

    @property
    @pulumi.getter(name="memoryProfile")
    def memory_profile(self) -> Optional[builtins.str]:
        """
        Memory profile of Broker.
        """
        return pulumi.get(self, "memory_profile")


@pulumi.output_type
class BrokerResourceRuleResponse(dict):
    """
    Broker Resource Rule properties. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIds":
            suggest = "client_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerResourceRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerResourceRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerResourceRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: builtins.str,
                 client_ids: Optional[Sequence[builtins.str]] = None,
                 topics: Optional[Sequence[builtins.str]] = None):
        """
        Broker Resource Rule properties. This defines the objects that represent the actions or topics, such as - method.Connect, method.Publish, etc.
        :param builtins.str method: Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        :param Sequence[builtins.str] client_ids: A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection. This subfield may be set if the method is Connect.
        :param Sequence[builtins.str] topics: A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        pulumi.set(__self__, "method", method)
        if client_ids is not None:
            pulumi.set(__self__, "client_ids", client_ids)
        if topics is not None:
            pulumi.set(__self__, "topics", topics)

    @property
    @pulumi.getter
    def method(self) -> builtins.str:
        """
        Give access for a Broker method (i.e., Connect, Subscribe, or Publish).
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection. This subfield may be set if the method is Connect.
        """
        return pulumi.get(self, "client_ids")

    @property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of topics or topic patterns that match the topics that the clients can publish or subscribe to. This subfield is required if the method is Publish or Subscribe.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class CardinalityResponse(dict):
    """
    Cardinality properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendChain":
            suggest = "backend_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CardinalityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CardinalityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CardinalityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_chain: 'outputs.BackendChainResponse',
                 frontend: 'outputs.FrontendResponse'):
        """
        Cardinality properties
        :param 'BackendChainResponse' backend_chain: The backend broker desired properties
        :param 'FrontendResponse' frontend: The frontend desired properties
        """
        pulumi.set(__self__, "backend_chain", backend_chain)
        pulumi.set(__self__, "frontend", frontend)

    @property
    @pulumi.getter(name="backendChain")
    def backend_chain(self) -> 'outputs.BackendChainResponse':
        """
        The backend broker desired properties
        """
        return pulumi.get(self, "backend_chain")

    @property
    @pulumi.getter
    def frontend(self) -> 'outputs.FrontendResponse':
        """
        The frontend desired properties
        """
        return pulumi.get(self, "frontend")


@pulumi.output_type
class CertManagerCertOptionsResponse(dict):
    """
    Cert Manager Cert properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "renewBefore":
            suggest = "renew_before"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertManagerCertOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertManagerCertOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertManagerCertOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: builtins.str,
                 private_key: 'outputs.CertManagerPrivateKeyResponse',
                 renew_before: builtins.str):
        """
        Cert Manager Cert properties
        :param builtins.str duration: Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param 'CertManagerPrivateKeyResponse' private_key: Configuration of certificate private key.
        :param builtins.str renew_before: When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "renew_before", renew_before)

    @property
    @pulumi.getter
    def duration(self) -> builtins.str:
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> 'outputs.CertManagerPrivateKeyResponse':
        """
        Configuration of certificate private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> builtins.str:
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "renew_before")


@pulumi.output_type
class CertManagerCertificateSpecResponse(dict):
    """
    Automatic TLS server certificate management with cert-manager
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuerRef":
            suggest = "issuer_ref"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "renewBefore":
            suggest = "renew_before"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertManagerCertificateSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertManagerCertificateSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertManagerCertificateSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issuer_ref: 'outputs.CertManagerIssuerRefResponse',
                 duration: Optional[builtins.str] = None,
                 private_key: Optional['outputs.CertManagerPrivateKeyResponse'] = None,
                 renew_before: Optional[builtins.str] = None,
                 san: Optional['outputs.SanForCertResponse'] = None,
                 secret_name: Optional[builtins.str] = None):
        """
        Automatic TLS server certificate management with cert-manager
        :param 'CertManagerIssuerRefResponse' issuer_ref: cert-manager issuerRef.
        :param builtins.str duration: Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param 'CertManagerPrivateKeyResponse' private_key: Type of certificate private key.
        :param builtins.str renew_before: When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        :param 'SanForCertResponse' san: Additional Subject Alternative Names (SANs) to include in the certificate.
        :param builtins.str secret_name: Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
        pulumi.set(__self__, "issuer_ref", issuer_ref)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if renew_before is not None:
            pulumi.set(__self__, "renew_before", renew_before)
        if san is not None:
            pulumi.set(__self__, "san", san)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> 'outputs.CertManagerIssuerRefResponse':
        """
        cert-manager issuerRef.
        """
        return pulumi.get(self, "issuer_ref")

    @property
    @pulumi.getter
    def duration(self) -> Optional[builtins.str]:
        """
        Lifetime of certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional['outputs.CertManagerPrivateKeyResponse']:
        """
        Type of certificate private key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="renewBefore")
    def renew_before(self) -> Optional[builtins.str]:
        """
        When to begin renewing certificate. Must be specified using a Go time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes.
        """
        return pulumi.get(self, "renew_before")

    @property
    @pulumi.getter
    def san(self) -> Optional['outputs.SanForCertResponse']:
        """
        Additional Subject Alternative Names (SANs) to include in the certificate.
        """
        return pulumi.get(self, "san")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[builtins.str]:
        """
        Secret for storing server certificate. Any existing data will be overwritten. This is a reference to the secret through an identifying name, not the secret itself.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class CertManagerIssuerRefResponse(dict):
    """
    Cert-Manager issuerRef properties
    """
    def __init__(__self__, *,
                 group: Optional[builtins.str] = None,
                 kind: builtins.str,
                 name: builtins.str):
        """
        Cert-Manager issuerRef properties
        :param builtins.str group: group of issuer.
        :param builtins.str kind: kind of issuer (Issuer or ClusterIssuer).
        :param builtins.str name: name of issuer.
        """
        if group is None:
            group = 'cert-manager.io'
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> builtins.str:
        """
        group of issuer.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        kind of issuer (Issuer or ClusterIssuer).
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        name of issuer.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CertManagerPrivateKeyResponse(dict):
    """
    Cert Manager private key properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rotationPolicy":
            suggest = "rotation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertManagerPrivateKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertManagerPrivateKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertManagerPrivateKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: builtins.str,
                 rotation_policy: builtins.str):
        """
        Cert Manager private key properties
        :param builtins.str algorithm: algorithm for private key.
        :param builtins.str rotation_policy: cert-manager private key rotationPolicy.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "rotation_policy", rotation_policy)

    @property
    @pulumi.getter
    def algorithm(self) -> builtins.str:
        """
        algorithm for private key.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="rotationPolicy")
    def rotation_policy(self) -> builtins.str:
        """
        cert-manager private key rotationPolicy.
        """
        return pulumi.get(self, "rotation_policy")


@pulumi.output_type
class ClientConfigResponse(dict):
    """
    The settings of Client Config.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxKeepAliveSeconds":
            suggest = "max_keep_alive_seconds"
        elif key == "maxMessageExpirySeconds":
            suggest = "max_message_expiry_seconds"
        elif key == "maxPacketSizeBytes":
            suggest = "max_packet_size_bytes"
        elif key == "maxReceiveMaximum":
            suggest = "max_receive_maximum"
        elif key == "maxSessionExpirySeconds":
            suggest = "max_session_expiry_seconds"
        elif key == "subscriberQueueLimit":
            suggest = "subscriber_queue_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_keep_alive_seconds: Optional[builtins.int] = None,
                 max_message_expiry_seconds: Optional[builtins.int] = None,
                 max_packet_size_bytes: Optional[builtins.int] = None,
                 max_receive_maximum: Optional[builtins.int] = None,
                 max_session_expiry_seconds: Optional[builtins.int] = None,
                 subscriber_queue_limit: Optional['outputs.SubscriberQueueLimitResponse'] = None):
        """
        The settings of Client Config.
        :param builtins.int max_keep_alive_seconds: Upper bound of a client's Keep Alive, in seconds.
        :param builtins.int max_message_expiry_seconds: Upper bound of Message Expiry Interval, in seconds.
        :param builtins.int max_packet_size_bytes: Max message size for a packet in Bytes.
        :param builtins.int max_receive_maximum: Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        :param builtins.int max_session_expiry_seconds: Upper bound of Session Expiry Interval, in seconds.
        :param 'SubscriberQueueLimitResponse' subscriber_queue_limit: The limit on the number of queued messages for a subscriber.
        """
        if max_keep_alive_seconds is not None:
            pulumi.set(__self__, "max_keep_alive_seconds", max_keep_alive_seconds)
        if max_message_expiry_seconds is not None:
            pulumi.set(__self__, "max_message_expiry_seconds", max_message_expiry_seconds)
        if max_packet_size_bytes is not None:
            pulumi.set(__self__, "max_packet_size_bytes", max_packet_size_bytes)
        if max_receive_maximum is not None:
            pulumi.set(__self__, "max_receive_maximum", max_receive_maximum)
        if max_session_expiry_seconds is not None:
            pulumi.set(__self__, "max_session_expiry_seconds", max_session_expiry_seconds)
        if subscriber_queue_limit is not None:
            pulumi.set(__self__, "subscriber_queue_limit", subscriber_queue_limit)

    @property
    @pulumi.getter(name="maxKeepAliveSeconds")
    def max_keep_alive_seconds(self) -> Optional[builtins.int]:
        """
        Upper bound of a client's Keep Alive, in seconds.
        """
        return pulumi.get(self, "max_keep_alive_seconds")

    @property
    @pulumi.getter(name="maxMessageExpirySeconds")
    def max_message_expiry_seconds(self) -> Optional[builtins.int]:
        """
        Upper bound of Message Expiry Interval, in seconds.
        """
        return pulumi.get(self, "max_message_expiry_seconds")

    @property
    @pulumi.getter(name="maxPacketSizeBytes")
    def max_packet_size_bytes(self) -> Optional[builtins.int]:
        """
        Max message size for a packet in Bytes.
        """
        return pulumi.get(self, "max_packet_size_bytes")

    @property
    @pulumi.getter(name="maxReceiveMaximum")
    def max_receive_maximum(self) -> Optional[builtins.int]:
        """
        Upper bound of Receive Maximum that a client can request in the CONNECT packet.
        """
        return pulumi.get(self, "max_receive_maximum")

    @property
    @pulumi.getter(name="maxSessionExpirySeconds")
    def max_session_expiry_seconds(self) -> Optional[builtins.int]:
        """
        Upper bound of Session Expiry Interval, in seconds.
        """
        return pulumi.get(self, "max_session_expiry_seconds")

    @property
    @pulumi.getter(name="subscriberQueueLimit")
    def subscriber_queue_limit(self) -> Optional['outputs.SubscriberQueueLimitResponse']:
        """
        The limit on the number of queued messages for a subscriber.
        """
        return pulumi.get(self, "subscriber_queue_limit")


@pulumi.output_type
class DataflowBuiltInTransformationDatasetResponse(dict):
    """
    Dataflow BuiltIn Transformation dataset properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRef":
            suggest = "schema_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowBuiltInTransformationDatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowBuiltInTransformationDatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowBuiltInTransformationDatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inputs: Sequence[builtins.str],
                 key: builtins.str,
                 description: Optional[builtins.str] = None,
                 expression: Optional[builtins.str] = None,
                 schema_ref: Optional[builtins.str] = None):
        """
        Dataflow BuiltIn Transformation dataset properties
        :param Sequence[builtins.str] inputs: List of fields for enriching from the Broker State Store.
        :param builtins.str key: The key of the dataset.
        :param builtins.str description: A user provided optional description of the dataset.
        :param builtins.str expression: Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        :param builtins.str schema_ref: The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "key", key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)

    @property
    @pulumi.getter
    def inputs(self) -> Sequence[builtins.str]:
        """
        List of fields for enriching from the Broker State Store.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        The key of the dataset.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A user provided optional description of the dataset.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Condition to enrich data from Broker State Store. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[builtins.str]:
        """
        The reference to the schema that describes the dataset. Allowed: JSON Schema/draft-7.
        """
        return pulumi.get(self, "schema_ref")


@pulumi.output_type
class DataflowBuiltInTransformationFilterResponse(dict):
    """
    Dataflow BuiltIn Transformation filter properties
    """
    def __init__(__self__, *,
                 expression: builtins.str,
                 inputs: Sequence[builtins.str],
                 description: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Dataflow BuiltIn Transformation filter properties
        :param builtins.str expression: Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        :param Sequence[builtins.str] inputs: List of fields for filtering in JSON path expression.
        :param builtins.str description: A user provided optional description of the filter.
        :param builtins.str type: The type of dataflow operation.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "inputs", inputs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is None:
            type = 'Filter'
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        Condition to filter data. Can reference input fields with {n} where n is the index of the input field starting from 1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1 and $2 are provided)
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def inputs(self) -> Sequence[builtins.str]:
        """
        List of fields for filtering in JSON path expression.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A user provided optional description of the filter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The type of dataflow operation.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataflowBuiltInTransformationMapResponse(dict):
    """
    Dataflow BuiltIn Transformation map properties
    """
    def __init__(__self__, *,
                 inputs: Sequence[builtins.str],
                 output: builtins.str,
                 description: Optional[builtins.str] = None,
                 expression: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Dataflow BuiltIn Transformation map properties
        :param Sequence[builtins.str] inputs: List of fields for mapping in JSON path expression.
        :param builtins.str output: Where and how the input fields to be organized in the output record.
        :param builtins.str description: A user provided optional description of the mapping function.
        :param builtins.str expression: Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        :param builtins.str type: Type of transformation.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "output", output)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def inputs(self) -> Sequence[builtins.str]:
        """
        List of fields for mapping in JSON path expression.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter
    def output(self) -> builtins.str:
        """
        Where and how the input fields to be organized in the output record.
        """
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A user provided optional description of the mapping function.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> Optional[builtins.str]:
        """
        Modify the inputs field(s) to the final output field. Example: $1 * 2.2 (Assuming inputs section $1 is provided)
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of transformation.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataflowBuiltInTransformationSettingsResponse(dict):
    """
    Dataflow BuiltIn Transformation properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRef":
            suggest = "schema_ref"
        elif key == "serializationFormat":
            suggest = "serialization_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowBuiltInTransformationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowBuiltInTransformationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowBuiltInTransformationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datasets: Optional[Sequence['outputs.DataflowBuiltInTransformationDatasetResponse']] = None,
                 filter: Optional[Sequence['outputs.DataflowBuiltInTransformationFilterResponse']] = None,
                 map: Optional[Sequence['outputs.DataflowBuiltInTransformationMapResponse']] = None,
                 schema_ref: Optional[builtins.str] = None,
                 serialization_format: Optional[builtins.str] = None):
        """
        Dataflow BuiltIn Transformation properties
        :param Sequence['DataflowBuiltInTransformationDatasetResponse'] datasets: Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        :param Sequence['DataflowBuiltInTransformationFilterResponse'] filter: Filters input record or datapoints based on condition.
        :param Sequence['DataflowBuiltInTransformationMapResponse'] map: Maps input to output message.
        :param builtins.str schema_ref: Reference to the schema that describes the output of the transformation.
        :param builtins.str serialization_format: Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
        if datasets is not None:
            pulumi.set(__self__, "datasets", datasets)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if map is not None:
            pulumi.set(__self__, "map", map)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is None:
            serialization_format = 'Json'
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @property
    @pulumi.getter
    def datasets(self) -> Optional[Sequence['outputs.DataflowBuiltInTransformationDatasetResponse']]:
        """
        Enrich data from Broker State Store. Dataset references a key in Broker State Store.
        """
        return pulumi.get(self, "datasets")

    @property
    @pulumi.getter
    def filter(self) -> Optional[Sequence['outputs.DataflowBuiltInTransformationFilterResponse']]:
        """
        Filters input record or datapoints based on condition.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def map(self) -> Optional[Sequence['outputs.DataflowBuiltInTransformationMapResponse']]:
        """
        Maps input to output message.
        """
        return pulumi.get(self, "map")

    @property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[builtins.str]:
        """
        Reference to the schema that describes the output of the transformation.
        """
        return pulumi.get(self, "schema_ref")

    @property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[builtins.str]:
        """
        Serialization format. Optional; defaults to JSON. Allowed value JSON Schema/draft-7, Parquet. Default: Json
        """
        return pulumi.get(self, "serialization_format")


@pulumi.output_type
class DataflowDestinationOperationSettingsResponse(dict):
    """
    Dataflow Destination Operation properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDestination":
            suggest = "data_destination"
        elif key == "endpointRef":
            suggest = "endpoint_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowDestinationOperationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowDestinationOperationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowDestinationOperationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_destination: builtins.str,
                 endpoint_ref: builtins.str):
        """
        Dataflow Destination Operation properties
        :param builtins.str data_destination: Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        :param builtins.str endpoint_ref: Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
        pulumi.set(__self__, "data_destination", data_destination)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)

    @property
    @pulumi.getter(name="dataDestination")
    def data_destination(self) -> builtins.str:
        """
        Destination location, can be a topic or table name. Supports dynamic values with $topic, $systemProperties, $userProperties, $payload, $context, and $subscription.
        """
        return pulumi.get(self, "data_destination")

    @property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> builtins.str:
        """
        Reference to the Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
        """
        return pulumi.get(self, "endpoint_ref")


@pulumi.output_type
class DataflowEndpointAuthenticationAccessTokenResponse(dict):
    """
    DataflowEndpoint Authentication Access Token properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointAuthenticationAccessTokenResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointAuthenticationAccessTokenResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointAuthenticationAccessTokenResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: builtins.str):
        """
        DataflowEndpoint Authentication Access Token properties
        :param builtins.str secret_ref: Token secret name.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> builtins.str:
        """
        Token secret name.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class DataflowEndpointAuthenticationSaslResponse(dict):
    """
    DataflowEndpoint Authentication Sasl properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "saslType":
            suggest = "sasl_type"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointAuthenticationSaslResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointAuthenticationSaslResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointAuthenticationSaslResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sasl_type: builtins.str,
                 secret_ref: builtins.str):
        """
        DataflowEndpoint Authentication Sasl properties
        :param builtins.str sasl_type: Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        :param builtins.str secret_ref: Token secret name.
        """
        pulumi.set(__self__, "sasl_type", sasl_type)
        pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="saslType")
    def sasl_type(self) -> builtins.str:
        """
        Type of SASL authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
        """
        return pulumi.get(self, "sasl_type")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> builtins.str:
        """
        Token secret name.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class DataflowEndpointAuthenticationServiceAccountTokenResponse(dict):
    """
    Service Account Token for BrokerAuthentication
    """
    def __init__(__self__, *,
                 audience: builtins.str):
        """
        Service Account Token for BrokerAuthentication
        :param builtins.str audience: Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
        pulumi.set(__self__, "audience", audience)

    @property
    @pulumi.getter
    def audience(self) -> builtins.str:
        """
        Audience of the service account. Optional, defaults to the broker internal service account audience.
        """
        return pulumi.get(self, "audience")


@pulumi.output_type
class DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse(dict):
    """
    DataflowEndpoint Authentication SystemAssignedManagedIdentity properties
    """
    def __init__(__self__, *,
                 audience: Optional[builtins.str] = None):
        """
        DataflowEndpoint Authentication SystemAssignedManagedIdentity properties
        :param builtins.str audience: Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)

    @property
    @pulumi.getter
    def audience(self) -> Optional[builtins.str]:
        """
        Audience of the service to authenticate against. Optional; defaults to the audience for Service host configuration.
        """
        return pulumi.get(self, "audience")


@pulumi.output_type
class DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse(dict):
    """
    DataflowEndpoint Authentication UserAssignedManagedIdentity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 tenant_id: builtins.str,
                 scope: Optional[builtins.str] = None):
        """
        DataflowEndpoint Authentication UserAssignedManagedIdentity properties
        :param builtins.str client_id: Client ID for the user-assigned managed identity.
        :param builtins.str tenant_id: Tenant ID.
        :param builtins.str scope: Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        Client ID for the user-assigned managed identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def scope(self) -> Optional[builtins.str]:
        """
        Resource identifier (application ID URI) of the resource, affixed with the .default suffix.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class DataflowEndpointAuthenticationX509Response(dict):
    """
    DataflowEndpoint Authentication X509 properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointAuthenticationX509Response. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointAuthenticationX509Response.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointAuthenticationX509Response.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: builtins.str):
        """
        DataflowEndpoint Authentication X509 properties
        :param builtins.str secret_ref: Secret reference of the X.509 certificate.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> builtins.str:
        """
        Secret reference of the X.509 certificate.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class DataflowEndpointDataExplorerAuthenticationResponse(dict):
    """
    Azure Data Explorer Authentication properties. NOTE - only authentication property is allowed per entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointDataExplorerAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointDataExplorerAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointDataExplorerAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Any,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None):
        """
        Azure Data Explorer Authentication properties. NOTE - only authentication property is allowed per entry.
        :param Any method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        """
        pulumi.set(__self__, "method", method)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @property
    @pulumi.getter
    def method(self) -> Any:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")


@pulumi.output_type
class DataflowEndpointDataExplorerResponse(dict):
    """
    Azure Data Explorer endpoint properties
    """
    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointDataExplorerAuthenticationResponse',
                 database: builtins.str,
                 host: builtins.str,
                 batching: Optional['outputs.BatchingConfigurationResponse'] = None):
        """
        Azure Data Explorer endpoint properties
        :param 'DataflowEndpointDataExplorerAuthenticationResponse' authentication: Authentication configuration. NOTE - only authentication property is allowed per entry.
        :param builtins.str database: Database name.
        :param builtins.str host: Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        :param 'BatchingConfigurationResponse' batching: Azure Data Explorer endpoint batching configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointDataExplorerAuthenticationResponse':
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def database(self) -> builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        Host of the Azure Data Explorer in the form of <cluster>.<region>.kusto.windows.net .
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def batching(self) -> Optional['outputs.BatchingConfigurationResponse']:
        """
        Azure Data Explorer endpoint batching configuration.
        """
        return pulumi.get(self, "batching")


@pulumi.output_type
class DataflowEndpointDataLakeStorageAuthenticationResponse(dict):
    """
    Azure Data Lake endpoint Authentication properties.  NOTE Enum - Only one method is supported for one entry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTokenSettings":
            suggest = "access_token_settings"
        elif key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointDataLakeStorageAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointDataLakeStorageAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointDataLakeStorageAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: builtins.str,
                 access_token_settings: Optional['outputs.DataflowEndpointAuthenticationAccessTokenResponse'] = None,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None):
        """
        Azure Data Lake endpoint Authentication properties.  NOTE Enum - Only one method is supported for one entry
        :param builtins.str method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationAccessTokenResponse' access_token_settings: SAS token authentication.
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        """
        pulumi.set(__self__, "method", method)
        if access_token_settings is not None:
            pulumi.set(__self__, "access_token_settings", access_token_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @property
    @pulumi.getter
    def method(self) -> builtins.str:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="accessTokenSettings")
    def access_token_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationAccessTokenResponse']:
        """
        SAS token authentication.
        """
        return pulumi.get(self, "access_token_settings")

    @property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")


@pulumi.output_type
class DataflowEndpointDataLakeStorageResponse(dict):
    """
    Azure Data Lake endpoint properties
    """
    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointDataLakeStorageAuthenticationResponse',
                 host: builtins.str,
                 batching: Optional['outputs.BatchingConfigurationResponse'] = None):
        """
        Azure Data Lake endpoint properties
        :param 'DataflowEndpointDataLakeStorageAuthenticationResponse' authentication: Authentication configuration. NOTE - only authentication property is allowed per entry.
        :param builtins.str host: Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        :param 'BatchingConfigurationResponse' batching: Azure Data Lake endpoint batching configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointDataLakeStorageAuthenticationResponse':
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        Host of the Azure Data Lake in the form of <account>.blob.core.windows.net .
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def batching(self) -> Optional['outputs.BatchingConfigurationResponse']:
        """
        Azure Data Lake endpoint batching configuration.
        """
        return pulumi.get(self, "batching")


@pulumi.output_type
class DataflowEndpointFabricOneLakeAuthenticationResponse(dict):
    """
    Microsoft Fabric endpoint. Authentication properties. NOTE - Only one method is supported for one entry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointFabricOneLakeAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointFabricOneLakeAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointFabricOneLakeAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Any,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None):
        """
        Microsoft Fabric endpoint. Authentication properties. NOTE - Only one method is supported for one entry
        :param Any method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        """
        pulumi.set(__self__, "method", method)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)

    @property
    @pulumi.getter
    def method(self) -> Any:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")


@pulumi.output_type
class DataflowEndpointFabricOneLakeNamesResponse(dict):
    """
    Microsoft Fabric endpoint Names properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lakehouseName":
            suggest = "lakehouse_name"
        elif key == "workspaceName":
            suggest = "workspace_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointFabricOneLakeNamesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointFabricOneLakeNamesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointFabricOneLakeNamesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lakehouse_name: builtins.str,
                 workspace_name: builtins.str):
        """
        Microsoft Fabric endpoint Names properties
        :param builtins.str lakehouse_name: Lakehouse name.
        :param builtins.str workspace_name: Workspace name.
        """
        pulumi.set(__self__, "lakehouse_name", lakehouse_name)
        pulumi.set(__self__, "workspace_name", workspace_name)

    @property
    @pulumi.getter(name="lakehouseName")
    def lakehouse_name(self) -> builtins.str:
        """
        Lakehouse name.
        """
        return pulumi.get(self, "lakehouse_name")

    @property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> builtins.str:
        """
        Workspace name.
        """
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class DataflowEndpointFabricOneLakeResponse(dict):
    """
    Microsoft Fabric endpoint properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oneLakePathType":
            suggest = "one_lake_path_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointFabricOneLakeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointFabricOneLakeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointFabricOneLakeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointFabricOneLakeAuthenticationResponse',
                 host: builtins.str,
                 names: 'outputs.DataflowEndpointFabricOneLakeNamesResponse',
                 one_lake_path_type: builtins.str,
                 batching: Optional['outputs.BatchingConfigurationResponse'] = None):
        """
        Microsoft Fabric endpoint properties
        :param 'DataflowEndpointFabricOneLakeAuthenticationResponse' authentication: Authentication configuration. NOTE - only one authentication property is allowed per entry.
        :param builtins.str host: Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        :param 'DataflowEndpointFabricOneLakeNamesResponse' names: Names of the workspace and lakehouse.
        :param builtins.str one_lake_path_type: Type of location of the data in the workspace. Can be either tables or files.
        :param 'BatchingConfigurationResponse' batching: Batching configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "one_lake_path_type", one_lake_path_type)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointFabricOneLakeAuthenticationResponse':
        """
        Authentication configuration. NOTE - only one authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        Host of the Microsoft Fabric in the form of https://<host>.fabric.microsoft.com.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def names(self) -> 'outputs.DataflowEndpointFabricOneLakeNamesResponse':
        """
        Names of the workspace and lakehouse.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter(name="oneLakePathType")
    def one_lake_path_type(self) -> builtins.str:
        """
        Type of location of the data in the workspace. Can be either tables or files.
        """
        return pulumi.get(self, "one_lake_path_type")

    @property
    @pulumi.getter
    def batching(self) -> Optional['outputs.BatchingConfigurationResponse']:
        """
        Batching configuration.
        """
        return pulumi.get(self, "batching")


@pulumi.output_type
class DataflowEndpointKafkaAuthenticationResponse(dict):
    """
    Kafka endpoint Authentication properties. NOTE - only authentication property is allowed per entry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "saslSettings":
            suggest = "sasl_settings"
        elif key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"
        elif key == "x509CertificateSettings":
            suggest = "x509_certificate_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointKafkaAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointKafkaAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointKafkaAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: builtins.str,
                 sasl_settings: Optional['outputs.DataflowEndpointAuthenticationSaslResponse'] = None,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None,
                 x509_certificate_settings: Optional['outputs.DataflowEndpointAuthenticationX509Response'] = None):
        """
        Kafka endpoint Authentication properties. NOTE - only authentication property is allowed per entry
        :param builtins.str method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationSaslResponse' sasl_settings: SASL authentication.
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationX509Response' x509_certificate_settings: X.509 certificate authentication.
        """
        pulumi.set(__self__, "method", method)
        if sasl_settings is not None:
            pulumi.set(__self__, "sasl_settings", sasl_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)
        if x509_certificate_settings is not None:
            pulumi.set(__self__, "x509_certificate_settings", x509_certificate_settings)

    @property
    @pulumi.getter
    def method(self) -> builtins.str:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="saslSettings")
    def sasl_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSaslResponse']:
        """
        SASL authentication.
        """
        return pulumi.get(self, "sasl_settings")

    @property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @property
    @pulumi.getter(name="x509CertificateSettings")
    def x509_certificate_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationX509Response']:
        """
        X.509 certificate authentication.
        """
        return pulumi.get(self, "x509_certificate_settings")


@pulumi.output_type
class DataflowEndpointKafkaBatchingResponse(dict):
    """
    Kafka endpoint Batching properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latencyMs":
            suggest = "latency_ms"
        elif key == "maxBytes":
            suggest = "max_bytes"
        elif key == "maxMessages":
            suggest = "max_messages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointKafkaBatchingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointKafkaBatchingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointKafkaBatchingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 latency_ms: Optional[builtins.int] = None,
                 max_bytes: Optional[builtins.int] = None,
                 max_messages: Optional[builtins.int] = None,
                 mode: Optional[builtins.str] = None):
        """
        Kafka endpoint Batching properties
        :param builtins.int latency_ms: Batching latency in milliseconds.
        :param builtins.int max_bytes: Maximum number of bytes in a batch.
        :param builtins.int max_messages: Maximum number of messages in a batch.
        :param builtins.str mode: Mode for batching.
        """
        if latency_ms is None:
            latency_ms = 5
        if latency_ms is not None:
            pulumi.set(__self__, "latency_ms", latency_ms)
        if max_bytes is None:
            max_bytes = 1000000
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_messages is None:
            max_messages = 100000
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="latencyMs")
    def latency_ms(self) -> Optional[builtins.int]:
        """
        Batching latency in milliseconds.
        """
        return pulumi.get(self, "latency_ms")

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[builtins.int]:
        """
        Maximum number of bytes in a batch.
        """
        return pulumi.get(self, "max_bytes")

    @property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[builtins.int]:
        """
        Maximum number of messages in a batch.
        """
        return pulumi.get(self, "max_messages")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Mode for batching.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DataflowEndpointKafkaResponse(dict):
    """
    Kafka endpoint properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudEventAttributes":
            suggest = "cloud_event_attributes"
        elif key == "consumerGroupId":
            suggest = "consumer_group_id"
        elif key == "copyMqttProperties":
            suggest = "copy_mqtt_properties"
        elif key == "kafkaAcks":
            suggest = "kafka_acks"
        elif key == "partitionStrategy":
            suggest = "partition_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointKafkaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointKafkaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointKafkaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointKafkaAuthenticationResponse',
                 host: builtins.str,
                 batching: Optional['outputs.DataflowEndpointKafkaBatchingResponse'] = None,
                 cloud_event_attributes: Optional[builtins.str] = None,
                 compression: Optional[builtins.str] = None,
                 consumer_group_id: Optional[builtins.str] = None,
                 copy_mqtt_properties: Optional[builtins.str] = None,
                 kafka_acks: Optional[builtins.str] = None,
                 partition_strategy: Optional[builtins.str] = None,
                 tls: Optional['outputs.TlsPropertiesResponse'] = None):
        """
        Kafka endpoint properties
        :param 'DataflowEndpointKafkaAuthenticationResponse' authentication: Authentication configuration. NOTE - only authentication property is allowed per entry.
        :param builtins.str host: Kafka endpoint host.
        :param 'DataflowEndpointKafkaBatchingResponse' batching: Batching configuration.
        :param builtins.str cloud_event_attributes: Cloud event mapping config.
        :param builtins.str compression: Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        :param builtins.str consumer_group_id: Consumer group ID.
        :param builtins.str copy_mqtt_properties: Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        :param builtins.str kafka_acks: Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        :param builtins.str partition_strategy: Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        :param 'TlsPropertiesResponse' tls: TLS configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "host", host)
        if batching is not None:
            pulumi.set(__self__, "batching", batching)
        if cloud_event_attributes is not None:
            pulumi.set(__self__, "cloud_event_attributes", cloud_event_attributes)
        if compression is None:
            compression = 'None'
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if copy_mqtt_properties is None:
            copy_mqtt_properties = 'Enabled'
        if copy_mqtt_properties is not None:
            pulumi.set(__self__, "copy_mqtt_properties", copy_mqtt_properties)
        if kafka_acks is None:
            kafka_acks = 'All'
        if kafka_acks is not None:
            pulumi.set(__self__, "kafka_acks", kafka_acks)
        if partition_strategy is None:
            partition_strategy = 'Default'
        if partition_strategy is not None:
            pulumi.set(__self__, "partition_strategy", partition_strategy)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointKafkaAuthenticationResponse':
        """
        Authentication configuration. NOTE - only authentication property is allowed per entry.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        Kafka endpoint host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def batching(self) -> Optional['outputs.DataflowEndpointKafkaBatchingResponse']:
        """
        Batching configuration.
        """
        return pulumi.get(self, "batching")

    @property
    @pulumi.getter(name="cloudEventAttributes")
    def cloud_event_attributes(self) -> Optional[builtins.str]:
        """
        Cloud event mapping config.
        """
        return pulumi.get(self, "cloud_event_attributes")

    @property
    @pulumi.getter
    def compression(self) -> Optional[builtins.str]:
        """
        Compression. Can be none, gzip, lz4, or snappy. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[builtins.str]:
        """
        Consumer group ID.
        """
        return pulumi.get(self, "consumer_group_id")

    @property
    @pulumi.getter(name="copyMqttProperties")
    def copy_mqtt_properties(self) -> Optional[builtins.str]:
        """
        Copy Broker properties. No effect if the endpoint is used as a source or if the dataflow doesn't have an Broker source.
        """
        return pulumi.get(self, "copy_mqtt_properties")

    @property
    @pulumi.getter(name="kafkaAcks")
    def kafka_acks(self) -> Optional[builtins.str]:
        """
        Kafka acks. Can be all, one, or zero. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "kafka_acks")

    @property
    @pulumi.getter(name="partitionStrategy")
    def partition_strategy(self) -> Optional[builtins.str]:
        """
        Partition handling strategy. Can be default or static. No effect if the endpoint is used as a source.
        """
        return pulumi.get(self, "partition_strategy")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.TlsPropertiesResponse']:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DataflowEndpointLocalStorageResponse(dict):
    """
    Local persistent volume endpoint properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "persistentVolumeClaimRef":
            suggest = "persistent_volume_claim_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointLocalStorageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointLocalStorageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointLocalStorageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 persistent_volume_claim_ref: builtins.str):
        """
        Local persistent volume endpoint properties
        :param builtins.str persistent_volume_claim_ref: Persistent volume claim name.
        """
        pulumi.set(__self__, "persistent_volume_claim_ref", persistent_volume_claim_ref)

    @property
    @pulumi.getter(name="persistentVolumeClaimRef")
    def persistent_volume_claim_ref(self) -> builtins.str:
        """
        Persistent volume claim name.
        """
        return pulumi.get(self, "persistent_volume_claim_ref")


@pulumi.output_type
class DataflowEndpointMqttAuthenticationResponse(dict):
    """
    Mqtt endpoint Authentication properties. NOTE - only authentication property is allowed per entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountTokenSettings":
            suggest = "service_account_token_settings"
        elif key == "systemAssignedManagedIdentitySettings":
            suggest = "system_assigned_managed_identity_settings"
        elif key == "userAssignedManagedIdentitySettings":
            suggest = "user_assigned_managed_identity_settings"
        elif key == "x509CertificateSettings":
            suggest = "x509_certificate_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointMqttAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointMqttAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointMqttAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: builtins.str,
                 service_account_token_settings: Optional['outputs.DataflowEndpointAuthenticationServiceAccountTokenResponse'] = None,
                 system_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse'] = None,
                 user_assigned_managed_identity_settings: Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse'] = None,
                 x509_certificate_settings: Optional['outputs.DataflowEndpointAuthenticationX509Response'] = None):
        """
        Mqtt endpoint Authentication properties. NOTE - only authentication property is allowed per entry.
        :param builtins.str method: Mode of Authentication.
        :param 'DataflowEndpointAuthenticationServiceAccountTokenResponse' service_account_token_settings: Kubernetes service account token authentication. Default audience if not set is aio-internal
        :param 'DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse' system_assigned_managed_identity_settings: System-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse' user_assigned_managed_identity_settings: User-assigned managed identity authentication.
        :param 'DataflowEndpointAuthenticationX509Response' x509_certificate_settings: X.509 certificate authentication.
        """
        pulumi.set(__self__, "method", method)
        if service_account_token_settings is not None:
            pulumi.set(__self__, "service_account_token_settings", service_account_token_settings)
        if system_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "system_assigned_managed_identity_settings", system_assigned_managed_identity_settings)
        if user_assigned_managed_identity_settings is not None:
            pulumi.set(__self__, "user_assigned_managed_identity_settings", user_assigned_managed_identity_settings)
        if x509_certificate_settings is not None:
            pulumi.set(__self__, "x509_certificate_settings", x509_certificate_settings)

    @property
    @pulumi.getter
    def method(self) -> builtins.str:
        """
        Mode of Authentication.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="serviceAccountTokenSettings")
    def service_account_token_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationServiceAccountTokenResponse']:
        """
        Kubernetes service account token authentication. Default audience if not set is aio-internal
        """
        return pulumi.get(self, "service_account_token_settings")

    @property
    @pulumi.getter(name="systemAssignedManagedIdentitySettings")
    def system_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationSystemAssignedManagedIdentityResponse']:
        """
        System-assigned managed identity authentication.
        """
        return pulumi.get(self, "system_assigned_managed_identity_settings")

    @property
    @pulumi.getter(name="userAssignedManagedIdentitySettings")
    def user_assigned_managed_identity_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationUserAssignedManagedIdentityResponse']:
        """
        User-assigned managed identity authentication.
        """
        return pulumi.get(self, "user_assigned_managed_identity_settings")

    @property
    @pulumi.getter(name="x509CertificateSettings")
    def x509_certificate_settings(self) -> Optional['outputs.DataflowEndpointAuthenticationX509Response']:
        """
        X.509 certificate authentication.
        """
        return pulumi.get(self, "x509_certificate_settings")


@pulumi.output_type
class DataflowEndpointMqttResponse(dict):
    """
    Broker endpoint properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIdPrefix":
            suggest = "client_id_prefix"
        elif key == "cloudEventAttributes":
            suggest = "cloud_event_attributes"
        elif key == "keepAliveSeconds":
            suggest = "keep_alive_seconds"
        elif key == "maxInflightMessages":
            suggest = "max_inflight_messages"
        elif key == "sessionExpirySeconds":
            suggest = "session_expiry_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointMqttResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointMqttResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointMqttResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: 'outputs.DataflowEndpointMqttAuthenticationResponse',
                 client_id_prefix: Optional[builtins.str] = None,
                 cloud_event_attributes: Optional[builtins.str] = None,
                 host: Optional[builtins.str] = None,
                 keep_alive_seconds: Optional[builtins.int] = None,
                 max_inflight_messages: Optional[builtins.int] = None,
                 protocol: Optional[builtins.str] = None,
                 qos: Optional[builtins.int] = None,
                 retain: Optional[builtins.str] = None,
                 session_expiry_seconds: Optional[builtins.int] = None,
                 tls: Optional['outputs.TlsPropertiesResponse'] = None):
        """
        Broker endpoint properties
        :param 'DataflowEndpointMqttAuthenticationResponse' authentication: authentication properties. DEFAULT: kubernetes.audience=aio-internal. NOTE - Enum field only property is allowed
        :param builtins.str client_id_prefix: Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        :param builtins.str cloud_event_attributes: Cloud event mapping config.
        :param builtins.str host: Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        :param builtins.int keep_alive_seconds: Broker KeepAlive for connection in seconds.
        :param builtins.int max_inflight_messages: The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        :param builtins.str protocol: Enable or disable websockets.
        :param builtins.int qos: Qos for Broker connection.
        :param builtins.str retain: Whether or not to keep the retain setting.
        :param builtins.int session_expiry_seconds: Session expiry in seconds.
        :param 'TlsPropertiesResponse' tls: TLS configuration.
        """
        pulumi.set(__self__, "authentication", authentication)
        if client_id_prefix is not None:
            pulumi.set(__self__, "client_id_prefix", client_id_prefix)
        if cloud_event_attributes is not None:
            pulumi.set(__self__, "cloud_event_attributes", cloud_event_attributes)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_alive_seconds is None:
            keep_alive_seconds = 60
        if keep_alive_seconds is not None:
            pulumi.set(__self__, "keep_alive_seconds", keep_alive_seconds)
        if max_inflight_messages is None:
            max_inflight_messages = 100
        if max_inflight_messages is not None:
            pulumi.set(__self__, "max_inflight_messages", max_inflight_messages)
        if protocol is None:
            protocol = 'Mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if qos is None:
            qos = 1
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if retain is None:
            retain = 'Keep'
        if retain is not None:
            pulumi.set(__self__, "retain", retain)
        if session_expiry_seconds is not None:
            pulumi.set(__self__, "session_expiry_seconds", session_expiry_seconds)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.DataflowEndpointMqttAuthenticationResponse':
        """
        authentication properties. DEFAULT: kubernetes.audience=aio-internal. NOTE - Enum field only property is allowed
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="clientIdPrefix")
    def client_id_prefix(self) -> Optional[builtins.str]:
        """
        Client ID prefix. Client ID generated by the dataflow is <prefix>-TBD. Optional; no prefix if omitted.
        """
        return pulumi.get(self, "client_id_prefix")

    @property
    @pulumi.getter(name="cloudEventAttributes")
    def cloud_event_attributes(self) -> Optional[builtins.str]:
        """
        Cloud event mapping config.
        """
        return pulumi.get(self, "cloud_event_attributes")

    @property
    @pulumi.getter
    def host(self) -> Optional[builtins.str]:
        """
        Host of the Broker in the form of <hostname>:<port>. Optional; connects to Broker if omitted.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="keepAliveSeconds")
    def keep_alive_seconds(self) -> Optional[builtins.int]:
        """
        Broker KeepAlive for connection in seconds.
        """
        return pulumi.get(self, "keep_alive_seconds")

    @property
    @pulumi.getter(name="maxInflightMessages")
    def max_inflight_messages(self) -> Optional[builtins.int]:
        """
        The max number of messages to keep in flight. For subscribe, this is the receive maximum. For publish, this is the maximum number of messages to send before waiting for an ack.
        """
        return pulumi.get(self, "max_inflight_messages")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        """
        Enable or disable websockets.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def qos(self) -> Optional[builtins.int]:
        """
        Qos for Broker connection.
        """
        return pulumi.get(self, "qos")

    @property
    @pulumi.getter
    def retain(self) -> Optional[builtins.str]:
        """
        Whether or not to keep the retain setting.
        """
        return pulumi.get(self, "retain")

    @property
    @pulumi.getter(name="sessionExpirySeconds")
    def session_expiry_seconds(self) -> Optional[builtins.int]:
        """
        Session expiry in seconds.
        """
        return pulumi.get(self, "session_expiry_seconds")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.TlsPropertiesResponse']:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DataflowEndpointPropertiesResponse(dict):
    """
    DataflowEndpoint Resource properties. NOTE - Only one type of endpoint is supported for one Resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "dataExplorerSettings":
            suggest = "data_explorer_settings"
        elif key == "dataLakeStorageSettings":
            suggest = "data_lake_storage_settings"
        elif key == "fabricOneLakeSettings":
            suggest = "fabric_one_lake_settings"
        elif key == "kafkaSettings":
            suggest = "kafka_settings"
        elif key == "localStorageSettings":
            suggest = "local_storage_settings"
        elif key == "mqttSettings":
            suggest = "mqtt_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowEndpointPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowEndpointPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowEndpointPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_type: builtins.str,
                 provisioning_state: builtins.str,
                 data_explorer_settings: Optional['outputs.DataflowEndpointDataExplorerResponse'] = None,
                 data_lake_storage_settings: Optional['outputs.DataflowEndpointDataLakeStorageResponse'] = None,
                 fabric_one_lake_settings: Optional['outputs.DataflowEndpointFabricOneLakeResponse'] = None,
                 kafka_settings: Optional['outputs.DataflowEndpointKafkaResponse'] = None,
                 local_storage_settings: Optional['outputs.DataflowEndpointLocalStorageResponse'] = None,
                 mqtt_settings: Optional['outputs.DataflowEndpointMqttResponse'] = None):
        """
        DataflowEndpoint Resource properties. NOTE - Only one type of endpoint is supported for one Resource
        :param builtins.str endpoint_type: Endpoint Type.
        :param builtins.str provisioning_state: The status of the last operation.
        :param 'DataflowEndpointDataExplorerResponse' data_explorer_settings: Azure Data Explorer endpoint.
        :param 'DataflowEndpointDataLakeStorageResponse' data_lake_storage_settings: Azure Data Lake endpoint.
        :param 'DataflowEndpointFabricOneLakeResponse' fabric_one_lake_settings: Microsoft Fabric endpoint.
        :param 'DataflowEndpointKafkaResponse' kafka_settings: Kafka endpoint.
        :param 'DataflowEndpointLocalStorageResponse' local_storage_settings: Local persistent volume endpoint.
        :param 'DataflowEndpointMqttResponse' mqtt_settings: Broker endpoint.
        """
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if data_explorer_settings is not None:
            pulumi.set(__self__, "data_explorer_settings", data_explorer_settings)
        if data_lake_storage_settings is not None:
            pulumi.set(__self__, "data_lake_storage_settings", data_lake_storage_settings)
        if fabric_one_lake_settings is not None:
            pulumi.set(__self__, "fabric_one_lake_settings", fabric_one_lake_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if local_storage_settings is not None:
            pulumi.set(__self__, "local_storage_settings", local_storage_settings)
        if mqtt_settings is not None:
            pulumi.set(__self__, "mqtt_settings", mqtt_settings)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Endpoint Type.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="dataExplorerSettings")
    def data_explorer_settings(self) -> Optional['outputs.DataflowEndpointDataExplorerResponse']:
        """
        Azure Data Explorer endpoint.
        """
        return pulumi.get(self, "data_explorer_settings")

    @property
    @pulumi.getter(name="dataLakeStorageSettings")
    def data_lake_storage_settings(self) -> Optional['outputs.DataflowEndpointDataLakeStorageResponse']:
        """
        Azure Data Lake endpoint.
        """
        return pulumi.get(self, "data_lake_storage_settings")

    @property
    @pulumi.getter(name="fabricOneLakeSettings")
    def fabric_one_lake_settings(self) -> Optional['outputs.DataflowEndpointFabricOneLakeResponse']:
        """
        Microsoft Fabric endpoint.
        """
        return pulumi.get(self, "fabric_one_lake_settings")

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional['outputs.DataflowEndpointKafkaResponse']:
        """
        Kafka endpoint.
        """
        return pulumi.get(self, "kafka_settings")

    @property
    @pulumi.getter(name="localStorageSettings")
    def local_storage_settings(self) -> Optional['outputs.DataflowEndpointLocalStorageResponse']:
        """
        Local persistent volume endpoint.
        """
        return pulumi.get(self, "local_storage_settings")

    @property
    @pulumi.getter(name="mqttSettings")
    def mqtt_settings(self) -> Optional['outputs.DataflowEndpointMqttResponse']:
        """
        Broker endpoint.
        """
        return pulumi.get(self, "mqtt_settings")


@pulumi.output_type
class DataflowOperationResponse(dict):
    """
    Dataflow Operation properties. NOTE - One only method is allowed to be used for one entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operationType":
            suggest = "operation_type"
        elif key == "builtInTransformationSettings":
            suggest = "built_in_transformation_settings"
        elif key == "destinationSettings":
            suggest = "destination_settings"
        elif key == "sourceSettings":
            suggest = "source_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowOperationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowOperationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowOperationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operation_type: builtins.str,
                 built_in_transformation_settings: Optional['outputs.DataflowBuiltInTransformationSettingsResponse'] = None,
                 destination_settings: Optional['outputs.DataflowDestinationOperationSettingsResponse'] = None,
                 name: Optional[builtins.str] = None,
                 source_settings: Optional['outputs.DataflowSourceOperationSettingsResponse'] = None):
        """
        Dataflow Operation properties. NOTE - One only method is allowed to be used for one entry.
        :param builtins.str operation_type: Type of operation.
        :param 'DataflowBuiltInTransformationSettingsResponse' built_in_transformation_settings: Built In Transformation configuration.
        :param 'DataflowDestinationOperationSettingsResponse' destination_settings: Destination configuration.
        :param builtins.str name: Optional user provided name of the transformation.
        :param 'DataflowSourceOperationSettingsResponse' source_settings: Source configuration.
        """
        pulumi.set(__self__, "operation_type", operation_type)
        if built_in_transformation_settings is not None:
            pulumi.set(__self__, "built_in_transformation_settings", built_in_transformation_settings)
        if destination_settings is not None:
            pulumi.set(__self__, "destination_settings", destination_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_settings is not None:
            pulumi.set(__self__, "source_settings", source_settings)

    @property
    @pulumi.getter(name="operationType")
    def operation_type(self) -> builtins.str:
        """
        Type of operation.
        """
        return pulumi.get(self, "operation_type")

    @property
    @pulumi.getter(name="builtInTransformationSettings")
    def built_in_transformation_settings(self) -> Optional['outputs.DataflowBuiltInTransformationSettingsResponse']:
        """
        Built In Transformation configuration.
        """
        return pulumi.get(self, "built_in_transformation_settings")

    @property
    @pulumi.getter(name="destinationSettings")
    def destination_settings(self) -> Optional['outputs.DataflowDestinationOperationSettingsResponse']:
        """
        Destination configuration.
        """
        return pulumi.get(self, "destination_settings")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Optional user provided name of the transformation.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceSettings")
    def source_settings(self) -> Optional['outputs.DataflowSourceOperationSettingsResponse']:
        """
        Source configuration.
        """
        return pulumi.get(self, "source_settings")


@pulumi.output_type
class DataflowProfilePropertiesResponse(dict):
    """
    DataflowProfile Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "instanceCount":
            suggest = "instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowProfilePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowProfilePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowProfilePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 diagnostics: Optional['outputs.ProfileDiagnosticsResponse'] = None,
                 instance_count: Optional[builtins.int] = None):
        """
        DataflowProfile Resource properties
        :param builtins.str provisioning_state: The status of the last operation.
        :param 'ProfileDiagnosticsResponse' diagnostics: Spec defines the desired identities of NBC diagnostics settings.
        :param builtins.int instance_count: To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if diagnostics is not None:
            pulumi.set(__self__, "diagnostics", diagnostics)
        if instance_count is None:
            instance_count = 1
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def diagnostics(self) -> Optional['outputs.ProfileDiagnosticsResponse']:
        """
        Spec defines the desired identities of NBC diagnostics settings.
        """
        return pulumi.get(self, "diagnostics")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[builtins.int]:
        """
        To manually scale the dataflow profile, specify the maximum number of instances you want to run.
        """
        return pulumi.get(self, "instance_count")


@pulumi.output_type
class DataflowPropertiesResponse(dict):
    """
    Dataflow Resource properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operations: Sequence['outputs.DataflowOperationResponse'],
                 provisioning_state: builtins.str,
                 mode: Optional[builtins.str] = None):
        """
        Dataflow Resource properties
        :param Sequence['DataflowOperationResponse'] operations: List of operations including source and destination references as well as transformation.
        :param builtins.str provisioning_state: The status of the last operation.
        :param builtins.str mode: Mode for Dataflow. Optional; defaults to Enabled.
        """
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def operations(self) -> Sequence['outputs.DataflowOperationResponse']:
        """
        List of operations including source and destination references as well as transformation.
        """
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Mode for Dataflow. Optional; defaults to Enabled.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class DataflowSourceOperationSettingsResponse(dict):
    """
    Dataflow Source Operation properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSources":
            suggest = "data_sources"
        elif key == "endpointRef":
            suggest = "endpoint_ref"
        elif key == "assetRef":
            suggest = "asset_ref"
        elif key == "schemaRef":
            suggest = "schema_ref"
        elif key == "serializationFormat":
            suggest = "serialization_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataflowSourceOperationSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataflowSourceOperationSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataflowSourceOperationSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_sources: Sequence[builtins.str],
                 endpoint_ref: builtins.str,
                 asset_ref: Optional[builtins.str] = None,
                 schema_ref: Optional[builtins.str] = None,
                 serialization_format: Optional[builtins.str] = None):
        """
        Dataflow Source Operation properties
        :param Sequence[builtins.str] data_sources: List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        :param builtins.str endpoint_ref: Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        :param builtins.str asset_ref: Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        :param builtins.str schema_ref: Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        :param builtins.str serialization_format: Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "endpoint_ref", endpoint_ref)
        if asset_ref is not None:
            pulumi.set(__self__, "asset_ref", asset_ref)
        if schema_ref is not None:
            pulumi.set(__self__, "schema_ref", schema_ref)
        if serialization_format is None:
            serialization_format = 'Json'
        if serialization_format is not None:
            pulumi.set(__self__, "serialization_format", serialization_format)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence[builtins.str]:
        """
        List of source locations. Can be Broker or Kafka topics. Supports wildcards # and +.
        """
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter(name="endpointRef")
    def endpoint_ref(self) -> builtins.str:
        """
        Reference to the Dataflow Endpoint resource. Can only be of Broker and Kafka type.
        """
        return pulumi.get(self, "endpoint_ref")

    @property
    @pulumi.getter(name="assetRef")
    def asset_ref(self) -> Optional[builtins.str]:
        """
        Reference to the resource in Azure Device Registry where the data in the endpoint originates from.
        """
        return pulumi.get(self, "asset_ref")

    @property
    @pulumi.getter(name="schemaRef")
    def schema_ref(self) -> Optional[builtins.str]:
        """
        Schema CR reference. Data will be deserialized according to the schema, and dropped if it doesn't match.
        """
        return pulumi.get(self, "schema_ref")

    @property
    @pulumi.getter(name="serializationFormat")
    def serialization_format(self) -> Optional[builtins.str]:
        """
        Content is a JSON Schema. Allowed: JSON Schema/draft-7.
        """
        return pulumi.get(self, "serialization_format")


@pulumi.output_type
class DiagnosticsLogsResponse(dict):
    """
    Diagnostic Log properties
    """
    def __init__(__self__, *,
                 level: Optional[builtins.str] = None):
        """
        Diagnostic Log properties
        :param builtins.str level: The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        if level is None:
            level = 'info'
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def level(self) -> Optional[builtins.str]:
        """
        The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class DiskBackedMessageBufferResponse(dict):
    """
    DiskBackedMessageBuffer properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "ephemeralVolumeClaimSpec":
            suggest = "ephemeral_volume_claim_spec"
        elif key == "persistentVolumeClaimSpec":
            suggest = "persistent_volume_claim_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskBackedMessageBufferResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskBackedMessageBufferResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskBackedMessageBufferResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_size: builtins.str,
                 ephemeral_volume_claim_spec: Optional['outputs.VolumeClaimSpecResponse'] = None,
                 persistent_volume_claim_spec: Optional['outputs.VolumeClaimSpecResponse'] = None):
        """
        DiskBackedMessageBuffer properties
        :param builtins.str max_size: The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        :param 'VolumeClaimSpecResponse' ephemeral_volume_claim_spec: Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        :param 'VolumeClaimSpecResponse' persistent_volume_claim_spec: Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        pulumi.set(__self__, "max_size", max_size)
        if ephemeral_volume_claim_spec is not None:
            pulumi.set(__self__, "ephemeral_volume_claim_spec", ephemeral_volume_claim_spec)
        if persistent_volume_claim_spec is not None:
            pulumi.set(__self__, "persistent_volume_claim_spec", persistent_volume_claim_spec)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> builtins.str:
        """
        The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="ephemeralVolumeClaimSpec")
    def ephemeral_volume_claim_spec(self) -> Optional['outputs.VolumeClaimSpecResponse']:
        """
        Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes> for details.
        """
        return pulumi.get(self, "ephemeral_volume_claim_spec")

    @property
    @pulumi.getter(name="persistentVolumeClaimSpec")
    def persistent_volume_claim_spec(self) -> Optional['outputs.VolumeClaimSpecResponse']:
        """
        Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        """
        return pulumi.get(self, "persistent_volume_claim_spec")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    """
    Extended location is an extension of Azure locations. They provide a way to use their Azure ARC enabled Kubernetes clusters as target locations for deploying Azure services instances.
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str):
        """
        Extended location is an extension of Azure locations. They provide a way to use their Azure ARC enabled Kubernetes clusters as target locations for deploying Azure services instances.
        :param builtins.str name: The name of the extended location.
        :param builtins.str type: Type of ExtendedLocation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of ExtendedLocation.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FrontendResponse(dict):
    """
    The desired properties of the frontend instances of the Broker
    """
    def __init__(__self__, *,
                 replicas: builtins.int,
                 workers: Optional[builtins.int] = None):
        """
        The desired properties of the frontend instances of the Broker
        :param builtins.int replicas: The desired number of frontend instances (pods).
        :param builtins.int workers: Number of logical frontend workers per instance (pod).
        """
        pulumi.set(__self__, "replicas", replicas)
        if workers is None:
            workers = 2
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter
    def replicas(self) -> builtins.int:
        """
        The desired number of frontend instances (pods).
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def workers(self) -> Optional[builtins.int]:
        """
        Number of logical frontend workers per instance (pod).
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class GenerateResourceLimitsResponse(dict):
    """
    GenerateResourceLimits properties
    """
    def __init__(__self__, *,
                 cpu: Optional[builtins.str] = None):
        """
        GenerateResourceLimits properties
        :param builtins.str cpu: The toggle to enable/disable cpu resource limits.
        """
        if cpu is None:
            cpu = 'Enabled'
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[builtins.str]:
        """
        The toggle to enable/disable cpu resource limits.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class InstancePropertiesResponse(dict):
    """
    The properties of the Instance resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "schemaRegistryRef":
            suggest = "schema_registry_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: builtins.str,
                 schema_registry_ref: 'outputs.SchemaRegistryRefResponse',
                 version: builtins.str,
                 description: Optional[builtins.str] = None):
        """
        The properties of the Instance resource.
        :param builtins.str provisioning_state: The status of the last operation.
        :param 'SchemaRegistryRefResponse' schema_registry_ref: The reference to the Schema Registry for this AIO Instance.
        :param builtins.str version: The Azure IoT Operations version.
        :param builtins.str description: Detailed description of the Instance.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "schema_registry_ref", schema_registry_ref)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="schemaRegistryRef")
    def schema_registry_ref(self) -> 'outputs.SchemaRegistryRefResponse':
        """
        The reference to the Schema Registry for this AIO Instance.
        """
        return pulumi.get(self, "schema_registry_ref")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        The Azure IoT Operations version.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Detailed description of the Instance.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class KubernetesReferenceResponse(dict):
    """
    Kubernetes reference
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGroup":
            suggest = "api_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: builtins.str,
                 name: builtins.str,
                 api_group: Optional[builtins.str] = None,
                 namespace: Optional[builtins.str] = None):
        """
        Kubernetes reference
        :param builtins.str kind: Kind is the type of resource being referenced
        :param builtins.str name: Name is the name of resource being referenced
        :param builtins.str api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        :param builtins.str namespace: Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[builtins.str]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ListenerPortResponse(dict):
    """
    Defines a TCP port on which a `BrokerListener` listens.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationRef":
            suggest = "authentication_ref"
        elif key == "authorizationRef":
            suggest = "authorization_ref"
        elif key == "nodePort":
            suggest = "node_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ListenerPortResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ListenerPortResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ListenerPortResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: builtins.int,
                 authentication_ref: Optional[builtins.str] = None,
                 authorization_ref: Optional[builtins.str] = None,
                 node_port: Optional[builtins.int] = None,
                 protocol: Optional[builtins.str] = None,
                 tls: Optional['outputs.TlsCertMethodResponse'] = None):
        """
        Defines a TCP port on which a `BrokerListener` listens.
        :param builtins.int port: TCP port for accepting client connections.
        :param builtins.str authentication_ref: Reference to client authentication settings. Omit to disable authentication.
        :param builtins.str authorization_ref: Reference to client authorization settings. Omit to disable authorization.
        :param builtins.int node_port: Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        :param builtins.str protocol: Protocol to use for client connections.
        :param 'TlsCertMethodResponse' tls: TLS server certificate settings for this port. Omit to disable TLS.
        """
        pulumi.set(__self__, "port", port)
        if authentication_ref is not None:
            pulumi.set(__self__, "authentication_ref", authentication_ref)
        if authorization_ref is not None:
            pulumi.set(__self__, "authorization_ref", authorization_ref)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)
        if protocol is None:
            protocol = 'Mqtt'
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def port(self) -> builtins.int:
        """
        TCP port for accepting client connections.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="authenticationRef")
    def authentication_ref(self) -> Optional[builtins.str]:
        """
        Reference to client authentication settings. Omit to disable authentication.
        """
        return pulumi.get(self, "authentication_ref")

    @property
    @pulumi.getter(name="authorizationRef")
    def authorization_ref(self) -> Optional[builtins.str]:
        """
        Reference to client authorization settings. Omit to disable authorization.
        """
        return pulumi.get(self, "authorization_ref")

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[builtins.int]:
        """
        Kubernetes node port. Only relevant when this port is associated with a `NodePort` listener.
        """
        return pulumi.get(self, "node_port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        """
        Protocol to use for client connections.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.TlsCertMethodResponse']:
        """
        TLS server certificate settings for this port. Omit to disable TLS.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class LocalKubernetesReferenceResponse(dict):
    """
    Kubernetes reference
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGroup":
            suggest = "api_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalKubernetesReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalKubernetesReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalKubernetesReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: builtins.str,
                 name: builtins.str,
                 api_group: Optional[builtins.str] = None):
        """
        Kubernetes reference
        :param builtins.str kind: Kind is the type of resource being referenced
        :param builtins.str name: Name is the name of resource being referenced
        :param builtins.str api_group: APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_group is not None:
            pulumi.set(__self__, "api_group", api_group)

    @property
    @pulumi.getter
    def kind(self) -> builtins.str:
        """
        Kind is the type of resource being referenced
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name is the name of resource being referenced
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="apiGroup")
    def api_group(self) -> Optional[builtins.str]:
        """
        APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        """
        return pulumi.get(self, "api_group")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MetricsResponse(dict):
    """
    Diagnostic Metrics properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prometheusPort":
            suggest = "prometheus_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prometheus_port: Optional[builtins.int] = None):
        """
        Diagnostic Metrics properties
        :param builtins.int prometheus_port: The prometheus port to expose the metrics.
        """
        if prometheus_port is None:
            prometheus_port = 9600
        if prometheus_port is not None:
            pulumi.set(__self__, "prometheus_port", prometheus_port)

    @property
    @pulumi.getter(name="prometheusPort")
    def prometheus_port(self) -> Optional[builtins.int]:
        """
        The prometheus port to expose the metrics.
        """
        return pulumi.get(self, "prometheus_port")


@pulumi.output_type
class PrincipalDefinitionResponse(dict):
    """
    PrincipalDefinition properties of Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIds":
            suggest = "client_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrincipalDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrincipalDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrincipalDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attributes: Optional[Sequence[Mapping[str, builtins.str]]] = None,
                 client_ids: Optional[Sequence[builtins.str]] = None,
                 usernames: Optional[Sequence[builtins.str]] = None):
        """
        PrincipalDefinition properties of Rule
        :param Sequence[Mapping[str, builtins.str]] attributes: A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        :param Sequence[builtins.str] client_ids: A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        :param Sequence[builtins.str] usernames: A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if client_ids is not None:
            pulumi.set(__self__, "client_ids", client_ids)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence[Mapping[str, builtins.str]]]:
        """
        A list of key-value pairs that match the attributes of the clients. The attributes are case-sensitive and must match the attributes provided by the clients during authentication.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="clientIds")
    def client_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of client IDs that match the clients. The client IDs are case-sensitive and must match the client IDs provided by the clients during connection.
        """
        return pulumi.get(self, "client_ids")

    @property
    @pulumi.getter
    def usernames(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of usernames that match the clients. The usernames are case-sensitive and must match the usernames provided by the clients during authentication.
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class ProfileDiagnosticsResponse(dict):
    """
    DataflowProfile Diagnostics properties
    """
    def __init__(__self__, *,
                 logs: Optional['outputs.DiagnosticsLogsResponse'] = None,
                 metrics: Optional['outputs.MetricsResponse'] = None):
        """
        DataflowProfile Diagnostics properties
        :param 'DiagnosticsLogsResponse' logs: Diagnostic log settings for the resource.
        :param 'MetricsResponse' metrics: The metrics settings for the resource.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @property
    @pulumi.getter
    def logs(self) -> Optional['outputs.DiagnosticsLogsResponse']:
        """
        Diagnostic log settings for the resource.
        """
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.MetricsResponse']:
        """
        The metrics settings for the resource.
        """
        return pulumi.get(self, "metrics")


@pulumi.output_type
class SanForCertResponse(dict):
    """
    Subject Alternative Names (SANs) for certificate.
    """
    def __init__(__self__, *,
                 dns: Sequence[builtins.str],
                 ip: Sequence[builtins.str]):
        """
        Subject Alternative Names (SANs) for certificate.
        :param Sequence[builtins.str] dns: DNS SANs.
        :param Sequence[builtins.str] ip: IP address SANs.
        """
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def dns(self) -> Sequence[builtins.str]:
        """
        DNS SANs.
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def ip(self) -> Sequence[builtins.str]:
        """
        IP address SANs.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class SchemaRegistryRefResponse(dict):
    """
    The reference to the Schema Registry for this AIO Instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaRegistryRefResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaRegistryRefResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaRegistryRefResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: builtins.str):
        """
        The reference to the Schema Registry for this AIO Instance.
        :param builtins.str resource_id: The resource ID of the Schema Registry.
        """
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> builtins.str:
        """
        The resource ID of the Schema Registry.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class SelfCheckResponse(dict):
    """
    Broker Diagnostic Self check properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSeconds":
            suggest = "interval_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelfCheckResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelfCheckResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelfCheckResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_seconds: Optional[builtins.int] = None,
                 mode: Optional[builtins.str] = None,
                 timeout_seconds: Optional[builtins.int] = None):
        """
        Broker Diagnostic Self check properties
        :param builtins.int interval_seconds: The self check interval.
        :param builtins.str mode: The toggle to enable/disable self check.
        :param builtins.int timeout_seconds: The timeout for self check.
        """
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if timeout_seconds is None:
            timeout_seconds = 15
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[builtins.int]:
        """
        The self check interval.
        """
        return pulumi.get(self, "interval_seconds")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        The toggle to enable/disable self check.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[builtins.int]:
        """
        The timeout for self check.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class SelfTracingResponse(dict):
    """
    Diagnostic Self tracing properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSeconds":
            suggest = "interval_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SelfTracingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SelfTracingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SelfTracingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_seconds: Optional[builtins.int] = None,
                 mode: Optional[builtins.str] = None):
        """
        Diagnostic Self tracing properties
        :param builtins.int interval_seconds: The self tracing interval.
        :param builtins.str mode: The toggle to enable/disable self tracing.
        """
        if interval_seconds is None:
            interval_seconds = 30
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[builtins.int]:
        """
        The self tracing interval.
        """
        return pulumi.get(self, "interval_seconds")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        The toggle to enable/disable self tracing.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class StateStoreResourceRuleResponse(dict):
    """
    State Store Resource Rule properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyType":
            suggest = "key_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StateStoreResourceRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StateStoreResourceRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StateStoreResourceRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_type: builtins.str,
                 keys: Sequence[builtins.str],
                 method: builtins.str):
        """
        State Store Resource Rule properties.
        :param builtins.str key_type: Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        :param Sequence[builtins.str] keys: Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        :param builtins.str method: Give access for `Read`, `Write` and `ReadWrite` access level.
        """
        pulumi.set(__self__, "key_type", key_type)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> builtins.str:
        """
        Allowed keyTypes pattern, string, binary. The key type used for matching, for example pattern tries to match the key to a glob-style pattern and string checks key is equal to value provided in keys.
        """
        return pulumi.get(self, "key_type")

    @property
    @pulumi.getter
    def keys(self) -> Sequence[builtins.str]:
        """
        Give access to state store keys for the corresponding principals defined. When key type is pattern set glob-style pattern (e.g., '*', 'clients/*').
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter
    def method(self) -> builtins.str:
        """
        Give access for `Read`, `Write` and `ReadWrite` access level.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class SubscriberQueueLimitResponse(dict):
    """
    The settings of Subscriber Queue Limit.
    """
    def __init__(__self__, *,
                 length: Optional[builtins.float] = None,
                 strategy: Optional[builtins.str] = None):
        """
        The settings of Subscriber Queue Limit.
        :param builtins.float length: The maximum length of the queue before messages start getting dropped.
        :param builtins.str strategy: The strategy to use for dropping messages from the queue.
        """
        if length is not None:
            pulumi.set(__self__, "length", length)
        if strategy is None:
            strategy = 'None'
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def length(self) -> Optional[builtins.float]:
        """
        The maximum length of the queue before messages start getting dropped.
        """
        return pulumi.get(self, "length")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[builtins.str]:
        """
        The strategy to use for dropping messages from the queue.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TlsCertMethodResponse(dict):
    """
    Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certManagerCertificateSpec":
            suggest = "cert_manager_certificate_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TlsCertMethodResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TlsCertMethodResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TlsCertMethodResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: builtins.str,
                 cert_manager_certificate_spec: Optional['outputs.CertManagerCertificateSpecResponse'] = None,
                 manual: Optional['outputs.X509ManualCertificateResponse'] = None):
        """
        Collection of different TLS types, NOTE- Enum at a time only one of them needs to be supported
        :param builtins.str mode: Mode of TLS server certificate management.
        :param 'CertManagerCertificateSpecResponse' cert_manager_certificate_spec: Option 1 - Automatic TLS server certificate management with cert-manager.
        :param 'X509ManualCertificateResponse' manual: Option 2 - Manual TLS server certificate management through a defined secret.
        """
        pulumi.set(__self__, "mode", mode)
        if cert_manager_certificate_spec is not None:
            pulumi.set(__self__, "cert_manager_certificate_spec", cert_manager_certificate_spec)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @property
    @pulumi.getter
    def mode(self) -> builtins.str:
        """
        Mode of TLS server certificate management.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="certManagerCertificateSpec")
    def cert_manager_certificate_spec(self) -> Optional['outputs.CertManagerCertificateSpecResponse']:
        """
        Option 1 - Automatic TLS server certificate management with cert-manager.
        """
        return pulumi.get(self, "cert_manager_certificate_spec")

    @property
    @pulumi.getter
    def manual(self) -> Optional['outputs.X509ManualCertificateResponse']:
        """
        Option 2 - Manual TLS server certificate management through a defined secret.
        """
        return pulumi.get(self, "manual")


@pulumi.output_type
class TlsPropertiesResponse(dict):
    """
    Tls properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCaCertificateConfigMapRef":
            suggest = "trusted_ca_certificate_config_map_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TlsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TlsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TlsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[builtins.str] = None,
                 trusted_ca_certificate_config_map_ref: Optional[builtins.str] = None):
        """
        Tls properties
        :param builtins.str mode: Mode for TLS.
        :param builtins.str trusted_ca_certificate_config_map_ref: Trusted CA certificate config map.
        """
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if trusted_ca_certificate_config_map_ref is not None:
            pulumi.set(__self__, "trusted_ca_certificate_config_map_ref", trusted_ca_certificate_config_map_ref)

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        Mode for TLS.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="trustedCaCertificateConfigMapRef")
    def trusted_ca_certificate_config_map_ref(self) -> Optional[builtins.str]:
        """
        Trusted CA certificate config map.
        """
        return pulumi.get(self, "trusted_ca_certificate_config_map_ref")


@pulumi.output_type
class TracesResponse(dict):
    """
    Broker Diagnostic Trace properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheSizeMegabytes":
            suggest = "cache_size_megabytes"
        elif key == "selfTracing":
            suggest = "self_tracing"
        elif key == "spanChannelCapacity":
            suggest = "span_channel_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TracesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TracesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TracesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_size_megabytes: Optional[builtins.int] = None,
                 mode: Optional[builtins.str] = None,
                 self_tracing: Optional['outputs.SelfTracingResponse'] = None,
                 span_channel_capacity: Optional[builtins.int] = None):
        """
        Broker Diagnostic Trace properties
        :param builtins.int cache_size_megabytes: The cache size in megabytes.
        :param builtins.str mode: The toggle to enable/disable traces.
        :param 'SelfTracingResponse' self_tracing: The self tracing properties.
        :param builtins.int span_channel_capacity: The span channel capacity.
        """
        if cache_size_megabytes is None:
            cache_size_megabytes = 16
        if cache_size_megabytes is not None:
            pulumi.set(__self__, "cache_size_megabytes", cache_size_megabytes)
        if mode is None:
            mode = 'Enabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if self_tracing is not None:
            pulumi.set(__self__, "self_tracing", self_tracing)
        if span_channel_capacity is None:
            span_channel_capacity = 1000
        if span_channel_capacity is not None:
            pulumi.set(__self__, "span_channel_capacity", span_channel_capacity)

    @property
    @pulumi.getter(name="cacheSizeMegabytes")
    def cache_size_megabytes(self) -> Optional[builtins.int]:
        """
        The cache size in megabytes.
        """
        return pulumi.get(self, "cache_size_megabytes")

    @property
    @pulumi.getter
    def mode(self) -> Optional[builtins.str]:
        """
        The toggle to enable/disable traces.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="selfTracing")
    def self_tracing(self) -> Optional['outputs.SelfTracingResponse']:
        """
        The self tracing properties.
        """
        return pulumi.get(self, "self_tracing")

    @property
    @pulumi.getter(name="spanChannelCapacity")
    def span_channel_capacity(self) -> Optional[builtins.int]:
        """
        The span channel capacity.
        """
        return pulumi.get(self, "span_channel_capacity")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 principal_id: builtins.str):
        """
        User assigned identity properties
        :param builtins.str client_id: The client ID of the assigned identity.
        :param builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VolumeClaimResourceRequirementsResponse(dict):
    """
    VolumeClaimResourceRequirements properties
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, builtins.str]] = None,
                 requests: Optional[Mapping[str, builtins.str]] = None):
        """
        VolumeClaimResourceRequirements properties
        :param Mapping[str, builtins.str] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, builtins.str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class VolumeClaimSpecResponse(dict):
    """
    VolumeClaimSpec properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessModes":
            suggest = "access_modes"
        elif key == "dataSource":
            suggest = "data_source"
        elif key == "dataSourceRef":
            suggest = "data_source_ref"
        elif key == "storageClassName":
            suggest = "storage_class_name"
        elif key == "volumeMode":
            suggest = "volume_mode"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeClaimSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeClaimSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeClaimSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_modes: Optional[Sequence[builtins.str]] = None,
                 data_source: Optional['outputs.LocalKubernetesReferenceResponse'] = None,
                 data_source_ref: Optional['outputs.KubernetesReferenceResponse'] = None,
                 resources: Optional['outputs.VolumeClaimResourceRequirementsResponse'] = None,
                 selector: Optional['outputs.VolumeClaimSpecSelectorResponse'] = None,
                 storage_class_name: Optional[builtins.str] = None,
                 volume_mode: Optional[builtins.str] = None,
                 volume_name: Optional[builtins.str] = None):
        """
        VolumeClaimSpec properties
        :param Sequence[builtins.str] access_modes: AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        :param 'LocalKubernetesReferenceResponse' data_source: This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        :param 'KubernetesReferenceResponse' data_source_ref: Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        :param 'VolumeClaimResourceRequirementsResponse' resources: Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param 'VolumeClaimSpecSelectorResponse' selector: A label query over volumes to consider for binding.
        :param builtins.str storage_class_name: Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        :param builtins.str volume_mode: volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        :param builtins.str volume_name: VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        if access_modes is not None:
            pulumi.set(__self__, "access_modes", access_modes)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if data_source_ref is not None:
            pulumi.set(__self__, "data_source_ref", data_source_ref)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)
        if volume_mode is not None:
            pulumi.set(__self__, "volume_mode", volume_mode)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Optional[Sequence[builtins.str]]:
        """
        AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional['outputs.LocalKubernetesReferenceResponse']:
        """
        This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="dataSourceRef")
    def data_source_ref(self) -> Optional['outputs.KubernetesReferenceResponse']:
        """
        Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        """
        return pulumi.get(self, "data_source_ref")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.VolumeClaimResourceRequirementsResponse']:
        """
        Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.VolumeClaimSpecSelectorResponse']:
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[builtins.str]:
        """
        Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        """
        return pulumi.get(self, "storage_class_name")

    @property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> Optional[builtins.str]:
        """
        volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
        """
        return pulumi.get(self, "volume_mode")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[builtins.str]:
        """
        VolumeName is the binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class VolumeClaimSpecSelectorMatchExpressionsResponse(dict):
    """
    VolumeClaimSpecSelectorMatchExpressions properties
    """
    def __init__(__self__, *,
                 key: builtins.str,
                 operator: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        """
        VolumeClaimSpecSelectorMatchExpressions properties
        :param builtins.str key: key is the label key that the selector applies to.
        :param builtins.str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[builtins.str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> builtins.str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class VolumeClaimSpecSelectorResponse(dict):
    """
    VolumeClaimSpecSelector properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeClaimSpecSelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeClaimSpecSelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeClaimSpecSelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.VolumeClaimSpecSelectorMatchExpressionsResponse']] = None,
                 match_labels: Optional[Mapping[str, builtins.str]] = None):
        """
        VolumeClaimSpecSelector properties
        :param Sequence['VolumeClaimSpecSelectorMatchExpressionsResponse'] match_expressions: MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, builtins.str] match_labels: MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.VolumeClaimSpecSelectorMatchExpressionsResponse']]:
        """
        MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class X509ManualCertificateResponse(dict):
    """
    X509 Certificate Authentication properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in X509ManualCertificateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        X509ManualCertificateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        X509ManualCertificateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: builtins.str):
        """
        X509 Certificate Authentication properties.
        :param builtins.str secret_ref: Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> builtins.str:
        """
        Kubernetes secret containing an X.509 client certificate. This is a reference to the secret through an identifying name, not the secret itself.
        """
        return pulumi.get(self, "secret_ref")


