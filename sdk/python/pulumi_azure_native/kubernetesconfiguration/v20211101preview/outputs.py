# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'DependsOnDefinitionResponse',
    'GitRepositoryDefinitionResponse',
    'HelmReleasePropertiesDefinitionResponse',
    'KustomizationDefinitionResponse',
    'ObjectReferenceDefinitionResponse',
    'ObjectStatusConditionDefinitionResponse',
    'ObjectStatusDefinitionResponse',
    'RepositoryRefDefinitionResponse',
    'SystemDataResponse',
]

@pulumi.output_type
class DependsOnDefinitionResponse(dict):
    """
    Specify which kustomizations must succeed reconciliation on the cluster prior to reconciling this kustomization
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kustomizationName":
            suggest = "kustomization_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DependsOnDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DependsOnDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DependsOnDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kustomization_name: Optional[str] = None):
        """
        Specify which kustomizations must succeed reconciliation on the cluster prior to reconciling this kustomization
        :param str kustomization_name: Name of the kustomization to claim dependency on
        """
        DependsOnDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kustomization_name=kustomization_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kustomization_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if kustomization_name is None and 'kustomizationName' in kwargs:
            kustomization_name = kwargs['kustomizationName']

        if kustomization_name is not None:
            _setter("kustomization_name", kustomization_name)

    @property
    @pulumi.getter(name="kustomizationName")
    def kustomization_name(self) -> Optional[str]:
        """
        Name of the kustomization to claim dependency on
        """
        return pulumi.get(self, "kustomization_name")


@pulumi.output_type
class GitRepositoryDefinitionResponse(dict):
    """
    Parameters to reconcile to the GitRepository source kind type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpsCAFile":
            suggest = "https_ca_file"
        elif key == "httpsUser":
            suggest = "https_user"
        elif key == "localAuthRef":
            suggest = "local_auth_ref"
        elif key == "repositoryRef":
            suggest = "repository_ref"
        elif key == "sshKnownHosts":
            suggest = "ssh_known_hosts"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitRepositoryDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitRepositoryDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitRepositoryDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 https_ca_file: Optional[str] = None,
                 https_user: Optional[str] = None,
                 local_auth_ref: Optional[str] = None,
                 repository_ref: Optional['outputs.RepositoryRefDefinitionResponse'] = None,
                 ssh_known_hosts: Optional[str] = None,
                 sync_interval_in_seconds: Optional[float] = None,
                 timeout_in_seconds: Optional[float] = None,
                 url: Optional[str] = None):
        """
        Parameters to reconcile to the GitRepository source kind type.
        :param str https_ca_file: Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS
        :param str https_user: Base64-encoded HTTPS username used to access private git repositories over HTTPS
        :param str local_auth_ref: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param 'RepositoryRefDefinitionResponse' repository_ref: The source reference for the GitRepository object.
        :param str ssh_known_hosts: Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH
        :param float sync_interval_in_seconds: The interval at which to re-reconcile the cluster git repository source with the remote.
        :param float timeout_in_seconds: The maximum time to attempt to reconcile the cluster git repository source with the remote.
        :param str url: The URL to sync for the flux configuration git repository.
        """
        GitRepositoryDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            https_ca_file=https_ca_file,
            https_user=https_user,
            local_auth_ref=local_auth_ref,
            repository_ref=repository_ref,
            ssh_known_hosts=ssh_known_hosts,
            sync_interval_in_seconds=sync_interval_in_seconds,
            timeout_in_seconds=timeout_in_seconds,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             https_ca_file: Optional[str] = None,
             https_user: Optional[str] = None,
             local_auth_ref: Optional[str] = None,
             repository_ref: Optional['outputs.RepositoryRefDefinitionResponse'] = None,
             ssh_known_hosts: Optional[str] = None,
             sync_interval_in_seconds: Optional[float] = None,
             timeout_in_seconds: Optional[float] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if https_ca_file is None and 'httpsCAFile' in kwargs:
            https_ca_file = kwargs['httpsCAFile']
        if https_user is None and 'httpsUser' in kwargs:
            https_user = kwargs['httpsUser']
        if local_auth_ref is None and 'localAuthRef' in kwargs:
            local_auth_ref = kwargs['localAuthRef']
        if repository_ref is None and 'repositoryRef' in kwargs:
            repository_ref = kwargs['repositoryRef']
        if ssh_known_hosts is None and 'sshKnownHosts' in kwargs:
            ssh_known_hosts = kwargs['sshKnownHosts']
        if sync_interval_in_seconds is None and 'syncIntervalInSeconds' in kwargs:
            sync_interval_in_seconds = kwargs['syncIntervalInSeconds']
        if timeout_in_seconds is None and 'timeoutInSeconds' in kwargs:
            timeout_in_seconds = kwargs['timeoutInSeconds']

        if https_ca_file is not None:
            _setter("https_ca_file", https_ca_file)
        if https_user is not None:
            _setter("https_user", https_user)
        if local_auth_ref is not None:
            _setter("local_auth_ref", local_auth_ref)
        if repository_ref is not None:
            _setter("repository_ref", repository_ref)
        if ssh_known_hosts is not None:
            _setter("ssh_known_hosts", ssh_known_hosts)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            _setter("sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            _setter("timeout_in_seconds", timeout_in_seconds)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter(name="httpsCAFile")
    def https_ca_file(self) -> Optional[str]:
        """
        Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS
        """
        return pulumi.get(self, "https_ca_file")

    @property
    @pulumi.getter(name="httpsUser")
    def https_user(self) -> Optional[str]:
        """
        Base64-encoded HTTPS username used to access private git repositories over HTTPS
        """
        return pulumi.get(self, "https_user")

    @property
    @pulumi.getter(name="localAuthRef")
    def local_auth_ref(self) -> Optional[str]:
        """
        Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_ref")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional['outputs.RepositoryRefDefinitionResponse']:
        """
        The source reference for the GitRepository object.
        """
        return pulumi.get(self, "repository_ref")

    @property
    @pulumi.getter(name="sshKnownHosts")
    def ssh_known_hosts(self) -> Optional[str]:
        """
        Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH
        """
        return pulumi.get(self, "ssh_known_hosts")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[float]:
        """
        The interval at which to re-reconcile the cluster git repository source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[float]:
        """
        The maximum time to attempt to reconcile the cluster git repository source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to sync for the flux configuration git repository.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class HelmReleasePropertiesDefinitionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCount":
            suggest = "failure_count"
        elif key == "helmChartRef":
            suggest = "helm_chart_ref"
        elif key == "installFailureCount":
            suggest = "install_failure_count"
        elif key == "lastRevisionApplied":
            suggest = "last_revision_applied"
        elif key == "upgradeFailureCount":
            suggest = "upgrade_failure_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HelmReleasePropertiesDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HelmReleasePropertiesDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HelmReleasePropertiesDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_count: Optional[float] = None,
                 helm_chart_ref: Optional['outputs.ObjectReferenceDefinitionResponse'] = None,
                 install_failure_count: Optional[float] = None,
                 last_revision_applied: Optional[float] = None,
                 upgrade_failure_count: Optional[float] = None):
        """
        :param float failure_count: Total number of times that the HelmRelease failed to install or upgrade
        :param 'ObjectReferenceDefinitionResponse' helm_chart_ref: The reference to the HelmChart object used as the source to this HelmRelease
        :param float install_failure_count: Number of times that the HelmRelease failed to install
        :param float last_revision_applied: The revision number of the last released object change
        :param float upgrade_failure_count: Number of times that the HelmRelease failed to upgrade
        """
        HelmReleasePropertiesDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_count=failure_count,
            helm_chart_ref=helm_chart_ref,
            install_failure_count=install_failure_count,
            last_revision_applied=last_revision_applied,
            upgrade_failure_count=upgrade_failure_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_count: Optional[float] = None,
             helm_chart_ref: Optional['outputs.ObjectReferenceDefinitionResponse'] = None,
             install_failure_count: Optional[float] = None,
             last_revision_applied: Optional[float] = None,
             upgrade_failure_count: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_count is None and 'failureCount' in kwargs:
            failure_count = kwargs['failureCount']
        if helm_chart_ref is None and 'helmChartRef' in kwargs:
            helm_chart_ref = kwargs['helmChartRef']
        if install_failure_count is None and 'installFailureCount' in kwargs:
            install_failure_count = kwargs['installFailureCount']
        if last_revision_applied is None and 'lastRevisionApplied' in kwargs:
            last_revision_applied = kwargs['lastRevisionApplied']
        if upgrade_failure_count is None and 'upgradeFailureCount' in kwargs:
            upgrade_failure_count = kwargs['upgradeFailureCount']

        if failure_count is not None:
            _setter("failure_count", failure_count)
        if helm_chart_ref is not None:
            _setter("helm_chart_ref", helm_chart_ref)
        if install_failure_count is not None:
            _setter("install_failure_count", install_failure_count)
        if last_revision_applied is not None:
            _setter("last_revision_applied", last_revision_applied)
        if upgrade_failure_count is not None:
            _setter("upgrade_failure_count", upgrade_failure_count)

    @property
    @pulumi.getter(name="failureCount")
    def failure_count(self) -> Optional[float]:
        """
        Total number of times that the HelmRelease failed to install or upgrade
        """
        return pulumi.get(self, "failure_count")

    @property
    @pulumi.getter(name="helmChartRef")
    def helm_chart_ref(self) -> Optional['outputs.ObjectReferenceDefinitionResponse']:
        """
        The reference to the HelmChart object used as the source to this HelmRelease
        """
        return pulumi.get(self, "helm_chart_ref")

    @property
    @pulumi.getter(name="installFailureCount")
    def install_failure_count(self) -> Optional[float]:
        """
        Number of times that the HelmRelease failed to install
        """
        return pulumi.get(self, "install_failure_count")

    @property
    @pulumi.getter(name="lastRevisionApplied")
    def last_revision_applied(self) -> Optional[float]:
        """
        The revision number of the last released object change
        """
        return pulumi.get(self, "last_revision_applied")

    @property
    @pulumi.getter(name="upgradeFailureCount")
    def upgrade_failure_count(self) -> Optional[float]:
        """
        Number of times that the HelmRelease failed to upgrade
        """
        return pulumi.get(self, "upgrade_failure_count")


@pulumi.output_type
class KustomizationDefinitionResponse(dict):
    """
    The Kustomization defining how to reconcile the artifact pulled by the source type on the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependsOn":
            suggest = "depends_on"
        elif key == "retryIntervalInSeconds":
            suggest = "retry_interval_in_seconds"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KustomizationDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KustomizationDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KustomizationDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 depends_on: Optional[Sequence['outputs.DependsOnDefinitionResponse']] = None,
                 force: Optional[bool] = None,
                 path: Optional[str] = None,
                 prune: Optional[bool] = None,
                 retry_interval_in_seconds: Optional[float] = None,
                 sync_interval_in_seconds: Optional[float] = None,
                 timeout_in_seconds: Optional[float] = None,
                 validation: Optional[str] = None):
        """
        The Kustomization defining how to reconcile the artifact pulled by the source type on the cluster.
        :param Sequence['DependsOnDefinitionResponse'] depends_on: Specifies other Kustomizations that this Kustomization depends on. This Kustomization will not reconcile until all dependencies have completed their reconciliation.
        :param bool force: Enable/disable re-creating Kubernetes resources on the cluster when patching fails due to an immutable field change.
        :param str path: The path in the source reference to reconcile on the cluster.
        :param bool prune: Enable/disable garbage collections of Kubernetes objects created by this Kustomization.
        :param float retry_interval_in_seconds: The interval at which to re-reconcile the Kustomization on the cluster in the event of failure on reconciliation.
        :param float sync_interval_in_seconds: The interval at which to re-reconcile the Kustomization on the cluster.
        :param float timeout_in_seconds: The maximum time to attempt to reconcile the Kustomization on the cluster.
        :param str validation: Specify whether to validate the Kubernetes objects referenced in the Kustomization before applying them to the cluster.
        """
        KustomizationDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            depends_on=depends_on,
            force=force,
            path=path,
            prune=prune,
            retry_interval_in_seconds=retry_interval_in_seconds,
            sync_interval_in_seconds=sync_interval_in_seconds,
            timeout_in_seconds=timeout_in_seconds,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             depends_on: Optional[Sequence['outputs.DependsOnDefinitionResponse']] = None,
             force: Optional[bool] = None,
             path: Optional[str] = None,
             prune: Optional[bool] = None,
             retry_interval_in_seconds: Optional[float] = None,
             sync_interval_in_seconds: Optional[float] = None,
             timeout_in_seconds: Optional[float] = None,
             validation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if depends_on is None and 'dependsOn' in kwargs:
            depends_on = kwargs['dependsOn']
        if retry_interval_in_seconds is None and 'retryIntervalInSeconds' in kwargs:
            retry_interval_in_seconds = kwargs['retryIntervalInSeconds']
        if sync_interval_in_seconds is None and 'syncIntervalInSeconds' in kwargs:
            sync_interval_in_seconds = kwargs['syncIntervalInSeconds']
        if timeout_in_seconds is None and 'timeoutInSeconds' in kwargs:
            timeout_in_seconds = kwargs['timeoutInSeconds']

        if depends_on is not None:
            _setter("depends_on", depends_on)
        if force is None:
            force = False
        if force is not None:
            _setter("force", force)
        if path is None:
            path = ''
        if path is not None:
            _setter("path", path)
        if prune is None:
            prune = False
        if prune is not None:
            _setter("prune", prune)
        if retry_interval_in_seconds is not None:
            _setter("retry_interval_in_seconds", retry_interval_in_seconds)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            _setter("sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            _setter("timeout_in_seconds", timeout_in_seconds)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[Sequence['outputs.DependsOnDefinitionResponse']]:
        """
        Specifies other Kustomizations that this Kustomization depends on. This Kustomization will not reconcile until all dependencies have completed their reconciliation.
        """
        return pulumi.get(self, "depends_on")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        """
        Enable/disable re-creating Kubernetes resources on the cluster when patching fails due to an immutable field change.
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path in the source reference to reconcile on the cluster.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def prune(self) -> Optional[bool]:
        """
        Enable/disable garbage collections of Kubernetes objects created by this Kustomization.
        """
        return pulumi.get(self, "prune")

    @property
    @pulumi.getter(name="retryIntervalInSeconds")
    def retry_interval_in_seconds(self) -> Optional[float]:
        """
        The interval at which to re-reconcile the Kustomization on the cluster in the event of failure on reconciliation.
        """
        return pulumi.get(self, "retry_interval_in_seconds")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[float]:
        """
        The interval at which to re-reconcile the Kustomization on the cluster.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[float]:
        """
        The maximum time to attempt to reconcile the Kustomization on the cluster.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def validation(self) -> Optional[str]:
        """
        Specify whether to validate the Kubernetes objects referenced in the Kustomization before applying them to the cluster.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class ObjectReferenceDefinitionResponse(dict):
    """
    Object reference to a Kubernetes object on a cluster
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        Object reference to a Kubernetes object on a cluster
        :param str name: Name of the object
        :param str namespace: Namespace of the object
        """
        ObjectReferenceDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            namespace=namespace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             namespace: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if namespace is not None:
            _setter("namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the object
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the object
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ObjectStatusConditionDefinitionResponse(dict):
    """
    Status condition of Kubernetes object
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectStatusConditionDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectStatusConditionDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectStatusConditionDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Status condition of Kubernetes object
        :param str last_transition_time: Last time this status condition has changed
        :param str message: A more verbose description of the object status condition
        :param str reason: Reason for the specified status condition type status
        :param str status: Status of the Kubernetes object condition type
        :param str type: Object status condition type for this object
        """
        ObjectStatusConditionDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_transition_time=last_transition_time,
            message=message,
            reason=reason,
            status=status,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_transition_time: Optional[str] = None,
             message: Optional[str] = None,
             reason: Optional[str] = None,
             status: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if last_transition_time is None and 'lastTransitionTime' in kwargs:
            last_transition_time = kwargs['lastTransitionTime']

        if last_transition_time is not None:
            _setter("last_transition_time", last_transition_time)
        if message is not None:
            _setter("message", message)
        if reason is not None:
            _setter("reason", reason)
        if status is not None:
            _setter("status", status)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time this status condition has changed
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A more verbose description of the object status condition
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason for the specified status condition type status
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the Kubernetes object condition type
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Object status condition type for this object
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ObjectStatusDefinitionResponse(dict):
    """
    Statuses of objects deployed by the user-specified kustomizations from the git repository.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedBy":
            suggest = "applied_by"
        elif key == "complianceState":
            suggest = "compliance_state"
        elif key == "helmReleaseProperties":
            suggest = "helm_release_properties"
        elif key == "statusConditions":
            suggest = "status_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectStatusDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectStatusDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectStatusDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applied_by: Optional['outputs.ObjectReferenceDefinitionResponse'] = None,
                 compliance_state: Optional[str] = None,
                 helm_release_properties: Optional['outputs.HelmReleasePropertiesDefinitionResponse'] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 status_conditions: Optional[Sequence['outputs.ObjectStatusConditionDefinitionResponse']] = None):
        """
        Statuses of objects deployed by the user-specified kustomizations from the git repository.
        :param 'ObjectReferenceDefinitionResponse' applied_by: Object reference to the Kustomization that applied this object
        :param str compliance_state: Compliance state of the applied object showing whether the applied object has come into a ready state on the cluster.
        :param 'HelmReleasePropertiesDefinitionResponse' helm_release_properties: Additional properties that are provided from objects of the HelmRelease kind
        :param str kind: Kind of the applied object
        :param str name: Name of the applied object
        :param str namespace: Namespace of the applied object
        :param Sequence['ObjectStatusConditionDefinitionResponse'] status_conditions: List of Kubernetes object status conditions present on the cluster
        """
        ObjectStatusDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            applied_by=applied_by,
            compliance_state=compliance_state,
            helm_release_properties=helm_release_properties,
            kind=kind,
            name=name,
            namespace=namespace,
            status_conditions=status_conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             applied_by: Optional['outputs.ObjectReferenceDefinitionResponse'] = None,
             compliance_state: Optional[str] = None,
             helm_release_properties: Optional['outputs.HelmReleasePropertiesDefinitionResponse'] = None,
             kind: Optional[str] = None,
             name: Optional[str] = None,
             namespace: Optional[str] = None,
             status_conditions: Optional[Sequence['outputs.ObjectStatusConditionDefinitionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if applied_by is None and 'appliedBy' in kwargs:
            applied_by = kwargs['appliedBy']
        if compliance_state is None and 'complianceState' in kwargs:
            compliance_state = kwargs['complianceState']
        if helm_release_properties is None and 'helmReleaseProperties' in kwargs:
            helm_release_properties = kwargs['helmReleaseProperties']
        if status_conditions is None and 'statusConditions' in kwargs:
            status_conditions = kwargs['statusConditions']

        if applied_by is not None:
            _setter("applied_by", applied_by)
        if compliance_state is not None:
            _setter("compliance_state", compliance_state)
        if helm_release_properties is not None:
            _setter("helm_release_properties", helm_release_properties)
        if kind is not None:
            _setter("kind", kind)
        if name is not None:
            _setter("name", name)
        if namespace is not None:
            _setter("namespace", namespace)
        if status_conditions is not None:
            _setter("status_conditions", status_conditions)

    @property
    @pulumi.getter(name="appliedBy")
    def applied_by(self) -> Optional['outputs.ObjectReferenceDefinitionResponse']:
        """
        Object reference to the Kustomization that applied this object
        """
        return pulumi.get(self, "applied_by")

    @property
    @pulumi.getter(name="complianceState")
    def compliance_state(self) -> Optional[str]:
        """
        Compliance state of the applied object showing whether the applied object has come into a ready state on the cluster.
        """
        return pulumi.get(self, "compliance_state")

    @property
    @pulumi.getter(name="helmReleaseProperties")
    def helm_release_properties(self) -> Optional['outputs.HelmReleasePropertiesDefinitionResponse']:
        """
        Additional properties that are provided from objects of the HelmRelease kind
        """
        return pulumi.get(self, "helm_release_properties")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the applied object
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the applied object
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the applied object
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="statusConditions")
    def status_conditions(self) -> Optional[Sequence['outputs.ObjectStatusConditionDefinitionResponse']]:
        """
        List of Kubernetes object status conditions present on the cluster
        """
        return pulumi.get(self, "status_conditions")


@pulumi.output_type
class RepositoryRefDefinitionResponse(dict):
    """
    The source reference for the GitRepository object.
    """
    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 commit: Optional[str] = None,
                 semver: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        The source reference for the GitRepository object.
        :param str branch: The git repository branch name to checkout.
        :param str commit: The commit SHA to checkout. This value must be combined with the branch name to be valid. This takes precedence over semver.
        :param str semver: The semver range used to match against git repository tags. This takes precedence over tag.
        :param str tag: The git repository tag name to checkout. This takes precedence over branch.
        """
        RepositoryRefDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            branch=branch,
            commit=commit,
            semver=semver,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             branch: Optional[str] = None,
             commit: Optional[str] = None,
             semver: Optional[str] = None,
             tag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if branch is not None:
            _setter("branch", branch)
        if commit is not None:
            _setter("commit", commit)
        if semver is not None:
            _setter("semver", semver)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        The git repository branch name to checkout.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter
    def commit(self) -> Optional[str]:
        """
        The commit SHA to checkout. This value must be combined with the branch name to be valid. This takes precedence over semver.
        """
        return pulumi.get(self, "commit")

    @property
    @pulumi.getter
    def semver(self) -> Optional[str]:
        """
        The semver range used to match against git repository tags. This takes precedence over tag.
        """
        return pulumi.get(self, "semver")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The git repository tag name to checkout. This takes precedence over branch.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


