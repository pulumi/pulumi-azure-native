# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AzureBlobDefinitionResponse',
    'BucketDefinitionResponse',
    'GitRepositoryDefinitionResponse',
    'HelmReleasePropertiesDefinitionResponse',
    'KustomizationDefinitionResponse',
    'LayerSelectorDefinitionResponse',
    'ManagedIdentityDefinitionResponse',
    'MatchOidcIdentityDefinitionResponse',
    'OCIRepositoryDefinitionResponse',
    'OCIRepositoryRefDefinitionResponse',
    'ObjectReferenceDefinitionResponse',
    'ObjectStatusConditionDefinitionResponse',
    'ObjectStatusDefinitionResponse',
    'PostBuildDefinitionResponse',
    'RepositoryRefDefinitionResponse',
    'ServicePrincipalDefinitionResponse',
    'SubstituteFromDefinitionResponse',
    'SystemDataResponse',
    'TlsConfigDefinitionResponse',
    'VerifyDefinitionResponse',
]

@pulumi.output_type
class AzureBlobDefinitionResponse(dict):
    """
    Parameters to reconcile to the AzureBlob source kind type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountKey":
            suggest = "account_key"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "localAuthRef":
            suggest = "local_auth_ref"
        elif key == "managedIdentity":
            suggest = "managed_identity"
        elif key == "sasToken":
            suggest = "sas_token"
        elif key == "servicePrincipal":
            suggest = "service_principal"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBlobDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBlobDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBlobDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_key: Optional[str] = None,
                 container_name: Optional[str] = None,
                 local_auth_ref: Optional[str] = None,
                 managed_identity: Optional['outputs.ManagedIdentityDefinitionResponse'] = None,
                 sas_token: Optional[str] = None,
                 service_principal: Optional['outputs.ServicePrincipalDefinitionResponse'] = None,
                 sync_interval_in_seconds: Optional[float] = None,
                 timeout_in_seconds: Optional[float] = None,
                 url: Optional[str] = None):
        """
        Parameters to reconcile to the AzureBlob source kind type.
        :param str account_key: The account key (shared key) to access the storage account
        :param str container_name: The Azure Blob container name to sync from the url endpoint for the flux configuration.
        :param str local_auth_ref: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param 'ManagedIdentityDefinitionResponse' managed_identity: Parameters to authenticate using a Managed Identity.
        :param str sas_token: The Shared Access token to access the storage container
        :param 'ServicePrincipalDefinitionResponse' service_principal: Parameters to authenticate using Service Principal.
        :param float sync_interval_in_seconds: The interval at which to re-reconcile the cluster Azure Blob source with the remote.
        :param float timeout_in_seconds: The maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
        :param str url: The URL to sync for the flux configuration Azure Blob storage account.
        """
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if local_auth_ref is not None:
            pulumi.set(__self__, "local_auth_ref", local_auth_ref)
        if managed_identity is not None:
            pulumi.set(__self__, "managed_identity", managed_identity)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if service_principal is not None:
            pulumi.set(__self__, "service_principal", service_principal)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[str]:
        """
        The account key (shared key) to access the storage account
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        The Azure Blob container name to sync from the url endpoint for the flux configuration.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="localAuthRef")
    def local_auth_ref(self) -> Optional[str]:
        """
        Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_ref")

    @property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> Optional['outputs.ManagedIdentityDefinitionResponse']:
        """
        Parameters to authenticate using a Managed Identity.
        """
        return pulumi.get(self, "managed_identity")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[str]:
        """
        The Shared Access token to access the storage container
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="servicePrincipal")
    def service_principal(self) -> Optional['outputs.ServicePrincipalDefinitionResponse']:
        """
        Parameters to authenticate using Service Principal.
        """
        return pulumi.get(self, "service_principal")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[float]:
        """
        The interval at which to re-reconcile the cluster Azure Blob source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[float]:
        """
        The maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to sync for the flux configuration Azure Blob storage account.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class BucketDefinitionResponse(dict):
    """
    Parameters to reconcile to the Bucket source kind type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "localAuthRef":
            suggest = "local_auth_ref"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BucketDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BucketDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BucketDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 bucket_name: Optional[str] = None,
                 insecure: Optional[bool] = None,
                 local_auth_ref: Optional[str] = None,
                 sync_interval_in_seconds: Optional[float] = None,
                 timeout_in_seconds: Optional[float] = None,
                 url: Optional[str] = None):
        """
        Parameters to reconcile to the Bucket source kind type.
        :param str access_key: Plaintext access key used to securely access the S3 bucket
        :param str bucket_name: The bucket name to sync from the url endpoint for the flux configuration.
        :param bool insecure: Specify whether to use insecure communication when puling data from the S3 bucket.
        :param str local_auth_ref: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param float sync_interval_in_seconds: The interval at which to re-reconcile the cluster bucket source with the remote.
        :param float timeout_in_seconds: The maximum time to attempt to reconcile the cluster bucket source with the remote.
        :param str url: The URL to sync for the flux configuration S3 bucket.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if insecure is None:
            insecure = True
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if local_auth_ref is not None:
            pulumi.set(__self__, "local_auth_ref", local_auth_ref)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Plaintext access key used to securely access the S3 bucket
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The bucket name to sync from the url endpoint for the flux configuration.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Specify whether to use insecure communication when puling data from the S3 bucket.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter(name="localAuthRef")
    def local_auth_ref(self) -> Optional[str]:
        """
        Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_ref")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[float]:
        """
        The interval at which to re-reconcile the cluster bucket source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[float]:
        """
        The maximum time to attempt to reconcile the cluster bucket source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to sync for the flux configuration S3 bucket.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GitRepositoryDefinitionResponse(dict):
    """
    Parameters to reconcile to the GitRepository source kind type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpsCACert":
            suggest = "https_ca_cert"
        elif key == "httpsUser":
            suggest = "https_user"
        elif key == "localAuthRef":
            suggest = "local_auth_ref"
        elif key == "repositoryRef":
            suggest = "repository_ref"
        elif key == "sshKnownHosts":
            suggest = "ssh_known_hosts"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitRepositoryDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitRepositoryDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitRepositoryDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 https_ca_cert: Optional[str] = None,
                 https_user: Optional[str] = None,
                 local_auth_ref: Optional[str] = None,
                 repository_ref: Optional['outputs.RepositoryRefDefinitionResponse'] = None,
                 ssh_known_hosts: Optional[str] = None,
                 sync_interval_in_seconds: Optional[float] = None,
                 timeout_in_seconds: Optional[float] = None,
                 url: Optional[str] = None):
        """
        Parameters to reconcile to the GitRepository source kind type.
        :param str https_ca_cert: Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS
        :param str https_user: Plaintext HTTPS username used to access private git repositories over HTTPS
        :param str local_auth_ref: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param 'RepositoryRefDefinitionResponse' repository_ref: The source reference for the GitRepository object.
        :param str ssh_known_hosts: Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH
        :param float sync_interval_in_seconds: The interval at which to re-reconcile the cluster git repository source with the remote.
        :param float timeout_in_seconds: The maximum time to attempt to reconcile the cluster git repository source with the remote.
        :param str url: The URL to sync for the flux configuration git repository.
        """
        if https_ca_cert is not None:
            pulumi.set(__self__, "https_ca_cert", https_ca_cert)
        if https_user is not None:
            pulumi.set(__self__, "https_user", https_user)
        if local_auth_ref is not None:
            pulumi.set(__self__, "local_auth_ref", local_auth_ref)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)
        if ssh_known_hosts is not None:
            pulumi.set(__self__, "ssh_known_hosts", ssh_known_hosts)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="httpsCACert")
    def https_ca_cert(self) -> Optional[str]:
        """
        Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS
        """
        return pulumi.get(self, "https_ca_cert")

    @property
    @pulumi.getter(name="httpsUser")
    def https_user(self) -> Optional[str]:
        """
        Plaintext HTTPS username used to access private git repositories over HTTPS
        """
        return pulumi.get(self, "https_user")

    @property
    @pulumi.getter(name="localAuthRef")
    def local_auth_ref(self) -> Optional[str]:
        """
        Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_ref")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional['outputs.RepositoryRefDefinitionResponse']:
        """
        The source reference for the GitRepository object.
        """
        return pulumi.get(self, "repository_ref")

    @property
    @pulumi.getter(name="sshKnownHosts")
    def ssh_known_hosts(self) -> Optional[str]:
        """
        Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH
        """
        return pulumi.get(self, "ssh_known_hosts")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[float]:
        """
        The interval at which to re-reconcile the cluster git repository source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[float]:
        """
        The maximum time to attempt to reconcile the cluster git repository source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to sync for the flux configuration git repository.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class HelmReleasePropertiesDefinitionResponse(dict):
    """
    Properties for HelmRelease objects
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCount":
            suggest = "failure_count"
        elif key == "helmChartRef":
            suggest = "helm_chart_ref"
        elif key == "installFailureCount":
            suggest = "install_failure_count"
        elif key == "lastRevisionApplied":
            suggest = "last_revision_applied"
        elif key == "upgradeFailureCount":
            suggest = "upgrade_failure_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HelmReleasePropertiesDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HelmReleasePropertiesDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HelmReleasePropertiesDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_count: Optional[float] = None,
                 helm_chart_ref: Optional['outputs.ObjectReferenceDefinitionResponse'] = None,
                 install_failure_count: Optional[float] = None,
                 last_revision_applied: Optional[float] = None,
                 upgrade_failure_count: Optional[float] = None):
        """
        Properties for HelmRelease objects
        :param float failure_count: Total number of times that the HelmRelease failed to install or upgrade
        :param 'ObjectReferenceDefinitionResponse' helm_chart_ref: The reference to the HelmChart object used as the source to this HelmRelease
        :param float install_failure_count: Number of times that the HelmRelease failed to install
        :param float last_revision_applied: The revision number of the last released object change
        :param float upgrade_failure_count: Number of times that the HelmRelease failed to upgrade
        """
        if failure_count is not None:
            pulumi.set(__self__, "failure_count", failure_count)
        if helm_chart_ref is not None:
            pulumi.set(__self__, "helm_chart_ref", helm_chart_ref)
        if install_failure_count is not None:
            pulumi.set(__self__, "install_failure_count", install_failure_count)
        if last_revision_applied is not None:
            pulumi.set(__self__, "last_revision_applied", last_revision_applied)
        if upgrade_failure_count is not None:
            pulumi.set(__self__, "upgrade_failure_count", upgrade_failure_count)

    @property
    @pulumi.getter(name="failureCount")
    def failure_count(self) -> Optional[float]:
        """
        Total number of times that the HelmRelease failed to install or upgrade
        """
        return pulumi.get(self, "failure_count")

    @property
    @pulumi.getter(name="helmChartRef")
    def helm_chart_ref(self) -> Optional['outputs.ObjectReferenceDefinitionResponse']:
        """
        The reference to the HelmChart object used as the source to this HelmRelease
        """
        return pulumi.get(self, "helm_chart_ref")

    @property
    @pulumi.getter(name="installFailureCount")
    def install_failure_count(self) -> Optional[float]:
        """
        Number of times that the HelmRelease failed to install
        """
        return pulumi.get(self, "install_failure_count")

    @property
    @pulumi.getter(name="lastRevisionApplied")
    def last_revision_applied(self) -> Optional[float]:
        """
        The revision number of the last released object change
        """
        return pulumi.get(self, "last_revision_applied")

    @property
    @pulumi.getter(name="upgradeFailureCount")
    def upgrade_failure_count(self) -> Optional[float]:
        """
        Number of times that the HelmRelease failed to upgrade
        """
        return pulumi.get(self, "upgrade_failure_count")


@pulumi.output_type
class KustomizationDefinitionResponse(dict):
    """
    The Kustomization defining how to reconcile the artifact pulled by the source type on the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependsOn":
            suggest = "depends_on"
        elif key == "postBuild":
            suggest = "post_build"
        elif key == "retryIntervalInSeconds":
            suggest = "retry_interval_in_seconds"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KustomizationDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KustomizationDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KustomizationDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 depends_on: Optional[Sequence[str]] = None,
                 force: Optional[bool] = None,
                 path: Optional[str] = None,
                 post_build: Optional['outputs.PostBuildDefinitionResponse'] = None,
                 prune: Optional[bool] = None,
                 retry_interval_in_seconds: Optional[float] = None,
                 sync_interval_in_seconds: Optional[float] = None,
                 timeout_in_seconds: Optional[float] = None,
                 wait: Optional[bool] = None):
        """
        The Kustomization defining how to reconcile the artifact pulled by the source type on the cluster.
        :param str name: Name of the Kustomization, matching the key in the Kustomizations object map.
        :param Sequence[str] depends_on: Specifies other Kustomizations that this Kustomization depends on. This Kustomization will not reconcile until all dependencies have completed their reconciliation.
        :param bool force: Enable/disable re-creating Kubernetes resources on the cluster when patching fails due to an immutable field change.
        :param str path: The path in the source reference to reconcile on the cluster.
        :param 'PostBuildDefinitionResponse' post_build: Used for variable substitution for this Kustomization after kustomize build.
        :param bool prune: Enable/disable garbage collections of Kubernetes objects created by this Kustomization.
        :param float retry_interval_in_seconds: The interval at which to re-reconcile the Kustomization on the cluster in the event of failure on reconciliation.
        :param float sync_interval_in_seconds: The interval at which to re-reconcile the Kustomization on the cluster.
        :param float timeout_in_seconds: The maximum time to attempt to reconcile the Kustomization on the cluster.
        :param bool wait: Enable/disable health check for all Kubernetes objects created by this Kustomization.
        """
        pulumi.set(__self__, "name", name)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if force is None:
            force = False
        if force is not None:
            pulumi.set(__self__, "force", force)
        if path is None:
            path = ''
        if path is not None:
            pulumi.set(__self__, "path", path)
        if post_build is not None:
            pulumi.set(__self__, "post_build", post_build)
        if prune is None:
            prune = False
        if prune is not None:
            pulumi.set(__self__, "prune", prune)
        if retry_interval_in_seconds is not None:
            pulumi.set(__self__, "retry_interval_in_seconds", retry_interval_in_seconds)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if wait is None:
            wait = True
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Kustomization, matching the key in the Kustomizations object map.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[Sequence[str]]:
        """
        Specifies other Kustomizations that this Kustomization depends on. This Kustomization will not reconcile until all dependencies have completed their reconciliation.
        """
        return pulumi.get(self, "depends_on")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        """
        Enable/disable re-creating Kubernetes resources on the cluster when patching fails due to an immutable field change.
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path in the source reference to reconcile on the cluster.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="postBuild")
    def post_build(self) -> Optional['outputs.PostBuildDefinitionResponse']:
        """
        Used for variable substitution for this Kustomization after kustomize build.
        """
        return pulumi.get(self, "post_build")

    @property
    @pulumi.getter
    def prune(self) -> Optional[bool]:
        """
        Enable/disable garbage collections of Kubernetes objects created by this Kustomization.
        """
        return pulumi.get(self, "prune")

    @property
    @pulumi.getter(name="retryIntervalInSeconds")
    def retry_interval_in_seconds(self) -> Optional[float]:
        """
        The interval at which to re-reconcile the Kustomization on the cluster in the event of failure on reconciliation.
        """
        return pulumi.get(self, "retry_interval_in_seconds")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[float]:
        """
        The interval at which to re-reconcile the Kustomization on the cluster.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[float]:
        """
        The maximum time to attempt to reconcile the Kustomization on the cluster.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def wait(self) -> Optional[bool]:
        """
        Enable/disable health check for all Kubernetes objects created by this Kustomization.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class LayerSelectorDefinitionResponse(dict):
    """
    Parameters to specify which layer to pull from the OCI artifact. By default, the first layer in the artifact is pulled.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LayerSelectorDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LayerSelectorDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LayerSelectorDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 media_type: Optional[str] = None,
                 operation: Optional[str] = None):
        """
        Parameters to specify which layer to pull from the OCI artifact. By default, the first layer in the artifact is pulled.
        :param str media_type: The first layer matching the specified media type will be used.
        :param str operation: The operation to be performed on the selected layer. The default value is 'extract', but it can be set to 'copy'.
        """
        if media_type is not None:
            pulumi.set(__self__, "media_type", media_type)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> Optional[str]:
        """
        The first layer matching the specified media type will be used.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def operation(self) -> Optional[str]:
        """
        The operation to be performed on the selected layer. The default value is 'extract', but it can be set to 'copy'.
        """
        return pulumi.get(self, "operation")


@pulumi.output_type
class ManagedIdentityDefinitionResponse(dict):
    """
    Parameters to authenticate using a Managed Identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None):
        """
        Parameters to authenticate using a Managed Identity.
        :param str client_id: The client Id for authenticating a Managed Identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client Id for authenticating a Managed Identity.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class MatchOidcIdentityDefinitionResponse(dict):
    """
    MatchOIDCIdentity defines the criteria for matching the identity while verifying an OCI artifact.
    """
    def __init__(__self__, *,
                 issuer: Optional[str] = None,
                 subject: Optional[str] = None):
        """
        MatchOIDCIdentity defines the criteria for matching the identity while verifying an OCI artifact.
        :param str issuer: The regex pattern to match against to verify the OIDC issuer.
        :param str subject: The regex pattern to match against to verify the identity subject.
        """
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The regex pattern to match against to verify the OIDC issuer.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        """
        The regex pattern to match against to verify the identity subject.
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class OCIRepositoryDefinitionResponse(dict):
    """
    Parameters to reconcile to the OCIRepository source kind type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layerSelector":
            suggest = "layer_selector"
        elif key == "localAuthRef":
            suggest = "local_auth_ref"
        elif key == "repositoryRef":
            suggest = "repository_ref"
        elif key == "serviceAccountName":
            suggest = "service_account_name"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"
        elif key == "tlsConfig":
            suggest = "tls_config"
        elif key == "useWorkloadIdentity":
            suggest = "use_workload_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OCIRepositoryDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OCIRepositoryDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OCIRepositoryDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insecure: Optional[bool] = None,
                 layer_selector: Optional['outputs.LayerSelectorDefinitionResponse'] = None,
                 local_auth_ref: Optional[str] = None,
                 repository_ref: Optional['outputs.OCIRepositoryRefDefinitionResponse'] = None,
                 service_account_name: Optional[str] = None,
                 sync_interval_in_seconds: Optional[float] = None,
                 timeout_in_seconds: Optional[float] = None,
                 tls_config: Optional['outputs.TlsConfigDefinitionResponse'] = None,
                 url: Optional[str] = None,
                 use_workload_identity: Optional[bool] = None,
                 verify: Optional['outputs.VerifyDefinitionResponse'] = None):
        """
        Parameters to reconcile to the OCIRepository source kind type.
        :param bool insecure: Specify whether to allow connecting to a non-TLS HTTP container registry.
        :param 'LayerSelectorDefinitionResponse' layer_selector: The layer to be pulled from the OCI artifact.
        :param str local_auth_ref: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param 'OCIRepositoryRefDefinitionResponse' repository_ref: The source reference for the OCIRepository object.
        :param str service_account_name: The service account name to authenticate with the OCI repository.
        :param float sync_interval_in_seconds: The interval at which to re-reconcile the cluster OCI repository source with the remote.
        :param float timeout_in_seconds: The maximum time to attempt to reconcile the cluster OCI repository source with the remote.
        :param 'TlsConfigDefinitionResponse' tls_config: Parameters to authenticate using TLS config for OCI repository.
        :param str url: The URL to sync for the flux configuration OCI repository.
        :param bool use_workload_identity: Specifies whether to use Workload Identity to authenticate with the OCI repository.
        :param 'VerifyDefinitionResponse' verify: Verification of the authenticity of an OCI Artifact.
        """
        if insecure is None:
            insecure = False
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if layer_selector is not None:
            pulumi.set(__self__, "layer_selector", layer_selector)
        if local_auth_ref is not None:
            pulumi.set(__self__, "local_auth_ref", local_auth_ref)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)
        if service_account_name is not None:
            pulumi.set(__self__, "service_account_name", service_account_name)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if use_workload_identity is None:
            use_workload_identity = False
        if use_workload_identity is not None:
            pulumi.set(__self__, "use_workload_identity", use_workload_identity)
        if verify is not None:
            pulumi.set(__self__, "verify", verify)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Specify whether to allow connecting to a non-TLS HTTP container registry.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter(name="layerSelector")
    def layer_selector(self) -> Optional['outputs.LayerSelectorDefinitionResponse']:
        """
        The layer to be pulled from the OCI artifact.
        """
        return pulumi.get(self, "layer_selector")

    @property
    @pulumi.getter(name="localAuthRef")
    def local_auth_ref(self) -> Optional[str]:
        """
        Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_ref")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional['outputs.OCIRepositoryRefDefinitionResponse']:
        """
        The source reference for the OCIRepository object.
        """
        return pulumi.get(self, "repository_ref")

    @property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> Optional[str]:
        """
        The service account name to authenticate with the OCI repository.
        """
        return pulumi.get(self, "service_account_name")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[float]:
        """
        The interval at which to re-reconcile the cluster OCI repository source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[float]:
        """
        The maximum time to attempt to reconcile the cluster OCI repository source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional['outputs.TlsConfigDefinitionResponse']:
        """
        Parameters to authenticate using TLS config for OCI repository.
        """
        return pulumi.get(self, "tls_config")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to sync for the flux configuration OCI repository.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="useWorkloadIdentity")
    def use_workload_identity(self) -> Optional[bool]:
        """
        Specifies whether to use Workload Identity to authenticate with the OCI repository.
        """
        return pulumi.get(self, "use_workload_identity")

    @property
    @pulumi.getter
    def verify(self) -> Optional['outputs.VerifyDefinitionResponse']:
        """
        Verification of the authenticity of an OCI Artifact.
        """
        return pulumi.get(self, "verify")


@pulumi.output_type
class OCIRepositoryRefDefinitionResponse(dict):
    """
    The source reference for the OCIRepository object.
    """
    def __init__(__self__, *,
                 digest: Optional[str] = None,
                 semver: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        The source reference for the OCIRepository object.
        :param str digest: The image digest to pull from OCI repository, the value should be in the format ‘sha256:’. This takes precedence over semver.
        :param str semver: The semver range used to match against OCI repository tags. This takes precedence over tag.
        :param str tag: The OCI repository image tag name to pull. This defaults to 'latest'.
        """
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if semver is not None:
            pulumi.set(__self__, "semver", semver)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        """
        The image digest to pull from OCI repository, the value should be in the format ‘sha256:’. This takes precedence over semver.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def semver(self) -> Optional[str]:
        """
        The semver range used to match against OCI repository tags. This takes precedence over tag.
        """
        return pulumi.get(self, "semver")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The OCI repository image tag name to pull. This defaults to 'latest'.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class ObjectReferenceDefinitionResponse(dict):
    """
    Object reference to a Kubernetes object on a cluster
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        Object reference to a Kubernetes object on a cluster
        :param str name: Name of the object
        :param str namespace: Namespace of the object
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the object
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the object
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ObjectStatusConditionDefinitionResponse(dict):
    """
    Status condition of Kubernetes object
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectStatusConditionDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectStatusConditionDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectStatusConditionDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Status condition of Kubernetes object
        :param str last_transition_time: Last time this status condition has changed
        :param str message: A more verbose description of the object status condition
        :param str reason: Reason for the specified status condition type status
        :param str status: Status of the Kubernetes object condition type
        :param str type: Object status condition type for this object
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time this status condition has changed
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A more verbose description of the object status condition
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason for the specified status condition type status
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the Kubernetes object condition type
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Object status condition type for this object
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ObjectStatusDefinitionResponse(dict):
    """
    Statuses of objects deployed by the user-specified kustomizations from the git repository.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedBy":
            suggest = "applied_by"
        elif key == "complianceState":
            suggest = "compliance_state"
        elif key == "helmReleaseProperties":
            suggest = "helm_release_properties"
        elif key == "statusConditions":
            suggest = "status_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectStatusDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectStatusDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectStatusDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applied_by: Optional['outputs.ObjectReferenceDefinitionResponse'] = None,
                 compliance_state: Optional[str] = None,
                 helm_release_properties: Optional['outputs.HelmReleasePropertiesDefinitionResponse'] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 status_conditions: Optional[Sequence['outputs.ObjectStatusConditionDefinitionResponse']] = None):
        """
        Statuses of objects deployed by the user-specified kustomizations from the git repository.
        :param 'ObjectReferenceDefinitionResponse' applied_by: Object reference to the Kustomization that applied this object
        :param str compliance_state: Compliance state of the applied object showing whether the applied object has come into a ready state on the cluster.
        :param 'HelmReleasePropertiesDefinitionResponse' helm_release_properties: Additional properties that are provided from objects of the HelmRelease kind
        :param str kind: Kind of the applied object
        :param str name: Name of the applied object
        :param str namespace: Namespace of the applied object
        :param Sequence['ObjectStatusConditionDefinitionResponse'] status_conditions: List of Kubernetes object status conditions present on the cluster
        """
        if applied_by is not None:
            pulumi.set(__self__, "applied_by", applied_by)
        if compliance_state is not None:
            pulumi.set(__self__, "compliance_state", compliance_state)
        if helm_release_properties is not None:
            pulumi.set(__self__, "helm_release_properties", helm_release_properties)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if status_conditions is not None:
            pulumi.set(__self__, "status_conditions", status_conditions)

    @property
    @pulumi.getter(name="appliedBy")
    def applied_by(self) -> Optional['outputs.ObjectReferenceDefinitionResponse']:
        """
        Object reference to the Kustomization that applied this object
        """
        return pulumi.get(self, "applied_by")

    @property
    @pulumi.getter(name="complianceState")
    def compliance_state(self) -> Optional[str]:
        """
        Compliance state of the applied object showing whether the applied object has come into a ready state on the cluster.
        """
        return pulumi.get(self, "compliance_state")

    @property
    @pulumi.getter(name="helmReleaseProperties")
    def helm_release_properties(self) -> Optional['outputs.HelmReleasePropertiesDefinitionResponse']:
        """
        Additional properties that are provided from objects of the HelmRelease kind
        """
        return pulumi.get(self, "helm_release_properties")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the applied object
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the applied object
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the applied object
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="statusConditions")
    def status_conditions(self) -> Optional[Sequence['outputs.ObjectStatusConditionDefinitionResponse']]:
        """
        List of Kubernetes object status conditions present on the cluster
        """
        return pulumi.get(self, "status_conditions")


@pulumi.output_type
class PostBuildDefinitionResponse(dict):
    """
    The postBuild definitions defining variable substitutions for this Kustomization after kustomize build.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "substituteFrom":
            suggest = "substitute_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PostBuildDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PostBuildDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PostBuildDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 substitute: Optional[Mapping[str, str]] = None,
                 substitute_from: Optional[Sequence['outputs.SubstituteFromDefinitionResponse']] = None):
        """
        The postBuild definitions defining variable substitutions for this Kustomization after kustomize build.
        :param Mapping[str, str] substitute: Key/value pairs holding the variables to be substituted in this Kustomization.
        :param Sequence['SubstituteFromDefinitionResponse'] substitute_from: Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
        """
        if substitute is not None:
            pulumi.set(__self__, "substitute", substitute)
        if substitute_from is not None:
            pulumi.set(__self__, "substitute_from", substitute_from)

    @property
    @pulumi.getter
    def substitute(self) -> Optional[Mapping[str, str]]:
        """
        Key/value pairs holding the variables to be substituted in this Kustomization.
        """
        return pulumi.get(self, "substitute")

    @property
    @pulumi.getter(name="substituteFrom")
    def substitute_from(self) -> Optional[Sequence['outputs.SubstituteFromDefinitionResponse']]:
        """
        Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
        """
        return pulumi.get(self, "substitute_from")


@pulumi.output_type
class RepositoryRefDefinitionResponse(dict):
    """
    The source reference for the GitRepository object.
    """
    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 commit: Optional[str] = None,
                 semver: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        The source reference for the GitRepository object.
        :param str branch: The git repository branch name to checkout.
        :param str commit: The commit SHA to checkout. This value must be combined with the branch name to be valid. This takes precedence over semver.
        :param str semver: The semver range used to match against git repository tags. This takes precedence over tag.
        :param str tag: The git repository tag name to checkout. This takes precedence over branch.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit is not None:
            pulumi.set(__self__, "commit", commit)
        if semver is not None:
            pulumi.set(__self__, "semver", semver)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        The git repository branch name to checkout.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter
    def commit(self) -> Optional[str]:
        """
        The commit SHA to checkout. This value must be combined with the branch name to be valid. This takes precedence over semver.
        """
        return pulumi.get(self, "commit")

    @property
    @pulumi.getter
    def semver(self) -> Optional[str]:
        """
        The semver range used to match against git repository tags. This takes precedence over tag.
        """
        return pulumi.get(self, "semver")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        The git repository tag name to checkout. This takes precedence over branch.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class ServicePrincipalDefinitionResponse(dict):
    """
    Parameters to authenticate using Service Principal.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientCertificatePassword":
            suggest = "client_certificate_password"
        elif key == "clientCertificateSendChain":
            suggest = "client_certificate_send_chain"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicePrincipalDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicePrincipalDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicePrincipalDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: Optional[str] = None,
                 client_certificate_password: Optional[str] = None,
                 client_certificate_send_chain: Optional[bool] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        Parameters to authenticate using Service Principal.
        :param str client_certificate: Base64-encoded certificate used to authenticate a Service Principal 
        :param str client_certificate_password: The password for the certificate used to authenticate a Service Principal 
        :param bool client_certificate_send_chain: Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the Client Certificate
        :param str client_id: The client Id for authenticating a Service Principal.
        :param str client_secret: The client secret for authenticating a Service Principal
        :param str tenant_id: The tenant Id for authenticating a Service Principal
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_certificate_password is not None:
            pulumi.set(__self__, "client_certificate_password", client_certificate_password)
        if client_certificate_send_chain is None:
            client_certificate_send_chain = False
        if client_certificate_send_chain is not None:
            pulumi.set(__self__, "client_certificate_send_chain", client_certificate_send_chain)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Base64-encoded certificate used to authenticate a Service Principal 
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientCertificatePassword")
    def client_certificate_password(self) -> Optional[str]:
        """
        The password for the certificate used to authenticate a Service Principal 
        """
        return pulumi.get(self, "client_certificate_password")

    @property
    @pulumi.getter(name="clientCertificateSendChain")
    def client_certificate_send_chain(self) -> Optional[bool]:
        """
        Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the Client Certificate
        """
        return pulumi.get(self, "client_certificate_send_chain")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client Id for authenticating a Service Principal.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret for authenticating a Service Principal
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The tenant Id for authenticating a Service Principal
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SubstituteFromDefinitionResponse(dict):
    """
    Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
    """
    def __init__(__self__, *,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
        :param str kind: Define whether it is ConfigMap or Secret that holds the variables to be used in substitution.
        :param str name: Name of the ConfigMap/Secret that holds the variables to be used in substitution.
        :param bool optional: Set to True to proceed without ConfigMap/Secret, if it is not present.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is None:
            optional = False
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Define whether it is ConfigMap or Secret that holds the variables to be used in substitution.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ConfigMap/Secret that holds the variables to be used in substitution.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Set to True to proceed without ConfigMap/Secret, if it is not present.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TlsConfigDefinitionResponse(dict):
    """
    Parameters to authenticate using TLS config for OCI repository.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TlsConfigDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TlsConfigDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TlsConfigDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 private_key: Optional[str] = None):
        """
        Parameters to authenticate using TLS config for OCI repository.
        :param str ca_certificate: Base64-encoded CA certificate used to verify the server.
        :param str client_certificate: Base64-encoded certificate used to authenticate a client with the OCI repository.
        :param str private_key: Base64-encoded private key used to authenticate a client with the OCI repository.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        Base64-encoded CA certificate used to verify the server.
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Base64-encoded certificate used to authenticate a client with the OCI repository.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        Base64-encoded private key used to authenticate a client with the OCI repository.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class VerifyDefinitionResponse(dict):
    """
    Parameters to verify the authenticity of an OCI Artifact.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchOidcIdentity":
            suggest = "match_oidc_identity"
        elif key == "verificationConfig":
            suggest = "verification_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifyDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifyDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifyDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_oidc_identity: Optional[Sequence['outputs.MatchOidcIdentityDefinitionResponse']] = None,
                 provider: Optional[str] = None,
                 verification_config: Optional[Mapping[str, str]] = None):
        """
        Parameters to verify the authenticity of an OCI Artifact.
        :param Sequence['MatchOidcIdentityDefinitionResponse'] match_oidc_identity: Array defining the criteria for matching the identity while verifying an OCI artifact.
        :param str provider: Verification provider name.
        :param Mapping[str, str] verification_config: An object containing trusted public keys of trusted authors.
        """
        if match_oidc_identity is not None:
            pulumi.set(__self__, "match_oidc_identity", match_oidc_identity)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if verification_config is not None:
            pulumi.set(__self__, "verification_config", verification_config)

    @property
    @pulumi.getter(name="matchOidcIdentity")
    def match_oidc_identity(self) -> Optional[Sequence['outputs.MatchOidcIdentityDefinitionResponse']]:
        """
        Array defining the criteria for matching the identity while verifying an OCI artifact.
        """
        return pulumi.get(self, "match_oidc_identity")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Verification provider name.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="verificationConfig")
    def verification_config(self) -> Optional[Mapping[str, str]]:
        """
        An object containing trusted public keys of trusted authors.
        """
        return pulumi.get(self, "verification_config")


