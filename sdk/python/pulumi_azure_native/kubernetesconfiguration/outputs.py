# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AzureBlobDefinitionResponse',
    'BucketDefinitionResponse',
    'ComplianceStatusResponse',
    'ErrorAdditionalInfoResponse',
    'ErrorDetailResponse',
    'ExtensionResponseAksAssignedIdentity',
    'ExtensionStatusResponse',
    'GitRepositoryDefinitionResponse',
    'HelmOperatorPropertiesResponse',
    'HelmReleasePropertiesDefinitionResponse',
    'IdentityResponse',
    'KubernetesConfigurationPrivateLinkScopePropertiesResponse',
    'KustomizationDefinitionResponse',
    'ManagedIdentityDefinitionResponse',
    'ObjectReferenceDefinitionResponse',
    'ObjectStatusConditionDefinitionResponse',
    'ObjectStatusDefinitionResponse',
    'PlanResponse',
    'PostBuildDefinitionResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'RepositoryRefDefinitionResponse',
    'ScopeClusterResponse',
    'ScopeNamespaceResponse',
    'ScopeResponse',
    'ServicePrincipalDefinitionResponse',
    'SubstituteFromDefinitionResponse',
    'SystemDataResponse',
]

@pulumi.output_type
class AzureBlobDefinitionResponse(dict):
    """
    Parameters to reconcile to the AzureBlob source kind type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountKey":
            suggest = "account_key"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "localAuthRef":
            suggest = "local_auth_ref"
        elif key == "managedIdentity":
            suggest = "managed_identity"
        elif key == "sasToken":
            suggest = "sas_token"
        elif key == "servicePrincipal":
            suggest = "service_principal"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBlobDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBlobDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBlobDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_key: Optional[builtins.str] = None,
                 container_name: Optional[builtins.str] = None,
                 local_auth_ref: Optional[builtins.str] = None,
                 managed_identity: Optional['outputs.ManagedIdentityDefinitionResponse'] = None,
                 sas_token: Optional[builtins.str] = None,
                 service_principal: Optional['outputs.ServicePrincipalDefinitionResponse'] = None,
                 sync_interval_in_seconds: Optional[builtins.float] = None,
                 timeout_in_seconds: Optional[builtins.float] = None,
                 url: Optional[builtins.str] = None):
        """
        Parameters to reconcile to the AzureBlob source kind type.
        :param builtins.str account_key: The account key (shared key) to access the storage account
        :param builtins.str container_name: The Azure Blob container name to sync from the url endpoint for the flux configuration.
        :param builtins.str local_auth_ref: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param 'ManagedIdentityDefinitionResponse' managed_identity: Parameters to authenticate using a Managed Identity.
        :param builtins.str sas_token: The Shared Access token to access the storage container
        :param 'ServicePrincipalDefinitionResponse' service_principal: Parameters to authenticate using Service Principal.
        :param builtins.float sync_interval_in_seconds: The interval at which to re-reconcile the cluster Azure Blob source with the remote.
        :param builtins.float timeout_in_seconds: The maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
        :param builtins.str url: The URL to sync for the flux configuration Azure Blob storage account.
        """
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if local_auth_ref is not None:
            pulumi.set(__self__, "local_auth_ref", local_auth_ref)
        if managed_identity is not None:
            pulumi.set(__self__, "managed_identity", managed_identity)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if service_principal is not None:
            pulumi.set(__self__, "service_principal", service_principal)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[builtins.str]:
        """
        The account key (shared key) to access the storage account
        """
        return pulumi.get(self, "account_key")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[builtins.str]:
        """
        The Azure Blob container name to sync from the url endpoint for the flux configuration.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="localAuthRef")
    def local_auth_ref(self) -> Optional[builtins.str]:
        """
        Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_ref")

    @property
    @pulumi.getter(name="managedIdentity")
    def managed_identity(self) -> Optional['outputs.ManagedIdentityDefinitionResponse']:
        """
        Parameters to authenticate using a Managed Identity.
        """
        return pulumi.get(self, "managed_identity")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[builtins.str]:
        """
        The Shared Access token to access the storage container
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="servicePrincipal")
    def service_principal(self) -> Optional['outputs.ServicePrincipalDefinitionResponse']:
        """
        Parameters to authenticate using Service Principal.
        """
        return pulumi.get(self, "service_principal")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[builtins.float]:
        """
        The interval at which to re-reconcile the cluster Azure Blob source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[builtins.float]:
        """
        The maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        The URL to sync for the flux configuration Azure Blob storage account.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class BucketDefinitionResponse(dict):
    """
    Parameters to reconcile to the Bucket source kind type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "localAuthRef":
            suggest = "local_auth_ref"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BucketDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BucketDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BucketDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[builtins.str] = None,
                 bucket_name: Optional[builtins.str] = None,
                 insecure: Optional[builtins.bool] = None,
                 local_auth_ref: Optional[builtins.str] = None,
                 sync_interval_in_seconds: Optional[builtins.float] = None,
                 timeout_in_seconds: Optional[builtins.float] = None,
                 url: Optional[builtins.str] = None):
        """
        Parameters to reconcile to the Bucket source kind type.
        :param builtins.str access_key: Plaintext access key used to securely access the S3 bucket
        :param builtins.str bucket_name: The bucket name to sync from the url endpoint for the flux configuration.
        :param builtins.bool insecure: Specify whether to use insecure communication when puling data from the S3 bucket.
        :param builtins.str local_auth_ref: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param builtins.float sync_interval_in_seconds: The interval at which to re-reconcile the cluster bucket source with the remote.
        :param builtins.float timeout_in_seconds: The maximum time to attempt to reconcile the cluster bucket source with the remote.
        :param builtins.str url: The URL to sync for the flux configuration S3 bucket.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if insecure is None:
            insecure = True
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if local_auth_ref is not None:
            pulumi.set(__self__, "local_auth_ref", local_auth_ref)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Plaintext access key used to securely access the S3 bucket
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        """
        The bucket name to sync from the url endpoint for the flux configuration.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[builtins.bool]:
        """
        Specify whether to use insecure communication when puling data from the S3 bucket.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter(name="localAuthRef")
    def local_auth_ref(self) -> Optional[builtins.str]:
        """
        Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_ref")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[builtins.float]:
        """
        The interval at which to re-reconcile the cluster bucket source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[builtins.float]:
        """
        The maximum time to attempt to reconcile the cluster bucket source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        The URL to sync for the flux configuration S3 bucket.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ComplianceStatusResponse(dict):
    """
    Compliance Status details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "complianceState":
            suggest = "compliance_state"
        elif key == "lastConfigApplied":
            suggest = "last_config_applied"
        elif key == "messageLevel":
            suggest = "message_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComplianceStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComplianceStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComplianceStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compliance_state: builtins.str,
                 last_config_applied: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 message_level: Optional[builtins.str] = None):
        """
        Compliance Status details
        :param builtins.str compliance_state: The compliance state of the configuration.
        :param builtins.str last_config_applied: Datetime the configuration was last applied.
        :param builtins.str message: Message from when the configuration was applied.
        :param builtins.str message_level: Level of the message.
        """
        pulumi.set(__self__, "compliance_state", compliance_state)
        if last_config_applied is not None:
            pulumi.set(__self__, "last_config_applied", last_config_applied)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_level is not None:
            pulumi.set(__self__, "message_level", message_level)

    @property
    @pulumi.getter(name="complianceState")
    def compliance_state(self) -> builtins.str:
        """
        The compliance state of the configuration.
        """
        return pulumi.get(self, "compliance_state")

    @property
    @pulumi.getter(name="lastConfigApplied")
    def last_config_applied(self) -> Optional[builtins.str]:
        """
        Datetime the configuration was last applied.
        """
        return pulumi.get(self, "last_config_applied")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Message from when the configuration was applied.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="messageLevel")
    def message_level(self) -> Optional[builtins.str]:
        """
        Level of the message.
        """
        return pulumi.get(self, "message_level")


@pulumi.output_type
class ErrorAdditionalInfoResponse(dict):
    """
    The resource management error additional info.
    """
    def __init__(__self__, *,
                 info: Any,
                 type: builtins.str):
        """
        The resource management error additional info.
        :param Any info: The additional info.
        :param builtins.str type: The additional info type.
        """
        pulumi.set(__self__, "info", info)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def info(self) -> Any:
        """
        The additional info.
        """
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The additional info type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ErrorDetailResponse(dict):
    """
    The error detail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInfo":
            suggest = "additional_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ErrorDetailResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_info: Sequence['outputs.ErrorAdditionalInfoResponse'],
                 code: builtins.str,
                 details: Sequence['outputs.ErrorDetailResponse'],
                 message: builtins.str,
                 target: builtins.str):
        """
        The error detail.
        :param Sequence['ErrorAdditionalInfoResponse'] additional_info: The error additional info.
        :param builtins.str code: The error code.
        :param Sequence['ErrorDetailResponse'] details: The error details.
        :param builtins.str message: The error message.
        :param builtins.str target: The error target.
        """
        pulumi.set(__self__, "additional_info", additional_info)
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Sequence['outputs.ErrorAdditionalInfoResponse']:
        """
        The error additional info.
        """
        return pulumi.get(self, "additional_info")

    @property
    @pulumi.getter
    def code(self) -> builtins.str:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailResponse']:
        """
        The error details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        The error message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ExtensionResponseAksAssignedIdentity(dict):
    """
    Identity of the Extension resource in an AKS cluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExtensionResponseAksAssignedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExtensionResponseAksAssignedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExtensionResponseAksAssignedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: Optional[builtins.str] = None):
        """
        Identity of the Extension resource in an AKS cluster
        :param builtins.str principal_id: The principal ID of resource identity.
        :param builtins.str tenant_id: The tenant ID of resource.
        :param builtins.str type: The identity type.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ExtensionStatusResponse(dict):
    """
    Status from the extension.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayStatus":
            suggest = "display_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExtensionStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExtensionStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExtensionStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[builtins.str] = None,
                 display_status: Optional[builtins.str] = None,
                 level: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 time: Optional[builtins.str] = None):
        """
        Status from the extension.
        :param builtins.str code: Status code provided by the Extension
        :param builtins.str display_status: Short description of status of the extension.
        :param builtins.str level: Level of the status.
        :param builtins.str message: Detailed message of the status from the Extension.
        :param builtins.str time: DateLiteral (per ISO8601) noting the time of installation status.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if display_status is not None:
            pulumi.set(__self__, "display_status", display_status)
        if level is None:
            level = 'Information'
        if level is not None:
            pulumi.set(__self__, "level", level)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def code(self) -> Optional[builtins.str]:
        """
        Status code provided by the Extension
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="displayStatus")
    def display_status(self) -> Optional[builtins.str]:
        """
        Short description of status of the extension.
        """
        return pulumi.get(self, "display_status")

    @property
    @pulumi.getter
    def level(self) -> Optional[builtins.str]:
        """
        Level of the status.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Detailed message of the status from the Extension.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def time(self) -> Optional[builtins.str]:
        """
        DateLiteral (per ISO8601) noting the time of installation status.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GitRepositoryDefinitionResponse(dict):
    """
    Parameters to reconcile to the GitRepository source kind type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpsCACert":
            suggest = "https_ca_cert"
        elif key == "httpsUser":
            suggest = "https_user"
        elif key == "localAuthRef":
            suggest = "local_auth_ref"
        elif key == "repositoryRef":
            suggest = "repository_ref"
        elif key == "sshKnownHosts":
            suggest = "ssh_known_hosts"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitRepositoryDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitRepositoryDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitRepositoryDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 https_ca_cert: Optional[builtins.str] = None,
                 https_user: Optional[builtins.str] = None,
                 local_auth_ref: Optional[builtins.str] = None,
                 repository_ref: Optional['outputs.RepositoryRefDefinitionResponse'] = None,
                 ssh_known_hosts: Optional[builtins.str] = None,
                 sync_interval_in_seconds: Optional[builtins.float] = None,
                 timeout_in_seconds: Optional[builtins.float] = None,
                 url: Optional[builtins.str] = None):
        """
        Parameters to reconcile to the GitRepository source kind type.
        :param builtins.str https_ca_cert: Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS
        :param builtins.str https_user: Plaintext HTTPS username used to access private git repositories over HTTPS
        :param builtins.str local_auth_ref: Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        :param 'RepositoryRefDefinitionResponse' repository_ref: The source reference for the GitRepository object.
        :param builtins.str ssh_known_hosts: Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH
        :param builtins.float sync_interval_in_seconds: The interval at which to re-reconcile the cluster git repository source with the remote.
        :param builtins.float timeout_in_seconds: The maximum time to attempt to reconcile the cluster git repository source with the remote.
        :param builtins.str url: The URL to sync for the flux configuration git repository.
        """
        if https_ca_cert is not None:
            pulumi.set(__self__, "https_ca_cert", https_ca_cert)
        if https_user is not None:
            pulumi.set(__self__, "https_user", https_user)
        if local_auth_ref is not None:
            pulumi.set(__self__, "local_auth_ref", local_auth_ref)
        if repository_ref is not None:
            pulumi.set(__self__, "repository_ref", repository_ref)
        if ssh_known_hosts is not None:
            pulumi.set(__self__, "ssh_known_hosts", ssh_known_hosts)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="httpsCACert")
    def https_ca_cert(self) -> Optional[builtins.str]:
        """
        Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS
        """
        return pulumi.get(self, "https_ca_cert")

    @property
    @pulumi.getter(name="httpsUser")
    def https_user(self) -> Optional[builtins.str]:
        """
        Plaintext HTTPS username used to access private git repositories over HTTPS
        """
        return pulumi.get(self, "https_user")

    @property
    @pulumi.getter(name="localAuthRef")
    def local_auth_ref(self) -> Optional[builtins.str]:
        """
        Name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
        """
        return pulumi.get(self, "local_auth_ref")

    @property
    @pulumi.getter(name="repositoryRef")
    def repository_ref(self) -> Optional['outputs.RepositoryRefDefinitionResponse']:
        """
        The source reference for the GitRepository object.
        """
        return pulumi.get(self, "repository_ref")

    @property
    @pulumi.getter(name="sshKnownHosts")
    def ssh_known_hosts(self) -> Optional[builtins.str]:
        """
        Base64-encoded known_hosts value containing public SSH keys required to access private git repositories over SSH
        """
        return pulumi.get(self, "ssh_known_hosts")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[builtins.float]:
        """
        The interval at which to re-reconcile the cluster git repository source with the remote.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[builtins.float]:
        """
        The maximum time to attempt to reconcile the cluster git repository source with the remote.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        The URL to sync for the flux configuration git repository.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class HelmOperatorPropertiesResponse(dict):
    """
    Properties for Helm operator.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chartValues":
            suggest = "chart_values"
        elif key == "chartVersion":
            suggest = "chart_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HelmOperatorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HelmOperatorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HelmOperatorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chart_values: Optional[builtins.str] = None,
                 chart_version: Optional[builtins.str] = None):
        """
        Properties for Helm operator.
        :param builtins.str chart_values: Values override for the operator Helm chart.
        :param builtins.str chart_version: Version of the operator Helm chart.
        """
        if chart_values is not None:
            pulumi.set(__self__, "chart_values", chart_values)
        if chart_version is not None:
            pulumi.set(__self__, "chart_version", chart_version)

    @property
    @pulumi.getter(name="chartValues")
    def chart_values(self) -> Optional[builtins.str]:
        """
        Values override for the operator Helm chart.
        """
        return pulumi.get(self, "chart_values")

    @property
    @pulumi.getter(name="chartVersion")
    def chart_version(self) -> Optional[builtins.str]:
        """
        Version of the operator Helm chart.
        """
        return pulumi.get(self, "chart_version")


@pulumi.output_type
class HelmReleasePropertiesDefinitionResponse(dict):
    """
    Properties for HelmRelease objects
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCount":
            suggest = "failure_count"
        elif key == "helmChartRef":
            suggest = "helm_chart_ref"
        elif key == "installFailureCount":
            suggest = "install_failure_count"
        elif key == "lastRevisionApplied":
            suggest = "last_revision_applied"
        elif key == "upgradeFailureCount":
            suggest = "upgrade_failure_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HelmReleasePropertiesDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HelmReleasePropertiesDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HelmReleasePropertiesDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_count: Optional[builtins.float] = None,
                 helm_chart_ref: Optional['outputs.ObjectReferenceDefinitionResponse'] = None,
                 install_failure_count: Optional[builtins.float] = None,
                 last_revision_applied: Optional[builtins.float] = None,
                 upgrade_failure_count: Optional[builtins.float] = None):
        """
        Properties for HelmRelease objects
        :param builtins.float failure_count: Total number of times that the HelmRelease failed to install or upgrade
        :param 'ObjectReferenceDefinitionResponse' helm_chart_ref: The reference to the HelmChart object used as the source to this HelmRelease
        :param builtins.float install_failure_count: Number of times that the HelmRelease failed to install
        :param builtins.float last_revision_applied: The revision number of the last released object change
        :param builtins.float upgrade_failure_count: Number of times that the HelmRelease failed to upgrade
        """
        if failure_count is not None:
            pulumi.set(__self__, "failure_count", failure_count)
        if helm_chart_ref is not None:
            pulumi.set(__self__, "helm_chart_ref", helm_chart_ref)
        if install_failure_count is not None:
            pulumi.set(__self__, "install_failure_count", install_failure_count)
        if last_revision_applied is not None:
            pulumi.set(__self__, "last_revision_applied", last_revision_applied)
        if upgrade_failure_count is not None:
            pulumi.set(__self__, "upgrade_failure_count", upgrade_failure_count)

    @property
    @pulumi.getter(name="failureCount")
    def failure_count(self) -> Optional[builtins.float]:
        """
        Total number of times that the HelmRelease failed to install or upgrade
        """
        return pulumi.get(self, "failure_count")

    @property
    @pulumi.getter(name="helmChartRef")
    def helm_chart_ref(self) -> Optional['outputs.ObjectReferenceDefinitionResponse']:
        """
        The reference to the HelmChart object used as the source to this HelmRelease
        """
        return pulumi.get(self, "helm_chart_ref")

    @property
    @pulumi.getter(name="installFailureCount")
    def install_failure_count(self) -> Optional[builtins.float]:
        """
        Number of times that the HelmRelease failed to install
        """
        return pulumi.get(self, "install_failure_count")

    @property
    @pulumi.getter(name="lastRevisionApplied")
    def last_revision_applied(self) -> Optional[builtins.float]:
        """
        The revision number of the last released object change
        """
        return pulumi.get(self, "last_revision_applied")

    @property
    @pulumi.getter(name="upgradeFailureCount")
    def upgrade_failure_count(self) -> Optional[builtins.float]:
        """
        Number of times that the HelmRelease failed to upgrade
        """
        return pulumi.get(self, "upgrade_failure_count")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: Optional[builtins.str] = None):
        """
        Identity for the resource.
        :param builtins.str principal_id: The principal ID of resource identity.
        :param builtins.str tenant_id: The tenant ID of resource.
        :param builtins.str type: The identity type.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KubernetesConfigurationPrivateLinkScopePropertiesResponse(dict):
    """
    Properties that define a Azure Arc PrivateLinkScope resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterResourceId":
            suggest = "cluster_resource_id"
        elif key == "privateEndpointConnections":
            suggest = "private_endpoint_connections"
        elif key == "privateLinkScopeId":
            suggest = "private_link_scope_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "publicNetworkAccess":
            suggest = "public_network_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesConfigurationPrivateLinkScopePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesConfigurationPrivateLinkScopePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesConfigurationPrivateLinkScopePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_resource_id: builtins.str,
                 private_endpoint_connections: Sequence['outputs.PrivateEndpointConnectionResponse'],
                 private_link_scope_id: builtins.str,
                 provisioning_state: builtins.str,
                 public_network_access: Optional[builtins.str] = None):
        """
        Properties that define a Azure Arc PrivateLinkScope resource.
        :param builtins.str cluster_resource_id: Managed Cluster ARM ID for the private link scope  (Required)
        :param Sequence['PrivateEndpointConnectionResponse'] private_endpoint_connections: The collection of associated Private Endpoint Connections.
        :param builtins.str private_link_scope_id: The Guid id of the private link scope.
        :param builtins.str provisioning_state: Current state of this PrivateLinkScope: whether or not is has been provisioned within the resource group it is defined. Users cannot change this value but are able to read from it. Values will include Provisioning ,Succeeded, Canceled and Failed.
        :param builtins.str public_network_access: Indicates whether machines associated with the private link scope can also use public Azure Arc service endpoints.
        """
        pulumi.set(__self__, "cluster_resource_id", cluster_resource_id)
        pulumi.set(__self__, "private_endpoint_connections", private_endpoint_connections)
        pulumi.set(__self__, "private_link_scope_id", private_link_scope_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)

    @property
    @pulumi.getter(name="clusterResourceId")
    def cluster_resource_id(self) -> builtins.str:
        """
        Managed Cluster ARM ID for the private link scope  (Required)
        """
        return pulumi.get(self, "cluster_resource_id")

    @property
    @pulumi.getter(name="privateEndpointConnections")
    def private_endpoint_connections(self) -> Sequence['outputs.PrivateEndpointConnectionResponse']:
        """
        The collection of associated Private Endpoint Connections.
        """
        return pulumi.get(self, "private_endpoint_connections")

    @property
    @pulumi.getter(name="privateLinkScopeId")
    def private_link_scope_id(self) -> builtins.str:
        """
        The Guid id of the private link scope.
        """
        return pulumi.get(self, "private_link_scope_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Current state of this PrivateLinkScope: whether or not is has been provisioned within the resource group it is defined. Users cannot change this value but are able to read from it. Values will include Provisioning ,Succeeded, Canceled and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[builtins.str]:
        """
        Indicates whether machines associated with the private link scope can also use public Azure Arc service endpoints.
        """
        return pulumi.get(self, "public_network_access")


@pulumi.output_type
class KustomizationDefinitionResponse(dict):
    """
    The Kustomization defining how to reconcile the artifact pulled by the source type on the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependsOn":
            suggest = "depends_on"
        elif key == "postBuild":
            suggest = "post_build"
        elif key == "retryIntervalInSeconds":
            suggest = "retry_interval_in_seconds"
        elif key == "syncIntervalInSeconds":
            suggest = "sync_interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KustomizationDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KustomizationDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KustomizationDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 depends_on: Optional[Sequence[builtins.str]] = None,
                 force: Optional[builtins.bool] = None,
                 path: Optional[builtins.str] = None,
                 post_build: Optional['outputs.PostBuildDefinitionResponse'] = None,
                 prune: Optional[builtins.bool] = None,
                 retry_interval_in_seconds: Optional[builtins.float] = None,
                 sync_interval_in_seconds: Optional[builtins.float] = None,
                 timeout_in_seconds: Optional[builtins.float] = None,
                 wait: Optional[builtins.bool] = None):
        """
        The Kustomization defining how to reconcile the artifact pulled by the source type on the cluster.
        :param builtins.str name: Name of the Kustomization, matching the key in the Kustomizations object map.
        :param Sequence[builtins.str] depends_on: Specifies other Kustomizations that this Kustomization depends on. This Kustomization will not reconcile until all dependencies have completed their reconciliation.
        :param builtins.bool force: Enable/disable re-creating Kubernetes resources on the cluster when patching fails due to an immutable field change.
        :param builtins.str path: The path in the source reference to reconcile on the cluster.
        :param 'PostBuildDefinitionResponse' post_build: Used for variable substitution for this Kustomization after kustomize build.
        :param builtins.bool prune: Enable/disable garbage collections of Kubernetes objects created by this Kustomization.
        :param builtins.float retry_interval_in_seconds: The interval at which to re-reconcile the Kustomization on the cluster in the event of failure on reconciliation.
        :param builtins.float sync_interval_in_seconds: The interval at which to re-reconcile the Kustomization on the cluster.
        :param builtins.float timeout_in_seconds: The maximum time to attempt to reconcile the Kustomization on the cluster.
        :param builtins.bool wait: Enable/disable health check for all Kubernetes objects created by this Kustomization.
        """
        pulumi.set(__self__, "name", name)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if force is None:
            force = False
        if force is not None:
            pulumi.set(__self__, "force", force)
        if path is None:
            path = ''
        if path is not None:
            pulumi.set(__self__, "path", path)
        if post_build is not None:
            pulumi.set(__self__, "post_build", post_build)
        if prune is None:
            prune = False
        if prune is not None:
            pulumi.set(__self__, "prune", prune)
        if retry_interval_in_seconds is not None:
            pulumi.set(__self__, "retry_interval_in_seconds", retry_interval_in_seconds)
        if sync_interval_in_seconds is None:
            sync_interval_in_seconds = 600
        if sync_interval_in_seconds is not None:
            pulumi.set(__self__, "sync_interval_in_seconds", sync_interval_in_seconds)
        if timeout_in_seconds is None:
            timeout_in_seconds = 600
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if wait is None:
            wait = True
        if wait is not None:
            pulumi.set(__self__, "wait", wait)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the Kustomization, matching the key in the Kustomizations object map.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[Sequence[builtins.str]]:
        """
        Specifies other Kustomizations that this Kustomization depends on. This Kustomization will not reconcile until all dependencies have completed their reconciliation.
        """
        return pulumi.get(self, "depends_on")

    @property
    @pulumi.getter
    def force(self) -> Optional[builtins.bool]:
        """
        Enable/disable re-creating Kubernetes resources on the cluster when patching fails due to an immutable field change.
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The path in the source reference to reconcile on the cluster.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="postBuild")
    def post_build(self) -> Optional['outputs.PostBuildDefinitionResponse']:
        """
        Used for variable substitution for this Kustomization after kustomize build.
        """
        return pulumi.get(self, "post_build")

    @property
    @pulumi.getter
    def prune(self) -> Optional[builtins.bool]:
        """
        Enable/disable garbage collections of Kubernetes objects created by this Kustomization.
        """
        return pulumi.get(self, "prune")

    @property
    @pulumi.getter(name="retryIntervalInSeconds")
    def retry_interval_in_seconds(self) -> Optional[builtins.float]:
        """
        The interval at which to re-reconcile the Kustomization on the cluster in the event of failure on reconciliation.
        """
        return pulumi.get(self, "retry_interval_in_seconds")

    @property
    @pulumi.getter(name="syncIntervalInSeconds")
    def sync_interval_in_seconds(self) -> Optional[builtins.float]:
        """
        The interval at which to re-reconcile the Kustomization on the cluster.
        """
        return pulumi.get(self, "sync_interval_in_seconds")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[builtins.float]:
        """
        The maximum time to attempt to reconcile the Kustomization on the cluster.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def wait(self) -> Optional[builtins.bool]:
        """
        Enable/disable health check for all Kubernetes objects created by this Kustomization.
        """
        return pulumi.get(self, "wait")


@pulumi.output_type
class ManagedIdentityDefinitionResponse(dict):
    """
    Parameters to authenticate using a Managed Identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None):
        """
        Parameters to authenticate using a Managed Identity.
        :param builtins.str client_id: The client Id for authenticating a Managed Identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The client Id for authenticating a Managed Identity.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class ObjectReferenceDefinitionResponse(dict):
    """
    Object reference to a Kubernetes object on a cluster
    """
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 namespace: Optional[builtins.str] = None):
        """
        Object reference to a Kubernetes object on a cluster
        :param builtins.str name: Name of the object
        :param builtins.str namespace: Namespace of the object
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the object
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Namespace of the object
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ObjectStatusConditionDefinitionResponse(dict):
    """
    Status condition of Kubernetes object
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectStatusConditionDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectStatusConditionDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectStatusConditionDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Status condition of Kubernetes object
        :param builtins.str last_transition_time: Last time this status condition has changed
        :param builtins.str message: A more verbose description of the object status condition
        :param builtins.str reason: Reason for the specified status condition type status
        :param builtins.str status: Status of the Kubernetes object condition type
        :param builtins.str type: Object status condition type for this object
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        Last time this status condition has changed
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        A more verbose description of the object status condition
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        Reason for the specified status condition type status
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Status of the Kubernetes object condition type
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Object status condition type for this object
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ObjectStatusDefinitionResponse(dict):
    """
    Statuses of objects deployed by the user-specified kustomizations from the git repository.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedBy":
            suggest = "applied_by"
        elif key == "complianceState":
            suggest = "compliance_state"
        elif key == "helmReleaseProperties":
            suggest = "helm_release_properties"
        elif key == "statusConditions":
            suggest = "status_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectStatusDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectStatusDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectStatusDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applied_by: Optional['outputs.ObjectReferenceDefinitionResponse'] = None,
                 compliance_state: Optional[builtins.str] = None,
                 helm_release_properties: Optional['outputs.HelmReleasePropertiesDefinitionResponse'] = None,
                 kind: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 namespace: Optional[builtins.str] = None,
                 status_conditions: Optional[Sequence['outputs.ObjectStatusConditionDefinitionResponse']] = None):
        """
        Statuses of objects deployed by the user-specified kustomizations from the git repository.
        :param 'ObjectReferenceDefinitionResponse' applied_by: Object reference to the Kustomization that applied this object
        :param builtins.str compliance_state: Compliance state of the applied object showing whether the applied object has come into a ready state on the cluster.
        :param 'HelmReleasePropertiesDefinitionResponse' helm_release_properties: Additional properties that are provided from objects of the HelmRelease kind
        :param builtins.str kind: Kind of the applied object
        :param builtins.str name: Name of the applied object
        :param builtins.str namespace: Namespace of the applied object
        :param Sequence['ObjectStatusConditionDefinitionResponse'] status_conditions: List of Kubernetes object status conditions present on the cluster
        """
        if applied_by is not None:
            pulumi.set(__self__, "applied_by", applied_by)
        if compliance_state is not None:
            pulumi.set(__self__, "compliance_state", compliance_state)
        if helm_release_properties is not None:
            pulumi.set(__self__, "helm_release_properties", helm_release_properties)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if status_conditions is not None:
            pulumi.set(__self__, "status_conditions", status_conditions)

    @property
    @pulumi.getter(name="appliedBy")
    def applied_by(self) -> Optional['outputs.ObjectReferenceDefinitionResponse']:
        """
        Object reference to the Kustomization that applied this object
        """
        return pulumi.get(self, "applied_by")

    @property
    @pulumi.getter(name="complianceState")
    def compliance_state(self) -> Optional[builtins.str]:
        """
        Compliance state of the applied object showing whether the applied object has come into a ready state on the cluster.
        """
        return pulumi.get(self, "compliance_state")

    @property
    @pulumi.getter(name="helmReleaseProperties")
    def helm_release_properties(self) -> Optional['outputs.HelmReleasePropertiesDefinitionResponse']:
        """
        Additional properties that are provided from objects of the HelmRelease kind
        """
        return pulumi.get(self, "helm_release_properties")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of the applied object
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the applied object
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Namespace of the applied object
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="statusConditions")
    def status_conditions(self) -> Optional[Sequence['outputs.ObjectStatusConditionDefinitionResponse']]:
        """
        List of Kubernetes object status conditions present on the cluster
        """
        return pulumi.get(self, "status_conditions")


@pulumi.output_type
class PlanResponse(dict):
    """
    Plan for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promotionCode":
            suggest = "promotion_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 product: builtins.str,
                 publisher: builtins.str,
                 promotion_code: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Plan for the resource.
        :param builtins.str name: A user defined name of the 3rd Party Artifact that is being procured.
        :param builtins.str product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        :param builtins.str publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        :param builtins.str promotion_code: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        :param builtins.str version: The version of the desired product/artifact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> builtins.str:
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> builtins.str:
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[builtins.str]:
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        return pulumi.get(self, "promotion_code")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        The version of the desired product/artifact.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class PostBuildDefinitionResponse(dict):
    """
    The postBuild definitions defining variable substitutions for this Kustomization after kustomize build.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "substituteFrom":
            suggest = "substitute_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PostBuildDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PostBuildDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PostBuildDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 substitute: Optional[Mapping[str, builtins.str]] = None,
                 substitute_from: Optional[Sequence['outputs.SubstituteFromDefinitionResponse']] = None):
        """
        The postBuild definitions defining variable substitutions for this Kustomization after kustomize build.
        :param Mapping[str, builtins.str] substitute: Key/value pairs holding the variables to be substituted in this Kustomization.
        :param Sequence['SubstituteFromDefinitionResponse'] substitute_from: Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
        """
        if substitute is not None:
            pulumi.set(__self__, "substitute", substitute)
        if substitute_from is not None:
            pulumi.set(__self__, "substitute_from", substitute_from)

    @property
    @pulumi.getter
    def substitute(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Key/value pairs holding the variables to be substituted in this Kustomization.
        """
        return pulumi.get(self, "substitute")

    @property
    @pulumi.getter(name="substituteFrom")
    def substitute_from(self) -> Optional[Sequence['outputs.SubstituteFromDefinitionResponse']]:
        """
        Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
        """
        return pulumi.get(self, "substitute_from")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The Private Endpoint Connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "systemData":
            suggest = "system_data"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: builtins.str,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None):
        """
        The Private Endpoint Connection resource.
        :param builtins.str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param builtins.str name: The name of the resource
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param builtins.str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'PrivateEndpointResponse' private_endpoint: The resource of private end point.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The resource of private end point.
        """
        return pulumi.get(self, "private_endpoint")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: builtins.str):
        """
        The Private Endpoint resource.
        :param builtins.str id: The ARM identifier for Private Endpoint
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param builtins.str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param builtins.str description: The reason for approval/rejection of the connection.
        :param builtins.str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[builtins.str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RepositoryRefDefinitionResponse(dict):
    """
    The source reference for the GitRepository object.
    """
    def __init__(__self__, *,
                 branch: Optional[builtins.str] = None,
                 commit: Optional[builtins.str] = None,
                 semver: Optional[builtins.str] = None,
                 tag: Optional[builtins.str] = None):
        """
        The source reference for the GitRepository object.
        :param builtins.str branch: The git repository branch name to checkout.
        :param builtins.str commit: The commit SHA to checkout. This value must be combined with the branch name to be valid. This takes precedence over semver.
        :param builtins.str semver: The semver range used to match against git repository tags. This takes precedence over tag.
        :param builtins.str tag: The git repository tag name to checkout. This takes precedence over branch.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit is not None:
            pulumi.set(__self__, "commit", commit)
        if semver is not None:
            pulumi.set(__self__, "semver", semver)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def branch(self) -> Optional[builtins.str]:
        """
        The git repository branch name to checkout.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter
    def commit(self) -> Optional[builtins.str]:
        """
        The commit SHA to checkout. This value must be combined with the branch name to be valid. This takes precedence over semver.
        """
        return pulumi.get(self, "commit")

    @property
    @pulumi.getter
    def semver(self) -> Optional[builtins.str]:
        """
        The semver range used to match against git repository tags. This takes precedence over tag.
        """
        return pulumi.get(self, "semver")

    @property
    @pulumi.getter
    def tag(self) -> Optional[builtins.str]:
        """
        The git repository tag name to checkout. This takes precedence over branch.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class ScopeClusterResponse(dict):
    """
    Specifies that the scope of the extension is Cluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseNamespace":
            suggest = "release_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScopeClusterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScopeClusterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScopeClusterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 release_namespace: Optional[builtins.str] = None):
        """
        Specifies that the scope of the extension is Cluster
        :param builtins.str release_namespace: Namespace where the extension Release must be placed, for a Cluster scoped extension.  If this namespace does not exist, it will be created
        """
        if release_namespace is not None:
            pulumi.set(__self__, "release_namespace", release_namespace)

    @property
    @pulumi.getter(name="releaseNamespace")
    def release_namespace(self) -> Optional[builtins.str]:
        """
        Namespace where the extension Release must be placed, for a Cluster scoped extension.  If this namespace does not exist, it will be created
        """
        return pulumi.get(self, "release_namespace")


@pulumi.output_type
class ScopeNamespaceResponse(dict):
    """
    Specifies that the scope of the extension is Namespace
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetNamespace":
            suggest = "target_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScopeNamespaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScopeNamespaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScopeNamespaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_namespace: Optional[builtins.str] = None):
        """
        Specifies that the scope of the extension is Namespace
        :param builtins.str target_namespace: Namespace where the extension will be created for an Namespace scoped extension.  If this namespace does not exist, it will be created
        """
        if target_namespace is not None:
            pulumi.set(__self__, "target_namespace", target_namespace)

    @property
    @pulumi.getter(name="targetNamespace")
    def target_namespace(self) -> Optional[builtins.str]:
        """
        Namespace where the extension will be created for an Namespace scoped extension.  If this namespace does not exist, it will be created
        """
        return pulumi.get(self, "target_namespace")


@pulumi.output_type
class ScopeResponse(dict):
    """
    Scope of the extension. It can be either Cluster or Namespace; but not both.
    """
    def __init__(__self__, *,
                 cluster: Optional['outputs.ScopeClusterResponse'] = None,
                 namespace: Optional['outputs.ScopeNamespaceResponse'] = None):
        """
        Scope of the extension. It can be either Cluster or Namespace; but not both.
        :param 'ScopeClusterResponse' cluster: Specifies that the scope of the extension is Cluster
        :param 'ScopeNamespaceResponse' namespace: Specifies that the scope of the extension is Namespace
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def cluster(self) -> Optional['outputs.ScopeClusterResponse']:
        """
        Specifies that the scope of the extension is Cluster
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def namespace(self) -> Optional['outputs.ScopeNamespaceResponse']:
        """
        Specifies that the scope of the extension is Namespace
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ServicePrincipalDefinitionResponse(dict):
    """
    Parameters to authenticate using Service Principal.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientCertificatePassword":
            suggest = "client_certificate_password"
        elif key == "clientCertificateSendChain":
            suggest = "client_certificate_send_chain"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicePrincipalDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicePrincipalDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicePrincipalDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: Optional[builtins.str] = None,
                 client_certificate_password: Optional[builtins.str] = None,
                 client_certificate_send_chain: Optional[builtins.bool] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None):
        """
        Parameters to authenticate using Service Principal.
        :param builtins.str client_certificate: Base64-encoded certificate used to authenticate a Service Principal 
        :param builtins.str client_certificate_password: The password for the certificate used to authenticate a Service Principal 
        :param builtins.bool client_certificate_send_chain: Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the Client Certificate
        :param builtins.str client_id: The client Id for authenticating a Service Principal.
        :param builtins.str client_secret: The client secret for authenticating a Service Principal
        :param builtins.str tenant_id: The tenant Id for authenticating a Service Principal
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_certificate_password is not None:
            pulumi.set(__self__, "client_certificate_password", client_certificate_password)
        if client_certificate_send_chain is None:
            client_certificate_send_chain = False
        if client_certificate_send_chain is not None:
            pulumi.set(__self__, "client_certificate_send_chain", client_certificate_send_chain)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[builtins.str]:
        """
        Base64-encoded certificate used to authenticate a Service Principal 
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientCertificatePassword")
    def client_certificate_password(self) -> Optional[builtins.str]:
        """
        The password for the certificate used to authenticate a Service Principal 
        """
        return pulumi.get(self, "client_certificate_password")

    @property
    @pulumi.getter(name="clientCertificateSendChain")
    def client_certificate_send_chain(self) -> Optional[builtins.bool]:
        """
        Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the Client Certificate
        """
        return pulumi.get(self, "client_certificate_send_chain")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The client Id for authenticating a Service Principal.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        The client secret for authenticating a Service Principal
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The tenant Id for authenticating a Service Principal
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SubstituteFromDefinitionResponse(dict):
    """
    Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
    """
    def __init__(__self__, *,
                 kind: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 optional: Optional[builtins.bool] = None):
        """
        Array of ConfigMaps/Secrets from which the variables are substituted for this Kustomization.
        :param builtins.str kind: Define whether it is ConfigMap or Secret that holds the variables to be used in substitution.
        :param builtins.str name: Name of the ConfigMap/Secret that holds the variables to be used in substitution.
        :param builtins.bool optional: Set to True to proceed without ConfigMap/Secret, if it is not present.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is None:
            optional = False
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Define whether it is ConfigMap or Secret that holds the variables to be used in substitution.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the ConfigMap/Secret that holds the variables to be used in substitution.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[builtins.bool]:
        """
        Set to True to proceed without ConfigMap/Secret, if it is not present.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


