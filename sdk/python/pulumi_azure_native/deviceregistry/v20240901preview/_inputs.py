# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AuthenticationArgs',
    'AuthenticationArgsDict',
    'DataPointArgs',
    'DataPointArgsDict',
    'DatasetArgs',
    'DatasetArgsDict',
    'DiscoveredDataPointArgs',
    'DiscoveredDataPointArgsDict',
    'DiscoveredDatasetArgs',
    'DiscoveredDatasetArgsDict',
    'DiscoveredEventArgs',
    'DiscoveredEventArgsDict',
    'EventArgs',
    'EventArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'SystemAssignedServiceIdentityArgs',
    'SystemAssignedServiceIdentityArgsDict',
    'TopicArgs',
    'TopicArgsDict',
    'UsernamePasswordCredentialsArgs',
    'UsernamePasswordCredentialsArgsDict',
    'X509CredentialsArgs',
    'X509CredentialsArgsDict',
]

MYPY = False

if not MYPY:
    class AuthenticationArgsDict(TypedDict):
        """
        Definition of the client authentication mechanism to the server.
        """
        method: pulumi.Input[Union[str, 'AuthenticationMethod']]
        """
        Defines the method to authenticate the user of the client at the server.
        """
        username_password_credentials: NotRequired[pulumi.Input['UsernamePasswordCredentialsArgsDict']]
        """
        Defines the username and password references when UsernamePassword user authentication mode is selected.
        """
        x509_credentials: NotRequired[pulumi.Input['X509CredentialsArgsDict']]
        """
        Defines the certificate reference when Certificate user authentication mode is selected.
        """
elif False:
    AuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[Union[str, 'AuthenticationMethod']]] = None,
                 username_password_credentials: Optional[pulumi.Input['UsernamePasswordCredentialsArgs']] = None,
                 x509_credentials: Optional[pulumi.Input['X509CredentialsArgs']] = None):
        """
        Definition of the client authentication mechanism to the server.
        :param pulumi.Input[Union[str, 'AuthenticationMethod']] method: Defines the method to authenticate the user of the client at the server.
        :param pulumi.Input['UsernamePasswordCredentialsArgs'] username_password_credentials: Defines the username and password references when UsernamePassword user authentication mode is selected.
        :param pulumi.Input['X509CredentialsArgs'] x509_credentials: Defines the certificate reference when Certificate user authentication mode is selected.
        """
        if method is None:
            method = 'Certificate'
        pulumi.set(__self__, "method", method)
        if username_password_credentials is not None:
            pulumi.set(__self__, "username_password_credentials", username_password_credentials)
        if x509_credentials is not None:
            pulumi.set(__self__, "x509_credentials", x509_credentials)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[str, 'AuthenticationMethod']]:
        """
        Defines the method to authenticate the user of the client at the server.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[str, 'AuthenticationMethod']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="usernamePasswordCredentials")
    def username_password_credentials(self) -> Optional[pulumi.Input['UsernamePasswordCredentialsArgs']]:
        """
        Defines the username and password references when UsernamePassword user authentication mode is selected.
        """
        return pulumi.get(self, "username_password_credentials")

    @username_password_credentials.setter
    def username_password_credentials(self, value: Optional[pulumi.Input['UsernamePasswordCredentialsArgs']]):
        pulumi.set(self, "username_password_credentials", value)

    @property
    @pulumi.getter(name="x509Credentials")
    def x509_credentials(self) -> Optional[pulumi.Input['X509CredentialsArgs']]:
        """
        Defines the certificate reference when Certificate user authentication mode is selected.
        """
        return pulumi.get(self, "x509_credentials")

    @x509_credentials.setter
    def x509_credentials(self, value: Optional[pulumi.Input['X509CredentialsArgs']]):
        pulumi.set(self, "x509_credentials", value)


if not MYPY:
    class DataPointArgsDict(TypedDict):
        """
        Defines the data point properties.
        """
        data_source: pulumi.Input[str]
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        name: pulumi.Input[str]
        """
        The name of the data point.
        """
        data_point_configuration: NotRequired[pulumi.Input[str]]
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        observability_mode: NotRequired[pulumi.Input[Union[str, 'DataPointObservabilityMode']]]
        """
        An indication of how the data point should be mapped to OpenTelemetry.
        """
elif False:
    DataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataPointArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 data_point_configuration: Optional[pulumi.Input[str]] = None,
                 observability_mode: Optional[pulumi.Input[Union[str, 'DataPointObservabilityMode']]] = None):
        """
        Defines the data point properties.
        :param pulumi.Input[str] data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param pulumi.Input[str] name: The name of the data point.
        :param pulumi.Input[str] data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[Union[str, 'DataPointObservabilityMode']] observability_mode: An indication of how the data point should be mapped to OpenTelemetry.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if observability_mode is None:
            observability_mode = 'None'
        if observability_mode is not None:
            pulumi.set(__self__, "observability_mode", observability_mode)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[pulumi.Input[str]]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @data_point_configuration.setter
    def data_point_configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_point_configuration", value)

    @property
    @pulumi.getter(name="observabilityMode")
    def observability_mode(self) -> Optional[pulumi.Input[Union[str, 'DataPointObservabilityMode']]]:
        """
        An indication of how the data point should be mapped to OpenTelemetry.
        """
        return pulumi.get(self, "observability_mode")

    @observability_mode.setter
    def observability_mode(self, value: Optional[pulumi.Input[Union[str, 'DataPointObservabilityMode']]]):
        pulumi.set(self, "observability_mode", value)


if not MYPY:
    class DatasetArgsDict(TypedDict):
        """
        Defines the dataset properties.
        """
        name: pulumi.Input[str]
        """
        Name of the dataset.
        """
        data_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataPointArgsDict']]]]
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        dataset_configuration: NotRequired[pulumi.Input[str]]
        """
        Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        """
        topic: NotRequired[pulumi.Input['TopicArgsDict']]
        """
        Object that describes the topic information for the specific dataset.
        """
elif False:
    DatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 data_points: Optional[pulumi.Input[Sequence[pulumi.Input['DataPointArgs']]]] = None,
                 dataset_configuration: Optional[pulumi.Input[str]] = None,
                 topic: Optional[pulumi.Input['TopicArgs']] = None):
        """
        Defines the dataset properties.
        :param pulumi.Input[str] name: Name of the dataset.
        :param pulumi.Input[Sequence[pulumi.Input['DataPointArgs']]] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param pulumi.Input[str] dataset_configuration: Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        :param pulumi.Input['TopicArgs'] topic: Object that describes the topic information for the specific dataset.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataPointArgs']]]]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataPointArgs']]]]):
        pulumi.set(self, "data_points", value)

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[pulumi.Input[str]]:
        """
        Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @dataset_configuration.setter
    def dataset_configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_configuration", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['TopicArgs']]:
        """
        Object that describes the topic information for the specific dataset.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['TopicArgs']]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class DiscoveredDataPointArgsDict(TypedDict):
        """
        Defines the data point properties.
        """
        data_source: pulumi.Input[str]
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        name: pulumi.Input[str]
        """
        The name of the data point.
        """
        data_point_configuration: NotRequired[pulumi.Input[str]]
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        last_updated_on: NotRequired[pulumi.Input[str]]
        """
        UTC timestamp indicating when the data point was added or modified.
        """
elif False:
    DiscoveredDataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveredDataPointArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 data_point_configuration: Optional[pulumi.Input[str]] = None,
                 last_updated_on: Optional[pulumi.Input[str]] = None):
        """
        Defines the data point properties.
        :param pulumi.Input[str] data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param pulumi.Input[str] name: The name of the data point.
        :param pulumi.Input[str] data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[str] last_updated_on: UTC timestamp indicating when the data point was added or modified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[pulumi.Input[str]]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @data_point_configuration.setter
    def data_point_configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_point_configuration", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[str]]:
        """
        UTC timestamp indicating when the data point was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated_on", value)


if not MYPY:
    class DiscoveredDatasetArgsDict(TypedDict):
        """
        Defines the dataset properties.
        """
        name: pulumi.Input[str]
        """
        Name of the dataset.
        """
        data_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgsDict']]]]
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        dataset_configuration: NotRequired[pulumi.Input[str]]
        """
        Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        """
        topic: NotRequired[pulumi.Input['TopicArgsDict']]
        """
        Object that describes the topic information for the specific dataset.
        """
elif False:
    DiscoveredDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveredDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 data_points: Optional[pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgs']]]] = None,
                 dataset_configuration: Optional[pulumi.Input[str]] = None,
                 topic: Optional[pulumi.Input['TopicArgs']] = None):
        """
        Defines the dataset properties.
        :param pulumi.Input[str] name: Name of the dataset.
        :param pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgs']]] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param pulumi.Input[str] dataset_configuration: Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        :param pulumi.Input['TopicArgs'] topic: Object that describes the topic information for the specific dataset.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgs']]]]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgs']]]]):
        pulumi.set(self, "data_points", value)

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[pulumi.Input[str]]:
        """
        Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @dataset_configuration.setter
    def dataset_configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_configuration", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['TopicArgs']]:
        """
        Object that describes the topic information for the specific dataset.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['TopicArgs']]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class DiscoveredEventArgsDict(TypedDict):
        """
        Defines the event properties.
        """
        event_notifier: pulumi.Input[str]
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        name: pulumi.Input[str]
        """
        The name of the event.
        """
        event_configuration: NotRequired[pulumi.Input[str]]
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        last_updated_on: NotRequired[pulumi.Input[str]]
        """
        UTC timestamp indicating when the event was added or modified.
        """
        topic: NotRequired[pulumi.Input['TopicArgsDict']]
        """
        Object that describes the topic information for the specific event.
        """
elif False:
    DiscoveredEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveredEventArgs:
    def __init__(__self__, *,
                 event_notifier: pulumi.Input[str],
                 name: pulumi.Input[str],
                 event_configuration: Optional[pulumi.Input[str]] = None,
                 last_updated_on: Optional[pulumi.Input[str]] = None,
                 topic: Optional[pulumi.Input['TopicArgs']] = None):
        """
        Defines the event properties.
        :param pulumi.Input[str] event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param pulumi.Input[str] name: The name of the event.
        :param pulumi.Input[str] event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[str] last_updated_on: UTC timestamp indicating when the event was added or modified.
        :param pulumi.Input['TopicArgs'] topic: Object that describes the topic information for the specific event.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> pulumi.Input[str]:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @event_notifier.setter
    def event_notifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_notifier", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[pulumi.Input[str]]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @event_configuration.setter
    def event_configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_configuration", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[str]]:
        """
        UTC timestamp indicating when the event was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated_on", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['TopicArgs']]:
        """
        Object that describes the topic information for the specific event.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['TopicArgs']]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class EventArgsDict(TypedDict):
        """
        Defines the event properties.
        """
        event_notifier: pulumi.Input[str]
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        name: pulumi.Input[str]
        """
        The name of the event.
        """
        event_configuration: NotRequired[pulumi.Input[str]]
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        observability_mode: NotRequired[pulumi.Input[Union[str, 'EventObservabilityMode']]]
        """
        An indication of how the event should be mapped to OpenTelemetry.
        """
        topic: NotRequired[pulumi.Input['TopicArgsDict']]
        """
        Object that describes the topic information for the specific event.
        """
elif False:
    EventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventArgs:
    def __init__(__self__, *,
                 event_notifier: pulumi.Input[str],
                 name: pulumi.Input[str],
                 event_configuration: Optional[pulumi.Input[str]] = None,
                 observability_mode: Optional[pulumi.Input[Union[str, 'EventObservabilityMode']]] = None,
                 topic: Optional[pulumi.Input['TopicArgs']] = None):
        """
        Defines the event properties.
        :param pulumi.Input[str] event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param pulumi.Input[str] name: The name of the event.
        :param pulumi.Input[str] event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[Union[str, 'EventObservabilityMode']] observability_mode: An indication of how the event should be mapped to OpenTelemetry.
        :param pulumi.Input['TopicArgs'] topic: Object that describes the topic information for the specific event.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if observability_mode is None:
            observability_mode = 'None'
        if observability_mode is not None:
            pulumi.set(__self__, "observability_mode", observability_mode)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> pulumi.Input[str]:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @event_notifier.setter
    def event_notifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_notifier", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[pulumi.Input[str]]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @event_configuration.setter
    def event_configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_configuration", value)

    @property
    @pulumi.getter(name="observabilityMode")
    def observability_mode(self) -> Optional[pulumi.Input[Union[str, 'EventObservabilityMode']]]:
        """
        An indication of how the event should be mapped to OpenTelemetry.
        """
        return pulumi.get(self, "observability_mode")

    @observability_mode.setter
    def observability_mode(self, value: Optional[pulumi.Input[Union[str, 'EventObservabilityMode']]]):
        pulumi.set(self, "observability_mode", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['TopicArgs']]:
        """
        Object that describes the topic information for the specific event.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['TopicArgs']]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        The extended location.
        """
        name: pulumi.Input[str]
        """
        The extended location name.
        """
        type: pulumi.Input[str]
        """
        The extended location type.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        The extended location.
        :param pulumi.Input[str] name: The extended location name.
        :param pulumi.Input[str] type: The extended location type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The extended location name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The extended location type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SystemAssignedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (either system assigned, or none)
        """
        type: pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']]
        """
        Type of managed service identity (either system assigned, or none).
        """
elif False:
    SystemAssignedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemAssignedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']]):
        """
        Managed service identity (either system assigned, or none)
        :param pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']] type: Type of managed service identity (either system assigned, or none).
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']]:
        """
        Type of managed service identity (either system assigned, or none).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'SystemAssignedServiceIdentityType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TopicArgsDict(TypedDict):
        """
        Object that describes the topic information.
        """
        path: pulumi.Input[str]
        """
        The topic path for messages published to an MQTT broker.
        """
        retain: NotRequired[pulumi.Input[Union[str, 'TopicRetainType']]]
        """
        When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
elif False:
    TopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 retain: Optional[pulumi.Input[Union[str, 'TopicRetainType']]] = None):
        """
        Object that describes the topic information.
        :param pulumi.Input[str] path: The topic path for messages published to an MQTT broker.
        :param pulumi.Input[Union[str, 'TopicRetainType']] retain: When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
        pulumi.set(__self__, "path", path)
        if retain is None:
            retain = 'Never'
        if retain is not None:
            pulumi.set(__self__, "retain", retain)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The topic path for messages published to an MQTT broker.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def retain(self) -> Optional[pulumi.Input[Union[str, 'TopicRetainType']]]:
        """
        When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
        return pulumi.get(self, "retain")

    @retain.setter
    def retain(self, value: Optional[pulumi.Input[Union[str, 'TopicRetainType']]]):
        pulumi.set(self, "retain", value)


if not MYPY:
    class UsernamePasswordCredentialsArgsDict(TypedDict):
        """
        The credentials for authentication mode UsernamePassword.
        """
        password_secret_name: pulumi.Input[str]
        """
        The name of the secret containing the password.
        """
        username_secret_name: pulumi.Input[str]
        """
        The name of the secret containing the username.
        """
elif False:
    UsernamePasswordCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsernamePasswordCredentialsArgs:
    def __init__(__self__, *,
                 password_secret_name: pulumi.Input[str],
                 username_secret_name: pulumi.Input[str]):
        """
        The credentials for authentication mode UsernamePassword.
        :param pulumi.Input[str] password_secret_name: The name of the secret containing the password.
        :param pulumi.Input[str] username_secret_name: The name of the secret containing the username.
        """
        pulumi.set(__self__, "password_secret_name", password_secret_name)
        pulumi.set(__self__, "username_secret_name", username_secret_name)

    @property
    @pulumi.getter(name="passwordSecretName")
    def password_secret_name(self) -> pulumi.Input[str]:
        """
        The name of the secret containing the password.
        """
        return pulumi.get(self, "password_secret_name")

    @password_secret_name.setter
    def password_secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "password_secret_name", value)

    @property
    @pulumi.getter(name="usernameSecretName")
    def username_secret_name(self) -> pulumi.Input[str]:
        """
        The name of the secret containing the username.
        """
        return pulumi.get(self, "username_secret_name")

    @username_secret_name.setter
    def username_secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "username_secret_name", value)


if not MYPY:
    class X509CredentialsArgsDict(TypedDict):
        """
        The x509 certificate for authentication mode Certificate.
        """
        certificate_secret_name: pulumi.Input[str]
        """
        The name of the secret containing the certificate and private key (e.g. stored as .der/.pem or .der/.pfx).
        """
elif False:
    X509CredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class X509CredentialsArgs:
    def __init__(__self__, *,
                 certificate_secret_name: pulumi.Input[str]):
        """
        The x509 certificate for authentication mode Certificate.
        :param pulumi.Input[str] certificate_secret_name: The name of the secret containing the certificate and private key (e.g. stored as .der/.pem or .der/.pfx).
        """
        pulumi.set(__self__, "certificate_secret_name", certificate_secret_name)

    @property
    @pulumi.getter(name="certificateSecretName")
    def certificate_secret_name(self) -> pulumi.Input[str]:
        """
        The name of the secret containing the certificate and private key (e.g. stored as .der/.pem or .der/.pfx).
        """
        return pulumi.get(self, "certificate_secret_name")

    @certificate_secret_name.setter
    def certificate_secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_secret_name", value)


