# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AssetEndpointProfileStatusErrorResponse',
    'AssetEndpointProfileStatusResponse',
    'AssetStatusDatasetResponse',
    'AssetStatusErrorResponse',
    'AssetStatusEventResponse',
    'AssetStatusResponse',
    'AuthenticationResponse',
    'BrokerStateStoreDestinationConfigurationResponse',
    'DataPointResponse',
    'DatasetBrokerStateStoreDestinationResponse',
    'DatasetMqttDestinationResponse',
    'DatasetResponse',
    'DatasetStorageDestinationResponse',
    'DeviceMessagingEndpointResponse',
    'DeviceRefResponse',
    'DeviceStatusEndpointResponse',
    'DeviceStatusEndpointsResponse',
    'DeviceStatusResponse',
    'DiscoveredDataPointResponse',
    'DiscoveredDatasetResponse',
    'DiscoveredEventResponse',
    'DiscoveredInboundEndpointsResponse',
    'DiscoveredMessagingEndpointsResponse',
    'DiscoveredOutboundEndpointsResponse',
    'ErrorDetailsResponse',
    'EventMqttDestinationResponse',
    'EventResponse',
    'EventStorageDestinationResponse',
    'ExtendedLocationResponse',
    'HostAuthenticationResponse',
    'InboundEndpointsResponse',
    'ManagementActionResponse',
    'ManagementGroupResponse',
    'MessageSchemaReferenceResponse',
    'MessagingEndpointResponse',
    'MessagingEndpointsResponse',
    'MessagingResponse',
    'MqttDestinationConfigurationResponse',
    'NamespaceAssetStatusDatasetResponse',
    'NamespaceAssetStatusEventResponse',
    'NamespaceAssetStatusManagementActionResponse',
    'NamespaceAssetStatusManagementGroupResponse',
    'NamespaceAssetStatusResponse',
    'NamespaceAssetStatusStreamResponse',
    'NamespaceDatasetDataPointResponse',
    'NamespaceDatasetResponse',
    'NamespaceDiscoveredDatasetDataPointResponse',
    'NamespaceDiscoveredDatasetResponse',
    'NamespaceDiscoveredEventDataPointResponse',
    'NamespaceDiscoveredEventResponse',
    'NamespaceDiscoveredManagementActionResponse',
    'NamespaceDiscoveredManagementGroupResponse',
    'NamespaceDiscoveredStreamResponse',
    'NamespaceEventDataPointResponse',
    'NamespaceEventResponse',
    'NamespaceMessageSchemaReferenceResponse',
    'NamespaceStreamResponse',
    'OutboundEndpointsResponse',
    'StatusConfigResponse',
    'StatusErrorResponse',
    'StorageDestinationConfigurationResponse',
    'StreamMqttDestinationResponse',
    'StreamStorageDestinationResponse',
    'SystemAssignedServiceIdentityResponse',
    'SystemDataResponse',
    'TopicResponse',
    'TrustSettingsResponse',
    'UsernamePasswordCredentialsResponse',
    'X509CredentialsResponse',
]

@pulumi.output_type
class AssetEndpointProfileStatusErrorResponse(dict):
    """
    Defines the asset endpoint profile status error properties.
    """
    def __init__(__self__, *,
                 code: builtins.int,
                 message: builtins.str):
        """
        Defines the asset endpoint profile status error properties.
        :param builtins.int code: Error code for classification of errors (ex: 400, 404, 500, etc.).
        :param builtins.str message: Human readable helpful error message to provide additional context for error (ex: “targetAddress 'foo' is not a valid url”).
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> builtins.int:
        """
        Error code for classification of errors (ex: 400, 404, 500, etc.).
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        Human readable helpful error message to provide additional context for error (ex: “targetAddress 'foo' is not a valid url”).
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class AssetEndpointProfileStatusResponse(dict):
    """
    Defines the asset endpoint profile status properties.
    """
    def __init__(__self__, *,
                 errors: Sequence['outputs.AssetEndpointProfileStatusErrorResponse']):
        """
        Defines the asset endpoint profile status properties.
        :param Sequence['AssetEndpointProfileStatusErrorResponse'] errors: Array object to transfer and persist errors that originate from the Edge.
        """
        pulumi.set(__self__, "errors", errors)

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.AssetEndpointProfileStatusErrorResponse']:
        """
        Array object to transfer and persist errors that originate from the Edge.
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class AssetStatusDatasetResponse(dict):
    """
    Defines the asset status dataset properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageSchemaReference":
            suggest = "message_schema_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetStatusDatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetStatusDatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetStatusDatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_schema_reference: 'outputs.MessageSchemaReferenceResponse',
                 name: builtins.str):
        """
        Defines the asset status dataset properties.
        :param 'MessageSchemaReferenceResponse' message_schema_reference: The message schema reference object.
        :param builtins.str name: The name of the dataset. Must be unique within the status.datasets array. This name is used to correlate between the spec and status dataset information.
        """
        pulumi.set(__self__, "message_schema_reference", message_schema_reference)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="messageSchemaReference")
    def message_schema_reference(self) -> 'outputs.MessageSchemaReferenceResponse':
        """
        The message schema reference object.
        """
        return pulumi.get(self, "message_schema_reference")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the dataset. Must be unique within the status.datasets array. This name is used to correlate between the spec and status dataset information.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AssetStatusErrorResponse(dict):
    """
    Defines the asset status error properties.
    """
    def __init__(__self__, *,
                 code: builtins.int,
                 message: builtins.str):
        """
        Defines the asset status error properties.
        :param builtins.int code: Error code for classification of errors (ex: 400, 404, 500, etc.).
        :param builtins.str message: Human readable helpful error message to provide additional context for error (ex: “capability Id 'foo' does not exist”).
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> builtins.int:
        """
        Error code for classification of errors (ex: 400, 404, 500, etc.).
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        Human readable helpful error message to provide additional context for error (ex: “capability Id 'foo' does not exist”).
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class AssetStatusEventResponse(dict):
    """
    Defines the asset status event properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageSchemaReference":
            suggest = "message_schema_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssetStatusEventResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssetStatusEventResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssetStatusEventResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_schema_reference: 'outputs.MessageSchemaReferenceResponse',
                 name: builtins.str):
        """
        Defines the asset status event properties.
        :param 'MessageSchemaReferenceResponse' message_schema_reference: The message schema reference object.
        :param builtins.str name: The name of the event. Must be unique within the status.events array. This name is used to correlate between the spec and status event information.
        """
        pulumi.set(__self__, "message_schema_reference", message_schema_reference)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="messageSchemaReference")
    def message_schema_reference(self) -> 'outputs.MessageSchemaReferenceResponse':
        """
        The message schema reference object.
        """
        return pulumi.get(self, "message_schema_reference")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the event. Must be unique within the status.events array. This name is used to correlate between the spec and status event information.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AssetStatusResponse(dict):
    """
    Defines the asset status properties.
    """
    def __init__(__self__, *,
                 datasets: Sequence['outputs.AssetStatusDatasetResponse'],
                 errors: Sequence['outputs.AssetStatusErrorResponse'],
                 events: Sequence['outputs.AssetStatusEventResponse'],
                 version: builtins.float):
        """
        Defines the asset status properties.
        :param Sequence['AssetStatusDatasetResponse'] datasets: Array of dataset statuses that describe the status of each dataset.
        :param Sequence['AssetStatusErrorResponse'] errors: Array object to transfer and persist errors that originate from the Edge.
        :param Sequence['AssetStatusEventResponse'] events: Array of event statuses that describe the status of each event.
        :param builtins.float version: A read only incremental counter indicating the number of times the configuration has been modified from the perspective of the current actual (Edge) state of the Asset. Edge would be the only writer of this value and would sync back up to the cloud. In steady state, this should equal version.
        """
        pulumi.set(__self__, "datasets", datasets)
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def datasets(self) -> Sequence['outputs.AssetStatusDatasetResponse']:
        """
        Array of dataset statuses that describe the status of each dataset.
        """
        return pulumi.get(self, "datasets")

    @property
    @pulumi.getter
    def errors(self) -> Sequence['outputs.AssetStatusErrorResponse']:
        """
        Array object to transfer and persist errors that originate from the Edge.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def events(self) -> Sequence['outputs.AssetStatusEventResponse']:
        """
        Array of event statuses that describe the status of each event.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def version(self) -> builtins.float:
        """
        A read only incremental counter indicating the number of times the configuration has been modified from the perspective of the current actual (Edge) state of the Asset. Edge would be the only writer of this value and would sync back up to the cloud. In steady state, this should equal version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AuthenticationResponse(dict):
    """
    Definition of the client authentication mechanism to the server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usernamePasswordCredentials":
            suggest = "username_password_credentials"
        elif key == "x509Credentials":
            suggest = "x509_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[builtins.str] = None,
                 username_password_credentials: Optional['outputs.UsernamePasswordCredentialsResponse'] = None,
                 x509_credentials: Optional['outputs.X509CredentialsResponse'] = None):
        """
        Definition of the client authentication mechanism to the server.
        :param builtins.str method: Defines the method to authenticate the user of the client at the server.
        :param 'UsernamePasswordCredentialsResponse' username_password_credentials: Defines the username and password references when UsernamePassword user authentication mode is selected.
        :param 'X509CredentialsResponse' x509_credentials: Defines the certificate reference when Certificate user authentication mode is selected.
        """
        if method is None:
            method = 'Certificate'
        pulumi.set(__self__, "method", method)
        if username_password_credentials is not None:
            pulumi.set(__self__, "username_password_credentials", username_password_credentials)
        if x509_credentials is not None:
            pulumi.set(__self__, "x509_credentials", x509_credentials)

    @property
    @pulumi.getter
    def method(self) -> builtins.str:
        """
        Defines the method to authenticate the user of the client at the server.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="usernamePasswordCredentials")
    def username_password_credentials(self) -> Optional['outputs.UsernamePasswordCredentialsResponse']:
        """
        Defines the username and password references when UsernamePassword user authentication mode is selected.
        """
        return pulumi.get(self, "username_password_credentials")

    @property
    @pulumi.getter(name="x509Credentials")
    def x509_credentials(self) -> Optional['outputs.X509CredentialsResponse']:
        """
        Defines the certificate reference when Certificate user authentication mode is selected.
        """
        return pulumi.get(self, "x509_credentials")


@pulumi.output_type
class BrokerStateStoreDestinationConfigurationResponse(dict):
    """
    The configuration for a MQTT broker state store destination.
    """
    def __init__(__self__, *,
                 key: builtins.str):
        """
        The configuration for a MQTT broker state store destination.
        :param builtins.str key: The MQTT broker state store destination key.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        The MQTT broker state store destination key.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class DataPointResponse(dict):
    """
    Defines the data point properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "dataPointConfiguration":
            suggest = "data_point_configuration"
        elif key == "observabilityMode":
            suggest = "observability_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataPointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataPointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataPointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: builtins.str,
                 name: builtins.str,
                 data_point_configuration: Optional[builtins.str] = None,
                 observability_mode: Optional[builtins.str] = None):
        """
        Defines the data point properties.
        :param builtins.str data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param builtins.str name: The name of the data point.
        :param builtins.str data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param builtins.str observability_mode: An indication of how the data point should be mapped to OpenTelemetry.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if observability_mode is None:
            observability_mode = 'None'
        if observability_mode is not None:
            pulumi.set(__self__, "observability_mode", observability_mode)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> builtins.str:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @property
    @pulumi.getter(name="observabilityMode")
    def observability_mode(self) -> Optional[builtins.str]:
        """
        An indication of how the data point should be mapped to OpenTelemetry.
        """
        return pulumi.get(self, "observability_mode")


@pulumi.output_type
class DatasetBrokerStateStoreDestinationResponse(dict):
    """
    The type for a MQTT broker state store destination.
    """
    def __init__(__self__, *,
                 configuration: 'outputs.BrokerStateStoreDestinationConfigurationResponse',
                 target: builtins.str):
        """
        The type for a MQTT broker state store destination.
        :param 'BrokerStateStoreDestinationConfigurationResponse' configuration: The MQTT broker state store destination configuration.
        :param builtins.str target: The set of supported dataset destinations for an asset.
               Expected value is 'BrokerStateStore'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'BrokerStateStore')

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.BrokerStateStoreDestinationConfigurationResponse':
        """
        The MQTT broker state store destination configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The set of supported dataset destinations for an asset.
        Expected value is 'BrokerStateStore'.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DatasetMqttDestinationResponse(dict):
    """
    The type for a MQTT destination.
    """
    def __init__(__self__, *,
                 configuration: 'outputs.MqttDestinationConfigurationResponse',
                 target: builtins.str):
        """
        The type for a MQTT destination.
        :param 'MqttDestinationConfigurationResponse' configuration: The MQTT destination configuration.
        :param builtins.str target: The set of supported dataset destinations for an asset.
               Expected value is 'Mqtt'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Mqtt')

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.MqttDestinationConfigurationResponse':
        """
        The MQTT destination configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The set of supported dataset destinations for an asset.
        Expected value is 'Mqtt'.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DatasetResponse(dict):
    """
    Defines the dataset properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPoints":
            suggest = "data_points"
        elif key == "datasetConfiguration":
            suggest = "dataset_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 data_points: Optional[Sequence['outputs.DataPointResponse']] = None,
                 dataset_configuration: Optional[builtins.str] = None,
                 topic: Optional['outputs.TopicResponse'] = None):
        """
        Defines the dataset properties.
        :param builtins.str name: Name of the dataset.
        :param Sequence['DataPointResponse'] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param builtins.str dataset_configuration: Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        :param 'TopicResponse' topic: Object that describes the topic information for the specific dataset.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[Sequence['outputs.DataPointResponse']]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @property
    @pulumi.getter
    def topic(self) -> Optional['outputs.TopicResponse']:
        """
        Object that describes the topic information for the specific dataset.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class DatasetStorageDestinationResponse(dict):
    """
    The type for a storage destination.
    """
    def __init__(__self__, *,
                 configuration: 'outputs.StorageDestinationConfigurationResponse',
                 target: builtins.str):
        """
        The type for a storage destination.
        :param 'StorageDestinationConfigurationResponse' configuration: The storage destination configuration.
        :param builtins.str target: The set of supported dataset destinations for an asset.
               Expected value is 'Storage'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Storage')

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.StorageDestinationConfigurationResponse':
        """
        The storage destination configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The set of supported dataset destinations for an asset.
        Expected value is 'Storage'.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class DeviceMessagingEndpointResponse(dict):
    """
    Device messaging endpoint model.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceMessagingEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceMessagingEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceMessagingEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: builtins.str,
                 endpoint_type: Optional[builtins.str] = None):
        """
        Device messaging endpoint model.
        :param builtins.str address: The endpoint address to connect to.
        :param builtins.str endpoint_type: Type of connection used for the messaging endpoint.
        """
        pulumi.set(__self__, "address", address)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        The endpoint address to connect to.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[builtins.str]:
        """
        Type of connection used for the messaging endpoint.
        """
        return pulumi.get(self, "endpoint_type")


@pulumi.output_type
class DeviceRefResponse(dict):
    """
    Defines which device and endpoint to use for this asset
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "endpointName":
            suggest = "endpoint_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceRefResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceRefResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceRefResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: builtins.str,
                 endpoint_name: builtins.str):
        """
        Defines which device and endpoint to use for this asset
        :param builtins.str device_name: Name of the device resource
        :param builtins.str endpoint_name: The name of endpoint to use
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "endpoint_name", endpoint_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> builtins.str:
        """
        Name of the device resource
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> builtins.str:
        """
        The name of endpoint to use
        """
        return pulumi.get(self, "endpoint_name")


@pulumi.output_type
class DeviceStatusEndpointResponse(dict):
    """
    Defines the device status properties.
    """
    def __init__(__self__, *,
                 error: 'outputs.StatusErrorResponse'):
        """
        Defines the device status properties.
        :param 'StatusErrorResponse' error: Defines the error related to this endpoint.
        """
        pulumi.set(__self__, "error", error)

    @property
    @pulumi.getter
    def error(self) -> 'outputs.StatusErrorResponse':
        """
        Defines the error related to this endpoint.
        """
        return pulumi.get(self, "error")


@pulumi.output_type
class DeviceStatusEndpointsResponse(dict):
    """
    Defines the device status for inbound/outbound endpoints.
    """
    def __init__(__self__, *,
                 inbound: Mapping[str, 'outputs.DeviceStatusEndpointResponse']):
        """
        Defines the device status for inbound/outbound endpoints.
        :param Mapping[str, 'DeviceStatusEndpointResponse'] inbound: KeyValue pair representing status of inbound endpoints.
        """
        pulumi.set(__self__, "inbound", inbound)

    @property
    @pulumi.getter
    def inbound(self) -> Mapping[str, 'outputs.DeviceStatusEndpointResponse']:
        """
        KeyValue pair representing status of inbound endpoints.
        """
        return pulumi.get(self, "inbound")


@pulumi.output_type
class DeviceStatusResponse(dict):
    """
    Defines the device status properties.
    """
    def __init__(__self__, *,
                 config: 'outputs.StatusConfigResponse',
                 endpoints: 'outputs.DeviceStatusEndpointsResponse'):
        """
        Defines the device status properties.
        :param 'StatusConfigResponse' config: Defines the device status config properties.
        :param 'DeviceStatusEndpointsResponse' endpoints: Defines the device status for inbound/outbound endpoints.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "endpoints", endpoints)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.StatusConfigResponse':
        """
        Defines the device status config properties.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def endpoints(self) -> 'outputs.DeviceStatusEndpointsResponse':
        """
        Defines the device status for inbound/outbound endpoints.
        """
        return pulumi.get(self, "endpoints")


@pulumi.output_type
class DiscoveredDataPointResponse(dict):
    """
    Defines the data point properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "dataPointConfiguration":
            suggest = "data_point_configuration"
        elif key == "lastUpdatedOn":
            suggest = "last_updated_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiscoveredDataPointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiscoveredDataPointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiscoveredDataPointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: builtins.str,
                 name: builtins.str,
                 data_point_configuration: Optional[builtins.str] = None,
                 last_updated_on: Optional[builtins.str] = None):
        """
        Defines the data point properties.
        :param builtins.str data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param builtins.str name: The name of the data point.
        :param builtins.str data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param builtins.str last_updated_on: UTC timestamp indicating when the data point was added or modified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> builtins.str:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        UTC timestamp indicating when the data point was added or modified.
        """
        return pulumi.get(self, "last_updated_on")


@pulumi.output_type
class DiscoveredDatasetResponse(dict):
    """
    Defines the dataset properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPoints":
            suggest = "data_points"
        elif key == "datasetConfiguration":
            suggest = "dataset_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiscoveredDatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiscoveredDatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiscoveredDatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 data_points: Optional[Sequence['outputs.DiscoveredDataPointResponse']] = None,
                 dataset_configuration: Optional[builtins.str] = None,
                 topic: Optional['outputs.TopicResponse'] = None):
        """
        Defines the dataset properties.
        :param builtins.str name: Name of the dataset.
        :param Sequence['DiscoveredDataPointResponse'] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param builtins.str dataset_configuration: Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        :param 'TopicResponse' topic: Object that describes the topic information for the specific dataset.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[Sequence['outputs.DiscoveredDataPointResponse']]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @property
    @pulumi.getter
    def topic(self) -> Optional['outputs.TopicResponse']:
        """
        Object that describes the topic information for the specific dataset.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class DiscoveredEventResponse(dict):
    """
    Defines the event properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventNotifier":
            suggest = "event_notifier"
        elif key == "eventConfiguration":
            suggest = "event_configuration"
        elif key == "lastUpdatedOn":
            suggest = "last_updated_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiscoveredEventResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiscoveredEventResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiscoveredEventResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_notifier: builtins.str,
                 name: builtins.str,
                 event_configuration: Optional[builtins.str] = None,
                 last_updated_on: Optional[builtins.str] = None,
                 topic: Optional['outputs.TopicResponse'] = None):
        """
        Defines the event properties.
        :param builtins.str event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param builtins.str name: The name of the event.
        :param builtins.str event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param builtins.str last_updated_on: UTC timestamp indicating when the event was added or modified.
        :param 'TopicResponse' topic: Object that describes the topic information for the specific event.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> builtins.str:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        UTC timestamp indicating when the event was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @property
    @pulumi.getter
    def topic(self) -> Optional['outputs.TopicResponse']:
        """
        Object that describes the topic information for the specific event.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class DiscoveredInboundEndpointsResponse(dict):
    """
    An endpoint to connect to the device.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "additionalConfiguration":
            suggest = "additional_configuration"
        elif key == "lastUpdatedOn":
            suggest = "last_updated_on"
        elif key == "supportedAuthenticationMethods":
            suggest = "supported_authentication_methods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiscoveredInboundEndpointsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiscoveredInboundEndpointsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiscoveredInboundEndpointsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: builtins.str,
                 endpoint_type: builtins.str,
                 additional_configuration: Optional[builtins.str] = None,
                 last_updated_on: Optional[builtins.str] = None,
                 supported_authentication_methods: Optional[Sequence[builtins.str]] = None,
                 version: Optional[builtins.str] = None):
        """
        An endpoint to connect to the device.
        :param builtins.str address: The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        :param builtins.str endpoint_type: Type of connection endpoint.
        :param builtins.str additional_configuration: Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        :param builtins.str last_updated_on: The timestamp (in UTC) when the endpoint was discovered.
        :param Sequence[builtins.str] supported_authentication_methods: List of supported authentication methods supported by device for Inbound connections.
        :param builtins.str version: Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        if additional_configuration is not None:
            pulumi.set(__self__, "additional_configuration", additional_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if supported_authentication_methods is not None:
            pulumi.set(__self__, "supported_authentication_methods", supported_authentication_methods)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of connection endpoint.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="additionalConfiguration")
    def additional_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        """
        return pulumi.get(self, "additional_configuration")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        The timestamp (in UTC) when the endpoint was discovered.
        """
        return pulumi.get(self, "last_updated_on")

    @property
    @pulumi.getter(name="supportedAuthenticationMethods")
    def supported_authentication_methods(self) -> Optional[Sequence[builtins.str]]:
        """
        List of supported authentication methods supported by device for Inbound connections.
        """
        return pulumi.get(self, "supported_authentication_methods")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DiscoveredMessagingEndpointsResponse(dict):
    """
    Connection endpoint URL a device can use to connect to a service.
    """
    def __init__(__self__, *,
                 inbound: Optional[Mapping[str, 'outputs.DiscoveredInboundEndpointsResponse']] = None,
                 outbound: Optional['outputs.DiscoveredOutboundEndpointsResponse'] = None):
        """
        Connection endpoint URL a device can use to connect to a service.
        :param Mapping[str, 'DiscoveredInboundEndpointsResponse'] inbound: Set of endpoints to connect to the device.
        :param 'DiscoveredOutboundEndpointsResponse' outbound: Set of endpoints a device can connect to.
        """
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @property
    @pulumi.getter
    def inbound(self) -> Optional[Mapping[str, 'outputs.DiscoveredInboundEndpointsResponse']]:
        """
        Set of endpoints to connect to the device.
        """
        return pulumi.get(self, "inbound")

    @property
    @pulumi.getter
    def outbound(self) -> Optional['outputs.DiscoveredOutboundEndpointsResponse']:
        """
        Set of endpoints a device can connect to.
        """
        return pulumi.get(self, "outbound")


@pulumi.output_type
class DiscoveredOutboundEndpointsResponse(dict):
    """
    Property bag contains the device's outbound endpoints
    """
    def __init__(__self__, *,
                 assigned: Mapping[str, 'outputs.DeviceMessagingEndpointResponse']):
        """
        Property bag contains the device's outbound endpoints
        :param Mapping[str, 'DeviceMessagingEndpointResponse'] assigned: Endpoints the device can connect to.
        """
        pulumi.set(__self__, "assigned", assigned)

    @property
    @pulumi.getter
    def assigned(self) -> Mapping[str, 'outputs.DeviceMessagingEndpointResponse']:
        """
        Endpoints the device can connect to.
        """
        return pulumi.get(self, "assigned")


@pulumi.output_type
class ErrorDetailsResponse(dict):
    """
    Defines the error details properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "correlationId":
            suggest = "correlation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ErrorDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ErrorDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ErrorDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: builtins.str,
                 correlation_id: builtins.str,
                 info: builtins.str,
                 message: builtins.str):
        """
        Defines the error details properties.
        :param builtins.str code: Multi-part error code for classification and root causing of errors (ex: 400.200.100.432).
        :param builtins.str correlation_id: Unique identifier for the transaction to aid in debugging.
        :param builtins.str info: Human-readable helpful detailed text context for debugging (ex: “The following mechanisms are supported...”).
        :param builtins.str message: Human-readable helpful error message to provide additional context for error (ex: “Authentication method not supported”).
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "correlation_id", correlation_id)
        pulumi.set(__self__, "info", info)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> builtins.str:
        """
        Multi-part error code for classification and root causing of errors (ex: 400.200.100.432).
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> builtins.str:
        """
        Unique identifier for the transaction to aid in debugging.
        """
        return pulumi.get(self, "correlation_id")

    @property
    @pulumi.getter
    def info(self) -> builtins.str:
        """
        Human-readable helpful detailed text context for debugging (ex: “The following mechanisms are supported...”).
        """
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        Human-readable helpful error message to provide additional context for error (ex: “Authentication method not supported”).
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class EventMqttDestinationResponse(dict):
    """
    The type for a MQTT destination.
    """
    def __init__(__self__, *,
                 configuration: 'outputs.MqttDestinationConfigurationResponse',
                 target: builtins.str):
        """
        The type for a MQTT destination.
        :param 'MqttDestinationConfigurationResponse' configuration: The MQTT destination configuration.
        :param builtins.str target: The set of supported event destinations for an asset.
               Expected value is 'Mqtt'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Mqtt')

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.MqttDestinationConfigurationResponse':
        """
        The MQTT destination configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The set of supported event destinations for an asset.
        Expected value is 'Mqtt'.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class EventResponse(dict):
    """
    Defines the event properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventNotifier":
            suggest = "event_notifier"
        elif key == "eventConfiguration":
            suggest = "event_configuration"
        elif key == "observabilityMode":
            suggest = "observability_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_notifier: builtins.str,
                 name: builtins.str,
                 event_configuration: Optional[builtins.str] = None,
                 observability_mode: Optional[builtins.str] = None,
                 topic: Optional['outputs.TopicResponse'] = None):
        """
        Defines the event properties.
        :param builtins.str event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param builtins.str name: The name of the event.
        :param builtins.str event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param builtins.str observability_mode: An indication of how the event should be mapped to OpenTelemetry.
        :param 'TopicResponse' topic: Object that describes the topic information for the specific event.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if observability_mode is None:
            observability_mode = 'None'
        if observability_mode is not None:
            pulumi.set(__self__, "observability_mode", observability_mode)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> builtins.str:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @property
    @pulumi.getter(name="observabilityMode")
    def observability_mode(self) -> Optional[builtins.str]:
        """
        An indication of how the event should be mapped to OpenTelemetry.
        """
        return pulumi.get(self, "observability_mode")

    @property
    @pulumi.getter
    def topic(self) -> Optional['outputs.TopicResponse']:
        """
        Object that describes the topic information for the specific event.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class EventStorageDestinationResponse(dict):
    """
    The type for a storage destination.
    """
    def __init__(__self__, *,
                 configuration: 'outputs.StorageDestinationConfigurationResponse',
                 target: builtins.str):
        """
        The type for a storage destination.
        :param 'StorageDestinationConfigurationResponse' configuration: The storage destination configuration.
        :param builtins.str target: The set of supported event destinations for an asset.
               Expected value is 'Storage'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Storage')

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.StorageDestinationConfigurationResponse':
        """
        The storage destination configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The set of supported event destinations for an asset.
        Expected value is 'Storage'.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    """
    The extended location.
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str):
        """
        The extended location.
        :param builtins.str name: The extended location name.
        :param builtins.str type: The extended location type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The extended location name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The extended location type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HostAuthenticationResponse(dict):
    """
    Definition of the client authentication mechanism to the host.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usernamePasswordCredentials":
            suggest = "username_password_credentials"
        elif key == "x509Credentials":
            suggest = "x509_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[builtins.str] = None,
                 username_password_credentials: Optional['outputs.UsernamePasswordCredentialsResponse'] = None,
                 x509_credentials: Optional['outputs.X509CredentialsResponse'] = None):
        """
        Definition of the client authentication mechanism to the host.
        :param builtins.str method: Defines the method to authenticate the user of the client at the server.
        :param 'UsernamePasswordCredentialsResponse' username_password_credentials: Defines the username and password references when UsernamePassword user authentication mode is selected.
        :param 'X509CredentialsResponse' x509_credentials: Defines the certificate reference when Certificate user authentication mode is selected.
        """
        if method is None:
            method = 'Certificate'
        pulumi.set(__self__, "method", method)
        if username_password_credentials is not None:
            pulumi.set(__self__, "username_password_credentials", username_password_credentials)
        if x509_credentials is not None:
            pulumi.set(__self__, "x509_credentials", x509_credentials)

    @property
    @pulumi.getter
    def method(self) -> builtins.str:
        """
        Defines the method to authenticate the user of the client at the server.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="usernamePasswordCredentials")
    def username_password_credentials(self) -> Optional['outputs.UsernamePasswordCredentialsResponse']:
        """
        Defines the username and password references when UsernamePassword user authentication mode is selected.
        """
        return pulumi.get(self, "username_password_credentials")

    @property
    @pulumi.getter(name="x509Credentials")
    def x509_credentials(self) -> Optional['outputs.X509CredentialsResponse']:
        """
        Defines the certificate reference when Certificate user authentication mode is selected.
        """
        return pulumi.get(self, "x509_credentials")


@pulumi.output_type
class InboundEndpointsResponse(dict):
    """
    An endpoint to connect to the device.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "additionalConfiguration":
            suggest = "additional_configuration"
        elif key == "trustSettings":
            suggest = "trust_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InboundEndpointsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InboundEndpointsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InboundEndpointsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: builtins.str,
                 endpoint_type: builtins.str,
                 additional_configuration: Optional[builtins.str] = None,
                 authentication: Optional['outputs.HostAuthenticationResponse'] = None,
                 trust_settings: Optional['outputs.TrustSettingsResponse'] = None,
                 version: Optional[builtins.str] = None):
        """
        An endpoint to connect to the device.
        :param builtins.str address: The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        :param builtins.str endpoint_type: Type of connection endpoint.
        :param builtins.str additional_configuration: Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        :param 'HostAuthenticationResponse' authentication: Defines the client authentication mechanism to the server.
        :param 'TrustSettingsResponse' trust_settings: Defines server trust settings for the endpoint.
        :param builtins.str version: Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        if additional_configuration is not None:
            pulumi.set(__self__, "additional_configuration", additional_configuration)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if trust_settings is not None:
            pulumi.set(__self__, "trust_settings", trust_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> builtins.str:
        """
        Type of connection endpoint.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="additionalConfiguration")
    def additional_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        """
        return pulumi.get(self, "additional_configuration")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.HostAuthenticationResponse']:
        """
        Defines the client authentication mechanism to the server.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="trustSettings")
    def trust_settings(self) -> Optional['outputs.TrustSettingsResponse']:
        """
        Defines server trust settings for the endpoint.
        """
        return pulumi.get(self, "trust_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ManagementActionResponse(dict):
    """
    Defines the action properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUri":
            suggest = "target_uri"
        elif key == "actionConfiguration":
            suggest = "action_configuration"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 target_uri: builtins.str,
                 action_configuration: Optional[builtins.str] = None,
                 action_type: Optional[builtins.str] = None,
                 timeout_in_seconds: Optional[builtins.int] = None,
                 topic: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the action properties.
        :param builtins.str name: Name of the action.
        :param builtins.str target_uri: The target URI on which a client can invoke the specific action.
        :param builtins.str action_configuration: Stringified JSON that contains connector-specific configuration for the action.
        :param builtins.str action_type: The type of the action.
        :param builtins.int timeout_in_seconds: Response timeout for the action.
        :param builtins.str topic: The MQTT topic path on which a client will receive the request for the action.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_uri", target_uri)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)
        if action_type is None:
            action_type = 'Call'
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> builtins.str:
        """
        The target URI on which a client can invoke the specific action.
        """
        return pulumi.get(self, "target_uri")

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the action.
        """
        return pulumi.get(self, "action_configuration")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[builtins.str]:
        """
        The type of the action.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[builtins.int]:
        """
        Response timeout for the action.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def topic(self) -> Optional[builtins.str]:
        """
        The MQTT topic path on which a client will receive the request for the action.
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class ManagementGroupResponse(dict):
    """
    Defines the management group properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTimeoutInSeconds":
            suggest = "default_timeout_in_seconds"
        elif key == "defaultTopic":
            suggest = "default_topic"
        elif key == "managementGroupConfiguration":
            suggest = "management_group_configuration"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagementGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagementGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagementGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 actions: Optional[Sequence['outputs.ManagementActionResponse']] = None,
                 default_timeout_in_seconds: Optional[builtins.int] = None,
                 default_topic: Optional[builtins.str] = None,
                 management_group_configuration: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the management group properties.
        :param builtins.str name: Name of the management group.
        :param Sequence['ManagementActionResponse'] actions: Array of actions that are part of the management group. Each action can have an individual configuration.
        :param builtins.int default_timeout_in_seconds: Default response timeout for all actions that are part of the management group.
        :param builtins.str default_topic: Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        :param builtins.str management_group_configuration: Stringified JSON that contains connector-specific configuration for the management group.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if default_timeout_in_seconds is None:
            default_timeout_in_seconds = 100
        if default_timeout_in_seconds is not None:
            pulumi.set(__self__, "default_timeout_in_seconds", default_timeout_in_seconds)
        if default_topic is not None:
            pulumi.set(__self__, "default_topic", default_topic)
        if management_group_configuration is not None:
            pulumi.set(__self__, "management_group_configuration", management_group_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the management group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.ManagementActionResponse']]:
        """
        Array of actions that are part of the management group. Each action can have an individual configuration.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="defaultTimeoutInSeconds")
    def default_timeout_in_seconds(self) -> Optional[builtins.int]:
        """
        Default response timeout for all actions that are part of the management group.
        """
        return pulumi.get(self, "default_timeout_in_seconds")

    @property
    @pulumi.getter(name="defaultTopic")
    def default_topic(self) -> Optional[builtins.str]:
        """
        Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        """
        return pulumi.get(self, "default_topic")

    @property
    @pulumi.getter(name="managementGroupConfiguration")
    def management_group_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the management group.
        """
        return pulumi.get(self, "management_group_configuration")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class MessageSchemaReferenceResponse(dict):
    """
    Defines the message schema reference properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaName":
            suggest = "schema_name"
        elif key == "schemaRegistryNamespace":
            suggest = "schema_registry_namespace"
        elif key == "schemaVersion":
            suggest = "schema_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageSchemaReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageSchemaReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageSchemaReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_name: builtins.str,
                 schema_registry_namespace: builtins.str,
                 schema_version: builtins.str):
        """
        Defines the message schema reference properties.
        :param builtins.str schema_name: The message schema name.
        :param builtins.str schema_registry_namespace: The message schema registry namespace.
        :param builtins.str schema_version: The message schema version.
        """
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "schema_registry_namespace", schema_registry_namespace)
        pulumi.set(__self__, "schema_version", schema_version)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> builtins.str:
        """
        The message schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="schemaRegistryNamespace")
    def schema_registry_namespace(self) -> builtins.str:
        """
        The message schema registry namespace.
        """
        return pulumi.get(self, "schema_registry_namespace")

    @property
    @pulumi.getter(name="schemaVersion")
    def schema_version(self) -> builtins.str:
        """
        The message schema version.
        """
        return pulumi.get(self, "schema_version")


@pulumi.output_type
class MessagingEndpointResponse(dict):
    """
    Namespace messaging endpoint model used by a device to connect to a service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointType":
            suggest = "endpoint_type"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessagingEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessagingEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessagingEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: builtins.str,
                 endpoint_type: Optional[builtins.str] = None,
                 resource_id: Optional[builtins.str] = None):
        """
        Namespace messaging endpoint model used by a device to connect to a service.
        :param builtins.str address: The endpoint address to connect to.
        :param builtins.str endpoint_type: Type of connection used for messaging endpoint.
        :param builtins.str resource_id: The messaging endpoint Azure resource Id.
        """
        pulumi.set(__self__, "address", address)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        The endpoint address to connect to.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[builtins.str]:
        """
        Type of connection used for messaging endpoint.
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[builtins.str]:
        """
        The messaging endpoint Azure resource Id.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class MessagingEndpointsResponse(dict):
    """
    Connection endpoint URL a device can use to connect to a service.
    """
    def __init__(__self__, *,
                 inbound: Optional[Mapping[str, 'outputs.InboundEndpointsResponse']] = None,
                 outbound: Optional['outputs.OutboundEndpointsResponse'] = None):
        """
        Connection endpoint URL a device can use to connect to a service.
        :param Mapping[str, 'InboundEndpointsResponse'] inbound: Set of endpoints to connect to the device.
        :param 'OutboundEndpointsResponse' outbound: Set of endpoints a device can connect to.
        """
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @property
    @pulumi.getter
    def inbound(self) -> Optional[Mapping[str, 'outputs.InboundEndpointsResponse']]:
        """
        Set of endpoints to connect to the device.
        """
        return pulumi.get(self, "inbound")

    @property
    @pulumi.getter
    def outbound(self) -> Optional['outputs.OutboundEndpointsResponse']:
        """
        Set of endpoints a device can connect to.
        """
        return pulumi.get(self, "outbound")


@pulumi.output_type
class MessagingResponse(dict):
    """
    The namespace messaging endpoints model.
    """
    def __init__(__self__, *,
                 endpoints: Optional[Mapping[str, 'outputs.MessagingEndpointResponse']] = None):
        """
        The namespace messaging endpoints model.
        :param Mapping[str, 'MessagingEndpointResponse'] endpoints: Dictionary of messaging endpoints.
        """
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Mapping[str, 'outputs.MessagingEndpointResponse']]:
        """
        Dictionary of messaging endpoints.
        """
        return pulumi.get(self, "endpoints")


@pulumi.output_type
class MqttDestinationConfigurationResponse(dict):
    """
    The configuration for a MQTT destination.
    """
    def __init__(__self__, *,
                 topic: builtins.str,
                 qos: Optional[builtins.str] = None,
                 retain: Optional[builtins.str] = None,
                 ttl: Optional[builtins.float] = None):
        """
        The configuration for a MQTT destination.
        :param builtins.str topic: The MQTT topic.
        :param builtins.str qos: The MQTT QoS setting. Defaults to QoS 1.
        :param builtins.str retain: When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        :param builtins.float ttl: The MQTT TTL setting.
        """
        pulumi.set(__self__, "topic", topic)
        if qos is None:
            qos = 'Qos1'
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if retain is None:
            retain = 'Never'
        if retain is not None:
            pulumi.set(__self__, "retain", retain)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def topic(self) -> builtins.str:
        """
        The MQTT topic.
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter
    def qos(self) -> Optional[builtins.str]:
        """
        The MQTT QoS setting. Defaults to QoS 1.
        """
        return pulumi.get(self, "qos")

    @property
    @pulumi.getter
    def retain(self) -> Optional[builtins.str]:
        """
        When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
        return pulumi.get(self, "retain")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[builtins.float]:
        """
        The MQTT TTL setting.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class NamespaceAssetStatusDatasetResponse(dict):
    """
    Defines the asset status dataset properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageSchemaReference":
            suggest = "message_schema_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceAssetStatusDatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceAssetStatusDatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceAssetStatusDatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.StatusErrorResponse',
                 message_schema_reference: 'outputs.NamespaceMessageSchemaReferenceResponse',
                 name: builtins.str):
        """
        Defines the asset status dataset properties.
        :param 'StatusErrorResponse' error: Object to transfer and persist errors that originate from the edge.
        :param 'NamespaceMessageSchemaReferenceResponse' message_schema_reference: The message schema reference object.
        :param builtins.str name: The name of the dataset. Must be unique within the status.datasets array. This name is used to correlate between the spec and status dataset information.
        """
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "message_schema_reference", message_schema_reference)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def error(self) -> 'outputs.StatusErrorResponse':
        """
        Object to transfer and persist errors that originate from the edge.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="messageSchemaReference")
    def message_schema_reference(self) -> 'outputs.NamespaceMessageSchemaReferenceResponse':
        """
        The message schema reference object.
        """
        return pulumi.get(self, "message_schema_reference")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the dataset. Must be unique within the status.datasets array. This name is used to correlate between the spec and status dataset information.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NamespaceAssetStatusEventResponse(dict):
    """
    Defines the asset status event properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageSchemaReference":
            suggest = "message_schema_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceAssetStatusEventResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceAssetStatusEventResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceAssetStatusEventResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.StatusErrorResponse',
                 message_schema_reference: 'outputs.NamespaceMessageSchemaReferenceResponse',
                 name: builtins.str):
        """
        Defines the asset status event properties.
        :param 'StatusErrorResponse' error: Object to transfer and persist errors that originate from the edge.
        :param 'NamespaceMessageSchemaReferenceResponse' message_schema_reference: The message schema reference object.
        :param builtins.str name: The name of the event. Must be unique within the status.events array. This name is used to correlate between the spec and status event information.
        """
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "message_schema_reference", message_schema_reference)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def error(self) -> 'outputs.StatusErrorResponse':
        """
        Object to transfer and persist errors that originate from the edge.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="messageSchemaReference")
    def message_schema_reference(self) -> 'outputs.NamespaceMessageSchemaReferenceResponse':
        """
        The message schema reference object.
        """
        return pulumi.get(self, "message_schema_reference")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the event. Must be unique within the status.events array. This name is used to correlate between the spec and status event information.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NamespaceAssetStatusManagementActionResponse(dict):
    """
    Defines the asset status action properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestMessageSchemaReference":
            suggest = "request_message_schema_reference"
        elif key == "responseMessageSchemaReference":
            suggest = "response_message_schema_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceAssetStatusManagementActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceAssetStatusManagementActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceAssetStatusManagementActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.StatusErrorResponse',
                 name: builtins.str,
                 request_message_schema_reference: 'outputs.NamespaceMessageSchemaReferenceResponse',
                 response_message_schema_reference: 'outputs.NamespaceMessageSchemaReferenceResponse'):
        """
        Defines the asset status action properties.
        :param 'StatusErrorResponse' error: Object to transfer and persist errors that originate from the edge.
        :param builtins.str name: The name of the action. Must be unique within the status.actions array. This name is used to correlate between the spec and status event information.
        :param 'NamespaceMessageSchemaReferenceResponse' request_message_schema_reference: The request message schema reference object for the action.
        :param 'NamespaceMessageSchemaReferenceResponse' response_message_schema_reference: The response message schema reference object for the action.
        """
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "request_message_schema_reference", request_message_schema_reference)
        pulumi.set(__self__, "response_message_schema_reference", response_message_schema_reference)

    @property
    @pulumi.getter
    def error(self) -> 'outputs.StatusErrorResponse':
        """
        Object to transfer and persist errors that originate from the edge.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the action. Must be unique within the status.actions array. This name is used to correlate between the spec and status event information.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="requestMessageSchemaReference")
    def request_message_schema_reference(self) -> 'outputs.NamespaceMessageSchemaReferenceResponse':
        """
        The request message schema reference object for the action.
        """
        return pulumi.get(self, "request_message_schema_reference")

    @property
    @pulumi.getter(name="responseMessageSchemaReference")
    def response_message_schema_reference(self) -> 'outputs.NamespaceMessageSchemaReferenceResponse':
        """
        The response message schema reference object for the action.
        """
        return pulumi.get(self, "response_message_schema_reference")


@pulumi.output_type
class NamespaceAssetStatusManagementGroupResponse(dict):
    """
    Defines the asset status management group properties.
    """
    def __init__(__self__, *,
                 actions: Sequence['outputs.NamespaceAssetStatusManagementActionResponse'],
                 name: builtins.str):
        """
        Defines the asset status management group properties.
        :param Sequence['NamespaceAssetStatusManagementActionResponse'] actions: Array of action statuses that describe the status of each action.
        :param builtins.str name: The name of the management group. Must be unique within the status.managementGroups array. This name is used to correlate between the spec and status event information.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.NamespaceAssetStatusManagementActionResponse']:
        """
        Array of action statuses that describe the status of each action.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the management group. Must be unique within the status.managementGroups array. This name is used to correlate between the spec and status event information.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NamespaceAssetStatusResponse(dict):
    """
    Defines the asset status properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementGroups":
            suggest = "management_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceAssetStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceAssetStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceAssetStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: 'outputs.StatusConfigResponse',
                 datasets: Sequence['outputs.NamespaceAssetStatusDatasetResponse'],
                 events: Sequence['outputs.NamespaceAssetStatusEventResponse'],
                 management_groups: Sequence['outputs.NamespaceAssetStatusManagementGroupResponse'],
                 streams: Sequence['outputs.NamespaceAssetStatusStreamResponse']):
        """
        Defines the asset status properties.
        :param 'StatusConfigResponse' config: Defines the asset status config properties.
        :param Sequence['NamespaceAssetStatusDatasetResponse'] datasets: Array of dataset statuses that describe the status of each dataset.
        :param Sequence['NamespaceAssetStatusEventResponse'] events: Array of event statuses that describe the status of each event.
        :param Sequence['NamespaceAssetStatusManagementGroupResponse'] management_groups: Array of management group statuses that describe the status of each management group.
        :param Sequence['NamespaceAssetStatusStreamResponse'] streams: Array of stream statuses that describe the status of each stream.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "datasets", datasets)
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "management_groups", management_groups)
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def config(self) -> 'outputs.StatusConfigResponse':
        """
        Defines the asset status config properties.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def datasets(self) -> Sequence['outputs.NamespaceAssetStatusDatasetResponse']:
        """
        Array of dataset statuses that describe the status of each dataset.
        """
        return pulumi.get(self, "datasets")

    @property
    @pulumi.getter
    def events(self) -> Sequence['outputs.NamespaceAssetStatusEventResponse']:
        """
        Array of event statuses that describe the status of each event.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="managementGroups")
    def management_groups(self) -> Sequence['outputs.NamespaceAssetStatusManagementGroupResponse']:
        """
        Array of management group statuses that describe the status of each management group.
        """
        return pulumi.get(self, "management_groups")

    @property
    @pulumi.getter
    def streams(self) -> Sequence['outputs.NamespaceAssetStatusStreamResponse']:
        """
        Array of stream statuses that describe the status of each stream.
        """
        return pulumi.get(self, "streams")


@pulumi.output_type
class NamespaceAssetStatusStreamResponse(dict):
    """
    Defines the asset status stream properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageSchemaReference":
            suggest = "message_schema_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceAssetStatusStreamResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceAssetStatusStreamResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceAssetStatusStreamResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.StatusErrorResponse',
                 message_schema_reference: 'outputs.NamespaceMessageSchemaReferenceResponse',
                 name: builtins.str):
        """
        Defines the asset status stream properties.
        :param 'StatusErrorResponse' error: Object to transfer and persist errors that originate from the edge.
        :param 'NamespaceMessageSchemaReferenceResponse' message_schema_reference: The message schema reference object.
        :param builtins.str name: The name of the stream. Must be unique within the status.streams array. This name is used to correlate between the spec and status event information.
        """
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "message_schema_reference", message_schema_reference)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def error(self) -> 'outputs.StatusErrorResponse':
        """
        Object to transfer and persist errors that originate from the edge.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="messageSchemaReference")
    def message_schema_reference(self) -> 'outputs.NamespaceMessageSchemaReferenceResponse':
        """
        The message schema reference object.
        """
        return pulumi.get(self, "message_schema_reference")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the stream. Must be unique within the status.streams array. This name is used to correlate between the spec and status event information.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NamespaceDatasetDataPointResponse(dict):
    """
    Defines the dataset data point properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "dataPointConfiguration":
            suggest = "data_point_configuration"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceDatasetDataPointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceDatasetDataPointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceDatasetDataPointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: builtins.str,
                 name: builtins.str,
                 data_point_configuration: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the dataset data point properties.
        :param builtins.str data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param builtins.str name: The name of the data point.
        :param builtins.str data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> builtins.str:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class NamespaceDatasetResponse(dict):
    """
    Defines the dataset properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPoints":
            suggest = "data_points"
        elif key == "dataSource":
            suggest = "data_source"
        elif key == "datasetConfiguration":
            suggest = "dataset_configuration"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceDatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceDatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceDatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 data_points: Optional[Sequence['outputs.NamespaceDatasetDataPointResponse']] = None,
                 data_source: Optional[builtins.str] = None,
                 dataset_configuration: Optional[builtins.str] = None,
                 destinations: Optional[Sequence[Any]] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the dataset properties.
        :param builtins.str name: Name of the dataset.
        :param Sequence['NamespaceDatasetDataPointResponse'] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param builtins.str data_source: Reference to a data source for a given dataset.
        :param builtins.str dataset_configuration: Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        :param Sequence[Union['DatasetBrokerStateStoreDestinationResponse', 'DatasetMqttDestinationResponse', 'DatasetStorageDestinationResponse']] destinations: Destinations for a dataset.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[Sequence['outputs.NamespaceDatasetDataPointResponse']]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[builtins.str]:
        """
        Reference to a data source for a given dataset.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[Any]]:
        """
        Destinations for a dataset.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class NamespaceDiscoveredDatasetDataPointResponse(dict):
    """
    Defines the discovered dataset data point properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "dataPointConfiguration":
            suggest = "data_point_configuration"
        elif key == "lastUpdatedOn":
            suggest = "last_updated_on"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceDiscoveredDatasetDataPointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceDiscoveredDatasetDataPointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceDiscoveredDatasetDataPointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: builtins.str,
                 name: builtins.str,
                 data_point_configuration: Optional[builtins.str] = None,
                 last_updated_on: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the discovered dataset data point properties.
        :param builtins.str data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param builtins.str name: The name of the data point.
        :param builtins.str data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param builtins.str last_updated_on: UTC timestamp indicating when the data point was added or modified.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> builtins.str:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        UTC timestamp indicating when the data point was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class NamespaceDiscoveredDatasetResponse(dict):
    """
    Defines the dataset properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataPoints":
            suggest = "data_points"
        elif key == "dataSource":
            suggest = "data_source"
        elif key == "datasetConfiguration":
            suggest = "dataset_configuration"
        elif key == "lastUpdatedOn":
            suggest = "last_updated_on"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceDiscoveredDatasetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceDiscoveredDatasetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceDiscoveredDatasetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 data_points: Optional[Sequence['outputs.NamespaceDiscoveredDatasetDataPointResponse']] = None,
                 data_source: Optional[builtins.str] = None,
                 dataset_configuration: Optional[builtins.str] = None,
                 destinations: Optional[Sequence[Any]] = None,
                 last_updated_on: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the dataset properties.
        :param builtins.str name: Name of the dataset.
        :param Sequence['NamespaceDiscoveredDatasetDataPointResponse'] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param builtins.str data_source: Reference to a data source for a given dataset.
        :param builtins.str dataset_configuration: Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        :param Sequence[Union['DatasetBrokerStateStoreDestinationResponse', 'DatasetMqttDestinationResponse', 'DatasetStorageDestinationResponse']] destinations: Destinations for a dataset.
        :param builtins.str last_updated_on: Timestamp (in UTC) indicating when the dataset was added or modified.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[Sequence['outputs.NamespaceDiscoveredDatasetDataPointResponse']]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[builtins.str]:
        """
        Reference to a data source for a given dataset.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[Any]]:
        """
        Destinations for a dataset.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        Timestamp (in UTC) indicating when the dataset was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class NamespaceDiscoveredEventDataPointResponse(dict):
    """
    Defines the discovered event data point properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "dataPointConfiguration":
            suggest = "data_point_configuration"
        elif key == "lastUpdatedOn":
            suggest = "last_updated_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceDiscoveredEventDataPointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceDiscoveredEventDataPointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceDiscoveredEventDataPointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: builtins.str,
                 name: builtins.str,
                 data_point_configuration: Optional[builtins.str] = None,
                 last_updated_on: Optional[builtins.str] = None):
        """
        Defines the discovered event data point properties.
        :param builtins.str data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param builtins.str name: The name of the data point.
        :param builtins.str data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param builtins.str last_updated_on: UTC timestamp indicating when the data point was added or modified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> builtins.str:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        UTC timestamp indicating when the data point was added or modified.
        """
        return pulumi.get(self, "last_updated_on")


@pulumi.output_type
class NamespaceDiscoveredEventResponse(dict):
    """
    Defines the event properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventNotifier":
            suggest = "event_notifier"
        elif key == "dataPoints":
            suggest = "data_points"
        elif key == "eventConfiguration":
            suggest = "event_configuration"
        elif key == "lastUpdatedOn":
            suggest = "last_updated_on"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceDiscoveredEventResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceDiscoveredEventResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceDiscoveredEventResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_notifier: builtins.str,
                 name: builtins.str,
                 data_points: Optional[Sequence['outputs.NamespaceDiscoveredEventDataPointResponse']] = None,
                 destinations: Optional[Sequence[Any]] = None,
                 event_configuration: Optional[builtins.str] = None,
                 last_updated_on: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the event properties.
        :param builtins.str event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param builtins.str name: The name of the event.
        :param Sequence['NamespaceDiscoveredEventDataPointResponse'] data_points: Array of data points that are part of the event. Each data point can have a per-data point configuration.
        :param Sequence[Union['EventMqttDestinationResponse', 'EventStorageDestinationResponse']] destinations: Destinations for an event.
        :param builtins.str event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param builtins.str last_updated_on: UTC timestamp indicating when the event was added or modified.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> builtins.str:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[Sequence['outputs.NamespaceDiscoveredEventDataPointResponse']]:
        """
        Array of data points that are part of the event. Each data point can have a per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[Any]]:
        """
        Destinations for an event.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        UTC timestamp indicating when the event was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class NamespaceDiscoveredManagementActionResponse(dict):
    """
    Defines the action properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUri":
            suggest = "target_uri"
        elif key == "actionConfiguration":
            suggest = "action_configuration"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "lastUpdatedOn":
            suggest = "last_updated_on"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceDiscoveredManagementActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceDiscoveredManagementActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceDiscoveredManagementActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 target_uri: builtins.str,
                 action_configuration: Optional[builtins.str] = None,
                 action_type: Optional[builtins.str] = None,
                 last_updated_on: Optional[builtins.str] = None,
                 timeout_in_seconds: Optional[builtins.int] = None,
                 topic: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the action properties.
        :param builtins.str name: Name of the action.
        :param builtins.str target_uri: The target URI on which a client can invoke the specific action.
        :param builtins.str action_configuration: Stringified JSON that contains connector-specific configuration for the action.
        :param builtins.str action_type: The type of the action.
        :param builtins.str last_updated_on: Timestamp (in UTC) indicating when the management action was added or modified.
        :param builtins.int timeout_in_seconds: Response timeout for the action.
        :param builtins.str topic: The MQTT topic path on which a client will receive the request for the action.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_uri", target_uri)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)
        if action_type is None:
            action_type = 'Call'
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> builtins.str:
        """
        The target URI on which a client can invoke the specific action.
        """
        return pulumi.get(self, "target_uri")

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the action.
        """
        return pulumi.get(self, "action_configuration")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[builtins.str]:
        """
        The type of the action.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        Timestamp (in UTC) indicating when the management action was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[builtins.int]:
        """
        Response timeout for the action.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @property
    @pulumi.getter
    def topic(self) -> Optional[builtins.str]:
        """
        The MQTT topic path on which a client will receive the request for the action.
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class NamespaceDiscoveredManagementGroupResponse(dict):
    """
    Defines the management group properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultTimeoutInSeconds":
            suggest = "default_timeout_in_seconds"
        elif key == "defaultTopic":
            suggest = "default_topic"
        elif key == "lastUpdatedOn":
            suggest = "last_updated_on"
        elif key == "managementGroupConfiguration":
            suggest = "management_group_configuration"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceDiscoveredManagementGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceDiscoveredManagementGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceDiscoveredManagementGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 actions: Optional[Sequence['outputs.NamespaceDiscoveredManagementActionResponse']] = None,
                 default_timeout_in_seconds: Optional[builtins.int] = None,
                 default_topic: Optional[builtins.str] = None,
                 last_updated_on: Optional[builtins.str] = None,
                 management_group_configuration: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the management group properties.
        :param builtins.str name: Name of the management group.
        :param Sequence['NamespaceDiscoveredManagementActionResponse'] actions: Array of actions that are part of the management group. Each action can have an individual configuration.
        :param builtins.int default_timeout_in_seconds: Default response timeout for all actions that are part of the management group.
        :param builtins.str default_topic: Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        :param builtins.str last_updated_on: Timestamp (in UTC) indicating when the management group was added or modified.
        :param builtins.str management_group_configuration: Stringified JSON that contains connector-specific configuration for the management group.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if default_timeout_in_seconds is None:
            default_timeout_in_seconds = 100
        if default_timeout_in_seconds is not None:
            pulumi.set(__self__, "default_timeout_in_seconds", default_timeout_in_seconds)
        if default_topic is not None:
            pulumi.set(__self__, "default_topic", default_topic)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if management_group_configuration is not None:
            pulumi.set(__self__, "management_group_configuration", management_group_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the management group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.NamespaceDiscoveredManagementActionResponse']]:
        """
        Array of actions that are part of the management group. Each action can have an individual configuration.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="defaultTimeoutInSeconds")
    def default_timeout_in_seconds(self) -> Optional[builtins.int]:
        """
        Default response timeout for all actions that are part of the management group.
        """
        return pulumi.get(self, "default_timeout_in_seconds")

    @property
    @pulumi.getter(name="defaultTopic")
    def default_topic(self) -> Optional[builtins.str]:
        """
        Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        """
        return pulumi.get(self, "default_topic")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        Timestamp (in UTC) indicating when the management group was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @property
    @pulumi.getter(name="managementGroupConfiguration")
    def management_group_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the management group.
        """
        return pulumi.get(self, "management_group_configuration")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class NamespaceDiscoveredStreamResponse(dict):
    """
    Defines the stream properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastUpdatedOn":
            suggest = "last_updated_on"
        elif key == "streamConfiguration":
            suggest = "stream_configuration"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceDiscoveredStreamResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceDiscoveredStreamResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceDiscoveredStreamResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 destinations: Optional[Sequence[Any]] = None,
                 last_updated_on: Optional[builtins.str] = None,
                 stream_configuration: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the stream properties.
        :param builtins.str name: Name of the stream definition.
        :param Sequence[Union['StreamMqttDestinationResponse', 'StreamStorageDestinationResponse']] destinations: Destinations for a stream.
        :param builtins.str last_updated_on: Timestamp (in UTC) indicating when the stream was added or modified.
        :param builtins.str stream_configuration: Stringified JSON that contains connector-specific configuration for the specific stream.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if stream_configuration is not None:
            pulumi.set(__self__, "stream_configuration", stream_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the stream definition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[Any]]:
        """
        Destinations for a stream.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[builtins.str]:
        """
        Timestamp (in UTC) indicating when the stream was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @property
    @pulumi.getter(name="streamConfiguration")
    def stream_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the specific stream.
        """
        return pulumi.get(self, "stream_configuration")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class NamespaceEventDataPointResponse(dict):
    """
    Defines the event data point properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "dataPointConfiguration":
            suggest = "data_point_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceEventDataPointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceEventDataPointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceEventDataPointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: builtins.str,
                 name: builtins.str,
                 data_point_configuration: Optional[builtins.str] = None):
        """
        Defines the event data point properties.
        :param builtins.str data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param builtins.str name: The name of the data point.
        :param builtins.str data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> builtins.str:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")


@pulumi.output_type
class NamespaceEventResponse(dict):
    """
    Defines the event properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventNotifier":
            suggest = "event_notifier"
        elif key == "dataPoints":
            suggest = "data_points"
        elif key == "eventConfiguration":
            suggest = "event_configuration"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceEventResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceEventResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceEventResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_notifier: builtins.str,
                 name: builtins.str,
                 data_points: Optional[Sequence['outputs.NamespaceEventDataPointResponse']] = None,
                 destinations: Optional[Sequence[Any]] = None,
                 event_configuration: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the event properties.
        :param builtins.str event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param builtins.str name: The name of the event.
        :param Sequence['NamespaceEventDataPointResponse'] data_points: Array of data points that are part of the event. Each data point can have a per-data point configuration.
        :param Sequence[Union['EventMqttDestinationResponse', 'EventStorageDestinationResponse']] destinations: Destinations for an event.
        :param builtins.str event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> builtins.str:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[Sequence['outputs.NamespaceEventDataPointResponse']]:
        """
        Array of data points that are part of the event. Each data point can have a per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[Any]]:
        """
        Destinations for an event.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class NamespaceMessageSchemaReferenceResponse(dict):
    """
    Defines the message schema reference properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaName":
            suggest = "schema_name"
        elif key == "schemaRegistryNamespace":
            suggest = "schema_registry_namespace"
        elif key == "schemaVersion":
            suggest = "schema_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceMessageSchemaReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceMessageSchemaReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceMessageSchemaReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_name: builtins.str,
                 schema_registry_namespace: builtins.str,
                 schema_version: builtins.str):
        """
        Defines the message schema reference properties.
        :param builtins.str schema_name: The message schema name.
        :param builtins.str schema_registry_namespace: The message schema registry namespace.
        :param builtins.str schema_version: The message schema version.
        """
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "schema_registry_namespace", schema_registry_namespace)
        pulumi.set(__self__, "schema_version", schema_version)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> builtins.str:
        """
        The message schema name.
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter(name="schemaRegistryNamespace")
    def schema_registry_namespace(self) -> builtins.str:
        """
        The message schema registry namespace.
        """
        return pulumi.get(self, "schema_registry_namespace")

    @property
    @pulumi.getter(name="schemaVersion")
    def schema_version(self) -> builtins.str:
        """
        The message schema version.
        """
        return pulumi.get(self, "schema_version")


@pulumi.output_type
class NamespaceStreamResponse(dict):
    """
    Defines the stream properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamConfiguration":
            suggest = "stream_configuration"
        elif key == "typeRef":
            suggest = "type_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceStreamResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceStreamResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceStreamResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 destinations: Optional[Sequence[Any]] = None,
                 stream_configuration: Optional[builtins.str] = None,
                 type_ref: Optional[builtins.str] = None):
        """
        Defines the stream properties.
        :param builtins.str name: Name of the stream definition.
        :param Sequence[Union['StreamMqttDestinationResponse', 'StreamStorageDestinationResponse']] destinations: Destinations for a stream.
        :param builtins.str stream_configuration: Stringified JSON that contains connector-specific configuration for the specific stream.
        :param builtins.str type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if stream_configuration is not None:
            pulumi.set(__self__, "stream_configuration", stream_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the stream definition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[Any]]:
        """
        Destinations for a stream.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="streamConfiguration")
    def stream_configuration(self) -> Optional[builtins.str]:
        """
        Stringified JSON that contains connector-specific configuration for the specific stream.
        """
        return pulumi.get(self, "stream_configuration")

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[builtins.str]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")


@pulumi.output_type
class OutboundEndpointsResponse(dict):
    """
    Property bag contains the device's outbound endpoints
    """
    def __init__(__self__, *,
                 assigned: Mapping[str, 'outputs.DeviceMessagingEndpointResponse'],
                 unassigned: Optional[Mapping[str, 'outputs.DeviceMessagingEndpointResponse']] = None):
        """
        Property bag contains the device's outbound endpoints
        :param Mapping[str, 'DeviceMessagingEndpointResponse'] assigned: Endpoints the device can connect to.
        :param Mapping[str, 'DeviceMessagingEndpointResponse'] unassigned: Set of most recently removed endpoints.
        """
        pulumi.set(__self__, "assigned", assigned)
        if unassigned is not None:
            pulumi.set(__self__, "unassigned", unassigned)

    @property
    @pulumi.getter
    def assigned(self) -> Mapping[str, 'outputs.DeviceMessagingEndpointResponse']:
        """
        Endpoints the device can connect to.
        """
        return pulumi.get(self, "assigned")

    @property
    @pulumi.getter
    def unassigned(self) -> Optional[Mapping[str, 'outputs.DeviceMessagingEndpointResponse']]:
        """
        Set of most recently removed endpoints.
        """
        return pulumi.get(self, "unassigned")


@pulumi.output_type
class StatusConfigResponse(dict):
    """
    Defines the status config properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: 'outputs.StatusErrorResponse',
                 last_transition_time: builtins.str,
                 version: builtins.float):
        """
        Defines the status config properties.
        :param 'StatusErrorResponse' error: Object to transfer and persist errors that originate from the edge.
        :param builtins.str last_transition_time: A read-only timestamp indicating the last time the configuration has been modified from the perspective of the current actual (edge) state of the CRD. Edge would be the only writer of this value and would sync back up to the cloud.
        :param builtins.float version: A read-only incremental counter indicating the number of times the configuration has been modified from the perspective of the current actual (edge) state of the CRD. Edge would be the only writer of this value and would sync back up to the cloud. In steady state, this should equal version.
        """
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def error(self) -> 'outputs.StatusErrorResponse':
        """
        Object to transfer and persist errors that originate from the edge.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> builtins.str:
        """
        A read-only timestamp indicating the last time the configuration has been modified from the perspective of the current actual (edge) state of the CRD. Edge would be the only writer of this value and would sync back up to the cloud.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def version(self) -> builtins.float:
        """
        A read-only incremental counter indicating the number of times the configuration has been modified from the perspective of the current actual (edge) state of the CRD. Edge would be the only writer of this value and would sync back up to the cloud. In steady state, this should equal version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class StatusErrorResponse(dict):
    """
    Defines the status config error properties.
    """
    def __init__(__self__, *,
                 code: builtins.str,
                 details: Sequence['outputs.ErrorDetailsResponse'],
                 message: builtins.str):
        """
        Defines the status config error properties.
        :param builtins.str code: Error code for classification of errors (ex: '400', '404', '500', etc.).
        :param Sequence['ErrorDetailsResponse'] details: Array of error details that describe the status of each error.
        :param builtins.str message: Human-readable helpful error message to provide additional context for error (e.g.,: “Capability ID 'foo' does not exist”).
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> builtins.str:
        """
        Error code for classification of errors (ex: '400', '404', '500', etc.).
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailsResponse']:
        """
        Array of error details that describe the status of each error.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        Human-readable helpful error message to provide additional context for error (e.g.,: “Capability ID 'foo' does not exist”).
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class StorageDestinationConfigurationResponse(dict):
    """
    The configuration for a storage destination.
    """
    def __init__(__self__, *,
                 path: builtins.str):
        """
        The configuration for a storage destination.
        :param builtins.str path: The storage destination path.
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The storage destination path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class StreamMqttDestinationResponse(dict):
    """
    The type for a MQTT destination.
    """
    def __init__(__self__, *,
                 configuration: 'outputs.MqttDestinationConfigurationResponse',
                 target: builtins.str):
        """
        The type for a MQTT destination.
        :param 'MqttDestinationConfigurationResponse' configuration: The MQTT destination configuration.
        :param builtins.str target: The set of supported stream destinations for an asset.
               Expected value is 'Mqtt'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Mqtt')

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.MqttDestinationConfigurationResponse':
        """
        The MQTT destination configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The set of supported stream destinations for an asset.
        Expected value is 'Mqtt'.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class StreamStorageDestinationResponse(dict):
    """
    The type for a storage destination.
    """
    def __init__(__self__, *,
                 configuration: 'outputs.StorageDestinationConfigurationResponse',
                 target: builtins.str):
        """
        The type for a storage destination.
        :param 'StorageDestinationConfigurationResponse' configuration: The storage destination configuration.
        :param builtins.str target: The set of supported stream destinations for an asset.
               Expected value is 'Storage'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Storage')

    @property
    @pulumi.getter
    def configuration(self) -> 'outputs.StorageDestinationConfigurationResponse':
        """
        The storage destination configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def target(self) -> builtins.str:
        """
        The set of supported stream destinations for an asset.
        Expected value is 'Storage'.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class SystemAssignedServiceIdentityResponse(dict):
    """
    Managed service identity (either system assigned, or none)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemAssignedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemAssignedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemAssignedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: builtins.str):
        """
        Managed service identity (either system assigned, or none)
        :param builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str type: Type of managed service identity (either system assigned, or none).
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of managed service identity (either system assigned, or none).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TopicResponse(dict):
    """
    Object that describes the topic information.
    """
    def __init__(__self__, *,
                 path: builtins.str,
                 retain: Optional[builtins.str] = None):
        """
        Object that describes the topic information.
        :param builtins.str path: The topic path for messages published to an MQTT broker.
        :param builtins.str retain: When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
        pulumi.set(__self__, "path", path)
        if retain is None:
            retain = 'Never'
        if retain is not None:
            pulumi.set(__self__, "retain", retain)

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The topic path for messages published to an MQTT broker.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def retain(self) -> Optional[builtins.str]:
        """
        When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
        return pulumi.get(self, "retain")


@pulumi.output_type
class TrustSettingsResponse(dict):
    """
    Defines server trust settings for an endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustList":
            suggest = "trust_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrustSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrustSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrustSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust_list: Optional[builtins.str] = None):
        """
        Defines server trust settings for an endpoint.
        :param builtins.str trust_list: Defines a secret reference for certificates to trust.
        """
        if trust_list is not None:
            pulumi.set(__self__, "trust_list", trust_list)

    @property
    @pulumi.getter(name="trustList")
    def trust_list(self) -> Optional[builtins.str]:
        """
        Defines a secret reference for certificates to trust.
        """
        return pulumi.get(self, "trust_list")


@pulumi.output_type
class UsernamePasswordCredentialsResponse(dict):
    """
    The credentials for authentication mode UsernamePassword.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretName":
            suggest = "password_secret_name"
        elif key == "usernameSecretName":
            suggest = "username_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsernamePasswordCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsernamePasswordCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsernamePasswordCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_secret_name: builtins.str,
                 username_secret_name: builtins.str):
        """
        The credentials for authentication mode UsernamePassword.
        :param builtins.str password_secret_name: The name of the secret containing the password.
        :param builtins.str username_secret_name: The name of the secret containing the username.
        """
        pulumi.set(__self__, "password_secret_name", password_secret_name)
        pulumi.set(__self__, "username_secret_name", username_secret_name)

    @property
    @pulumi.getter(name="passwordSecretName")
    def password_secret_name(self) -> builtins.str:
        """
        The name of the secret containing the password.
        """
        return pulumi.get(self, "password_secret_name")

    @property
    @pulumi.getter(name="usernameSecretName")
    def username_secret_name(self) -> builtins.str:
        """
        The name of the secret containing the username.
        """
        return pulumi.get(self, "username_secret_name")


@pulumi.output_type
class X509CredentialsResponse(dict):
    """
    The x509 certificate for authentication mode Certificate.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateSecretName":
            suggest = "certificate_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in X509CredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        X509CredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        X509CredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_secret_name: builtins.str):
        """
        The x509 certificate for authentication mode Certificate.
        :param builtins.str certificate_secret_name: The name of the secret containing the certificate and private key (e.g. stored as .der/.pem or .der/.pfx).
        """
        pulumi.set(__self__, "certificate_secret_name", certificate_secret_name)

    @property
    @pulumi.getter(name="certificateSecretName")
    def certificate_secret_name(self) -> builtins.str:
        """
        The name of the secret containing the certificate and private key (e.g. stored as .der/.pem or .der/.pfx).
        """
        return pulumi.get(self, "certificate_secret_name")


