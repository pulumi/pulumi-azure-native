# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AuthenticationArgs',
    'AuthenticationArgsDict',
    'BrokerStateStoreDestinationConfigurationArgs',
    'BrokerStateStoreDestinationConfigurationArgsDict',
    'DataPointArgs',
    'DataPointArgsDict',
    'DatasetBrokerStateStoreDestinationArgs',
    'DatasetBrokerStateStoreDestinationArgsDict',
    'DatasetMqttDestinationArgs',
    'DatasetMqttDestinationArgsDict',
    'DatasetStorageDestinationArgs',
    'DatasetStorageDestinationArgsDict',
    'DatasetArgs',
    'DatasetArgsDict',
    'DeviceMessagingEndpointArgs',
    'DeviceMessagingEndpointArgsDict',
    'DeviceRefArgs',
    'DeviceRefArgsDict',
    'DiscoveredDataPointArgs',
    'DiscoveredDataPointArgsDict',
    'DiscoveredDatasetArgs',
    'DiscoveredDatasetArgsDict',
    'DiscoveredEventArgs',
    'DiscoveredEventArgsDict',
    'DiscoveredInboundEndpointsArgs',
    'DiscoveredInboundEndpointsArgsDict',
    'DiscoveredMessagingEndpointsArgs',
    'DiscoveredMessagingEndpointsArgsDict',
    'DiscoveredOutboundEndpointsArgs',
    'DiscoveredOutboundEndpointsArgsDict',
    'EventMqttDestinationArgs',
    'EventMqttDestinationArgsDict',
    'EventStorageDestinationArgs',
    'EventStorageDestinationArgsDict',
    'EventArgs',
    'EventArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'HostAuthenticationArgs',
    'HostAuthenticationArgsDict',
    'InboundEndpointsArgs',
    'InboundEndpointsArgsDict',
    'ManagementActionArgs',
    'ManagementActionArgsDict',
    'ManagementGroupArgs',
    'ManagementGroupArgsDict',
    'MessagingEndpointsArgs',
    'MessagingEndpointsArgsDict',
    'MessagingEndpointArgs',
    'MessagingEndpointArgsDict',
    'MessagingArgs',
    'MessagingArgsDict',
    'MqttDestinationConfigurationArgs',
    'MqttDestinationConfigurationArgsDict',
    'NamespaceDatasetDataPointArgs',
    'NamespaceDatasetDataPointArgsDict',
    'NamespaceDatasetArgs',
    'NamespaceDatasetArgsDict',
    'NamespaceDiscoveredDatasetDataPointArgs',
    'NamespaceDiscoveredDatasetDataPointArgsDict',
    'NamespaceDiscoveredDatasetArgs',
    'NamespaceDiscoveredDatasetArgsDict',
    'NamespaceDiscoveredEventDataPointArgs',
    'NamespaceDiscoveredEventDataPointArgsDict',
    'NamespaceDiscoveredEventArgs',
    'NamespaceDiscoveredEventArgsDict',
    'NamespaceDiscoveredManagementActionArgs',
    'NamespaceDiscoveredManagementActionArgsDict',
    'NamespaceDiscoveredManagementGroupArgs',
    'NamespaceDiscoveredManagementGroupArgsDict',
    'NamespaceDiscoveredStreamArgs',
    'NamespaceDiscoveredStreamArgsDict',
    'NamespaceEventDataPointArgs',
    'NamespaceEventDataPointArgsDict',
    'NamespaceEventArgs',
    'NamespaceEventArgsDict',
    'NamespaceStreamArgs',
    'NamespaceStreamArgsDict',
    'OutboundEndpointsArgs',
    'OutboundEndpointsArgsDict',
    'StorageDestinationConfigurationArgs',
    'StorageDestinationConfigurationArgsDict',
    'StreamMqttDestinationArgs',
    'StreamMqttDestinationArgsDict',
    'StreamStorageDestinationArgs',
    'StreamStorageDestinationArgsDict',
    'SystemAssignedServiceIdentityArgs',
    'SystemAssignedServiceIdentityArgsDict',
    'TopicArgs',
    'TopicArgsDict',
    'TrustSettingsArgs',
    'TrustSettingsArgsDict',
    'UsernamePasswordCredentialsArgs',
    'UsernamePasswordCredentialsArgsDict',
    'X509CredentialsArgs',
    'X509CredentialsArgsDict',
]

MYPY = False

if not MYPY:
    class AuthenticationArgsDict(TypedDict):
        """
        Definition of the client authentication mechanism to the server.
        """
        method: pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]
        """
        Defines the method to authenticate the user of the client at the server.
        """
        username_password_credentials: NotRequired[pulumi.Input['UsernamePasswordCredentialsArgsDict']]
        """
        Defines the username and password references when UsernamePassword user authentication mode is selected.
        """
        x509_credentials: NotRequired[pulumi.Input['X509CredentialsArgsDict']]
        """
        Defines the certificate reference when Certificate user authentication mode is selected.
        """
elif False:
    AuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]] = None,
                 username_password_credentials: Optional[pulumi.Input['UsernamePasswordCredentialsArgs']] = None,
                 x509_credentials: Optional[pulumi.Input['X509CredentialsArgs']] = None):
        """
        Definition of the client authentication mechanism to the server.
        :param pulumi.Input[Union[builtins.str, 'AuthenticationMethod']] method: Defines the method to authenticate the user of the client at the server.
        :param pulumi.Input['UsernamePasswordCredentialsArgs'] username_password_credentials: Defines the username and password references when UsernamePassword user authentication mode is selected.
        :param pulumi.Input['X509CredentialsArgs'] x509_credentials: Defines the certificate reference when Certificate user authentication mode is selected.
        """
        if method is None:
            method = 'Certificate'
        pulumi.set(__self__, "method", method)
        if username_password_credentials is not None:
            pulumi.set(__self__, "username_password_credentials", username_password_credentials)
        if x509_credentials is not None:
            pulumi.set(__self__, "x509_credentials", x509_credentials)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]:
        """
        Defines the method to authenticate the user of the client at the server.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="usernamePasswordCredentials")
    def username_password_credentials(self) -> Optional[pulumi.Input['UsernamePasswordCredentialsArgs']]:
        """
        Defines the username and password references when UsernamePassword user authentication mode is selected.
        """
        return pulumi.get(self, "username_password_credentials")

    @username_password_credentials.setter
    def username_password_credentials(self, value: Optional[pulumi.Input['UsernamePasswordCredentialsArgs']]):
        pulumi.set(self, "username_password_credentials", value)

    @property
    @pulumi.getter(name="x509Credentials")
    def x509_credentials(self) -> Optional[pulumi.Input['X509CredentialsArgs']]:
        """
        Defines the certificate reference when Certificate user authentication mode is selected.
        """
        return pulumi.get(self, "x509_credentials")

    @x509_credentials.setter
    def x509_credentials(self, value: Optional[pulumi.Input['X509CredentialsArgs']]):
        pulumi.set(self, "x509_credentials", value)


if not MYPY:
    class BrokerStateStoreDestinationConfigurationArgsDict(TypedDict):
        """
        The configuration for a MQTT broker state store destination.
        """
        key: pulumi.Input[builtins.str]
        """
        The MQTT broker state store destination key.
        """
elif False:
    BrokerStateStoreDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrokerStateStoreDestinationConfigurationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str]):
        """
        The configuration for a MQTT broker state store destination.
        :param pulumi.Input[builtins.str] key: The MQTT broker state store destination key.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The MQTT broker state store destination key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class DataPointArgsDict(TypedDict):
        """
        Defines the data point properties.
        """
        data_source: pulumi.Input[builtins.str]
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the data point.
        """
        data_point_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        observability_mode: NotRequired[pulumi.Input[Union[builtins.str, 'DataPointObservabilityMode']]]
        """
        An indication of how the data point should be mapped to OpenTelemetry.
        """
elif False:
    DataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataPointArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 data_point_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 observability_mode: Optional[pulumi.Input[Union[builtins.str, 'DataPointObservabilityMode']]] = None):
        """
        Defines the data point properties.
        :param pulumi.Input[builtins.str] data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param pulumi.Input[builtins.str] name: The name of the data point.
        :param pulumi.Input[builtins.str] data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[Union[builtins.str, 'DataPointObservabilityMode']] observability_mode: An indication of how the data point should be mapped to OpenTelemetry.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if observability_mode is None:
            observability_mode = 'None'
        if observability_mode is not None:
            pulumi.set(__self__, "observability_mode", observability_mode)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[builtins.str]:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @data_point_configuration.setter
    def data_point_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_point_configuration", value)

    @property
    @pulumi.getter(name="observabilityMode")
    def observability_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'DataPointObservabilityMode']]]:
        """
        An indication of how the data point should be mapped to OpenTelemetry.
        """
        return pulumi.get(self, "observability_mode")

    @observability_mode.setter
    def observability_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'DataPointObservabilityMode']]]):
        pulumi.set(self, "observability_mode", value)


if not MYPY:
    class DatasetBrokerStateStoreDestinationArgsDict(TypedDict):
        """
        The type for a MQTT broker state store destination.
        """
        configuration: pulumi.Input['BrokerStateStoreDestinationConfigurationArgsDict']
        """
        The MQTT broker state store destination configuration.
        """
        target: pulumi.Input[builtins.str]
        """
        The set of supported dataset destinations for an asset.
        Expected value is 'BrokerStateStore'.
        """
elif False:
    DatasetBrokerStateStoreDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetBrokerStateStoreDestinationArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input['BrokerStateStoreDestinationConfigurationArgs'],
                 target: pulumi.Input[builtins.str]):
        """
        The type for a MQTT broker state store destination.
        :param pulumi.Input['BrokerStateStoreDestinationConfigurationArgs'] configuration: The MQTT broker state store destination configuration.
        :param pulumi.Input[builtins.str] target: The set of supported dataset destinations for an asset.
               Expected value is 'BrokerStateStore'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'BrokerStateStore')

    @property
    @pulumi.getter
    def configuration(self) -> pulumi.Input['BrokerStateStoreDestinationConfigurationArgs']:
        """
        The MQTT broker state store destination configuration.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input['BrokerStateStoreDestinationConfigurationArgs']):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[builtins.str]:
        """
        The set of supported dataset destinations for an asset.
        Expected value is 'BrokerStateStore'.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target", value)


if not MYPY:
    class DatasetMqttDestinationArgsDict(TypedDict):
        """
        The type for a MQTT destination.
        """
        configuration: pulumi.Input['MqttDestinationConfigurationArgsDict']
        """
        The MQTT destination configuration.
        """
        target: pulumi.Input[builtins.str]
        """
        The set of supported dataset destinations for an asset.
        Expected value is 'Mqtt'.
        """
elif False:
    DatasetMqttDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetMqttDestinationArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input['MqttDestinationConfigurationArgs'],
                 target: pulumi.Input[builtins.str]):
        """
        The type for a MQTT destination.
        :param pulumi.Input['MqttDestinationConfigurationArgs'] configuration: The MQTT destination configuration.
        :param pulumi.Input[builtins.str] target: The set of supported dataset destinations for an asset.
               Expected value is 'Mqtt'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Mqtt')

    @property
    @pulumi.getter
    def configuration(self) -> pulumi.Input['MqttDestinationConfigurationArgs']:
        """
        The MQTT destination configuration.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input['MqttDestinationConfigurationArgs']):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[builtins.str]:
        """
        The set of supported dataset destinations for an asset.
        Expected value is 'Mqtt'.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target", value)


if not MYPY:
    class DatasetStorageDestinationArgsDict(TypedDict):
        """
        The type for a storage destination.
        """
        configuration: pulumi.Input['StorageDestinationConfigurationArgsDict']
        """
        The storage destination configuration.
        """
        target: pulumi.Input[builtins.str]
        """
        The set of supported dataset destinations for an asset.
        Expected value is 'Storage'.
        """
elif False:
    DatasetStorageDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetStorageDestinationArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input['StorageDestinationConfigurationArgs'],
                 target: pulumi.Input[builtins.str]):
        """
        The type for a storage destination.
        :param pulumi.Input['StorageDestinationConfigurationArgs'] configuration: The storage destination configuration.
        :param pulumi.Input[builtins.str] target: The set of supported dataset destinations for an asset.
               Expected value is 'Storage'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Storage')

    @property
    @pulumi.getter
    def configuration(self) -> pulumi.Input['StorageDestinationConfigurationArgs']:
        """
        The storage destination configuration.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input['StorageDestinationConfigurationArgs']):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[builtins.str]:
        """
        The set of supported dataset destinations for an asset.
        Expected value is 'Storage'.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target", value)


if not MYPY:
    class DatasetArgsDict(TypedDict):
        """
        Defines the dataset properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the dataset.
        """
        data_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataPointArgsDict']]]]
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        dataset_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        """
        topic: NotRequired[pulumi.Input['TopicArgsDict']]
        """
        Object that describes the topic information for the specific dataset.
        """
elif False:
    DatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 data_points: Optional[pulumi.Input[Sequence[pulumi.Input['DataPointArgs']]]] = None,
                 dataset_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 topic: Optional[pulumi.Input['TopicArgs']] = None):
        """
        Defines the dataset properties.
        :param pulumi.Input[builtins.str] name: Name of the dataset.
        :param pulumi.Input[Sequence[pulumi.Input['DataPointArgs']]] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param pulumi.Input[builtins.str] dataset_configuration: Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        :param pulumi.Input['TopicArgs'] topic: Object that describes the topic information for the specific dataset.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataPointArgs']]]]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataPointArgs']]]]):
        pulumi.set(self, "data_points", value)

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @dataset_configuration.setter
    def dataset_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dataset_configuration", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['TopicArgs']]:
        """
        Object that describes the topic information for the specific dataset.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['TopicArgs']]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class DeviceMessagingEndpointArgsDict(TypedDict):
        """
        Device messaging endpoint model.
        """
        address: pulumi.Input[builtins.str]
        """
        The endpoint address to connect to.
        """
        endpoint_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of connection used for the messaging endpoint.
        """
elif False:
    DeviceMessagingEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceMessagingEndpointArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str],
                 endpoint_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        Device messaging endpoint model.
        :param pulumi.Input[builtins.str] address: The endpoint address to connect to.
        :param pulumi.Input[builtins.str] endpoint_type: Type of connection used for the messaging endpoint.
        """
        pulumi.set(__self__, "address", address)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        """
        The endpoint address to connect to.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of connection used for the messaging endpoint.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "endpoint_type", value)


if not MYPY:
    class DeviceRefArgsDict(TypedDict):
        """
        Defines which device and endpoint to use for this asset
        """
        device_name: pulumi.Input[builtins.str]
        """
        Name of the device resource
        """
        endpoint_name: pulumi.Input[builtins.str]
        """
        The name of endpoint to use
        """
elif False:
    DeviceRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceRefArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[builtins.str],
                 endpoint_name: pulumi.Input[builtins.str]):
        """
        Defines which device and endpoint to use for this asset
        :param pulumi.Input[builtins.str] device_name: Name of the device resource
        :param pulumi.Input[builtins.str] endpoint_name: The name of endpoint to use
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "endpoint_name", endpoint_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the device resource
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of endpoint to use
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "endpoint_name", value)


if not MYPY:
    class DiscoveredDataPointArgsDict(TypedDict):
        """
        Defines the data point properties.
        """
        data_source: pulumi.Input[builtins.str]
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the data point.
        """
        data_point_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        UTC timestamp indicating when the data point was added or modified.
        """
elif False:
    DiscoveredDataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveredDataPointArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 data_point_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the data point properties.
        :param pulumi.Input[builtins.str] data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param pulumi.Input[builtins.str] name: The name of the data point.
        :param pulumi.Input[builtins.str] data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[builtins.str] last_updated_on: UTC timestamp indicating when the data point was added or modified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[builtins.str]:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @data_point_configuration.setter
    def data_point_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_point_configuration", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        UTC timestamp indicating when the data point was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)


if not MYPY:
    class DiscoveredDatasetArgsDict(TypedDict):
        """
        Defines the dataset properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the dataset.
        """
        data_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgsDict']]]]
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        dataset_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        """
        topic: NotRequired[pulumi.Input['TopicArgsDict']]
        """
        Object that describes the topic information for the specific dataset.
        """
elif False:
    DiscoveredDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveredDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 data_points: Optional[pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgs']]]] = None,
                 dataset_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 topic: Optional[pulumi.Input['TopicArgs']] = None):
        """
        Defines the dataset properties.
        :param pulumi.Input[builtins.str] name: Name of the dataset.
        :param pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgs']]] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param pulumi.Input[builtins.str] dataset_configuration: Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        :param pulumi.Input['TopicArgs'] topic: Object that describes the topic information for the specific dataset.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgs']]]]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiscoveredDataPointArgs']]]]):
        pulumi.set(self, "data_points", value)

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @dataset_configuration.setter
    def dataset_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dataset_configuration", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['TopicArgs']]:
        """
        Object that describes the topic information for the specific dataset.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['TopicArgs']]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class DiscoveredEventArgsDict(TypedDict):
        """
        Defines the event properties.
        """
        event_notifier: pulumi.Input[builtins.str]
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the event.
        """
        event_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        UTC timestamp indicating when the event was added or modified.
        """
        topic: NotRequired[pulumi.Input['TopicArgsDict']]
        """
        Object that describes the topic information for the specific event.
        """
elif False:
    DiscoveredEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveredEventArgs:
    def __init__(__self__, *,
                 event_notifier: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 event_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None,
                 topic: Optional[pulumi.Input['TopicArgs']] = None):
        """
        Defines the event properties.
        :param pulumi.Input[builtins.str] event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param pulumi.Input[builtins.str] name: The name of the event.
        :param pulumi.Input[builtins.str] event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[builtins.str] last_updated_on: UTC timestamp indicating when the event was added or modified.
        :param pulumi.Input['TopicArgs'] topic: Object that describes the topic information for the specific event.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> pulumi.Input[builtins.str]:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @event_notifier.setter
    def event_notifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "event_notifier", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @event_configuration.setter
    def event_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "event_configuration", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        UTC timestamp indicating when the event was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['TopicArgs']]:
        """
        Object that describes the topic information for the specific event.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['TopicArgs']]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class DiscoveredInboundEndpointsArgsDict(TypedDict):
        """
        An endpoint to connect to the device.
        """
        address: pulumi.Input[builtins.str]
        """
        The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        """
        endpoint_type: pulumi.Input[builtins.str]
        """
        Type of connection endpoint.
        """
        additional_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        The timestamp (in UTC) when the endpoint was discovered.
        """
        supported_authentication_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]]]]
        """
        List of supported authentication methods supported by device for Inbound connections.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
elif False:
    DiscoveredInboundEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveredInboundEndpointsArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str],
                 endpoint_type: pulumi.Input[builtins.str],
                 additional_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None,
                 supported_authentication_methods: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]]]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        An endpoint to connect to the device.
        :param pulumi.Input[builtins.str] address: The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        :param pulumi.Input[builtins.str] endpoint_type: Type of connection endpoint.
        :param pulumi.Input[builtins.str] additional_configuration: Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        :param pulumi.Input[builtins.str] last_updated_on: The timestamp (in UTC) when the endpoint was discovered.
        :param pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]]] supported_authentication_methods: List of supported authentication methods supported by device for Inbound connections.
        :param pulumi.Input[builtins.str] version: Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        if additional_configuration is not None:
            pulumi.set(__self__, "additional_configuration", additional_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if supported_authentication_methods is not None:
            pulumi.set(__self__, "supported_authentication_methods", supported_authentication_methods)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        """
        The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of connection endpoint.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="additionalConfiguration")
    def additional_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        """
        return pulumi.get(self, "additional_configuration")

    @additional_configuration.setter
    def additional_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "additional_configuration", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The timestamp (in UTC) when the endpoint was discovered.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)

    @property
    @pulumi.getter(name="supportedAuthenticationMethods")
    def supported_authentication_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]]]]:
        """
        List of supported authentication methods supported by device for Inbound connections.
        """
        return pulumi.get(self, "supported_authentication_methods")

    @supported_authentication_methods.setter
    def supported_authentication_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]]]]):
        pulumi.set(self, "supported_authentication_methods", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DiscoveredMessagingEndpointsArgsDict(TypedDict):
        """
        Connection endpoint URL a device can use to connect to a service.
        """
        inbound: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DiscoveredInboundEndpointsArgsDict']]]]
        """
        Set of endpoints to connect to the device.
        """
        outbound: NotRequired[pulumi.Input['DiscoveredOutboundEndpointsArgsDict']]
        """
        Set of endpoints a device can connect to.
        """
elif False:
    DiscoveredMessagingEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveredMessagingEndpointsArgs:
    def __init__(__self__, *,
                 inbound: Optional[pulumi.Input[Mapping[str, pulumi.Input['DiscoveredInboundEndpointsArgs']]]] = None,
                 outbound: Optional[pulumi.Input['DiscoveredOutboundEndpointsArgs']] = None):
        """
        Connection endpoint URL a device can use to connect to a service.
        :param pulumi.Input[Mapping[str, pulumi.Input['DiscoveredInboundEndpointsArgs']]] inbound: Set of endpoints to connect to the device.
        :param pulumi.Input['DiscoveredOutboundEndpointsArgs'] outbound: Set of endpoints a device can connect to.
        """
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @property
    @pulumi.getter
    def inbound(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DiscoveredInboundEndpointsArgs']]]]:
        """
        Set of endpoints to connect to the device.
        """
        return pulumi.get(self, "inbound")

    @inbound.setter
    def inbound(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DiscoveredInboundEndpointsArgs']]]]):
        pulumi.set(self, "inbound", value)

    @property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input['DiscoveredOutboundEndpointsArgs']]:
        """
        Set of endpoints a device can connect to.
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input['DiscoveredOutboundEndpointsArgs']]):
        pulumi.set(self, "outbound", value)


if not MYPY:
    class DiscoveredOutboundEndpointsArgsDict(TypedDict):
        """
        Property bag contains the device's outbound endpoints
        """
        assigned: pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgsDict']]]
        """
        Endpoints the device can connect to.
        """
elif False:
    DiscoveredOutboundEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiscoveredOutboundEndpointsArgs:
    def __init__(__self__, *,
                 assigned: pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]]):
        """
        Property bag contains the device's outbound endpoints
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]] assigned: Endpoints the device can connect to.
        """
        pulumi.set(__self__, "assigned", assigned)

    @property
    @pulumi.getter
    def assigned(self) -> pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]]:
        """
        Endpoints the device can connect to.
        """
        return pulumi.get(self, "assigned")

    @assigned.setter
    def assigned(self, value: pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]]):
        pulumi.set(self, "assigned", value)


if not MYPY:
    class EventMqttDestinationArgsDict(TypedDict):
        """
        The type for a MQTT destination.
        """
        configuration: pulumi.Input['MqttDestinationConfigurationArgsDict']
        """
        The MQTT destination configuration.
        """
        target: pulumi.Input[builtins.str]
        """
        The set of supported event destinations for an asset.
        Expected value is 'Mqtt'.
        """
elif False:
    EventMqttDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventMqttDestinationArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input['MqttDestinationConfigurationArgs'],
                 target: pulumi.Input[builtins.str]):
        """
        The type for a MQTT destination.
        :param pulumi.Input['MqttDestinationConfigurationArgs'] configuration: The MQTT destination configuration.
        :param pulumi.Input[builtins.str] target: The set of supported event destinations for an asset.
               Expected value is 'Mqtt'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Mqtt')

    @property
    @pulumi.getter
    def configuration(self) -> pulumi.Input['MqttDestinationConfigurationArgs']:
        """
        The MQTT destination configuration.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input['MqttDestinationConfigurationArgs']):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[builtins.str]:
        """
        The set of supported event destinations for an asset.
        Expected value is 'Mqtt'.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target", value)


if not MYPY:
    class EventStorageDestinationArgsDict(TypedDict):
        """
        The type for a storage destination.
        """
        configuration: pulumi.Input['StorageDestinationConfigurationArgsDict']
        """
        The storage destination configuration.
        """
        target: pulumi.Input[builtins.str]
        """
        The set of supported event destinations for an asset.
        Expected value is 'Storage'.
        """
elif False:
    EventStorageDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventStorageDestinationArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input['StorageDestinationConfigurationArgs'],
                 target: pulumi.Input[builtins.str]):
        """
        The type for a storage destination.
        :param pulumi.Input['StorageDestinationConfigurationArgs'] configuration: The storage destination configuration.
        :param pulumi.Input[builtins.str] target: The set of supported event destinations for an asset.
               Expected value is 'Storage'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Storage')

    @property
    @pulumi.getter
    def configuration(self) -> pulumi.Input['StorageDestinationConfigurationArgs']:
        """
        The storage destination configuration.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input['StorageDestinationConfigurationArgs']):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[builtins.str]:
        """
        The set of supported event destinations for an asset.
        Expected value is 'Storage'.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target", value)


if not MYPY:
    class EventArgsDict(TypedDict):
        """
        Defines the event properties.
        """
        event_notifier: pulumi.Input[builtins.str]
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the event.
        """
        event_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        observability_mode: NotRequired[pulumi.Input[Union[builtins.str, 'EventObservabilityMode']]]
        """
        An indication of how the event should be mapped to OpenTelemetry.
        """
        topic: NotRequired[pulumi.Input['TopicArgsDict']]
        """
        Object that describes the topic information for the specific event.
        """
elif False:
    EventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventArgs:
    def __init__(__self__, *,
                 event_notifier: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 event_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 observability_mode: Optional[pulumi.Input[Union[builtins.str, 'EventObservabilityMode']]] = None,
                 topic: Optional[pulumi.Input['TopicArgs']] = None):
        """
        Defines the event properties.
        :param pulumi.Input[builtins.str] event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param pulumi.Input[builtins.str] name: The name of the event.
        :param pulumi.Input[builtins.str] event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[Union[builtins.str, 'EventObservabilityMode']] observability_mode: An indication of how the event should be mapped to OpenTelemetry.
        :param pulumi.Input['TopicArgs'] topic: Object that describes the topic information for the specific event.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if observability_mode is None:
            observability_mode = 'None'
        if observability_mode is not None:
            pulumi.set(__self__, "observability_mode", observability_mode)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> pulumi.Input[builtins.str]:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @event_notifier.setter
    def event_notifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "event_notifier", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @event_configuration.setter
    def event_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "event_configuration", value)

    @property
    @pulumi.getter(name="observabilityMode")
    def observability_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'EventObservabilityMode']]]:
        """
        An indication of how the event should be mapped to OpenTelemetry.
        """
        return pulumi.get(self, "observability_mode")

    @observability_mode.setter
    def observability_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'EventObservabilityMode']]]):
        pulumi.set(self, "observability_mode", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input['TopicArgs']]:
        """
        Object that describes the topic information for the specific event.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input['TopicArgs']]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        The extended location.
        """
        name: pulumi.Input[builtins.str]
        """
        The extended location name.
        """
        type: pulumi.Input[builtins.str]
        """
        The extended location type.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        The extended location.
        :param pulumi.Input[builtins.str] name: The extended location name.
        :param pulumi.Input[builtins.str] type: The extended location type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The extended location name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The extended location type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HostAuthenticationArgsDict(TypedDict):
        """
        Definition of the client authentication mechanism to the host.
        """
        method: pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]
        """
        Defines the method to authenticate the user of the client at the server.
        """
        username_password_credentials: NotRequired[pulumi.Input['UsernamePasswordCredentialsArgsDict']]
        """
        Defines the username and password references when UsernamePassword user authentication mode is selected.
        """
        x509_credentials: NotRequired[pulumi.Input['X509CredentialsArgsDict']]
        """
        Defines the certificate reference when Certificate user authentication mode is selected.
        """
elif False:
    HostAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostAuthenticationArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]] = None,
                 username_password_credentials: Optional[pulumi.Input['UsernamePasswordCredentialsArgs']] = None,
                 x509_credentials: Optional[pulumi.Input['X509CredentialsArgs']] = None):
        """
        Definition of the client authentication mechanism to the host.
        :param pulumi.Input[Union[builtins.str, 'AuthenticationMethod']] method: Defines the method to authenticate the user of the client at the server.
        :param pulumi.Input['UsernamePasswordCredentialsArgs'] username_password_credentials: Defines the username and password references when UsernamePassword user authentication mode is selected.
        :param pulumi.Input['X509CredentialsArgs'] x509_credentials: Defines the certificate reference when Certificate user authentication mode is selected.
        """
        if method is None:
            method = 'Certificate'
        pulumi.set(__self__, "method", method)
        if username_password_credentials is not None:
            pulumi.set(__self__, "username_password_credentials", username_password_credentials)
        if x509_credentials is not None:
            pulumi.set(__self__, "x509_credentials", x509_credentials)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]:
        """
        Defines the method to authenticate the user of the client at the server.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="usernamePasswordCredentials")
    def username_password_credentials(self) -> Optional[pulumi.Input['UsernamePasswordCredentialsArgs']]:
        """
        Defines the username and password references when UsernamePassword user authentication mode is selected.
        """
        return pulumi.get(self, "username_password_credentials")

    @username_password_credentials.setter
    def username_password_credentials(self, value: Optional[pulumi.Input['UsernamePasswordCredentialsArgs']]):
        pulumi.set(self, "username_password_credentials", value)

    @property
    @pulumi.getter(name="x509Credentials")
    def x509_credentials(self) -> Optional[pulumi.Input['X509CredentialsArgs']]:
        """
        Defines the certificate reference when Certificate user authentication mode is selected.
        """
        return pulumi.get(self, "x509_credentials")

    @x509_credentials.setter
    def x509_credentials(self, value: Optional[pulumi.Input['X509CredentialsArgs']]):
        pulumi.set(self, "x509_credentials", value)


if not MYPY:
    class InboundEndpointsArgsDict(TypedDict):
        """
        An endpoint to connect to the device.
        """
        address: pulumi.Input[builtins.str]
        """
        The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        """
        endpoint_type: pulumi.Input[builtins.str]
        """
        Type of connection endpoint.
        """
        additional_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        """
        authentication: NotRequired[pulumi.Input['HostAuthenticationArgsDict']]
        """
        Defines the client authentication mechanism to the server.
        """
        trust_settings: NotRequired[pulumi.Input['TrustSettingsArgsDict']]
        """
        Defines server trust settings for the endpoint.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
elif False:
    InboundEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InboundEndpointsArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str],
                 endpoint_type: pulumi.Input[builtins.str],
                 additional_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 authentication: Optional[pulumi.Input['HostAuthenticationArgs']] = None,
                 trust_settings: Optional[pulumi.Input['TrustSettingsArgs']] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        An endpoint to connect to the device.
        :param pulumi.Input[builtins.str] address: The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        :param pulumi.Input[builtins.str] endpoint_type: Type of connection endpoint.
        :param pulumi.Input[builtins.str] additional_configuration: Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        :param pulumi.Input['HostAuthenticationArgs'] authentication: Defines the client authentication mechanism to the server.
        :param pulumi.Input['TrustSettingsArgs'] trust_settings: Defines server trust settings for the endpoint.
        :param pulumi.Input[builtins.str] version: Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "endpoint_type", endpoint_type)
        if additional_configuration is not None:
            pulumi.set(__self__, "additional_configuration", additional_configuration)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if trust_settings is not None:
            pulumi.set(__self__, "trust_settings", trust_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        """
        The endpoint address & port. This can be either an IP address (e.g., 192.168.1.1) or a fully qualified domain name (FQDN, e.g., server.example.com).
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of connection endpoint.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="additionalConfiguration")
    def additional_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains configuration to be used by the connector (e.g., OPC UA, ONVIF).
        """
        return pulumi.get(self, "additional_configuration")

    @additional_configuration.setter
    def additional_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "additional_configuration", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['HostAuthenticationArgs']]:
        """
        Defines the client authentication mechanism to the server.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['HostAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="trustSettings")
    def trust_settings(self) -> Optional[pulumi.Input['TrustSettingsArgs']]:
        """
        Defines server trust settings for the endpoint.
        """
        return pulumi.get(self, "trust_settings")

    @trust_settings.setter
    def trust_settings(self, value: Optional[pulumi.Input['TrustSettingsArgs']]):
        pulumi.set(self, "trust_settings", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Protocol version associated with the endpoint e.g. 1 or 2 for endpointType Microsoft.HTTP, and 3.5 or 5.0 for endpointType Microsoft.Mqtt etc.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ManagementActionArgsDict(TypedDict):
        """
        Defines the action properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the action.
        """
        target_uri: pulumi.Input[builtins.str]
        """
        The target URI on which a client can invoke the specific action.
        """
        action_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the action.
        """
        action_type: NotRequired[pulumi.Input[Union[builtins.str, 'ManagementActionType']]]
        """
        The type of the action.
        """
        timeout_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Response timeout for the action.
        """
        topic: NotRequired[pulumi.Input[builtins.str]]
        """
        The MQTT topic path on which a client will receive the request for the action.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    ManagementActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 target_uri: pulumi.Input[builtins.str],
                 action_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 action_type: Optional[pulumi.Input[Union[builtins.str, 'ManagementActionType']]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 topic: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the action properties.
        :param pulumi.Input[builtins.str] name: Name of the action.
        :param pulumi.Input[builtins.str] target_uri: The target URI on which a client can invoke the specific action.
        :param pulumi.Input[builtins.str] action_configuration: Stringified JSON that contains connector-specific configuration for the action.
        :param pulumi.Input[Union[builtins.str, 'ManagementActionType']] action_type: The type of the action.
        :param pulumi.Input[builtins.int] timeout_in_seconds: Response timeout for the action.
        :param pulumi.Input[builtins.str] topic: The MQTT topic path on which a client will receive the request for the action.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_uri", target_uri)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)
        if action_type is None:
            action_type = 'Call'
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[builtins.str]:
        """
        The target URI on which a client can invoke the specific action.
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target_uri", value)

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the action.
        """
        return pulumi.get(self, "action_configuration")

    @action_configuration.setter
    def action_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action_configuration", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ManagementActionType']]]:
        """
        The type of the action.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ManagementActionType']]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Response timeout for the action.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_in_seconds", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The MQTT topic path on which a client will receive the request for the action.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class ManagementGroupArgsDict(TypedDict):
        """
        Defines the management group properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the management group.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ManagementActionArgsDict']]]]
        """
        Array of actions that are part of the management group. Each action can have an individual configuration.
        """
        default_timeout_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Default response timeout for all actions that are part of the management group.
        """
        default_topic: NotRequired[pulumi.Input[builtins.str]]
        """
        Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        """
        management_group_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the management group.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    ManagementGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['ManagementActionArgs']]]] = None,
                 default_timeout_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 default_topic: Optional[pulumi.Input[builtins.str]] = None,
                 management_group_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the management group properties.
        :param pulumi.Input[builtins.str] name: Name of the management group.
        :param pulumi.Input[Sequence[pulumi.Input['ManagementActionArgs']]] actions: Array of actions that are part of the management group. Each action can have an individual configuration.
        :param pulumi.Input[builtins.int] default_timeout_in_seconds: Default response timeout for all actions that are part of the management group.
        :param pulumi.Input[builtins.str] default_topic: Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        :param pulumi.Input[builtins.str] management_group_configuration: Stringified JSON that contains connector-specific configuration for the management group.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if default_timeout_in_seconds is None:
            default_timeout_in_seconds = 100
        if default_timeout_in_seconds is not None:
            pulumi.set(__self__, "default_timeout_in_seconds", default_timeout_in_seconds)
        if default_topic is not None:
            pulumi.set(__self__, "default_topic", default_topic)
        if management_group_configuration is not None:
            pulumi.set(__self__, "management_group_configuration", management_group_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the management group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManagementActionArgs']]]]:
        """
        Array of actions that are part of the management group. Each action can have an individual configuration.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManagementActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="defaultTimeoutInSeconds")
    def default_timeout_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Default response timeout for all actions that are part of the management group.
        """
        return pulumi.get(self, "default_timeout_in_seconds")

    @default_timeout_in_seconds.setter
    def default_timeout_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "default_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="defaultTopic")
    def default_topic(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        """
        return pulumi.get(self, "default_topic")

    @default_topic.setter
    def default_topic(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_topic", value)

    @property
    @pulumi.getter(name="managementGroupConfiguration")
    def management_group_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the management group.
        """
        return pulumi.get(self, "management_group_configuration")

    @management_group_configuration.setter
    def management_group_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "management_group_configuration", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class MessagingEndpointsArgsDict(TypedDict):
        """
        Connection endpoint URL a device can use to connect to a service.
        """
        inbound: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['InboundEndpointsArgsDict']]]]
        """
        Set of endpoints to connect to the device.
        """
        outbound: NotRequired[pulumi.Input['OutboundEndpointsArgsDict']]
        """
        Set of endpoints a device can connect to.
        """
elif False:
    MessagingEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MessagingEndpointsArgs:
    def __init__(__self__, *,
                 inbound: Optional[pulumi.Input[Mapping[str, pulumi.Input['InboundEndpointsArgs']]]] = None,
                 outbound: Optional[pulumi.Input['OutboundEndpointsArgs']] = None):
        """
        Connection endpoint URL a device can use to connect to a service.
        :param pulumi.Input[Mapping[str, pulumi.Input['InboundEndpointsArgs']]] inbound: Set of endpoints to connect to the device.
        :param pulumi.Input['OutboundEndpointsArgs'] outbound: Set of endpoints a device can connect to.
        """
        if inbound is not None:
            pulumi.set(__self__, "inbound", inbound)
        if outbound is not None:
            pulumi.set(__self__, "outbound", outbound)

    @property
    @pulumi.getter
    def inbound(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['InboundEndpointsArgs']]]]:
        """
        Set of endpoints to connect to the device.
        """
        return pulumi.get(self, "inbound")

    @inbound.setter
    def inbound(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['InboundEndpointsArgs']]]]):
        pulumi.set(self, "inbound", value)

    @property
    @pulumi.getter
    def outbound(self) -> Optional[pulumi.Input['OutboundEndpointsArgs']]:
        """
        Set of endpoints a device can connect to.
        """
        return pulumi.get(self, "outbound")

    @outbound.setter
    def outbound(self, value: Optional[pulumi.Input['OutboundEndpointsArgs']]):
        pulumi.set(self, "outbound", value)


if not MYPY:
    class MessagingEndpointArgsDict(TypedDict):
        """
        Namespace messaging endpoint model used by a device to connect to a service.
        """
        address: pulumi.Input[builtins.str]
        """
        The endpoint address to connect to.
        """
        endpoint_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of connection used for messaging endpoint.
        """
        resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The messaging endpoint Azure resource Id.
        """
elif False:
    MessagingEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MessagingEndpointArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str],
                 endpoint_type: Optional[pulumi.Input[builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Namespace messaging endpoint model used by a device to connect to a service.
        :param pulumi.Input[builtins.str] address: The endpoint address to connect to.
        :param pulumi.Input[builtins.str] endpoint_type: Type of connection used for messaging endpoint.
        :param pulumi.Input[builtins.str] resource_id: The messaging endpoint Azure resource Id.
        """
        pulumi.set(__self__, "address", address)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        """
        The endpoint address to connect to.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of connection used for messaging endpoint.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The messaging endpoint Azure resource Id.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class MessagingArgsDict(TypedDict):
        """
        The namespace messaging endpoints model.
        """
        endpoints: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['MessagingEndpointArgsDict']]]]
        """
        Dictionary of messaging endpoints.
        """
elif False:
    MessagingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MessagingArgs:
    def __init__(__self__, *,
                 endpoints: Optional[pulumi.Input[Mapping[str, pulumi.Input['MessagingEndpointArgs']]]] = None):
        """
        The namespace messaging endpoints model.
        :param pulumi.Input[Mapping[str, pulumi.Input['MessagingEndpointArgs']]] endpoints: Dictionary of messaging endpoints.
        """
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['MessagingEndpointArgs']]]]:
        """
        Dictionary of messaging endpoints.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['MessagingEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)


if not MYPY:
    class MqttDestinationConfigurationArgsDict(TypedDict):
        """
        The configuration for a MQTT destination.
        """
        topic: pulumi.Input[builtins.str]
        """
        The MQTT topic.
        """
        qos: NotRequired[pulumi.Input[Union[builtins.str, 'MqttDestinationQos']]]
        """
        The MQTT QoS setting. Defaults to QoS 1.
        """
        retain: NotRequired[pulumi.Input[Union[builtins.str, 'TopicRetainType']]]
        """
        When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
        ttl: NotRequired[pulumi.Input[builtins.float]]
        """
        The MQTT TTL setting.
        """
elif False:
    MqttDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MqttDestinationConfigurationArgs:
    def __init__(__self__, *,
                 topic: pulumi.Input[builtins.str],
                 qos: Optional[pulumi.Input[Union[builtins.str, 'MqttDestinationQos']]] = None,
                 retain: Optional[pulumi.Input[Union[builtins.str, 'TopicRetainType']]] = None,
                 ttl: Optional[pulumi.Input[builtins.float]] = None):
        """
        The configuration for a MQTT destination.
        :param pulumi.Input[builtins.str] topic: The MQTT topic.
        :param pulumi.Input[Union[builtins.str, 'MqttDestinationQos']] qos: The MQTT QoS setting. Defaults to QoS 1.
        :param pulumi.Input[Union[builtins.str, 'TopicRetainType']] retain: When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        :param pulumi.Input[builtins.float] ttl: The MQTT TTL setting.
        """
        pulumi.set(__self__, "topic", topic)
        if qos is None:
            qos = 'Qos1'
        if qos is not None:
            pulumi.set(__self__, "qos", qos)
        if retain is None:
            retain = 'Never'
        if retain is not None:
            pulumi.set(__self__, "retain", retain)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[builtins.str]:
        """
        The MQTT topic.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[Union[builtins.str, 'MqttDestinationQos']]]:
        """
        The MQTT QoS setting. Defaults to QoS 1.
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[Union[builtins.str, 'MqttDestinationQos']]]):
        pulumi.set(self, "qos", value)

    @property
    @pulumi.getter
    def retain(self) -> Optional[pulumi.Input[Union[builtins.str, 'TopicRetainType']]]:
        """
        When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
        return pulumi.get(self, "retain")

    @retain.setter
    def retain(self, value: Optional[pulumi.Input[Union[builtins.str, 'TopicRetainType']]]):
        pulumi.set(self, "retain", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The MQTT TTL setting.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class NamespaceDatasetDataPointArgsDict(TypedDict):
        """
        Defines the dataset data point properties.
        """
        data_source: pulumi.Input[builtins.str]
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the data point.
        """
        data_point_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceDatasetDataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceDatasetDataPointArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 data_point_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the dataset data point properties.
        :param pulumi.Input[builtins.str] data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param pulumi.Input[builtins.str] name: The name of the data point.
        :param pulumi.Input[builtins.str] data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[builtins.str]:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @data_point_configuration.setter
    def data_point_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_point_configuration", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class NamespaceDatasetArgsDict(TypedDict):
        """
        Defines the dataset properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the dataset.
        """
        data_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['NamespaceDatasetDataPointArgsDict']]]]
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        data_source: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a data source for a given dataset.
        """
        dataset_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgsDict', 'DatasetMqttDestinationArgsDict', 'DatasetStorageDestinationArgsDict']]]]]
        """
        Destinations for a dataset.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 data_points: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDatasetDataPointArgs']]]] = None,
                 data_source: Optional[pulumi.Input[builtins.str]] = None,
                 dataset_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgs', 'DatasetMqttDestinationArgs', 'DatasetStorageDestinationArgs']]]]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the dataset properties.
        :param pulumi.Input[builtins.str] name: Name of the dataset.
        :param pulumi.Input[Sequence[pulumi.Input['NamespaceDatasetDataPointArgs']]] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param pulumi.Input[builtins.str] data_source: Reference to a data source for a given dataset.
        :param pulumi.Input[builtins.str] dataset_configuration: Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgs', 'DatasetMqttDestinationArgs', 'DatasetStorageDestinationArgs']]]] destinations: Destinations for a dataset.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDatasetDataPointArgs']]]]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDatasetDataPointArgs']]]]):
        pulumi.set(self, "data_points", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a data source for a given dataset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific JSON string that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @dataset_configuration.setter
    def dataset_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dataset_configuration", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgs', 'DatasetMqttDestinationArgs', 'DatasetStorageDestinationArgs']]]]]:
        """
        Destinations for a dataset.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgs', 'DatasetMqttDestinationArgs', 'DatasetStorageDestinationArgs']]]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class NamespaceDiscoveredDatasetDataPointArgsDict(TypedDict):
        """
        Defines the discovered dataset data point properties.
        """
        data_source: pulumi.Input[builtins.str]
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the data point.
        """
        data_point_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        UTC timestamp indicating when the data point was added or modified.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceDiscoveredDatasetDataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceDiscoveredDatasetDataPointArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 data_point_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the discovered dataset data point properties.
        :param pulumi.Input[builtins.str] data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param pulumi.Input[builtins.str] name: The name of the data point.
        :param pulumi.Input[builtins.str] data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[builtins.str] last_updated_on: UTC timestamp indicating when the data point was added or modified.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[builtins.str]:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @data_point_configuration.setter
    def data_point_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_point_configuration", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        UTC timestamp indicating when the data point was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class NamespaceDiscoveredDatasetArgsDict(TypedDict):
        """
        Defines the dataset properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the dataset.
        """
        data_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredDatasetDataPointArgsDict']]]]
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        data_source: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a data source for a given dataset.
        """
        dataset_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgsDict', 'DatasetMqttDestinationArgsDict', 'DatasetStorageDestinationArgsDict']]]]]
        """
        Destinations for a dataset.
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        Timestamp (in UTC) indicating when the dataset was added or modified.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceDiscoveredDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceDiscoveredDatasetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 data_points: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredDatasetDataPointArgs']]]] = None,
                 data_source: Optional[pulumi.Input[builtins.str]] = None,
                 dataset_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgs', 'DatasetMqttDestinationArgs', 'DatasetStorageDestinationArgs']]]]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the dataset properties.
        :param pulumi.Input[builtins.str] name: Name of the dataset.
        :param pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredDatasetDataPointArgs']]] data_points: Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        :param pulumi.Input[builtins.str] data_source: Reference to a data source for a given dataset.
        :param pulumi.Input[builtins.str] dataset_configuration: Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgs', 'DatasetMqttDestinationArgs', 'DatasetStorageDestinationArgs']]]] destinations: Destinations for a dataset.
        :param pulumi.Input[builtins.str] last_updated_on: Timestamp (in UTC) indicating when the dataset was added or modified.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if dataset_configuration is not None:
            pulumi.set(__self__, "dataset_configuration", dataset_configuration)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the dataset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredDatasetDataPointArgs']]]]:
        """
        Array of data points that are part of the dataset. Each data point can have per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredDatasetDataPointArgs']]]]):
        pulumi.set(self, "data_points", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a data source for a given dataset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter(name="datasetConfiguration")
    def dataset_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific properties that describes configuration for the specific dataset.
        """
        return pulumi.get(self, "dataset_configuration")

    @dataset_configuration.setter
    def dataset_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dataset_configuration", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgs', 'DatasetMqttDestinationArgs', 'DatasetStorageDestinationArgs']]]]]:
        """
        Destinations for a dataset.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DatasetBrokerStateStoreDestinationArgs', 'DatasetMqttDestinationArgs', 'DatasetStorageDestinationArgs']]]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Timestamp (in UTC) indicating when the dataset was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class NamespaceDiscoveredEventDataPointArgsDict(TypedDict):
        """
        Defines the discovered event data point properties.
        """
        data_source: pulumi.Input[builtins.str]
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the data point.
        """
        data_point_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        UTC timestamp indicating when the data point was added or modified.
        """
elif False:
    NamespaceDiscoveredEventDataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceDiscoveredEventDataPointArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 data_point_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the discovered event data point properties.
        :param pulumi.Input[builtins.str] data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param pulumi.Input[builtins.str] name: The name of the data point.
        :param pulumi.Input[builtins.str] data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[builtins.str] last_updated_on: UTC timestamp indicating when the data point was added or modified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[builtins.str]:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @data_point_configuration.setter
    def data_point_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_point_configuration", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        UTC timestamp indicating when the data point was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)


if not MYPY:
    class NamespaceDiscoveredEventArgsDict(TypedDict):
        """
        Defines the event properties.
        """
        event_notifier: pulumi.Input[builtins.str]
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the event.
        """
        data_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredEventDataPointArgsDict']]]]
        """
        Array of data points that are part of the event. Each data point can have a per-data point configuration.
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgsDict', 'EventStorageDestinationArgsDict']]]]]
        """
        Destinations for an event.
        """
        event_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        UTC timestamp indicating when the event was added or modified.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceDiscoveredEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceDiscoveredEventArgs:
    def __init__(__self__, *,
                 event_notifier: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 data_points: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredEventDataPointArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgs', 'EventStorageDestinationArgs']]]]] = None,
                 event_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the event properties.
        :param pulumi.Input[builtins.str] event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param pulumi.Input[builtins.str] name: The name of the event.
        :param pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredEventDataPointArgs']]] data_points: Array of data points that are part of the event. Each data point can have a per-data point configuration.
        :param pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgs', 'EventStorageDestinationArgs']]]] destinations: Destinations for an event.
        :param pulumi.Input[builtins.str] event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[builtins.str] last_updated_on: UTC timestamp indicating when the event was added or modified.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> pulumi.Input[builtins.str]:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @event_notifier.setter
    def event_notifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "event_notifier", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredEventDataPointArgs']]]]:
        """
        Array of data points that are part of the event. Each data point can have a per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredEventDataPointArgs']]]]):
        pulumi.set(self, "data_points", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgs', 'EventStorageDestinationArgs']]]]]:
        """
        Destinations for an event.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgs', 'EventStorageDestinationArgs']]]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @event_configuration.setter
    def event_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "event_configuration", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        UTC timestamp indicating when the event was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class NamespaceDiscoveredManagementActionArgsDict(TypedDict):
        """
        Defines the action properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the action.
        """
        target_uri: pulumi.Input[builtins.str]
        """
        The target URI on which a client can invoke the specific action.
        """
        action_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the action.
        """
        action_type: NotRequired[pulumi.Input[Union[builtins.str, 'NamespaceDiscoveredManagementActionType']]]
        """
        The type of the action.
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        Timestamp (in UTC) indicating when the management action was added or modified.
        """
        timeout_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Response timeout for the action.
        """
        topic: NotRequired[pulumi.Input[builtins.str]]
        """
        The MQTT topic path on which a client will receive the request for the action.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceDiscoveredManagementActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceDiscoveredManagementActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 target_uri: pulumi.Input[builtins.str],
                 action_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 action_type: Optional[pulumi.Input[Union[builtins.str, 'NamespaceDiscoveredManagementActionType']]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 topic: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the action properties.
        :param pulumi.Input[builtins.str] name: Name of the action.
        :param pulumi.Input[builtins.str] target_uri: The target URI on which a client can invoke the specific action.
        :param pulumi.Input[builtins.str] action_configuration: Stringified JSON that contains connector-specific configuration for the action.
        :param pulumi.Input[Union[builtins.str, 'NamespaceDiscoveredManagementActionType']] action_type: The type of the action.
        :param pulumi.Input[builtins.str] last_updated_on: Timestamp (in UTC) indicating when the management action was added or modified.
        :param pulumi.Input[builtins.int] timeout_in_seconds: Response timeout for the action.
        :param pulumi.Input[builtins.str] topic: The MQTT topic path on which a client will receive the request for the action.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_uri", target_uri)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)
        if action_type is None:
            action_type = 'Call'
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[builtins.str]:
        """
        The target URI on which a client can invoke the specific action.
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target_uri", value)

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the action.
        """
        return pulumi.get(self, "action_configuration")

    @action_configuration.setter
    def action_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action_configuration", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'NamespaceDiscoveredManagementActionType']]]:
        """
        The type of the action.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'NamespaceDiscoveredManagementActionType']]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Timestamp (in UTC) indicating when the management action was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Response timeout for the action.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_in_seconds", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The MQTT topic path on which a client will receive the request for the action.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class NamespaceDiscoveredManagementGroupArgsDict(TypedDict):
        """
        Defines the management group properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the management group.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredManagementActionArgsDict']]]]
        """
        Array of actions that are part of the management group. Each action can have an individual configuration.
        """
        default_timeout_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Default response timeout for all actions that are part of the management group.
        """
        default_topic: NotRequired[pulumi.Input[builtins.str]]
        """
        Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        Timestamp (in UTC) indicating when the management group was added or modified.
        """
        management_group_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the management group.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceDiscoveredManagementGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceDiscoveredManagementGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredManagementActionArgs']]]] = None,
                 default_timeout_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 default_topic: Optional[pulumi.Input[builtins.str]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None,
                 management_group_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the management group properties.
        :param pulumi.Input[builtins.str] name: Name of the management group.
        :param pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredManagementActionArgs']]] actions: Array of actions that are part of the management group. Each action can have an individual configuration.
        :param pulumi.Input[builtins.int] default_timeout_in_seconds: Default response timeout for all actions that are part of the management group.
        :param pulumi.Input[builtins.str] default_topic: Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        :param pulumi.Input[builtins.str] last_updated_on: Timestamp (in UTC) indicating when the management group was added or modified.
        :param pulumi.Input[builtins.str] management_group_configuration: Stringified JSON that contains connector-specific configuration for the management group.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if default_timeout_in_seconds is None:
            default_timeout_in_seconds = 100
        if default_timeout_in_seconds is not None:
            pulumi.set(__self__, "default_timeout_in_seconds", default_timeout_in_seconds)
        if default_topic is not None:
            pulumi.set(__self__, "default_topic", default_topic)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if management_group_configuration is not None:
            pulumi.set(__self__, "management_group_configuration", management_group_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the management group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredManagementActionArgs']]]]:
        """
        Array of actions that are part of the management group. Each action can have an individual configuration.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceDiscoveredManagementActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="defaultTimeoutInSeconds")
    def default_timeout_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Default response timeout for all actions that are part of the management group.
        """
        return pulumi.get(self, "default_timeout_in_seconds")

    @default_timeout_in_seconds.setter
    def default_timeout_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "default_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="defaultTopic")
    def default_topic(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default MQTT topic path on which a client will receive the request for all actions that are part of the management group.
        """
        return pulumi.get(self, "default_topic")

    @default_topic.setter
    def default_topic(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_topic", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Timestamp (in UTC) indicating when the management group was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)

    @property
    @pulumi.getter(name="managementGroupConfiguration")
    def management_group_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the management group.
        """
        return pulumi.get(self, "management_group_configuration")

    @management_group_configuration.setter
    def management_group_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "management_group_configuration", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class NamespaceDiscoveredStreamArgsDict(TypedDict):
        """
        Defines the stream properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the stream definition.
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgsDict', 'StreamStorageDestinationArgsDict']]]]]
        """
        Destinations for a stream.
        """
        last_updated_on: NotRequired[pulumi.Input[builtins.str]]
        """
        Timestamp (in UTC) indicating when the stream was added or modified.
        """
        stream_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the specific stream.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceDiscoveredStreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceDiscoveredStreamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgs', 'StreamStorageDestinationArgs']]]]] = None,
                 last_updated_on: Optional[pulumi.Input[builtins.str]] = None,
                 stream_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the stream properties.
        :param pulumi.Input[builtins.str] name: Name of the stream definition.
        :param pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgs', 'StreamStorageDestinationArgs']]]] destinations: Destinations for a stream.
        :param pulumi.Input[builtins.str] last_updated_on: Timestamp (in UTC) indicating when the stream was added or modified.
        :param pulumi.Input[builtins.str] stream_configuration: Stringified JSON that contains connector-specific configuration for the specific stream.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if last_updated_on is not None:
            pulumi.set(__self__, "last_updated_on", last_updated_on)
        if stream_configuration is not None:
            pulumi.set(__self__, "stream_configuration", stream_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the stream definition.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgs', 'StreamStorageDestinationArgs']]]]]:
        """
        Destinations for a stream.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgs', 'StreamStorageDestinationArgs']]]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="lastUpdatedOn")
    def last_updated_on(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Timestamp (in UTC) indicating when the stream was added or modified.
        """
        return pulumi.get(self, "last_updated_on")

    @last_updated_on.setter
    def last_updated_on(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_updated_on", value)

    @property
    @pulumi.getter(name="streamConfiguration")
    def stream_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the specific stream.
        """
        return pulumi.get(self, "stream_configuration")

    @stream_configuration.setter
    def stream_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "stream_configuration", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class NamespaceEventDataPointArgsDict(TypedDict):
        """
        Defines the event data point properties.
        """
        data_source: pulumi.Input[builtins.str]
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the data point.
        """
        data_point_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
elif False:
    NamespaceEventDataPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceEventDataPointArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 data_point_configuration: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the event data point properties.
        :param pulumi.Input[builtins.str] data_source: The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        :param pulumi.Input[builtins.str] name: The name of the data point.
        :param pulumi.Input[builtins.str] data_point_configuration: Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if data_point_configuration is not None:
            pulumi.set(__self__, "data_point_configuration", data_point_configuration)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[builtins.str]:
        """
        The address of the source of the data in the asset (e.g. URL) so that a client can access the data source on the asset.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the data point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPointConfiguration")
    def data_point_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the data point. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "data_point_configuration")

    @data_point_configuration.setter
    def data_point_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_point_configuration", value)


if not MYPY:
    class NamespaceEventArgsDict(TypedDict):
        """
        Defines the event properties.
        """
        event_notifier: pulumi.Input[builtins.str]
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the event.
        """
        data_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['NamespaceEventDataPointArgsDict']]]]
        """
        Array of data points that are part of the event. Each data point can have a per-data point configuration.
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgsDict', 'EventStorageDestinationArgsDict']]]]]
        """
        Destinations for an event.
        """
        event_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceEventArgs:
    def __init__(__self__, *,
                 event_notifier: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 data_points: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceEventDataPointArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgs', 'EventStorageDestinationArgs']]]]] = None,
                 event_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the event properties.
        :param pulumi.Input[builtins.str] event_notifier: The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        :param pulumi.Input[builtins.str] name: The name of the event.
        :param pulumi.Input[Sequence[pulumi.Input['NamespaceEventDataPointArgs']]] data_points: Array of data points that are part of the event. Each data point can have a per-data point configuration.
        :param pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgs', 'EventStorageDestinationArgs']]]] destinations: Destinations for an event.
        :param pulumi.Input[builtins.str] event_configuration: Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "event_notifier", event_notifier)
        pulumi.set(__self__, "name", name)
        if data_points is not None:
            pulumi.set(__self__, "data_points", data_points)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if event_configuration is not None:
            pulumi.set(__self__, "event_configuration", event_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter(name="eventNotifier")
    def event_notifier(self) -> pulumi.Input[builtins.str]:
        """
        The address of the notifier of the event in the asset (e.g. URL) so that a client can access the event on the asset.
        """
        return pulumi.get(self, "event_notifier")

    @event_notifier.setter
    def event_notifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "event_notifier", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the event.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataPoints")
    def data_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceEventDataPointArgs']]]]:
        """
        Array of data points that are part of the event. Each data point can have a per-data point configuration.
        """
        return pulumi.get(self, "data_points")

    @data_points.setter
    def data_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespaceEventDataPointArgs']]]]):
        pulumi.set(self, "data_points", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgs', 'EventStorageDestinationArgs']]]]]:
        """
        Destinations for an event.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['EventMqttDestinationArgs', 'EventStorageDestinationArgs']]]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="eventConfiguration")
    def event_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the event. For OPC UA, this could include configuration like, publishingInterval, samplingInterval, and queueSize.
        """
        return pulumi.get(self, "event_configuration")

    @event_configuration.setter
    def event_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "event_configuration", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class NamespaceStreamArgsDict(TypedDict):
        """
        Defines the stream properties.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the stream definition.
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgsDict', 'StreamStorageDestinationArgsDict']]]]]
        """
        Destinations for a stream.
        """
        stream_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        Stringified JSON that contains connector-specific configuration for the specific stream.
        """
        type_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        URI or type definition ID.
        """
elif False:
    NamespaceStreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceStreamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgs', 'StreamStorageDestinationArgs']]]]] = None,
                 stream_configuration: Optional[pulumi.Input[builtins.str]] = None,
                 type_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines the stream properties.
        :param pulumi.Input[builtins.str] name: Name of the stream definition.
        :param pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgs', 'StreamStorageDestinationArgs']]]] destinations: Destinations for a stream.
        :param pulumi.Input[builtins.str] stream_configuration: Stringified JSON that contains connector-specific configuration for the specific stream.
        :param pulumi.Input[builtins.str] type_ref: URI or type definition ID.
        """
        pulumi.set(__self__, "name", name)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if stream_configuration is not None:
            pulumi.set(__self__, "stream_configuration", stream_configuration)
        if type_ref is not None:
            pulumi.set(__self__, "type_ref", type_ref)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the stream definition.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgs', 'StreamStorageDestinationArgs']]]]]:
        """
        Destinations for a stream.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['StreamMqttDestinationArgs', 'StreamStorageDestinationArgs']]]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="streamConfiguration")
    def stream_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Stringified JSON that contains connector-specific configuration for the specific stream.
        """
        return pulumi.get(self, "stream_configuration")

    @stream_configuration.setter
    def stream_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "stream_configuration", value)

    @property
    @pulumi.getter(name="typeRef")
    def type_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI or type definition ID.
        """
        return pulumi.get(self, "type_ref")

    @type_ref.setter
    def type_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_ref", value)


if not MYPY:
    class OutboundEndpointsArgsDict(TypedDict):
        """
        Property bag contains the device's outbound endpoints
        """
        assigned: pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgsDict']]]
        """
        Endpoints the device can connect to.
        """
        unassigned: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgsDict']]]]
        """
        Set of most recently removed endpoints.
        """
elif False:
    OutboundEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OutboundEndpointsArgs:
    def __init__(__self__, *,
                 assigned: pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]],
                 unassigned: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]]] = None):
        """
        Property bag contains the device's outbound endpoints
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]] assigned: Endpoints the device can connect to.
        :param pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]] unassigned: Set of most recently removed endpoints.
        """
        pulumi.set(__self__, "assigned", assigned)
        if unassigned is not None:
            pulumi.set(__self__, "unassigned", unassigned)

    @property
    @pulumi.getter
    def assigned(self) -> pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]]:
        """
        Endpoints the device can connect to.
        """
        return pulumi.get(self, "assigned")

    @assigned.setter
    def assigned(self, value: pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]]):
        pulumi.set(self, "assigned", value)

    @property
    @pulumi.getter
    def unassigned(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]]]:
        """
        Set of most recently removed endpoints.
        """
        return pulumi.get(self, "unassigned")

    @unassigned.setter
    def unassigned(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeviceMessagingEndpointArgs']]]]):
        pulumi.set(self, "unassigned", value)


if not MYPY:
    class StorageDestinationConfigurationArgsDict(TypedDict):
        """
        The configuration for a storage destination.
        """
        path: pulumi.Input[builtins.str]
        """
        The storage destination path.
        """
elif False:
    StorageDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageDestinationConfigurationArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[builtins.str]):
        """
        The configuration for a storage destination.
        :param pulumi.Input[builtins.str] path: The storage destination path.
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        The storage destination path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class StreamMqttDestinationArgsDict(TypedDict):
        """
        The type for a MQTT destination.
        """
        configuration: pulumi.Input['MqttDestinationConfigurationArgsDict']
        """
        The MQTT destination configuration.
        """
        target: pulumi.Input[builtins.str]
        """
        The set of supported stream destinations for an asset.
        Expected value is 'Mqtt'.
        """
elif False:
    StreamMqttDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamMqttDestinationArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input['MqttDestinationConfigurationArgs'],
                 target: pulumi.Input[builtins.str]):
        """
        The type for a MQTT destination.
        :param pulumi.Input['MqttDestinationConfigurationArgs'] configuration: The MQTT destination configuration.
        :param pulumi.Input[builtins.str] target: The set of supported stream destinations for an asset.
               Expected value is 'Mqtt'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Mqtt')

    @property
    @pulumi.getter
    def configuration(self) -> pulumi.Input['MqttDestinationConfigurationArgs']:
        """
        The MQTT destination configuration.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input['MqttDestinationConfigurationArgs']):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[builtins.str]:
        """
        The set of supported stream destinations for an asset.
        Expected value is 'Mqtt'.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target", value)


if not MYPY:
    class StreamStorageDestinationArgsDict(TypedDict):
        """
        The type for a storage destination.
        """
        configuration: pulumi.Input['StorageDestinationConfigurationArgsDict']
        """
        The storage destination configuration.
        """
        target: pulumi.Input[builtins.str]
        """
        The set of supported stream destinations for an asset.
        Expected value is 'Storage'.
        """
elif False:
    StreamStorageDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamStorageDestinationArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input['StorageDestinationConfigurationArgs'],
                 target: pulumi.Input[builtins.str]):
        """
        The type for a storage destination.
        :param pulumi.Input['StorageDestinationConfigurationArgs'] configuration: The storage destination configuration.
        :param pulumi.Input[builtins.str] target: The set of supported stream destinations for an asset.
               Expected value is 'Storage'.
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "target", 'Storage')

    @property
    @pulumi.getter
    def configuration(self) -> pulumi.Input['StorageDestinationConfigurationArgs']:
        """
        The storage destination configuration.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input['StorageDestinationConfigurationArgs']):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[builtins.str]:
        """
        The set of supported stream destinations for an asset.
        Expected value is 'Storage'.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target", value)


if not MYPY:
    class SystemAssignedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (either system assigned, or none)
        """
        type: pulumi.Input[Union[builtins.str, 'SystemAssignedServiceIdentityType']]
        """
        Type of managed service identity (either system assigned, or none).
        """
elif False:
    SystemAssignedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SystemAssignedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[builtins.str, 'SystemAssignedServiceIdentityType']]):
        """
        Managed service identity (either system assigned, or none)
        :param pulumi.Input[Union[builtins.str, 'SystemAssignedServiceIdentityType']] type: Type of managed service identity (either system assigned, or none).
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'SystemAssignedServiceIdentityType']]:
        """
        Type of managed service identity (either system assigned, or none).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'SystemAssignedServiceIdentityType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TopicArgsDict(TypedDict):
        """
        Object that describes the topic information.
        """
        path: pulumi.Input[builtins.str]
        """
        The topic path for messages published to an MQTT broker.
        """
        retain: NotRequired[pulumi.Input[Union[builtins.str, 'TopicRetainType']]]
        """
        When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
elif False:
    TopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[builtins.str],
                 retain: Optional[pulumi.Input[Union[builtins.str, 'TopicRetainType']]] = None):
        """
        Object that describes the topic information.
        :param pulumi.Input[builtins.str] path: The topic path for messages published to an MQTT broker.
        :param pulumi.Input[Union[builtins.str, 'TopicRetainType']] retain: When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
        pulumi.set(__self__, "path", path)
        if retain is None:
            retain = 'Never'
        if retain is not None:
            pulumi.set(__self__, "retain", retain)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        The topic path for messages published to an MQTT broker.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def retain(self) -> Optional[pulumi.Input[Union[builtins.str, 'TopicRetainType']]]:
        """
        When set to 'Keep', messages published to an MQTT broker will have the retain flag set. Default: 'Never'.
        """
        return pulumi.get(self, "retain")

    @retain.setter
    def retain(self, value: Optional[pulumi.Input[Union[builtins.str, 'TopicRetainType']]]):
        pulumi.set(self, "retain", value)


if not MYPY:
    class TrustSettingsArgsDict(TypedDict):
        """
        Defines server trust settings for an endpoint.
        """
        trust_list: NotRequired[pulumi.Input[builtins.str]]
        """
        Defines a secret reference for certificates to trust.
        """
elif False:
    TrustSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrustSettingsArgs:
    def __init__(__self__, *,
                 trust_list: Optional[pulumi.Input[builtins.str]] = None):
        """
        Defines server trust settings for an endpoint.
        :param pulumi.Input[builtins.str] trust_list: Defines a secret reference for certificates to trust.
        """
        if trust_list is not None:
            pulumi.set(__self__, "trust_list", trust_list)

    @property
    @pulumi.getter(name="trustList")
    def trust_list(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Defines a secret reference for certificates to trust.
        """
        return pulumi.get(self, "trust_list")

    @trust_list.setter
    def trust_list(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "trust_list", value)


if not MYPY:
    class UsernamePasswordCredentialsArgsDict(TypedDict):
        """
        The credentials for authentication mode UsernamePassword.
        """
        password_secret_name: pulumi.Input[builtins.str]
        """
        The name of the secret containing the password.
        """
        username_secret_name: pulumi.Input[builtins.str]
        """
        The name of the secret containing the username.
        """
elif False:
    UsernamePasswordCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsernamePasswordCredentialsArgs:
    def __init__(__self__, *,
                 password_secret_name: pulumi.Input[builtins.str],
                 username_secret_name: pulumi.Input[builtins.str]):
        """
        The credentials for authentication mode UsernamePassword.
        :param pulumi.Input[builtins.str] password_secret_name: The name of the secret containing the password.
        :param pulumi.Input[builtins.str] username_secret_name: The name of the secret containing the username.
        """
        pulumi.set(__self__, "password_secret_name", password_secret_name)
        pulumi.set(__self__, "username_secret_name", username_secret_name)

    @property
    @pulumi.getter(name="passwordSecretName")
    def password_secret_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the secret containing the password.
        """
        return pulumi.get(self, "password_secret_name")

    @password_secret_name.setter
    def password_secret_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_secret_name", value)

    @property
    @pulumi.getter(name="usernameSecretName")
    def username_secret_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the secret containing the username.
        """
        return pulumi.get(self, "username_secret_name")

    @username_secret_name.setter
    def username_secret_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username_secret_name", value)


if not MYPY:
    class X509CredentialsArgsDict(TypedDict):
        """
        The x509 certificate for authentication mode Certificate.
        """
        certificate_secret_name: pulumi.Input[builtins.str]
        """
        The name of the secret containing the certificate and private key (e.g. stored as .der/.pem or .der/.pfx).
        """
elif False:
    X509CredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class X509CredentialsArgs:
    def __init__(__self__, *,
                 certificate_secret_name: pulumi.Input[builtins.str]):
        """
        The x509 certificate for authentication mode Certificate.
        :param pulumi.Input[builtins.str] certificate_secret_name: The name of the secret containing the certificate and private key (e.g. stored as .der/.pem or .der/.pfx).
        """
        pulumi.set(__self__, "certificate_secret_name", certificate_secret_name)

    @property
    @pulumi.getter(name="certificateSecretName")
    def certificate_secret_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the secret containing the certificate and private key (e.g. stored as .der/.pem or .der/.pfx).
        """
        return pulumi.get(self, "certificate_secret_name")

    @certificate_secret_name.setter
    def certificate_secret_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "certificate_secret_name", value)


