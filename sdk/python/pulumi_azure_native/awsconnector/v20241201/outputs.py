# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AbortIncompleteMultipartUploadResponse',
    'AccelerateConfigurationResponse',
    'AcceleratorCountRequestResponse',
    'AcceleratorTotalMemoryMiBRequestResponse',
    'AccessAnalyzerAnalyzerPropertiesResponse',
    'AccessConfigResponseResponse',
    'AccessControlTranslationResponse',
    'AccessLogSettingResponse',
    'AccessRulesResponse',
    'AccountAttributeValueResponse',
    'AcmCertificateSummaryPropertiesResponse',
    'ActionConditionModelPropertiesResponse',
    'ActionDefinitionResponse',
    'ActionResponse',
    'ActiveModelResponse',
    'AddOnResponse',
    'AdditionalAuthenticationProviderResponse',
    'AddressResponse',
    'AdvancedEventSelectorResponse',
    'AdvancedFieldSelectorResponse',
    'AdvancedSecurityOptionsResponse',
    'AliasTargetResponse',
    'AmdSevSnpSpecificationEnumValueResponse',
    'AnalyticsConfigurationResponse',
    'AnomalyDetectionResponse',
    'AnomalyResultEnumEnumValueResponse',
    'ApiGatewayRestApiPropertiesResponse',
    'ApiGatewayStagePropertiesResponse',
    'AppSyncGraphqlApiPropertiesResponse',
    'ApplicationResourceLifecycleConfigResponse',
    'ApplicationResponse',
    'ApplicationVersionLifecycleConfigResponse',
    'ArchitectureValuesEnumValueResponse',
    'ArchiveRuleResponse',
    'ArtifactNamespaceEnumValueResponse',
    'ArtifactPackagingEnumValueResponse',
    'ArtifactsTypeEnumValueResponse',
    'AttachmentStatusEnumValueResponse',
    'AttributeDefinitionResponse',
    'AuthTypeEnumValueResponse',
    'AuthenticateCognitoConfigResponse',
    'AuthenticateOidcConfigResponse',
    'AuthenticationModeEnumValueResponse',
    'AuthenticationTypeEnumValueResponse',
    'AuthorizationConfigResponse',
    'AutoDeploymentResponse',
    'AutoScalingAutoScalingGroupPropertiesResponse',
    'AutoSnapshotAddOnResponse',
    'AutoTuneOptionsOutputResponse',
    'AutoTuneStateEnumValueResponse',
    'AvailabilityZoneResponse',
    'AwsAccessAnalyzerAnalyzerPropertiesResponse',
    'AwsAcmCertificateSummaryPropertiesResponse',
    'AwsApiGatewayRestApiPropertiesResponse',
    'AwsApiGatewayStagePropertiesResponse',
    'AwsAppSyncGraphqlApiPropertiesResponse',
    'AwsAutoScalingAutoScalingGroupPropertiesResponse',
    'AwsCloudFormationStackPropertiesResponse',
    'AwsCloudFormationStackSetPropertiesResponse',
    'AwsCloudFrontDistributionPropertiesResponse',
    'AwsCloudTrailTrailPropertiesResponse',
    'AwsCloudWatchAlarmPropertiesResponse',
    'AwsCodeBuildProjectPropertiesResponse',
    'AwsCodeBuildSourceCredentialsInfoPropertiesResponse',
    'AwsConfigServiceConfigurationRecorderPropertiesResponse',
    'AwsConfigServiceConfigurationRecorderStatusPropertiesResponse',
    'AwsConfigServiceDeliveryChannelPropertiesResponse',
    'AwsDatabaseMigrationServiceReplicationInstancePropertiesResponse',
    'AwsDaxClusterPropertiesResponse',
    'AwsDynamoDBContinuousBackupsDescriptionPropertiesResponse',
    'AwsDynamoDBTablePropertiesResponse',
    'AwsEc2AccountAttributePropertiesResponse',
    'AwsEc2AddressPropertiesResponse',
    'AwsEc2FlowLogPropertiesResponse',
    'AwsEc2ImagePropertiesResponse',
    'AwsEc2InstancePropertiesResponse',
    'AwsEc2InstanceStatusPropertiesResponse',
    'AwsEc2IpamPropertiesResponse',
    'AwsEc2KeyPairPropertiesResponse',
    'AwsEc2NetworkAclPropertiesResponse',
    'AwsEc2NetworkInterfacePropertiesResponse',
    'AwsEc2RouteTablePropertiesResponse',
    'AwsEc2SecurityGroupPropertiesResponse',
    'AwsEc2SnapshotPropertiesResponse',
    'AwsEc2SubnetPropertiesResponse',
    'AwsEc2VPCEndpointPropertiesResponse',
    'AwsEc2VPCPeeringConnectionPropertiesResponse',
    'AwsEc2VolumePropertiesResponse',
    'AwsEc2VpcPropertiesResponse',
    'AwsEcrImageDetailPropertiesResponse',
    'AwsEcrRepositoryPropertiesResponse',
    'AwsEcsClusterPropertiesResponse',
    'AwsEcsServicePropertiesResponse',
    'AwsEcsTaskDefinitionPropertiesResponse',
    'AwsEfsFileSystemPropertiesResponse',
    'AwsEfsMountTargetPropertiesResponse',
    'AwsEksClusterPropertiesResponse',
    'AwsEksNodegroupPropertiesResponse',
    'AwsElasticBeanstalkApplicationPropertiesResponse',
    'AwsElasticBeanstalkConfigurationTemplatePropertiesResponse',
    'AwsElasticBeanstalkEnvironmentPropertiesResponse',
    'AwsElasticLoadBalancingV2ListenerPropertiesResponse',
    'AwsElasticLoadBalancingV2LoadBalancerPropertiesResponse',
    'AwsElasticLoadBalancingV2TargetGroupPropertiesResponse',
    'AwsElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse',
    'AwsEmrClusterPropertiesResponse',
    'AwsEmrClusterSummaryPropertiesResponse',
    'AwsGuardDutyDetectorPropertiesResponse',
    'AwsIamAccessKeyLastUsedPropertiesResponse',
    'AwsIamAccessKeyMetadataPropertiesResponse',
    'AwsIamGroupPropertiesResponse',
    'AwsIamInstanceProfilePropertiesResponse',
    'AwsIamMFADevicePropertiesResponse',
    'AwsIamPasswordPolicyPropertiesResponse',
    'AwsIamPolicyVersionPropertiesResponse',
    'AwsIamRolePropertiesResponse',
    'AwsIamServerCertificatePropertiesResponse',
    'AwsIamVirtualMFADevicePropertiesResponse',
    'AwsKmsAliasPropertiesResponse',
    'AwsKmsKeyPropertiesResponse',
    'AwsLambdaFunctionCodeLocationPropertiesResponse',
    'AwsLambdaFunctionPropertiesResponse',
    'AwsLightsailBucketPropertiesResponse',
    'AwsLightsailInstancePropertiesResponse',
    'AwsLogsLogGroupPropertiesResponse',
    'AwsLogsLogStreamPropertiesResponse',
    'AwsLogsMetricFilterPropertiesResponse',
    'AwsLogsSubscriptionFilterPropertiesResponse',
    'AwsMacie2JobSummaryPropertiesResponse',
    'AwsMacieAllowListPropertiesResponse',
    'AwsNetworkFirewallFirewallPolicyPropertiesResponse',
    'AwsNetworkFirewallFirewallPropertiesResponse',
    'AwsNetworkFirewallRuleGroupPropertiesResponse',
    'AwsOpenSearchDomainStatusPropertiesResponse',
    'AwsOrganizationsAccountPropertiesResponse',
    'AwsOrganizationsOrganizationPropertiesResponse',
    'AwsRdsDBClusterPropertiesResponse',
    'AwsRdsDBInstancePropertiesResponse',
    'AwsRdsDBSnapshotAttributesResultPropertiesResponse',
    'AwsRdsDBSnapshotPropertiesResponse',
    'AwsRdsEventSubscriptionPropertiesResponse',
    'AwsRdsExportTaskPropertiesResponse',
    'AwsRedshiftClusterParameterGroupPropertiesResponse',
    'AwsRedshiftClusterPropertiesResponse',
    'AwsRoute53DomainsDomainSummaryPropertiesResponse',
    'AwsRoute53HostedZonePropertiesResponse',
    'AwsRoute53ResourceRecordSetPropertiesResponse',
    'AwsS3AccessPointPropertiesResponse',
    'AwsS3BucketPolicyPropertiesResponse',
    'AwsS3BucketPropertiesResponse',
    'AwsS3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse',
    'AwsSageMakerAppPropertiesResponse',
    'AwsSageMakerNotebookInstanceSummaryPropertiesResponse',
    'AwsSecretsManagerResourcePolicyPropertiesResponse',
    'AwsSecretsManagerSecretPropertiesResponse',
    'AwsSnsSubscriptionPropertiesResponse',
    'AwsSnsTopicPropertiesResponse',
    'AwsSqsQueuePropertiesResponse',
    'AwsSsmInstanceInformationPropertiesResponse',
    'AwsSsmParameterPropertiesResponse',
    'AwsSsmResourceComplianceSummaryItemPropertiesResponse',
    'AwsVpcConfigurationResponse',
    'AwsWafWebACLSummaryPropertiesResponse',
    'AwsWafv2LoggingConfigurationPropertiesResponse',
    'BackupPolicyResponse',
    'BaselineEbsBandwidthMbpsRequestResponse',
    'BatchReportModeTypeEnumValueResponse',
    'BatchRestrictionsResponse',
    'BlockDeviceMappingResponse',
    'BootModeValuesEnumValueResponse',
    'BucketEncryptionResponse',
    'BucketOwnerAccessEnumValueResponse',
    'BuildStatusConfigResponse',
    'CFNDataSourceConfigurationsResponse',
    'CFNFeatureAdditionalConfigurationResponse',
    'CFNFeatureConfigurationResponse',
    'CFNKubernetesAuditLogsConfigurationResponse',
    'CFNKubernetesConfigurationResponse',
    'CFNMalwareProtectionConfigurationResponse',
    'CFNS3LogsConfigurationResponse',
    'CFNScanEc2InstanceWithFindingsConfigurationResponse',
    'CacheBehaviorResponse',
    'CacheTypeEnumValueResponse',
    'CanarySettingResponse',
    'CapacityProviderStrategyItemResponse',
    'CapacityReservationPreferenceEnumValueResponse',
    'CapacityReservationSpecificationResponseResponse',
    'CapacityReservationTargetResponseResponse',
    'CertificateDetailsResponse',
    'CertificateResponse',
    'CertificateStatusEnumValueResponse',
    'CertificateTypeEnumValueResponse',
    'ChangeProgressDetailsResponse',
    'CidrRoutingConfigResponse',
    'CloudFormationStackPropertiesResponse',
    'CloudFormationStackSetPropertiesResponse',
    'CloudFrontDistributionPropertiesResponse',
    'CloudTrailTrailPropertiesResponse',
    'CloudWatchAlarmPropertiesResponse',
    'CloudWatchLogsConfigResponse',
    'ClusterConfigResponse',
    'ClusterConfigurationResponse',
    'ClusterEndpointEncryptionTypeEnumValueResponse',
    'ClusterHealthResponse',
    'ClusterIssueCodeEnumValueResponse',
    'ClusterIssueResponse',
    'ClusterSettingsResponse',
    'ClusterStateChangeReasonCodeEnumValueResponse',
    'ClusterStateChangeReasonResponse',
    'ClusterStateEnumValueResponse',
    'ClusterStatusEnumValueResponse',
    'ClusterTimelineResponse',
    'CodeBuildProjectPropertiesResponse',
    'CodeBuildSourceCredentialsInfoPropertiesResponse',
    'CodeResponse',
    'CognitoOptionsResponse',
    'CognitoUserPoolConfigResponse',
    'ColdStorageOptionsResponse',
    'ComplianceExecutionSummaryResponse',
    'ComplianceSeverityEnumValueResponse',
    'ComplianceStatusEnumValueResponse',
    'CompliantSummaryResponse',
    'ComputeTypeEnumValueResponse',
    'ConditionResponse',
    'ConfigChangeStatusEnumValueResponse',
    'ConfigServiceConfigurationRecorderPropertiesResponse',
    'ConfigServiceConfigurationRecorderStatusPropertiesResponse',
    'ConfigServiceDeliveryChannelPropertiesResponse',
    'ConfigSnapshotDeliveryPropertiesResponse',
    'ConfigurationOptionSettingResponse',
    'ConfigurationResponse',
    'ConnectionTrackingSpecificationResponse',
    'ConnectionTrackingSpecificationResponseResponse',
    'ConnectorConfigResponseResponse',
    'ContainerDefinitionResponse',
    'ContainerDependencyResponse',
    'ContinuousBackupsStatusEnumValueResponse',
    'ContributorInsightsSpecificationResponse',
    'ControlPlanePlacementResponseResponse',
    'CookiesResponse',
    'CoordinatesResponse',
    'CorsConfigurationResponse',
    'CorsRuleResponse',
    'CpuOptionsResponse',
    'CredentialProviderTypeEnumValueResponse',
    'CriteriaBlockForJobResponse',
    'CriteriaForJobResponse',
    'CriteriaResponse',
    'CsvResponse',
    'CustomActionResponse',
    'CustomErrorResponseResponse',
    'CustomOriginConfigResponse',
    'DBClusterRoleResponse',
    'DBInstanceRoleResponse',
    'DBSnapshotAttributeResponse',
    'DataExportResponse',
    'DataResourceResponse',
    'DataSourceLevelMetricsBehaviorEnumValueResponse',
    'DatabaseMigrationServiceReplicationInstancePropertiesResponse',
    'DaxClusterEndpointResponse',
    'DaxClusterPropertiesResponse',
    'DeadLetterConfigResponse',
    'DefaultActionEnumValueResponse',
    'DefaultCacheBehaviorResponse',
    'DefaultRetentionResponse',
    'DeleteMarkerReplicationResponse',
    'DeploymentAlarmsResponse',
    'DeploymentCircuitBreakerResponse',
    'DeploymentConfigurationResponse',
    'DeploymentControllerResponse',
    'DeploymentStatusEnumValueResponse',
    'DeploymentTargetsResponse',
    'DestinationOptionsModelPropertiesResponse',
    'DestinationResponse',
    'DeviceResponse',
    'DeviceTypeEnumValueResponse',
    'DimensionResponse',
    'DiskResponse',
    'DistributionConfigResponse',
    'DockerVolumeConfigurationResponse',
    'DomainEndpointOptionsResponse',
    'DomainProcessingStatusTypeEnumValueResponse',
    'DomainTypeEnumValueResponse',
    'DynamoDBContinuousBackupsDescriptionPropertiesResponse',
    'DynamoDBTablePropertiesResponse',
    'EBSOptionsResponse',
    'EBSTagSpecificationResponse',
    'EFSVolumeConfigurationResponse',
    'EbsBlockDeviceResponse',
    'EbsInstanceBlockDeviceResponse',
    'Ec2AccountAttributePropertiesResponse',
    'Ec2AddressPropertiesResponse',
    'Ec2FlowLogPropertiesResponse',
    'Ec2ImagePropertiesResponse',
    'Ec2InstanceAttributesResponse',
    'Ec2InstancePropertiesResponse',
    'Ec2InstanceStatusPropertiesResponse',
    'Ec2IpamPropertiesResponse',
    'Ec2KeyPairPropertiesResponse',
    'Ec2NetworkAclPropertiesResponse',
    'Ec2NetworkInterfacePropertiesResponse',
    'Ec2RouteTablePropertiesResponse',
    'Ec2SecurityGroupPropertiesResponse',
    'Ec2SnapshotPropertiesResponse',
    'Ec2SubnetPropertiesResponse',
    'Ec2VPCEndpointPropertiesResponse',
    'Ec2VPCPeeringConnectionPropertiesResponse',
    'Ec2VolumePropertiesResponse',
    'Ec2VpcPropertiesResponse',
    'EcrImageDetailPropertiesResponse',
    'EcrRepositoryPropertiesResponse',
    'EcsClusterPropertiesResponse',
    'EcsServicePropertiesResponse',
    'EcsTaskDefinitionPropertiesResponse',
    'EfsFileSystemPropertiesResponse',
    'EfsMountTargetPropertiesResponse',
    'EksClusterPropertiesResponse',
    'EksNodegroupPropertiesResponse',
    'ElasticBeanstalkApplicationPropertiesResponse',
    'ElasticBeanstalkConfigurationTemplatePropertiesResponse',
    'ElasticBeanstalkEnvironmentPropertiesResponse',
    'ElasticFileSystemTagResponse',
    'ElasticGpuAssociationResponse',
    'ElasticInferenceAcceleratorAssociationResponse',
    'ElasticLoadBalancingV2ListenerPropertiesResponse',
    'ElasticLoadBalancingV2LoadBalancerPropertiesResponse',
    'ElasticLoadBalancingV2TargetGroupPropertiesResponse',
    'ElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse',
    'EmrClusterPropertiesResponse',
    'EmrClusterStatusResponse',
    'EmrClusterSummaryPropertiesResponse',
    'EnclaveOptionsResponse',
    'EncryptionAtRestOptionsResponse',
    'EncryptionConfigResponse',
    'EncryptionConfigurationResponse',
    'EndpointConfigurationResponse',
    'EnhancedMetricsConfigResponse',
    'EnvironmentFileResponse',
    'EnvironmentResponse',
    'EnvironmentTypeEnumValueResponse',
    'EnvironmentVariableResponse',
    'EnvironmentVariableTypeEnumValueResponse',
    'EphemeralStorageResponse',
    'ErrorDetailResponse',
    'EstablishedMultiRegionAccessPointPolicyResponse',
    'EventBridgeConfigurationResponse',
    'EventCodeEnumValueResponse',
    'EventSelectorResponse',
    'ExclusionByResourceTypesResponse',
    'ExecuteCommandConfigurationResponse',
    'ExecuteCommandLogConfigurationResponse',
    'ExportSourceTypeEnumValueResponse',
    'FSxAuthorizationConfigResponse',
    'FSxWindowsFileServerVolumeConfigurationResponse',
    'FieldLogLevelEnumValueResponse',
    'FieldToMatchResponse',
    'FileSystemConfigResponse',
    'FileSystemProtectionResponse',
    'FileSystemTypeEnumValueResponse',
    'FilterGroupResponse',
    'FilterResponse',
    'FilterRuleResponse',
    'FirelensConfigurationResponse',
    'FirewallPolicyResponse',
    'FixedResponseConfigResponse',
    'ForwardConfigResponse',
    'ForwardedValuesResponse',
    'FunctionAssociationResponse',
    'GenerateSecretStringResponse',
    'GeoLocationResponse',
    'GeoProximityLocationResponse',
    'GeoRestrictionResponse',
    'GitSubmodulesConfigResponse',
    'GlobalSecondaryIndexResponse',
    'GraphQLApiIntrospectionConfigEnumValueResponse',
    'GraphQLApiTypeEnumValueResponse',
    'GraphQLApiVisibilityEnumValueResponse',
    'GroupIdentifierResponse',
    'GuardDutyDetectorPropertiesResponse',
    'HardwareResponse',
    'HeaderResponse',
    'HealthCheckResponse',
    'HibernationOptionsResponse',
    'HostEntryResponse',
    'HostVolumePropertiesResponse',
    'HostedZoneConfigResponse',
    'HostedZoneTagResponse',
    'HostnameTypeEnumValueResponse',
    'HttpTokensStateEnumValueResponse',
    'HypervisorTypeEnumValueResponse',
    'IPAddressTypeEnumValueResponse',
    'IPSetReferenceResponse',
    'IPSetResponse',
    'IamAccessKeyLastUsedPropertiesResponse',
    'IamAccessKeyMetadataPropertiesResponse',
    'IamGroupPropertiesResponse',
    'IamInstanceProfilePropertiesResponse',
    'IamInstanceProfileResponse',
    'IamMFADevicePropertiesResponse',
    'IamPasswordPolicyPropertiesResponse',
    'IamPolicyVersionPropertiesResponse',
    'IamRolePropertiesResponse',
    'IamServerCertificatePropertiesResponse',
    'IamVirtualMFADevicePropertiesResponse',
    'IdentityResponse',
    'ImageConfigResponse',
    'ImagePullCredentialsTypeEnumValueResponse',
    'ImageScanFindingsSummaryResponse',
    'ImageScanStatusResponse',
    'ImageScanningConfigurationResponse',
    'ImageStateEnumValueResponse',
    'ImageTypeValuesEnumValueResponse',
    'ImdsSupportValuesEnumValueResponse',
    'ImportSourceSpecificationResponse',
    'InferenceAcceleratorResponse',
    'InitiatedByEnumValueResponse',
    'InputFormatOptionsResponse',
    'InsightSelectorResponse',
    'InstanceAggregatedAssociationOverviewResponse',
    'InstanceAttachmentEnaSrdSpecificationResponse',
    'InstanceAttachmentEnaSrdUdpSpecificationResponse',
    'InstanceAutoRecoveryStateEnumValueResponse',
    'InstanceBlockDeviceMappingResponse',
    'InstanceBootModeValuesEnumValueResponse',
    'InstanceCollectionTypeEnumValueResponse',
    'InstanceIpv4PrefixResponse',
    'InstanceIpv6AddressResponse',
    'InstanceIpv6PrefixResponse',
    'InstanceLifecycleTypeEnumValueResponse',
    'InstanceMaintenanceOptionsResponse',
    'InstanceMaintenancePolicyResponse',
    'InstanceMetadataEndpointStateEnumValueResponse',
    'InstanceMetadataOptionsResponseResponse',
    'InstanceMetadataOptionsStateEnumValueResponse',
    'InstanceMetadataProtocolStateEnumValueResponse',
    'InstanceMetadataTagsStateEnumValueResponse',
    'InstanceNetworkInterfaceAssociationResponse',
    'InstanceNetworkInterfaceAttachmentResponse',
    'InstanceNetworkInterfaceResponse',
    'InstancePrivateIpAddressResponse',
    'InstanceRequirementsResponse',
    'InstanceRoleTypeEnumValueResponse',
    'InstanceStateNameEnumValueResponse',
    'InstanceStateResponse',
    'InstanceStatusDetailsResponse',
    'InstanceStatusEventResponse',
    'InstanceStatusSummaryResponse',
    'InstanceTypeEnumValueResponse',
    'InstancesDistributionResponse',
    'IntelligentTieringConfigurationResponse',
    'InventoryConfigurationResponse',
    'IpFamilyEnumValueResponse',
    'IpPermissionResponse',
    'IpRangeResponse',
    'IpamOperatingRegionResponse',
    'IpamStateEnumValueResponse',
    'IpamTierEnumValueResponse',
    'Ipv4PrefixSpecificationResponse',
    'Ipv6PrefixSpecificationResponse',
    'Ipv6RangeResponse',
    'JobComparatorEnumValueResponse',
    'JobStatusEnumValueResponse',
    'JobTypeEnumValueResponse',
    'KerberosAttributesResponse',
    'KernelCapabilitiesResponse',
    'KeyAlgorithmEnumValueResponse',
    'KeySchemaResponse',
    'KeyValuePairResponse',
    'KinesisStreamSpecificationResponse',
    'KmsAliasPropertiesResponse',
    'KmsKeyPropertiesResponse',
    'KubernetesNetworkConfigResponseResponse',
    'LabelNameConditionModelPropertiesResponse',
    'LambdaAuthorizerConfigResponse',
    'LambdaConfigurationResponse',
    'LambdaFunctionAssociationResponse',
    'LambdaFunctionCodeLocationPropertiesResponse',
    'LambdaFunctionPropertiesResponse',
    'LastRunErrorStatusCodeEnumValueResponse',
    'LastRunErrorStatusResponse',
    'LaunchTemplateOverridesResponse',
    'LaunchTemplateResponse',
    'LaunchTemplateSpecificationResponse',
    'LegacyCustomOriginResponse',
    'LegacyS3OriginResponse',
    'LicenseConfigurationResponse',
    'LifecycleConfigurationResponse',
    'LifecycleHookSpecificationResponse',
    'LifecyclePolicyResponse',
    'LightsailBucketPropertiesResponse',
    'LightsailInstancePropertiesResponse',
    'LinuxParametersResponse',
    'LoadBalancerAttributeResponse',
    'LoadBalancerResponse',
    'LocalSecondaryIndexResponse',
    'LocationResponse',
    'LogConfigResponse',
    'LogConfigurationResponse',
    'LogPublishingOptionResponse',
    'LogSetupResponse',
    'LoggingConfigResponse',
    'LoggingConfigurationResponse',
    'LoggingFilterModelPropertiesResponse',
    'LoggingPropertiesResponse',
    'LoggingResponse',
    'LogsConfigResponse',
    'LogsConfigStatusTypeEnumValueResponse',
    'LogsLogGroupPropertiesResponse',
    'LogsLogStreamPropertiesResponse',
    'LogsMetricFilterPropertiesResponse',
    'LogsSubscriptionFilterPropertiesResponse',
    'Macie2JobSummaryPropertiesResponse',
    'MacieAllowListPropertiesResponse',
    'MasterUserSecretResponse',
    'MatchAttributesResponse',
    'MatcherResponse',
    'MaxAgeRuleResponse',
    'MaxCountRuleResponse',
    'MaximumExecutionFrequencyEnumValueResponse',
    'MemoryGiBPerVCpuRequestResponse',
    'MemoryMiBRequestResponse',
    'MethodSettingResponse',
    'MetricDataQueryResponse',
    'MetricResponse',
    'MetricStatResponse',
    'MetricTransformationResponse',
    'MetricsCollectionResponse',
    'MetricsConfigurationResponse',
    'MetricsResponse',
    'MitigationInEffectEnumEnumValueResponse',
    'MixedInstancesPolicyResponse',
    'ModifyingPropertiesResponse',
    'MonitoringResponse',
    'MonitoringStateEnumValueResponse',
    'MonthlyTransferResponse',
    'MountPointResponse',
    'MutualAuthenticationResponse',
    'NetworkBandwidthGbpsRequestResponse',
    'NetworkConfigurationResponse',
    'NetworkFirewallFirewallPolicyPropertiesResponse',
    'NetworkFirewallFirewallPropertiesResponse',
    'NetworkFirewallRuleGroupPropertiesResponse',
    'NetworkInterfaceCountRequestResponse',
    'NetworkInterfaceStatusEnumValueResponse',
    'NetworkingResponse',
    'NodeResponse',
    'NodeToNodeEncryptionOptionsResponse',
    'NonCompliantSummaryResponse',
    'NoncurrentVersionExpirationResponse',
    'NoncurrentVersionTransitionResponse',
    'NotebookInstanceStatusEnumValueResponse',
    'NotificationConfigurationResponse',
    'NotificationFilterResponse',
    'OIDCResponse',
    'ObjectLockConfigurationResponse',
    'ObjectLockRuleResponse',
    'OffPeakWindowOptionsResponse',
    'OffPeakWindowResponse',
    'OpenIDConnectConfigResponse',
    'OpenSearchDomainStatusPropertiesResponse',
    'OpenSearchPartitionInstanceTypeEnumValueResponse',
    'OpenSearchWarmPartitionInstanceTypeEnumValueResponse',
    'OperationLevelMetricsConfigEnumValueResponse',
    'OperationPreferencesResponse',
    'OptionSettingResponse',
    'OrganizationsAccountPropertiesResponse',
    'OrganizationsOrganizationPropertiesResponse',
    'OriginCustomHeaderResponse',
    'OriginGroupFailoverCriteriaResponse',
    'OriginGroupMemberResponse',
    'OriginGroupMembersResponse',
    'OriginGroupResponse',
    'OriginGroupsResponse',
    'OriginResponse',
    'OriginShieldResponse',
    'OutpostConfigResponseResponse',
    'OutputResponse',
    'OwnershipControlsResponse',
    'OwnershipControlsRuleResponse',
    'ParameterGroupStatusResponse',
    'ParameterResponse',
    'PartitionedPrefixResponse',
    'PingStatusEnumValueResponse',
    'PlacementConstraintResponse',
    'PlacementGroupConfigResponse',
    'PlacementGroupStrategyEnumValueResponse',
    'PlacementResponse',
    'PlacementStrategyResponse',
    'PlatformTypeEnumValueResponse',
    'PlatformValuesEnumValueResponse',
    'PointInTimeRecoveryDescriptionResponse',
    'PointInTimeRecoverySpecificationResponse',
    'PointInTimeRecoveryStatusEnumValueResponse',
    'PolicyResponse',
    'PortMappingResponse',
    'PortRangeResponse',
    'PortResponse',
    'PortSetResponse',
    'PrefixListIdResponse',
    'PrivateDnsNameOptionsOnLaunchModelPropertiesResponse',
    'PrivateDnsNameOptionsResponseResponse',
    'PrivateIpAddressSpecificationResponse',
    'ProcessorFeatureResponse',
    'ProductCodeResponse',
    'ProductCodeValuesEnumValueResponse',
    'ProjectArtifactsResponse',
    'ProjectBadgeResponse',
    'ProjectBuildBatchConfigResponse',
    'ProjectCacheResponse',
    'ProjectEnvironmentResponse',
    'ProjectFileSystemLocationResponse',
    'ProjectFleetResponse',
    'ProjectSourceResponse',
    'ProjectSourceVersionResponse',
    'ProjectVisibilityTypeEnumValueResponse',
    'ProjectionResponse',
    'PropertyValueTypeEnumValueResponse',
    'ProposedMultiRegionAccessPointPolicyResponse',
    'ProviderResponse',
    'ProvisionedThroughputResponse',
    'ProxyConfigurationResponse',
    'PublicAccessBlockConfigurationResponse',
    'PublishMetricActionResponse',
    'QueryLoggingConfigResponse',
    'QueueConfigurationResponse',
    'RRTypeEnumValueResponse',
    'RdsDBClusterPropertiesResponse',
    'RdsDBInstancePropertiesResponse',
    'RdsDBSnapshotAttributesResultPropertiesResponse',
    'RdsDBSnapshotPropertiesResponse',
    'RdsDbClusterEndpointResponse',
    'RdsDbInstanceEndpointResponse',
    'RdsEventSubscriptionPropertiesResponse',
    'RdsExportTaskPropertiesResponse',
    'ReadEndpointResponse',
    'RecorderStatusEnumValueResponse',
    'RecordingFrequencyEnumValueResponse',
    'RecordingGroupResponse',
    'RecordingModeOverrideResponse',
    'RecordingModeResponse',
    'RecordingStrategyResponse',
    'RecordingStrategyTypeEnumValueResponse',
    'RedirectAllRequestsToResponse',
    'RedirectConfigResponse',
    'RedirectRuleResponse',
    'RedshiftClusterEndpointResponse',
    'RedshiftClusterParameterGroupPropertiesResponse',
    'RedshiftClusterPropertiesResponse',
    'ReferenceSetsResponse',
    'RegistryCredentialResponse',
    'RemoteAccessResponse',
    'RenewalEligibilityEnumValueResponse',
    'ReplicaModificationsResponse',
    'ReplicaRegionResponse',
    'ReplicationConfigurationResponse',
    'ReplicationDestinationResponse',
    'ReplicationPendingModifiedValuesResponse',
    'ReplicationRuleAndOperatorResponse',
    'ReplicationRuleFilterResponse',
    'ReplicationRuleResponse',
    'ReplicationSubnetGroupResponse',
    'ReplicationTimeResponse',
    'ReplicationTimeValueResponse',
    'RepoUpgradeOnBootEnumValueResponse',
    'RepositoryCredentialsResponse',
    'ResolverLevelMetricsBehaviorEnumValueResponse',
    'ResourcePolicyResponse',
    'ResourceRecordResponse',
    'ResourceRecordSetFailoverEnumValueResponse',
    'ResourceRecordSetRegionEnumValueResponse',
    'ResourceRequirementResponse',
    'ResourceSpecResponse',
    'ResourceTypeEnumValueResponse',
    'RestrictionsResponse',
    'Route53DomainsDomainSummaryPropertiesResponse',
    'Route53HostedZonePropertiesResponse',
    'Route53ResourceRecordSetPropertiesResponse',
    'RoutingRuleConditionResponse',
    'RoutingRuleResponse',
    'RuleDefinitionResponse',
    'RuleGroupResponse',
    'RuleOptionResponse',
    'RuleResponse',
    'RuleVariablesModelResponse',
    'RuleVariablesResponse',
    'RulesSourceListResponse',
    'RulesSourceResponse',
    'RuntimeManagementConfigResponse',
    'RuntimePlatformResponse',
    'S3AccessPointPropertiesResponse',
    'S3BucketCriteriaForJobResponse',
    'S3BucketDefinitionForJobResponse',
    'S3BucketPolicyPropertiesResponse',
    'S3BucketPropertiesResponse',
    'S3BucketSourceResponse',
    'S3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse',
    'S3KeyFilterResponse',
    'S3LocationResponse',
    'S3LogsConfigResponse',
    'S3OriginConfigResponse',
    'S3WordsListResponse',
    'SAMLIdpResponse',
    'SAMLOptionsOutputResponse',
    'SSEDescriptionResponse',
    'SSESpecificationResponse',
    'SSEStatusEnumValueResponse',
    'SSETypeEnumValueResponse',
    'SageMakerAppPropertiesResponse',
    'SageMakerNotebookInstanceSummaryPropertiesResponse',
    'ScaleDownBehaviorEnumValueResponse',
    'ScalingConfigResponse',
    'ScalingConfigurationResponse',
    'ScanStatusEnumValueResponse',
    'SecretResponse',
    'SecretsManagerResourcePolicyPropertiesResponse',
    'SecretsManagerSecretPropertiesResponse',
    'SecurityGroupMembershipResponse',
    'ServerSideEncryptionByDefaultResponse',
    'ServerSideEncryptionRuleResponse',
    'ServerTypeEnumValueResponse',
    'ServerlessV2ScalingConfigurationResponse',
    'ServiceConnectClientAliasResponse',
    'ServiceConnectConfigurationResponse',
    'ServiceConnectDefaultsResponse',
    'ServiceConnectServiceResponse',
    'ServiceConnectTlsCertificateAuthorityResponse',
    'ServiceConnectTlsConfigurationResponse',
    'ServiceManagedEBSVolumeConfigurationResponse',
    'ServiceRegistryResponse',
    'ServiceSoftwareOptionsResponse',
    'ServiceVolumeConfigurationResponse',
    'SeveritySummaryResponse',
    'SimpleCriterionForJobResponse',
    'SimpleCriterionKeyForJobEnumValueResponse',
    'SingleHeaderModelPropertiesResponse',
    'SnapStartResponse',
    'SnapStartResponseResponse',
    'SnapshotOptionsResponse',
    'SnapshotStateEnumValueResponse',
    'SnsSubscriptionPropertiesResponse',
    'SnsTopicPropertiesResponse',
    'SoftwareUpdateOptionsResponse',
    'SourceAuthResponse',
    'SourceAuthTypeEnumValueResponse',
    'SourceConfigurationResponse',
    'SourceSelectionCriteriaResponse',
    'SourceTypeEnumValueResponse',
    'SqsQueuePropertiesResponse',
    'SseKmsEncryptedObjectsResponse',
    'SsmInstanceInformationPropertiesResponse',
    'SsmParameterPropertiesResponse',
    'SsmResourceComplianceSummaryItemPropertiesResponse',
    'StackInstancesResponse',
    'StateReasonResponse',
    'StateResponse',
    'StatefulEngineOptionsResponse',
    'StatefulRuleGroupOverrideResponse',
    'StatefulRuleGroupReferenceResponse',
    'StatefulRuleOptionsResponse',
    'StatefulRuleResponse',
    'StatelessRuleGroupReferenceResponse',
    'StatelessRuleResponse',
    'StatelessRulesAndCustomActionsResponse',
    'StatusCodesResponse',
    'StatusNameEnumValueResponse',
    'StatusTypeEnumValueResponse',
    'StorageClassAnalysisResponse',
    'StorageTierEnumValueResponse',
    'StreamSpecificationResponse',
    'SubnetMappingResponse',
    'SubnetResponse',
    'SubscriptionResponse',
    'SummaryStatusEnumValueResponse',
    'SystemControlResponse',
    'SystemDataResponse',
    'TCPFlagFieldResponse',
    'TLSSecurityPolicyEnumValueResponse',
    'TagCriterionForJobResponse',
    'TagCriterionPairForJobResponse',
    'TagFilterResponse',
    'TagItemResponse',
    'TagPropertyResponse',
    'TagResponse',
    'TaintResponse',
    'TargetDescriptionResponse',
    'TargetGroupAttributeResponse',
    'TargetGroupStickinessConfigResponse',
    'TargetGroupTupleResponse',
    'TargetHealthReasonEnumEnumValueResponse',
    'TargetHealthResponse',
    'TargetHealthStateEnumEnumValueResponse',
    'TargetObjectKeyFormatResponse',
    'TaskDefinitionPlacementConstraintResponse',
    'TenancyEnumValueResponse',
    'TierResponse',
    'TieringResponse',
    'TimeToLiveSpecificationResponse',
    'TimeoutConfigurationResponse',
    'TmpfsResponse',
    'TopicConfigurationResponse',
    'TotalLocalStorageGBRequestResponse',
    'TpmSupportValuesEnumValueResponse',
    'TracingConfigResponse',
    'TransitionResponse',
    'UlimitResponse',
    'UnusedAccessConfigurationResponse',
    'UpdateConfigResponse',
    'UserIdGroupPairResponse',
    'UserPausedDetailsResponse',
    'UserPoolConfigResponse',
    'VCpuCountRequestResponse',
    'VPCDerivedInfoResponse',
    'VPCResponse',
    'VersioningConfigurationResponse',
    'ViewerCertificateResponse',
    'VirtualizationTypeEnumValueResponse',
    'VolumeFromResponse',
    'VolumeResponse',
    'VolumeTypeEnumValueResponse',
    'VpcConfigResponse',
    'VpcConfigResponseResponse',
    'VpcConfigurationResponse',
    'VpcSecurityGroupMembershipResponse',
    'WafWebACLSummaryPropertiesResponse',
    'Wafv2LoggingConfigurationPropertiesResponse',
    'WebhookBuildTypeEnumValueResponse',
    'WebhookFilterResponse',
    'WebhookFilterTypeEnumValueResponse',
    'WebhookResponse',
    'WebsiteConfigurationResponse',
    'WindowStartTimeResponse',
    'ZoneAwarenessConfigResponse',
]

@pulumi.output_type
class AbortIncompleteMultipartUploadResponse(dict):
    """
    Definition of AbortIncompleteMultipartUpload
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysAfterInitiation":
            suggest = "days_after_initiation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AbortIncompleteMultipartUploadResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AbortIncompleteMultipartUploadResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AbortIncompleteMultipartUploadResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_after_initiation: Optional[int] = None):
        """
        Definition of AbortIncompleteMultipartUpload
        :param int days_after_initiation: Specifies the number of days after which Amazon S3 stops an incomplete multipart upload.
        """
        if days_after_initiation is not None:
            pulumi.set(__self__, "days_after_initiation", days_after_initiation)

    @property
    @pulumi.getter(name="daysAfterInitiation")
    def days_after_initiation(self) -> Optional[int]:
        """
        Specifies the number of days after which Amazon S3 stops an incomplete multipart upload.
        """
        return pulumi.get(self, "days_after_initiation")


@pulumi.output_type
class AccelerateConfigurationResponse(dict):
    """
    Definition of AccelerateConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accelerationStatus":
            suggest = "acceleration_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccelerateConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccelerateConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccelerateConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acceleration_status: Optional[str] = None):
        """
        Definition of AccelerateConfiguration
        :param str acceleration_status: Specifies the transfer acceleration status of the bucket.
        """
        if acceleration_status is not None:
            pulumi.set(__self__, "acceleration_status", acceleration_status)

    @property
    @pulumi.getter(name="accelerationStatus")
    def acceleration_status(self) -> Optional[str]:
        """
        Specifies the transfer acceleration status of the bucket.
        """
        return pulumi.get(self, "acceleration_status")


@pulumi.output_type
class AcceleratorCountRequestResponse(dict):
    """
    Definition of AcceleratorCountRequest
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Definition of AcceleratorCountRequest
        :param int max: The maximum value.
        :param int min: The minimum value.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum value.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum value.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class AcceleratorTotalMemoryMiBRequestResponse(dict):
    """
    Definition of AcceleratorTotalMemoryMiBRequest
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Definition of AcceleratorTotalMemoryMiBRequest
        :param int max: The memory maximum in MiB.
        :param int min: The memory minimum in MiB.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The memory maximum in MiB.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The memory minimum in MiB.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class AccessAnalyzerAnalyzerPropertiesResponse(dict):
    """
    Definition of AccessAnalyzerAnalyzer
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessAnalyzerAnalyzerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessAnalyzerAnalyzerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessAnalyzerAnalyzerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsAccessAnalyzerAnalyzerPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of AccessAnalyzerAnalyzer
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsAccessAnalyzerAnalyzerPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsAccessAnalyzerAnalyzerPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class AccessConfigResponseResponse(dict):
    """
    Definition of AccessConfigResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMode":
            suggest = "authentication_mode"
        elif key == "bootstrapClusterCreatorAdminPermissions":
            suggest = "bootstrap_cluster_creator_admin_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessConfigResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessConfigResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessConfigResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_mode: Optional['outputs.AuthenticationModeEnumValueResponse'] = None,
                 bootstrap_cluster_creator_admin_permissions: Optional[bool] = None):
        """
        Definition of AccessConfigResponse
        :param 'AuthenticationModeEnumValueResponse' authentication_mode: <p>The current authentication mode of the cluster.</p>
        :param bool bootstrap_cluster_creator_admin_permissions: <p>Specifies whether or not the cluster creator IAM principal was set as a cluster admin access entry during cluster creation time.</p>
        """
        if authentication_mode is not None:
            pulumi.set(__self__, "authentication_mode", authentication_mode)
        if bootstrap_cluster_creator_admin_permissions is not None:
            pulumi.set(__self__, "bootstrap_cluster_creator_admin_permissions", bootstrap_cluster_creator_admin_permissions)

    @property
    @pulumi.getter(name="authenticationMode")
    def authentication_mode(self) -> Optional['outputs.AuthenticationModeEnumValueResponse']:
        """
        <p>The current authentication mode of the cluster.</p>
        """
        return pulumi.get(self, "authentication_mode")

    @property
    @pulumi.getter(name="bootstrapClusterCreatorAdminPermissions")
    def bootstrap_cluster_creator_admin_permissions(self) -> Optional[bool]:
        """
        <p>Specifies whether or not the cluster creator IAM principal was set as a cluster admin access entry during cluster creation time.</p>
        """
        return pulumi.get(self, "bootstrap_cluster_creator_admin_permissions")


@pulumi.output_type
class AccessControlTranslationResponse(dict):
    """
    Definition of AccessControlTranslation
    """
    def __init__(__self__, *,
                 owner: Optional[str] = None):
        """
        Definition of AccessControlTranslation
        :param str owner: Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the *Amazon S3 API Reference*.
        """
        if owner is not None:
            pulumi.set(__self__, "owner", owner)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Specifies the replica ownership. For default and valid values, see [PUT bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) in the *Amazon S3 API Reference*.
        """
        return pulumi.get(self, "owner")


@pulumi.output_type
class AccessLogSettingResponse(dict):
    """
    Definition of AccessLogSetting
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationArn":
            suggest = "destination_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessLogSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessLogSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessLogSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_arn: Optional[str] = None,
                 format: Optional[str] = None):
        """
        Definition of AccessLogSetting
        :param str destination_arn: The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with ``amazon-apigateway-``. This parameter is required to enable access logging.
        :param str format: A single line format of the access logs of data, as specified by selected [$context variables](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference). The format must include at least ``$context.requestId``. This parameter is required to enable access logging.
        """
        if destination_arn is not None:
            pulumi.set(__self__, "destination_arn", destination_arn)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with ``amazon-apigateway-``. This parameter is required to enable access logging.
        """
        return pulumi.get(self, "destination_arn")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        A single line format of the access logs of data, as specified by selected [$context variables](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference). The format must include at least ``$context.requestId``. This parameter is required to enable access logging.
        """
        return pulumi.get(self, "format")


@pulumi.output_type
class AccessRulesResponse(dict):
    """
    Definition of AccessRules
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPublicOverrides":
            suggest = "allow_public_overrides"
        elif key == "getObject":
            suggest = "get_object"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_public_overrides: Optional[bool] = None,
                 get_object: Optional[str] = None):
        """
        Definition of AccessRules
        :param bool allow_public_overrides: A Boolean value that indicates whether the access control list (ACL) permissions that are applied to individual objects override the getObject option that is currently specified.
        :param str get_object: Specifies the anonymous access to all objects in a bucket.
        """
        if allow_public_overrides is not None:
            pulumi.set(__self__, "allow_public_overrides", allow_public_overrides)
        if get_object is not None:
            pulumi.set(__self__, "get_object", get_object)

    @property
    @pulumi.getter(name="allowPublicOverrides")
    def allow_public_overrides(self) -> Optional[bool]:
        """
        A Boolean value that indicates whether the access control list (ACL) permissions that are applied to individual objects override the getObject option that is currently specified.
        """
        return pulumi.get(self, "allow_public_overrides")

    @property
    @pulumi.getter(name="getObject")
    def get_object(self) -> Optional[str]:
        """
        Specifies the anonymous access to all objects in a bucket.
        """
        return pulumi.get(self, "get_object")


@pulumi.output_type
class AccountAttributeValueResponse(dict):
    """
    Definition of AccountAttributeValue
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeValue":
            suggest = "attribute_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountAttributeValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountAttributeValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountAttributeValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_value: Optional[str] = None):
        """
        Definition of AccountAttributeValue
        :param str attribute_value: <p>The value of the attribute.</p>
        """
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[str]:
        """
        <p>The value of the attribute.</p>
        """
        return pulumi.get(self, "attribute_value")


@pulumi.output_type
class AcmCertificateSummaryPropertiesResponse(dict):
    """
    Definition of AcmCertificateSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AcmCertificateSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AcmCertificateSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AcmCertificateSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsAcmCertificateSummaryPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of AcmCertificateSummary
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsAcmCertificateSummaryPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsAcmCertificateSummaryPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ActionConditionModelPropertiesResponse(dict):
    """
    Definition of ActionConditionModelProperties
    """
    def __init__(__self__, *,
                 action: Optional[str] = None):
        """
        Definition of ActionConditionModelProperties
        :param str action: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class ActionDefinitionResponse(dict):
    """
    Definition of ActionDefinition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publishMetricAction":
            suggest = "publish_metric_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 publish_metric_action: Optional['outputs.PublishMetricActionResponse'] = None):
        """
        Definition of ActionDefinition
        :param 'PublishMetricActionResponse' publish_metric_action: Property publishMetricAction
        """
        if publish_metric_action is not None:
            pulumi.set(__self__, "publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> Optional['outputs.PublishMetricActionResponse']:
        """
        Property publishMetricAction
        """
        return pulumi.get(self, "publish_metric_action")


@pulumi.output_type
class ActionResponse(dict):
    """
    Definition of Action
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateCognitoConfig":
            suggest = "authenticate_cognito_config"
        elif key == "authenticateOidcConfig":
            suggest = "authenticate_oidc_config"
        elif key == "fixedResponseConfig":
            suggest = "fixed_response_config"
        elif key == "forwardConfig":
            suggest = "forward_config"
        elif key == "redirectConfig":
            suggest = "redirect_config"
        elif key == "targetGroupArn":
            suggest = "target_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_cognito_config: Optional['outputs.AuthenticateCognitoConfigResponse'] = None,
                 authenticate_oidc_config: Optional['outputs.AuthenticateOidcConfigResponse'] = None,
                 fixed_response_config: Optional['outputs.FixedResponseConfigResponse'] = None,
                 forward_config: Optional['outputs.ForwardConfigResponse'] = None,
                 order: Optional[int] = None,
                 redirect_config: Optional['outputs.RedirectConfigResponse'] = None,
                 target_group_arn: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Definition of Action
        :param 'AuthenticateCognitoConfigResponse' authenticate_cognito_config: [HTTPS listeners] Information for using Amazon Cognito to authenticate users. Specify only when ``Type`` is ``authenticate-cognito``. Specifies information required when integrating with Amazon Cognito to authenticate users.
        :param 'AuthenticateOidcConfigResponse' authenticate_oidc_config: [HTTPS listeners] Information about an identity provider that is compliant with OpenID Connect (OIDC). Specify only when ``Type`` is ``authenticate-oidc``. Specifies information required using an identity provide (IdP) that is compliant with OpenID Connect (OIDC) to authenticate users.
        :param 'FixedResponseConfigResponse' fixed_response_config: [Application Load Balancer] Information for creating an action that returns a custom HTTP response. Specify only when ``Type`` is ``fixed-response``. Specifies information required when returning a custom HTTP response.
        :param 'ForwardConfigResponse' forward_config: Information for creating an action that distributes requests among one or more target groups. For Network Load Balancers, you can specify a single target group. Specify only when ``Type`` is ``forward``. If you specify both ``ForwardConfig`` and ``TargetGroupArn``, you can specify only one target group using ``ForwardConfig`` and it must be the same target group specified in ``TargetGroupArn``. Information for creating an action that distributes requests among one or more target groups. For Network Load Balancers, you can specify a single target group. Specify only when ``Type`` is ``forward``. If you specify both ``ForwardConfig`` and ``TargetGroupArn``, you can specify only one target group using ``ForwardConfig`` and it must be the same target group specified in ``TargetGroupArn``.
        :param int order: The order for the action. This value is required for rules with multiple actions. The action with the lowest value for order is performed first.
        :param 'RedirectConfigResponse' redirect_config: [Application Load Balancer] Information for creating a redirect action. Specify only when ``Type`` is ``redirect``. Information about a redirect action. A URI consists of the following components: protocol://hostname:port/path?query. You must modify at least one of the following components to avoid a redirect loop: protocol, hostname, port, or path. Any components that you do not modify retain their original values. You can reuse URI components using the following reserved keywords:  +  #{protocol}  +  #{host}  +  #{port}  +  #{path} (the leading '/' is removed)  +  #{query}   For example, you can change the path to '/new/#{path}', the hostname to 'example.#{host}', or the query to '#{query}&value=xyz'.
        :param str target_group_arn: The Amazon Resource Name (ARN) of the target group. Specify only when ``Type`` is ``forward`` and you want to route to a single target group. To route to one or more target groups, use ``ForwardConfig`` instead.
        :param str type: The type of action.
        """
        if authenticate_cognito_config is not None:
            pulumi.set(__self__, "authenticate_cognito_config", authenticate_cognito_config)
        if authenticate_oidc_config is not None:
            pulumi.set(__self__, "authenticate_oidc_config", authenticate_oidc_config)
        if fixed_response_config is not None:
            pulumi.set(__self__, "fixed_response_config", fixed_response_config)
        if forward_config is not None:
            pulumi.set(__self__, "forward_config", forward_config)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if redirect_config is not None:
            pulumi.set(__self__, "redirect_config", redirect_config)
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="authenticateCognitoConfig")
    def authenticate_cognito_config(self) -> Optional['outputs.AuthenticateCognitoConfigResponse']:
        """
        [HTTPS listeners] Information for using Amazon Cognito to authenticate users. Specify only when ``Type`` is ``authenticate-cognito``. Specifies information required when integrating with Amazon Cognito to authenticate users.
        """
        return pulumi.get(self, "authenticate_cognito_config")

    @property
    @pulumi.getter(name="authenticateOidcConfig")
    def authenticate_oidc_config(self) -> Optional['outputs.AuthenticateOidcConfigResponse']:
        """
        [HTTPS listeners] Information about an identity provider that is compliant with OpenID Connect (OIDC). Specify only when ``Type`` is ``authenticate-oidc``. Specifies information required using an identity provide (IdP) that is compliant with OpenID Connect (OIDC) to authenticate users.
        """
        return pulumi.get(self, "authenticate_oidc_config")

    @property
    @pulumi.getter(name="fixedResponseConfig")
    def fixed_response_config(self) -> Optional['outputs.FixedResponseConfigResponse']:
        """
        [Application Load Balancer] Information for creating an action that returns a custom HTTP response. Specify only when ``Type`` is ``fixed-response``. Specifies information required when returning a custom HTTP response.
        """
        return pulumi.get(self, "fixed_response_config")

    @property
    @pulumi.getter(name="forwardConfig")
    def forward_config(self) -> Optional['outputs.ForwardConfigResponse']:
        """
        Information for creating an action that distributes requests among one or more target groups. For Network Load Balancers, you can specify a single target group. Specify only when ``Type`` is ``forward``. If you specify both ``ForwardConfig`` and ``TargetGroupArn``, you can specify only one target group using ``ForwardConfig`` and it must be the same target group specified in ``TargetGroupArn``. Information for creating an action that distributes requests among one or more target groups. For Network Load Balancers, you can specify a single target group. Specify only when ``Type`` is ``forward``. If you specify both ``ForwardConfig`` and ``TargetGroupArn``, you can specify only one target group using ``ForwardConfig`` and it must be the same target group specified in ``TargetGroupArn``.
        """
        return pulumi.get(self, "forward_config")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        The order for the action. This value is required for rules with multiple actions. The action with the lowest value for order is performed first.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="redirectConfig")
    def redirect_config(self) -> Optional['outputs.RedirectConfigResponse']:
        """
        [Application Load Balancer] Information for creating a redirect action. Specify only when ``Type`` is ``redirect``. Information about a redirect action. A URI consists of the following components: protocol://hostname:port/path?query. You must modify at least one of the following components to avoid a redirect loop: protocol, hostname, port, or path. Any components that you do not modify retain their original values. You can reuse URI components using the following reserved keywords:  +  #{protocol}  +  #{host}  +  #{port}  +  #{path} (the leading '/' is removed)  +  #{query}   For example, you can change the path to '/new/#{path}', the hostname to 'example.#{host}', or the query to '#{query}&value=xyz'.
        """
        return pulumi.get(self, "redirect_config")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the target group. Specify only when ``Type`` is ``forward`` and you want to route to a single target group. To route to one or more target groups, use ``ForwardConfig`` instead.
        """
        return pulumi.get(self, "target_group_arn")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ActiveModelResponse(dict):
    """
    Definition of Active
    """
    def __init__(__self__, *,
                 active: Optional[bool] = None):
        """
        Definition of Active
        :param bool active: When true, StackSets performs non-conflicting operations concurrently and queues conflicting operations. After conflicting operations finish, StackSets starts queued operations in request order.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        When true, StackSets performs non-conflicting operations concurrently and queues conflicting operations. After conflicting operations finish, StackSets starts queued operations in request order.
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class AddOnResponse(dict):
    """
    Definition of AddOn
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addOnType":
            suggest = "add_on_type"
        elif key == "autoSnapshotAddOnRequest":
            suggest = "auto_snapshot_add_on_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddOnResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddOnResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddOnResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_on_type: Optional[str] = None,
                 auto_snapshot_add_on_request: Optional['outputs.AutoSnapshotAddOnResponse'] = None,
                 status: Optional[str] = None):
        """
        Definition of AddOn
        :param str add_on_type: The add-on type
        :param 'AutoSnapshotAddOnResponse' auto_snapshot_add_on_request: An object that represents additional parameters when enabling or modifying the automatic snapshot add-on
        :param str status: Status of the Addon
        """
        if add_on_type is not None:
            pulumi.set(__self__, "add_on_type", add_on_type)
        if auto_snapshot_add_on_request is not None:
            pulumi.set(__self__, "auto_snapshot_add_on_request", auto_snapshot_add_on_request)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="addOnType")
    def add_on_type(self) -> Optional[str]:
        """
        The add-on type
        """
        return pulumi.get(self, "add_on_type")

    @property
    @pulumi.getter(name="autoSnapshotAddOnRequest")
    def auto_snapshot_add_on_request(self) -> Optional['outputs.AutoSnapshotAddOnResponse']:
        """
        An object that represents additional parameters when enabling or modifying the automatic snapshot add-on
        """
        return pulumi.get(self, "auto_snapshot_add_on_request")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the Addon
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AdditionalAuthenticationProviderResponse(dict):
    """
    Definition of AdditionalAuthenticationProvider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationType":
            suggest = "authentication_type"
        elif key == "lambdaAuthorizerConfig":
            suggest = "lambda_authorizer_config"
        elif key == "openIDConnectConfig":
            suggest = "open_id_connect_config"
        elif key == "userPoolConfig":
            suggest = "user_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdditionalAuthenticationProviderResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdditionalAuthenticationProviderResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdditionalAuthenticationProviderResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_type: Optional['outputs.AuthenticationTypeEnumValueResponse'] = None,
                 lambda_authorizer_config: Optional['outputs.LambdaAuthorizerConfigResponse'] = None,
                 open_id_connect_config: Optional['outputs.OpenIDConnectConfigResponse'] = None,
                 user_pool_config: Optional['outputs.CognitoUserPoolConfigResponse'] = None):
        """
        Definition of AdditionalAuthenticationProvider
        :param 'AuthenticationTypeEnumValueResponse' authentication_type: <p>The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.</p>
        :param 'LambdaAuthorizerConfigResponse' lambda_authorizer_config: <p>Configuration for Lambda function authorization.</p>
        :param 'OpenIDConnectConfigResponse' open_id_connect_config: <p>The OIDC configuration.</p>
        :param 'CognitoUserPoolConfigResponse' user_pool_config: <p>The Amazon Cognito user pool configuration.</p>
        """
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if lambda_authorizer_config is not None:
            pulumi.set(__self__, "lambda_authorizer_config", lambda_authorizer_config)
        if open_id_connect_config is not None:
            pulumi.set(__self__, "open_id_connect_config", open_id_connect_config)
        if user_pool_config is not None:
            pulumi.set(__self__, "user_pool_config", user_pool_config)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional['outputs.AuthenticationTypeEnumValueResponse']:
        """
        <p>The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.</p>
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter(name="lambdaAuthorizerConfig")
    def lambda_authorizer_config(self) -> Optional['outputs.LambdaAuthorizerConfigResponse']:
        """
        <p>Configuration for Lambda function authorization.</p>
        """
        return pulumi.get(self, "lambda_authorizer_config")

    @property
    @pulumi.getter(name="openIDConnectConfig")
    def open_id_connect_config(self) -> Optional['outputs.OpenIDConnectConfigResponse']:
        """
        <p>The OIDC configuration.</p>
        """
        return pulumi.get(self, "open_id_connect_config")

    @property
    @pulumi.getter(name="userPoolConfig")
    def user_pool_config(self) -> Optional['outputs.CognitoUserPoolConfigResponse']:
        """
        <p>The Amazon Cognito user pool configuration.</p>
        """
        return pulumi.get(self, "user_pool_config")


@pulumi.output_type
class AddressResponse(dict):
    """
    Definition of Address
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressDefinition":
            suggest = "address_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_definition: Optional[str] = None):
        """
        Definition of Address
        :param str address_definition: Property addressDefinition
        """
        if address_definition is not None:
            pulumi.set(__self__, "address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> Optional[str]:
        """
        Property addressDefinition
        """
        return pulumi.get(self, "address_definition")


@pulumi.output_type
class AdvancedEventSelectorResponse(dict):
    """
    Definition of AdvancedEventSelector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSelectors":
            suggest = "field_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedEventSelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedEventSelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedEventSelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_selectors: Optional[Sequence['outputs.AdvancedFieldSelectorResponse']] = None,
                 name: Optional[str] = None):
        """
        Definition of AdvancedEventSelector
        :param Sequence['AdvancedFieldSelectorResponse'] field_selectors: Contains all selector statements in an advanced event selector.
        :param str name: An optional, descriptive name for an advanced event selector, such as 'Log data events for only two S3 buckets'.
        """
        if field_selectors is not None:
            pulumi.set(__self__, "field_selectors", field_selectors)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="fieldSelectors")
    def field_selectors(self) -> Optional[Sequence['outputs.AdvancedFieldSelectorResponse']]:
        """
        Contains all selector statements in an advanced event selector.
        """
        return pulumi.get(self, "field_selectors")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        An optional, descriptive name for an advanced event selector, such as 'Log data events for only two S3 buckets'.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AdvancedFieldSelectorResponse(dict):
    """
    Definition of AdvancedFieldSelector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endsWith":
            suggest = "ends_with"
        elif key == "notEndsWith":
            suggest = "not_ends_with"
        elif key == "notEquals":
            suggest = "not_equals"
        elif key == "notStartsWith":
            suggest = "not_starts_with"
        elif key == "startsWith":
            suggest = "starts_with"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedFieldSelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedFieldSelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedFieldSelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ends_with: Optional[Sequence[str]] = None,
                 equals: Optional[Sequence[str]] = None,
                 field: Optional[str] = None,
                 not_ends_with: Optional[Sequence[str]] = None,
                 not_equals: Optional[Sequence[str]] = None,
                 not_starts_with: Optional[Sequence[str]] = None,
                 starts_with: Optional[Sequence[str]] = None):
        """
        Definition of AdvancedFieldSelector
        :param Sequence[str] ends_with: An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        :param Sequence[str] equals: An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
        :param str field: A field in an event record on which to filter events to be logged. Supported fields include readOnly, eventCategory, eventSource (for management events), eventName, resources.type, and resources.ARN.
        :param Sequence[str] not_ends_with: An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        :param Sequence[str] not_equals: An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        :param Sequence[str] not_starts_with: An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        :param Sequence[str] starts_with: An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        if ends_with is not None:
            pulumi.set(__self__, "ends_with", ends_with)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if not_ends_with is not None:
            pulumi.set(__self__, "not_ends_with", not_ends_with)
        if not_equals is not None:
            pulumi.set(__self__, "not_equals", not_equals)
        if not_starts_with is not None:
            pulumi.set(__self__, "not_starts_with", not_starts_with)
        if starts_with is not None:
            pulumi.set(__self__, "starts_with", starts_with)

    @property
    @pulumi.getter(name="endsWith")
    def ends_with(self) -> Optional[Sequence[str]]:
        """
        An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "ends_with")

    @property
    @pulumi.getter
    def equals(self) -> Optional[Sequence[str]]:
        """
        An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
        """
        return pulumi.get(self, "equals")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        A field in an event record on which to filter events to be logged. Supported fields include readOnly, eventCategory, eventSource (for management events), eventName, resources.type, and resources.ARN.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter(name="notEndsWith")
    def not_ends_with(self) -> Optional[Sequence[str]]:
        """
        An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_ends_with")

    @property
    @pulumi.getter(name="notEquals")
    def not_equals(self) -> Optional[Sequence[str]]:
        """
        An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_equals")

    @property
    @pulumi.getter(name="notStartsWith")
    def not_starts_with(self) -> Optional[Sequence[str]]:
        """
        An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_starts_with")

    @property
    @pulumi.getter(name="startsWith")
    def starts_with(self) -> Optional[Sequence[str]]:
        """
        An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "starts_with")


@pulumi.output_type
class AdvancedSecurityOptionsResponse(dict):
    """
    Definition of AdvancedSecurityOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousAuthDisableDate":
            suggest = "anonymous_auth_disable_date"
        elif key == "anonymousAuthEnabled":
            suggest = "anonymous_auth_enabled"
        elif key == "internalUserDatabaseEnabled":
            suggest = "internal_user_database_enabled"
        elif key == "samlOptions":
            suggest = "saml_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedSecurityOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedSecurityOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedSecurityOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous_auth_disable_date: Optional[str] = None,
                 anonymous_auth_enabled: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 internal_user_database_enabled: Optional[bool] = None,
                 saml_options: Optional['outputs.SAMLOptionsOutputResponse'] = None):
        """
        Definition of AdvancedSecurityOptions
        :param str anonymous_auth_disable_date: <p>Date and time when the migration period will be disabled. Only necessary when <a href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing'>enabling fine-grained access control on an existing domain</a>.</p>
        :param bool anonymous_auth_enabled: <p>True if a 30-day migration period is enabled, during which administrators can create role mappings. Only necessary when <a href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing'>enabling fine-grained access control on an existing domain</a>.</p>
        :param bool enabled: <p>True if fine-grained access control is enabled.</p>
        :param bool internal_user_database_enabled: <p>True if the internal user database is enabled.</p>
        :param 'SAMLOptionsOutputResponse' saml_options: <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
        """
        if anonymous_auth_disable_date is not None:
            pulumi.set(__self__, "anonymous_auth_disable_date", anonymous_auth_disable_date)
        if anonymous_auth_enabled is not None:
            pulumi.set(__self__, "anonymous_auth_enabled", anonymous_auth_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if internal_user_database_enabled is not None:
            pulumi.set(__self__, "internal_user_database_enabled", internal_user_database_enabled)
        if saml_options is not None:
            pulumi.set(__self__, "saml_options", saml_options)

    @property
    @pulumi.getter(name="anonymousAuthDisableDate")
    def anonymous_auth_disable_date(self) -> Optional[str]:
        """
        <p>Date and time when the migration period will be disabled. Only necessary when <a href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing'>enabling fine-grained access control on an existing domain</a>.</p>
        """
        return pulumi.get(self, "anonymous_auth_disable_date")

    @property
    @pulumi.getter(name="anonymousAuthEnabled")
    def anonymous_auth_enabled(self) -> Optional[bool]:
        """
        <p>True if a 30-day migration period is enabled, during which administrators can create role mappings. Only necessary when <a href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing'>enabling fine-grained access control on an existing domain</a>.</p>
        """
        return pulumi.get(self, "anonymous_auth_enabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>True if fine-grained access control is enabled.</p>
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="internalUserDatabaseEnabled")
    def internal_user_database_enabled(self) -> Optional[bool]:
        """
        <p>True if the internal user database is enabled.</p>
        """
        return pulumi.get(self, "internal_user_database_enabled")

    @property
    @pulumi.getter(name="samlOptions")
    def saml_options(self) -> Optional['outputs.SAMLOptionsOutputResponse']:
        """
        <p>Container for information about the SAML configuration for OpenSearch Dashboards.</p>
        """
        return pulumi.get(self, "saml_options")


@pulumi.output_type
class AliasTargetResponse(dict):
    """
    Definition of AliasTarget
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "evaluateTargetHealth":
            suggest = "evaluate_target_health"
        elif key == "hostedZoneId":
            suggest = "hosted_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AliasTargetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AliasTargetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AliasTargetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[str] = None,
                 evaluate_target_health: Optional[bool] = None,
                 hosted_zone_id: Optional[str] = None):
        """
        Definition of AliasTarget
        :param str dns_name: <p> <i>Alias resource record sets only:</i> The value that you specify depends on where you want to route queries:</p> <dl> <dt>Amazon API Gateway custom regional APIs and edge-optimized APIs</dt> <dd> <p>Specify the applicable domain name for your API. You can get the applicable value using the CLI command <a href='https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-domain-names.html'>get-domain-names</a>:</p> <ul> <li> <p>For regional APIs, specify the value of <code>regionalDomainName</code>.</p> </li> <li> <p>For edge-optimized APIs, specify the value of <code>distributionDomainName</code>. This is the name of the associated CloudFront distribution, such as <code>da1b2c3d4e5.cloudfront.net</code>.</p> </li> </ul> <note> <p>The name of the record that you're creating must match a custom domain name for your API, such as <code>api.example.com</code>.</p> </note> </dd> <dt>Amazon Virtual Private Cloud interface VPC endpoint</dt> <dd> <p>Enter the API endpoint for the interface endpoint, such as <code>vpce-123456789abcdef01-example-us-east-1a.elasticloadbalancing.us-east-1.vpce.amazonaws.com</code>. For edge-optimized APIs, this is the domain name for the corresponding CloudFront distribution. You can get the value of <code>DnsName</code> using the CLI command <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-vpc-endpoints.html'>describe-vpc-endpoints</a>.</p> </dd> <dt>CloudFront distribution</dt> <dd> <p>Specify the domain name that CloudFront assigned when you created your distribution.</p> <p>Your CloudFront distribution must include an alternate domain name that matches the name of the resource record set. For example, if the name of the resource record set is <i>acme.example.com</i>, your CloudFront distribution must include <i>acme.example.com</i> as one of the alternate domain names. For more information, see <a href='https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html'>Using Alternate Domain Names (CNAMEs)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p> <p>You can't create a resource record set in a private hosted zone to route traffic to a CloudFront distribution.</p> <note> <p>For failover alias records, you can't specify a CloudFront distribution for both the primary and secondary records. A distribution must include an alternate domain name that matches the name of the record. However, the primary and secondary records have the same name, and you can't include the same alternate domain name in more than one distribution. </p> </note> </dd> <dt>Elastic Beanstalk environment</dt> <dd> <p>If the domain name for your Elastic Beanstalk environment includes the region that you deployed the environment in, you can create an alias record that routes traffic to the environment. For example, the domain name <code>my-environment.<i>us-west-2</i>.elasticbeanstalk.com</code> is a regionalized domain name. </p> <important> <p>For environments that were created before early 2016, the domain name doesn't include the region. To route traffic to these environments, you must create a CNAME record instead of an alias record. Note that you can't create a CNAME record for the root domain name. For example, if your domain name is example.com, you can create a record that routes traffic for acme.example.com to your Elastic Beanstalk environment, but you can't create a record that routes traffic for example.com to your Elastic Beanstalk environment.</p> </important> <p>For Elastic Beanstalk environments that have regionalized subdomains, specify the <code>CNAME</code> attribute for the environment. You can use the following methods to get the value of the CNAME attribute:</p> <ul> <li> <p> <i>Amazon Web Services Management Console</i>: For information about how to get the value by using the console, see <a href='https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/customdomains.html'>Using Custom Domains with Elastic Beanstalk</a> in the <i>Elastic Beanstalk Developer Guide</i>.</p> </li> <li> <p> <i>Elastic Beanstalk API</i>: Use the <code>DescribeEnvironments</code> action to get the value of the <code>CNAME</code> attribute. For more information, see <a href='https://docs.aws.amazon.com/elasticbeanstalk/latest/api/API_DescribeEnvironments.html'>DescribeEnvironments</a> in the <i>Elastic Beanstalk API Reference</i>.</p> </li> <li> <p> <i>CLI</i>: Use the <code>describe-environments</code> command to get the value of the <code>CNAME</code> attribute. For more information, see <a href='https://docs.aws.amazon.com/cli/latest/reference/elasticbeanstalk/describe-environments.html'>describe-environments</a> in the <i>CLI Command Reference</i>.</p> </li> </ul> </dd> <dt>ELB load balancer</dt> <dd> <p>Specify the DNS name that is associated with the load balancer. Get the DNS name by using the Amazon Web Services Management Console, the ELB API, or the CLI. </p> <ul> <li> <p> <b>Amazon Web Services Management Console</b>: Go to the EC2 page, choose <b>Load Balancers</b> in the navigation pane, choose the load balancer, choose the <b>Description</b> tab, and get the value of the <b>DNS name</b> field. </p> <p>If you're routing traffic to a Classic Load Balancer, get the value that begins with <b>dualstack</b>. If you're routing traffic to another type of load balancer, get the value that applies to the record type, A or AAAA.</p> </li> <li> <p> <b>Elastic Load Balancing API</b>: Use <code>DescribeLoadBalancers</code> to get the value of <code>DNSName</code>. For more information, see the applicable guide:</p> <ul> <li> <p>Classic Load Balancers: <a href='https://docs.aws.amazon.com/elasticloadbalancing/2012-06-01/APIReference/API_DescribeLoadBalancers.html'>DescribeLoadBalancers</a> </p> </li> <li> <p>Application and Network Load Balancers: <a href='https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html'>DescribeLoadBalancers</a> </p> </li> </ul> </li> <li> <p> <b>CLI</b>: Use <code>describe-load-balancers</code> to get the value of <code>DNSName</code>. For more information, see the applicable guide:</p> <ul> <li> <p>Classic Load Balancers: <a href='http://docs.aws.amazon.com/cli/latest/reference/elb/describe-load-balancers.html'>describe-load-balancers</a> </p> </li> <li> <p>Application and Network Load Balancers: <a href='http://docs.aws.amazon.com/cli/latest/reference/elbv2/describe-load-balancers.html'>describe-load-balancers</a> </p> </li> </ul> </li> </ul> </dd> <dt>Global Accelerator accelerator</dt> <dd> <p>Specify the DNS name for your accelerator:</p> <ul> <li> <p> <b>Global Accelerator API:</b> To get the DNS name, use <a href='https://docs.aws.amazon.com/global-accelerator/latest/api/API_DescribeAccelerator.html'>DescribeAccelerator</a>.</p> </li> <li> <p> <b>CLI:</b> To get the DNS name, use <a href='https://docs.aws.amazon.com/cli/latest/reference/globalaccelerator/describe-accelerator.html'>describe-accelerator</a>.</p> </li> </ul> </dd> <dt>Amazon S3 bucket that is configured as a static website</dt> <dd> <p>Specify the domain name of the Amazon S3 website endpoint that you created the bucket in, for example, <code>s3-website.us-east-2.amazonaws.com</code>. For more information about valid values, see the table <a href='https://docs.aws.amazon.com/general/latest/gr/s3.html#s3_website_region_endpoints'>Amazon S3 Website Endpoints</a> in the <i>Amazon Web Services General Reference</i>. For more information about using S3 buckets for websites, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/getting-started.html'>Getting Started with Amazon Route 53</a> in the <i>Amazon Route 53 Developer Guide.</i> </p> </dd> <dt>Another Route 53 resource record set</dt> <dd> <p>Specify the value of the <code>Name</code> element for a resource record set in the current hosted zone.</p> <note> <p>If you're creating an alias record that has the same name as the hosted zone (known as the zone apex), you can't specify the domain name for a record for which the value of <code>Type</code> is <code>CNAME</code>. This is because the alias record must have the same type as the record that you're routing traffic to, and creating a CNAME record for the zone apex isn't supported even for an alias record.</p> </note> </dd> </dl>
        :param bool evaluate_target_health: <p> <i>Applies only to alias, failover alias, geolocation alias, latency alias, and weighted alias resource record sets:</i> When <code>EvaluateTargetHealth</code> is <code>true</code>, an alias resource record set inherits the health of the referenced Amazon Web Services resource, such as an ELB load balancer or another resource record set in the hosted zone.</p> <p>Note the following:</p> <dl> <dt>CloudFront distributions</dt> <dd> <p>You can't set <code>EvaluateTargetHealth</code> to <code>true</code> when the alias target is a CloudFront distribution.</p> </dd> <dt>Elastic Beanstalk environments that have regionalized subdomains</dt> <dd> <p>If you specify an Elastic Beanstalk environment in <code>DNSName</code> and the environment contains an ELB load balancer, Elastic Load Balancing routes queries only to the healthy Amazon EC2 instances that are registered with the load balancer. (An environment automatically contains an ELB load balancer if it includes more than one Amazon EC2 instance.) If you set <code>EvaluateTargetHealth</code> to <code>true</code> and either no Amazon EC2 instances are healthy or the load balancer itself is unhealthy, Route 53 routes queries to other available resources that are healthy, if any. </p> <p>If the environment contains a single Amazon EC2 instance, there are no special requirements.</p> </dd> <dt>ELB load balancers</dt> <dd> <p>Health checking behavior depends on the type of load balancer:</p> <ul> <li> <p> <b>Classic Load Balancers</b>: If you specify an ELB Classic Load Balancer in <code>DNSName</code>, Elastic Load Balancing routes queries only to the healthy Amazon EC2 instances that are registered with the load balancer. If you set <code>EvaluateTargetHealth</code> to <code>true</code> and either no EC2 instances are healthy or the load balancer itself is unhealthy, Route 53 routes queries to other resources.</p> </li> <li> <p> <b>Application and Network Load Balancers</b>: If you specify an ELB Application or Network Load Balancer and you set <code>EvaluateTargetHealth</code> to <code>true</code>, Route 53 routes queries to the load balancer based on the health of the target groups that are associated with the load balancer:</p> <ul> <li> <p>For an Application or Network Load Balancer to be considered healthy, every target group that contains targets must contain at least one healthy target. If any target group contains only unhealthy targets, the load balancer is considered unhealthy, and Route 53 routes queries to other resources.</p> </li> <li> <p>A target group that has no registered targets is considered unhealthy.</p> </li> </ul> </li> </ul> <note> <p>When you create a load balancer, you configure settings for Elastic Load Balancing health checks; they're not Route 53 health checks, but they perform a similar function. Do not create Route 53 health checks for the EC2 instances that you register with an ELB load balancer. </p> </note> </dd> <dt>S3 buckets</dt> <dd> <p>There are no special requirements for setting <code>EvaluateTargetHealth</code> to <code>true</code> when the alias target is an S3 bucket.</p> </dd> <dt>Other records in the same hosted zone</dt> <dd> <p>If the Amazon Web Services resource that you specify in <code>DNSName</code> is a record or a group of records (for example, a group of weighted records) but is not another alias record, we recommend that you associate a health check with all of the records in the alias target. For more information, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-complex-configs.html#dns-failover-complex-configs-hc-omitting'>What Happens When You Omit Health Checks?</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> </dd> </dl> <p>For more information and examples, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html'>Amazon Route 53 Health Checks and DNS Failover</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
        :param str hosted_zone_id: <p> <i>Alias resource records sets only</i>: The value used depends on where you want to route traffic:</p> <dl> <dt>Amazon API Gateway custom regional APIs and edge-optimized APIs</dt> <dd> <p>Specify the hosted zone ID for your API. You can get the applicable value using the CLI command <a href='https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-domain-names.html'>get-domain-names</a>:</p> <ul> <li> <p>For regional APIs, specify the value of <code>regionalHostedZoneId</code>.</p> </li> <li> <p>For edge-optimized APIs, specify the value of <code>distributionHostedZoneId</code>.</p> </li> </ul> </dd> <dt>Amazon Virtual Private Cloud interface VPC endpoint</dt> <dd> <p>Specify the hosted zone ID for your interface endpoint. You can get the value of <code>HostedZoneId</code> using the CLI command <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-vpc-endpoints.html'>describe-vpc-endpoints</a>.</p> </dd> <dt>CloudFront distribution</dt> <dd> <p>Specify <code>Z2FDTNDATAQYW2</code>.</p> <note> <p>Alias resource record sets for CloudFront can't be created in a private zone.</p> </note> </dd> <dt>Elastic Beanstalk environment</dt> <dd> <p>Specify the hosted zone ID for the region that you created the environment in. The environment must have a regionalized subdomain. For a list of regions and the corresponding hosted zone IDs, see <a href='https://docs.aws.amazon.com/general/latest/gr/elasticbeanstalk.html'>Elastic Beanstalk endpoints and quotas</a> in the <i>Amazon Web Services General Reference</i>.</p> </dd> <dt>ELB load balancer</dt> <dd> <p>Specify the value of the hosted zone ID for the load balancer. Use the following methods to get the hosted zone ID:</p> <ul> <li> <p> <a href='https://docs.aws.amazon.com/general/latest/gr/elb.html'>Elastic Load Balancing endpoints and quotas</a> topic in the <i>Amazon Web Services General Reference</i>: Use the value that corresponds with the region that you created your load balancer in. Note that there are separate columns for Application and Classic Load Balancers and for Network Load Balancers.</p> </li> <li> <p> <b>Amazon Web Services Management Console</b>: Go to the Amazon EC2 page, choose <b>Load Balancers</b> in the navigation pane, select the load balancer, and get the value of the <b>Hosted zone</b> field on the <b>Description</b> tab.</p> </li> <li> <p> <b>Elastic Load Balancing API</b>: Use <code>DescribeLoadBalancers</code> to get the applicable value. For more information, see the applicable guide:</p> <ul> <li> <p>Classic Load Balancers: Use <a href='https://docs.aws.amazon.com/elasticloadbalancing/2012-06-01/APIReference/API_DescribeLoadBalancers.html'>DescribeLoadBalancers</a> to get the value of <code>CanonicalHostedZoneNameId</code>.</p> </li> <li> <p>Application and Network Load Balancers: Use <a href='https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html'>DescribeLoadBalancers</a> to get the value of <code>CanonicalHostedZoneId</code>.</p> </li> </ul> </li> <li> <p> <b>CLI</b>: Use <code>describe-load-balancers</code> to get the applicable value. For more information, see the applicable guide:</p> <ul> <li> <p>Classic Load Balancers: Use <a href='http://docs.aws.amazon.com/cli/latest/reference/elb/describe-load-balancers.html'>describe-load-balancers</a> to get the value of <code>CanonicalHostedZoneNameId</code>.</p> </li> <li> <p>Application and Network Load Balancers: Use <a href='http://docs.aws.amazon.com/cli/latest/reference/elbv2/describe-load-balancers.html'>describe-load-balancers</a> to get the value of <code>CanonicalHostedZoneId</code>.</p> </li> </ul> </li> </ul> </dd> <dt>Global Accelerator accelerator</dt> <dd> <p>Specify <code>Z2BJ6XQ5FK7U4H</code>.</p> </dd> <dt>An Amazon S3 bucket configured as a static website</dt> <dd> <p>Specify the hosted zone ID for the region that you created the bucket in. For more information about valid values, see the table <a href='https://docs.aws.amazon.com/general/latest/gr/s3.html#s3_website_region_endpoints'>Amazon S3 Website Endpoints</a> in the <i>Amazon Web Services General Reference</i>.</p> </dd> <dt>Another Route 53 resource record set in your hosted zone</dt> <dd> <p>Specify the hosted zone ID of your hosted zone. (An alias resource record set can't reference a resource record set in a different hosted zone.)</p> </dd> </dl>
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if evaluate_target_health is not None:
            pulumi.set(__self__, "evaluate_target_health", evaluate_target_health)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[str]:
        """
        <p> <i>Alias resource record sets only:</i> The value that you specify depends on where you want to route queries:</p> <dl> <dt>Amazon API Gateway custom regional APIs and edge-optimized APIs</dt> <dd> <p>Specify the applicable domain name for your API. You can get the applicable value using the CLI command <a href='https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-domain-names.html'>get-domain-names</a>:</p> <ul> <li> <p>For regional APIs, specify the value of <code>regionalDomainName</code>.</p> </li> <li> <p>For edge-optimized APIs, specify the value of <code>distributionDomainName</code>. This is the name of the associated CloudFront distribution, such as <code>da1b2c3d4e5.cloudfront.net</code>.</p> </li> </ul> <note> <p>The name of the record that you're creating must match a custom domain name for your API, such as <code>api.example.com</code>.</p> </note> </dd> <dt>Amazon Virtual Private Cloud interface VPC endpoint</dt> <dd> <p>Enter the API endpoint for the interface endpoint, such as <code>vpce-123456789abcdef01-example-us-east-1a.elasticloadbalancing.us-east-1.vpce.amazonaws.com</code>. For edge-optimized APIs, this is the domain name for the corresponding CloudFront distribution. You can get the value of <code>DnsName</code> using the CLI command <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-vpc-endpoints.html'>describe-vpc-endpoints</a>.</p> </dd> <dt>CloudFront distribution</dt> <dd> <p>Specify the domain name that CloudFront assigned when you created your distribution.</p> <p>Your CloudFront distribution must include an alternate domain name that matches the name of the resource record set. For example, if the name of the resource record set is <i>acme.example.com</i>, your CloudFront distribution must include <i>acme.example.com</i> as one of the alternate domain names. For more information, see <a href='https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html'>Using Alternate Domain Names (CNAMEs)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p> <p>You can't create a resource record set in a private hosted zone to route traffic to a CloudFront distribution.</p> <note> <p>For failover alias records, you can't specify a CloudFront distribution for both the primary and secondary records. A distribution must include an alternate domain name that matches the name of the record. However, the primary and secondary records have the same name, and you can't include the same alternate domain name in more than one distribution. </p> </note> </dd> <dt>Elastic Beanstalk environment</dt> <dd> <p>If the domain name for your Elastic Beanstalk environment includes the region that you deployed the environment in, you can create an alias record that routes traffic to the environment. For example, the domain name <code>my-environment.<i>us-west-2</i>.elasticbeanstalk.com</code> is a regionalized domain name. </p> <important> <p>For environments that were created before early 2016, the domain name doesn't include the region. To route traffic to these environments, you must create a CNAME record instead of an alias record. Note that you can't create a CNAME record for the root domain name. For example, if your domain name is example.com, you can create a record that routes traffic for acme.example.com to your Elastic Beanstalk environment, but you can't create a record that routes traffic for example.com to your Elastic Beanstalk environment.</p> </important> <p>For Elastic Beanstalk environments that have regionalized subdomains, specify the <code>CNAME</code> attribute for the environment. You can use the following methods to get the value of the CNAME attribute:</p> <ul> <li> <p> <i>Amazon Web Services Management Console</i>: For information about how to get the value by using the console, see <a href='https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/customdomains.html'>Using Custom Domains with Elastic Beanstalk</a> in the <i>Elastic Beanstalk Developer Guide</i>.</p> </li> <li> <p> <i>Elastic Beanstalk API</i>: Use the <code>DescribeEnvironments</code> action to get the value of the <code>CNAME</code> attribute. For more information, see <a href='https://docs.aws.amazon.com/elasticbeanstalk/latest/api/API_DescribeEnvironments.html'>DescribeEnvironments</a> in the <i>Elastic Beanstalk API Reference</i>.</p> </li> <li> <p> <i>CLI</i>: Use the <code>describe-environments</code> command to get the value of the <code>CNAME</code> attribute. For more information, see <a href='https://docs.aws.amazon.com/cli/latest/reference/elasticbeanstalk/describe-environments.html'>describe-environments</a> in the <i>CLI Command Reference</i>.</p> </li> </ul> </dd> <dt>ELB load balancer</dt> <dd> <p>Specify the DNS name that is associated with the load balancer. Get the DNS name by using the Amazon Web Services Management Console, the ELB API, or the CLI. </p> <ul> <li> <p> <b>Amazon Web Services Management Console</b>: Go to the EC2 page, choose <b>Load Balancers</b> in the navigation pane, choose the load balancer, choose the <b>Description</b> tab, and get the value of the <b>DNS name</b> field. </p> <p>If you're routing traffic to a Classic Load Balancer, get the value that begins with <b>dualstack</b>. If you're routing traffic to another type of load balancer, get the value that applies to the record type, A or AAAA.</p> </li> <li> <p> <b>Elastic Load Balancing API</b>: Use <code>DescribeLoadBalancers</code> to get the value of <code>DNSName</code>. For more information, see the applicable guide:</p> <ul> <li> <p>Classic Load Balancers: <a href='https://docs.aws.amazon.com/elasticloadbalancing/2012-06-01/APIReference/API_DescribeLoadBalancers.html'>DescribeLoadBalancers</a> </p> </li> <li> <p>Application and Network Load Balancers: <a href='https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html'>DescribeLoadBalancers</a> </p> </li> </ul> </li> <li> <p> <b>CLI</b>: Use <code>describe-load-balancers</code> to get the value of <code>DNSName</code>. For more information, see the applicable guide:</p> <ul> <li> <p>Classic Load Balancers: <a href='http://docs.aws.amazon.com/cli/latest/reference/elb/describe-load-balancers.html'>describe-load-balancers</a> </p> </li> <li> <p>Application and Network Load Balancers: <a href='http://docs.aws.amazon.com/cli/latest/reference/elbv2/describe-load-balancers.html'>describe-load-balancers</a> </p> </li> </ul> </li> </ul> </dd> <dt>Global Accelerator accelerator</dt> <dd> <p>Specify the DNS name for your accelerator:</p> <ul> <li> <p> <b>Global Accelerator API:</b> To get the DNS name, use <a href='https://docs.aws.amazon.com/global-accelerator/latest/api/API_DescribeAccelerator.html'>DescribeAccelerator</a>.</p> </li> <li> <p> <b>CLI:</b> To get the DNS name, use <a href='https://docs.aws.amazon.com/cli/latest/reference/globalaccelerator/describe-accelerator.html'>describe-accelerator</a>.</p> </li> </ul> </dd> <dt>Amazon S3 bucket that is configured as a static website</dt> <dd> <p>Specify the domain name of the Amazon S3 website endpoint that you created the bucket in, for example, <code>s3-website.us-east-2.amazonaws.com</code>. For more information about valid values, see the table <a href='https://docs.aws.amazon.com/general/latest/gr/s3.html#s3_website_region_endpoints'>Amazon S3 Website Endpoints</a> in the <i>Amazon Web Services General Reference</i>. For more information about using S3 buckets for websites, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/getting-started.html'>Getting Started with Amazon Route 53</a> in the <i>Amazon Route 53 Developer Guide.</i> </p> </dd> <dt>Another Route 53 resource record set</dt> <dd> <p>Specify the value of the <code>Name</code> element for a resource record set in the current hosted zone.</p> <note> <p>If you're creating an alias record that has the same name as the hosted zone (known as the zone apex), you can't specify the domain name for a record for which the value of <code>Type</code> is <code>CNAME</code>. This is because the alias record must have the same type as the record that you're routing traffic to, and creating a CNAME record for the zone apex isn't supported even for an alias record.</p> </note> </dd> </dl>
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[bool]:
        """
        <p> <i>Applies only to alias, failover alias, geolocation alias, latency alias, and weighted alias resource record sets:</i> When <code>EvaluateTargetHealth</code> is <code>true</code>, an alias resource record set inherits the health of the referenced Amazon Web Services resource, such as an ELB load balancer or another resource record set in the hosted zone.</p> <p>Note the following:</p> <dl> <dt>CloudFront distributions</dt> <dd> <p>You can't set <code>EvaluateTargetHealth</code> to <code>true</code> when the alias target is a CloudFront distribution.</p> </dd> <dt>Elastic Beanstalk environments that have regionalized subdomains</dt> <dd> <p>If you specify an Elastic Beanstalk environment in <code>DNSName</code> and the environment contains an ELB load balancer, Elastic Load Balancing routes queries only to the healthy Amazon EC2 instances that are registered with the load balancer. (An environment automatically contains an ELB load balancer if it includes more than one Amazon EC2 instance.) If you set <code>EvaluateTargetHealth</code> to <code>true</code> and either no Amazon EC2 instances are healthy or the load balancer itself is unhealthy, Route 53 routes queries to other available resources that are healthy, if any. </p> <p>If the environment contains a single Amazon EC2 instance, there are no special requirements.</p> </dd> <dt>ELB load balancers</dt> <dd> <p>Health checking behavior depends on the type of load balancer:</p> <ul> <li> <p> <b>Classic Load Balancers</b>: If you specify an ELB Classic Load Balancer in <code>DNSName</code>, Elastic Load Balancing routes queries only to the healthy Amazon EC2 instances that are registered with the load balancer. If you set <code>EvaluateTargetHealth</code> to <code>true</code> and either no EC2 instances are healthy or the load balancer itself is unhealthy, Route 53 routes queries to other resources.</p> </li> <li> <p> <b>Application and Network Load Balancers</b>: If you specify an ELB Application or Network Load Balancer and you set <code>EvaluateTargetHealth</code> to <code>true</code>, Route 53 routes queries to the load balancer based on the health of the target groups that are associated with the load balancer:</p> <ul> <li> <p>For an Application or Network Load Balancer to be considered healthy, every target group that contains targets must contain at least one healthy target. If any target group contains only unhealthy targets, the load balancer is considered unhealthy, and Route 53 routes queries to other resources.</p> </li> <li> <p>A target group that has no registered targets is considered unhealthy.</p> </li> </ul> </li> </ul> <note> <p>When you create a load balancer, you configure settings for Elastic Load Balancing health checks; they're not Route 53 health checks, but they perform a similar function. Do not create Route 53 health checks for the EC2 instances that you register with an ELB load balancer. </p> </note> </dd> <dt>S3 buckets</dt> <dd> <p>There are no special requirements for setting <code>EvaluateTargetHealth</code> to <code>true</code> when the alias target is an S3 bucket.</p> </dd> <dt>Other records in the same hosted zone</dt> <dd> <p>If the Amazon Web Services resource that you specify in <code>DNSName</code> is a record or a group of records (for example, a group of weighted records) but is not another alias record, we recommend that you associate a health check with all of the records in the alias target. For more information, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-complex-configs.html#dns-failover-complex-configs-hc-omitting'>What Happens When You Omit Health Checks?</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> </dd> </dl> <p>For more information and examples, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html'>Amazon Route 53 Health Checks and DNS Failover</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
        """
        return pulumi.get(self, "evaluate_target_health")

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[str]:
        """
        <p> <i>Alias resource records sets only</i>: The value used depends on where you want to route traffic:</p> <dl> <dt>Amazon API Gateway custom regional APIs and edge-optimized APIs</dt> <dd> <p>Specify the hosted zone ID for your API. You can get the applicable value using the CLI command <a href='https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-domain-names.html'>get-domain-names</a>:</p> <ul> <li> <p>For regional APIs, specify the value of <code>regionalHostedZoneId</code>.</p> </li> <li> <p>For edge-optimized APIs, specify the value of <code>distributionHostedZoneId</code>.</p> </li> </ul> </dd> <dt>Amazon Virtual Private Cloud interface VPC endpoint</dt> <dd> <p>Specify the hosted zone ID for your interface endpoint. You can get the value of <code>HostedZoneId</code> using the CLI command <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-vpc-endpoints.html'>describe-vpc-endpoints</a>.</p> </dd> <dt>CloudFront distribution</dt> <dd> <p>Specify <code>Z2FDTNDATAQYW2</code>.</p> <note> <p>Alias resource record sets for CloudFront can't be created in a private zone.</p> </note> </dd> <dt>Elastic Beanstalk environment</dt> <dd> <p>Specify the hosted zone ID for the region that you created the environment in. The environment must have a regionalized subdomain. For a list of regions and the corresponding hosted zone IDs, see <a href='https://docs.aws.amazon.com/general/latest/gr/elasticbeanstalk.html'>Elastic Beanstalk endpoints and quotas</a> in the <i>Amazon Web Services General Reference</i>.</p> </dd> <dt>ELB load balancer</dt> <dd> <p>Specify the value of the hosted zone ID for the load balancer. Use the following methods to get the hosted zone ID:</p> <ul> <li> <p> <a href='https://docs.aws.amazon.com/general/latest/gr/elb.html'>Elastic Load Balancing endpoints and quotas</a> topic in the <i>Amazon Web Services General Reference</i>: Use the value that corresponds with the region that you created your load balancer in. Note that there are separate columns for Application and Classic Load Balancers and for Network Load Balancers.</p> </li> <li> <p> <b>Amazon Web Services Management Console</b>: Go to the Amazon EC2 page, choose <b>Load Balancers</b> in the navigation pane, select the load balancer, and get the value of the <b>Hosted zone</b> field on the <b>Description</b> tab.</p> </li> <li> <p> <b>Elastic Load Balancing API</b>: Use <code>DescribeLoadBalancers</code> to get the applicable value. For more information, see the applicable guide:</p> <ul> <li> <p>Classic Load Balancers: Use <a href='https://docs.aws.amazon.com/elasticloadbalancing/2012-06-01/APIReference/API_DescribeLoadBalancers.html'>DescribeLoadBalancers</a> to get the value of <code>CanonicalHostedZoneNameId</code>.</p> </li> <li> <p>Application and Network Load Balancers: Use <a href='https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html'>DescribeLoadBalancers</a> to get the value of <code>CanonicalHostedZoneId</code>.</p> </li> </ul> </li> <li> <p> <b>CLI</b>: Use <code>describe-load-balancers</code> to get the applicable value. For more information, see the applicable guide:</p> <ul> <li> <p>Classic Load Balancers: Use <a href='http://docs.aws.amazon.com/cli/latest/reference/elb/describe-load-balancers.html'>describe-load-balancers</a> to get the value of <code>CanonicalHostedZoneNameId</code>.</p> </li> <li> <p>Application and Network Load Balancers: Use <a href='http://docs.aws.amazon.com/cli/latest/reference/elbv2/describe-load-balancers.html'>describe-load-balancers</a> to get the value of <code>CanonicalHostedZoneId</code>.</p> </li> </ul> </li> </ul> </dd> <dt>Global Accelerator accelerator</dt> <dd> <p>Specify <code>Z2BJ6XQ5FK7U4H</code>.</p> </dd> <dt>An Amazon S3 bucket configured as a static website</dt> <dd> <p>Specify the hosted zone ID for the region that you created the bucket in. For more information about valid values, see the table <a href='https://docs.aws.amazon.com/general/latest/gr/s3.html#s3_website_region_endpoints'>Amazon S3 Website Endpoints</a> in the <i>Amazon Web Services General Reference</i>.</p> </dd> <dt>Another Route 53 resource record set in your hosted zone</dt> <dd> <p>Specify the hosted zone ID of your hosted zone. (An alias resource record set can't reference a resource record set in a different hosted zone.)</p> </dd> </dl>
        """
        return pulumi.get(self, "hosted_zone_id")


@pulumi.output_type
class AmdSevSnpSpecificationEnumValueResponse(dict):
    """
    Definition of AmdSevSnpSpecificationEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of AmdSevSnpSpecificationEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AnalyticsConfigurationResponse(dict):
    """
    Definition of AnalyticsConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClassAnalysis":
            suggest = "storage_class_analysis"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalyticsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalyticsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalyticsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 prefix: Optional[str] = None,
                 storage_class_analysis: Optional['outputs.StorageClassAnalysisResponse'] = None,
                 tag_filters: Optional[Sequence['outputs.TagFilterResponse']] = None):
        """
        Definition of AnalyticsConfiguration
        :param str id: The ID that identifies the analytics configuration.
        :param str prefix: The prefix that an object must have to be included in the analytics results.
        :param 'StorageClassAnalysisResponse' storage_class_analysis: Contains data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes. Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
        :param Sequence['TagFilterResponse'] tag_filters: The tags to use when evaluating an analytics filter. The analytics only includes objects that meet the filter's criteria. If no filter is specified, all of the contents of the bucket are included in the analysis.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if storage_class_analysis is not None:
            pulumi.set(__self__, "storage_class_analysis", storage_class_analysis)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID that identifies the analytics configuration.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The prefix that an object must have to be included in the analytics results.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="storageClassAnalysis")
    def storage_class_analysis(self) -> Optional['outputs.StorageClassAnalysisResponse']:
        """
        Contains data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes. Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
        """
        return pulumi.get(self, "storage_class_analysis")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.TagFilterResponse']]:
        """
        The tags to use when evaluating an analytics filter. The analytics only includes objects that meet the filter's criteria. If no filter is specified, all of the contents of the bucket are included in the analysis.
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class AnomalyDetectionResponse(dict):
    """
    Definition of AnomalyDetection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mitigationInEffect":
            suggest = "mitigation_in_effect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalyDetectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalyDetectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalyDetectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mitigation_in_effect: Optional['outputs.MitigationInEffectEnumEnumValueResponse'] = None,
                 result: Optional['outputs.AnomalyResultEnumEnumValueResponse'] = None):
        """
        Definition of AnomalyDetection
        :param 'MitigationInEffectEnumEnumValueResponse' mitigation_in_effect: <p>Indicates whether anomaly mitigation is in progress.</p>
        :param 'AnomalyResultEnumEnumValueResponse' result: <p>The latest anomaly detection result.</p>
        """
        if mitigation_in_effect is not None:
            pulumi.set(__self__, "mitigation_in_effect", mitigation_in_effect)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @property
    @pulumi.getter(name="mitigationInEffect")
    def mitigation_in_effect(self) -> Optional['outputs.MitigationInEffectEnumEnumValueResponse']:
        """
        <p>Indicates whether anomaly mitigation is in progress.</p>
        """
        return pulumi.get(self, "mitigation_in_effect")

    @property
    @pulumi.getter
    def result(self) -> Optional['outputs.AnomalyResultEnumEnumValueResponse']:
        """
        <p>The latest anomaly detection result.</p>
        """
        return pulumi.get(self, "result")


@pulumi.output_type
class AnomalyResultEnumEnumValueResponse(dict):
    """
    Definition of AnomalyResultEnumEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of AnomalyResultEnumEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ApiGatewayRestApiPropertiesResponse(dict):
    """
    Definition of ApiGatewayRestApi
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiGatewayRestApiPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiGatewayRestApiPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiGatewayRestApiPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsApiGatewayRestApiPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ApiGatewayRestApi
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsApiGatewayRestApiPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsApiGatewayRestApiPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ApiGatewayStagePropertiesResponse(dict):
    """
    Definition of ApiGatewayStage
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiGatewayStagePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiGatewayStagePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiGatewayStagePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsApiGatewayStagePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ApiGatewayStage
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsApiGatewayStagePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsApiGatewayStagePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class AppSyncGraphqlApiPropertiesResponse(dict):
    """
    Definition of AppSyncGraphqlApi
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSyncGraphqlApiPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSyncGraphqlApiPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSyncGraphqlApiPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsAppSyncGraphqlApiPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of AppSyncGraphqlApi
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsAppSyncGraphqlApiPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsAppSyncGraphqlApiPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ApplicationResourceLifecycleConfigResponse(dict):
    """
    Definition of ApplicationResourceLifecycleConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceRole":
            suggest = "service_role"
        elif key == "versionLifecycleConfig":
            suggest = "version_lifecycle_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationResourceLifecycleConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationResourceLifecycleConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationResourceLifecycleConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_role: Optional[str] = None,
                 version_lifecycle_config: Optional['outputs.ApplicationVersionLifecycleConfigResponse'] = None):
        """
        Definition of ApplicationResourceLifecycleConfig
        :param str service_role: The ARN of an IAM service role that Elastic Beanstalk has permission to assume. The ServiceRole property is required the first time that you provide a ResourceLifecycleConfig for the application. After you provide it once, Elastic Beanstalk persists the Service Role with the application, and you don't need to specify it again. You can, however, specify it in subsequent updates to change the Service Role to another value.
        :param 'ApplicationVersionLifecycleConfigResponse' version_lifecycle_config: Defines lifecycle settings for application versions.
        """
        if service_role is not None:
            pulumi.set(__self__, "service_role", service_role)
        if version_lifecycle_config is not None:
            pulumi.set(__self__, "version_lifecycle_config", version_lifecycle_config)

    @property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> Optional[str]:
        """
        The ARN of an IAM service role that Elastic Beanstalk has permission to assume. The ServiceRole property is required the first time that you provide a ResourceLifecycleConfig for the application. After you provide it once, Elastic Beanstalk persists the Service Role with the application, and you don't need to specify it again. You can, however, specify it in subsequent updates to change the Service Role to another value.
        """
        return pulumi.get(self, "service_role")

    @property
    @pulumi.getter(name="versionLifecycleConfig")
    def version_lifecycle_config(self) -> Optional['outputs.ApplicationVersionLifecycleConfigResponse']:
        """
        Defines lifecycle settings for application versions.
        """
        return pulumi.get(self, "version_lifecycle_config")


@pulumi.output_type
class ApplicationResponse(dict):
    """
    Definition of Application
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInfo":
            suggest = "additional_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_info: Optional[Mapping[str, str]] = None,
                 args: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Definition of Application
        :param Mapping[str, str] additional_info: <p>This option is for advanced users only. This is meta information about third-party applications that third-party vendors use for testing purposes.</p>
        :param Sequence[str] args: <p>Arguments for Amazon EMR to pass to the application.</p>
        :param str name: <p>The name of the application.</p>
        :param str version: <p>The version of the application.</p>
        """
        if additional_info is not None:
            pulumi.set(__self__, "additional_info", additional_info)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Optional[Mapping[str, str]]:
        """
        <p>This option is for advanced users only. This is meta information about third-party applications that third-party vendors use for testing purposes.</p>
        """
        return pulumi.get(self, "additional_info")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        <p>Arguments for Amazon EMR to pass to the application.</p>
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the application.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        <p>The version of the application.</p>
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ApplicationVersionLifecycleConfigResponse(dict):
    """
    Definition of ApplicationVersionLifecycleConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAgeRule":
            suggest = "max_age_rule"
        elif key == "maxCountRule":
            suggest = "max_count_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationVersionLifecycleConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationVersionLifecycleConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationVersionLifecycleConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_age_rule: Optional['outputs.MaxAgeRuleResponse'] = None,
                 max_count_rule: Optional['outputs.MaxCountRuleResponse'] = None):
        """
        Definition of ApplicationVersionLifecycleConfig
        :param 'MaxAgeRuleResponse' max_age_rule: Specify a max age rule to restrict the length of time that application versions are retained for an application.
        :param 'MaxCountRuleResponse' max_count_rule: Specify a max count rule to restrict the number of application versions that are retained for an application.
        """
        if max_age_rule is not None:
            pulumi.set(__self__, "max_age_rule", max_age_rule)
        if max_count_rule is not None:
            pulumi.set(__self__, "max_count_rule", max_count_rule)

    @property
    @pulumi.getter(name="maxAgeRule")
    def max_age_rule(self) -> Optional['outputs.MaxAgeRuleResponse']:
        """
        Specify a max age rule to restrict the length of time that application versions are retained for an application.
        """
        return pulumi.get(self, "max_age_rule")

    @property
    @pulumi.getter(name="maxCountRule")
    def max_count_rule(self) -> Optional['outputs.MaxCountRuleResponse']:
        """
        Specify a max count rule to restrict the number of application versions that are retained for an application.
        """
        return pulumi.get(self, "max_count_rule")


@pulumi.output_type
class ArchitectureValuesEnumValueResponse(dict):
    """
    Definition of ArchitectureValuesEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ArchitectureValuesEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ArchiveRuleResponse(dict):
    """
    Definition of ArchiveRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleName":
            suggest = "rule_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArchiveRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArchiveRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArchiveRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter: Optional[Sequence['outputs.FilterResponse']] = None,
                 rule_name: Optional[str] = None):
        """
        Definition of ArchiveRule
        :param Sequence['FilterResponse'] filter: Property filter
        :param str rule_name: The archive rule name
        """
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)

    @property
    @pulumi.getter
    def filter(self) -> Optional[Sequence['outputs.FilterResponse']]:
        """
        Property filter
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[str]:
        """
        The archive rule name
        """
        return pulumi.get(self, "rule_name")


@pulumi.output_type
class ArtifactNamespaceEnumValueResponse(dict):
    """
    Definition of ArtifactNamespaceEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ArtifactNamespaceEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ArtifactPackagingEnumValueResponse(dict):
    """
    Definition of ArtifactPackagingEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ArtifactPackagingEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ArtifactsTypeEnumValueResponse(dict):
    """
    Definition of ArtifactsTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ArtifactsTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AttachmentStatusEnumValueResponse(dict):
    """
    Definition of AttachmentStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of AttachmentStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AttributeDefinitionResponse(dict):
    """
    Definition of AttributeDefinition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeType":
            suggest = "attribute_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AttributeDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AttributeDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AttributeDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_type: Optional[str] = None):
        """
        Definition of AttributeDefinition
        :param str attribute_name: A name for the attribute.
        :param str attribute_type: The data type for the attribute, where:  +   ``S`` - the attribute is of type String  +   ``N`` - the attribute is of type Number  +   ``B`` - the attribute is of type Binary
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_type is not None:
            pulumi.set(__self__, "attribute_type", attribute_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        """
        A name for the attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> Optional[str]:
        """
        The data type for the attribute, where:  +   ``S`` - the attribute is of type String  +   ``N`` - the attribute is of type Number  +   ``B`` - the attribute is of type Binary
        """
        return pulumi.get(self, "attribute_type")


@pulumi.output_type
class AuthTypeEnumValueResponse(dict):
    """
    Definition of AuthTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of AuthTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AuthenticateCognitoConfigResponse(dict):
    """
    Definition of AuthenticateCognitoConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationRequestExtraParams":
            suggest = "authentication_request_extra_params"
        elif key == "onUnauthenticatedRequest":
            suggest = "on_unauthenticated_request"
        elif key == "sessionCookieName":
            suggest = "session_cookie_name"
        elif key == "sessionTimeout":
            suggest = "session_timeout"
        elif key == "userPoolArn":
            suggest = "user_pool_arn"
        elif key == "userPoolClientId":
            suggest = "user_pool_client_id"
        elif key == "userPoolDomain":
            suggest = "user_pool_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthenticateCognitoConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthenticateCognitoConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthenticateCognitoConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_request_extra_params: Optional[Mapping[str, str]] = None,
                 on_unauthenticated_request: Optional[str] = None,
                 scope: Optional[str] = None,
                 session_cookie_name: Optional[str] = None,
                 session_timeout: Optional[str] = None,
                 user_pool_arn: Optional[str] = None,
                 user_pool_client_id: Optional[str] = None,
                 user_pool_domain: Optional[str] = None):
        """
        Definition of AuthenticateCognitoConfig
        :param Mapping[str, str] authentication_request_extra_params: The query parameters (up to 10) to include in the redirect request to the authorization endpoint.
        :param str on_unauthenticated_request: The behavior if the user is not authenticated. The following are possible values:  +  deny```` - Return an HTTP 401 Unauthorized error.  +  allow```` - Allow the request to be forwarded to the target.  +  authenticate```` - Redirect the request to the IdP authorization endpoint. This is the default value.
        :param str scope: The set of user claims to be requested from the IdP. The default is ``openid``. To verify which scope values your IdP supports and how to separate multiple values, see the documentation for your IdP.
        :param str session_cookie_name: The name of the cookie used to maintain session information. The default is AWSELBAuthSessionCookie.
        :param str session_timeout: The maximum duration of the authentication session, in seconds. The default is 604800 seconds (7 days).
        :param str user_pool_arn: The Amazon Resource Name (ARN) of the Amazon Cognito user pool.
        :param str user_pool_client_id: The ID of the Amazon Cognito user pool client.
        :param str user_pool_domain: The domain prefix or fully-qualified domain name of the Amazon Cognito user pool.
        """
        if authentication_request_extra_params is not None:
            pulumi.set(__self__, "authentication_request_extra_params", authentication_request_extra_params)
        if on_unauthenticated_request is not None:
            pulumi.set(__self__, "on_unauthenticated_request", on_unauthenticated_request)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if session_cookie_name is not None:
            pulumi.set(__self__, "session_cookie_name", session_cookie_name)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)
        if user_pool_arn is not None:
            pulumi.set(__self__, "user_pool_arn", user_pool_arn)
        if user_pool_client_id is not None:
            pulumi.set(__self__, "user_pool_client_id", user_pool_client_id)
        if user_pool_domain is not None:
            pulumi.set(__self__, "user_pool_domain", user_pool_domain)

    @property
    @pulumi.getter(name="authenticationRequestExtraParams")
    def authentication_request_extra_params(self) -> Optional[Mapping[str, str]]:
        """
        The query parameters (up to 10) to include in the redirect request to the authorization endpoint.
        """
        return pulumi.get(self, "authentication_request_extra_params")

    @property
    @pulumi.getter(name="onUnauthenticatedRequest")
    def on_unauthenticated_request(self) -> Optional[str]:
        """
        The behavior if the user is not authenticated. The following are possible values:  +  deny```` - Return an HTTP 401 Unauthorized error.  +  allow```` - Allow the request to be forwarded to the target.  +  authenticate```` - Redirect the request to the IdP authorization endpoint. This is the default value.
        """
        return pulumi.get(self, "on_unauthenticated_request")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The set of user claims to be requested from the IdP. The default is ``openid``. To verify which scope values your IdP supports and how to separate multiple values, see the documentation for your IdP.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sessionCookieName")
    def session_cookie_name(self) -> Optional[str]:
        """
        The name of the cookie used to maintain session information. The default is AWSELBAuthSessionCookie.
        """
        return pulumi.get(self, "session_cookie_name")

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[str]:
        """
        The maximum duration of the authentication session, in seconds. The default is 604800 seconds (7 days).
        """
        return pulumi.get(self, "session_timeout")

    @property
    @pulumi.getter(name="userPoolArn")
    def user_pool_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon Cognito user pool.
        """
        return pulumi.get(self, "user_pool_arn")

    @property
    @pulumi.getter(name="userPoolClientId")
    def user_pool_client_id(self) -> Optional[str]:
        """
        The ID of the Amazon Cognito user pool client.
        """
        return pulumi.get(self, "user_pool_client_id")

    @property
    @pulumi.getter(name="userPoolDomain")
    def user_pool_domain(self) -> Optional[str]:
        """
        The domain prefix or fully-qualified domain name of the Amazon Cognito user pool.
        """
        return pulumi.get(self, "user_pool_domain")


@pulumi.output_type
class AuthenticateOidcConfigResponse(dict):
    """
    Definition of AuthenticateOidcConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationRequestExtraParams":
            suggest = "authentication_request_extra_params"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "onUnauthenticatedRequest":
            suggest = "on_unauthenticated_request"
        elif key == "sessionCookieName":
            suggest = "session_cookie_name"
        elif key == "sessionTimeout":
            suggest = "session_timeout"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "useExistingClientSecret":
            suggest = "use_existing_client_secret"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthenticateOidcConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthenticateOidcConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthenticateOidcConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_request_extra_params: Optional[Mapping[str, str]] = None,
                 authorization_endpoint: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 issuer: Optional[str] = None,
                 on_unauthenticated_request: Optional[str] = None,
                 scope: Optional[str] = None,
                 session_cookie_name: Optional[str] = None,
                 session_timeout: Optional[str] = None,
                 token_endpoint: Optional[str] = None,
                 use_existing_client_secret: Optional[bool] = None,
                 user_info_endpoint: Optional[str] = None):
        """
        Definition of AuthenticateOidcConfig
        :param Mapping[str, str] authentication_request_extra_params: The query parameters (up to 10) to include in the redirect request to the authorization endpoint.
        :param str authorization_endpoint: The authorization endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.
        :param str client_id: The OAuth 2.0 client identifier.
        :param str client_secret: The OAuth 2.0 client secret. This parameter is required if you are creating a rule. If you are modifying a rule, you can omit this parameter if you set ``UseExistingClientSecret`` to true.
        :param str issuer: The OIDC issuer identifier of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.
        :param str on_unauthenticated_request: The behavior if the user is not authenticated. The following are possible values:  +  deny```` - Return an HTTP 401 Unauthorized error.  +  allow```` - Allow the request to be forwarded to the target.  +  authenticate```` - Redirect the request to the IdP authorization endpoint. This is the default value.
        :param str scope: The set of user claims to be requested from the IdP. The default is ``openid``. To verify which scope values your IdP supports and how to separate multiple values, see the documentation for your IdP.
        :param str session_cookie_name: The name of the cookie used to maintain session information. The default is AWSELBAuthSessionCookie.
        :param str session_timeout: The maximum duration of the authentication session, in seconds. The default is 604800 seconds (7 days).
        :param str token_endpoint: The token endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.
        :param bool use_existing_client_secret: Indicates whether to use the existing client secret when modifying a rule. If you are creating a rule, you can omit this parameter or set it to false.
        :param str user_info_endpoint: The user info endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.
        """
        if authentication_request_extra_params is not None:
            pulumi.set(__self__, "authentication_request_extra_params", authentication_request_extra_params)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if on_unauthenticated_request is not None:
            pulumi.set(__self__, "on_unauthenticated_request", on_unauthenticated_request)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if session_cookie_name is not None:
            pulumi.set(__self__, "session_cookie_name", session_cookie_name)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_existing_client_secret is not None:
            pulumi.set(__self__, "use_existing_client_secret", use_existing_client_secret)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="authenticationRequestExtraParams")
    def authentication_request_extra_params(self) -> Optional[Mapping[str, str]]:
        """
        The query parameters (up to 10) to include in the redirect request to the authorization endpoint.
        """
        return pulumi.get(self, "authentication_request_extra_params")

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[str]:
        """
        The authorization endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.
        """
        return pulumi.get(self, "authorization_endpoint")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The OAuth 2.0 client identifier.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth 2.0 client secret. This parameter is required if you are creating a rule. If you are modifying a rule, you can omit this parameter if you set ``UseExistingClientSecret`` to true.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OIDC issuer identifier of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="onUnauthenticatedRequest")
    def on_unauthenticated_request(self) -> Optional[str]:
        """
        The behavior if the user is not authenticated. The following are possible values:  +  deny```` - Return an HTTP 401 Unauthorized error.  +  allow```` - Allow the request to be forwarded to the target.  +  authenticate```` - Redirect the request to the IdP authorization endpoint. This is the default value.
        """
        return pulumi.get(self, "on_unauthenticated_request")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The set of user claims to be requested from the IdP. The default is ``openid``. To verify which scope values your IdP supports and how to separate multiple values, see the documentation for your IdP.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sessionCookieName")
    def session_cookie_name(self) -> Optional[str]:
        """
        The name of the cookie used to maintain session information. The default is AWSELBAuthSessionCookie.
        """
        return pulumi.get(self, "session_cookie_name")

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[str]:
        """
        The maximum duration of the authentication session, in seconds. The default is 604800 seconds (7 days).
        """
        return pulumi.get(self, "session_timeout")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The token endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.
        """
        return pulumi.get(self, "token_endpoint")

    @property
    @pulumi.getter(name="useExistingClientSecret")
    def use_existing_client_secret(self) -> Optional[bool]:
        """
        Indicates whether to use the existing client secret when modifying a rule. If you are creating a rule, you can omit this parameter or set it to false.
        """
        return pulumi.get(self, "use_existing_client_secret")

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[str]:
        """
        The user info endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the domain, and the path.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class AuthenticationModeEnumValueResponse(dict):
    """
    Definition of AuthenticationModeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of AuthenticationModeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AuthenticationTypeEnumValueResponse(dict):
    """
    Definition of AuthenticationTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of AuthenticationTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AuthorizationConfigResponse(dict):
    """
    Definition of AuthorizationConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPointId":
            suggest = "access_point_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_point_id: Optional[str] = None,
                 iam: Optional[str] = None):
        """
        Definition of AuthorizationConfig
        :param str access_point_id: The Amazon EFS access point ID to use. If an access point is specified, the root directory value specified in the ``EFSVolumeConfiguration`` must either be omitted or set to ``/`` which will enforce the path set on the EFS access point. If an access point is used, transit encryption must be on in the ``EFSVolumeConfiguration``. For more information, see [Working with Amazon EFS access points](https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html) in the *Amazon Elastic File System User Guide*.
        :param str iam: Determines whether to use the Amazon ECS task role defined in a task definition when mounting the Amazon EFS file system. If it is turned on, transit encryption must be turned on in the ``EFSVolumeConfiguration``. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Using Amazon EFS access points](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html#efs-volume-accesspoints) in the *Amazon Elastic Container Service Developer Guide*.
        """
        if access_point_id is not None:
            pulumi.set(__self__, "access_point_id", access_point_id)
        if iam is not None:
            pulumi.set(__self__, "iam", iam)

    @property
    @pulumi.getter(name="accessPointId")
    def access_point_id(self) -> Optional[str]:
        """
        The Amazon EFS access point ID to use. If an access point is specified, the root directory value specified in the ``EFSVolumeConfiguration`` must either be omitted or set to ``/`` which will enforce the path set on the EFS access point. If an access point is used, transit encryption must be on in the ``EFSVolumeConfiguration``. For more information, see [Working with Amazon EFS access points](https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html) in the *Amazon Elastic File System User Guide*.
        """
        return pulumi.get(self, "access_point_id")

    @property
    @pulumi.getter
    def iam(self) -> Optional[str]:
        """
        Determines whether to use the Amazon ECS task role defined in a task definition when mounting the Amazon EFS file system. If it is turned on, transit encryption must be turned on in the ``EFSVolumeConfiguration``. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Using Amazon EFS access points](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html#efs-volume-accesspoints) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "iam")


@pulumi.output_type
class AutoDeploymentResponse(dict):
    """
    Definition of AutoDeployment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retainStacksOnAccountRemoval":
            suggest = "retain_stacks_on_account_removal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoDeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoDeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoDeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 retain_stacks_on_account_removal: Optional[bool] = None):
        """
        Definition of AutoDeployment
        :param bool enabled: If set to true, StackSets automatically deploys additional stack instances to AWS Organizations accounts that are added to a target organization or organizational unit (OU) in the specified Regions. If an account is removed from a target organization or OU, StackSets deletes stack instances from the account in the specified Regions.
        :param bool retain_stacks_on_account_removal: If set to true, stack resources are retained when an account is removed from a target organization or OU. If set to false, stack resources are deleted. Specify only if Enabled is set to True.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if retain_stacks_on_account_removal is not None:
            pulumi.set(__self__, "retain_stacks_on_account_removal", retain_stacks_on_account_removal)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set to true, StackSets automatically deploys additional stack instances to AWS Organizations accounts that are added to a target organization or organizational unit (OU) in the specified Regions. If an account is removed from a target organization or OU, StackSets deletes stack instances from the account in the specified Regions.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="retainStacksOnAccountRemoval")
    def retain_stacks_on_account_removal(self) -> Optional[bool]:
        """
        If set to true, stack resources are retained when an account is removed from a target organization or OU. If set to false, stack resources are deleted. Specify only if Enabled is set to True.
        """
        return pulumi.get(self, "retain_stacks_on_account_removal")


@pulumi.output_type
class AutoScalingAutoScalingGroupPropertiesResponse(dict):
    """
    Definition of AutoScalingAutoScalingGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingAutoScalingGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingAutoScalingGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingAutoScalingGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsAutoScalingAutoScalingGroupPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of AutoScalingAutoScalingGroup
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsAutoScalingAutoScalingGroupPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsAutoScalingAutoScalingGroupPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class AutoSnapshotAddOnResponse(dict):
    """
    Definition of AutoSnapshotAddOn
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotTimeOfDay":
            suggest = "snapshot_time_of_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoSnapshotAddOnResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoSnapshotAddOnResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoSnapshotAddOnResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snapshot_time_of_day: Optional[str] = None):
        """
        Definition of AutoSnapshotAddOn
        :param str snapshot_time_of_day: The daily time when an automatic snapshot will be created.
        """
        if snapshot_time_of_day is not None:
            pulumi.set(__self__, "snapshot_time_of_day", snapshot_time_of_day)

    @property
    @pulumi.getter(name="snapshotTimeOfDay")
    def snapshot_time_of_day(self) -> Optional[str]:
        """
        The daily time when an automatic snapshot will be created.
        """
        return pulumi.get(self, "snapshot_time_of_day")


@pulumi.output_type
class AutoTuneOptionsOutputResponse(dict):
    """
    Definition of AutoTuneOptionsOutput
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "useOffPeakWindow":
            suggest = "use_off_peak_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoTuneOptionsOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoTuneOptionsOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoTuneOptionsOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: Optional[str] = None,
                 state: Optional['outputs.AutoTuneStateEnumValueResponse'] = None,
                 use_off_peak_window: Optional[bool] = None):
        """
        Definition of AutoTuneOptionsOutput
        :param str error_message: <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
        :param 'AutoTuneStateEnumValueResponse' state: <p>The current state of Auto-Tune on the domain.</p>
        :param bool use_off_peak_window: <p>Whether the domain's off-peak window will be used to deploy Auto-Tune changes rather than a maintenance schedule.</p>
        """
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if use_off_peak_window is not None:
            pulumi.set(__self__, "use_off_peak_window", use_off_peak_window)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        <p>Any errors that occurred while enabling or disabling Auto-Tune.</p>
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.AutoTuneStateEnumValueResponse']:
        """
        <p>The current state of Auto-Tune on the domain.</p>
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="useOffPeakWindow")
    def use_off_peak_window(self) -> Optional[bool]:
        """
        <p>Whether the domain's off-peak window will be used to deploy Auto-Tune changes rather than a maintenance schedule.</p>
        """
        return pulumi.get(self, "use_off_peak_window")


@pulumi.output_type
class AutoTuneStateEnumValueResponse(dict):
    """
    Definition of AutoTuneStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of AutoTuneStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AvailabilityZoneResponse(dict):
    """
    Definition of AvailabilityZone
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        Definition of AvailabilityZone
        :param str name: <p>The name of the Availability Zone.</p>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the Availability Zone.</p>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AwsAccessAnalyzerAnalyzerPropertiesResponse(dict):
    """
    Definition of awsAccessAnalyzerAnalyzer
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "analyzerConfiguration":
            suggest = "analyzer_configuration"
        elif key == "analyzerName":
            suggest = "analyzer_name"
        elif key == "archiveRules":
            suggest = "archive_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAccessAnalyzerAnalyzerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAccessAnalyzerAnalyzerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAccessAnalyzerAnalyzerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analyzer_configuration: Optional['outputs.UnusedAccessConfigurationResponse'] = None,
                 analyzer_name: Optional[str] = None,
                 archive_rules: Optional[Sequence['outputs.ArchiveRuleResponse']] = None,
                 arn: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 type: Optional[str] = None):
        """
        Definition of awsAccessAnalyzerAnalyzer
        :param 'UnusedAccessConfigurationResponse' analyzer_configuration: The configuration for the analyzer
        :param str analyzer_name: Analyzer name
        :param Sequence['ArchiveRuleResponse'] archive_rules: Property archiveRules
        :param str arn: Amazon Resource Name (ARN) of the analyzer
        :param Sequence['TagResponse'] tags: An array of key-value pairs to apply to this resource.
        :param str type: The type of the analyzer, must be one of ACCOUNT, ORGANIZATION, ACCOUNT_UNUSED_ACCESS or ORGANIZATION_UNUSED_ACCESS
        """
        if analyzer_configuration is not None:
            pulumi.set(__self__, "analyzer_configuration", analyzer_configuration)
        if analyzer_name is not None:
            pulumi.set(__self__, "analyzer_name", analyzer_name)
        if archive_rules is not None:
            pulumi.set(__self__, "archive_rules", archive_rules)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="analyzerConfiguration")
    def analyzer_configuration(self) -> Optional['outputs.UnusedAccessConfigurationResponse']:
        """
        The configuration for the analyzer
        """
        return pulumi.get(self, "analyzer_configuration")

    @property
    @pulumi.getter(name="analyzerName")
    def analyzer_name(self) -> Optional[str]:
        """
        Analyzer name
        """
        return pulumi.get(self, "analyzer_name")

    @property
    @pulumi.getter(name="archiveRules")
    def archive_rules(self) -> Optional[Sequence['outputs.ArchiveRuleResponse']]:
        """
        Property archiveRules
        """
        return pulumi.get(self, "archive_rules")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the analyzer
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An array of key-value pairs to apply to this resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the analyzer, must be one of ACCOUNT, ORGANIZATION, ACCOUNT_UNUSED_ACCESS or ORGANIZATION_UNUSED_ACCESS
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AwsAcmCertificateSummaryPropertiesResponse(dict):
    """
    Definition of awsAcmCertificateSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateArn":
            suggest = "certificate_arn"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "extendedKeyUsages":
            suggest = "extended_key_usages"
        elif key == "hasAdditionalSubjectAlternativeNames":
            suggest = "has_additional_subject_alternative_names"
        elif key == "importedAt":
            suggest = "imported_at"
        elif key == "inUse":
            suggest = "in_use"
        elif key == "issuedAt":
            suggest = "issued_at"
        elif key == "keyAlgorithm":
            suggest = "key_algorithm"
        elif key == "keyUsages":
            suggest = "key_usages"
        elif key == "notAfter":
            suggest = "not_after"
        elif key == "notBefore":
            suggest = "not_before"
        elif key == "renewalEligibility":
            suggest = "renewal_eligibility"
        elif key == "revokedAt":
            suggest = "revoked_at"
        elif key == "subjectAlternativeNameSummaries":
            suggest = "subject_alternative_name_summaries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAcmCertificateSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAcmCertificateSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAcmCertificateSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_arn: Optional[str] = None,
                 created_at: Optional[str] = None,
                 domain_name: Optional[str] = None,
                 exported: Optional[bool] = None,
                 extended_key_usages: Optional[Sequence[str]] = None,
                 has_additional_subject_alternative_names: Optional[bool] = None,
                 imported_at: Optional[str] = None,
                 in_use: Optional[bool] = None,
                 issued_at: Optional[str] = None,
                 key_algorithm: Optional['outputs.KeyAlgorithmEnumValueResponse'] = None,
                 key_usages: Optional[Sequence[str]] = None,
                 not_after: Optional[str] = None,
                 not_before: Optional[str] = None,
                 renewal_eligibility: Optional['outputs.RenewalEligibilityEnumValueResponse'] = None,
                 revoked_at: Optional[str] = None,
                 status: Optional['outputs.CertificateStatusEnumValueResponse'] = None,
                 subject_alternative_name_summaries: Optional[Sequence[str]] = None,
                 type: Optional['outputs.CertificateTypeEnumValueResponse'] = None):
        """
        Definition of awsAcmCertificateSummary
        :param str certificate_arn: <p>Amazon Resource Name (ARN) of the certificate. This is of the form:</p> <p> <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code> </p> <p>For more information about ARNs, see <a href='https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html'>Amazon Resource Names (ARNs)</a>.</p>
        :param str created_at: <p>The time at which the certificate was requested.</p>
        :param str domain_name: <p>Fully qualified domain name (FQDN), such as www.example.com or example.com, for the certificate.</p>
        :param bool exported: <p>Indicates whether the certificate has been exported. This value exists only when the certificate type is <code>PRIVATE</code>.</p>
        :param Sequence[str] extended_key_usages: <p>Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID). </p>
        :param bool has_additional_subject_alternative_names: <p>When called by <a href='https://docs.aws.amazon.com/acm/latestAPIReference/API_ListCertificates.html'>ListCertificates</a>, indicates whether the full list of subject alternative names has been included in the response. If false, the response includes all of the subject alternative names included in the certificate. If true, the response only includes the first 100 subject alternative names included in the certificate. To display the full list of subject alternative names, use <a href='https://docs.aws.amazon.com/acm/latestAPIReference/API_DescribeCertificate.html'>DescribeCertificate</a>.</p>
        :param str imported_at: <p>The date and time when the certificate was imported. This value exists only when the certificate type is <code>IMPORTED</code>. </p>
        :param bool in_use: <p>Indicates whether the certificate is currently in use by any Amazon Web Services resources.</p>
        :param str issued_at: <p>The time at which the certificate was issued. This value exists only when the certificate type is <code>AMAZON_ISSUED</code>. </p>
        :param 'KeyAlgorithmEnumValueResponse' key_algorithm: <p>The algorithm that was used to generate the public-private key pair.</p>
        :param Sequence[str] key_usages: <p>A list of Key Usage X.509 v3 extension objects. Each object is a string value that identifies the purpose of the public key contained in the certificate. Possible extension values include DIGITAL_SIGNATURE, KEY_ENCHIPHERMENT, NON_REPUDIATION, and more.</p>
        :param str not_after: <p>The time after which the certificate is not valid.</p>
        :param str not_before: <p>The time before which the certificate is not valid.</p>
        :param 'RenewalEligibilityEnumValueResponse' renewal_eligibility: <p>Specifies whether the certificate is eligible for renewal. At this time, only exported private certificates can be renewed with the <a>RenewCertificate</a> command.</p>
        :param str revoked_at: <p>The time at which the certificate was revoked. This value exists only when the certificate status is <code>REVOKED</code>. </p>
        :param 'CertificateStatusEnumValueResponse' status: <p>The status of the certificate.</p> <p>A certificate enters status PENDING_VALIDATION upon being requested, unless it fails for any of the reasons given in the troubleshooting topic <a href='https://docs.aws.amazon.com/acm/latest/userguide/troubleshooting-failed.html'>Certificate request fails</a>. ACM makes repeated attempts to validate a certificate for 72 hours and then times out. If a certificate shows status FAILED or VALIDATION_TIMED_OUT, delete the request, correct the issue with <a href='https://docs.aws.amazon.com/acm/latest/userguide/dns-validation.html'>DNS validation</a> or <a href='https://docs.aws.amazon.com/acm/latest/userguide/email-validation.html'>Email validation</a>, and try again. If validation succeeds, the certificate enters status ISSUED. </p>
        :param Sequence[str] subject_alternative_name_summaries: <p>One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate. The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website. </p> <p>When called by <a href='https://docs.aws.amazon.com/acm/latestAPIReference/API_ListCertificates.html'>ListCertificates</a>, this parameter will only return the first 100 subject alternative names included in the certificate. To display the full list of subject alternative names, use <a href='https://docs.aws.amazon.com/acm/latestAPIReference/API_DescribeCertificate.html'>DescribeCertificate</a>.</p>
        :param 'CertificateTypeEnumValueResponse' type: <p>The source of the certificate. For certificates provided by ACM, this value is <code>AMAZON_ISSUED</code>. For certificates that you imported with <a>ImportCertificate</a>, this value is <code>IMPORTED</code>. ACM does not provide <a href='https://docs.aws.amazon.com/acm/latest/userguide/acm-renewal.html'>managed renewal</a> for imported certificates. For more information about the differences between certificates that you import and those that ACM provides, see <a href='https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html'>Importing Certificates</a> in the <i>Certificate Manager User Guide</i>. </p>
        """
        if certificate_arn is not None:
            pulumi.set(__self__, "certificate_arn", certificate_arn)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if exported is not None:
            pulumi.set(__self__, "exported", exported)
        if extended_key_usages is not None:
            pulumi.set(__self__, "extended_key_usages", extended_key_usages)
        if has_additional_subject_alternative_names is not None:
            pulumi.set(__self__, "has_additional_subject_alternative_names", has_additional_subject_alternative_names)
        if imported_at is not None:
            pulumi.set(__self__, "imported_at", imported_at)
        if in_use is not None:
            pulumi.set(__self__, "in_use", in_use)
        if issued_at is not None:
            pulumi.set(__self__, "issued_at", issued_at)
        if key_algorithm is not None:
            pulumi.set(__self__, "key_algorithm", key_algorithm)
        if key_usages is not None:
            pulumi.set(__self__, "key_usages", key_usages)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)
        if renewal_eligibility is not None:
            pulumi.set(__self__, "renewal_eligibility", renewal_eligibility)
        if revoked_at is not None:
            pulumi.set(__self__, "revoked_at", revoked_at)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if subject_alternative_name_summaries is not None:
            pulumi.set(__self__, "subject_alternative_name_summaries", subject_alternative_name_summaries)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> Optional[str]:
        """
        <p>Amazon Resource Name (ARN) of the certificate. This is of the form:</p> <p> <code>arn:aws:acm:region:123456789012:certificate/12345678-1234-1234-1234-123456789012</code> </p> <p>For more information about ARNs, see <a href='https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html'>Amazon Resource Names (ARNs)</a>.</p>
        """
        return pulumi.get(self, "certificate_arn")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        <p>The time at which the certificate was requested.</p>
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        <p>Fully qualified domain name (FQDN), such as www.example.com or example.com, for the certificate.</p>
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def exported(self) -> Optional[bool]:
        """
        <p>Indicates whether the certificate has been exported. This value exists only when the certificate type is <code>PRIVATE</code>.</p>
        """
        return pulumi.get(self, "exported")

    @property
    @pulumi.getter(name="extendedKeyUsages")
    def extended_key_usages(self) -> Optional[Sequence[str]]:
        """
        <p>Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID). </p>
        """
        return pulumi.get(self, "extended_key_usages")

    @property
    @pulumi.getter(name="hasAdditionalSubjectAlternativeNames")
    def has_additional_subject_alternative_names(self) -> Optional[bool]:
        """
        <p>When called by <a href='https://docs.aws.amazon.com/acm/latestAPIReference/API_ListCertificates.html'>ListCertificates</a>, indicates whether the full list of subject alternative names has been included in the response. If false, the response includes all of the subject alternative names included in the certificate. If true, the response only includes the first 100 subject alternative names included in the certificate. To display the full list of subject alternative names, use <a href='https://docs.aws.amazon.com/acm/latestAPIReference/API_DescribeCertificate.html'>DescribeCertificate</a>.</p>
        """
        return pulumi.get(self, "has_additional_subject_alternative_names")

    @property
    @pulumi.getter(name="importedAt")
    def imported_at(self) -> Optional[str]:
        """
        <p>The date and time when the certificate was imported. This value exists only when the certificate type is <code>IMPORTED</code>. </p>
        """
        return pulumi.get(self, "imported_at")

    @property
    @pulumi.getter(name="inUse")
    def in_use(self) -> Optional[bool]:
        """
        <p>Indicates whether the certificate is currently in use by any Amazon Web Services resources.</p>
        """
        return pulumi.get(self, "in_use")

    @property
    @pulumi.getter(name="issuedAt")
    def issued_at(self) -> Optional[str]:
        """
        <p>The time at which the certificate was issued. This value exists only when the certificate type is <code>AMAZON_ISSUED</code>. </p>
        """
        return pulumi.get(self, "issued_at")

    @property
    @pulumi.getter(name="keyAlgorithm")
    def key_algorithm(self) -> Optional['outputs.KeyAlgorithmEnumValueResponse']:
        """
        <p>The algorithm that was used to generate the public-private key pair.</p>
        """
        return pulumi.get(self, "key_algorithm")

    @property
    @pulumi.getter(name="keyUsages")
    def key_usages(self) -> Optional[Sequence[str]]:
        """
        <p>A list of Key Usage X.509 v3 extension objects. Each object is a string value that identifies the purpose of the public key contained in the certificate. Possible extension values include DIGITAL_SIGNATURE, KEY_ENCHIPHERMENT, NON_REPUDIATION, and more.</p>
        """
        return pulumi.get(self, "key_usages")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[str]:
        """
        <p>The time after which the certificate is not valid.</p>
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[str]:
        """
        <p>The time before which the certificate is not valid.</p>
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter(name="renewalEligibility")
    def renewal_eligibility(self) -> Optional['outputs.RenewalEligibilityEnumValueResponse']:
        """
        <p>Specifies whether the certificate is eligible for renewal. At this time, only exported private certificates can be renewed with the <a>RenewCertificate</a> command.</p>
        """
        return pulumi.get(self, "renewal_eligibility")

    @property
    @pulumi.getter(name="revokedAt")
    def revoked_at(self) -> Optional[str]:
        """
        <p>The time at which the certificate was revoked. This value exists only when the certificate status is <code>REVOKED</code>. </p>
        """
        return pulumi.get(self, "revoked_at")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.CertificateStatusEnumValueResponse']:
        """
        <p>The status of the certificate.</p> <p>A certificate enters status PENDING_VALIDATION upon being requested, unless it fails for any of the reasons given in the troubleshooting topic <a href='https://docs.aws.amazon.com/acm/latest/userguide/troubleshooting-failed.html'>Certificate request fails</a>. ACM makes repeated attempts to validate a certificate for 72 hours and then times out. If a certificate shows status FAILED or VALIDATION_TIMED_OUT, delete the request, correct the issue with <a href='https://docs.aws.amazon.com/acm/latest/userguide/dns-validation.html'>DNS validation</a> or <a href='https://docs.aws.amazon.com/acm/latest/userguide/email-validation.html'>Email validation</a>, and try again. If validation succeeds, the certificate enters status ISSUED. </p>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subjectAlternativeNameSummaries")
    def subject_alternative_name_summaries(self) -> Optional[Sequence[str]]:
        """
        <p>One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate. The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website. </p> <p>When called by <a href='https://docs.aws.amazon.com/acm/latestAPIReference/API_ListCertificates.html'>ListCertificates</a>, this parameter will only return the first 100 subject alternative names included in the certificate. To display the full list of subject alternative names, use <a href='https://docs.aws.amazon.com/acm/latestAPIReference/API_DescribeCertificate.html'>DescribeCertificate</a>.</p>
        """
        return pulumi.get(self, "subject_alternative_name_summaries")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.CertificateTypeEnumValueResponse']:
        """
        <p>The source of the certificate. For certificates provided by ACM, this value is <code>AMAZON_ISSUED</code>. For certificates that you imported with <a>ImportCertificate</a>, this value is <code>IMPORTED</code>. ACM does not provide <a href='https://docs.aws.amazon.com/acm/latest/userguide/acm-renewal.html'>managed renewal</a> for imported certificates. For more information about the differences between certificates that you import and those that ACM provides, see <a href='https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html'>Importing Certificates</a> in the <i>Certificate Manager User Guide</i>. </p>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AwsApiGatewayRestApiPropertiesResponse(dict):
    """
    Definition of awsApiGatewayRestApi
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeySourceType":
            suggest = "api_key_source_type"
        elif key == "binaryMediaTypes":
            suggest = "binary_media_types"
        elif key == "bodyS3Location":
            suggest = "body_s3_location"
        elif key == "cloneFrom":
            suggest = "clone_from"
        elif key == "disableExecuteApiEndpoint":
            suggest = "disable_execute_api_endpoint"
        elif key == "endpointConfiguration":
            suggest = "endpoint_configuration"
        elif key == "failOnWarnings":
            suggest = "fail_on_warnings"
        elif key == "minimumCompressionSize":
            suggest = "minimum_compression_size"
        elif key == "restApiId":
            suggest = "rest_api_id"
        elif key == "rootResourceId":
            suggest = "root_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsApiGatewayRestApiPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsApiGatewayRestApiPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsApiGatewayRestApiPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_source_type: Optional[str] = None,
                 binary_media_types: Optional[Sequence[str]] = None,
                 body: Optional[Any] = None,
                 body_s3_location: Optional['outputs.S3LocationResponse'] = None,
                 clone_from: Optional[str] = None,
                 description: Optional[str] = None,
                 disable_execute_api_endpoint: Optional[bool] = None,
                 endpoint_configuration: Optional['outputs.EndpointConfigurationResponse'] = None,
                 fail_on_warnings: Optional[bool] = None,
                 minimum_compression_size: Optional[int] = None,
                 mode: Optional[str] = None,
                 name: Optional[str] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 policy: Optional[str] = None,
                 rest_api_id: Optional[str] = None,
                 root_resource_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsApiGatewayRestApi
        :param str api_key_source_type: The source of the API key for metering requests according to a usage plan. Valid values are: ``HEADER`` to read the API key from the ``X-API-Key`` header of a request. ``AUTHORIZER`` to read the API key from the ``UsageIdentifierKey`` from a custom authorizer.
        :param Sequence[str] binary_media_types: The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
        :param Any body: An OpenAPI specification that defines a set of RESTful APIs in JSON format. For YAML templates, you can also provide the specification in YAML format.
        :param 'S3LocationResponse' body_s3_location: The Amazon Simple Storage Service (Amazon S3) location that points to an OpenAPI file, which defines a set of RESTful APIs in JSON or YAML format. ``S3Location`` is a property of the [AWS::ApiGateway::RestApi](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html) resource that specifies the Amazon S3 location of a OpenAPI (formerly Swagger) file that defines a set of RESTful APIs in JSON or YAML. On January 1, 2016, the Swagger Specification was donated to the [OpenAPI initiative](https://docs.aws.amazon.com/https://www.openapis.org/), becoming the foundation of the OpenAPI Specification.
        :param str clone_from: The ID of the RestApi that you want to clone from.
        :param str description: The description of the RestApi.
        :param bool disable_execute_api_endpoint: Specifies whether clients can invoke your API by using the default ``execute-api`` endpoint. By default, clients can invoke your API with the default ``https://{api_id}.execute-api.{region}.amazonaws.com`` endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint
        :param 'EndpointConfigurationResponse' endpoint_configuration: A list of the endpoint types of the API. Use this property when creating an API. When importing an existing API, specify the endpoint configuration types using the ``Parameters`` property. The ``EndpointConfiguration`` property type specifies the endpoint types of a REST API. ``EndpointConfiguration`` is a property of the [AWS::ApiGateway::RestApi](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html) resource.
        :param bool fail_on_warnings: A query parameter to indicate whether to rollback the API update (``true``) or not (``false``) when a warning is encountered. The default value is ``false``.
        :param int minimum_compression_size: A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
        :param str mode: This property applies only when you use OpenAPI to define your REST API. The ``Mode`` determines how API Gateway handles resource updates. Valid values are ``overwrite`` or ``merge``.  For ``overwrite``, the new API definition replaces the existing one. The existing API identifier remains unchanged.  For ``merge``, the new API definition is merged with the existing API. If you don't specify this property, a default value is chosen. For REST APIs created before March 29, 2021, the default is ``overwrite``. For REST APIs created after March 29, 2021, the new API definition takes precedence, but any container types such as endpoint configurations and binary media types are merged with the existing API.  Use the default mode to define top-level ``RestApi`` properties in addition to using OpenAPI. Generally, it's preferred to use API Gateway's OpenAPI extensions to model these properties.
        :param str name: The name of the RestApi. A name is required if the REST API is not based on an OpenAPI specification.
        :param Mapping[str, str] parameters: Custom header parameters as part of the request. For example, to exclude DocumentationParts from an imported API, set ``ignore=documentation`` as a ``parameters`` value, as in the AWS CLI command of ``aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'``.
        :param str policy: A policy document that contains the permissions for the ``RestApi`` resource. To set the ARN for the policy, use the ``!Join`` intrinsic function with ``''`` as delimiter and values of ``'execute-api:/'`` and ``'*'``.
        :param str rest_api_id: Property restApiId
        :param str root_resource_id: Property rootResourceId
        :param Sequence['TagResponse'] tags: The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with ``aws:``. The tag value can be up to 256 characters.
        """
        if api_key_source_type is not None:
            pulumi.set(__self__, "api_key_source_type", api_key_source_type)
        if binary_media_types is not None:
            pulumi.set(__self__, "binary_media_types", binary_media_types)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if body_s3_location is not None:
            pulumi.set(__self__, "body_s3_location", body_s3_location)
        if clone_from is not None:
            pulumi.set(__self__, "clone_from", clone_from)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_execute_api_endpoint is not None:
            pulumi.set(__self__, "disable_execute_api_endpoint", disable_execute_api_endpoint)
        if endpoint_configuration is not None:
            pulumi.set(__self__, "endpoint_configuration", endpoint_configuration)
        if fail_on_warnings is not None:
            pulumi.set(__self__, "fail_on_warnings", fail_on_warnings)
        if minimum_compression_size is not None:
            pulumi.set(__self__, "minimum_compression_size", minimum_compression_size)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if rest_api_id is not None:
            pulumi.set(__self__, "rest_api_id", rest_api_id)
        if root_resource_id is not None:
            pulumi.set(__self__, "root_resource_id", root_resource_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="apiKeySourceType")
    def api_key_source_type(self) -> Optional[str]:
        """
        The source of the API key for metering requests according to a usage plan. Valid values are: ``HEADER`` to read the API key from the ``X-API-Key`` header of a request. ``AUTHORIZER`` to read the API key from the ``UsageIdentifierKey`` from a custom authorizer.
        """
        return pulumi.get(self, "api_key_source_type")

    @property
    @pulumi.getter(name="binaryMediaTypes")
    def binary_media_types(self) -> Optional[Sequence[str]]:
        """
        The list of binary media types supported by the RestApi. By default, the RestApi supports only UTF-8-encoded text payloads.
        """
        return pulumi.get(self, "binary_media_types")

    @property
    @pulumi.getter
    def body(self) -> Optional[Any]:
        """
        An OpenAPI specification that defines a set of RESTful APIs in JSON format. For YAML templates, you can also provide the specification in YAML format.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="bodyS3Location")
    def body_s3_location(self) -> Optional['outputs.S3LocationResponse']:
        """
        The Amazon Simple Storage Service (Amazon S3) location that points to an OpenAPI file, which defines a set of RESTful APIs in JSON or YAML format. ``S3Location`` is a property of the [AWS::ApiGateway::RestApi](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html) resource that specifies the Amazon S3 location of a OpenAPI (formerly Swagger) file that defines a set of RESTful APIs in JSON or YAML. On January 1, 2016, the Swagger Specification was donated to the [OpenAPI initiative](https://docs.aws.amazon.com/https://www.openapis.org/), becoming the foundation of the OpenAPI Specification.
        """
        return pulumi.get(self, "body_s3_location")

    @property
    @pulumi.getter(name="cloneFrom")
    def clone_from(self) -> Optional[str]:
        """
        The ID of the RestApi that you want to clone from.
        """
        return pulumi.get(self, "clone_from")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the RestApi.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableExecuteApiEndpoint")
    def disable_execute_api_endpoint(self) -> Optional[bool]:
        """
        Specifies whether clients can invoke your API by using the default ``execute-api`` endpoint. By default, clients can invoke your API with the default ``https://{api_id}.execute-api.{region}.amazonaws.com`` endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint
        """
        return pulumi.get(self, "disable_execute_api_endpoint")

    @property
    @pulumi.getter(name="endpointConfiguration")
    def endpoint_configuration(self) -> Optional['outputs.EndpointConfigurationResponse']:
        """
        A list of the endpoint types of the API. Use this property when creating an API. When importing an existing API, specify the endpoint configuration types using the ``Parameters`` property. The ``EndpointConfiguration`` property type specifies the endpoint types of a REST API. ``EndpointConfiguration`` is a property of the [AWS::ApiGateway::RestApi](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html) resource.
        """
        return pulumi.get(self, "endpoint_configuration")

    @property
    @pulumi.getter(name="failOnWarnings")
    def fail_on_warnings(self) -> Optional[bool]:
        """
        A query parameter to indicate whether to rollback the API update (``true``) or not (``false``) when a warning is encountered. The default value is ``false``.
        """
        return pulumi.get(self, "fail_on_warnings")

    @property
    @pulumi.getter(name="minimumCompressionSize")
    def minimum_compression_size(self) -> Optional[int]:
        """
        A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
        """
        return pulumi.get(self, "minimum_compression_size")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        This property applies only when you use OpenAPI to define your REST API. The ``Mode`` determines how API Gateway handles resource updates. Valid values are ``overwrite`` or ``merge``.  For ``overwrite``, the new API definition replaces the existing one. The existing API identifier remains unchanged.  For ``merge``, the new API definition is merged with the existing API. If you don't specify this property, a default value is chosen. For REST APIs created before March 29, 2021, the default is ``overwrite``. For REST APIs created after March 29, 2021, the new API definition takes precedence, but any container types such as endpoint configurations and binary media types are merged with the existing API.  Use the default mode to define top-level ``RestApi`` properties in addition to using OpenAPI. Generally, it's preferred to use API Gateway's OpenAPI extensions to model these properties.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the RestApi. A name is required if the REST API is not based on an OpenAPI specification.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        Custom header parameters as part of the request. For example, to exclude DocumentationParts from an imported API, set ``ignore=documentation`` as a ``parameters`` value, as in the AWS CLI command of ``aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'``.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        A policy document that contains the permissions for the ``RestApi`` resource. To set the ARN for the policy, use the ``!Join`` intrinsic function with ``''`` as delimiter and values of ``'execute-api:/'`` and ``'*'``.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter(name="restApiId")
    def rest_api_id(self) -> Optional[str]:
        """
        Property restApiId
        """
        return pulumi.get(self, "rest_api_id")

    @property
    @pulumi.getter(name="rootResourceId")
    def root_resource_id(self) -> Optional[str]:
        """
        Property rootResourceId
        """
        return pulumi.get(self, "root_resource_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with ``aws:``. The tag value can be up to 256 characters.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsApiGatewayStagePropertiesResponse(dict):
    """
    Definition of awsApiGatewayStage
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLogSetting":
            suggest = "access_log_setting"
        elif key == "cacheClusterEnabled":
            suggest = "cache_cluster_enabled"
        elif key == "cacheClusterSize":
            suggest = "cache_cluster_size"
        elif key == "canarySetting":
            suggest = "canary_setting"
        elif key == "clientCertificateId":
            suggest = "client_certificate_id"
        elif key == "deploymentId":
            suggest = "deployment_id"
        elif key == "documentationVersion":
            suggest = "documentation_version"
        elif key == "methodSettings":
            suggest = "method_settings"
        elif key == "restApiId":
            suggest = "rest_api_id"
        elif key == "stageName":
            suggest = "stage_name"
        elif key == "tracingEnabled":
            suggest = "tracing_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsApiGatewayStagePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsApiGatewayStagePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsApiGatewayStagePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_log_setting: Optional['outputs.AccessLogSettingResponse'] = None,
                 cache_cluster_enabled: Optional[bool] = None,
                 cache_cluster_size: Optional[str] = None,
                 canary_setting: Optional['outputs.CanarySettingResponse'] = None,
                 client_certificate_id: Optional[str] = None,
                 deployment_id: Optional[str] = None,
                 description: Optional[str] = None,
                 documentation_version: Optional[str] = None,
                 method_settings: Optional[Sequence['outputs.MethodSettingResponse']] = None,
                 rest_api_id: Optional[str] = None,
                 stage_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 tracing_enabled: Optional[bool] = None,
                 variables: Optional[Mapping[str, str]] = None):
        """
        Definition of awsApiGatewayStage
        :param 'AccessLogSettingResponse' access_log_setting: Access log settings, including the access log format and access log destination ARN. The ``AccessLogSetting`` property type specifies settings for logging access in this stage.  ``AccessLogSetting`` is a property of the [AWS::ApiGateway::Stage](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-stage.html) resource.
        :param bool cache_cluster_enabled: Specifies whether a cache cluster is enabled for the stage.
        :param str cache_cluster_size: The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
        :param 'CanarySettingResponse' canary_setting: Settings for the canary deployment in this stage. Configuration settings of a canary deployment.
        :param str client_certificate_id: The identifier of a client certificate for an API stage.
        :param str deployment_id: The identifier of the Deployment that the stage points to.
        :param str description: The stage's description.
        :param str documentation_version: The version of the associated API documentation.
        :param Sequence['MethodSettingResponse'] method_settings: A map that defines the method settings for a Stage resource. Keys (designated as ``/{method_setting_key`` below) are method paths defined as ``{resource_path}/{http_method}`` for an individual method override, or ``/\\*/\\*`` for overriding all methods in the stage.
        :param str rest_api_id: The string identifier of the associated RestApi.
        :param str stage_name: The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
        :param Sequence['TagResponse'] tags: The collection of tags. Each tag element is associated with a given resource.
        :param bool tracing_enabled: Specifies whether active tracing with X-ray is enabled for the Stage.
        :param Mapping[str, str] variables: A map (string-to-string map) that defines the stage variables, where the variable name is the key and the variable value is the value. Variable names are limited to alphanumeric characters. Values must match the following regular expression: ``[A-Za-z0-9-._~:/?#&=,]+``.
        """
        if access_log_setting is not None:
            pulumi.set(__self__, "access_log_setting", access_log_setting)
        if cache_cluster_enabled is not None:
            pulumi.set(__self__, "cache_cluster_enabled", cache_cluster_enabled)
        if cache_cluster_size is not None:
            pulumi.set(__self__, "cache_cluster_size", cache_cluster_size)
        if canary_setting is not None:
            pulumi.set(__self__, "canary_setting", canary_setting)
        if client_certificate_id is not None:
            pulumi.set(__self__, "client_certificate_id", client_certificate_id)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if documentation_version is not None:
            pulumi.set(__self__, "documentation_version", documentation_version)
        if method_settings is not None:
            pulumi.set(__self__, "method_settings", method_settings)
        if rest_api_id is not None:
            pulumi.set(__self__, "rest_api_id", rest_api_id)
        if stage_name is not None:
            pulumi.set(__self__, "stage_name", stage_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tracing_enabled is not None:
            pulumi.set(__self__, "tracing_enabled", tracing_enabled)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="accessLogSetting")
    def access_log_setting(self) -> Optional['outputs.AccessLogSettingResponse']:
        """
        Access log settings, including the access log format and access log destination ARN. The ``AccessLogSetting`` property type specifies settings for logging access in this stage.  ``AccessLogSetting`` is a property of the [AWS::ApiGateway::Stage](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-stage.html) resource.
        """
        return pulumi.get(self, "access_log_setting")

    @property
    @pulumi.getter(name="cacheClusterEnabled")
    def cache_cluster_enabled(self) -> Optional[bool]:
        """
        Specifies whether a cache cluster is enabled for the stage.
        """
        return pulumi.get(self, "cache_cluster_enabled")

    @property
    @pulumi.getter(name="cacheClusterSize")
    def cache_cluster_size(self) -> Optional[str]:
        """
        The stage's cache capacity in GB. For more information about choosing a cache size, see [Enabling API caching to enhance responsiveness](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html).
        """
        return pulumi.get(self, "cache_cluster_size")

    @property
    @pulumi.getter(name="canarySetting")
    def canary_setting(self) -> Optional['outputs.CanarySettingResponse']:
        """
        Settings for the canary deployment in this stage. Configuration settings of a canary deployment.
        """
        return pulumi.get(self, "canary_setting")

    @property
    @pulumi.getter(name="clientCertificateId")
    def client_certificate_id(self) -> Optional[str]:
        """
        The identifier of a client certificate for an API stage.
        """
        return pulumi.get(self, "client_certificate_id")

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[str]:
        """
        The identifier of the Deployment that the stage points to.
        """
        return pulumi.get(self, "deployment_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The stage's description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="documentationVersion")
    def documentation_version(self) -> Optional[str]:
        """
        The version of the associated API documentation.
        """
        return pulumi.get(self, "documentation_version")

    @property
    @pulumi.getter(name="methodSettings")
    def method_settings(self) -> Optional[Sequence['outputs.MethodSettingResponse']]:
        """
        A map that defines the method settings for a Stage resource. Keys (designated as ``/{method_setting_key`` below) are method paths defined as ``{resource_path}/{http_method}`` for an individual method override, or ``/\\*/\\*`` for overriding all methods in the stage.
        """
        return pulumi.get(self, "method_settings")

    @property
    @pulumi.getter(name="restApiId")
    def rest_api_id(self) -> Optional[str]:
        """
        The string identifier of the associated RestApi.
        """
        return pulumi.get(self, "rest_api_id")

    @property
    @pulumi.getter(name="stageName")
    def stage_name(self) -> Optional[str]:
        """
        The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
        """
        return pulumi.get(self, "stage_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The collection of tags. Each tag element is associated with a given resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tracingEnabled")
    def tracing_enabled(self) -> Optional[bool]:
        """
        Specifies whether active tracing with X-ray is enabled for the Stage.
        """
        return pulumi.get(self, "tracing_enabled")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, str]]:
        """
        A map (string-to-string map) that defines the stage variables, where the variable name is the key and the variable value is the value. Variable names are limited to alphanumeric characters. Values must match the following regular expression: ``[A-Za-z0-9-._~:/?#&=,]+``.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class AwsAppSyncGraphqlApiPropertiesResponse(dict):
    """
    Definition of awsAppSyncGraphqlApi
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalAuthenticationProviders":
            suggest = "additional_authentication_providers"
        elif key == "apiId":
            suggest = "api_id"
        elif key == "apiType":
            suggest = "api_type"
        elif key == "authenticationType":
            suggest = "authentication_type"
        elif key == "enhancedMetricsConfig":
            suggest = "enhanced_metrics_config"
        elif key == "introspectionConfig":
            suggest = "introspection_config"
        elif key == "lambdaAuthorizerConfig":
            suggest = "lambda_authorizer_config"
        elif key == "logConfig":
            suggest = "log_config"
        elif key == "mergedApiExecutionRoleArn":
            suggest = "merged_api_execution_role_arn"
        elif key == "openIDConnectConfig":
            suggest = "open_id_connect_config"
        elif key == "ownerContact":
            suggest = "owner_contact"
        elif key == "queryDepthLimit":
            suggest = "query_depth_limit"
        elif key == "resolverCountLimit":
            suggest = "resolver_count_limit"
        elif key == "userPoolConfig":
            suggest = "user_pool_config"
        elif key == "wafWebAclArn":
            suggest = "waf_web_acl_arn"
        elif key == "xrayEnabled":
            suggest = "xray_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAppSyncGraphqlApiPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAppSyncGraphqlApiPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAppSyncGraphqlApiPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_authentication_providers: Optional[Sequence['outputs.AdditionalAuthenticationProviderResponse']] = None,
                 api_id: Optional[str] = None,
                 api_type: Optional['outputs.GraphQLApiTypeEnumValueResponse'] = None,
                 arn: Optional[str] = None,
                 authentication_type: Optional['outputs.AuthenticationTypeEnumValueResponse'] = None,
                 dns: Optional[Mapping[str, str]] = None,
                 enhanced_metrics_config: Optional['outputs.EnhancedMetricsConfigResponse'] = None,
                 introspection_config: Optional['outputs.GraphQLApiIntrospectionConfigEnumValueResponse'] = None,
                 lambda_authorizer_config: Optional['outputs.LambdaAuthorizerConfigResponse'] = None,
                 log_config: Optional['outputs.LogConfigResponse'] = None,
                 merged_api_execution_role_arn: Optional[str] = None,
                 name: Optional[str] = None,
                 open_id_connect_config: Optional['outputs.OpenIDConnectConfigResponse'] = None,
                 owner: Optional[str] = None,
                 owner_contact: Optional[str] = None,
                 query_depth_limit: Optional[int] = None,
                 resolver_count_limit: Optional[int] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 uris: Optional[Mapping[str, str]] = None,
                 user_pool_config: Optional['outputs.UserPoolConfigResponse'] = None,
                 visibility: Optional['outputs.GraphQLApiVisibilityEnumValueResponse'] = None,
                 waf_web_acl_arn: Optional[str] = None,
                 xray_enabled: Optional[bool] = None):
        """
        Definition of awsAppSyncGraphqlApi
        :param Sequence['AdditionalAuthenticationProviderResponse'] additional_authentication_providers: <p>A list of additional authentication providers for the <code>GraphqlApi</code> API.</p>
        :param str api_id: <p>The API ID.</p>
        :param 'GraphQLApiTypeEnumValueResponse' api_type: <p>The value that indicates whether the GraphQL API is a standard API (<code>GRAPHQL</code>) or merged API (<code>MERGED</code>).</p>
        :param str arn: <p>The Amazon Resource Name (ARN).</p>
        :param 'AuthenticationTypeEnumValueResponse' authentication_type: <p>The authentication type.</p>
        :param Mapping[str, str] dns: <p>The DNS records for the API.</p>
        :param 'EnhancedMetricsConfigResponse' enhanced_metrics_config: <p>The <code>enhancedMetricsConfig</code> object.</p>
        :param 'GraphQLApiIntrospectionConfigEnumValueResponse' introspection_config: <p>Sets the value of the GraphQL API to enable (<code>ENABLED</code>) or disable (<code>DISABLED</code>) introspection. If no value is provided, the introspection configuration will be set to <code>ENABLED</code> by default. This field will produce an error if the operation attempts to use the introspection feature while this field is disabled.</p> <p>For more information about introspection, see <a href='https://graphql.org/learn/introspection/'>GraphQL introspection</a>.</p>
        :param 'LambdaAuthorizerConfigResponse' lambda_authorizer_config: <p>Configuration for Lambda function authorization.</p>
        :param 'LogConfigResponse' log_config: <p>The Amazon CloudWatch Logs configuration.</p>
        :param str merged_api_execution_role_arn: <p>The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the <code>AUTO_MERGE</code> to update the merged API endpoint with the source API changes automatically.</p>
        :param str name: <p>The API name.</p>
        :param 'OpenIDConnectConfigResponse' open_id_connect_config: <p>The OpenID Connect configuration.</p>
        :param str owner: <p>The account owner of the GraphQL API.</p>
        :param str owner_contact: <p>The owner contact information for an API resource.</p> <p>This field accepts any string input with a length of 0 - 256 characters.</p>
        :param int query_depth_limit: <p>The maximum depth a query can have in a single request. Depth refers to the amount of nested levels allowed in the body of query. The default value is <code>0</code> (or unspecified), which indicates there's no depth limit. If you set a limit, it can be between <code>1</code> and <code>75</code> nested levels. This field will produce a limit error if the operation falls out of bounds.</p> <p>Note that fields can still be set to nullable or non-nullable. If a non-nullable field produces an error, the error will be thrown upwards to the first nullable field available.</p>
        :param int resolver_count_limit: <p>The maximum number of resolvers that can be invoked in a single request. The default value is <code>0</code> (or unspecified), which will set the limit to <code>10000</code>. When specified, the limit value can be between <code>1</code> and <code>10000</code>. This field will produce a limit error if the operation falls out of bounds.</p>
        :param Mapping[str, str] tags: <p>The tags.</p>
        :param Mapping[str, str] uris: <p>The URIs.</p>
        :param 'UserPoolConfigResponse' user_pool_config: <p>The Amazon Cognito user pool configuration.</p>
        :param 'GraphQLApiVisibilityEnumValueResponse' visibility: <p>Sets the value of the GraphQL API to public (<code>GLOBAL</code>) or private (<code>PRIVATE</code>). If no value is provided, the visibility will be set to <code>GLOBAL</code> by default. This value cannot be changed once the API has been created.</p>
        :param str waf_web_acl_arn: <p>The ARN of the WAF access control list (ACL) associated with this <code>GraphqlApi</code>, if one exists.</p>
        :param bool xray_enabled: <p>A flag indicating whether to use X-Ray tracing for this <code>GraphqlApi</code>.</p>
        """
        if additional_authentication_providers is not None:
            pulumi.set(__self__, "additional_authentication_providers", additional_authentication_providers)
        if api_id is not None:
            pulumi.set(__self__, "api_id", api_id)
        if api_type is not None:
            pulumi.set(__self__, "api_type", api_type)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if enhanced_metrics_config is not None:
            pulumi.set(__self__, "enhanced_metrics_config", enhanced_metrics_config)
        if introspection_config is not None:
            pulumi.set(__self__, "introspection_config", introspection_config)
        if lambda_authorizer_config is not None:
            pulumi.set(__self__, "lambda_authorizer_config", lambda_authorizer_config)
        if log_config is not None:
            pulumi.set(__self__, "log_config", log_config)
        if merged_api_execution_role_arn is not None:
            pulumi.set(__self__, "merged_api_execution_role_arn", merged_api_execution_role_arn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_id_connect_config is not None:
            pulumi.set(__self__, "open_id_connect_config", open_id_connect_config)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if owner_contact is not None:
            pulumi.set(__self__, "owner_contact", owner_contact)
        if query_depth_limit is not None:
            pulumi.set(__self__, "query_depth_limit", query_depth_limit)
        if resolver_count_limit is not None:
            pulumi.set(__self__, "resolver_count_limit", resolver_count_limit)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if uris is not None:
            pulumi.set(__self__, "uris", uris)
        if user_pool_config is not None:
            pulumi.set(__self__, "user_pool_config", user_pool_config)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)
        if waf_web_acl_arn is not None:
            pulumi.set(__self__, "waf_web_acl_arn", waf_web_acl_arn)
        if xray_enabled is not None:
            pulumi.set(__self__, "xray_enabled", xray_enabled)

    @property
    @pulumi.getter(name="additionalAuthenticationProviders")
    def additional_authentication_providers(self) -> Optional[Sequence['outputs.AdditionalAuthenticationProviderResponse']]:
        """
        <p>A list of additional authentication providers for the <code>GraphqlApi</code> API.</p>
        """
        return pulumi.get(self, "additional_authentication_providers")

    @property
    @pulumi.getter(name="apiId")
    def api_id(self) -> Optional[str]:
        """
        <p>The API ID.</p>
        """
        return pulumi.get(self, "api_id")

    @property
    @pulumi.getter(name="apiType")
    def api_type(self) -> Optional['outputs.GraphQLApiTypeEnumValueResponse']:
        """
        <p>The value that indicates whether the GraphQL API is a standard API (<code>GRAPHQL</code>) or merged API (<code>MERGED</code>).</p>
        """
        return pulumi.get(self, "api_type")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN).</p>
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional['outputs.AuthenticationTypeEnumValueResponse']:
        """
        <p>The authentication type.</p>
        """
        return pulumi.get(self, "authentication_type")

    @property
    @pulumi.getter
    def dns(self) -> Optional[Mapping[str, str]]:
        """
        <p>The DNS records for the API.</p>
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter(name="enhancedMetricsConfig")
    def enhanced_metrics_config(self) -> Optional['outputs.EnhancedMetricsConfigResponse']:
        """
        <p>The <code>enhancedMetricsConfig</code> object.</p>
        """
        return pulumi.get(self, "enhanced_metrics_config")

    @property
    @pulumi.getter(name="introspectionConfig")
    def introspection_config(self) -> Optional['outputs.GraphQLApiIntrospectionConfigEnumValueResponse']:
        """
        <p>Sets the value of the GraphQL API to enable (<code>ENABLED</code>) or disable (<code>DISABLED</code>) introspection. If no value is provided, the introspection configuration will be set to <code>ENABLED</code> by default. This field will produce an error if the operation attempts to use the introspection feature while this field is disabled.</p> <p>For more information about introspection, see <a href='https://graphql.org/learn/introspection/'>GraphQL introspection</a>.</p>
        """
        return pulumi.get(self, "introspection_config")

    @property
    @pulumi.getter(name="lambdaAuthorizerConfig")
    def lambda_authorizer_config(self) -> Optional['outputs.LambdaAuthorizerConfigResponse']:
        """
        <p>Configuration for Lambda function authorization.</p>
        """
        return pulumi.get(self, "lambda_authorizer_config")

    @property
    @pulumi.getter(name="logConfig")
    def log_config(self) -> Optional['outputs.LogConfigResponse']:
        """
        <p>The Amazon CloudWatch Logs configuration.</p>
        """
        return pulumi.get(self, "log_config")

    @property
    @pulumi.getter(name="mergedApiExecutionRoleArn")
    def merged_api_execution_role_arn(self) -> Optional[str]:
        """
        <p>The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the <code>AUTO_MERGE</code> to update the merged API endpoint with the source API changes automatically.</p>
        """
        return pulumi.get(self, "merged_api_execution_role_arn")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The API name.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="openIDConnectConfig")
    def open_id_connect_config(self) -> Optional['outputs.OpenIDConnectConfigResponse']:
        """
        <p>The OpenID Connect configuration.</p>
        """
        return pulumi.get(self, "open_id_connect_config")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        <p>The account owner of the GraphQL API.</p>
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="ownerContact")
    def owner_contact(self) -> Optional[str]:
        """
        <p>The owner contact information for an API resource.</p> <p>This field accepts any string input with a length of 0 - 256 characters.</p>
        """
        return pulumi.get(self, "owner_contact")

    @property
    @pulumi.getter(name="queryDepthLimit")
    def query_depth_limit(self) -> Optional[int]:
        """
        <p>The maximum depth a query can have in a single request. Depth refers to the amount of nested levels allowed in the body of query. The default value is <code>0</code> (or unspecified), which indicates there's no depth limit. If you set a limit, it can be between <code>1</code> and <code>75</code> nested levels. This field will produce a limit error if the operation falls out of bounds.</p> <p>Note that fields can still be set to nullable or non-nullable. If a non-nullable field produces an error, the error will be thrown upwards to the first nullable field available.</p>
        """
        return pulumi.get(self, "query_depth_limit")

    @property
    @pulumi.getter(name="resolverCountLimit")
    def resolver_count_limit(self) -> Optional[int]:
        """
        <p>The maximum number of resolvers that can be invoked in a single request. The default value is <code>0</code> (or unspecified), which will set the limit to <code>10000</code>. When specified, the limit value can be between <code>1</code> and <code>10000</code>. This field will produce a limit error if the operation falls out of bounds.</p>
        """
        return pulumi.get(self, "resolver_count_limit")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        <p>The tags.</p>
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def uris(self) -> Optional[Mapping[str, str]]:
        """
        <p>The URIs.</p>
        """
        return pulumi.get(self, "uris")

    @property
    @pulumi.getter(name="userPoolConfig")
    def user_pool_config(self) -> Optional['outputs.UserPoolConfigResponse']:
        """
        <p>The Amazon Cognito user pool configuration.</p>
        """
        return pulumi.get(self, "user_pool_config")

    @property
    @pulumi.getter
    def visibility(self) -> Optional['outputs.GraphQLApiVisibilityEnumValueResponse']:
        """
        <p>Sets the value of the GraphQL API to public (<code>GLOBAL</code>) or private (<code>PRIVATE</code>). If no value is provided, the visibility will be set to <code>GLOBAL</code> by default. This value cannot be changed once the API has been created.</p>
        """
        return pulumi.get(self, "visibility")

    @property
    @pulumi.getter(name="wafWebAclArn")
    def waf_web_acl_arn(self) -> Optional[str]:
        """
        <p>The ARN of the WAF access control list (ACL) associated with this <code>GraphqlApi</code>, if one exists.</p>
        """
        return pulumi.get(self, "waf_web_acl_arn")

    @property
    @pulumi.getter(name="xrayEnabled")
    def xray_enabled(self) -> Optional[bool]:
        """
        <p>A flag indicating whether to use X-Ray tracing for this <code>GraphqlApi</code>.</p>
        """
        return pulumi.get(self, "xray_enabled")


@pulumi.output_type
class AwsAutoScalingAutoScalingGroupPropertiesResponse(dict):
    """
    Definition of awsAutoScalingAutoScalingGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScalingGroupName":
            suggest = "auto_scaling_group_name"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "capacityRebalance":
            suggest = "capacity_rebalance"
        elif key == "defaultInstanceWarmup":
            suggest = "default_instance_warmup"
        elif key == "desiredCapacity":
            suggest = "desired_capacity"
        elif key == "desiredCapacityType":
            suggest = "desired_capacity_type"
        elif key == "healthCheckGracePeriod":
            suggest = "health_check_grace_period"
        elif key == "healthCheckType":
            suggest = "health_check_type"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "instanceMaintenancePolicy":
            suggest = "instance_maintenance_policy"
        elif key == "launchConfigurationName":
            suggest = "launch_configuration_name"
        elif key == "launchTemplate":
            suggest = "launch_template"
        elif key == "lifecycleHookSpecificationList":
            suggest = "lifecycle_hook_specification_list"
        elif key == "loadBalancerNames":
            suggest = "load_balancer_names"
        elif key == "maxInstanceLifetime":
            suggest = "max_instance_lifetime"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "metricsCollection":
            suggest = "metrics_collection"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "mixedInstancesPolicy":
            suggest = "mixed_instances_policy"
        elif key == "newInstancesProtectedFromScaleIn":
            suggest = "new_instances_protected_from_scale_in"
        elif key == "notificationConfiguration":
            suggest = "notification_configuration"
        elif key == "notificationConfigurations":
            suggest = "notification_configurations"
        elif key == "placementGroup":
            suggest = "placement_group"
        elif key == "serviceLinkedRoleARN":
            suggest = "service_linked_role_arn"
        elif key == "targetGroupARNs":
            suggest = "target_group_arns"
        elif key == "terminationPolicies":
            suggest = "termination_policies"
        elif key == "vpcZoneIdentifier":
            suggest = "vpc_zone_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAutoScalingAutoScalingGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAutoScalingAutoScalingGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAutoScalingAutoScalingGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_scaling_group_name: Optional[str] = None,
                 availability_zones: Optional[Sequence[str]] = None,
                 capacity_rebalance: Optional[bool] = None,
                 context: Optional[str] = None,
                 cooldown: Optional[str] = None,
                 default_instance_warmup: Optional[int] = None,
                 desired_capacity: Optional[str] = None,
                 desired_capacity_type: Optional[str] = None,
                 health_check_grace_period: Optional[int] = None,
                 health_check_type: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 instance_maintenance_policy: Optional['outputs.InstanceMaintenancePolicyResponse'] = None,
                 launch_configuration_name: Optional[str] = None,
                 launch_template: Optional['outputs.LaunchTemplateSpecificationResponse'] = None,
                 lifecycle_hook_specification_list: Optional[Sequence['outputs.LifecycleHookSpecificationResponse']] = None,
                 load_balancer_names: Optional[Sequence[str]] = None,
                 max_instance_lifetime: Optional[int] = None,
                 max_size: Optional[str] = None,
                 metrics_collection: Optional[Sequence['outputs.MetricsCollectionResponse']] = None,
                 min_size: Optional[str] = None,
                 mixed_instances_policy: Optional['outputs.MixedInstancesPolicyResponse'] = None,
                 new_instances_protected_from_scale_in: Optional[bool] = None,
                 notification_configuration: Optional['outputs.NotificationConfigurationResponse'] = None,
                 notification_configurations: Optional[Sequence['outputs.NotificationConfigurationResponse']] = None,
                 placement_group: Optional[str] = None,
                 service_linked_role_arn: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagPropertyResponse']] = None,
                 target_group_arns: Optional[Sequence[str]] = None,
                 termination_policies: Optional[Sequence[str]] = None,
                 vpc_zone_identifier: Optional[Sequence[str]] = None):
        """
        Definition of awsAutoScalingAutoScalingGroup
        :param str auto_scaling_group_name: The name of the Auto Scaling group. This name must be unique per Region per account. The name can contain any ASCII character 33 to 126 including most punctuation characters, digits, and upper and lowercased letters.  You cannot use a colon (:) in the name.
        :param Sequence[str] availability_zones: A list of Availability Zones where instances in the Auto Scaling group can be created. Used for launching into the default VPC subnet in each Availability Zone when not using the ``VPCZoneIdentifier`` property, or for attaching a network interface when an existing network interface ID is specified in a launch template.
        :param bool capacity_rebalance: Indicates whether Capacity Rebalancing is enabled. Otherwise, Capacity Rebalancing is disabled. When you turn on Capacity Rebalancing, Amazon EC2 Auto Scaling attempts to launch a Spot Instance whenever Amazon EC2 notifies that a Spot Instance is at an elevated risk of interruption. After launching a new instance, it then terminates an old instance. For more information, see [Use Capacity Rebalancing to handle Amazon EC2 Spot Interruptions](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-capacity-rebalancing.html) in the in the *Amazon EC2 Auto Scaling User Guide*.
        :param str context: Reserved.
        :param str cooldown: *Only needed if you use simple scaling policies.*  The amount of time, in seconds, between one scaling activity ending and another one starting due to simple scaling policies. For more information, see [Scaling cooldowns for Amazon EC2 Auto Scaling](https://docs.aws.amazon.com/autoscaling/ec2/userguide/Cooldown.html) in the *Amazon EC2 Auto Scaling User Guide*. Default: ``300`` seconds
        :param int default_instance_warmup: The amount of time, in seconds, until a new instance is considered to have finished initializing and resource consumption to become stable after it enters the ``InService`` state.  During an instance refresh, Amazon EC2 Auto Scaling waits for the warm-up period after it replaces an instance before it moves on to replacing the next instance. Amazon EC2 Auto Scaling also waits for the warm-up period before aggregating the metrics for new instances with existing instances in the Amazon CloudWatch metrics that are used for scaling, resulting in more reliable usage data. For more information, see [Set the default instance warmup for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-default-instance-warmup.html) in the *Amazon EC2 Auto Scaling User Guide*.  To manage various warm-up settings at the group level, we recommend that you set the default instance warmup, *even if it is set to 0 seconds*. To remove a value that you previously set, include the property but specify ``-1`` for the value. However, we strongly recommend keeping the default instance warmup enabled by specifying a value of ``0`` or other nominal value.  Default: None
        :param str desired_capacity: The desired capacity is the initial capacity of the Auto Scaling group at the time of its creation and the capacity it attempts to maintain. It can scale beyond this capacity if you configure automatic scaling. The number must be greater than or equal to the minimum size of the group and less than or equal to the maximum size of the group. If you do not specify a desired capacity when creating the stack, the default is the minimum size of the group. CloudFormation marks the Auto Scaling group as successful (by setting its status to CREATE_COMPLETE) when the desired capacity is reached. However, if a maximum Spot price is set in the launch template or launch configuration that you specified, then desired capacity is not used as a criteria for success. Whether your request is fulfilled depends on Spot Instance capacity and your maximum price.
        :param str desired_capacity_type: The unit of measurement for the value specified for desired capacity. Amazon EC2 Auto Scaling supports ``DesiredCapacityType`` for attribute-based instance type selection only. For more information, see [Creating an Auto Scaling group using attribute-based instance type selection](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-asg-instance-type-requirements.html) in the *Amazon EC2 Auto Scaling User Guide*. By default, Amazon EC2 Auto Scaling specifies ``units``, which translates into number of instances. Valid values: ``units`` | ``vcpu`` | ``memory-mib``
        :param int health_check_grace_period: The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before checking the health status of an EC2 instance that has come into service and marking it unhealthy due to a failed health check. This is useful if your instances do not immediately pass their health checks after they enter the ``InService`` state. For more information, see [Set the health check grace period for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/health-check-grace-period.html) in the *Amazon EC2 Auto Scaling User Guide*. Default: ``0`` seconds
        :param str health_check_type: A comma-separated value string of one or more health check types. The valid values are ``EC2``, ``ELB``, and ``VPC_LATTICE``. ``EC2`` is the default health check and cannot be disabled. For more information, see [Health checks for Auto Scaling instances](https://docs.aws.amazon.com/autoscaling/ec2/userguide/healthcheck.html) in the *Amazon EC2 Auto Scaling User Guide*. Only specify ``EC2`` if you must clear a value that was previously set.
        :param str instance_id: The ID of the instance used to base the launch configuration on. For more information, see [Create an Auto Scaling group using an EC2 instance](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-asg-from-instance.html) in the *Amazon EC2 Auto Scaling User Guide*. If you specify ``LaunchTemplate``, ``MixedInstancesPolicy``, or ``LaunchConfigurationName``, don't specify ``InstanceId``.
        :param 'InstanceMaintenancePolicyResponse' instance_maintenance_policy: An instance maintenance policy. For more information, see [Set instance maintenance policy](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-instance-maintenance-policy.html) in the *Amazon EC2 Auto Scaling User Guide*. ``InstanceMaintenancePolicy`` is a property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. For more information, see [Instance maintenance policies](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-instance-maintenance-policy.html) in the *Amazon EC2 Auto Scaling User Guide*.
        :param str launch_configuration_name: The name of the launch configuration to use to launch instances. Required only if you don't specify ``LaunchTemplate``, ``MixedInstancesPolicy``, or ``InstanceId``.
        :param 'LaunchTemplateSpecificationResponse' launch_template: Information used to specify the launch template and version to use to launch instances. You can alternatively associate a launch template to the Auto Scaling group by specifying a ``MixedInstancesPolicy``. For more information about creating launch templates, see [Create a launch template for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html) in the *Amazon EC2 Auto Scaling User Guide*. If you omit this property, you must specify ``MixedInstancesPolicy``, ``LaunchConfigurationName``, or ``InstanceId``. Specifies a launch template to use when provisioning EC2 instances for an Auto Scaling group. You must specify the following:  +  The ID or the name of the launch template, but not both.  +  The version of the launch template.   ``LaunchTemplateSpecification`` is property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. It is also a property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplate.html) and [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property types. For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html) in the *Amazon EC2 Auto Scaling User Guide*. For examples of launch templates, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html) and the [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) section in the ``AWS::EC2::LaunchTemplate`` resource.
        :param Sequence['LifecycleHookSpecificationResponse'] lifecycle_hook_specification_list: One or more lifecycle hooks to add to the Auto Scaling group before instances are launched.
        :param Sequence[str] load_balancer_names: A list of Classic Load Balancers associated with this Auto Scaling group. For Application Load Balancers, Network Load Balancers, and Gateway Load Balancers, specify the ``TargetGroupARNs`` property instead.
        :param int max_instance_lifetime: The maximum amount of time, in seconds, that an instance can be in service. The default is null. If specified, the value must be either 0 or a number equal to or greater than 86,400 seconds (1 day). For more information, see [Replacing Auto Scaling instances based on maximum instance lifetime](https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-max-instance-lifetime.html) in the *Amazon EC2 Auto Scaling User Guide*.
        :param str max_size: The maximum size of the group.  With a mixed instances policy that uses instance weighting, Amazon EC2 Auto Scaling may need to go above ``MaxSize`` to meet your capacity requirements. In this event, Amazon EC2 Auto Scaling will never go above ``MaxSize`` by more than your largest instance weight (weights that define how many units each instance contributes to the desired capacity of the group).
        :param Sequence['MetricsCollectionResponse'] metrics_collection: Enables the monitoring of group metrics of an Auto Scaling group. By default, these metrics are disabled.
        :param str min_size: The minimum size of the group.
        :param 'MixedInstancesPolicyResponse' mixed_instances_policy: An embedded object that specifies a mixed instances policy. The policy includes properties that not only define the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances (optional), and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacities, but also the properties that specify the instance configuration informationthe launch template and instance types. The policy can also include a weight for each instance type and different launch templates for individual instance types. For more information, see [Auto Scaling groups with multiple instance types and purchase options](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups.html) in the *Amazon EC2 Auto Scaling User Guide*. Use this structure to launch multiple instance types and On-Demand Instances and Spot Instances within a single Auto Scaling group. A mixed instances policy contains information that Amazon EC2 Auto Scaling can use to launch instances and help optimize your costs. For more information, see [Auto Scaling groups with multiple instance types and purchase options](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups.html) in the *Amazon EC2 Auto Scaling User Guide*. You can create a mixed instances policy for new and existing Auto Scaling groups. You must use a launch template to configure the policy. You cannot use a launch configuration. There are key differences between Spot Instances and On-Demand Instances:  +  The price for Spot Instances varies based on demand  +  Amazon EC2 can terminate an individual Spot Instance as the availability of, or price for, Spot Instances changes   When a Spot Instance is terminated, Amazon EC2 Auto Scaling group attempts to launch a replacement instance to maintain the desired capacity for the group.   ``MixedInstancesPolicy`` is a property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource.
        :param bool new_instances_protected_from_scale_in: Indicates whether newly launched instances are protected from termination by Amazon EC2 Auto Scaling when scaling in. For more information about preventing instances from terminating on scale in, see [Using instance scale-in protection](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-instance-protection.html) in the *Amazon EC2 Auto Scaling User Guide*.
        :param 'NotificationConfigurationResponse' notification_configuration: A structure that specifies an Amazon SNS notification configuration for the ``NotificationConfigurations`` property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. For an example template snippet, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html). For more information, see [Get Amazon SNS notifications when your Auto Scaling group scales](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ASGettingNotifications.html) in the *Amazon EC2 Auto Scaling User Guide*.
        :param Sequence['NotificationConfigurationResponse'] notification_configurations: Configures an Auto Scaling group to send notifications when specified events take place.
        :param str placement_group: The name of the placement group into which to launch your instances. For more information, see [Placement groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html) in the *Amazon EC2 User Guide for Linux Instances*.  A *cluster* placement group is a logical grouping of instances within a single Availability Zone. You cannot specify multiple Availability Zones and a cluster placement group.
        :param str service_linked_role_arn: The Amazon Resource Name (ARN) of the service-linked role that the Auto Scaling group uses to call other AWS service on your behalf. By default, Amazon EC2 Auto Scaling uses a service-linked role named ``AWSServiceRoleForAutoScaling``, which it creates if it does not exist. For more information, see [Service-linked roles](https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-service-linked-role.html) in the *Amazon EC2 Auto Scaling User Guide*.
        :param Sequence['TagPropertyResponse'] tags: One or more tags. You can tag your Auto Scaling group and propagate the tags to the Amazon EC2 instances it launches. Tags are not propagated to Amazon EBS volumes. To add tags to Amazon EBS volumes, specify the tags in a launch template but use caution. If the launch template specifies an instance tag with a key that is also specified for the Auto Scaling group, Amazon EC2 Auto Scaling overrides the value of that instance tag with the value specified by the Auto Scaling group. For more information, see [Tag Auto Scaling groups and instances](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-tagging.html) in the *Amazon EC2 Auto Scaling User Guide*.
        :param Sequence[str] target_group_arns: The Amazon Resource Names (ARN) of the Elastic Load Balancing target groups to associate with the Auto Scaling group. Instances are registered as targets with the target groups. The target groups receive incoming traffic and route requests to one or more registered targets. For more information, see [Use Elastic Load Balancing to distribute traffic across the instances in your Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-load-balancer.html) in the *Amazon EC2 Auto Scaling User Guide*.
        :param Sequence[str] termination_policies: A policy or a list of policies that are used to select the instance to terminate. These policies are executed in the order that you list them. For more information, see [Work with Amazon EC2 Auto Scaling termination policies](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-termination-policies.html) in the *Amazon EC2 Auto Scaling User Guide*. Valid values: ``Default`` | ``AllocationStrategy`` | ``ClosestToNextInstanceHour`` | ``NewestInstance`` | ``OldestInstance`` | ``OldestLaunchConfiguration`` | ``OldestLaunchTemplate`` | ``arn:aws:lambda:region:account-id:function:my-function:my-alias``
        :param Sequence[str] vpc_zone_identifier: A list of subnet IDs for a virtual private cloud (VPC) where instances in the Auto Scaling group can be created. If this resource specifies public subnets and is also in a VPC that is defined in the same stack template, you must use the [DependsOn attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the [VPC-gateway attachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html).  When you update ``VPCZoneIdentifier``, this retains the same Auto Scaling group and replaces old instances with new ones, according to the specified subnets. You can optionally specify how CloudFormation handles these updates by using an [UpdatePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatepolicy.html).  Required to launch instances into a nondefault VPC. If you specify ``VPCZoneIdentifier`` with ``AvailabilityZones``, the subnets that you specify for this property must reside in those Availability Zones.
        """
        if auto_scaling_group_name is not None:
            pulumi.set(__self__, "auto_scaling_group_name", auto_scaling_group_name)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if default_instance_warmup is not None:
            pulumi.set(__self__, "default_instance_warmup", default_instance_warmup)
        if desired_capacity is not None:
            pulumi.set(__self__, "desired_capacity", desired_capacity)
        if desired_capacity_type is not None:
            pulumi.set(__self__, "desired_capacity_type", desired_capacity_type)
        if health_check_grace_period is not None:
            pulumi.set(__self__, "health_check_grace_period", health_check_grace_period)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_maintenance_policy is not None:
            pulumi.set(__self__, "instance_maintenance_policy", instance_maintenance_policy)
        if launch_configuration_name is not None:
            pulumi.set(__self__, "launch_configuration_name", launch_configuration_name)
        if launch_template is not None:
            pulumi.set(__self__, "launch_template", launch_template)
        if lifecycle_hook_specification_list is not None:
            pulumi.set(__self__, "lifecycle_hook_specification_list", lifecycle_hook_specification_list)
        if load_balancer_names is not None:
            pulumi.set(__self__, "load_balancer_names", load_balancer_names)
        if max_instance_lifetime is not None:
            pulumi.set(__self__, "max_instance_lifetime", max_instance_lifetime)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if metrics_collection is not None:
            pulumi.set(__self__, "metrics_collection", metrics_collection)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if mixed_instances_policy is not None:
            pulumi.set(__self__, "mixed_instances_policy", mixed_instances_policy)
        if new_instances_protected_from_scale_in is not None:
            pulumi.set(__self__, "new_instances_protected_from_scale_in", new_instances_protected_from_scale_in)
        if notification_configuration is not None:
            pulumi.set(__self__, "notification_configuration", notification_configuration)
        if notification_configurations is not None:
            pulumi.set(__self__, "notification_configurations", notification_configurations)
        if placement_group is not None:
            pulumi.set(__self__, "placement_group", placement_group)
        if service_linked_role_arn is not None:
            pulumi.set(__self__, "service_linked_role_arn", service_linked_role_arn)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if target_group_arns is not None:
            pulumi.set(__self__, "target_group_arns", target_group_arns)
        if termination_policies is not None:
            pulumi.set(__self__, "termination_policies", termination_policies)
        if vpc_zone_identifier is not None:
            pulumi.set(__self__, "vpc_zone_identifier", vpc_zone_identifier)

    @property
    @pulumi.getter(name="autoScalingGroupName")
    def auto_scaling_group_name(self) -> Optional[str]:
        """
        The name of the Auto Scaling group. This name must be unique per Region per account. The name can contain any ASCII character 33 to 126 including most punctuation characters, digits, and upper and lowercased letters.  You cannot use a colon (:) in the name.
        """
        return pulumi.get(self, "auto_scaling_group_name")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        """
        A list of Availability Zones where instances in the Auto Scaling group can be created. Used for launching into the default VPC subnet in each Availability Zone when not using the ``VPCZoneIdentifier`` property, or for attaching a network interface when an existing network interface ID is specified in a launch template.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional[bool]:
        """
        Indicates whether Capacity Rebalancing is enabled. Otherwise, Capacity Rebalancing is disabled. When you turn on Capacity Rebalancing, Amazon EC2 Auto Scaling attempts to launch a Spot Instance whenever Amazon EC2 notifies that a Spot Instance is at an elevated risk of interruption. After launching a new instance, it then terminates an old instance. For more information, see [Use Capacity Rebalancing to handle Amazon EC2 Spot Interruptions](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-capacity-rebalancing.html) in the in the *Amazon EC2 Auto Scaling User Guide*.
        """
        return pulumi.get(self, "capacity_rebalance")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        Reserved.
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[str]:
        """
        *Only needed if you use simple scaling policies.*  The amount of time, in seconds, between one scaling activity ending and another one starting due to simple scaling policies. For more information, see [Scaling cooldowns for Amazon EC2 Auto Scaling](https://docs.aws.amazon.com/autoscaling/ec2/userguide/Cooldown.html) in the *Amazon EC2 Auto Scaling User Guide*. Default: ``300`` seconds
        """
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter(name="defaultInstanceWarmup")
    def default_instance_warmup(self) -> Optional[int]:
        """
        The amount of time, in seconds, until a new instance is considered to have finished initializing and resource consumption to become stable after it enters the ``InService`` state.  During an instance refresh, Amazon EC2 Auto Scaling waits for the warm-up period after it replaces an instance before it moves on to replacing the next instance. Amazon EC2 Auto Scaling also waits for the warm-up period before aggregating the metrics for new instances with existing instances in the Amazon CloudWatch metrics that are used for scaling, resulting in more reliable usage data. For more information, see [Set the default instance warmup for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-default-instance-warmup.html) in the *Amazon EC2 Auto Scaling User Guide*.  To manage various warm-up settings at the group level, we recommend that you set the default instance warmup, *even if it is set to 0 seconds*. To remove a value that you previously set, include the property but specify ``-1`` for the value. However, we strongly recommend keeping the default instance warmup enabled by specifying a value of ``0`` or other nominal value.  Default: None
        """
        return pulumi.get(self, "default_instance_warmup")

    @property
    @pulumi.getter(name="desiredCapacity")
    def desired_capacity(self) -> Optional[str]:
        """
        The desired capacity is the initial capacity of the Auto Scaling group at the time of its creation and the capacity it attempts to maintain. It can scale beyond this capacity if you configure automatic scaling. The number must be greater than or equal to the minimum size of the group and less than or equal to the maximum size of the group. If you do not specify a desired capacity when creating the stack, the default is the minimum size of the group. CloudFormation marks the Auto Scaling group as successful (by setting its status to CREATE_COMPLETE) when the desired capacity is reached. However, if a maximum Spot price is set in the launch template or launch configuration that you specified, then desired capacity is not used as a criteria for success. Whether your request is fulfilled depends on Spot Instance capacity and your maximum price.
        """
        return pulumi.get(self, "desired_capacity")

    @property
    @pulumi.getter(name="desiredCapacityType")
    def desired_capacity_type(self) -> Optional[str]:
        """
        The unit of measurement for the value specified for desired capacity. Amazon EC2 Auto Scaling supports ``DesiredCapacityType`` for attribute-based instance type selection only. For more information, see [Creating an Auto Scaling group using attribute-based instance type selection](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-asg-instance-type-requirements.html) in the *Amazon EC2 Auto Scaling User Guide*. By default, Amazon EC2 Auto Scaling specifies ``units``, which translates into number of instances. Valid values: ``units`` | ``vcpu`` | ``memory-mib``
        """
        return pulumi.get(self, "desired_capacity_type")

    @property
    @pulumi.getter(name="healthCheckGracePeriod")
    def health_check_grace_period(self) -> Optional[int]:
        """
        The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before checking the health status of an EC2 instance that has come into service and marking it unhealthy due to a failed health check. This is useful if your instances do not immediately pass their health checks after they enter the ``InService`` state. For more information, see [Set the health check grace period for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/health-check-grace-period.html) in the *Amazon EC2 Auto Scaling User Guide*. Default: ``0`` seconds
        """
        return pulumi.get(self, "health_check_grace_period")

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[str]:
        """
        A comma-separated value string of one or more health check types. The valid values are ``EC2``, ``ELB``, and ``VPC_LATTICE``. ``EC2`` is the default health check and cannot be disabled. For more information, see [Health checks for Auto Scaling instances](https://docs.aws.amazon.com/autoscaling/ec2/userguide/healthcheck.html) in the *Amazon EC2 Auto Scaling User Guide*. Only specify ``EC2`` if you must clear a value that was previously set.
        """
        return pulumi.get(self, "health_check_type")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        The ID of the instance used to base the launch configuration on. For more information, see [Create an Auto Scaling group using an EC2 instance](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-asg-from-instance.html) in the *Amazon EC2 Auto Scaling User Guide*. If you specify ``LaunchTemplate``, ``MixedInstancesPolicy``, or ``LaunchConfigurationName``, don't specify ``InstanceId``.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceMaintenancePolicy")
    def instance_maintenance_policy(self) -> Optional['outputs.InstanceMaintenancePolicyResponse']:
        """
        An instance maintenance policy. For more information, see [Set instance maintenance policy](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-instance-maintenance-policy.html) in the *Amazon EC2 Auto Scaling User Guide*. ``InstanceMaintenancePolicy`` is a property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. For more information, see [Instance maintenance policies](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-instance-maintenance-policy.html) in the *Amazon EC2 Auto Scaling User Guide*.
        """
        return pulumi.get(self, "instance_maintenance_policy")

    @property
    @pulumi.getter(name="launchConfigurationName")
    def launch_configuration_name(self) -> Optional[str]:
        """
        The name of the launch configuration to use to launch instances. Required only if you don't specify ``LaunchTemplate``, ``MixedInstancesPolicy``, or ``InstanceId``.
        """
        return pulumi.get(self, "launch_configuration_name")

    @property
    @pulumi.getter(name="launchTemplate")
    def launch_template(self) -> Optional['outputs.LaunchTemplateSpecificationResponse']:
        """
        Information used to specify the launch template and version to use to launch instances. You can alternatively associate a launch template to the Auto Scaling group by specifying a ``MixedInstancesPolicy``. For more information about creating launch templates, see [Create a launch template for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html) in the *Amazon EC2 Auto Scaling User Guide*. If you omit this property, you must specify ``MixedInstancesPolicy``, ``LaunchConfigurationName``, or ``InstanceId``. Specifies a launch template to use when provisioning EC2 instances for an Auto Scaling group. You must specify the following:  +  The ID or the name of the launch template, but not both.  +  The version of the launch template.   ``LaunchTemplateSpecification`` is property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. It is also a property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplate.html) and [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property types. For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html) in the *Amazon EC2 Auto Scaling User Guide*. For examples of launch templates, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html) and the [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) section in the ``AWS::EC2::LaunchTemplate`` resource.
        """
        return pulumi.get(self, "launch_template")

    @property
    @pulumi.getter(name="lifecycleHookSpecificationList")
    def lifecycle_hook_specification_list(self) -> Optional[Sequence['outputs.LifecycleHookSpecificationResponse']]:
        """
        One or more lifecycle hooks to add to the Auto Scaling group before instances are launched.
        """
        return pulumi.get(self, "lifecycle_hook_specification_list")

    @property
    @pulumi.getter(name="loadBalancerNames")
    def load_balancer_names(self) -> Optional[Sequence[str]]:
        """
        A list of Classic Load Balancers associated with this Auto Scaling group. For Application Load Balancers, Network Load Balancers, and Gateway Load Balancers, specify the ``TargetGroupARNs`` property instead.
        """
        return pulumi.get(self, "load_balancer_names")

    @property
    @pulumi.getter(name="maxInstanceLifetime")
    def max_instance_lifetime(self) -> Optional[int]:
        """
        The maximum amount of time, in seconds, that an instance can be in service. The default is null. If specified, the value must be either 0 or a number equal to or greater than 86,400 seconds (1 day). For more information, see [Replacing Auto Scaling instances based on maximum instance lifetime](https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-max-instance-lifetime.html) in the *Amazon EC2 Auto Scaling User Guide*.
        """
        return pulumi.get(self, "max_instance_lifetime")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        """
        The maximum size of the group.  With a mixed instances policy that uses instance weighting, Amazon EC2 Auto Scaling may need to go above ``MaxSize`` to meet your capacity requirements. In this event, Amazon EC2 Auto Scaling will never go above ``MaxSize`` by more than your largest instance weight (weights that define how many units each instance contributes to the desired capacity of the group).
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="metricsCollection")
    def metrics_collection(self) -> Optional[Sequence['outputs.MetricsCollectionResponse']]:
        """
        Enables the monitoring of group metrics of an Auto Scaling group. By default, these metrics are disabled.
        """
        return pulumi.get(self, "metrics_collection")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[str]:
        """
        The minimum size of the group.
        """
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="mixedInstancesPolicy")
    def mixed_instances_policy(self) -> Optional['outputs.MixedInstancesPolicyResponse']:
        """
        An embedded object that specifies a mixed instances policy. The policy includes properties that not only define the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances (optional), and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacities, but also the properties that specify the instance configuration informationthe launch template and instance types. The policy can also include a weight for each instance type and different launch templates for individual instance types. For more information, see [Auto Scaling groups with multiple instance types and purchase options](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups.html) in the *Amazon EC2 Auto Scaling User Guide*. Use this structure to launch multiple instance types and On-Demand Instances and Spot Instances within a single Auto Scaling group. A mixed instances policy contains information that Amazon EC2 Auto Scaling can use to launch instances and help optimize your costs. For more information, see [Auto Scaling groups with multiple instance types and purchase options](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups.html) in the *Amazon EC2 Auto Scaling User Guide*. You can create a mixed instances policy for new and existing Auto Scaling groups. You must use a launch template to configure the policy. You cannot use a launch configuration. There are key differences between Spot Instances and On-Demand Instances:  +  The price for Spot Instances varies based on demand  +  Amazon EC2 can terminate an individual Spot Instance as the availability of, or price for, Spot Instances changes   When a Spot Instance is terminated, Amazon EC2 Auto Scaling group attempts to launch a replacement instance to maintain the desired capacity for the group.   ``MixedInstancesPolicy`` is a property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource.
        """
        return pulumi.get(self, "mixed_instances_policy")

    @property
    @pulumi.getter(name="newInstancesProtectedFromScaleIn")
    def new_instances_protected_from_scale_in(self) -> Optional[bool]:
        """
        Indicates whether newly launched instances are protected from termination by Amazon EC2 Auto Scaling when scaling in. For more information about preventing instances from terminating on scale in, see [Using instance scale-in protection](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-instance-protection.html) in the *Amazon EC2 Auto Scaling User Guide*.
        """
        return pulumi.get(self, "new_instances_protected_from_scale_in")

    @property
    @pulumi.getter(name="notificationConfiguration")
    def notification_configuration(self) -> Optional['outputs.NotificationConfigurationResponse']:
        """
        A structure that specifies an Amazon SNS notification configuration for the ``NotificationConfigurations`` property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. For an example template snippet, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html). For more information, see [Get Amazon SNS notifications when your Auto Scaling group scales](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ASGettingNotifications.html) in the *Amazon EC2 Auto Scaling User Guide*.
        """
        return pulumi.get(self, "notification_configuration")

    @property
    @pulumi.getter(name="notificationConfigurations")
    def notification_configurations(self) -> Optional[Sequence['outputs.NotificationConfigurationResponse']]:
        """
        Configures an Auto Scaling group to send notifications when specified events take place.
        """
        return pulumi.get(self, "notification_configurations")

    @property
    @pulumi.getter(name="placementGroup")
    def placement_group(self) -> Optional[str]:
        """
        The name of the placement group into which to launch your instances. For more information, see [Placement groups](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html) in the *Amazon EC2 User Guide for Linux Instances*.  A *cluster* placement group is a logical grouping of instances within a single Availability Zone. You cannot specify multiple Availability Zones and a cluster placement group.
        """
        return pulumi.get(self, "placement_group")

    @property
    @pulumi.getter(name="serviceLinkedRoleARN")
    def service_linked_role_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the service-linked role that the Auto Scaling group uses to call other AWS service on your behalf. By default, Amazon EC2 Auto Scaling uses a service-linked role named ``AWSServiceRoleForAutoScaling``, which it creates if it does not exist. For more information, see [Service-linked roles](https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-service-linked-role.html) in the *Amazon EC2 Auto Scaling User Guide*.
        """
        return pulumi.get(self, "service_linked_role_arn")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagPropertyResponse']]:
        """
        One or more tags. You can tag your Auto Scaling group and propagate the tags to the Amazon EC2 instances it launches. Tags are not propagated to Amazon EBS volumes. To add tags to Amazon EBS volumes, specify the tags in a launch template but use caution. If the launch template specifies an instance tag with a key that is also specified for the Auto Scaling group, Amazon EC2 Auto Scaling overrides the value of that instance tag with the value specified by the Auto Scaling group. For more information, see [Tag Auto Scaling groups and instances](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-tagging.html) in the *Amazon EC2 Auto Scaling User Guide*.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="targetGroupARNs")
    def target_group_arns(self) -> Optional[Sequence[str]]:
        """
        The Amazon Resource Names (ARN) of the Elastic Load Balancing target groups to associate with the Auto Scaling group. Instances are registered as targets with the target groups. The target groups receive incoming traffic and route requests to one or more registered targets. For more information, see [Use Elastic Load Balancing to distribute traffic across the instances in your Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-load-balancer.html) in the *Amazon EC2 Auto Scaling User Guide*.
        """
        return pulumi.get(self, "target_group_arns")

    @property
    @pulumi.getter(name="terminationPolicies")
    def termination_policies(self) -> Optional[Sequence[str]]:
        """
        A policy or a list of policies that are used to select the instance to terminate. These policies are executed in the order that you list them. For more information, see [Work with Amazon EC2 Auto Scaling termination policies](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-termination-policies.html) in the *Amazon EC2 Auto Scaling User Guide*. Valid values: ``Default`` | ``AllocationStrategy`` | ``ClosestToNextInstanceHour`` | ``NewestInstance`` | ``OldestInstance`` | ``OldestLaunchConfiguration`` | ``OldestLaunchTemplate`` | ``arn:aws:lambda:region:account-id:function:my-function:my-alias``
        """
        return pulumi.get(self, "termination_policies")

    @property
    @pulumi.getter(name="vpcZoneIdentifier")
    def vpc_zone_identifier(self) -> Optional[Sequence[str]]:
        """
        A list of subnet IDs for a virtual private cloud (VPC) where instances in the Auto Scaling group can be created. If this resource specifies public subnets and is also in a VPC that is defined in the same stack template, you must use the [DependsOn attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html) to declare a dependency on the [VPC-gateway attachment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html).  When you update ``VPCZoneIdentifier``, this retains the same Auto Scaling group and replaces old instances with new ones, according to the specified subnets. You can optionally specify how CloudFormation handles these updates by using an [UpdatePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatepolicy.html).  Required to launch instances into a nondefault VPC. If you specify ``VPCZoneIdentifier`` with ``AvailabilityZones``, the subnets that you specify for this property must reside in those Availability Zones.
        """
        return pulumi.get(self, "vpc_zone_identifier")


@pulumi.output_type
class AwsCloudFormationStackPropertiesResponse(dict):
    """
    Definition of awsCloudFormationStack
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeSetId":
            suggest = "change_set_id"
        elif key == "creationTime":
            suggest = "creation_time"
        elif key == "disableRollback":
            suggest = "disable_rollback"
        elif key == "enableTerminationProtection":
            suggest = "enable_termination_protection"
        elif key == "lastUpdateTime":
            suggest = "last_update_time"
        elif key == "notificationARNs":
            suggest = "notification_arns"
        elif key == "parentId":
            suggest = "parent_id"
        elif key == "roleARN":
            suggest = "role_arn"
        elif key == "rootId":
            suggest = "root_id"
        elif key == "stackId":
            suggest = "stack_id"
        elif key == "stackName":
            suggest = "stack_name"
        elif key == "stackPolicyBody":
            suggest = "stack_policy_body"
        elif key == "stackPolicyURL":
            suggest = "stack_policy_url"
        elif key == "stackStatus":
            suggest = "stack_status"
        elif key == "stackStatusReason":
            suggest = "stack_status_reason"
        elif key == "templateBody":
            suggest = "template_body"
        elif key == "templateURL":
            suggest = "template_url"
        elif key == "timeoutInMinutes":
            suggest = "timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudFormationStackPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudFormationStackPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudFormationStackPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capabilities: Optional[Sequence[str]] = None,
                 change_set_id: Optional[str] = None,
                 creation_time: Optional[str] = None,
                 description: Optional[str] = None,
                 disable_rollback: Optional[bool] = None,
                 enable_termination_protection: Optional[bool] = None,
                 last_update_time: Optional[str] = None,
                 notification_arns: Optional[Sequence[str]] = None,
                 outputs: Optional[Sequence['outputs.OutputResponse']] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 parent_id: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 root_id: Optional[str] = None,
                 stack_id: Optional[str] = None,
                 stack_name: Optional[str] = None,
                 stack_policy_body: Optional[Any] = None,
                 stack_policy_url: Optional[str] = None,
                 stack_status: Optional[str] = None,
                 stack_status_reason: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 template_body: Optional[Any] = None,
                 template_url: Optional[str] = None,
                 timeout_in_minutes: Optional[int] = None):
        """
        Definition of awsCloudFormationStack
        :param Sequence[str] capabilities: Property capabilities
        :param str change_set_id: Property changeSetId
        :param str creation_time: Property creationTime
        :param str description: Property description
        :param bool disable_rollback: Property disableRollback
        :param bool enable_termination_protection: Property enableTerminationProtection
        :param str last_update_time: Property lastUpdateTime
        :param Sequence[str] notification_arns: Property notificationARNs
        :param Sequence['OutputResponse'] outputs: Property outputs
        :param Mapping[str, str] parameters: Property parameters
        :param str parent_id: Property parentId
        :param str role_arn: Property roleARN
        :param str root_id: Property rootId
        :param str stack_id: Property stackId
        :param str stack_name: Property stackName
        :param Any stack_policy_body: Property stackPolicyBody
        :param str stack_policy_url: Property stackPolicyURL
        :param str stack_status: Property stackStatus
        :param str stack_status_reason: Property stackStatusReason
        :param Sequence['TagResponse'] tags: Property tags
        :param Any template_body: Property templateBody
        :param str template_url: Property templateURL
        :param int timeout_in_minutes: Property timeoutInMinutes
        """
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if change_set_id is not None:
            pulumi.set(__self__, "change_set_id", change_set_id)
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_rollback is not None:
            pulumi.set(__self__, "disable_rollback", disable_rollback)
        if enable_termination_protection is not None:
            pulumi.set(__self__, "enable_termination_protection", enable_termination_protection)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if notification_arns is not None:
            pulumi.set(__self__, "notification_arns", notification_arns)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if parent_id is not None:
            pulumi.set(__self__, "parent_id", parent_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if root_id is not None:
            pulumi.set(__self__, "root_id", root_id)
        if stack_id is not None:
            pulumi.set(__self__, "stack_id", stack_id)
        if stack_name is not None:
            pulumi.set(__self__, "stack_name", stack_name)
        if stack_policy_body is not None:
            pulumi.set(__self__, "stack_policy_body", stack_policy_body)
        if stack_policy_url is not None:
            pulumi.set(__self__, "stack_policy_url", stack_policy_url)
        if stack_status is not None:
            pulumi.set(__self__, "stack_status", stack_status)
        if stack_status_reason is not None:
            pulumi.set(__self__, "stack_status_reason", stack_status_reason)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if template_body is not None:
            pulumi.set(__self__, "template_body", template_body)
        if template_url is not None:
            pulumi.set(__self__, "template_url", template_url)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence[str]]:
        """
        Property capabilities
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter(name="changeSetId")
    def change_set_id(self) -> Optional[str]:
        """
        Property changeSetId
        """
        return pulumi.get(self, "change_set_id")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[str]:
        """
        Property creationTime
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Property description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="disableRollback")
    def disable_rollback(self) -> Optional[bool]:
        """
        Property disableRollback
        """
        return pulumi.get(self, "disable_rollback")

    @property
    @pulumi.getter(name="enableTerminationProtection")
    def enable_termination_protection(self) -> Optional[bool]:
        """
        Property enableTerminationProtection
        """
        return pulumi.get(self, "enable_termination_protection")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        Property lastUpdateTime
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter(name="notificationARNs")
    def notification_arns(self) -> Optional[Sequence[str]]:
        """
        Property notificationARNs
        """
        return pulumi.get(self, "notification_arns")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Sequence['outputs.OutputResponse']]:
        """
        Property outputs
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        """
        Property parameters
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[str]:
        """
        Property parentId
        """
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="roleARN")
    def role_arn(self) -> Optional[str]:
        """
        Property roleARN
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="rootId")
    def root_id(self) -> Optional[str]:
        """
        Property rootId
        """
        return pulumi.get(self, "root_id")

    @property
    @pulumi.getter(name="stackId")
    def stack_id(self) -> Optional[str]:
        """
        Property stackId
        """
        return pulumi.get(self, "stack_id")

    @property
    @pulumi.getter(name="stackName")
    def stack_name(self) -> Optional[str]:
        """
        Property stackName
        """
        return pulumi.get(self, "stack_name")

    @property
    @pulumi.getter(name="stackPolicyBody")
    def stack_policy_body(self) -> Optional[Any]:
        """
        Property stackPolicyBody
        """
        return pulumi.get(self, "stack_policy_body")

    @property
    @pulumi.getter(name="stackPolicyURL")
    def stack_policy_url(self) -> Optional[str]:
        """
        Property stackPolicyURL
        """
        return pulumi.get(self, "stack_policy_url")

    @property
    @pulumi.getter(name="stackStatus")
    def stack_status(self) -> Optional[str]:
        """
        Property stackStatus
        """
        return pulumi.get(self, "stack_status")

    @property
    @pulumi.getter(name="stackStatusReason")
    def stack_status_reason(self) -> Optional[str]:
        """
        Property stackStatusReason
        """
        return pulumi.get(self, "stack_status_reason")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="templateBody")
    def template_body(self) -> Optional[Any]:
        """
        Property templateBody
        """
        return pulumi.get(self, "template_body")

    @property
    @pulumi.getter(name="templateURL")
    def template_url(self) -> Optional[str]:
        """
        Property templateURL
        """
        return pulumi.get(self, "template_url")

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[int]:
        """
        Property timeoutInMinutes
        """
        return pulumi.get(self, "timeout_in_minutes")


@pulumi.output_type
class AwsCloudFormationStackSetPropertiesResponse(dict):
    """
    Definition of awsCloudFormationStackSet
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "administrationRoleARN":
            suggest = "administration_role_arn"
        elif key == "autoDeployment":
            suggest = "auto_deployment"
        elif key == "callAs":
            suggest = "call_as"
        elif key == "executionRoleName":
            suggest = "execution_role_name"
        elif key == "managedExecution":
            suggest = "managed_execution"
        elif key == "operationPreferences":
            suggest = "operation_preferences"
        elif key == "permissionModel":
            suggest = "permission_model"
        elif key == "stackInstancesGroup":
            suggest = "stack_instances_group"
        elif key == "stackSetId":
            suggest = "stack_set_id"
        elif key == "stackSetName":
            suggest = "stack_set_name"
        elif key == "templateBody":
            suggest = "template_body"
        elif key == "templateURL":
            suggest = "template_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudFormationStackSetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudFormationStackSetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudFormationStackSetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 administration_role_arn: Optional[str] = None,
                 auto_deployment: Optional['outputs.AutoDeploymentResponse'] = None,
                 call_as: Optional[str] = None,
                 capabilities: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 execution_role_name: Optional[str] = None,
                 managed_execution: Optional['outputs.ActiveModelResponse'] = None,
                 operation_preferences: Optional['outputs.OperationPreferencesResponse'] = None,
                 parameters: Optional[Sequence['outputs.ParameterResponse']] = None,
                 permission_model: Optional[str] = None,
                 stack_instances_group: Optional[Sequence['outputs.StackInstancesResponse']] = None,
                 stack_set_id: Optional[str] = None,
                 stack_set_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 template_body: Optional[str] = None,
                 template_url: Optional[str] = None):
        """
        Definition of awsCloudFormationStackSet
        :param str administration_role_arn: The Amazon Resource Number (ARN) of the IAM role to use to create this stack set. Specify an IAM role only if you are using customized administrator roles to control which users or groups can manage specific stack sets within the same administrator account.
        :param 'AutoDeploymentResponse' auto_deployment: Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to the target organization or organizational unit (OU). Specify only if PermissionModel is SERVICE_MANAGED.
        :param str call_as: Specifies the AWS account that you are acting from. By default, SELF is specified. For self-managed permissions, specify SELF; for service-managed permissions, if you are signed in to the organization's management account, specify SELF. If you are signed in to a delegated administrator account, specify DELEGATED_ADMIN.
        :param Sequence[str] capabilities: In some cases, you must explicitly acknowledge that your stack set template contains certain capabilities in order for AWS CloudFormation to create the stack set and related stack instances.
        :param str description: A description of the stack set. You can use the description to identify the stack set's purpose or other important information.
        :param str execution_role_name: The name of the IAM execution role to use to create the stack set. If you do not specify an execution role, AWS CloudFormation uses the AWSCloudFormationStackSetExecutionRole role for the stack set operation.
        :param 'ActiveModelResponse' managed_execution: Describes whether StackSets performs non-conflicting operations concurrently and queues conflicting operations.
        :param 'OperationPreferencesResponse' operation_preferences: The user-specified preferences for how AWS CloudFormation performs a stack set operation.
        :param Sequence['ParameterResponse'] parameters: The input parameters for the stack set template.
        :param str permission_model: Describes how the IAM roles required for stack set operations are created. By default, SELF-MANAGED is specified.
        :param Sequence['StackInstancesResponse'] stack_instances_group: A group of stack instances with parameters in some specific accounts and regions.
        :param str stack_set_id: The ID of the stack set that you're creating.
        :param str stack_set_name: The name to associate with the stack set. The name must be unique in the Region where you create your stack set.
        :param Sequence['TagResponse'] tags: The key-value pairs to associate with this stack set and the stacks created from it. AWS CloudFormation also propagates these tags to supported resources that are created in the stacks. A maximum number of 50 tags can be specified.
        :param str template_body: The structure that contains the template body, with a minimum length of 1 byte and a maximum length of 51,200 bytes.
        :param str template_url: Location of file containing the template body. The URL must point to a template (max size: 460,800 bytes) that is located in an Amazon S3 bucket.
        """
        if administration_role_arn is not None:
            pulumi.set(__self__, "administration_role_arn", administration_role_arn)
        if auto_deployment is not None:
            pulumi.set(__self__, "auto_deployment", auto_deployment)
        if call_as is not None:
            pulumi.set(__self__, "call_as", call_as)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if execution_role_name is not None:
            pulumi.set(__self__, "execution_role_name", execution_role_name)
        if managed_execution is not None:
            pulumi.set(__self__, "managed_execution", managed_execution)
        if operation_preferences is not None:
            pulumi.set(__self__, "operation_preferences", operation_preferences)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if permission_model is not None:
            pulumi.set(__self__, "permission_model", permission_model)
        if stack_instances_group is not None:
            pulumi.set(__self__, "stack_instances_group", stack_instances_group)
        if stack_set_id is not None:
            pulumi.set(__self__, "stack_set_id", stack_set_id)
        if stack_set_name is not None:
            pulumi.set(__self__, "stack_set_name", stack_set_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if template_body is not None:
            pulumi.set(__self__, "template_body", template_body)
        if template_url is not None:
            pulumi.set(__self__, "template_url", template_url)

    @property
    @pulumi.getter(name="administrationRoleARN")
    def administration_role_arn(self) -> Optional[str]:
        """
        The Amazon Resource Number (ARN) of the IAM role to use to create this stack set. Specify an IAM role only if you are using customized administrator roles to control which users or groups can manage specific stack sets within the same administrator account.
        """
        return pulumi.get(self, "administration_role_arn")

    @property
    @pulumi.getter(name="autoDeployment")
    def auto_deployment(self) -> Optional['outputs.AutoDeploymentResponse']:
        """
        Describes whether StackSets automatically deploys to AWS Organizations accounts that are added to the target organization or organizational unit (OU). Specify only if PermissionModel is SERVICE_MANAGED.
        """
        return pulumi.get(self, "auto_deployment")

    @property
    @pulumi.getter(name="callAs")
    def call_as(self) -> Optional[str]:
        """
        Specifies the AWS account that you are acting from. By default, SELF is specified. For self-managed permissions, specify SELF; for service-managed permissions, if you are signed in to the organization's management account, specify SELF. If you are signed in to a delegated administrator account, specify DELEGATED_ADMIN.
        """
        return pulumi.get(self, "call_as")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence[str]]:
        """
        In some cases, you must explicitly acknowledge that your stack set template contains certain capabilities in order for AWS CloudFormation to create the stack set and related stack instances.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the stack set. You can use the description to identify the stack set's purpose or other important information.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="executionRoleName")
    def execution_role_name(self) -> Optional[str]:
        """
        The name of the IAM execution role to use to create the stack set. If you do not specify an execution role, AWS CloudFormation uses the AWSCloudFormationStackSetExecutionRole role for the stack set operation.
        """
        return pulumi.get(self, "execution_role_name")

    @property
    @pulumi.getter(name="managedExecution")
    def managed_execution(self) -> Optional['outputs.ActiveModelResponse']:
        """
        Describes whether StackSets performs non-conflicting operations concurrently and queues conflicting operations.
        """
        return pulumi.get(self, "managed_execution")

    @property
    @pulumi.getter(name="operationPreferences")
    def operation_preferences(self) -> Optional['outputs.OperationPreferencesResponse']:
        """
        The user-specified preferences for how AWS CloudFormation performs a stack set operation.
        """
        return pulumi.get(self, "operation_preferences")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.ParameterResponse']]:
        """
        The input parameters for the stack set template.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="permissionModel")
    def permission_model(self) -> Optional[str]:
        """
        Describes how the IAM roles required for stack set operations are created. By default, SELF-MANAGED is specified.
        """
        return pulumi.get(self, "permission_model")

    @property
    @pulumi.getter(name="stackInstancesGroup")
    def stack_instances_group(self) -> Optional[Sequence['outputs.StackInstancesResponse']]:
        """
        A group of stack instances with parameters in some specific accounts and regions.
        """
        return pulumi.get(self, "stack_instances_group")

    @property
    @pulumi.getter(name="stackSetId")
    def stack_set_id(self) -> Optional[str]:
        """
        The ID of the stack set that you're creating.
        """
        return pulumi.get(self, "stack_set_id")

    @property
    @pulumi.getter(name="stackSetName")
    def stack_set_name(self) -> Optional[str]:
        """
        The name to associate with the stack set. The name must be unique in the Region where you create your stack set.
        """
        return pulumi.get(self, "stack_set_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The key-value pairs to associate with this stack set and the stacks created from it. AWS CloudFormation also propagates these tags to supported resources that are created in the stacks. A maximum number of 50 tags can be specified.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="templateBody")
    def template_body(self) -> Optional[str]:
        """
        The structure that contains the template body, with a minimum length of 1 byte and a maximum length of 51,200 bytes.
        """
        return pulumi.get(self, "template_body")

    @property
    @pulumi.getter(name="templateURL")
    def template_url(self) -> Optional[str]:
        """
        Location of file containing the template body. The URL must point to a template (max size: 460,800 bytes) that is located in an Amazon S3 bucket.
        """
        return pulumi.get(self, "template_url")


@pulumi.output_type
class AwsCloudFrontDistributionPropertiesResponse(dict):
    """
    Definition of awsCloudFrontDistribution
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionConfig":
            suggest = "distribution_config"
        elif key == "domainName":
            suggest = "domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudFrontDistributionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudFrontDistributionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudFrontDistributionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_config: Optional['outputs.DistributionConfigResponse'] = None,
                 domain_name: Optional[str] = None,
                 id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsCloudFrontDistribution
        :param 'DistributionConfigResponse' distribution_config: The distribution's configuration. A distribution configuration.
        :param str domain_name: Property domainName
        :param str id: Property id
        :param Sequence['TagResponse'] tags: A complex type that contains zero or more ``Tag`` elements.
        """
        if distribution_config is not None:
            pulumi.set(__self__, "distribution_config", distribution_config)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="distributionConfig")
    def distribution_config(self) -> Optional['outputs.DistributionConfigResponse']:
        """
        The distribution's configuration. A distribution configuration.
        """
        return pulumi.get(self, "distribution_config")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        Property domainName
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        A complex type that contains zero or more ``Tag`` elements.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsCloudTrailTrailPropertiesResponse(dict):
    """
    Definition of awsCloudTrailTrail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedEventSelectors":
            suggest = "advanced_event_selectors"
        elif key == "cloudWatchLogsLogGroupArn":
            suggest = "cloud_watch_logs_log_group_arn"
        elif key == "cloudWatchLogsRoleArn":
            suggest = "cloud_watch_logs_role_arn"
        elif key == "enableLogFileValidation":
            suggest = "enable_log_file_validation"
        elif key == "eventSelectors":
            suggest = "event_selectors"
        elif key == "includeGlobalServiceEvents":
            suggest = "include_global_service_events"
        elif key == "insightSelectors":
            suggest = "insight_selectors"
        elif key == "isLogging":
            suggest = "is_logging"
        elif key == "isMultiRegionTrail":
            suggest = "is_multi_region_trail"
        elif key == "isOrganizationTrail":
            suggest = "is_organization_trail"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3KeyPrefix":
            suggest = "s3_key_prefix"
        elif key == "snsTopicArn":
            suggest = "sns_topic_arn"
        elif key == "snsTopicName":
            suggest = "sns_topic_name"
        elif key == "trailName":
            suggest = "trail_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudTrailTrailPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudTrailTrailPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudTrailTrailPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_event_selectors: Optional[Sequence['outputs.AdvancedEventSelectorResponse']] = None,
                 arn: Optional[str] = None,
                 cloud_watch_logs_log_group_arn: Optional[str] = None,
                 cloud_watch_logs_role_arn: Optional[str] = None,
                 enable_log_file_validation: Optional[bool] = None,
                 event_selectors: Optional[Sequence['outputs.EventSelectorResponse']] = None,
                 include_global_service_events: Optional[bool] = None,
                 insight_selectors: Optional[Sequence['outputs.InsightSelectorResponse']] = None,
                 is_logging: Optional[bool] = None,
                 is_multi_region_trail: Optional[bool] = None,
                 is_organization_trail: Optional[bool] = None,
                 kms_key_id: Optional[str] = None,
                 s3_bucket_name: Optional[str] = None,
                 s3_key_prefix: Optional[str] = None,
                 sns_topic_arn: Optional[str] = None,
                 sns_topic_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 trail_name: Optional[str] = None):
        """
        Definition of awsCloudTrailTrail
        :param Sequence['AdvancedEventSelectorResponse'] advanced_event_selectors: The advanced event selectors that were used to select events for the data store.
        :param str arn: Property arn
        :param str cloud_watch_logs_log_group_arn: Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered. Not required unless you specify CloudWatchLogsRoleArn.
        :param str cloud_watch_logs_role_arn: Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
        :param bool enable_log_file_validation: Specifies whether log file validation is enabled. The default is false.
        :param Sequence['EventSelectorResponse'] event_selectors: Use event selectors to further specify the management and data event settings for your trail. By default, trails created without specific event selectors will be configured to log all read and write management events, and no data events. When an event occurs in your account, CloudTrail evaluates the event selector for all trails. For each trail, if the event matches any event selector, the trail processes and logs the event. If the event doesn't match any event selector, the trail doesn't log the event. You can configure up to five event selectors for a trail.
        :param bool include_global_service_events: Specifies whether the trail is publishing events from global services such as IAM to the log files.
        :param Sequence['InsightSelectorResponse'] insight_selectors: Lets you enable Insights event logging by specifying the Insights selectors that you want to enable on an existing trail.
        :param bool is_logging: Whether the CloudTrail is currently logging AWS API calls.
        :param bool is_multi_region_trail: Specifies whether the trail applies only to the current region or to all regions. The default is false. If the trail exists only in the current region and this value is set to true, shadow trails (replications of the trail) will be created in the other regions. If the trail exists in all regions and this value is set to false, the trail will remain in the region where it was created, and its shadow trails in other regions will be deleted. As a best practice, consider using trails that log events in all regions.
        :param bool is_organization_trail: Specifies whether the trail is created for all accounts in an organization in AWS Organizations, or only for the current AWS account. The default is false, and cannot be true unless the call is made on behalf of an AWS account that is the master account for an organization in AWS Organizations.
        :param str kms_key_id: Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by 'alias/', a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier.
        :param str s3_bucket_name: Specifies the name of the Amazon S3 bucket designated for publishing log files. See Amazon S3 Bucket Naming Requirements.
        :param str s3_key_prefix: Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see Finding Your CloudTrail Log Files. The maximum length is 200 characters.
        :param str sns_topic_arn: Property snsTopicArn
        :param str sns_topic_name: Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
        :param Sequence['TagResponse'] tags: Property tags
        :param str trail_name: Property trailName
        """
        if advanced_event_selectors is not None:
            pulumi.set(__self__, "advanced_event_selectors", advanced_event_selectors)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if cloud_watch_logs_log_group_arn is not None:
            pulumi.set(__self__, "cloud_watch_logs_log_group_arn", cloud_watch_logs_log_group_arn)
        if cloud_watch_logs_role_arn is not None:
            pulumi.set(__self__, "cloud_watch_logs_role_arn", cloud_watch_logs_role_arn)
        if enable_log_file_validation is not None:
            pulumi.set(__self__, "enable_log_file_validation", enable_log_file_validation)
        if event_selectors is not None:
            pulumi.set(__self__, "event_selectors", event_selectors)
        if include_global_service_events is not None:
            pulumi.set(__self__, "include_global_service_events", include_global_service_events)
        if insight_selectors is not None:
            pulumi.set(__self__, "insight_selectors", insight_selectors)
        if is_logging is not None:
            pulumi.set(__self__, "is_logging", is_logging)
        if is_multi_region_trail is not None:
            pulumi.set(__self__, "is_multi_region_trail", is_multi_region_trail)
        if is_organization_trail is not None:
            pulumi.set(__self__, "is_organization_trail", is_organization_trail)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)
        if sns_topic_arn is not None:
            pulumi.set(__self__, "sns_topic_arn", sns_topic_arn)
        if sns_topic_name is not None:
            pulumi.set(__self__, "sns_topic_name", sns_topic_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if trail_name is not None:
            pulumi.set(__self__, "trail_name", trail_name)

    @property
    @pulumi.getter(name="advancedEventSelectors")
    def advanced_event_selectors(self) -> Optional[Sequence['outputs.AdvancedEventSelectorResponse']]:
        """
        The advanced event selectors that were used to select events for the data store.
        """
        return pulumi.get(self, "advanced_event_selectors")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="cloudWatchLogsLogGroupArn")
    def cloud_watch_logs_log_group_arn(self) -> Optional[str]:
        """
        Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered. Not required unless you specify CloudWatchLogsRoleArn.
        """
        return pulumi.get(self, "cloud_watch_logs_log_group_arn")

    @property
    @pulumi.getter(name="cloudWatchLogsRoleArn")
    def cloud_watch_logs_role_arn(self) -> Optional[str]:
        """
        Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
        """
        return pulumi.get(self, "cloud_watch_logs_role_arn")

    @property
    @pulumi.getter(name="enableLogFileValidation")
    def enable_log_file_validation(self) -> Optional[bool]:
        """
        Specifies whether log file validation is enabled. The default is false.
        """
        return pulumi.get(self, "enable_log_file_validation")

    @property
    @pulumi.getter(name="eventSelectors")
    def event_selectors(self) -> Optional[Sequence['outputs.EventSelectorResponse']]:
        """
        Use event selectors to further specify the management and data event settings for your trail. By default, trails created without specific event selectors will be configured to log all read and write management events, and no data events. When an event occurs in your account, CloudTrail evaluates the event selector for all trails. For each trail, if the event matches any event selector, the trail processes and logs the event. If the event doesn't match any event selector, the trail doesn't log the event. You can configure up to five event selectors for a trail.
        """
        return pulumi.get(self, "event_selectors")

    @property
    @pulumi.getter(name="includeGlobalServiceEvents")
    def include_global_service_events(self) -> Optional[bool]:
        """
        Specifies whether the trail is publishing events from global services such as IAM to the log files.
        """
        return pulumi.get(self, "include_global_service_events")

    @property
    @pulumi.getter(name="insightSelectors")
    def insight_selectors(self) -> Optional[Sequence['outputs.InsightSelectorResponse']]:
        """
        Lets you enable Insights event logging by specifying the Insights selectors that you want to enable on an existing trail.
        """
        return pulumi.get(self, "insight_selectors")

    @property
    @pulumi.getter(name="isLogging")
    def is_logging(self) -> Optional[bool]:
        """
        Whether the CloudTrail is currently logging AWS API calls.
        """
        return pulumi.get(self, "is_logging")

    @property
    @pulumi.getter(name="isMultiRegionTrail")
    def is_multi_region_trail(self) -> Optional[bool]:
        """
        Specifies whether the trail applies only to the current region or to all regions. The default is false. If the trail exists only in the current region and this value is set to true, shadow trails (replications of the trail) will be created in the other regions. If the trail exists in all regions and this value is set to false, the trail will remain in the region where it was created, and its shadow trails in other regions will be deleted. As a best practice, consider using trails that log events in all regions.
        """
        return pulumi.get(self, "is_multi_region_trail")

    @property
    @pulumi.getter(name="isOrganizationTrail")
    def is_organization_trail(self) -> Optional[bool]:
        """
        Specifies whether the trail is created for all accounts in an organization in AWS Organizations, or only for the current AWS account. The default is false, and cannot be true unless the call is made on behalf of an AWS account that is the master account for an organization in AWS Organizations.
        """
        return pulumi.get(self, "is_organization_trail")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by 'alias/', a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[str]:
        """
        Specifies the name of the Amazon S3 bucket designated for publishing log files. See Amazon S3 Bucket Naming Requirements.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[str]:
        """
        Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see Finding Your CloudTrail Log Files. The maximum length is 200 characters.
        """
        return pulumi.get(self, "s3_key_prefix")

    @property
    @pulumi.getter(name="snsTopicArn")
    def sns_topic_arn(self) -> Optional[str]:
        """
        Property snsTopicArn
        """
        return pulumi.get(self, "sns_topic_arn")

    @property
    @pulumi.getter(name="snsTopicName")
    def sns_topic_name(self) -> Optional[str]:
        """
        Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
        """
        return pulumi.get(self, "sns_topic_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="trailName")
    def trail_name(self) -> Optional[str]:
        """
        Property trailName
        """
        return pulumi.get(self, "trail_name")


@pulumi.output_type
class AwsCloudWatchAlarmPropertiesResponse(dict):
    """
    Definition of awsCloudWatchAlarm
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsEnabled":
            suggest = "actions_enabled"
        elif key == "alarmActions":
            suggest = "alarm_actions"
        elif key == "alarmDescription":
            suggest = "alarm_description"
        elif key == "alarmName":
            suggest = "alarm_name"
        elif key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "datapointsToAlarm":
            suggest = "datapoints_to_alarm"
        elif key == "evaluateLowSampleCountPercentile":
            suggest = "evaluate_low_sample_count_percentile"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "extendedStatistic":
            suggest = "extended_statistic"
        elif key == "insufficientDataActions":
            suggest = "insufficient_data_actions"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "okActions":
            suggest = "ok_actions"
        elif key == "thresholdMetricId":
            suggest = "threshold_metric_id"
        elif key == "treatMissingData":
            suggest = "treat_missing_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudWatchAlarmPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudWatchAlarmPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudWatchAlarmPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_enabled: Optional[bool] = None,
                 alarm_actions: Optional[Sequence[str]] = None,
                 alarm_description: Optional[str] = None,
                 alarm_name: Optional[str] = None,
                 arn: Optional[str] = None,
                 comparison_operator: Optional[str] = None,
                 datapoints_to_alarm: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.DimensionResponse']] = None,
                 evaluate_low_sample_count_percentile: Optional[str] = None,
                 evaluation_periods: Optional[int] = None,
                 extended_statistic: Optional[str] = None,
                 insufficient_data_actions: Optional[Sequence[str]] = None,
                 metric_name: Optional[str] = None,
                 metrics: Optional[Sequence['outputs.MetricDataQueryResponse']] = None,
                 namespace: Optional[str] = None,
                 ok_actions: Optional[Sequence[str]] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 threshold: Optional[float] = None,
                 threshold_metric_id: Optional[str] = None,
                 treat_missing_data: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        Definition of awsCloudWatchAlarm
        :param bool actions_enabled: Indicates whether actions should be executed during any changes to the alarm state. The default is TRUE.
        :param Sequence[str] alarm_actions: The list of actions to execute when this alarm transitions into an ALARM state from any other state. Specify each action as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see [PutMetricAlarm](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutMetricAlarm.html) in the *API Reference*.
        :param str alarm_description: The description of the alarm.
        :param str alarm_name: The name of the alarm. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the alarm name.   If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        :param str arn: Property arn
        :param str comparison_operator: The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand.
        :param int datapoints_to_alarm: The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an 'M out of N' alarm. In that case, this value is the M, and the value that you set for ``EvaluationPeriods`` is the N value. For more information, see [Evaluating an Alarm](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation) in the *User Guide*. If you omit this parameter, CW uses the same value here that you set for ``EvaluationPeriods``, and the alarm goes to alarm state if that many consecutive periods are breaching.
        :param Sequence['DimensionResponse'] dimensions: The dimensions for the metric associated with the alarm. For an alarm based on a math expression, you can't specify ``Dimensions``. Instead, you use ``Metrics``.
        :param str evaluate_low_sample_count_percentile: Used only for alarms based on percentiles. If ``ignore``, the alarm state does not change during periods with too few data points to be statistically significant. If ``evaluate`` or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available.
        :param int evaluation_periods: The number of periods over which data is compared to the specified threshold. If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies that number. If you are setting an 'M out of N' alarm, this value is the N, and ``DatapointsToAlarm`` is the M. For more information, see [Evaluating an Alarm](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation) in the *User Guide*.
        :param str extended_statistic: The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100. For an alarm based on a metric, you must specify either ``Statistic`` or ``ExtendedStatistic`` but not both. For an alarm based on a math expression, you can't specify ``ExtendedStatistic``. Instead, you use ``Metrics``.
        :param Sequence[str] insufficient_data_actions: The actions to execute when this alarm transitions to the ``INSUFFICIENT_DATA`` state from any other state. Each action is specified as an Amazon Resource Name (ARN).
        :param str metric_name: The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use ``Metrics`` instead and you can't specify ``MetricName``.
        :param Sequence['MetricDataQueryResponse'] metrics: An array that enables you to create an alarm based on the result of a metric math expression. Each item in the array either retrieves a metric or performs a math expression. If you specify the ``Metrics`` parameter, you cannot specify ``MetricName``, ``Dimensions``, ``Period``, ``Namespace``, ``Statistic``, ``ExtendedStatistic``, or ``Unit``.
        :param str namespace: The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify ``Namespace`` and you use ``Metrics`` instead. For a list of namespaces for metrics from AWS services, see [Services That Publish Metrics.](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/aws-services-cloudwatch-metrics.html)
        :param Sequence[str] ok_actions: The actions to execute when this alarm transitions to the ``OK`` state from any other state. Each action is specified as an Amazon Resource Name (ARN).
        :param int period: The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. Valid values are 10, 30, 60, and any multiple of 60. For an alarm based on a math expression, you can't specify ``Period``, and instead you use the ``Metrics`` parameter. *Minimum:* 10
        :param str statistic: The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ``ExtendedStatistic``. For an alarm based on a metric, you must specify either ``Statistic`` or ``ExtendedStatistic`` but not both. For an alarm based on a math expression, you can't specify ``Statistic``. Instead, you use ``Metrics``.
        :param Sequence['TagResponse'] tags: Property tags
        :param float threshold: The value to compare with the specified statistic.
        :param str threshold_metric_id: In an alarm based on an anomaly detection model, this is the ID of the ``ANOMALY_DETECTION_BAND`` function used as the threshold for the alarm.
        :param str treat_missing_data: Sets how this alarm is to handle missing data points. Valid values are ``breaching``, ``notBreaching``, ``ignore``, and ``missing``. For more information, see [Configuring How Alarms Treat Missing Data](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarms-and-missing-data) in the *Amazon User Guide*. If you omit this parameter, the default behavior of ``missing`` is used.
        :param str unit: The unit of the metric associated with the alarm. Specify this only if you are creating an alarm based on a single metric. Do not specify this if you are specifying a ``Metrics`` array.  You can specify the following values: Seconds, Microseconds, Milliseconds, Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes, Bits, Kilobits, Megabits, Gigabits, Terabits, Percent, Count, Bytes/Second, Kilobytes/Second, Megabytes/Second, Gigabytes/Second, Terabytes/Second, Bits/Second, Kilobits/Second, Megabits/Second, Gigabits/Second, Terabits/Second, Count/Second, or None.
        """
        if actions_enabled is None:
            actions_enabled = True
        if actions_enabled is not None:
            pulumi.set(__self__, "actions_enabled", actions_enabled)
        if alarm_actions is not None:
            pulumi.set(__self__, "alarm_actions", alarm_actions)
        if alarm_description is not None:
            pulumi.set(__self__, "alarm_description", alarm_description)
        if alarm_name is not None:
            pulumi.set(__self__, "alarm_name", alarm_name)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if datapoints_to_alarm is not None:
            pulumi.set(__self__, "datapoints_to_alarm", datapoints_to_alarm)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluate_low_sample_count_percentile is not None:
            pulumi.set(__self__, "evaluate_low_sample_count_percentile", evaluate_low_sample_count_percentile)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if extended_statistic is not None:
            pulumi.set(__self__, "extended_statistic", extended_statistic)
        if insufficient_data_actions is not None:
            pulumi.set(__self__, "insufficient_data_actions", insufficient_data_actions)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if ok_actions is not None:
            pulumi.set(__self__, "ok_actions", ok_actions)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_metric_id is not None:
            pulumi.set(__self__, "threshold_metric_id", threshold_metric_id)
        if treat_missing_data is not None:
            pulumi.set(__self__, "treat_missing_data", treat_missing_data)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="actionsEnabled")
    def actions_enabled(self) -> Optional[bool]:
        """
        Indicates whether actions should be executed during any changes to the alarm state. The default is TRUE.
        """
        return pulumi.get(self, "actions_enabled")

    @property
    @pulumi.getter(name="alarmActions")
    def alarm_actions(self) -> Optional[Sequence[str]]:
        """
        The list of actions to execute when this alarm transitions into an ALARM state from any other state. Specify each action as an Amazon Resource Name (ARN). For more information about creating alarms and the actions that you can specify, see [PutMetricAlarm](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_PutMetricAlarm.html) in the *API Reference*.
        """
        return pulumi.get(self, "alarm_actions")

    @property
    @pulumi.getter(name="alarmDescription")
    def alarm_description(self) -> Optional[str]:
        """
        The description of the alarm.
        """
        return pulumi.get(self, "alarm_description")

    @property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> Optional[str]:
        """
        The name of the alarm. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the alarm name.   If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        """
        return pulumi.get(self, "alarm_name")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[str]:
        """
        The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand.
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="datapointsToAlarm")
    def datapoints_to_alarm(self) -> Optional[int]:
        """
        The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an 'M out of N' alarm. In that case, this value is the M, and the value that you set for ``EvaluationPeriods`` is the N value. For more information, see [Evaluating an Alarm](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation) in the *User Guide*. If you omit this parameter, CW uses the same value here that you set for ``EvaluationPeriods``, and the alarm goes to alarm state if that many consecutive periods are breaching.
        """
        return pulumi.get(self, "datapoints_to_alarm")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.DimensionResponse']]:
        """
        The dimensions for the metric associated with the alarm. For an alarm based on a math expression, you can't specify ``Dimensions``. Instead, you use ``Metrics``.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluateLowSampleCountPercentile")
    def evaluate_low_sample_count_percentile(self) -> Optional[str]:
        """
        Used only for alarms based on percentiles. If ``ignore``, the alarm state does not change during periods with too few data points to be statistically significant. If ``evaluate`` or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available.
        """
        return pulumi.get(self, "evaluate_low_sample_count_percentile")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        """
        The number of periods over which data is compared to the specified threshold. If you are setting an alarm that requires that a number of consecutive data points be breaching to trigger the alarm, this value specifies that number. If you are setting an 'M out of N' alarm, this value is the N, and ``DatapointsToAlarm`` is the M. For more information, see [Evaluating an Alarm](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarm-evaluation) in the *User Guide*.
        """
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="extendedStatistic")
    def extended_statistic(self) -> Optional[str]:
        """
        The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100. For an alarm based on a metric, you must specify either ``Statistic`` or ``ExtendedStatistic`` but not both. For an alarm based on a math expression, you can't specify ``ExtendedStatistic``. Instead, you use ``Metrics``.
        """
        return pulumi.get(self, "extended_statistic")

    @property
    @pulumi.getter(name="insufficientDataActions")
    def insufficient_data_actions(self) -> Optional[Sequence[str]]:
        """
        The actions to execute when this alarm transitions to the ``INSUFFICIENT_DATA`` state from any other state. Each action is specified as an Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "insufficient_data_actions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use ``Metrics`` instead and you can't specify ``MetricName``.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.MetricDataQueryResponse']]:
        """
        An array that enables you to create an alarm based on the result of a metric math expression. Each item in the array either retrieves a metric or performs a math expression. If you specify the ``Metrics`` parameter, you cannot specify ``MetricName``, ``Dimensions``, ``Period``, ``Namespace``, ``Statistic``, ``ExtendedStatistic``, or ``Unit``.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify ``Namespace`` and you use ``Metrics`` instead. For a list of namespaces for metrics from AWS services, see [Services That Publish Metrics.](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/aws-services-cloudwatch-metrics.html)
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="okActions")
    def ok_actions(self) -> Optional[Sequence[str]]:
        """
        The actions to execute when this alarm transitions to the ``OK`` state from any other state. Each action is specified as an Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "ok_actions")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric. Valid values are 10, 30, 60, and any multiple of 60. For an alarm based on a math expression, you can't specify ``Period``, and instead you use the ``Metrics`` parameter. *Minimum:* 10
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ``ExtendedStatistic``. For an alarm based on a metric, you must specify either ``Statistic`` or ``ExtendedStatistic`` but not both. For an alarm based on a math expression, you can't specify ``Statistic``. Instead, you use ``Metrics``.
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        The value to compare with the specified statistic.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdMetricId")
    def threshold_metric_id(self) -> Optional[str]:
        """
        In an alarm based on an anomaly detection model, this is the ID of the ``ANOMALY_DETECTION_BAND`` function used as the threshold for the alarm.
        """
        return pulumi.get(self, "threshold_metric_id")

    @property
    @pulumi.getter(name="treatMissingData")
    def treat_missing_data(self) -> Optional[str]:
        """
        Sets how this alarm is to handle missing data points. Valid values are ``breaching``, ``notBreaching``, ``ignore``, and ``missing``. For more information, see [Configuring How Alarms Treat Missing Data](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html#alarms-and-missing-data) in the *Amazon User Guide*. If you omit this parameter, the default behavior of ``missing`` is used.
        """
        return pulumi.get(self, "treat_missing_data")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit of the metric associated with the alarm. Specify this only if you are creating an alarm based on a single metric. Do not specify this if you are specifying a ``Metrics`` array.  You can specify the following values: Seconds, Microseconds, Milliseconds, Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes, Bits, Kilobits, Megabits, Gigabits, Terabits, Percent, Count, Bytes/Second, Kilobytes/Second, Megabytes/Second, Gigabytes/Second, Terabytes/Second, Bits/Second, Kilobits/Second, Megabits/Second, Gigabits/Second, Terabits/Second, Count/Second, or None.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class AwsCodeBuildProjectPropertiesResponse(dict):
    """
    Definition of awsCodeBuildProject
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildBatchConfig":
            suggest = "build_batch_config"
        elif key == "concurrentBuildLimit":
            suggest = "concurrent_build_limit"
        elif key == "encryptionKey":
            suggest = "encryption_key"
        elif key == "fileSystemLocations":
            suggest = "file_system_locations"
        elif key == "lastModified":
            suggest = "last_modified"
        elif key == "logsConfig":
            suggest = "logs_config"
        elif key == "projectVisibility":
            suggest = "project_visibility"
        elif key == "publicProjectAlias":
            suggest = "public_project_alias"
        elif key == "queuedTimeoutInMinutes":
            suggest = "queued_timeout_in_minutes"
        elif key == "resourceAccessRole":
            suggest = "resource_access_role"
        elif key == "secondaryArtifacts":
            suggest = "secondary_artifacts"
        elif key == "secondarySourceVersions":
            suggest = "secondary_source_versions"
        elif key == "secondarySources":
            suggest = "secondary_sources"
        elif key == "serviceRole":
            suggest = "service_role"
        elif key == "sourceVersion":
            suggest = "source_version"
        elif key == "timeoutInMinutes":
            suggest = "timeout_in_minutes"
        elif key == "vpcConfig":
            suggest = "vpc_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCodeBuildProjectPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCodeBuildProjectPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCodeBuildProjectPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 artifacts: Optional['outputs.ProjectArtifactsResponse'] = None,
                 badge: Optional['outputs.ProjectBadgeResponse'] = None,
                 build_batch_config: Optional['outputs.ProjectBuildBatchConfigResponse'] = None,
                 cache: Optional['outputs.ProjectCacheResponse'] = None,
                 concurrent_build_limit: Optional[int] = None,
                 created: Optional[str] = None,
                 description: Optional[str] = None,
                 encryption_key: Optional[str] = None,
                 environment: Optional['outputs.ProjectEnvironmentResponse'] = None,
                 file_system_locations: Optional[Sequence['outputs.ProjectFileSystemLocationResponse']] = None,
                 last_modified: Optional[str] = None,
                 logs_config: Optional['outputs.LogsConfigResponse'] = None,
                 name: Optional[str] = None,
                 project_visibility: Optional['outputs.ProjectVisibilityTypeEnumValueResponse'] = None,
                 public_project_alias: Optional[str] = None,
                 queued_timeout_in_minutes: Optional[int] = None,
                 resource_access_role: Optional[str] = None,
                 secondary_artifacts: Optional[Sequence['outputs.ProjectArtifactsResponse']] = None,
                 secondary_source_versions: Optional[Sequence['outputs.ProjectSourceVersionResponse']] = None,
                 secondary_sources: Optional[Sequence['outputs.ProjectSourceResponse']] = None,
                 service_role: Optional[str] = None,
                 source: Optional['outputs.ProjectSourceResponse'] = None,
                 source_version: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 timeout_in_minutes: Optional[int] = None,
                 vpc_config: Optional['outputs.VpcConfigResponse'] = None,
                 webhook: Optional['outputs.WebhookResponse'] = None):
        """
        Definition of awsCodeBuildProject
        :param str arn: <p>The Amazon Resource Name (ARN) of the build project.</p>
        :param 'ProjectArtifactsResponse' artifacts: <p>Information about the build output artifacts for the build project.</p>
        :param 'ProjectBadgeResponse' badge: <p>Information about the build badge for the build project.</p>
        :param 'ProjectBuildBatchConfigResponse' build_batch_config: <p>A <a>ProjectBuildBatchConfig</a> object that defines the batch build options for the project.</p>
        :param 'ProjectCacheResponse' cache: <p>Information about the cache for the build project.</p>
        :param int concurrent_build_limit: <p>The maximum number of concurrent builds that are allowed for this project.</p> <p>New builds are only started if the current number of builds is less than or equal to this limit. If the current build count meets this limit, new builds are throttled and are not run.</p>
        :param str created: <p>When the build project was created, expressed in Unix time format.</p>
        :param str description: <p>A description that makes the build project easy to identify.</p>
        :param str encryption_key: <p>The Key Management Service customer master key (CMK) to be used for encrypting the build output artifacts.</p> <note> <p>You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key. </p> </note> <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format <code>alias/&lt;alias-name&gt;</code>). If you don't specify a value, CodeBuild uses the managed CMK for Amazon Simple Storage Service (Amazon S3). </p>
        :param 'ProjectEnvironmentResponse' environment: <p>Information about the build environment for this build project.</p>
        :param Sequence['ProjectFileSystemLocationResponse'] file_system_locations: <p> An array of <code>ProjectFileSystemLocation</code> objects for a CodeBuild build project. A <code>ProjectFileSystemLocation</code> object specifies the <code>identifier</code>, <code>location</code>, <code>mountOptions</code>, <code>mountPoint</code>, and <code>type</code> of a file system created using Amazon Elastic File System. </p>
        :param str last_modified: <p>When the build project's settings were last modified, expressed in Unix time format.</p>
        :param 'LogsConfigResponse' logs_config: <p>Information about logs for the build project. A project can create logs in CloudWatch Logs, an S3 bucket, or both. </p>
        :param str name: <p>The name of the build project.</p>
        :param 'ProjectVisibilityTypeEnumValueResponse' project_visibility: Property projectVisibility
        :param str public_project_alias: <p>Contains the project identifier used with the public build APIs. </p>
        :param int queued_timeout_in_minutes: <p>The number of minutes a build is allowed to be queued before it times out. </p>
        :param str resource_access_role: <p>The ARN of the IAM role that enables CodeBuild to access the CloudWatch Logs and Amazon S3 artifacts for the project's builds.</p>
        :param Sequence['ProjectArtifactsResponse'] secondary_artifacts: <p>An array of <code>ProjectArtifacts</code> objects. </p>
        :param Sequence['ProjectSourceVersionResponse'] secondary_source_versions: <p>An array of <code>ProjectSourceVersion</code> objects. If <code>secondarySourceVersions</code> is specified at the build level, then they take over these <code>secondarySourceVersions</code> (at the project level). </p>
        :param Sequence['ProjectSourceResponse'] secondary_sources: <p>An array of <code>ProjectSource</code> objects. </p>
        :param str service_role: <p>The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.</p>
        :param 'ProjectSourceResponse' source: <p>Information about the build input source code for this build project.</p>
        :param str source_version: <p>A version of the build input to be built for this project. If not specified, the latest version is used. If specified, it must be one of:</p> <ul> <li> <p>For CodeCommit: the commit ID, branch, or Git tag to use.</p> </li> <li> <p>For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format <code>pr/pull-request-ID</code> (for example <code>pr/25</code>). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.</p> </li> <li> <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.</p> </li> <li> <p>For Amazon S3: the version ID of the object that represents the build input ZIP file to use.</p> </li> </ul> <p>If <code>sourceVersion</code> is specified at the build level, then that version takes precedence over this <code>sourceVersion</code> (at the project level). </p> <p>For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html'>Source Version Sample with CodeBuild</a> in the <i>CodeBuild User Guide</i>. </p>
        :param Sequence['TagResponse'] tags: <p>A list of tag key and value pairs associated with this build project.</p> <p>These tags are available for use by Amazon Web Services services that support CodeBuild build project tags.</p>
        :param int timeout_in_minutes: <p>How long, in minutes, from 5 to 480 (8 hours), for CodeBuild to wait before timing out any related build that did not get marked as completed. The default is 60 minutes.</p>
        :param 'VpcConfigResponse' vpc_config: <p>Information about the VPC configuration that CodeBuild accesses.</p>
        :param 'WebhookResponse' webhook: <p>Information about a webhook that connects repository events to a build project in CodeBuild.</p>
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if artifacts is not None:
            pulumi.set(__self__, "artifacts", artifacts)
        if badge is not None:
            pulumi.set(__self__, "badge", badge)
        if build_batch_config is not None:
            pulumi.set(__self__, "build_batch_config", build_batch_config)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if concurrent_build_limit is not None:
            pulumi.set(__self__, "concurrent_build_limit", concurrent_build_limit)
        if created is not None:
            pulumi.set(__self__, "created", created)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encryption_key is not None:
            pulumi.set(__self__, "encryption_key", encryption_key)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if file_system_locations is not None:
            pulumi.set(__self__, "file_system_locations", file_system_locations)
        if last_modified is not None:
            pulumi.set(__self__, "last_modified", last_modified)
        if logs_config is not None:
            pulumi.set(__self__, "logs_config", logs_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_visibility is not None:
            pulumi.set(__self__, "project_visibility", project_visibility)
        if public_project_alias is not None:
            pulumi.set(__self__, "public_project_alias", public_project_alias)
        if queued_timeout_in_minutes is not None:
            pulumi.set(__self__, "queued_timeout_in_minutes", queued_timeout_in_minutes)
        if resource_access_role is not None:
            pulumi.set(__self__, "resource_access_role", resource_access_role)
        if secondary_artifacts is not None:
            pulumi.set(__self__, "secondary_artifacts", secondary_artifacts)
        if secondary_source_versions is not None:
            pulumi.set(__self__, "secondary_source_versions", secondary_source_versions)
        if secondary_sources is not None:
            pulumi.set(__self__, "secondary_sources", secondary_sources)
        if service_role is not None:
            pulumi.set(__self__, "service_role", service_role)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_version is not None:
            pulumi.set(__self__, "source_version", source_version)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the build project.</p>
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def artifacts(self) -> Optional['outputs.ProjectArtifactsResponse']:
        """
        <p>Information about the build output artifacts for the build project.</p>
        """
        return pulumi.get(self, "artifacts")

    @property
    @pulumi.getter
    def badge(self) -> Optional['outputs.ProjectBadgeResponse']:
        """
        <p>Information about the build badge for the build project.</p>
        """
        return pulumi.get(self, "badge")

    @property
    @pulumi.getter(name="buildBatchConfig")
    def build_batch_config(self) -> Optional['outputs.ProjectBuildBatchConfigResponse']:
        """
        <p>A <a>ProjectBuildBatchConfig</a> object that defines the batch build options for the project.</p>
        """
        return pulumi.get(self, "build_batch_config")

    @property
    @pulumi.getter
    def cache(self) -> Optional['outputs.ProjectCacheResponse']:
        """
        <p>Information about the cache for the build project.</p>
        """
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter(name="concurrentBuildLimit")
    def concurrent_build_limit(self) -> Optional[int]:
        """
        <p>The maximum number of concurrent builds that are allowed for this project.</p> <p>New builds are only started if the current number of builds is less than or equal to this limit. If the current build count meets this limit, new builds are throttled and are not run.</p>
        """
        return pulumi.get(self, "concurrent_build_limit")

    @property
    @pulumi.getter
    def created(self) -> Optional[str]:
        """
        <p>When the build project was created, expressed in Unix time format.</p>
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description that makes the build project easy to identify.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> Optional[str]:
        """
        <p>The Key Management Service customer master key (CMK) to be used for encrypting the build output artifacts.</p> <note> <p>You can use a cross-account KMS key to encrypt the build output artifacts if your service role has permission to that key. </p> </note> <p>You can specify either the Amazon Resource Name (ARN) of the CMK or, if available, the CMK's alias (using the format <code>alias/&lt;alias-name&gt;</code>). If you don't specify a value, CodeBuild uses the managed CMK for Amazon Simple Storage Service (Amazon S3). </p>
        """
        return pulumi.get(self, "encryption_key")

    @property
    @pulumi.getter
    def environment(self) -> Optional['outputs.ProjectEnvironmentResponse']:
        """
        <p>Information about the build environment for this build project.</p>
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="fileSystemLocations")
    def file_system_locations(self) -> Optional[Sequence['outputs.ProjectFileSystemLocationResponse']]:
        """
        <p> An array of <code>ProjectFileSystemLocation</code> objects for a CodeBuild build project. A <code>ProjectFileSystemLocation</code> object specifies the <code>identifier</code>, <code>location</code>, <code>mountOptions</code>, <code>mountPoint</code>, and <code>type</code> of a file system created using Amazon Elastic File System. </p>
        """
        return pulumi.get(self, "file_system_locations")

    @property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> Optional[str]:
        """
        <p>When the build project's settings were last modified, expressed in Unix time format.</p>
        """
        return pulumi.get(self, "last_modified")

    @property
    @pulumi.getter(name="logsConfig")
    def logs_config(self) -> Optional['outputs.LogsConfigResponse']:
        """
        <p>Information about logs for the build project. A project can create logs in CloudWatch Logs, an S3 bucket, or both. </p>
        """
        return pulumi.get(self, "logs_config")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the build project.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectVisibility")
    def project_visibility(self) -> Optional['outputs.ProjectVisibilityTypeEnumValueResponse']:
        """
        Property projectVisibility
        """
        return pulumi.get(self, "project_visibility")

    @property
    @pulumi.getter(name="publicProjectAlias")
    def public_project_alias(self) -> Optional[str]:
        """
        <p>Contains the project identifier used with the public build APIs. </p>
        """
        return pulumi.get(self, "public_project_alias")

    @property
    @pulumi.getter(name="queuedTimeoutInMinutes")
    def queued_timeout_in_minutes(self) -> Optional[int]:
        """
        <p>The number of minutes a build is allowed to be queued before it times out. </p>
        """
        return pulumi.get(self, "queued_timeout_in_minutes")

    @property
    @pulumi.getter(name="resourceAccessRole")
    def resource_access_role(self) -> Optional[str]:
        """
        <p>The ARN of the IAM role that enables CodeBuild to access the CloudWatch Logs and Amazon S3 artifacts for the project's builds.</p>
        """
        return pulumi.get(self, "resource_access_role")

    @property
    @pulumi.getter(name="secondaryArtifacts")
    def secondary_artifacts(self) -> Optional[Sequence['outputs.ProjectArtifactsResponse']]:
        """
        <p>An array of <code>ProjectArtifacts</code> objects. </p>
        """
        return pulumi.get(self, "secondary_artifacts")

    @property
    @pulumi.getter(name="secondarySourceVersions")
    def secondary_source_versions(self) -> Optional[Sequence['outputs.ProjectSourceVersionResponse']]:
        """
        <p>An array of <code>ProjectSourceVersion</code> objects. If <code>secondarySourceVersions</code> is specified at the build level, then they take over these <code>secondarySourceVersions</code> (at the project level). </p>
        """
        return pulumi.get(self, "secondary_source_versions")

    @property
    @pulumi.getter(name="secondarySources")
    def secondary_sources(self) -> Optional[Sequence['outputs.ProjectSourceResponse']]:
        """
        <p>An array of <code>ProjectSource</code> objects. </p>
        """
        return pulumi.get(self, "secondary_sources")

    @property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> Optional[str]:
        """
        <p>The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.</p>
        """
        return pulumi.get(self, "service_role")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.ProjectSourceResponse']:
        """
        <p>Information about the build input source code for this build project.</p>
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourceVersion")
    def source_version(self) -> Optional[str]:
        """
        <p>A version of the build input to be built for this project. If not specified, the latest version is used. If specified, it must be one of:</p> <ul> <li> <p>For CodeCommit: the commit ID, branch, or Git tag to use.</p> </li> <li> <p>For GitHub: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format <code>pr/pull-request-ID</code> (for example <code>pr/25</code>). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.</p> </li> <li> <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.</p> </li> <li> <p>For Amazon S3: the version ID of the object that represents the build input ZIP file to use.</p> </li> </ul> <p>If <code>sourceVersion</code> is specified at the build level, then that version takes precedence over this <code>sourceVersion</code> (at the project level). </p> <p>For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html'>Source Version Sample with CodeBuild</a> in the <i>CodeBuild User Guide</i>. </p>
        """
        return pulumi.get(self, "source_version")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        <p>A list of tag key and value pairs associated with this build project.</p> <p>These tags are available for use by Amazon Web Services services that support CodeBuild build project tags.</p>
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[int]:
        """
        <p>How long, in minutes, from 5 to 480 (8 hours), for CodeBuild to wait before timing out any related build that did not get marked as completed. The default is 60 minutes.</p>
        """
        return pulumi.get(self, "timeout_in_minutes")

    @property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional['outputs.VpcConfigResponse']:
        """
        <p>Information about the VPC configuration that CodeBuild accesses.</p>
        """
        return pulumi.get(self, "vpc_config")

    @property
    @pulumi.getter
    def webhook(self) -> Optional['outputs.WebhookResponse']:
        """
        <p>Information about a webhook that connects repository events to a build project in CodeBuild.</p>
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class AwsCodeBuildSourceCredentialsInfoPropertiesResponse(dict):
    """
    Definition of awsCodeBuildSourceCredentialsInfo
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "serverType":
            suggest = "server_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCodeBuildSourceCredentialsInfoPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCodeBuildSourceCredentialsInfoPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCodeBuildSourceCredentialsInfoPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 auth_type: Optional['outputs.AuthTypeEnumValueResponse'] = None,
                 resource: Optional[str] = None,
                 server_type: Optional['outputs.ServerTypeEnumValueResponse'] = None):
        """
        Definition of awsCodeBuildSourceCredentialsInfo
        :param str arn: <p> The Amazon Resource Name (ARN) of the token. </p>
        :param 'AuthTypeEnumValueResponse' auth_type: <p> The type of authentication used by the credentials. Valid options are OAUTH, BASIC_AUTH, PERSONAL_ACCESS_TOKEN, or CODECONNECTIONS. </p>
        :param str resource: <p>The connection ARN if your serverType type is GITLAB or GITLAB_SELF_MANAGED and your authType is CODECONNECTIONS.</p>
        :param 'ServerTypeEnumValueResponse' server_type: <p> The type of source provider. The valid options are GITHUB, GITHUB_ENTERPRISE, GITLAB, GITLAB_SELF_MANAGED, or BITBUCKET. </p>
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        <p> The Amazon Resource Name (ARN) of the token. </p>
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional['outputs.AuthTypeEnumValueResponse']:
        """
        <p> The type of authentication used by the credentials. Valid options are OAUTH, BASIC_AUTH, PERSONAL_ACCESS_TOKEN, or CODECONNECTIONS. </p>
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        <p>The connection ARN if your serverType type is GITLAB or GITLAB_SELF_MANAGED and your authType is CODECONNECTIONS.</p>
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional['outputs.ServerTypeEnumValueResponse']:
        """
        <p> The type of source provider. The valid options are GITHUB, GITHUB_ENTERPRISE, GITLAB, GITLAB_SELF_MANAGED, or BITBUCKET. </p>
        """
        return pulumi.get(self, "server_type")


@pulumi.output_type
class AwsConfigServiceConfigurationRecorderPropertiesResponse(dict):
    """
    Definition of awsConfigServiceConfigurationRecorder
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordingGroup":
            suggest = "recording_group"
        elif key == "recordingMode":
            suggest = "recording_mode"
        elif key == "roleARN":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConfigServiceConfigurationRecorderPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConfigServiceConfigurationRecorderPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConfigServiceConfigurationRecorderPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 recording_group: Optional['outputs.RecordingGroupResponse'] = None,
                 recording_mode: Optional['outputs.RecordingModeResponse'] = None,
                 role_arn: Optional[str] = None):
        """
        Definition of awsConfigServiceConfigurationRecorder
        :param str name: <p>The name of the configuration recorder. Config automatically assigns the name of 'default' when creating the configuration recorder.</p> <note> <p>You cannot change the name of the configuration recorder after it has been created. To change the configuration recorder name, you must delete it and create a new configuration recorder with a new name. </p> </note>
        :param 'RecordingGroupResponse' recording_group: <p>Specifies which resource types Config records for configuration changes.</p> <note> <p> <b> High Number of Config Evaluations</b> </p> <p>You may notice increased activity in your account during your initial month recording with Config when compared to subsequent months. During the initial bootstrapping process, Config runs evaluations on all the resources in your account that you have selected for Config to record.</p> <p>If you are running ephemeral workloads, you may see increased activity from Config as it records configuration changes associated with creating and deleting these temporary resources. An <i>ephemeral workload</i> is a temporary use of computing resources that are loaded and run when needed. Examples include Amazon Elastic Compute Cloud (Amazon EC2) Spot Instances, Amazon EMR jobs, and Auto Scaling. If you want to avoid the increased activity from running ephemeral workloads, you can run these types of workloads in a separate account with Config turned off to avoid increased configuration recording and rule evaluations.</p> </note>
        :param 'RecordingModeResponse' recording_mode: <p>Specifies the default recording frequency that Config uses to record configuration changes. Config supports <i>Continuous recording</i> and <i>Daily recording</i>.</p> <ul> <li> <p>Continuous recording allows you to record configuration changes continuously whenever a change occurs.</p> </li> <li> <p>Daily recording allows you to receive a configuration item (CI) representing the most recent state of your resources over the last 24-hour period, only if its different from the previous CI recorded. </p> </li> </ul> <note> <p>Firewall Manager depends on continuous recording to monitor your resources. If you are using Firewall Manager, it is recommended that you set the recording frequency to Continuous.</p> </note> <p>You can also override the recording frequency for specific resource types.</p>
        :param str role_arn: <p>Amazon Resource Name (ARN) of the IAM role assumed by Config and used by the configuration recorder.</p> <note> <p>While the API model does not require this field, the server will reject a request without a defined <code>roleARN</code> for the configuration recorder.</p> </note> <note> <p> <b>Pre-existing Config role</b> </p> <p>If you have used an Amazon Web Services service that uses Config, such as Security Hub or Control Tower, and an Config role has already been created, make sure that the IAM role that you use when setting up Config keeps the same minimum permissions as the already created Config role. You must do this so that the other Amazon Web Services service continues to run as expected. </p> <p>For example, if Control Tower has an IAM role that allows Config to read Amazon Simple Storage Service (Amazon S3) objects, make sure that the same permissions are granted within the IAM role you use when setting up Config. Otherwise, it may interfere with how Control Tower operates. For more information about IAM roles for Config, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/security-iam.html'> <b>Identity and Access Management for Config</b> </a> in the <i>Config Developer Guide</i>. </p> </note>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if recording_group is not None:
            pulumi.set(__self__, "recording_group", recording_group)
        if recording_mode is not None:
            pulumi.set(__self__, "recording_mode", recording_mode)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the configuration recorder. Config automatically assigns the name of 'default' when creating the configuration recorder.</p> <note> <p>You cannot change the name of the configuration recorder after it has been created. To change the configuration recorder name, you must delete it and create a new configuration recorder with a new name. </p> </note>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="recordingGroup")
    def recording_group(self) -> Optional['outputs.RecordingGroupResponse']:
        """
        <p>Specifies which resource types Config records for configuration changes.</p> <note> <p> <b> High Number of Config Evaluations</b> </p> <p>You may notice increased activity in your account during your initial month recording with Config when compared to subsequent months. During the initial bootstrapping process, Config runs evaluations on all the resources in your account that you have selected for Config to record.</p> <p>If you are running ephemeral workloads, you may see increased activity from Config as it records configuration changes associated with creating and deleting these temporary resources. An <i>ephemeral workload</i> is a temporary use of computing resources that are loaded and run when needed. Examples include Amazon Elastic Compute Cloud (Amazon EC2) Spot Instances, Amazon EMR jobs, and Auto Scaling. If you want to avoid the increased activity from running ephemeral workloads, you can run these types of workloads in a separate account with Config turned off to avoid increased configuration recording and rule evaluations.</p> </note>
        """
        return pulumi.get(self, "recording_group")

    @property
    @pulumi.getter(name="recordingMode")
    def recording_mode(self) -> Optional['outputs.RecordingModeResponse']:
        """
        <p>Specifies the default recording frequency that Config uses to record configuration changes. Config supports <i>Continuous recording</i> and <i>Daily recording</i>.</p> <ul> <li> <p>Continuous recording allows you to record configuration changes continuously whenever a change occurs.</p> </li> <li> <p>Daily recording allows you to receive a configuration item (CI) representing the most recent state of your resources over the last 24-hour period, only if its different from the previous CI recorded. </p> </li> </ul> <note> <p>Firewall Manager depends on continuous recording to monitor your resources. If you are using Firewall Manager, it is recommended that you set the recording frequency to Continuous.</p> </note> <p>You can also override the recording frequency for specific resource types.</p>
        """
        return pulumi.get(self, "recording_mode")

    @property
    @pulumi.getter(name="roleARN")
    def role_arn(self) -> Optional[str]:
        """
        <p>Amazon Resource Name (ARN) of the IAM role assumed by Config and used by the configuration recorder.</p> <note> <p>While the API model does not require this field, the server will reject a request without a defined <code>roleARN</code> for the configuration recorder.</p> </note> <note> <p> <b>Pre-existing Config role</b> </p> <p>If you have used an Amazon Web Services service that uses Config, such as Security Hub or Control Tower, and an Config role has already been created, make sure that the IAM role that you use when setting up Config keeps the same minimum permissions as the already created Config role. You must do this so that the other Amazon Web Services service continues to run as expected. </p> <p>For example, if Control Tower has an IAM role that allows Config to read Amazon Simple Storage Service (Amazon S3) objects, make sure that the same permissions are granted within the IAM role you use when setting up Config. Otherwise, it may interfere with how Control Tower operates. For more information about IAM roles for Config, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/security-iam.html'> <b>Identity and Access Management for Config</b> </a> in the <i>Config Developer Guide</i>. </p> </note>
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class AwsConfigServiceConfigurationRecorderStatusPropertiesResponse(dict):
    """
    Definition of awsConfigServiceConfigurationRecorderStatus
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastErrorCode":
            suggest = "last_error_code"
        elif key == "lastErrorMessage":
            suggest = "last_error_message"
        elif key == "lastStartTime":
            suggest = "last_start_time"
        elif key == "lastStatus":
            suggest = "last_status"
        elif key == "lastStatusChangeTime":
            suggest = "last_status_change_time"
        elif key == "lastStopTime":
            suggest = "last_stop_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConfigServiceConfigurationRecorderStatusPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConfigServiceConfigurationRecorderStatusPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConfigServiceConfigurationRecorderStatusPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_error_code: Optional[str] = None,
                 last_error_message: Optional[str] = None,
                 last_start_time: Optional[str] = None,
                 last_status: Optional['outputs.RecorderStatusEnumValueResponse'] = None,
                 last_status_change_time: Optional[str] = None,
                 last_stop_time: Optional[str] = None,
                 name: Optional[str] = None,
                 recording: Optional[bool] = None):
        """
        Definition of awsConfigServiceConfigurationRecorderStatus
        :param str last_error_code: <p>The latest error code from when the recorder last failed.</p>
        :param str last_error_message: <p>The latest error message from when the recorder last failed.</p>
        :param str last_start_time: <p>The time the recorder was last started.</p>
        :param 'RecorderStatusEnumValueResponse' last_status: <p>The status of the latest recording event processed by the recorder.</p>
        :param str last_status_change_time: <p>The time of the latest change in status of an recording event processed by the recorder.</p>
        :param str last_stop_time: <p>The time the recorder was last stopped.</p>
        :param str name: <p>The name of the configuration recorder.</p>
        :param bool recording: <p>Specifies whether or not the recorder is currently recording.</p>
        """
        if last_error_code is not None:
            pulumi.set(__self__, "last_error_code", last_error_code)
        if last_error_message is not None:
            pulumi.set(__self__, "last_error_message", last_error_message)
        if last_start_time is not None:
            pulumi.set(__self__, "last_start_time", last_start_time)
        if last_status is not None:
            pulumi.set(__self__, "last_status", last_status)
        if last_status_change_time is not None:
            pulumi.set(__self__, "last_status_change_time", last_status_change_time)
        if last_stop_time is not None:
            pulumi.set(__self__, "last_stop_time", last_stop_time)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if recording is not None:
            pulumi.set(__self__, "recording", recording)

    @property
    @pulumi.getter(name="lastErrorCode")
    def last_error_code(self) -> Optional[str]:
        """
        <p>The latest error code from when the recorder last failed.</p>
        """
        return pulumi.get(self, "last_error_code")

    @property
    @pulumi.getter(name="lastErrorMessage")
    def last_error_message(self) -> Optional[str]:
        """
        <p>The latest error message from when the recorder last failed.</p>
        """
        return pulumi.get(self, "last_error_message")

    @property
    @pulumi.getter(name="lastStartTime")
    def last_start_time(self) -> Optional[str]:
        """
        <p>The time the recorder was last started.</p>
        """
        return pulumi.get(self, "last_start_time")

    @property
    @pulumi.getter(name="lastStatus")
    def last_status(self) -> Optional['outputs.RecorderStatusEnumValueResponse']:
        """
        <p>The status of the latest recording event processed by the recorder.</p>
        """
        return pulumi.get(self, "last_status")

    @property
    @pulumi.getter(name="lastStatusChangeTime")
    def last_status_change_time(self) -> Optional[str]:
        """
        <p>The time of the latest change in status of an recording event processed by the recorder.</p>
        """
        return pulumi.get(self, "last_status_change_time")

    @property
    @pulumi.getter(name="lastStopTime")
    def last_stop_time(self) -> Optional[str]:
        """
        <p>The time the recorder was last stopped.</p>
        """
        return pulumi.get(self, "last_stop_time")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the configuration recorder.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def recording(self) -> Optional[bool]:
        """
        <p>Specifies whether or not the recorder is currently recording.</p>
        """
        return pulumi.get(self, "recording")


@pulumi.output_type
class AwsConfigServiceDeliveryChannelPropertiesResponse(dict):
    """
    Definition of awsConfigServiceDeliveryChannel
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configSnapshotDeliveryProperties":
            suggest = "config_snapshot_delivery_properties"
        elif key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3KeyPrefix":
            suggest = "s3_key_prefix"
        elif key == "s3KmsKeyArn":
            suggest = "s3_kms_key_arn"
        elif key == "snsTopicARN":
            suggest = "sns_topic_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConfigServiceDeliveryChannelPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConfigServiceDeliveryChannelPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConfigServiceDeliveryChannelPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_snapshot_delivery_properties: Optional['outputs.ConfigSnapshotDeliveryPropertiesResponse'] = None,
                 name: Optional[str] = None,
                 s3_bucket_name: Optional[str] = None,
                 s3_key_prefix: Optional[str] = None,
                 s3_kms_key_arn: Optional[str] = None,
                 sns_topic_arn: Optional[str] = None):
        """
        Definition of awsConfigServiceDeliveryChannel
        :param 'ConfigSnapshotDeliveryPropertiesResponse' config_snapshot_delivery_properties: <p>The options for how often Config delivers configuration snapshots to the Amazon S3 bucket.</p>
        :param str name: <p>The name of the delivery channel. By default, Config assigns the name 'default' when creating the delivery channel. To change the delivery channel name, you must use the DeleteDeliveryChannel action to delete your current delivery channel, and then you must use the PutDeliveryChannel command to create a delivery channel that has the desired name.</p>
        :param str s3_bucket_name: <p>The name of the Amazon S3 bucket to which Config delivers configuration snapshots and configuration history files.</p> <p>If you specify a bucket that belongs to another Amazon Web Services account, that bucket must have policies that grant access permissions to Config. For more information, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html'>Permissions for the Amazon S3 Bucket</a> in the <i>Config Developer Guide</i>.</p>
        :param str s3_key_prefix: <p>The prefix for the specified Amazon S3 bucket.</p>
        :param str s3_kms_key_arn: <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS ) KMS key (KMS key) used to encrypt objects delivered by Config. Must belong to the same Region as the destination S3 bucket.</p>
        :param str sns_topic_arn: <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which Config sends notifications about configuration changes.</p> <p>If you choose a topic from another account, the topic must have policies that grant access permissions to Config. For more information, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html'>Permissions for the Amazon SNS Topic</a> in the <i>Config Developer Guide</i>.</p>
        """
        if config_snapshot_delivery_properties is not None:
            pulumi.set(__self__, "config_snapshot_delivery_properties", config_snapshot_delivery_properties)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)
        if s3_kms_key_arn is not None:
            pulumi.set(__self__, "s3_kms_key_arn", s3_kms_key_arn)
        if sns_topic_arn is not None:
            pulumi.set(__self__, "sns_topic_arn", sns_topic_arn)

    @property
    @pulumi.getter(name="configSnapshotDeliveryProperties")
    def config_snapshot_delivery_properties(self) -> Optional['outputs.ConfigSnapshotDeliveryPropertiesResponse']:
        """
        <p>The options for how often Config delivers configuration snapshots to the Amazon S3 bucket.</p>
        """
        return pulumi.get(self, "config_snapshot_delivery_properties")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the delivery channel. By default, Config assigns the name 'default' when creating the delivery channel. To change the delivery channel name, you must use the DeleteDeliveryChannel action to delete your current delivery channel, and then you must use the PutDeliveryChannel command to create a delivery channel that has the desired name.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[str]:
        """
        <p>The name of the Amazon S3 bucket to which Config delivers configuration snapshots and configuration history files.</p> <p>If you specify a bucket that belongs to another Amazon Web Services account, that bucket must have policies that grant access permissions to Config. For more information, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html'>Permissions for the Amazon S3 Bucket</a> in the <i>Config Developer Guide</i>.</p>
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[str]:
        """
        <p>The prefix for the specified Amazon S3 bucket.</p>
        """
        return pulumi.get(self, "s3_key_prefix")

    @property
    @pulumi.getter(name="s3KmsKeyArn")
    def s3_kms_key_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS ) KMS key (KMS key) used to encrypt objects delivered by Config. Must belong to the same Region as the destination S3 bucket.</p>
        """
        return pulumi.get(self, "s3_kms_key_arn")

    @property
    @pulumi.getter(name="snsTopicARN")
    def sns_topic_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which Config sends notifications about configuration changes.</p> <p>If you choose a topic from another account, the topic must have policies that grant access permissions to Config. For more information, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html'>Permissions for the Amazon SNS Topic</a> in the <i>Config Developer Guide</i>.</p>
        """
        return pulumi.get(self, "sns_topic_arn")


@pulumi.output_type
class AwsDatabaseMigrationServiceReplicationInstancePropertiesResponse(dict):
    """
    Definition of awsDatabaseMigrationServiceReplicationInstance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedStorage":
            suggest = "allocated_storage"
        elif key == "autoMinorVersionUpgrade":
            suggest = "auto_minor_version_upgrade"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "dnsNameServers":
            suggest = "dns_name_servers"
        elif key == "engineVersion":
            suggest = "engine_version"
        elif key == "freeUntil":
            suggest = "free_until"
        elif key == "instanceCreateTime":
            suggest = "instance_create_time"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "multiAZ":
            suggest = "multi_az"
        elif key == "networkType":
            suggest = "network_type"
        elif key == "pendingModifiedValues":
            suggest = "pending_modified_values"
        elif key == "preferredMaintenanceWindow":
            suggest = "preferred_maintenance_window"
        elif key == "publiclyAccessible":
            suggest = "publicly_accessible"
        elif key == "replicationInstanceArn":
            suggest = "replication_instance_arn"
        elif key == "replicationInstanceClass":
            suggest = "replication_instance_class"
        elif key == "replicationInstanceIdentifier":
            suggest = "replication_instance_identifier"
        elif key == "replicationInstanceIpv6Addresses":
            suggest = "replication_instance_ipv6_addresses"
        elif key == "replicationInstancePrivateIpAddress":
            suggest = "replication_instance_private_ip_address"
        elif key == "replicationInstancePrivateIpAddresses":
            suggest = "replication_instance_private_ip_addresses"
        elif key == "replicationInstancePublicIpAddress":
            suggest = "replication_instance_public_ip_address"
        elif key == "replicationInstancePublicIpAddresses":
            suggest = "replication_instance_public_ip_addresses"
        elif key == "replicationInstanceStatus":
            suggest = "replication_instance_status"
        elif key == "replicationSubnetGroup":
            suggest = "replication_subnet_group"
        elif key == "secondaryAvailabilityZone":
            suggest = "secondary_availability_zone"
        elif key == "vpcSecurityGroups":
            suggest = "vpc_security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsDatabaseMigrationServiceReplicationInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsDatabaseMigrationServiceReplicationInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsDatabaseMigrationServiceReplicationInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_storage: Optional[int] = None,
                 auto_minor_version_upgrade: Optional[bool] = None,
                 availability_zone: Optional[str] = None,
                 dns_name_servers: Optional[str] = None,
                 engine_version: Optional[str] = None,
                 free_until: Optional[str] = None,
                 instance_create_time: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 multi_az: Optional[bool] = None,
                 network_type: Optional[str] = None,
                 pending_modified_values: Optional['outputs.ReplicationPendingModifiedValuesResponse'] = None,
                 preferred_maintenance_window: Optional[str] = None,
                 publicly_accessible: Optional[bool] = None,
                 replication_instance_arn: Optional[str] = None,
                 replication_instance_class: Optional[str] = None,
                 replication_instance_identifier: Optional[str] = None,
                 replication_instance_ipv6_addresses: Optional[Sequence[str]] = None,
                 replication_instance_private_ip_address: Optional[str] = None,
                 replication_instance_private_ip_addresses: Optional[Sequence[str]] = None,
                 replication_instance_public_ip_address: Optional[str] = None,
                 replication_instance_public_ip_addresses: Optional[Sequence[str]] = None,
                 replication_instance_status: Optional[str] = None,
                 replication_subnet_group: Optional['outputs.ReplicationSubnetGroupResponse'] = None,
                 secondary_availability_zone: Optional[str] = None,
                 vpc_security_groups: Optional[Sequence['outputs.VpcSecurityGroupMembershipResponse']] = None):
        """
        Definition of awsDatabaseMigrationServiceReplicationInstance
        :param int allocated_storage: <p>The amount of storage (in gigabytes) that is allocated for the replication instance.</p>
        :param bool auto_minor_version_upgrade: <p>Boolean value indicating if minor version upgrades will be automatically applied to the instance.</p>
        :param str availability_zone: <p>The Availability Zone for the instance.</p>
        :param str dns_name_servers: <p>The DNS name servers supported for the replication instance to access your on-premise source or target database.</p>
        :param str engine_version: <p>The engine version number of the replication instance.</p> <p>If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.</p> <p>When modifying a major engine version of an instance, also set <code>AllowMajorVersionUpgrade</code> to <code>true</code>.</p>
        :param str free_until: <p> The expiration date of the free replication instance that is part of the Free DMS program. </p>
        :param str instance_create_time: <p>The time the replication instance was created.</p>
        :param str kms_key_id: <p>An KMS key identifier that is used to encrypt the data on the replication instance.</p> <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then DMS uses your default encryption key.</p> <p>KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.</p>
        :param bool multi_az: <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to <code>true</code>. </p>
        :param str network_type: <p>The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.</p>
        :param 'ReplicationPendingModifiedValuesResponse' pending_modified_values: <p>The pending modification values.</p>
        :param str preferred_maintenance_window: <p>The maintenance window times for the replication instance. Any pending upgrades to the replication instance are performed during this time.</p>
        :param bool publicly_accessible: <p> Specifies the accessibility options for the replication instance. A value of <code>true</code> represents an instance with a public IP address. A value of <code>false</code> represents an instance with a private IP address. The default value is <code>true</code>. </p>
        :param str replication_instance_arn: <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        :param str replication_instance_class: <p>The compute and memory capacity of the replication instance as defined for the specified replication instance class. It is a required parameter, although a default value is pre-selected in the DMS console.</p> <p>For more information on the settings and capacities for the available replication instance classes, see <a href='https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth'> Selecting the right DMS replication instance for your migration</a>. </p>
        :param str replication_instance_identifier: <p>The replication instance identifier is a required parameter. This parameter is stored as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain 1-63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul> <p>Example: <code>myrepinstance</code> </p>
        :param Sequence[str] replication_instance_ipv6_addresses: <p>One or more IPv6 addresses for the replication instance.</p>
        :param str replication_instance_private_ip_address: <p>The private IP address of the replication instance.</p>
        :param Sequence[str] replication_instance_private_ip_addresses: <p>One or more private IP addresses for the replication instance.</p>
        :param str replication_instance_public_ip_address: <p>The public IP address of the replication instance.</p>
        :param Sequence[str] replication_instance_public_ip_addresses: <p>One or more public IP addresses for the replication instance.</p>
        :param str replication_instance_status: <p>The status of the replication instance. The possible return values include:</p> <ul> <li> <p> <code>'available'</code> </p> </li> <li> <p> <code>'creating'</code> </p> </li> <li> <p> <code>'deleted'</code> </p> </li> <li> <p> <code>'deleting'</code> </p> </li> <li> <p> <code>'failed'</code> </p> </li> <li> <p> <code>'modifying'</code> </p> </li> <li> <p> <code>'upgrading'</code> </p> </li> <li> <p> <code>'rebooting'</code> </p> </li> <li> <p> <code>'resetting-master-credentials'</code> </p> </li> <li> <p> <code>'storage-full'</code> </p> </li> <li> <p> <code>'incompatible-credentials'</code> </p> </li> <li> <p> <code>'incompatible-network'</code> </p> </li> <li> <p> <code>'maintenance'</code> </p> </li> </ul>
        :param 'ReplicationSubnetGroupResponse' replication_subnet_group: <p>The subnet group for the replication instance.</p>
        :param str secondary_availability_zone: <p>The Availability Zone of the standby replication instance in a Multi-AZ deployment.</p>
        :param Sequence['VpcSecurityGroupMembershipResponse'] vpc_security_groups: <p>The VPC security group for the instance.</p>
        """
        if allocated_storage is not None:
            pulumi.set(__self__, "allocated_storage", allocated_storage)
        if auto_minor_version_upgrade is not None:
            pulumi.set(__self__, "auto_minor_version_upgrade", auto_minor_version_upgrade)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if dns_name_servers is not None:
            pulumi.set(__self__, "dns_name_servers", dns_name_servers)
        if engine_version is not None:
            pulumi.set(__self__, "engine_version", engine_version)
        if free_until is not None:
            pulumi.set(__self__, "free_until", free_until)
        if instance_create_time is not None:
            pulumi.set(__self__, "instance_create_time", instance_create_time)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if multi_az is not None:
            pulumi.set(__self__, "multi_az", multi_az)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if pending_modified_values is not None:
            pulumi.set(__self__, "pending_modified_values", pending_modified_values)
        if preferred_maintenance_window is not None:
            pulumi.set(__self__, "preferred_maintenance_window", preferred_maintenance_window)
        if publicly_accessible is not None:
            pulumi.set(__self__, "publicly_accessible", publicly_accessible)
        if replication_instance_arn is not None:
            pulumi.set(__self__, "replication_instance_arn", replication_instance_arn)
        if replication_instance_class is not None:
            pulumi.set(__self__, "replication_instance_class", replication_instance_class)
        if replication_instance_identifier is not None:
            pulumi.set(__self__, "replication_instance_identifier", replication_instance_identifier)
        if replication_instance_ipv6_addresses is not None:
            pulumi.set(__self__, "replication_instance_ipv6_addresses", replication_instance_ipv6_addresses)
        if replication_instance_private_ip_address is not None:
            pulumi.set(__self__, "replication_instance_private_ip_address", replication_instance_private_ip_address)
        if replication_instance_private_ip_addresses is not None:
            pulumi.set(__self__, "replication_instance_private_ip_addresses", replication_instance_private_ip_addresses)
        if replication_instance_public_ip_address is not None:
            pulumi.set(__self__, "replication_instance_public_ip_address", replication_instance_public_ip_address)
        if replication_instance_public_ip_addresses is not None:
            pulumi.set(__self__, "replication_instance_public_ip_addresses", replication_instance_public_ip_addresses)
        if replication_instance_status is not None:
            pulumi.set(__self__, "replication_instance_status", replication_instance_status)
        if replication_subnet_group is not None:
            pulumi.set(__self__, "replication_subnet_group", replication_subnet_group)
        if secondary_availability_zone is not None:
            pulumi.set(__self__, "secondary_availability_zone", secondary_availability_zone)
        if vpc_security_groups is not None:
            pulumi.set(__self__, "vpc_security_groups", vpc_security_groups)

    @property
    @pulumi.getter(name="allocatedStorage")
    def allocated_storage(self) -> Optional[int]:
        """
        <p>The amount of storage (in gigabytes) that is allocated for the replication instance.</p>
        """
        return pulumi.get(self, "allocated_storage")

    @property
    @pulumi.getter(name="autoMinorVersionUpgrade")
    def auto_minor_version_upgrade(self) -> Optional[bool]:
        """
        <p>Boolean value indicating if minor version upgrades will be automatically applied to the instance.</p>
        """
        return pulumi.get(self, "auto_minor_version_upgrade")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        <p>The Availability Zone for the instance.</p>
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="dnsNameServers")
    def dns_name_servers(self) -> Optional[str]:
        """
        <p>The DNS name servers supported for the replication instance to access your on-premise source or target database.</p>
        """
        return pulumi.get(self, "dns_name_servers")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> Optional[str]:
        """
        <p>The engine version number of the replication instance.</p> <p>If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.</p> <p>When modifying a major engine version of an instance, also set <code>AllowMajorVersionUpgrade</code> to <code>true</code>.</p>
        """
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter(name="freeUntil")
    def free_until(self) -> Optional[str]:
        """
        <p> The expiration date of the free replication instance that is part of the Free DMS program. </p>
        """
        return pulumi.get(self, "free_until")

    @property
    @pulumi.getter(name="instanceCreateTime")
    def instance_create_time(self) -> Optional[str]:
        """
        <p>The time the replication instance was created.</p>
        """
        return pulumi.get(self, "instance_create_time")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        <p>An KMS key identifier that is used to encrypt the data on the replication instance.</p> <p>If you don't specify a value for the <code>KmsKeyId</code> parameter, then DMS uses your default encryption key.</p> <p>KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.</p>
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="multiAZ")
    def multi_az(self) -> Optional[bool]:
        """
        <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to <code>true</code>. </p>
        """
        return pulumi.get(self, "multi_az")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[str]:
        """
        <p>The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.</p>
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="pendingModifiedValues")
    def pending_modified_values(self) -> Optional['outputs.ReplicationPendingModifiedValuesResponse']:
        """
        <p>The pending modification values.</p>
        """
        return pulumi.get(self, "pending_modified_values")

    @property
    @pulumi.getter(name="preferredMaintenanceWindow")
    def preferred_maintenance_window(self) -> Optional[str]:
        """
        <p>The maintenance window times for the replication instance. Any pending upgrades to the replication instance are performed during this time.</p>
        """
        return pulumi.get(self, "preferred_maintenance_window")

    @property
    @pulumi.getter(name="publiclyAccessible")
    def publicly_accessible(self) -> Optional[bool]:
        """
        <p> Specifies the accessibility options for the replication instance. A value of <code>true</code> represents an instance with a public IP address. A value of <code>false</code> represents an instance with a private IP address. The default value is <code>true</code>. </p>
        """
        return pulumi.get(self, "publicly_accessible")

    @property
    @pulumi.getter(name="replicationInstanceArn")
    def replication_instance_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the replication instance.</p>
        """
        return pulumi.get(self, "replication_instance_arn")

    @property
    @pulumi.getter(name="replicationInstanceClass")
    def replication_instance_class(self) -> Optional[str]:
        """
        <p>The compute and memory capacity of the replication instance as defined for the specified replication instance class. It is a required parameter, although a default value is pre-selected in the DMS console.</p> <p>For more information on the settings and capacities for the available replication instance classes, see <a href='https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth'> Selecting the right DMS replication instance for your migration</a>. </p>
        """
        return pulumi.get(self, "replication_instance_class")

    @property
    @pulumi.getter(name="replicationInstanceIdentifier")
    def replication_instance_identifier(self) -> Optional[str]:
        """
        <p>The replication instance identifier is a required parameter. This parameter is stored as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain 1-63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul> <p>Example: <code>myrepinstance</code> </p>
        """
        return pulumi.get(self, "replication_instance_identifier")

    @property
    @pulumi.getter(name="replicationInstanceIpv6Addresses")
    def replication_instance_ipv6_addresses(self) -> Optional[Sequence[str]]:
        """
        <p>One or more IPv6 addresses for the replication instance.</p>
        """
        return pulumi.get(self, "replication_instance_ipv6_addresses")

    @property
    @pulumi.getter(name="replicationInstancePrivateIpAddress")
    def replication_instance_private_ip_address(self) -> Optional[str]:
        """
        <p>The private IP address of the replication instance.</p>
        """
        return pulumi.get(self, "replication_instance_private_ip_address")

    @property
    @pulumi.getter(name="replicationInstancePrivateIpAddresses")
    def replication_instance_private_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        <p>One or more private IP addresses for the replication instance.</p>
        """
        return pulumi.get(self, "replication_instance_private_ip_addresses")

    @property
    @pulumi.getter(name="replicationInstancePublicIpAddress")
    def replication_instance_public_ip_address(self) -> Optional[str]:
        """
        <p>The public IP address of the replication instance.</p>
        """
        return pulumi.get(self, "replication_instance_public_ip_address")

    @property
    @pulumi.getter(name="replicationInstancePublicIpAddresses")
    def replication_instance_public_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        <p>One or more public IP addresses for the replication instance.</p>
        """
        return pulumi.get(self, "replication_instance_public_ip_addresses")

    @property
    @pulumi.getter(name="replicationInstanceStatus")
    def replication_instance_status(self) -> Optional[str]:
        """
        <p>The status of the replication instance. The possible return values include:</p> <ul> <li> <p> <code>'available'</code> </p> </li> <li> <p> <code>'creating'</code> </p> </li> <li> <p> <code>'deleted'</code> </p> </li> <li> <p> <code>'deleting'</code> </p> </li> <li> <p> <code>'failed'</code> </p> </li> <li> <p> <code>'modifying'</code> </p> </li> <li> <p> <code>'upgrading'</code> </p> </li> <li> <p> <code>'rebooting'</code> </p> </li> <li> <p> <code>'resetting-master-credentials'</code> </p> </li> <li> <p> <code>'storage-full'</code> </p> </li> <li> <p> <code>'incompatible-credentials'</code> </p> </li> <li> <p> <code>'incompatible-network'</code> </p> </li> <li> <p> <code>'maintenance'</code> </p> </li> </ul>
        """
        return pulumi.get(self, "replication_instance_status")

    @property
    @pulumi.getter(name="replicationSubnetGroup")
    def replication_subnet_group(self) -> Optional['outputs.ReplicationSubnetGroupResponse']:
        """
        <p>The subnet group for the replication instance.</p>
        """
        return pulumi.get(self, "replication_subnet_group")

    @property
    @pulumi.getter(name="secondaryAvailabilityZone")
    def secondary_availability_zone(self) -> Optional[str]:
        """
        <p>The Availability Zone of the standby replication instance in a Multi-AZ deployment.</p>
        """
        return pulumi.get(self, "secondary_availability_zone")

    @property
    @pulumi.getter(name="vpcSecurityGroups")
    def vpc_security_groups(self) -> Optional[Sequence['outputs.VpcSecurityGroupMembershipResponse']]:
        """
        <p>The VPC security group for the instance.</p>
        """
        return pulumi.get(self, "vpc_security_groups")


@pulumi.output_type
class AwsDaxClusterPropertiesResponse(dict):
    """
    Definition of awsDaxCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeNodes":
            suggest = "active_nodes"
        elif key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "clusterDiscoveryEndpoint":
            suggest = "cluster_discovery_endpoint"
        elif key == "clusterEndpointEncryptionType":
            suggest = "cluster_endpoint_encryption_type"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "iamRoleArn":
            suggest = "iam_role_arn"
        elif key == "nodeIdsToRemove":
            suggest = "node_ids_to_remove"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "notificationConfiguration":
            suggest = "notification_configuration"
        elif key == "parameterGroup":
            suggest = "parameter_group"
        elif key == "preferredMaintenanceWindow":
            suggest = "preferred_maintenance_window"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "sseDescription":
            suggest = "sse_description"
        elif key == "subnetGroup":
            suggest = "subnet_group"
        elif key == "totalNodes":
            suggest = "total_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsDaxClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsDaxClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsDaxClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_nodes: Optional[int] = None,
                 cluster_arn: Optional[str] = None,
                 cluster_discovery_endpoint: Optional['outputs.DaxClusterEndpointResponse'] = None,
                 cluster_endpoint_encryption_type: Optional['outputs.ClusterEndpointEncryptionTypeEnumValueResponse'] = None,
                 cluster_name: Optional[str] = None,
                 description: Optional[str] = None,
                 iam_role_arn: Optional[str] = None,
                 node_ids_to_remove: Optional[Sequence[str]] = None,
                 node_type: Optional[str] = None,
                 nodes: Optional[Sequence['outputs.NodeResponse']] = None,
                 notification_configuration: Optional['outputs.NotificationConfigurationResponse'] = None,
                 parameter_group: Optional['outputs.ParameterGroupStatusResponse'] = None,
                 preferred_maintenance_window: Optional[str] = None,
                 security_groups: Optional[Sequence['outputs.SecurityGroupMembershipResponse']] = None,
                 sse_description: Optional['outputs.SSEDescriptionResponse'] = None,
                 status: Optional[str] = None,
                 subnet_group: Optional[str] = None,
                 total_nodes: Optional[int] = None):
        """
        Definition of awsDaxCluster
        :param int active_nodes: <p>The number of nodes in the cluster that are active (i.e., capable of serving requests).</p>
        :param str cluster_arn: <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster. </p>
        :param 'DaxClusterEndpointResponse' cluster_discovery_endpoint: <p>The endpoint for this DAX cluster, consisting of a DNS name, a port number, and a URL. Applications should use the URL to configure the DAX client to find their cluster.</p>
        :param 'ClusterEndpointEncryptionTypeEnumValueResponse' cluster_endpoint_encryption_type: <p>The type of encryption supported by the cluster's endpoint. Values are:</p> <ul> <li> <p> <code>NONE</code> for no encryption</p> <p> <code>TLS</code> for Transport Layer Security</p> </li> </ul>
        :param str cluster_name: <p>The name of the DAX cluster.</p>
        :param str description: <p>The description of the cluster.</p>
        :param str iam_role_arn: <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.</p>
        :param Sequence[str] node_ids_to_remove: <p>A list of nodes to be removed from the cluster.</p>
        :param str node_type: <p>The node type for the nodes in the cluster. (All nodes in a DAX cluster are of the same type.)</p>
        :param Sequence['NodeResponse'] nodes: <p>A list of nodes that are currently in the cluster.</p>
        :param 'NotificationConfigurationResponse' notification_configuration: <p>Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).</p>
        :param 'ParameterGroupStatusResponse' parameter_group: <p>The parameter group being used by nodes in the cluster.</p>
        :param str preferred_maintenance_window: <p>A range of time when maintenance of DAX cluster software will be performed. For example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.</p>
        :param Sequence['SecurityGroupMembershipResponse'] security_groups: <p>A list of security groups, and the status of each, for the nodes in the cluster.</p>
        :param 'SSEDescriptionResponse' sse_description: <p>The description of the server-side encryption status on the specified DAX cluster.</p>
        :param str status: <p>The current status of the cluster.</p>
        :param str subnet_group: <p>The subnet group where the DAX cluster is running.</p>
        :param int total_nodes: <p>The total number of nodes in the cluster.</p>
        """
        if active_nodes is not None:
            pulumi.set(__self__, "active_nodes", active_nodes)
        if cluster_arn is not None:
            pulumi.set(__self__, "cluster_arn", cluster_arn)
        if cluster_discovery_endpoint is not None:
            pulumi.set(__self__, "cluster_discovery_endpoint", cluster_discovery_endpoint)
        if cluster_endpoint_encryption_type is not None:
            pulumi.set(__self__, "cluster_endpoint_encryption_type", cluster_endpoint_encryption_type)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if iam_role_arn is not None:
            pulumi.set(__self__, "iam_role_arn", iam_role_arn)
        if node_ids_to_remove is not None:
            pulumi.set(__self__, "node_ids_to_remove", node_ids_to_remove)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if notification_configuration is not None:
            pulumi.set(__self__, "notification_configuration", notification_configuration)
        if parameter_group is not None:
            pulumi.set(__self__, "parameter_group", parameter_group)
        if preferred_maintenance_window is not None:
            pulumi.set(__self__, "preferred_maintenance_window", preferred_maintenance_window)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if sse_description is not None:
            pulumi.set(__self__, "sse_description", sse_description)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if subnet_group is not None:
            pulumi.set(__self__, "subnet_group", subnet_group)
        if total_nodes is not None:
            pulumi.set(__self__, "total_nodes", total_nodes)

    @property
    @pulumi.getter(name="activeNodes")
    def active_nodes(self) -> Optional[int]:
        """
        <p>The number of nodes in the cluster that are active (i.e., capable of serving requests).</p>
        """
        return pulumi.get(self, "active_nodes")

    @property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster. </p>
        """
        return pulumi.get(self, "cluster_arn")

    @property
    @pulumi.getter(name="clusterDiscoveryEndpoint")
    def cluster_discovery_endpoint(self) -> Optional['outputs.DaxClusterEndpointResponse']:
        """
        <p>The endpoint for this DAX cluster, consisting of a DNS name, a port number, and a URL. Applications should use the URL to configure the DAX client to find their cluster.</p>
        """
        return pulumi.get(self, "cluster_discovery_endpoint")

    @property
    @pulumi.getter(name="clusterEndpointEncryptionType")
    def cluster_endpoint_encryption_type(self) -> Optional['outputs.ClusterEndpointEncryptionTypeEnumValueResponse']:
        """
        <p>The type of encryption supported by the cluster's endpoint. Values are:</p> <ul> <li> <p> <code>NONE</code> for no encryption</p> <p> <code>TLS</code> for Transport Layer Security</p> </li> </ul>
        """
        return pulumi.get(self, "cluster_endpoint_encryption_type")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        <p>The name of the DAX cluster.</p>
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>The description of the cluster.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> Optional[str]:
        """
        <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this role and use the role's permissions to access DynamoDB on your behalf.</p>
        """
        return pulumi.get(self, "iam_role_arn")

    @property
    @pulumi.getter(name="nodeIdsToRemove")
    def node_ids_to_remove(self) -> Optional[Sequence[str]]:
        """
        <p>A list of nodes to be removed from the cluster.</p>
        """
        return pulumi.get(self, "node_ids_to_remove")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        <p>The node type for the nodes in the cluster. (All nodes in a DAX cluster are of the same type.)</p>
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.NodeResponse']]:
        """
        <p>A list of nodes that are currently in the cluster.</p>
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter(name="notificationConfiguration")
    def notification_configuration(self) -> Optional['outputs.NotificationConfigurationResponse']:
        """
        <p>Describes a notification topic and its status. Notification topics are used for publishing DAX events to subscribers using Amazon Simple Notification Service (SNS).</p>
        """
        return pulumi.get(self, "notification_configuration")

    @property
    @pulumi.getter(name="parameterGroup")
    def parameter_group(self) -> Optional['outputs.ParameterGroupStatusResponse']:
        """
        <p>The parameter group being used by nodes in the cluster.</p>
        """
        return pulumi.get(self, "parameter_group")

    @property
    @pulumi.getter(name="preferredMaintenanceWindow")
    def preferred_maintenance_window(self) -> Optional[str]:
        """
        <p>A range of time when maintenance of DAX cluster software will be performed. For example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than 30 minutes, and is performed automatically within the maintenance window.</p>
        """
        return pulumi.get(self, "preferred_maintenance_window")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.SecurityGroupMembershipResponse']]:
        """
        <p>A list of security groups, and the status of each, for the nodes in the cluster.</p>
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="sseDescription")
    def sse_description(self) -> Optional['outputs.SSEDescriptionResponse']:
        """
        <p>The description of the server-side encryption status on the specified DAX cluster.</p>
        """
        return pulumi.get(self, "sse_description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        <p>The current status of the cluster.</p>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subnetGroup")
    def subnet_group(self) -> Optional[str]:
        """
        <p>The subnet group where the DAX cluster is running.</p>
        """
        return pulumi.get(self, "subnet_group")

    @property
    @pulumi.getter(name="totalNodes")
    def total_nodes(self) -> Optional[int]:
        """
        <p>The total number of nodes in the cluster.</p>
        """
        return pulumi.get(self, "total_nodes")


@pulumi.output_type
class AwsDynamoDBContinuousBackupsDescriptionPropertiesResponse(dict):
    """
    Definition of awsDynamoDBContinuousBackupsDescription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continuousBackupsStatus":
            suggest = "continuous_backups_status"
        elif key == "pointInTimeRecoveryDescription":
            suggest = "point_in_time_recovery_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsDynamoDBContinuousBackupsDescriptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsDynamoDBContinuousBackupsDescriptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsDynamoDBContinuousBackupsDescriptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continuous_backups_status: Optional['outputs.ContinuousBackupsStatusEnumValueResponse'] = None,
                 point_in_time_recovery_description: Optional['outputs.PointInTimeRecoveryDescriptionResponse'] = None):
        """
        Definition of awsDynamoDBContinuousBackupsDescription
        :param 'ContinuousBackupsStatusEnumValueResponse' continuous_backups_status: <p> <code>ContinuousBackupsStatus</code> can be one of the following states: ENABLED, DISABLED</p>
        :param 'PointInTimeRecoveryDescriptionResponse' point_in_time_recovery_description: <p>The description of the point in time recovery settings applied to the table.</p>
        """
        if continuous_backups_status is not None:
            pulumi.set(__self__, "continuous_backups_status", continuous_backups_status)
        if point_in_time_recovery_description is not None:
            pulumi.set(__self__, "point_in_time_recovery_description", point_in_time_recovery_description)

    @property
    @pulumi.getter(name="continuousBackupsStatus")
    def continuous_backups_status(self) -> Optional['outputs.ContinuousBackupsStatusEnumValueResponse']:
        """
        <p> <code>ContinuousBackupsStatus</code> can be one of the following states: ENABLED, DISABLED</p>
        """
        return pulumi.get(self, "continuous_backups_status")

    @property
    @pulumi.getter(name="pointInTimeRecoveryDescription")
    def point_in_time_recovery_description(self) -> Optional['outputs.PointInTimeRecoveryDescriptionResponse']:
        """
        <p>The description of the point in time recovery settings applied to the table.</p>
        """
        return pulumi.get(self, "point_in_time_recovery_description")


@pulumi.output_type
class AwsDynamoDBTablePropertiesResponse(dict):
    """
    Definition of awsDynamoDBTable
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeDefinitions":
            suggest = "attribute_definitions"
        elif key == "billingMode":
            suggest = "billing_mode"
        elif key == "contributorInsightsSpecification":
            suggest = "contributor_insights_specification"
        elif key == "deletionProtectionEnabled":
            suggest = "deletion_protection_enabled"
        elif key == "globalSecondaryIndexes":
            suggest = "global_secondary_indexes"
        elif key == "importSourceSpecification":
            suggest = "import_source_specification"
        elif key == "keySchema":
            suggest = "key_schema"
        elif key == "kinesisStreamSpecification":
            suggest = "kinesis_stream_specification"
        elif key == "localSecondaryIndexes":
            suggest = "local_secondary_indexes"
        elif key == "pointInTimeRecoverySpecification":
            suggest = "point_in_time_recovery_specification"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"
        elif key == "resourcePolicy":
            suggest = "resource_policy"
        elif key == "sseSpecification":
            suggest = "sse_specification"
        elif key == "streamArn":
            suggest = "stream_arn"
        elif key == "streamSpecification":
            suggest = "stream_specification"
        elif key == "tableClass":
            suggest = "table_class"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "timeToLiveSpecification":
            suggest = "time_to_live_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsDynamoDBTablePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsDynamoDBTablePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsDynamoDBTablePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 attribute_definitions: Optional[Sequence['outputs.AttributeDefinitionResponse']] = None,
                 billing_mode: Optional[str] = None,
                 contributor_insights_specification: Optional['outputs.ContributorInsightsSpecificationResponse'] = None,
                 deletion_protection_enabled: Optional[bool] = None,
                 global_secondary_indexes: Optional[Sequence['outputs.GlobalSecondaryIndexResponse']] = None,
                 import_source_specification: Optional['outputs.ImportSourceSpecificationResponse'] = None,
                 key_schema: Optional[Sequence['outputs.KeySchemaResponse']] = None,
                 kinesis_stream_specification: Optional['outputs.KinesisStreamSpecificationResponse'] = None,
                 local_secondary_indexes: Optional[Sequence['outputs.LocalSecondaryIndexResponse']] = None,
                 point_in_time_recovery_specification: Optional['outputs.PointInTimeRecoverySpecificationResponse'] = None,
                 provisioned_throughput: Optional['outputs.ProvisionedThroughputResponse'] = None,
                 resource_policy: Optional['outputs.ResourcePolicyResponse'] = None,
                 sse_specification: Optional['outputs.SSESpecificationResponse'] = None,
                 stream_arn: Optional[str] = None,
                 stream_specification: Optional['outputs.StreamSpecificationResponse'] = None,
                 table_class: Optional[str] = None,
                 table_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 time_to_live_specification: Optional['outputs.TimeToLiveSpecificationResponse'] = None):
        """
        Definition of awsDynamoDBTable
        :param str arn: Property arn
        :param Sequence['AttributeDefinitionResponse'] attribute_definitions: A list of attributes that describe the key schema for the table and indexes. This property is required to create a DDB table. Update requires: [Some interruptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-some-interrupt). Replacement if you edit an existing AttributeDefinition.
        :param str billing_mode: Specify how you are charged for read and write throughput and how you manage capacity. Valid values include:  +   ``PROVISIONED`` - We recommend using ``PROVISIONED`` for predictable workloads. ``PROVISIONED`` sets the billing mode to [Provisioned Mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual).  +   ``PAY_PER_REQUEST`` - We recommend using ``PAY_PER_REQUEST`` for unpredictable workloads. ``PAY_PER_REQUEST`` sets the billing mode to [On-Demand Mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand).   If not specified, the default is ``PROVISIONED``.
        :param 'ContributorInsightsSpecificationResponse' contributor_insights_specification: The settings used to enable or disable CloudWatch Contributor Insights for the specified table. The settings used to enable or disable CloudWatch Contributor Insights.
        :param bool deletion_protection_enabled: Determines if a table is protected from deletion. When enabled, the table cannot be deleted by any user or process. This setting is disabled by default. For more information, see [Using deletion protection](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.Basics.html#WorkingWithTables.Basics.DeletionProtection) in the *Developer Guide*.
        :param Sequence['GlobalSecondaryIndexResponse'] global_secondary_indexes: Global secondary indexes to be created on the table. You can create up to 20 global secondary indexes.  If you update a table to include a new global secondary index, CFNlong initiates the index creation and then proceeds with the stack update. CFNlong doesn't wait for the index to complete creation because the backfilling phase can take a long time, depending on the size of the table. You can't use the index or update the table until the index's status is ``ACTIVE``. You can track its status by using the DynamoDB [DescribeTable](https://docs.aws.amazon.com/cli/latest/reference/dynamodb/describe-table.html) command. If you add or delete an index during an update, we recommend that you don't update any other resources. If your stack fails to update and is rolled back while adding a new index, you must manually delete the index.  Updates are not supported. The following are exceptions:  +  If you update either the contributor insights specification or the provisioned throughput values of global secondary indexes, you can update the table without interruption.  +  You can delete or add one global secondary index without interruption. If you do both in the same update (for example, by changing the index's logical ID), the update fails.
        :param 'ImportSourceSpecificationResponse' import_source_specification: Specifies the properties of data being imported from the S3 bucket source to the table.  If you specify the ``ImportSourceSpecification`` property, and also specify either the ``StreamSpecification``, the ``TableClass`` property, or the ``DeletionProtectionEnabled`` property, the IAM entity creating/updating stack must have ``UpdateTable`` permission. Specifies the properties of data being imported from the S3 bucket source to the table.
        :param Sequence['KeySchemaResponse'] key_schema: Specifies the attributes that make up the primary key for the table. The attributes in the ``KeySchema`` property must also be defined in the ``AttributeDefinitions`` property.
        :param 'KinesisStreamSpecificationResponse' kinesis_stream_specification: The Kinesis Data Streams configuration for the specified table. The Kinesis Data Streams configuration for the specified table.
        :param Sequence['LocalSecondaryIndexResponse'] local_secondary_indexes: Local secondary indexes to be created on the table. You can create up to 5 local secondary indexes. Each index is scoped to a given hash key value. The size of each hash key can be up to 10 gigabytes.
        :param 'PointInTimeRecoverySpecificationResponse' point_in_time_recovery_specification: The settings used to enable point in time recovery. The settings used to enable point in time recovery.
        :param 'ProvisionedThroughputResponse' provisioned_throughput: Throughput for the specified table, which consists of values for ``ReadCapacityUnits`` and ``WriteCapacityUnits``. For more information about the contents of a provisioned throughput structure, see [Amazon DynamoDB Table ProvisionedThroughput](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ProvisionedThroughput.html).  If you set ``BillingMode`` as ``PROVISIONED``, you must specify this property. If you set ``BillingMode`` as ``PAY_PER_REQUEST``, you cannot specify this property. Throughput for the specified table, which consists of values for ``ReadCapacityUnits`` and ``WriteCapacityUnits``. For more information about the contents of a provisioned throughput structure, see [Table ProvisionedThroughput](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ProvisionedThroughput.html).
        :param 'ResourcePolicyResponse' resource_policy: A resource-based policy document that contains permissions to add to the specified table. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). When you attach a resource-based policy while creating a table, the policy creation is *strongly consistent*. For information about the considerations that you should keep in mind while attaching a resource-based policy, see [Resource-based policy considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html). Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a table, its indexes, and stream. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). While defining resource-based policies in your CFNshort templates, the following considerations apply:  +  The maximum size supported for a resource-based policy document in JSON format is 20 KB. DDB counts whitespaces when calculating the size of a policy against this limit.   +  Resource-based policies don't support [drift detection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html#). If you update a policy outside of the CFNshort stack template, you'll need to update the CFNshort stack with the changes.  +  Resource-based policies don't support out-of-band changes. If you add, update, or delete a policy outside of the CFNshort template, the change won't be overwritten if there are no changes to the policy within the template. For example, say that your template contains a resource-based policy, which you later update outside of the template. If you don't make any changes to the policy in the template, the updated policy in DDB wont be synced with the policy in the template. Conversely, say that your template doesnt contain a resource-based policy, but you add a policy outside of the template. This policy wont be removed from DDB as long as you dont add it to the template. When you add a policy to the template and update the stack, the existing policy in DDB will be updated to match the one defined in the template.   For a full list of all considerations, see [Resource-based policy considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
        :param 'SSESpecificationResponse' sse_specification: Specifies the settings to enable server-side encryption. Represents the settings used to enable server-side encryption.
        :param str stream_arn: Property streamArn
        :param 'StreamSpecificationResponse' stream_specification: The settings for the DDB table stream, which capture changes to items stored in the table. Represents the DynamoDB Streams configuration for a table in DynamoDB.
        :param str table_class: The table class of the new table. Valid values are ``STANDARD`` and ``STANDARD_INFREQUENT_ACCESS``.
        :param str table_name: A name for the table. If you don't specify a name, CFNlong generates a unique physical ID and uses that ID for the table name. For more information, see [Name Type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html).  If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        :param Sequence['TagResponse'] tags: An array of key-value pairs to apply to this resource. For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        :param 'TimeToLiveSpecificationResponse' time_to_live_specification: Specifies the Time to Live (TTL) settings for the table.  For detailed information about the limits in DynamoDB, see [Limits in Amazon DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide. Represents the settings used to enable or disable Time to Live (TTL) for the specified table.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if attribute_definitions is not None:
            pulumi.set(__self__, "attribute_definitions", attribute_definitions)
        if billing_mode is not None:
            pulumi.set(__self__, "billing_mode", billing_mode)
        if contributor_insights_specification is not None:
            pulumi.set(__self__, "contributor_insights_specification", contributor_insights_specification)
        if deletion_protection_enabled is not None:
            pulumi.set(__self__, "deletion_protection_enabled", deletion_protection_enabled)
        if global_secondary_indexes is not None:
            pulumi.set(__self__, "global_secondary_indexes", global_secondary_indexes)
        if import_source_specification is not None:
            pulumi.set(__self__, "import_source_specification", import_source_specification)
        if key_schema is not None:
            pulumi.set(__self__, "key_schema", key_schema)
        if kinesis_stream_specification is not None:
            pulumi.set(__self__, "kinesis_stream_specification", kinesis_stream_specification)
        if local_secondary_indexes is not None:
            pulumi.set(__self__, "local_secondary_indexes", local_secondary_indexes)
        if point_in_time_recovery_specification is not None:
            pulumi.set(__self__, "point_in_time_recovery_specification", point_in_time_recovery_specification)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if resource_policy is not None:
            pulumi.set(__self__, "resource_policy", resource_policy)
        if sse_specification is not None:
            pulumi.set(__self__, "sse_specification", sse_specification)
        if stream_arn is not None:
            pulumi.set(__self__, "stream_arn", stream_arn)
        if stream_specification is not None:
            pulumi.set(__self__, "stream_specification", stream_specification)
        if table_class is not None:
            pulumi.set(__self__, "table_class", table_class)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time_to_live_specification is not None:
            pulumi.set(__self__, "time_to_live_specification", time_to_live_specification)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="attributeDefinitions")
    def attribute_definitions(self) -> Optional[Sequence['outputs.AttributeDefinitionResponse']]:
        """
        A list of attributes that describe the key schema for the table and indexes. This property is required to create a DDB table. Update requires: [Some interruptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-some-interrupt). Replacement if you edit an existing AttributeDefinition.
        """
        return pulumi.get(self, "attribute_definitions")

    @property
    @pulumi.getter(name="billingMode")
    def billing_mode(self) -> Optional[str]:
        """
        Specify how you are charged for read and write throughput and how you manage capacity. Valid values include:  +   ``PROVISIONED`` - We recommend using ``PROVISIONED`` for predictable workloads. ``PROVISIONED`` sets the billing mode to [Provisioned Mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual).  +   ``PAY_PER_REQUEST`` - We recommend using ``PAY_PER_REQUEST`` for unpredictable workloads. ``PAY_PER_REQUEST`` sets the billing mode to [On-Demand Mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand).   If not specified, the default is ``PROVISIONED``.
        """
        return pulumi.get(self, "billing_mode")

    @property
    @pulumi.getter(name="contributorInsightsSpecification")
    def contributor_insights_specification(self) -> Optional['outputs.ContributorInsightsSpecificationResponse']:
        """
        The settings used to enable or disable CloudWatch Contributor Insights for the specified table. The settings used to enable or disable CloudWatch Contributor Insights.
        """
        return pulumi.get(self, "contributor_insights_specification")

    @property
    @pulumi.getter(name="deletionProtectionEnabled")
    def deletion_protection_enabled(self) -> Optional[bool]:
        """
        Determines if a table is protected from deletion. When enabled, the table cannot be deleted by any user or process. This setting is disabled by default. For more information, see [Using deletion protection](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.Basics.html#WorkingWithTables.Basics.DeletionProtection) in the *Developer Guide*.
        """
        return pulumi.get(self, "deletion_protection_enabled")

    @property
    @pulumi.getter(name="globalSecondaryIndexes")
    def global_secondary_indexes(self) -> Optional[Sequence['outputs.GlobalSecondaryIndexResponse']]:
        """
        Global secondary indexes to be created on the table. You can create up to 20 global secondary indexes.  If you update a table to include a new global secondary index, CFNlong initiates the index creation and then proceeds with the stack update. CFNlong doesn't wait for the index to complete creation because the backfilling phase can take a long time, depending on the size of the table. You can't use the index or update the table until the index's status is ``ACTIVE``. You can track its status by using the DynamoDB [DescribeTable](https://docs.aws.amazon.com/cli/latest/reference/dynamodb/describe-table.html) command. If you add or delete an index during an update, we recommend that you don't update any other resources. If your stack fails to update and is rolled back while adding a new index, you must manually delete the index.  Updates are not supported. The following are exceptions:  +  If you update either the contributor insights specification or the provisioned throughput values of global secondary indexes, you can update the table without interruption.  +  You can delete or add one global secondary index without interruption. If you do both in the same update (for example, by changing the index's logical ID), the update fails.
        """
        return pulumi.get(self, "global_secondary_indexes")

    @property
    @pulumi.getter(name="importSourceSpecification")
    def import_source_specification(self) -> Optional['outputs.ImportSourceSpecificationResponse']:
        """
        Specifies the properties of data being imported from the S3 bucket source to the table.  If you specify the ``ImportSourceSpecification`` property, and also specify either the ``StreamSpecification``, the ``TableClass`` property, or the ``DeletionProtectionEnabled`` property, the IAM entity creating/updating stack must have ``UpdateTable`` permission. Specifies the properties of data being imported from the S3 bucket source to the table.
        """
        return pulumi.get(self, "import_source_specification")

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> Optional[Sequence['outputs.KeySchemaResponse']]:
        """
        Specifies the attributes that make up the primary key for the table. The attributes in the ``KeySchema`` property must also be defined in the ``AttributeDefinitions`` property.
        """
        return pulumi.get(self, "key_schema")

    @property
    @pulumi.getter(name="kinesisStreamSpecification")
    def kinesis_stream_specification(self) -> Optional['outputs.KinesisStreamSpecificationResponse']:
        """
        The Kinesis Data Streams configuration for the specified table. The Kinesis Data Streams configuration for the specified table.
        """
        return pulumi.get(self, "kinesis_stream_specification")

    @property
    @pulumi.getter(name="localSecondaryIndexes")
    def local_secondary_indexes(self) -> Optional[Sequence['outputs.LocalSecondaryIndexResponse']]:
        """
        Local secondary indexes to be created on the table. You can create up to 5 local secondary indexes. Each index is scoped to a given hash key value. The size of each hash key can be up to 10 gigabytes.
        """
        return pulumi.get(self, "local_secondary_indexes")

    @property
    @pulumi.getter(name="pointInTimeRecoverySpecification")
    def point_in_time_recovery_specification(self) -> Optional['outputs.PointInTimeRecoverySpecificationResponse']:
        """
        The settings used to enable point in time recovery. The settings used to enable point in time recovery.
        """
        return pulumi.get(self, "point_in_time_recovery_specification")

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional['outputs.ProvisionedThroughputResponse']:
        """
        Throughput for the specified table, which consists of values for ``ReadCapacityUnits`` and ``WriteCapacityUnits``. For more information about the contents of a provisioned throughput structure, see [Amazon DynamoDB Table ProvisionedThroughput](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ProvisionedThroughput.html).  If you set ``BillingMode`` as ``PROVISIONED``, you must specify this property. If you set ``BillingMode`` as ``PAY_PER_REQUEST``, you cannot specify this property. Throughput for the specified table, which consists of values for ``ReadCapacityUnits`` and ``WriteCapacityUnits``. For more information about the contents of a provisioned throughput structure, see [Table ProvisionedThroughput](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ProvisionedThroughput.html).
        """
        return pulumi.get(self, "provisioned_throughput")

    @property
    @pulumi.getter(name="resourcePolicy")
    def resource_policy(self) -> Optional['outputs.ResourcePolicyResponse']:
        """
        A resource-based policy document that contains permissions to add to the specified table. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). When you attach a resource-based policy while creating a table, the policy creation is *strongly consistent*. For information about the considerations that you should keep in mind while attaching a resource-based policy, see [Resource-based policy considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html). Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a table, its indexes, and stream. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). While defining resource-based policies in your CFNshort templates, the following considerations apply:  +  The maximum size supported for a resource-based policy document in JSON format is 20 KB. DDB counts whitespaces when calculating the size of a policy against this limit.   +  Resource-based policies don't support [drift detection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html#). If you update a policy outside of the CFNshort stack template, you'll need to update the CFNshort stack with the changes.  +  Resource-based policies don't support out-of-band changes. If you add, update, or delete a policy outside of the CFNshort template, the change won't be overwritten if there are no changes to the policy within the template. For example, say that your template contains a resource-based policy, which you later update outside of the template. If you don't make any changes to the policy in the template, the updated policy in DDB wont be synced with the policy in the template. Conversely, say that your template doesnt contain a resource-based policy, but you add a policy outside of the template. This policy wont be removed from DDB as long as you dont add it to the template. When you add a policy to the template and update the stack, the existing policy in DDB will be updated to match the one defined in the template.   For a full list of all considerations, see [Resource-based policy considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
        """
        return pulumi.get(self, "resource_policy")

    @property
    @pulumi.getter(name="sseSpecification")
    def sse_specification(self) -> Optional['outputs.SSESpecificationResponse']:
        """
        Specifies the settings to enable server-side encryption. Represents the settings used to enable server-side encryption.
        """
        return pulumi.get(self, "sse_specification")

    @property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> Optional[str]:
        """
        Property streamArn
        """
        return pulumi.get(self, "stream_arn")

    @property
    @pulumi.getter(name="streamSpecification")
    def stream_specification(self) -> Optional['outputs.StreamSpecificationResponse']:
        """
        The settings for the DDB table stream, which capture changes to items stored in the table. Represents the DynamoDB Streams configuration for a table in DynamoDB.
        """
        return pulumi.get(self, "stream_specification")

    @property
    @pulumi.getter(name="tableClass")
    def table_class(self) -> Optional[str]:
        """
        The table class of the new table. Valid values are ``STANDARD`` and ``STANDARD_INFREQUENT_ACCESS``.
        """
        return pulumi.get(self, "table_class")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[str]:
        """
        A name for the table. If you don't specify a name, CFNlong generates a unique physical ID and uses that ID for the table name. For more information, see [Name Type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html).  If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An array of key-value pairs to apply to this resource. For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="timeToLiveSpecification")
    def time_to_live_specification(self) -> Optional['outputs.TimeToLiveSpecificationResponse']:
        """
        Specifies the Time to Live (TTL) settings for the table.  For detailed information about the limits in DynamoDB, see [Limits in Amazon DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the Amazon DynamoDB Developer Guide. Represents the settings used to enable or disable Time to Live (TTL) for the specified table.
        """
        return pulumi.get(self, "time_to_live_specification")


@pulumi.output_type
class AwsEc2AccountAttributePropertiesResponse(dict):
    """
    Definition of awsEc2AccountAttribute
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValues":
            suggest = "attribute_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2AccountAttributePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2AccountAttributePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2AccountAttributePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_values: Optional[Sequence['outputs.AccountAttributeValueResponse']] = None):
        """
        Definition of awsEc2AccountAttribute
        :param str attribute_name: <p>The name of the account attribute.</p>
        :param Sequence['AccountAttributeValueResponse'] attribute_values: <p>The values for the account attribute.</p>
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_values is not None:
            pulumi.set(__self__, "attribute_values", attribute_values)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        """
        <p>The name of the account attribute.</p>
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValues")
    def attribute_values(self) -> Optional[Sequence['outputs.AccountAttributeValueResponse']]:
        """
        <p>The values for the account attribute.</p>
        """
        return pulumi.get(self, "attribute_values")


@pulumi.output_type
class AwsEc2AddressPropertiesResponse(dict):
    """
    Definition of awsEc2Address
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"
        elif key == "associationId":
            suggest = "association_id"
        elif key == "carrierIp":
            suggest = "carrier_ip"
        elif key == "customerOwnedIp":
            suggest = "customer_owned_ip"
        elif key == "customerOwnedIpv4Pool":
            suggest = "customer_owned_ipv4_pool"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "networkBorderGroup":
            suggest = "network_border_group"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "networkInterfaceOwnerId":
            suggest = "network_interface_owner_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "publicIp":
            suggest = "public_ip"
        elif key == "publicIpv4Pool":
            suggest = "public_ipv4_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2AddressPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2AddressPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2AddressPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_id: Optional[str] = None,
                 association_id: Optional[str] = None,
                 carrier_ip: Optional[str] = None,
                 customer_owned_ip: Optional[str] = None,
                 customer_owned_ipv4_pool: Optional[str] = None,
                 domain: Optional['outputs.DomainTypeEnumValueResponse'] = None,
                 instance_id: Optional[str] = None,
                 network_border_group: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 network_interface_owner_id: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 public_ip: Optional[str] = None,
                 public_ipv4_pool: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsEc2Address
        :param str allocation_id: <p>The ID representing the allocation of the address.</p>
        :param str association_id: <p>The ID representing the association of the address with an instance.</p>
        :param str carrier_ip: <p>The carrier IP address associated. This option is only available for network interfaces which reside in a subnet in a Wavelength Zone (for example an EC2 instance). </p>
        :param str customer_owned_ip: <p>The customer-owned IP address.</p>
        :param str customer_owned_ipv4_pool: <p>The ID of the customer-owned address pool.</p>
        :param 'DomainTypeEnumValueResponse' domain: <p>The network (<code>vpc</code>).</p>
        :param str instance_id: <p>The ID of the instance that the address is associated with (if any).</p>
        :param str network_border_group: <p>The name of the unique set of Availability Zones, Local Zones, or Wavelength Zones from which Amazon Web Services advertises IP addresses.</p>
        :param str network_interface_id: <p>The ID of the network interface.</p>
        :param str network_interface_owner_id: <p>The ID of the Amazon Web Services account that owns the network interface.</p>
        :param str private_ip_address: <p>The private IP address associated with the Elastic IP address.</p>
        :param str public_ip: <p>The Elastic IP address.</p>
        :param str public_ipv4_pool: <p>The ID of an address pool.</p>
        :param Sequence['TagResponse'] tags: <p>Any tags assigned to the Elastic IP address.</p>
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if association_id is not None:
            pulumi.set(__self__, "association_id", association_id)
        if carrier_ip is not None:
            pulumi.set(__self__, "carrier_ip", carrier_ip)
        if customer_owned_ip is not None:
            pulumi.set(__self__, "customer_owned_ip", customer_owned_ip)
        if customer_owned_ipv4_pool is not None:
            pulumi.set(__self__, "customer_owned_ipv4_pool", customer_owned_ipv4_pool)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if network_border_group is not None:
            pulumi.set(__self__, "network_border_group", network_border_group)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if network_interface_owner_id is not None:
            pulumi.set(__self__, "network_interface_owner_id", network_interface_owner_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if public_ipv4_pool is not None:
            pulumi.set(__self__, "public_ipv4_pool", public_ipv4_pool)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[str]:
        """
        <p>The ID representing the allocation of the address.</p>
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter(name="associationId")
    def association_id(self) -> Optional[str]:
        """
        <p>The ID representing the association of the address with an instance.</p>
        """
        return pulumi.get(self, "association_id")

    @property
    @pulumi.getter(name="carrierIp")
    def carrier_ip(self) -> Optional[str]:
        """
        <p>The carrier IP address associated. This option is only available for network interfaces which reside in a subnet in a Wavelength Zone (for example an EC2 instance). </p>
        """
        return pulumi.get(self, "carrier_ip")

    @property
    @pulumi.getter(name="customerOwnedIp")
    def customer_owned_ip(self) -> Optional[str]:
        """
        <p>The customer-owned IP address.</p>
        """
        return pulumi.get(self, "customer_owned_ip")

    @property
    @pulumi.getter(name="customerOwnedIpv4Pool")
    def customer_owned_ipv4_pool(self) -> Optional[str]:
        """
        <p>The ID of the customer-owned address pool.</p>
        """
        return pulumi.get(self, "customer_owned_ipv4_pool")

    @property
    @pulumi.getter
    def domain(self) -> Optional['outputs.DomainTypeEnumValueResponse']:
        """
        <p>The network (<code>vpc</code>).</p>
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        <p>The ID of the instance that the address is associated with (if any).</p>
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="networkBorderGroup")
    def network_border_group(self) -> Optional[str]:
        """
        <p>The name of the unique set of Availability Zones, Local Zones, or Wavelength Zones from which Amazon Web Services advertises IP addresses.</p>
        """
        return pulumi.get(self, "network_border_group")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        <p>The ID of the network interface.</p>
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="networkInterfaceOwnerId")
    def network_interface_owner_id(self) -> Optional[str]:
        """
        <p>The ID of the Amazon Web Services account that owns the network interface.</p>
        """
        return pulumi.get(self, "network_interface_owner_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        <p>The private IP address associated with the Elastic IP address.</p>
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[str]:
        """
        <p>The Elastic IP address.</p>
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="publicIpv4Pool")
    def public_ipv4_pool(self) -> Optional[str]:
        """
        <p>The ID of an address pool.</p>
        """
        return pulumi.get(self, "public_ipv4_pool")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        <p>Any tags assigned to the Elastic IP address.</p>
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsEc2FlowLogPropertiesResponse(dict):
    """
    Definition of awsEc2FlowLog
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliverCrossAccountRole":
            suggest = "deliver_cross_account_role"
        elif key == "deliverLogsPermissionArn":
            suggest = "deliver_logs_permission_arn"
        elif key == "destinationOptions":
            suggest = "destination_options"
        elif key == "logDestination":
            suggest = "log_destination"
        elif key == "logDestinationType":
            suggest = "log_destination_type"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "maxAggregationInterval":
            suggest = "max_aggregation_interval"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "trafficType":
            suggest = "traffic_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2FlowLogPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2FlowLogPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2FlowLogPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deliver_cross_account_role: Optional[str] = None,
                 deliver_logs_permission_arn: Optional[str] = None,
                 destination_options: Optional['outputs.DestinationOptionsModelPropertiesResponse'] = None,
                 id: Optional[str] = None,
                 log_destination: Optional[str] = None,
                 log_destination_type: Optional[str] = None,
                 log_format: Optional[str] = None,
                 log_group_name: Optional[str] = None,
                 max_aggregation_interval: Optional[int] = None,
                 resource_id: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 traffic_type: Optional[str] = None):
        """
        Definition of awsEc2FlowLog
        :param str deliver_cross_account_role: The ARN of the IAM role that allows Amazon EC2 to publish flow logs across accounts.
        :param str deliver_logs_permission_arn: The ARN for the IAM role that permits Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account. If you specify LogDestinationType as s3 or kinesis-data-firehose, do not specify DeliverLogsPermissionArn or LogGroupName.
        :param 'DestinationOptionsModelPropertiesResponse' destination_options: Property destinationOptions
        :param str id: The Flow Log ID
        :param str log_destination: Specifies the destination to which the flow log data is to be published. Flow log data can be published to a CloudWatch Logs log group, an Amazon S3 bucket, or a Kinesis Firehose stream. The value specified for this parameter depends on the value specified for LogDestinationType.
        :param str log_destination_type: Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3.
        :param str log_format: The fields to include in the flow log record, in the order in which they should appear.
        :param str log_group_name: The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs. If you specify LogDestinationType as s3 or kinesis-data-firehose, do not specify DeliverLogsPermissionArn or LogGroupName.
        :param int max_aggregation_interval: The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. You can specify 60 seconds (1 minute) or 600 seconds (10 minutes).
        :param str resource_id: The ID of the subnet, network interface, or VPC for which you want to create a flow log.
        :param str resource_type: The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ResourceId property, specify VPC for this property.
        :param Sequence['TagResponse'] tags: The tags to apply to the flow logs.
        :param str traffic_type: The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
        """
        if deliver_cross_account_role is not None:
            pulumi.set(__self__, "deliver_cross_account_role", deliver_cross_account_role)
        if deliver_logs_permission_arn is not None:
            pulumi.set(__self__, "deliver_logs_permission_arn", deliver_logs_permission_arn)
        if destination_options is not None:
            pulumi.set(__self__, "destination_options", destination_options)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if log_destination is not None:
            pulumi.set(__self__, "log_destination", log_destination)
        if log_destination_type is not None:
            pulumi.set(__self__, "log_destination_type", log_destination_type)
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if max_aggregation_interval is not None:
            pulumi.set(__self__, "max_aggregation_interval", max_aggregation_interval)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if traffic_type is not None:
            pulumi.set(__self__, "traffic_type", traffic_type)

    @property
    @pulumi.getter(name="deliverCrossAccountRole")
    def deliver_cross_account_role(self) -> Optional[str]:
        """
        The ARN of the IAM role that allows Amazon EC2 to publish flow logs across accounts.
        """
        return pulumi.get(self, "deliver_cross_account_role")

    @property
    @pulumi.getter(name="deliverLogsPermissionArn")
    def deliver_logs_permission_arn(self) -> Optional[str]:
        """
        The ARN for the IAM role that permits Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account. If you specify LogDestinationType as s3 or kinesis-data-firehose, do not specify DeliverLogsPermissionArn or LogGroupName.
        """
        return pulumi.get(self, "deliver_logs_permission_arn")

    @property
    @pulumi.getter(name="destinationOptions")
    def destination_options(self) -> Optional['outputs.DestinationOptionsModelPropertiesResponse']:
        """
        Property destinationOptions
        """
        return pulumi.get(self, "destination_options")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The Flow Log ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> Optional[str]:
        """
        Specifies the destination to which the flow log data is to be published. Flow log data can be published to a CloudWatch Logs log group, an Amazon S3 bucket, or a Kinesis Firehose stream. The value specified for this parameter depends on the value specified for LogDestinationType.
        """
        return pulumi.get(self, "log_destination")

    @property
    @pulumi.getter(name="logDestinationType")
    def log_destination_type(self) -> Optional[str]:
        """
        Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3.
        """
        return pulumi.get(self, "log_destination_type")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[str]:
        """
        The fields to include in the flow log record, in the order in which they should appear.
        """
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[str]:
        """
        The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs. If you specify LogDestinationType as s3 or kinesis-data-firehose, do not specify DeliverLogsPermissionArn or LogGroupName.
        """
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter(name="maxAggregationInterval")
    def max_aggregation_interval(self) -> Optional[int]:
        """
        The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. You can specify 60 seconds (1 minute) or 600 seconds (10 minutes).
        """
        return pulumi.get(self, "max_aggregation_interval")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The ID of the subnet, network interface, or VPC for which you want to create a flow log.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ResourceId property, specify VPC for this property.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The tags to apply to the flow logs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> Optional[str]:
        """
        The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
        """
        return pulumi.get(self, "traffic_type")


@pulumi.output_type
class AwsEc2ImagePropertiesResponse(dict):
    """
    Definition of awsEc2Image
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDeviceMappings":
            suggest = "block_device_mappings"
        elif key == "bootMode":
            suggest = "boot_mode"
        elif key == "creationDate":
            suggest = "creation_date"
        elif key == "deprecationTime":
            suggest = "deprecation_time"
        elif key == "deregistrationProtection":
            suggest = "deregistration_protection"
        elif key == "enaSupport":
            suggest = "ena_support"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "imageLocation":
            suggest = "image_location"
        elif key == "imageOwnerAlias":
            suggest = "image_owner_alias"
        elif key == "imageType":
            suggest = "image_type"
        elif key == "imdsSupport":
            suggest = "imds_support"
        elif key == "kernelId":
            suggest = "kernel_id"
        elif key == "lastLaunchedTime":
            suggest = "last_launched_time"
        elif key == "ownerId":
            suggest = "owner_id"
        elif key == "platformDetails":
            suggest = "platform_details"
        elif key == "productCodes":
            suggest = "product_codes"
        elif key == "ramdiskId":
            suggest = "ramdisk_id"
        elif key == "rootDeviceName":
            suggest = "root_device_name"
        elif key == "rootDeviceType":
            suggest = "root_device_type"
        elif key == "sourceInstanceId":
            suggest = "source_instance_id"
        elif key == "sriovNetSupport":
            suggest = "sriov_net_support"
        elif key == "stateReason":
            suggest = "state_reason"
        elif key == "tpmSupport":
            suggest = "tpm_support"
        elif key == "usageOperation":
            suggest = "usage_operation"
        elif key == "virtualizationType":
            suggest = "virtualization_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2ImagePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2ImagePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2ImagePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture: Optional['outputs.ArchitectureValuesEnumValueResponse'] = None,
                 block_device_mappings: Optional[Sequence['outputs.BlockDeviceMappingResponse']] = None,
                 boot_mode: Optional['outputs.BootModeValuesEnumValueResponse'] = None,
                 creation_date: Optional[str] = None,
                 deprecation_time: Optional[str] = None,
                 deregistration_protection: Optional[str] = None,
                 description: Optional[str] = None,
                 ena_support: Optional[bool] = None,
                 hypervisor: Optional['outputs.HypervisorTypeEnumValueResponse'] = None,
                 image_id: Optional[str] = None,
                 image_location: Optional[str] = None,
                 image_owner_alias: Optional[str] = None,
                 image_type: Optional['outputs.ImageTypeValuesEnumValueResponse'] = None,
                 imds_support: Optional['outputs.ImdsSupportValuesEnumValueResponse'] = None,
                 kernel_id: Optional[str] = None,
                 last_launched_time: Optional[str] = None,
                 name: Optional[str] = None,
                 owner_id: Optional[str] = None,
                 platform: Optional['outputs.PlatformValuesEnumValueResponse'] = None,
                 platform_details: Optional[str] = None,
                 product_codes: Optional[Sequence['outputs.ProductCodeResponse']] = None,
                 public: Optional[bool] = None,
                 ramdisk_id: Optional[str] = None,
                 root_device_name: Optional[str] = None,
                 root_device_type: Optional['outputs.DeviceTypeEnumValueResponse'] = None,
                 source_instance_id: Optional[str] = None,
                 sriov_net_support: Optional[str] = None,
                 state: Optional['outputs.ImageStateEnumValueResponse'] = None,
                 state_reason: Optional['outputs.StateReasonResponse'] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 tpm_support: Optional['outputs.TpmSupportValuesEnumValueResponse'] = None,
                 usage_operation: Optional[str] = None,
                 virtualization_type: Optional['outputs.VirtualizationTypeEnumValueResponse'] = None):
        """
        Definition of awsEc2Image
        :param 'ArchitectureValuesEnumValueResponse' architecture: <p>The architecture of the image.</p>
        :param Sequence['BlockDeviceMappingResponse'] block_device_mappings: <p>Any block device mapping entries.</p>
        :param 'BootModeValuesEnumValueResponse' boot_mode: <p>The boot mode of the image. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html'>Boot modes</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param str creation_date: <p>The date and time the image was created.</p>
        :param str deprecation_time: <p>The date and time to deprecate the AMI, in UTC, in the following format: <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z. If you specified a value for seconds, Amazon EC2 rounds the seconds to the nearest minute.</p>
        :param str deregistration_protection: <p>Indicates whether deregistration protection is enabled for the AMI.</p>
        :param str description: <p>The description of the AMI that was provided during image creation.</p>
        :param bool ena_support: <p>Specifies whether enhanced networking with ENA is enabled.</p>
        :param 'HypervisorTypeEnumValueResponse' hypervisor: <p>The hypervisor type of the image. Only <code>xen</code> is supported. <code>ovm</code> is not supported.</p>
        :param str image_id: <p>The ID of the AMI.</p>
        :param str image_location: <p>The location of the AMI.</p>
        :param str image_owner_alias: <p>The owner alias (<code>amazon</code> | <code>aws-marketplace</code>).</p>
        :param 'ImageTypeValuesEnumValueResponse' image_type: <p>The type of image.</p>
        :param 'ImdsSupportValuesEnumValueResponse' imds_support: <p>If <code>v2.0</code>, it indicates that IMDSv2 is specified in the AMI. Instances launched from this AMI will have <code>HttpTokens</code> automatically set to <code>required</code> so that, by default, the instance requires that IMDSv2 is used when requesting instance metadata. In addition, <code>HttpPutResponseHopLimit</code> is set to <code>2</code>. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-IMDS-new-instances.html#configure-IMDS-new-instances-ami-configuration'>Configure the AMI</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param str kernel_id: <p>The kernel associated with the image, if any. Only applicable for machine images.</p>
        :param str last_launched_time: <p>The date and time, in <a href='http://www.iso.org/iso/iso8601'>ISO 8601 date-time format</a>, when the AMI was last used to launch an EC2 instance. When the AMI is used to launch an instance, there is a 24-hour delay before that usage is reported.</p> <note> <p> <code>lastLaunchedTime</code> data is available starting April 2017.</p> </note>
        :param str name: <p>The name of the AMI that was provided during image creation.</p>
        :param str owner_id: <p>The ID of the Amazon Web Services account that owns the image.</p>
        :param 'PlatformValuesEnumValueResponse' platform: <p>This value is set to <code>windows</code> for Windows AMIs; otherwise, it is blank.</p>
        :param str platform_details: <p>The platform details associated with the billing code of the AMI. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-billing-info.html'>Understand AMI billing information</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param Sequence['ProductCodeResponse'] product_codes: <p>Any product codes associated with the AMI.</p>
        :param bool public: <p>Indicates whether the image has public launch permissions. The value is <code>true</code> if this image has public launch permissions or <code>false</code> if it has only implicit and explicit launch permissions.</p>
        :param str ramdisk_id: <p>The RAM disk associated with the image, if any. Only applicable for machine images.</p>
        :param str root_device_name: <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
        :param 'DeviceTypeEnumValueResponse' root_device_type: <p>The type of root device used by the AMI. The AMI can use an Amazon EBS volume or an instance store volume.</p>
        :param str source_instance_id: <p>The ID of the instance that the AMI was created from if the AMI was created using <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateImage.html'>CreateImage</a>. This field only appears if the AMI was created using CreateImage.</p>
        :param str sriov_net_support: <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
        :param 'ImageStateEnumValueResponse' state: <p>The current state of the AMI. If the state is <code>available</code>, the image is successfully registered and can be used to launch an instance.</p>
        :param 'StateReasonResponse' state_reason: <p>The reason for the state change.</p>
        :param Sequence['TagResponse'] tags: <p>Any tags assigned to the image.</p>
        :param 'TpmSupportValuesEnumValueResponse' tpm_support: <p>If the image is configured for NitroTPM support, the value is <code>v2.0</code>. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nitrotpm.html'>NitroTPM</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param str usage_operation: <p>The operation of the Amazon EC2 instance and the billing code that is associated with the AMI. <code>usageOperation</code> corresponds to the <a href='https://docs.aws.amazon.com/cur/latest/userguide/Lineitem-columns.html#Lineitem-details-O-Operation'>lineitem/Operation</a> column on your Amazon Web Services Cost and Usage Report and in the <a href='https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/price-changes.html'>Amazon Web Services Price List API</a>. You can view these fields on the <b>Instances</b> or <b>AMIs</b> pages in the Amazon EC2 console, or in the responses that are returned by the <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImages.html'>DescribeImages</a> command in the Amazon EC2 API, or the <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-images.html'>describe-images</a> command in the CLI.</p>
        :param 'VirtualizationTypeEnumValueResponse' virtualization_type: <p>The type of virtualization of the AMI.</p>
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if boot_mode is not None:
            pulumi.set(__self__, "boot_mode", boot_mode)
        if creation_date is not None:
            pulumi.set(__self__, "creation_date", creation_date)
        if deprecation_time is not None:
            pulumi.set(__self__, "deprecation_time", deprecation_time)
        if deregistration_protection is not None:
            pulumi.set(__self__, "deregistration_protection", deregistration_protection)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ena_support is not None:
            pulumi.set(__self__, "ena_support", ena_support)
        if hypervisor is not None:
            pulumi.set(__self__, "hypervisor", hypervisor)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if image_location is not None:
            pulumi.set(__self__, "image_location", image_location)
        if image_owner_alias is not None:
            pulumi.set(__self__, "image_owner_alias", image_owner_alias)
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)
        if imds_support is not None:
            pulumi.set(__self__, "imds_support", imds_support)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if last_launched_time is not None:
            pulumi.set(__self__, "last_launched_time", last_launched_time)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if platform_details is not None:
            pulumi.set(__self__, "platform_details", platform_details)
        if product_codes is not None:
            pulumi.set(__self__, "product_codes", product_codes)
        if public is not None:
            pulumi.set(__self__, "public", public)
        if ramdisk_id is not None:
            pulumi.set(__self__, "ramdisk_id", ramdisk_id)
        if root_device_name is not None:
            pulumi.set(__self__, "root_device_name", root_device_name)
        if root_device_type is not None:
            pulumi.set(__self__, "root_device_type", root_device_type)
        if source_instance_id is not None:
            pulumi.set(__self__, "source_instance_id", source_instance_id)
        if sriov_net_support is not None:
            pulumi.set(__self__, "sriov_net_support", sriov_net_support)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_reason is not None:
            pulumi.set(__self__, "state_reason", state_reason)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tpm_support is not None:
            pulumi.set(__self__, "tpm_support", tpm_support)
        if usage_operation is not None:
            pulumi.set(__self__, "usage_operation", usage_operation)
        if virtualization_type is not None:
            pulumi.set(__self__, "virtualization_type", virtualization_type)

    @property
    @pulumi.getter
    def architecture(self) -> Optional['outputs.ArchitectureValuesEnumValueResponse']:
        """
        <p>The architecture of the image.</p>
        """
        return pulumi.get(self, "architecture")

    @property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[Sequence['outputs.BlockDeviceMappingResponse']]:
        """
        <p>Any block device mapping entries.</p>
        """
        return pulumi.get(self, "block_device_mappings")

    @property
    @pulumi.getter(name="bootMode")
    def boot_mode(self) -> Optional['outputs.BootModeValuesEnumValueResponse']:
        """
        <p>The boot mode of the image. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html'>Boot modes</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "boot_mode")

    @property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[str]:
        """
        <p>The date and time the image was created.</p>
        """
        return pulumi.get(self, "creation_date")

    @property
    @pulumi.getter(name="deprecationTime")
    def deprecation_time(self) -> Optional[str]:
        """
        <p>The date and time to deprecate the AMI, in UTC, in the following format: <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z. If you specified a value for seconds, Amazon EC2 rounds the seconds to the nearest minute.</p>
        """
        return pulumi.get(self, "deprecation_time")

    @property
    @pulumi.getter(name="deregistrationProtection")
    def deregistration_protection(self) -> Optional[str]:
        """
        <p>Indicates whether deregistration protection is enabled for the AMI.</p>
        """
        return pulumi.get(self, "deregistration_protection")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>The description of the AMI that was provided during image creation.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enaSupport")
    def ena_support(self) -> Optional[bool]:
        """
        <p>Specifies whether enhanced networking with ENA is enabled.</p>
        """
        return pulumi.get(self, "ena_support")

    @property
    @pulumi.getter
    def hypervisor(self) -> Optional['outputs.HypervisorTypeEnumValueResponse']:
        """
        <p>The hypervisor type of the image. Only <code>xen</code> is supported. <code>ovm</code> is not supported.</p>
        """
        return pulumi.get(self, "hypervisor")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[str]:
        """
        <p>The ID of the AMI.</p>
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="imageLocation")
    def image_location(self) -> Optional[str]:
        """
        <p>The location of the AMI.</p>
        """
        return pulumi.get(self, "image_location")

    @property
    @pulumi.getter(name="imageOwnerAlias")
    def image_owner_alias(self) -> Optional[str]:
        """
        <p>The owner alias (<code>amazon</code> | <code>aws-marketplace</code>).</p>
        """
        return pulumi.get(self, "image_owner_alias")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional['outputs.ImageTypeValuesEnumValueResponse']:
        """
        <p>The type of image.</p>
        """
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="imdsSupport")
    def imds_support(self) -> Optional['outputs.ImdsSupportValuesEnumValueResponse']:
        """
        <p>If <code>v2.0</code>, it indicates that IMDSv2 is specified in the AMI. Instances launched from this AMI will have <code>HttpTokens</code> automatically set to <code>required</code> so that, by default, the instance requires that IMDSv2 is used when requesting instance metadata. In addition, <code>HttpPutResponseHopLimit</code> is set to <code>2</code>. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-IMDS-new-instances.html#configure-IMDS-new-instances-ami-configuration'>Configure the AMI</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "imds_support")

    @property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[str]:
        """
        <p>The kernel associated with the image, if any. Only applicable for machine images.</p>
        """
        return pulumi.get(self, "kernel_id")

    @property
    @pulumi.getter(name="lastLaunchedTime")
    def last_launched_time(self) -> Optional[str]:
        """
        <p>The date and time, in <a href='http://www.iso.org/iso/iso8601'>ISO 8601 date-time format</a>, when the AMI was last used to launch an EC2 instance. When the AMI is used to launch an instance, there is a 24-hour delay before that usage is reported.</p> <note> <p> <code>lastLaunchedTime</code> data is available starting April 2017.</p> </note>
        """
        return pulumi.get(self, "last_launched_time")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the AMI that was provided during image creation.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[str]:
        """
        <p>The ID of the Amazon Web Services account that owns the image.</p>
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter
    def platform(self) -> Optional['outputs.PlatformValuesEnumValueResponse']:
        """
        <p>This value is set to <code>windows</code> for Windows AMIs; otherwise, it is blank.</p>
        """
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter(name="platformDetails")
    def platform_details(self) -> Optional[str]:
        """
        <p>The platform details associated with the billing code of the AMI. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-billing-info.html'>Understand AMI billing information</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "platform_details")

    @property
    @pulumi.getter(name="productCodes")
    def product_codes(self) -> Optional[Sequence['outputs.ProductCodeResponse']]:
        """
        <p>Any product codes associated with the AMI.</p>
        """
        return pulumi.get(self, "product_codes")

    @property
    @pulumi.getter
    def public(self) -> Optional[bool]:
        """
        <p>Indicates whether the image has public launch permissions. The value is <code>true</code> if this image has public launch permissions or <code>false</code> if it has only implicit and explicit launch permissions.</p>
        """
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="ramdiskId")
    def ramdisk_id(self) -> Optional[str]:
        """
        <p>The RAM disk associated with the image, if any. Only applicable for machine images.</p>
        """
        return pulumi.get(self, "ramdisk_id")

    @property
    @pulumi.getter(name="rootDeviceName")
    def root_device_name(self) -> Optional[str]:
        """
        <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
        """
        return pulumi.get(self, "root_device_name")

    @property
    @pulumi.getter(name="rootDeviceType")
    def root_device_type(self) -> Optional['outputs.DeviceTypeEnumValueResponse']:
        """
        <p>The type of root device used by the AMI. The AMI can use an Amazon EBS volume or an instance store volume.</p>
        """
        return pulumi.get(self, "root_device_type")

    @property
    @pulumi.getter(name="sourceInstanceId")
    def source_instance_id(self) -> Optional[str]:
        """
        <p>The ID of the instance that the AMI was created from if the AMI was created using <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateImage.html'>CreateImage</a>. This field only appears if the AMI was created using CreateImage.</p>
        """
        return pulumi.get(self, "source_instance_id")

    @property
    @pulumi.getter(name="sriovNetSupport")
    def sriov_net_support(self) -> Optional[str]:
        """
        <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
        """
        return pulumi.get(self, "sriov_net_support")

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.ImageStateEnumValueResponse']:
        """
        <p>The current state of the AMI. If the state is <code>available</code>, the image is successfully registered and can be used to launch an instance.</p>
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> Optional['outputs.StateReasonResponse']:
        """
        <p>The reason for the state change.</p>
        """
        return pulumi.get(self, "state_reason")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        <p>Any tags assigned to the image.</p>
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tpmSupport")
    def tpm_support(self) -> Optional['outputs.TpmSupportValuesEnumValueResponse']:
        """
        <p>If the image is configured for NitroTPM support, the value is <code>v2.0</code>. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nitrotpm.html'>NitroTPM</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "tpm_support")

    @property
    @pulumi.getter(name="usageOperation")
    def usage_operation(self) -> Optional[str]:
        """
        <p>The operation of the Amazon EC2 instance and the billing code that is associated with the AMI. <code>usageOperation</code> corresponds to the <a href='https://docs.aws.amazon.com/cur/latest/userguide/Lineitem-columns.html#Lineitem-details-O-Operation'>lineitem/Operation</a> column on your Amazon Web Services Cost and Usage Report and in the <a href='https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/price-changes.html'>Amazon Web Services Price List API</a>. You can view these fields on the <b>Instances</b> or <b>AMIs</b> pages in the Amazon EC2 console, or in the responses that are returned by the <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImages.html'>DescribeImages</a> command in the Amazon EC2 API, or the <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-images.html'>describe-images</a> command in the CLI.</p>
        """
        return pulumi.get(self, "usage_operation")

    @property
    @pulumi.getter(name="virtualizationType")
    def virtualization_type(self) -> Optional['outputs.VirtualizationTypeEnumValueResponse']:
        """
        <p>The type of virtualization of the AMI.</p>
        """
        return pulumi.get(self, "virtualization_type")


@pulumi.output_type
class AwsEc2InstancePropertiesResponse(dict):
    """
    Definition of awsEc2Instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amiLaunchIndex":
            suggest = "ami_launch_index"
        elif key == "blockDeviceMappings":
            suggest = "block_device_mappings"
        elif key == "bootMode":
            suggest = "boot_mode"
        elif key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationSpecification":
            suggest = "capacity_reservation_specification"
        elif key == "clientToken":
            suggest = "client_token"
        elif key == "cpuOptions":
            suggest = "cpu_options"
        elif key == "currentInstanceBootMode":
            suggest = "current_instance_boot_mode"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "elasticGpuAssociations":
            suggest = "elastic_gpu_associations"
        elif key == "elasticInferenceAcceleratorAssociations":
            suggest = "elastic_inference_accelerator_associations"
        elif key == "enaSupport":
            suggest = "ena_support"
        elif key == "enclaveOptions":
            suggest = "enclave_options"
        elif key == "hibernationOptions":
            suggest = "hibernation_options"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "instanceLifecycle":
            suggest = "instance_lifecycle"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "kernelId":
            suggest = "kernel_id"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "launchTime":
            suggest = "launch_time"
        elif key == "maintenanceOptions":
            suggest = "maintenance_options"
        elif key == "metadataOptions":
            suggest = "metadata_options"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "platformDetails":
            suggest = "platform_details"
        elif key == "privateDnsName":
            suggest = "private_dns_name"
        elif key == "privateDnsNameOptions":
            suggest = "private_dns_name_options"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "productCodes":
            suggest = "product_codes"
        elif key == "publicDnsName":
            suggest = "public_dns_name"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"
        elif key == "ramdiskId":
            suggest = "ramdisk_id"
        elif key == "rootDeviceName":
            suggest = "root_device_name"
        elif key == "rootDeviceType":
            suggest = "root_device_type"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "sourceDestCheck":
            suggest = "source_dest_check"
        elif key == "spotInstanceRequestId":
            suggest = "spot_instance_request_id"
        elif key == "sriovNetSupport":
            suggest = "sriov_net_support"
        elif key == "stateReason":
            suggest = "state_reason"
        elif key == "stateTransitionReason":
            suggest = "state_transition_reason"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tpmSupport":
            suggest = "tpm_support"
        elif key == "usageOperation":
            suggest = "usage_operation"
        elif key == "usageOperationUpdateTime":
            suggest = "usage_operation_update_time"
        elif key == "virtualizationType":
            suggest = "virtualization_type"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2InstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2InstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2InstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ami_launch_index: Optional[int] = None,
                 architecture: Optional['outputs.ArchitectureValuesEnumValueResponse'] = None,
                 block_device_mappings: Optional[Sequence['outputs.InstanceBlockDeviceMappingResponse']] = None,
                 boot_mode: Optional['outputs.BootModeValuesEnumValueResponse'] = None,
                 capacity_reservation_id: Optional[str] = None,
                 capacity_reservation_specification: Optional['outputs.CapacityReservationSpecificationResponseResponse'] = None,
                 client_token: Optional[str] = None,
                 cpu_options: Optional['outputs.CpuOptionsResponse'] = None,
                 current_instance_boot_mode: Optional['outputs.InstanceBootModeValuesEnumValueResponse'] = None,
                 ebs_optimized: Optional[bool] = None,
                 elastic_gpu_associations: Optional[Sequence['outputs.ElasticGpuAssociationResponse']] = None,
                 elastic_inference_accelerator_associations: Optional[Sequence['outputs.ElasticInferenceAcceleratorAssociationResponse']] = None,
                 ena_support: Optional[bool] = None,
                 enclave_options: Optional['outputs.EnclaveOptionsResponse'] = None,
                 hibernation_options: Optional['outputs.HibernationOptionsResponse'] = None,
                 hypervisor: Optional['outputs.HypervisorTypeEnumValueResponse'] = None,
                 iam_instance_profile: Optional['outputs.IamInstanceProfileResponse'] = None,
                 image_id: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 instance_lifecycle: Optional['outputs.InstanceLifecycleTypeEnumValueResponse'] = None,
                 instance_type: Optional['outputs.InstanceTypeEnumValueResponse'] = None,
                 ipv6_address: Optional[str] = None,
                 kernel_id: Optional[str] = None,
                 key_name: Optional[str] = None,
                 launch_time: Optional[str] = None,
                 licenses: Optional[Sequence['outputs.LicenseConfigurationResponse']] = None,
                 maintenance_options: Optional['outputs.InstanceMaintenanceOptionsResponse'] = None,
                 metadata_options: Optional['outputs.InstanceMetadataOptionsResponseResponse'] = None,
                 monitoring: Optional['outputs.MonitoringResponse'] = None,
                 network_interfaces: Optional[Sequence['outputs.InstanceNetworkInterfaceResponse']] = None,
                 outpost_arn: Optional[str] = None,
                 placement: Optional['outputs.PlacementResponse'] = None,
                 platform: Optional['outputs.PlatformValuesEnumValueResponse'] = None,
                 platform_details: Optional[str] = None,
                 private_dns_name: Optional[str] = None,
                 private_dns_name_options: Optional['outputs.PrivateDnsNameOptionsResponseResponse'] = None,
                 private_ip_address: Optional[str] = None,
                 product_codes: Optional[Sequence['outputs.ProductCodeResponse']] = None,
                 public_dns_name: Optional[str] = None,
                 public_ip_address: Optional[str] = None,
                 ramdisk_id: Optional[str] = None,
                 root_device_name: Optional[str] = None,
                 root_device_type: Optional['outputs.DeviceTypeEnumValueResponse'] = None,
                 security_groups: Optional[Sequence['outputs.GroupIdentifierResponse']] = None,
                 source_dest_check: Optional[bool] = None,
                 spot_instance_request_id: Optional[str] = None,
                 sriov_net_support: Optional[str] = None,
                 state: Optional['outputs.InstanceStateResponse'] = None,
                 state_reason: Optional['outputs.StateReasonResponse'] = None,
                 state_transition_reason: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 tpm_support: Optional[str] = None,
                 usage_operation: Optional[str] = None,
                 usage_operation_update_time: Optional[str] = None,
                 virtualization_type: Optional['outputs.VirtualizationTypeEnumValueResponse'] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsEc2Instance
        :param int ami_launch_index: <p>The AMI launch index, which can be used to find this instance in the launch group.</p>
        :param 'ArchitectureValuesEnumValueResponse' architecture: <p>The architecture of the image.</p>
        :param Sequence['InstanceBlockDeviceMappingResponse'] block_device_mappings: <p>Any block device mapping entries for the instance.</p>
        :param 'BootModeValuesEnumValueResponse' boot_mode: <p>The boot mode that was specified by the AMI. If the value is <code>uefi-preferred</code>, the AMI supports both UEFI and Legacy BIOS. The <code>currentInstanceBootMode</code> parameter is the boot mode that is used to boot the instance at launch or start.</p> <note> <p>The operating system contained in the AMI must be configured to support the specified boot mode.</p> </note> <p>For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html'>Boot modes</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param str capacity_reservation_id: <p>The ID of the Capacity Reservation.</p>
        :param 'CapacityReservationSpecificationResponseResponse' capacity_reservation_specification: <p>Information about the Capacity Reservation targeting option.</p>
        :param str client_token: <p>The idempotency token you provided when you launched the instance, if applicable.</p>
        :param 'CpuOptionsResponse' cpu_options: <p>The CPU options for the instance.</p>
        :param 'InstanceBootModeValuesEnumValueResponse' current_instance_boot_mode: <p>The boot mode that is used to boot the instance at launch or start. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html'>Boot modes</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param bool ebs_optimized: <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
        :param Sequence['ElasticGpuAssociationResponse'] elastic_gpu_associations: <p>Deprecated.</p> <note> <p>Amazon Elastic Graphics reached end of life on January 8, 2024. For workloads that require graphics acceleration, we recommend that you use Amazon EC2 G4ad, G4dn, or G5 instances.</p> </note>
        :param Sequence['ElasticInferenceAcceleratorAssociationResponse'] elastic_inference_accelerator_associations: <p>The elastic inference accelerator associated with the instance.</p>
        :param bool ena_support: <p>Specifies whether enhanced networking with ENA is enabled.</p>
        :param 'EnclaveOptionsResponse' enclave_options: <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.</p>
        :param 'HibernationOptionsResponse' hibernation_options: <p>Indicates whether the instance is enabled for hibernation.</p>
        :param 'HypervisorTypeEnumValueResponse' hypervisor: <p>The hypervisor type of the instance. The value <code>xen</code> is used for both Xen and Nitro hypervisors.</p>
        :param 'IamInstanceProfileResponse' iam_instance_profile: <p>The IAM instance profile associated with the instance, if applicable.</p>
        :param str image_id: <p>The ID of the AMI used to launch the instance.</p>
        :param str instance_id: <p>The ID of the instance.</p>
        :param 'InstanceLifecycleTypeEnumValueResponse' instance_lifecycle: <p>Indicates whether this is a Spot Instance or a Scheduled Instance.</p>
        :param 'InstanceTypeEnumValueResponse' instance_type: <p>The instance type.</p>
        :param str ipv6_address: <p>The IPv6 address assigned to the instance.</p>
        :param str kernel_id: <p>The kernel associated with this instance, if applicable.</p>
        :param str key_name: <p>The name of the key pair, if this instance was launched with an associated key pair.</p>
        :param str launch_time: <p>The time the instance was launched.</p>
        :param Sequence['LicenseConfigurationResponse'] licenses: <p>The license configurations for the instance.</p>
        :param 'InstanceMaintenanceOptionsResponse' maintenance_options: <p>Provides information on the recovery and maintenance options of your instance.</p>
        :param 'InstanceMetadataOptionsResponseResponse' metadata_options: <p>The metadata options for the instance.</p>
        :param 'MonitoringResponse' monitoring: <p>The monitoring for the instance.</p>
        :param Sequence['InstanceNetworkInterfaceResponse'] network_interfaces: <p>The network interfaces for the instance.</p>
        :param str outpost_arn: <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        :param 'PlacementResponse' placement: <p>The location where the instance launched, if applicable.</p>
        :param 'PlatformValuesEnumValueResponse' platform: <p>The platform. This value is <code>windows</code> for Windows instances; otherwise, it is empty.</p>
        :param str platform_details: <p>The platform details value for the instance. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/billing-info-fields.html'>AMI billing information fields</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param str private_dns_name: <p>[IPv4 only] The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the <code>running</code> state. </p> <p>The Amazon-provided DNS server resolves Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.</p>
        :param 'PrivateDnsNameOptionsResponseResponse' private_dns_name_options: <p>The options for the instance hostname.</p>
        :param str private_ip_address: <p>The private IPv4 address assigned to the instance.</p>
        :param Sequence['ProductCodeResponse'] product_codes: <p>The product codes attached to this instance, if applicable.</p>
        :param str public_dns_name: <p>[IPv4 only] The public DNS name assigned to the instance. This name is not available until the instance enters the <code>running</code> state. This name is only available if you've enabled DNS hostnames for your VPC.</p>
        :param str public_ip_address: <p>The public IPv4 address, or the Carrier IP address assigned to the instance, if applicable.</p> <p>A Carrier IP address only applies to an instance launched in a subnet associated with a Wavelength Zone.</p>
        :param str ramdisk_id: <p>The RAM disk associated with this instance, if applicable.</p>
        :param str root_device_name: <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
        :param 'DeviceTypeEnumValueResponse' root_device_type: <p>The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
        :param Sequence['GroupIdentifierResponse'] security_groups: <p>The security groups for the instance.</p>
        :param bool source_dest_check: <p>Indicates whether source/destination checking is enabled.</p>
        :param str spot_instance_request_id: <p>If the request is a Spot Instance request, the ID of the request.</p>
        :param str sriov_net_support: <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
        :param 'InstanceStateResponse' state: <p>The current state of the instance.</p>
        :param 'StateReasonResponse' state_reason: <p>The reason for the most recent state transition.</p>
        :param str state_transition_reason: <p>The reason for the most recent state transition. This might be an empty string.</p>
        :param str subnet_id: <p>The ID of the subnet in which the instance is running.</p>
        :param Sequence['TagResponse'] tags: <p>Any tags assigned to the instance.</p>
        :param str tpm_support: <p>If the instance is configured for NitroTPM support, the value is <code>v2.0</code>. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nitrotpm.html'>NitroTPM</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param str usage_operation: <p>The usage operation value for the instance. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/billing-info-fields.html'>AMI billing information fields</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param str usage_operation_update_time: <p>The time that the usage operation was last updated.</p>
        :param 'VirtualizationTypeEnumValueResponse' virtualization_type: <p>The virtualization type of the instance.</p>
        :param str vpc_id: <p>The ID of the VPC in which the instance is running.</p>
        """
        if ami_launch_index is not None:
            pulumi.set(__self__, "ami_launch_index", ami_launch_index)
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if boot_mode is not None:
            pulumi.set(__self__, "boot_mode", boot_mode)
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_specification is not None:
            pulumi.set(__self__, "capacity_reservation_specification", capacity_reservation_specification)
        if client_token is not None:
            pulumi.set(__self__, "client_token", client_token)
        if cpu_options is not None:
            pulumi.set(__self__, "cpu_options", cpu_options)
        if current_instance_boot_mode is not None:
            pulumi.set(__self__, "current_instance_boot_mode", current_instance_boot_mode)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if elastic_gpu_associations is not None:
            pulumi.set(__self__, "elastic_gpu_associations", elastic_gpu_associations)
        if elastic_inference_accelerator_associations is not None:
            pulumi.set(__self__, "elastic_inference_accelerator_associations", elastic_inference_accelerator_associations)
        if ena_support is not None:
            pulumi.set(__self__, "ena_support", ena_support)
        if enclave_options is not None:
            pulumi.set(__self__, "enclave_options", enclave_options)
        if hibernation_options is not None:
            pulumi.set(__self__, "hibernation_options", hibernation_options)
        if hypervisor is not None:
            pulumi.set(__self__, "hypervisor", hypervisor)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_lifecycle is not None:
            pulumi.set(__self__, "instance_lifecycle", instance_lifecycle)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if launch_time is not None:
            pulumi.set(__self__, "launch_time", launch_time)
        if licenses is not None:
            pulumi.set(__self__, "licenses", licenses)
        if maintenance_options is not None:
            pulumi.set(__self__, "maintenance_options", maintenance_options)
        if metadata_options is not None:
            pulumi.set(__self__, "metadata_options", metadata_options)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if platform_details is not None:
            pulumi.set(__self__, "platform_details", platform_details)
        if private_dns_name is not None:
            pulumi.set(__self__, "private_dns_name", private_dns_name)
        if private_dns_name_options is not None:
            pulumi.set(__self__, "private_dns_name_options", private_dns_name_options)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if product_codes is not None:
            pulumi.set(__self__, "product_codes", product_codes)
        if public_dns_name is not None:
            pulumi.set(__self__, "public_dns_name", public_dns_name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)
        if ramdisk_id is not None:
            pulumi.set(__self__, "ramdisk_id", ramdisk_id)
        if root_device_name is not None:
            pulumi.set(__self__, "root_device_name", root_device_name)
        if root_device_type is not None:
            pulumi.set(__self__, "root_device_type", root_device_type)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)
        if spot_instance_request_id is not None:
            pulumi.set(__self__, "spot_instance_request_id", spot_instance_request_id)
        if sriov_net_support is not None:
            pulumi.set(__self__, "sriov_net_support", sriov_net_support)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_reason is not None:
            pulumi.set(__self__, "state_reason", state_reason)
        if state_transition_reason is not None:
            pulumi.set(__self__, "state_transition_reason", state_transition_reason)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tpm_support is not None:
            pulumi.set(__self__, "tpm_support", tpm_support)
        if usage_operation is not None:
            pulumi.set(__self__, "usage_operation", usage_operation)
        if usage_operation_update_time is not None:
            pulumi.set(__self__, "usage_operation_update_time", usage_operation_update_time)
        if virtualization_type is not None:
            pulumi.set(__self__, "virtualization_type", virtualization_type)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="amiLaunchIndex")
    def ami_launch_index(self) -> Optional[int]:
        """
        <p>The AMI launch index, which can be used to find this instance in the launch group.</p>
        """
        return pulumi.get(self, "ami_launch_index")

    @property
    @pulumi.getter
    def architecture(self) -> Optional['outputs.ArchitectureValuesEnumValueResponse']:
        """
        <p>The architecture of the image.</p>
        """
        return pulumi.get(self, "architecture")

    @property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[Sequence['outputs.InstanceBlockDeviceMappingResponse']]:
        """
        <p>Any block device mapping entries for the instance.</p>
        """
        return pulumi.get(self, "block_device_mappings")

    @property
    @pulumi.getter(name="bootMode")
    def boot_mode(self) -> Optional['outputs.BootModeValuesEnumValueResponse']:
        """
        <p>The boot mode that was specified by the AMI. If the value is <code>uefi-preferred</code>, the AMI supports both UEFI and Legacy BIOS. The <code>currentInstanceBootMode</code> parameter is the boot mode that is used to boot the instance at launch or start.</p> <note> <p>The operating system contained in the AMI must be configured to support the specified boot mode.</p> </note> <p>For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html'>Boot modes</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "boot_mode")

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[str]:
        """
        <p>The ID of the Capacity Reservation.</p>
        """
        return pulumi.get(self, "capacity_reservation_id")

    @property
    @pulumi.getter(name="capacityReservationSpecification")
    def capacity_reservation_specification(self) -> Optional['outputs.CapacityReservationSpecificationResponseResponse']:
        """
        <p>Information about the Capacity Reservation targeting option.</p>
        """
        return pulumi.get(self, "capacity_reservation_specification")

    @property
    @pulumi.getter(name="clientToken")
    def client_token(self) -> Optional[str]:
        """
        <p>The idempotency token you provided when you launched the instance, if applicable.</p>
        """
        return pulumi.get(self, "client_token")

    @property
    @pulumi.getter(name="cpuOptions")
    def cpu_options(self) -> Optional['outputs.CpuOptionsResponse']:
        """
        <p>The CPU options for the instance.</p>
        """
        return pulumi.get(self, "cpu_options")

    @property
    @pulumi.getter(name="currentInstanceBootMode")
    def current_instance_boot_mode(self) -> Optional['outputs.InstanceBootModeValuesEnumValueResponse']:
        """
        <p>The boot mode that is used to boot the instance at launch or start. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ami-boot.html'>Boot modes</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "current_instance_boot_mode")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        """
        <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
        """
        return pulumi.get(self, "ebs_optimized")

    @property
    @pulumi.getter(name="elasticGpuAssociations")
    def elastic_gpu_associations(self) -> Optional[Sequence['outputs.ElasticGpuAssociationResponse']]:
        """
        <p>Deprecated.</p> <note> <p>Amazon Elastic Graphics reached end of life on January 8, 2024. For workloads that require graphics acceleration, we recommend that you use Amazon EC2 G4ad, G4dn, or G5 instances.</p> </note>
        """
        return pulumi.get(self, "elastic_gpu_associations")

    @property
    @pulumi.getter(name="elasticInferenceAcceleratorAssociations")
    def elastic_inference_accelerator_associations(self) -> Optional[Sequence['outputs.ElasticInferenceAcceleratorAssociationResponse']]:
        """
        <p>The elastic inference accelerator associated with the instance.</p>
        """
        return pulumi.get(self, "elastic_inference_accelerator_associations")

    @property
    @pulumi.getter(name="enaSupport")
    def ena_support(self) -> Optional[bool]:
        """
        <p>Specifies whether enhanced networking with ENA is enabled.</p>
        """
        return pulumi.get(self, "ena_support")

    @property
    @pulumi.getter(name="enclaveOptions")
    def enclave_options(self) -> Optional['outputs.EnclaveOptionsResponse']:
        """
        <p>Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.</p>
        """
        return pulumi.get(self, "enclave_options")

    @property
    @pulumi.getter(name="hibernationOptions")
    def hibernation_options(self) -> Optional['outputs.HibernationOptionsResponse']:
        """
        <p>Indicates whether the instance is enabled for hibernation.</p>
        """
        return pulumi.get(self, "hibernation_options")

    @property
    @pulumi.getter
    def hypervisor(self) -> Optional['outputs.HypervisorTypeEnumValueResponse']:
        """
        <p>The hypervisor type of the instance. The value <code>xen</code> is used for both Xen and Nitro hypervisors.</p>
        """
        return pulumi.get(self, "hypervisor")

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional['outputs.IamInstanceProfileResponse']:
        """
        <p>The IAM instance profile associated with the instance, if applicable.</p>
        """
        return pulumi.get(self, "iam_instance_profile")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[str]:
        """
        <p>The ID of the AMI used to launch the instance.</p>
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        <p>The ID of the instance.</p>
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceLifecycle")
    def instance_lifecycle(self) -> Optional['outputs.InstanceLifecycleTypeEnumValueResponse']:
        """
        <p>Indicates whether this is a Spot Instance or a Scheduled Instance.</p>
        """
        return pulumi.get(self, "instance_lifecycle")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional['outputs.InstanceTypeEnumValueResponse']:
        """
        <p>The instance type.</p>
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        """
        <p>The IPv6 address assigned to the instance.</p>
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[str]:
        """
        <p>The kernel associated with this instance, if applicable.</p>
        """
        return pulumi.get(self, "kernel_id")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        """
        <p>The name of the key pair, if this instance was launched with an associated key pair.</p>
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> Optional[str]:
        """
        <p>The time the instance was launched.</p>
        """
        return pulumi.get(self, "launch_time")

    @property
    @pulumi.getter
    def licenses(self) -> Optional[Sequence['outputs.LicenseConfigurationResponse']]:
        """
        <p>The license configurations for the instance.</p>
        """
        return pulumi.get(self, "licenses")

    @property
    @pulumi.getter(name="maintenanceOptions")
    def maintenance_options(self) -> Optional['outputs.InstanceMaintenanceOptionsResponse']:
        """
        <p>Provides information on the recovery and maintenance options of your instance.</p>
        """
        return pulumi.get(self, "maintenance_options")

    @property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> Optional['outputs.InstanceMetadataOptionsResponseResponse']:
        """
        <p>The metadata options for the instance.</p>
        """
        return pulumi.get(self, "metadata_options")

    @property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.MonitoringResponse']:
        """
        <p>The monitoring for the instance.</p>
        """
        return pulumi.get(self, "monitoring")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.InstanceNetworkInterfaceResponse']]:
        """
        <p>The network interfaces for the instance.</p>
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.PlacementResponse']:
        """
        <p>The location where the instance launched, if applicable.</p>
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter
    def platform(self) -> Optional['outputs.PlatformValuesEnumValueResponse']:
        """
        <p>The platform. This value is <code>windows</code> for Windows instances; otherwise, it is empty.</p>
        """
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter(name="platformDetails")
    def platform_details(self) -> Optional[str]:
        """
        <p>The platform details value for the instance. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/billing-info-fields.html'>AMI billing information fields</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "platform_details")

    @property
    @pulumi.getter(name="privateDnsName")
    def private_dns_name(self) -> Optional[str]:
        """
        <p>[IPv4 only] The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the <code>running</code> state. </p> <p>The Amazon-provided DNS server resolves Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.</p>
        """
        return pulumi.get(self, "private_dns_name")

    @property
    @pulumi.getter(name="privateDnsNameOptions")
    def private_dns_name_options(self) -> Optional['outputs.PrivateDnsNameOptionsResponseResponse']:
        """
        <p>The options for the instance hostname.</p>
        """
        return pulumi.get(self, "private_dns_name_options")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        <p>The private IPv4 address assigned to the instance.</p>
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="productCodes")
    def product_codes(self) -> Optional[Sequence['outputs.ProductCodeResponse']]:
        """
        <p>The product codes attached to this instance, if applicable.</p>
        """
        return pulumi.get(self, "product_codes")

    @property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> Optional[str]:
        """
        <p>[IPv4 only] The public DNS name assigned to the instance. This name is not available until the instance enters the <code>running</code> state. This name is only available if you've enabled DNS hostnames for your VPC.</p>
        """
        return pulumi.get(self, "public_dns_name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[str]:
        """
        <p>The public IPv4 address, or the Carrier IP address assigned to the instance, if applicable.</p> <p>A Carrier IP address only applies to an instance launched in a subnet associated with a Wavelength Zone.</p>
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="ramdiskId")
    def ramdisk_id(self) -> Optional[str]:
        """
        <p>The RAM disk associated with this instance, if applicable.</p>
        """
        return pulumi.get(self, "ramdisk_id")

    @property
    @pulumi.getter(name="rootDeviceName")
    def root_device_name(self) -> Optional[str]:
        """
        <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
        """
        return pulumi.get(self, "root_device_name")

    @property
    @pulumi.getter(name="rootDeviceType")
    def root_device_type(self) -> Optional['outputs.DeviceTypeEnumValueResponse']:
        """
        <p>The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
        """
        return pulumi.get(self, "root_device_type")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.GroupIdentifierResponse']]:
        """
        <p>The security groups for the instance.</p>
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[bool]:
        """
        <p>Indicates whether source/destination checking is enabled.</p>
        """
        return pulumi.get(self, "source_dest_check")

    @property
    @pulumi.getter(name="spotInstanceRequestId")
    def spot_instance_request_id(self) -> Optional[str]:
        """
        <p>If the request is a Spot Instance request, the ID of the request.</p>
        """
        return pulumi.get(self, "spot_instance_request_id")

    @property
    @pulumi.getter(name="sriovNetSupport")
    def sriov_net_support(self) -> Optional[str]:
        """
        <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
        """
        return pulumi.get(self, "sriov_net_support")

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.InstanceStateResponse']:
        """
        <p>The current state of the instance.</p>
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> Optional['outputs.StateReasonResponse']:
        """
        <p>The reason for the most recent state transition.</p>
        """
        return pulumi.get(self, "state_reason")

    @property
    @pulumi.getter(name="stateTransitionReason")
    def state_transition_reason(self) -> Optional[str]:
        """
        <p>The reason for the most recent state transition. This might be an empty string.</p>
        """
        return pulumi.get(self, "state_transition_reason")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        <p>The ID of the subnet in which the instance is running.</p>
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        <p>Any tags assigned to the instance.</p>
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tpmSupport")
    def tpm_support(self) -> Optional[str]:
        """
        <p>If the instance is configured for NitroTPM support, the value is <code>v2.0</code>. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nitrotpm.html'>NitroTPM</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "tpm_support")

    @property
    @pulumi.getter(name="usageOperation")
    def usage_operation(self) -> Optional[str]:
        """
        <p>The usage operation value for the instance. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/billing-info-fields.html'>AMI billing information fields</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "usage_operation")

    @property
    @pulumi.getter(name="usageOperationUpdateTime")
    def usage_operation_update_time(self) -> Optional[str]:
        """
        <p>The time that the usage operation was last updated.</p>
        """
        return pulumi.get(self, "usage_operation_update_time")

    @property
    @pulumi.getter(name="virtualizationType")
    def virtualization_type(self) -> Optional['outputs.VirtualizationTypeEnumValueResponse']:
        """
        <p>The virtualization type of the instance.</p>
        """
        return pulumi.get(self, "virtualization_type")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        <p>The ID of the VPC in which the instance is running.</p>
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsEc2InstanceStatusPropertiesResponse(dict):
    """
    Definition of awsEc2InstanceStatus
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "instanceState":
            suggest = "instance_state"
        elif key == "instanceStatus":
            suggest = "instance_status"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "systemStatus":
            suggest = "system_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2InstanceStatusPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2InstanceStatusPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2InstanceStatusPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 events: Optional[Sequence['outputs.InstanceStatusEventResponse']] = None,
                 instance_id: Optional[str] = None,
                 instance_state: Optional['outputs.InstanceStateResponse'] = None,
                 instance_status: Optional['outputs.InstanceStatusSummaryResponse'] = None,
                 outpost_arn: Optional[str] = None,
                 system_status: Optional['outputs.InstanceStatusSummaryResponse'] = None):
        """
        Definition of awsEc2InstanceStatus
        :param str availability_zone: <p>The Availability Zone of the instance.</p>
        :param Sequence['InstanceStatusEventResponse'] events: <p>Any scheduled events associated with the instance.</p>
        :param str instance_id: <p>The ID of the instance.</p>
        :param 'InstanceStateResponse' instance_state: <p>The intended state of the instance. <a>DescribeInstanceStatus</a> requires that an instance be in the <code>running</code> state.</p>
        :param 'InstanceStatusSummaryResponse' instance_status: <p>Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.</p>
        :param str outpost_arn: <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        :param 'InstanceStatusSummaryResponse' system_status: <p>Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.</p>
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_state is not None:
            pulumi.set(__self__, "instance_state", instance_state)
        if instance_status is not None:
            pulumi.set(__self__, "instance_status", instance_status)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if system_status is not None:
            pulumi.set(__self__, "system_status", system_status)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        <p>The Availability Zone of the instance.</p>
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.InstanceStatusEventResponse']]:
        """
        <p>Any scheduled events associated with the instance.</p>
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        <p>The ID of the instance.</p>
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="instanceState")
    def instance_state(self) -> Optional['outputs.InstanceStateResponse']:
        """
        <p>The intended state of the instance. <a>DescribeInstanceStatus</a> requires that an instance be in the <code>running</code> state.</p>
        """
        return pulumi.get(self, "instance_state")

    @property
    @pulumi.getter(name="instanceStatus")
    def instance_status(self) -> Optional['outputs.InstanceStatusSummaryResponse']:
        """
        <p>Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.</p>
        """
        return pulumi.get(self, "instance_status")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the Outpost.</p>
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter(name="systemStatus")
    def system_status(self) -> Optional['outputs.InstanceStatusSummaryResponse']:
        """
        <p>Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.</p>
        """
        return pulumi.get(self, "system_status")


@pulumi.output_type
class AwsEc2IpamPropertiesResponse(dict):
    """
    Definition of awsEc2Ipam
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultResourceDiscoveryAssociationId":
            suggest = "default_resource_discovery_association_id"
        elif key == "defaultResourceDiscoveryId":
            suggest = "default_resource_discovery_id"
        elif key == "ipamArn":
            suggest = "ipam_arn"
        elif key == "ipamId":
            suggest = "ipam_id"
        elif key == "ipamRegion":
            suggest = "ipam_region"
        elif key == "operatingRegions":
            suggest = "operating_regions"
        elif key == "ownerId":
            suggest = "owner_id"
        elif key == "privateDefaultScopeId":
            suggest = "private_default_scope_id"
        elif key == "publicDefaultScopeId":
            suggest = "public_default_scope_id"
        elif key == "resourceDiscoveryAssociationCount":
            suggest = "resource_discovery_association_count"
        elif key == "scopeCount":
            suggest = "scope_count"
        elif key == "stateMessage":
            suggest = "state_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2IpamPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2IpamPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2IpamPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_resource_discovery_association_id: Optional[str] = None,
                 default_resource_discovery_id: Optional[str] = None,
                 description: Optional[str] = None,
                 ipam_arn: Optional[str] = None,
                 ipam_id: Optional[str] = None,
                 ipam_region: Optional[str] = None,
                 operating_regions: Optional[Sequence['outputs.IpamOperatingRegionResponse']] = None,
                 owner_id: Optional[str] = None,
                 private_default_scope_id: Optional[str] = None,
                 public_default_scope_id: Optional[str] = None,
                 resource_discovery_association_count: Optional[int] = None,
                 scope_count: Optional[int] = None,
                 state: Optional['outputs.IpamStateEnumValueResponse'] = None,
                 state_message: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 tier: Optional['outputs.IpamTierEnumValueResponse'] = None):
        """
        Definition of awsEc2Ipam
        :param str default_resource_discovery_association_id: <p>The IPAM's default resource discovery association ID.</p>
        :param str default_resource_discovery_id: <p>The IPAM's default resource discovery ID.</p>
        :param str description: <p>The description for the IPAM.</p>
        :param str ipam_arn: <p>The Amazon Resource Name (ARN) of the IPAM.</p>
        :param str ipam_id: <p>The ID of the IPAM.</p>
        :param str ipam_region: <p>The Amazon Web Services Region of the IPAM.</p>
        :param Sequence['IpamOperatingRegionResponse'] operating_regions: <p>The operating Regions for an IPAM. Operating Regions are Amazon Web Services Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the Amazon Web Services Regions you select as operating Regions.</p> <p>For more information about operating Regions, see <a href='https://docs.aws.amazon.com/vpc/latest/ipam/create-ipam.html'>Create an IPAM</a> in the <i>Amazon VPC IPAM User Guide</i>.</p>
        :param str owner_id: <p>The Amazon Web Services account ID of the owner of the IPAM.</p>
        :param str private_default_scope_id: <p>The ID of the IPAM's default private scope.</p>
        :param str public_default_scope_id: <p>The ID of the IPAM's default public scope.</p>
        :param int resource_discovery_association_count: <p>The IPAM's resource discovery association count.</p>
        :param int scope_count: <p>The number of scopes in the IPAM. The scope quota is 5. For more information on quotas, see <a href='https://docs.aws.amazon.com/vpc/latest/ipam/quotas-ipam.html'>Quotas in IPAM</a> in the <i>Amazon VPC IPAM User Guide</i>. </p>
        :param 'IpamStateEnumValueResponse' state: <p>The state of the IPAM.</p>
        :param str state_message: <p>The state message.</p>
        :param Sequence['TagResponse'] tags: <p>The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        :param 'IpamTierEnumValueResponse' tier: <p>IPAM is offered in a Free Tier and an Advanced Tier. For more information about the features available in each tier and the costs associated with the tiers, see <a href='http://aws.amazon.com/vpc/pricing/'>Amazon VPC pricing &gt; IPAM tab</a>.</p>
        """
        if default_resource_discovery_association_id is not None:
            pulumi.set(__self__, "default_resource_discovery_association_id", default_resource_discovery_association_id)
        if default_resource_discovery_id is not None:
            pulumi.set(__self__, "default_resource_discovery_id", default_resource_discovery_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipam_arn is not None:
            pulumi.set(__self__, "ipam_arn", ipam_arn)
        if ipam_id is not None:
            pulumi.set(__self__, "ipam_id", ipam_id)
        if ipam_region is not None:
            pulumi.set(__self__, "ipam_region", ipam_region)
        if operating_regions is not None:
            pulumi.set(__self__, "operating_regions", operating_regions)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if private_default_scope_id is not None:
            pulumi.set(__self__, "private_default_scope_id", private_default_scope_id)
        if public_default_scope_id is not None:
            pulumi.set(__self__, "public_default_scope_id", public_default_scope_id)
        if resource_discovery_association_count is not None:
            pulumi.set(__self__, "resource_discovery_association_count", resource_discovery_association_count)
        if scope_count is not None:
            pulumi.set(__self__, "scope_count", scope_count)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_message is not None:
            pulumi.set(__self__, "state_message", state_message)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter(name="defaultResourceDiscoveryAssociationId")
    def default_resource_discovery_association_id(self) -> Optional[str]:
        """
        <p>The IPAM's default resource discovery association ID.</p>
        """
        return pulumi.get(self, "default_resource_discovery_association_id")

    @property
    @pulumi.getter(name="defaultResourceDiscoveryId")
    def default_resource_discovery_id(self) -> Optional[str]:
        """
        <p>The IPAM's default resource discovery ID.</p>
        """
        return pulumi.get(self, "default_resource_discovery_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>The description for the IPAM.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipamArn")
    def ipam_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the IPAM.</p>
        """
        return pulumi.get(self, "ipam_arn")

    @property
    @pulumi.getter(name="ipamId")
    def ipam_id(self) -> Optional[str]:
        """
        <p>The ID of the IPAM.</p>
        """
        return pulumi.get(self, "ipam_id")

    @property
    @pulumi.getter(name="ipamRegion")
    def ipam_region(self) -> Optional[str]:
        """
        <p>The Amazon Web Services Region of the IPAM.</p>
        """
        return pulumi.get(self, "ipam_region")

    @property
    @pulumi.getter(name="operatingRegions")
    def operating_regions(self) -> Optional[Sequence['outputs.IpamOperatingRegionResponse']]:
        """
        <p>The operating Regions for an IPAM. Operating Regions are Amazon Web Services Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the Amazon Web Services Regions you select as operating Regions.</p> <p>For more information about operating Regions, see <a href='https://docs.aws.amazon.com/vpc/latest/ipam/create-ipam.html'>Create an IPAM</a> in the <i>Amazon VPC IPAM User Guide</i>.</p>
        """
        return pulumi.get(self, "operating_regions")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[str]:
        """
        <p>The Amazon Web Services account ID of the owner of the IPAM.</p>
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter(name="privateDefaultScopeId")
    def private_default_scope_id(self) -> Optional[str]:
        """
        <p>The ID of the IPAM's default private scope.</p>
        """
        return pulumi.get(self, "private_default_scope_id")

    @property
    @pulumi.getter(name="publicDefaultScopeId")
    def public_default_scope_id(self) -> Optional[str]:
        """
        <p>The ID of the IPAM's default public scope.</p>
        """
        return pulumi.get(self, "public_default_scope_id")

    @property
    @pulumi.getter(name="resourceDiscoveryAssociationCount")
    def resource_discovery_association_count(self) -> Optional[int]:
        """
        <p>The IPAM's resource discovery association count.</p>
        """
        return pulumi.get(self, "resource_discovery_association_count")

    @property
    @pulumi.getter(name="scopeCount")
    def scope_count(self) -> Optional[int]:
        """
        <p>The number of scopes in the IPAM. The scope quota is 5. For more information on quotas, see <a href='https://docs.aws.amazon.com/vpc/latest/ipam/quotas-ipam.html'>Quotas in IPAM</a> in the <i>Amazon VPC IPAM User Guide</i>. </p>
        """
        return pulumi.get(self, "scope_count")

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.IpamStateEnumValueResponse']:
        """
        <p>The state of the IPAM.</p>
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> Optional[str]:
        """
        <p>The state message.</p>
        """
        return pulumi.get(self, "state_message")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        <p>The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p>
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def tier(self) -> Optional['outputs.IpamTierEnumValueResponse']:
        """
        <p>IPAM is offered in a Free Tier and an Advanced Tier. For more information about the features available in each tier and the costs associated with the tiers, see <a href='http://aws.amazon.com/vpc/pricing/'>Amazon VPC pricing &gt; IPAM tab</a>.</p>
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class AwsEc2KeyPairPropertiesResponse(dict):
    """
    Definition of awsEc2KeyPair
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyFingerprint":
            suggest = "key_fingerprint"
        elif key == "keyFormat":
            suggest = "key_format"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "keyPairId":
            suggest = "key_pair_id"
        elif key == "keyType":
            suggest = "key_type"
        elif key == "publicKeyMaterial":
            suggest = "public_key_material"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2KeyPairPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2KeyPairPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2KeyPairPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_fingerprint: Optional[str] = None,
                 key_format: Optional[str] = None,
                 key_name: Optional[str] = None,
                 key_pair_id: Optional[str] = None,
                 key_type: Optional[str] = None,
                 public_key_material: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsEc2KeyPair
        :param str key_fingerprint: Property keyFingerprint
        :param str key_format: The format of the key pair. Default: ``pem``
        :param str key_name: A unique name for the key pair. Constraints: Up to 255 ASCII characters
        :param str key_pair_id: Property keyPairId
        :param str key_type: The type of key pair. Note that ED25519 keys are not supported for Windows instances. If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value. Default: ``rsa``
        :param str public_key_material: The public key material. The ``PublicKeyMaterial`` property is used to import a key pair. If this property is not specified, then a new key pair will be created.
        :param Sequence['TagResponse'] tags: The tags to apply to the key pair.
        """
        if key_fingerprint is not None:
            pulumi.set(__self__, "key_fingerprint", key_fingerprint)
        if key_format is None:
            key_format = 'pem'
        if key_format is not None:
            pulumi.set(__self__, "key_format", key_format)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_pair_id is not None:
            pulumi.set(__self__, "key_pair_id", key_pair_id)
        if key_type is None:
            key_type = 'rsa'
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if public_key_material is not None:
            pulumi.set(__self__, "public_key_material", public_key_material)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="keyFingerprint")
    def key_fingerprint(self) -> Optional[str]:
        """
        Property keyFingerprint
        """
        return pulumi.get(self, "key_fingerprint")

    @property
    @pulumi.getter(name="keyFormat")
    def key_format(self) -> Optional[str]:
        """
        The format of the key pair. Default: ``pem``
        """
        return pulumi.get(self, "key_format")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        """
        A unique name for the key pair. Constraints: Up to 255 ASCII characters
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyPairId")
    def key_pair_id(self) -> Optional[str]:
        """
        Property keyPairId
        """
        return pulumi.get(self, "key_pair_id")

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[str]:
        """
        The type of key pair. Note that ED25519 keys are not supported for Windows instances. If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value. Default: ``rsa``
        """
        return pulumi.get(self, "key_type")

    @property
    @pulumi.getter(name="publicKeyMaterial")
    def public_key_material(self) -> Optional[str]:
        """
        The public key material. The ``PublicKeyMaterial`` property is used to import a key pair. If this property is not specified, then a new key pair will be created.
        """
        return pulumi.get(self, "public_key_material")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The tags to apply to the key pair.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsEc2NetworkAclPropertiesResponse(dict):
    """
    Definition of awsEc2NetworkAcl
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2NetworkAclPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2NetworkAclPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2NetworkAclPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsEc2NetworkAcl
        :param str id: Property id
        :param Sequence['TagResponse'] tags: The tags for the network ACL.
        :param str vpc_id: The ID of the VPC for the network ACL.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The tags for the network ACL.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        The ID of the VPC for the network ACL.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsEc2NetworkInterfacePropertiesResponse(dict):
    """
    Definition of awsEc2NetworkInterface
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionTrackingSpecification":
            suggest = "connection_tracking_specification"
        elif key == "enablePrimaryIpv6":
            suggest = "enable_primary_ipv6"
        elif key == "groupSet":
            suggest = "group_set"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "ipv4PrefixCount":
            suggest = "ipv4_prefix_count"
        elif key == "ipv4Prefixes":
            suggest = "ipv4_prefixes"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "ipv6PrefixCount":
            suggest = "ipv6_prefix_count"
        elif key == "ipv6Prefixes":
            suggest = "ipv6_prefixes"
        elif key == "primaryIpv6Address":
            suggest = "primary_ipv6_address"
        elif key == "primaryPrivateIpAddress":
            suggest = "primary_private_ip_address"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "secondaryPrivateIpAddresses":
            suggest = "secondary_private_ip_addresses"
        elif key == "sourceDestCheck":
            suggest = "source_dest_check"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2NetworkInterfacePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2NetworkInterfacePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2NetworkInterfacePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_tracking_specification: Optional['outputs.ConnectionTrackingSpecificationResponse'] = None,
                 description: Optional[str] = None,
                 enable_primary_ipv6: Optional[bool] = None,
                 group_set: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 interface_type: Optional[str] = None,
                 ipv4_prefix_count: Optional[int] = None,
                 ipv4_prefixes: Optional[Sequence['outputs.Ipv4PrefixSpecificationResponse']] = None,
                 ipv6_address_count: Optional[int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.InstanceIpv6AddressResponse']] = None,
                 ipv6_prefix_count: Optional[int] = None,
                 ipv6_prefixes: Optional[Sequence['outputs.Ipv6PrefixSpecificationResponse']] = None,
                 primary_ipv6_address: Optional[str] = None,
                 primary_private_ip_address: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.PrivateIpAddressSpecificationResponse']] = None,
                 secondary_private_ip_address_count: Optional[int] = None,
                 secondary_private_ip_addresses: Optional[Sequence[str]] = None,
                 source_dest_check: Optional[bool] = None,
                 subnet_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsEc2NetworkInterface
        :param 'ConnectionTrackingSpecificationResponse' connection_tracking_specification: Property connectionTrackingSpecification
        :param str description: A description for the network interface.
        :param bool enable_primary_ipv6: If you have instances or ENIs that rely on the IPv6 address not changing, to avoid disrupting traffic to instances or ENIs, you can enable a primary IPv6 address. Enable this option to automatically assign an IPv6 associated with the ENI attached to your instance to be the primary IPv6 address. When you enable an IPv6 address to be a primary IPv6, you cannot disable it. Traffic will be routed to the primary IPv6 address until the instance is terminated or the ENI is detached. If you have multiple IPv6 addresses associated with an ENI and you enable a primary IPv6 address, the first IPv6 address associated with the ENI becomes the primary IPv6 address.
        :param Sequence[str] group_set: A list of security group IDs associated with this network interface.
        :param str id: Network interface id.
        :param str interface_type: Indicates the type of network interface.
        :param int ipv4_prefix_count: The number of IPv4 prefixes to assign to a network interface. When you specify a number of IPv4 prefixes, Amazon EC2 selects these prefixes from your existing subnet CIDR reservations, if available, or from free spaces in the subnet. By default, these will be /28 prefixes. You can't specify a count of IPv4 prefixes if you've specified one of the following: specific IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.
        :param Sequence['Ipv4PrefixSpecificationResponse'] ipv4_prefixes: Assigns a list of IPv4 prefixes to the network interface. If you want EC2 to automatically assign IPv4 prefixes, use the Ipv4PrefixCount property and do not specify this property. Presently, only /28 prefixes are supported. You can't specify IPv4 prefixes if you've specified one of the following: a count of IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.
        :param int ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the Ipv6Addresses property and don't specify this property.
        :param Sequence['InstanceIpv6AddressResponse'] ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface. If you're specifying a number of IPv6 addresses, use the Ipv6AddressCount property and don't specify this property.
        :param int ipv6_prefix_count: The number of IPv6 prefixes to assign to a network interface. When you specify a number of IPv6 prefixes, Amazon EC2 selects these prefixes from your existing subnet CIDR reservations, if available, or from free spaces in the subnet. By default, these will be /80 prefixes. You can't specify a count of IPv6 prefixes if you've specified one of the following: specific IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.
        :param Sequence['Ipv6PrefixSpecificationResponse'] ipv6_prefixes: Assigns a list of IPv6 prefixes to the network interface. If you want EC2 to automatically assign IPv6 prefixes, use the Ipv6PrefixCount property and do not specify this property. Presently, only /80 prefixes are supported. You can't specify IPv6 prefixes if you've specified one of the following: a count of IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.
        :param str primary_ipv6_address: The primary IPv6 address
        :param str primary_private_ip_address: Returns the primary private IP address of the network interface.
        :param str private_ip_address: Assigns a single private IP address to the network interface, which is used as the primary private IP address. If you want to specify multiple private IP address, use the PrivateIpAddresses property.
        :param Sequence['PrivateIpAddressSpecificationResponse'] private_ip_addresses: Assigns a list of private IP addresses to the network interface. You can specify a primary private IP address by setting the value of the Primary property to true in the PrivateIpAddressSpecification property. If you want EC2 to automatically assign private IP addresses, use the SecondaryPrivateIpAddressCount property and do not specify this property.
        :param int secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using privateIpAddresses
        :param Sequence[str] secondary_private_ip_addresses: Returns the secondary private IP addresses of the network interface.
        :param bool source_dest_check: Indicates whether traffic to or from the instance is validated.
        :param str subnet_id: The ID of the subnet to associate with the network interface.
        :param Sequence['TagResponse'] tags: An arbitrary set of tags (key-value pairs) for this network interface.
        :param str vpc_id: The ID of the VPC
        """
        if connection_tracking_specification is not None:
            pulumi.set(__self__, "connection_tracking_specification", connection_tracking_specification)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_primary_ipv6 is not None:
            pulumi.set(__self__, "enable_primary_ipv6", enable_primary_ipv6)
        if group_set is not None:
            pulumi.set(__self__, "group_set", group_set)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if ipv4_prefix_count is not None:
            pulumi.set(__self__, "ipv4_prefix_count", ipv4_prefix_count)
        if ipv4_prefixes is not None:
            pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if ipv6_prefix_count is not None:
            pulumi.set(__self__, "ipv6_prefix_count", ipv6_prefix_count)
        if ipv6_prefixes is not None:
            pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        if primary_ipv6_address is not None:
            pulumi.set(__self__, "primary_ipv6_address", primary_ipv6_address)
        if primary_private_ip_address is not None:
            pulumi.set(__self__, "primary_private_ip_address", primary_private_ip_address)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if secondary_private_ip_addresses is not None:
            pulumi.set(__self__, "secondary_private_ip_addresses", secondary_private_ip_addresses)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="connectionTrackingSpecification")
    def connection_tracking_specification(self) -> Optional['outputs.ConnectionTrackingSpecificationResponse']:
        """
        Property connectionTrackingSpecification
        """
        return pulumi.get(self, "connection_tracking_specification")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for the network interface.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enablePrimaryIpv6")
    def enable_primary_ipv6(self) -> Optional[bool]:
        """
        If you have instances or ENIs that rely on the IPv6 address not changing, to avoid disrupting traffic to instances or ENIs, you can enable a primary IPv6 address. Enable this option to automatically assign an IPv6 associated with the ENI attached to your instance to be the primary IPv6 address. When you enable an IPv6 address to be a primary IPv6, you cannot disable it. Traffic will be routed to the primary IPv6 address until the instance is terminated or the ENI is detached. If you have multiple IPv6 addresses associated with an ENI and you enable a primary IPv6 address, the first IPv6 address associated with the ENI becomes the primary IPv6 address.
        """
        return pulumi.get(self, "enable_primary_ipv6")

    @property
    @pulumi.getter(name="groupSet")
    def group_set(self) -> Optional[Sequence[str]]:
        """
        A list of security group IDs associated with this network interface.
        """
        return pulumi.get(self, "group_set")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Network interface id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[str]:
        """
        Indicates the type of network interface.
        """
        return pulumi.get(self, "interface_type")

    @property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> Optional[int]:
        """
        The number of IPv4 prefixes to assign to a network interface. When you specify a number of IPv4 prefixes, Amazon EC2 selects these prefixes from your existing subnet CIDR reservations, if available, or from free spaces in the subnet. By default, these will be /28 prefixes. You can't specify a count of IPv4 prefixes if you've specified one of the following: specific IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.
        """
        return pulumi.get(self, "ipv4_prefix_count")

    @property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Optional[Sequence['outputs.Ipv4PrefixSpecificationResponse']]:
        """
        Assigns a list of IPv4 prefixes to the network interface. If you want EC2 to automatically assign IPv4 prefixes, use the Ipv4PrefixCount property and do not specify this property. Presently, only /28 prefixes are supported. You can't specify IPv4 prefixes if you've specified one of the following: a count of IPv4 prefixes, specific private IPv4 addresses, or a count of private IPv4 addresses.
        """
        return pulumi.get(self, "ipv4_prefixes")

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[int]:
        """
        The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the Ipv6Addresses property and don't specify this property.
        """
        return pulumi.get(self, "ipv6_address_count")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.InstanceIpv6AddressResponse']]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface. If you're specifying a number of IPv6 addresses, use the Ipv6AddressCount property and don't specify this property.
        """
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> Optional[int]:
        """
        The number of IPv6 prefixes to assign to a network interface. When you specify a number of IPv6 prefixes, Amazon EC2 selects these prefixes from your existing subnet CIDR reservations, if available, or from free spaces in the subnet. By default, these will be /80 prefixes. You can't specify a count of IPv6 prefixes if you've specified one of the following: specific IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_prefix_count")

    @property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Optional[Sequence['outputs.Ipv6PrefixSpecificationResponse']]:
        """
        Assigns a list of IPv6 prefixes to the network interface. If you want EC2 to automatically assign IPv6 prefixes, use the Ipv6PrefixCount property and do not specify this property. Presently, only /80 prefixes are supported. You can't specify IPv6 prefixes if you've specified one of the following: a count of IPv6 prefixes, specific IPv6 addresses, or a count of IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_prefixes")

    @property
    @pulumi.getter(name="primaryIpv6Address")
    def primary_ipv6_address(self) -> Optional[str]:
        """
        The primary IPv6 address
        """
        return pulumi.get(self, "primary_ipv6_address")

    @property
    @pulumi.getter(name="primaryPrivateIpAddress")
    def primary_private_ip_address(self) -> Optional[str]:
        """
        Returns the primary private IP address of the network interface.
        """
        return pulumi.get(self, "primary_private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        Assigns a single private IP address to the network interface, which is used as the primary private IP address. If you want to specify multiple private IP address, use the PrivateIpAddresses property.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.PrivateIpAddressSpecificationResponse']]:
        """
        Assigns a list of private IP addresses to the network interface. You can specify a primary private IP address by setting the value of the Primary property to true in the PrivateIpAddressSpecification property. If you want EC2 to automatically assign private IP addresses, use the SecondaryPrivateIpAddressCount property and do not specify this property.
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[int]:
        """
        The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using privateIpAddresses
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @property
    @pulumi.getter(name="secondaryPrivateIpAddresses")
    def secondary_private_ip_addresses(self) -> Optional[Sequence[str]]:
        """
        Returns the secondary private IP addresses of the network interface.
        """
        return pulumi.get(self, "secondary_private_ip_addresses")

    @property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[bool]:
        """
        Indicates whether traffic to or from the instance is validated.
        """
        return pulumi.get(self, "source_dest_check")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet to associate with the network interface.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An arbitrary set of tags (key-value pairs) for this network interface.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        The ID of the VPC
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsEc2RouteTablePropertiesResponse(dict):
    """
    Definition of awsEc2RouteTable
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTableId":
            suggest = "route_table_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2RouteTablePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2RouteTablePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2RouteTablePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 route_table_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsEc2RouteTable
        :param str route_table_id: Property routeTableId
        :param Sequence['TagResponse'] tags: Any tags assigned to the route table.
        :param str vpc_id: The ID of the VPC.
        """
        if route_table_id is not None:
            pulumi.set(__self__, "route_table_id", route_table_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[str]:
        """
        Property routeTableId
        """
        return pulumi.get(self, "route_table_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Any tags assigned to the route table.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsEc2SecurityGroupPropertiesResponse(dict):
    """
    Definition of awsEc2SecurityGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "ipPermissions":
            suggest = "ip_permissions"
        elif key == "ipPermissionsEgress":
            suggest = "ip_permissions_egress"
        elif key == "ownerId":
            suggest = "owner_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2SecurityGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2SecurityGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2SecurityGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 group_id: Optional[str] = None,
                 group_name: Optional[str] = None,
                 ip_permissions: Optional[Sequence['outputs.IpPermissionResponse']] = None,
                 ip_permissions_egress: Optional[Sequence['outputs.IpPermissionResponse']] = None,
                 owner_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsEc2SecurityGroup
        :param str description: <p>A description of the security group.</p>
        :param str group_id: <p>The ID of the security group.</p>
        :param str group_name: <p>The name of the security group.</p>
        :param Sequence['IpPermissionResponse'] ip_permissions: <p>The inbound rules associated with the security group.</p>
        :param Sequence['IpPermissionResponse'] ip_permissions_egress: <p>The outbound rules associated with the security group.</p>
        :param str owner_id: <p>The Amazon Web Services account ID of the owner of the security group.</p>
        :param Sequence['TagResponse'] tags: <p>Any tags assigned to the security group.</p>
        :param str vpc_id: <p>The ID of the VPC for the security group.</p>
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if ip_permissions is not None:
            pulumi.set(__self__, "ip_permissions", ip_permissions)
        if ip_permissions_egress is not None:
            pulumi.set(__self__, "ip_permissions_egress", ip_permissions_egress)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description of the security group.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        <p>The ID of the security group.</p>
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        <p>The name of the security group.</p>
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="ipPermissions")
    def ip_permissions(self) -> Optional[Sequence['outputs.IpPermissionResponse']]:
        """
        <p>The inbound rules associated with the security group.</p>
        """
        return pulumi.get(self, "ip_permissions")

    @property
    @pulumi.getter(name="ipPermissionsEgress")
    def ip_permissions_egress(self) -> Optional[Sequence['outputs.IpPermissionResponse']]:
        """
        <p>The outbound rules associated with the security group.</p>
        """
        return pulumi.get(self, "ip_permissions_egress")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[str]:
        """
        <p>The Amazon Web Services account ID of the owner of the security group.</p>
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        <p>Any tags assigned to the security group.</p>
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        <p>The ID of the VPC for the security group.</p>
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsEc2SnapshotPropertiesResponse(dict):
    """
    Definition of awsEc2Snapshot
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataEncryptionKeyId":
            suggest = "data_encryption_key_id"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "ownerAlias":
            suggest = "owner_alias"
        elif key == "ownerId":
            suggest = "owner_id"
        elif key == "restoreExpiryTime":
            suggest = "restore_expiry_time"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "sseType":
            suggest = "sse_type"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "stateMessage":
            suggest = "state_message"
        elif key == "storageTier":
            suggest = "storage_tier"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeSize":
            suggest = "volume_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2SnapshotPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2SnapshotPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2SnapshotPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_encryption_key_id: Optional[str] = None,
                 description: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 kms_key_id: Optional[str] = None,
                 outpost_arn: Optional[str] = None,
                 owner_alias: Optional[str] = None,
                 owner_id: Optional[str] = None,
                 progress: Optional[str] = None,
                 restore_expiry_time: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 sse_type: Optional['outputs.SSETypeEnumValueResponse'] = None,
                 start_time: Optional[str] = None,
                 state: Optional['outputs.SnapshotStateEnumValueResponse'] = None,
                 state_message: Optional[str] = None,
                 storage_tier: Optional['outputs.StorageTierEnumValueResponse'] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 volume_id: Optional[str] = None,
                 volume_size: Optional[int] = None):
        """
        Definition of awsEc2Snapshot
        :param str data_encryption_key_id: <p>The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by <a>DescribeSnapshots</a>.</p>
        :param str description: <p>The description for the snapshot.</p>
        :param bool encrypted: <p>Indicates whether the snapshot is encrypted.</p>
        :param str kms_key_id: <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS) KMS key that was used to protect the volume encryption key for the parent volume.</p>
        :param str outpost_arn: <p>The ARN of the Outpost on which the snapshot is stored. For more information, see <a href='https://docs.aws.amazon.com/ebs/latest/userguide/snapshots-outposts.html'>Amazon EBS local snapshots on Outposts</a> in the <i>Amazon EBS User Guide</i>.</p>
        :param str owner_alias: <p>The Amazon Web Services owner alias, from an Amazon-maintained list (<code>amazon</code>). This is not the user-configured Amazon Web Services account alias set using the IAM console.</p>
        :param str owner_id: <p>The ID of the Amazon Web Services account that owns the EBS snapshot.</p>
        :param str progress: <p>The progress of the snapshot, as a percentage.</p>
        :param str restore_expiry_time: <p>Only for archived snapshots that are temporarily restored. Indicates the date and time when a temporarily restored snapshot will be automatically re-archived.</p>
        :param str snapshot_id: <p>The ID of the snapshot. Each snapshot receives a unique identifier when it is created.</p>
        :param 'SSETypeEnumValueResponse' sse_type: <p>Reserved for future use.</p>
        :param str start_time: <p>The time stamp when the snapshot was initiated.</p>
        :param 'SnapshotStateEnumValueResponse' state: <p>The snapshot state.</p>
        :param str state_message: <p>Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper Key Management Service (KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by <a>DescribeSnapshots</a>.</p>
        :param 'StorageTierEnumValueResponse' storage_tier: <p>The storage tier in which the snapshot is stored. <code>standard</code> indicates that the snapshot is stored in the standard snapshot storage tier and that it is ready for use. <code>archive</code> indicates that the snapshot is currently archived and that it must be restored before it can be used.</p>
        :param Sequence['TagResponse'] tags: <p>Any tags assigned to the snapshot.</p>
        :param str volume_id: <p>The ID of the volume that was used to create the snapshot. Snapshots created by the <a>CopySnapshot</a> action have an arbitrary volume ID that should not be used for any purpose.</p>
        :param int volume_size: <p>The size of the volume, in GiB.</p>
        """
        if data_encryption_key_id is not None:
            pulumi.set(__self__, "data_encryption_key_id", data_encryption_key_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if owner_alias is not None:
            pulumi.set(__self__, "owner_alias", owner_alias)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if restore_expiry_time is not None:
            pulumi.set(__self__, "restore_expiry_time", restore_expiry_time)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if sse_type is not None:
            pulumi.set(__self__, "sse_type", sse_type)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_message is not None:
            pulumi.set(__self__, "state_message", state_message)
        if storage_tier is not None:
            pulumi.set(__self__, "storage_tier", storage_tier)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)

    @property
    @pulumi.getter(name="dataEncryptionKeyId")
    def data_encryption_key_id(self) -> Optional[str]:
        """
        <p>The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by <a>DescribeSnapshots</a>.</p>
        """
        return pulumi.get(self, "data_encryption_key_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>The description for the snapshot.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        <p>Indicates whether the snapshot is encrypted.</p>
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the Key Management Service (KMS) KMS key that was used to protect the volume encryption key for the parent volume.</p>
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        <p>The ARN of the Outpost on which the snapshot is stored. For more information, see <a href='https://docs.aws.amazon.com/ebs/latest/userguide/snapshots-outposts.html'>Amazon EBS local snapshots on Outposts</a> in the <i>Amazon EBS User Guide</i>.</p>
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter(name="ownerAlias")
    def owner_alias(self) -> Optional[str]:
        """
        <p>The Amazon Web Services owner alias, from an Amazon-maintained list (<code>amazon</code>). This is not the user-configured Amazon Web Services account alias set using the IAM console.</p>
        """
        return pulumi.get(self, "owner_alias")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[str]:
        """
        <p>The ID of the Amazon Web Services account that owns the EBS snapshot.</p>
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter
    def progress(self) -> Optional[str]:
        """
        <p>The progress of the snapshot, as a percentage.</p>
        """
        return pulumi.get(self, "progress")

    @property
    @pulumi.getter(name="restoreExpiryTime")
    def restore_expiry_time(self) -> Optional[str]:
        """
        <p>Only for archived snapshots that are temporarily restored. Indicates the date and time when a temporarily restored snapshot will be automatically re-archived.</p>
        """
        return pulumi.get(self, "restore_expiry_time")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        <p>The ID of the snapshot. Each snapshot receives a unique identifier when it is created.</p>
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="sseType")
    def sse_type(self) -> Optional['outputs.SSETypeEnumValueResponse']:
        """
        <p>Reserved for future use.</p>
        """
        return pulumi.get(self, "sse_type")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        <p>The time stamp when the snapshot was initiated.</p>
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.SnapshotStateEnumValueResponse']:
        """
        <p>The snapshot state.</p>
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> Optional[str]:
        """
        <p>Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper Key Management Service (KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by <a>DescribeSnapshots</a>.</p>
        """
        return pulumi.get(self, "state_message")

    @property
    @pulumi.getter(name="storageTier")
    def storage_tier(self) -> Optional['outputs.StorageTierEnumValueResponse']:
        """
        <p>The storage tier in which the snapshot is stored. <code>standard</code> indicates that the snapshot is stored in the standard snapshot storage tier and that it is ready for use. <code>archive</code> indicates that the snapshot is currently archived and that it must be restored before it can be used.</p>
        """
        return pulumi.get(self, "storage_tier")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        <p>Any tags assigned to the snapshot.</p>
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        <p>The ID of the volume that was used to create the snapshot. Snapshots created by the <a>CopySnapshot</a> action have an arbitrary volume ID that should not be used for any purpose.</p>
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        <p>The size of the volume, in GiB.</p>
        """
        return pulumi.get(self, "volume_size")


@pulumi.output_type
class AwsEc2SubnetPropertiesResponse(dict):
    """
    Definition of awsEc2Subnet
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignIpv6AddressOnCreation":
            suggest = "assign_ipv6_address_on_creation"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "availabilityZoneId":
            suggest = "availability_zone_id"
        elif key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "enableDns64":
            suggest = "enable_dns64"
        elif key == "enableLniAtDeviceIndex":
            suggest = "enable_lni_at_device_index"
        elif key == "ipv4IpamPoolId":
            suggest = "ipv4_ipam_pool_id"
        elif key == "ipv4NetmaskLength":
            suggest = "ipv4_netmask_length"
        elif key == "ipv6CidrBlock":
            suggest = "ipv6_cidr_block"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "ipv6IpamPoolId":
            suggest = "ipv6_ipam_pool_id"
        elif key == "ipv6Native":
            suggest = "ipv6_native"
        elif key == "ipv6NetmaskLength":
            suggest = "ipv6_netmask_length"
        elif key == "mapPublicIpOnLaunch":
            suggest = "map_public_ip_on_launch"
        elif key == "networkAclAssociationId":
            suggest = "network_acl_association_id"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "privateDnsNameOptionsOnLaunch":
            suggest = "private_dns_name_options_on_launch"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2SubnetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2SubnetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2SubnetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_ipv6_address_on_creation: Optional[bool] = None,
                 availability_zone: Optional[str] = None,
                 availability_zone_id: Optional[str] = None,
                 cidr_block: Optional[str] = None,
                 enable_dns64: Optional[bool] = None,
                 enable_lni_at_device_index: Optional[int] = None,
                 ipv4_ipam_pool_id: Optional[str] = None,
                 ipv4_netmask_length: Optional[int] = None,
                 ipv6_cidr_block: Optional[str] = None,
                 ipv6_cidr_blocks: Optional[Sequence[str]] = None,
                 ipv6_ipam_pool_id: Optional[str] = None,
                 ipv6_native: Optional[bool] = None,
                 ipv6_netmask_length: Optional[int] = None,
                 map_public_ip_on_launch: Optional[bool] = None,
                 network_acl_association_id: Optional[str] = None,
                 outpost_arn: Optional[str] = None,
                 private_dns_name_options_on_launch: Optional['outputs.PrivateDnsNameOptionsOnLaunchModelPropertiesResponse'] = None,
                 subnet_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsEc2Subnet
        :param bool assign_ipv6_address_on_creation: Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false``. If you specify ``AssignIpv6AddressOnCreation``, you must also specify an IPv6 CIDR block.
        :param str availability_zone: The Availability Zone of the subnet. If you update this property, you must also update the ``CidrBlock`` property.
        :param str availability_zone_id: The AZ ID of the subnet.
        :param str cidr_block: The IPv4 CIDR block assigned to the subnet. If you update this property, we create a new subnet, and then delete the existing one.
        :param bool enable_dns64: Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations. For more information, see [DNS64 and NAT64](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64) in the *User Guide*.
        :param int enable_lni_at_device_index: Indicates the device position for local network interfaces in this subnet. For example, ``1`` indicates local network interfaces in this subnet are the secondary network interface (eth1).
        :param str ipv4_ipam_pool_id: An IPv4 IPAM pool ID for the subnet.
        :param int ipv4_netmask_length: An IPv4 netmask length for the subnet.
        :param str ipv6_cidr_block: The IPv6 CIDR block. If you specify ``AssignIpv6AddressOnCreation``, you must also specify an IPv6 CIDR block.
        :param Sequence[str] ipv6_cidr_blocks: The IPv6 network ranges for the subnet, in CIDR notation.
        :param str ipv6_ipam_pool_id: An IPv6 IPAM pool ID for the subnet.
        :param bool ipv6_native: Indicates whether this is an IPv6 only subnet. For more information, see [Subnet basics](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics) in the *User Guide*.
        :param int ipv6_netmask_length: An IPv6 netmask length for the subnet.
        :param bool map_public_ip_on_launch: Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false``.  AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/).
        :param str network_acl_association_id: Property networkAclAssociationId
        :param str outpost_arn: The Amazon Resource Name (ARN) of the Outpost.
        :param 'PrivateDnsNameOptionsOnLaunchModelPropertiesResponse' private_dns_name_options_on_launch: The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*. Available options:  +  EnableResourceNameDnsAAAARecord (true | false)  +  EnableResourceNameDnsARecord (true | false)  +  HostnameType (ip-name | resource-name)
        :param str subnet_id: Property subnetId
        :param Sequence['TagResponse'] tags: Any tags assigned to the subnet.
        :param str vpc_id: The ID of the VPC the subnet is in. If you update this property, you must also update the ``CidrBlock`` property.
        """
        if assign_ipv6_address_on_creation is not None:
            pulumi.set(__self__, "assign_ipv6_address_on_creation", assign_ipv6_address_on_creation)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if availability_zone_id is not None:
            pulumi.set(__self__, "availability_zone_id", availability_zone_id)
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if enable_dns64 is not None:
            pulumi.set(__self__, "enable_dns64", enable_dns64)
        if enable_lni_at_device_index is not None:
            pulumi.set(__self__, "enable_lni_at_device_index", enable_lni_at_device_index)
        if ipv4_ipam_pool_id is not None:
            pulumi.set(__self__, "ipv4_ipam_pool_id", ipv4_ipam_pool_id)
        if ipv4_netmask_length is not None:
            pulumi.set(__self__, "ipv4_netmask_length", ipv4_netmask_length)
        if ipv6_cidr_block is not None:
            pulumi.set(__self__, "ipv6_cidr_block", ipv6_cidr_block)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if ipv6_ipam_pool_id is not None:
            pulumi.set(__self__, "ipv6_ipam_pool_id", ipv6_ipam_pool_id)
        if ipv6_native is not None:
            pulumi.set(__self__, "ipv6_native", ipv6_native)
        if ipv6_netmask_length is not None:
            pulumi.set(__self__, "ipv6_netmask_length", ipv6_netmask_length)
        if map_public_ip_on_launch is not None:
            pulumi.set(__self__, "map_public_ip_on_launch", map_public_ip_on_launch)
        if network_acl_association_id is not None:
            pulumi.set(__self__, "network_acl_association_id", network_acl_association_id)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if private_dns_name_options_on_launch is not None:
            pulumi.set(__self__, "private_dns_name_options_on_launch", private_dns_name_options_on_launch)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="assignIpv6AddressOnCreation")
    def assign_ipv6_address_on_creation(self) -> Optional[bool]:
        """
        Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false``. If you specify ``AssignIpv6AddressOnCreation``, you must also specify an IPv6 CIDR block.
        """
        return pulumi.get(self, "assign_ipv6_address_on_creation")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone of the subnet. If you update this property, you must also update the ``CidrBlock`` property.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> Optional[str]:
        """
        The AZ ID of the subnet.
        """
        return pulumi.get(self, "availability_zone_id")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The IPv4 CIDR block assigned to the subnet. If you update this property, we create a new subnet, and then delete the existing one.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="enableDns64")
    def enable_dns64(self) -> Optional[bool]:
        """
        Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations. For more information, see [DNS64 and NAT64](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64) in the *User Guide*.
        """
        return pulumi.get(self, "enable_dns64")

    @property
    @pulumi.getter(name="enableLniAtDeviceIndex")
    def enable_lni_at_device_index(self) -> Optional[int]:
        """
        Indicates the device position for local network interfaces in this subnet. For example, ``1`` indicates local network interfaces in this subnet are the secondary network interface (eth1).
        """
        return pulumi.get(self, "enable_lni_at_device_index")

    @property
    @pulumi.getter(name="ipv4IpamPoolId")
    def ipv4_ipam_pool_id(self) -> Optional[str]:
        """
        An IPv4 IPAM pool ID for the subnet.
        """
        return pulumi.get(self, "ipv4_ipam_pool_id")

    @property
    @pulumi.getter(name="ipv4NetmaskLength")
    def ipv4_netmask_length(self) -> Optional[int]:
        """
        An IPv4 netmask length for the subnet.
        """
        return pulumi.get(self, "ipv4_netmask_length")

    @property
    @pulumi.getter(name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> Optional[str]:
        """
        The IPv6 CIDR block. If you specify ``AssignIpv6AddressOnCreation``, you must also specify an IPv6 CIDR block.
        """
        return pulumi.get(self, "ipv6_cidr_block")

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        The IPv6 network ranges for the subnet, in CIDR notation.
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @property
    @pulumi.getter(name="ipv6IpamPoolId")
    def ipv6_ipam_pool_id(self) -> Optional[str]:
        """
        An IPv6 IPAM pool ID for the subnet.
        """
        return pulumi.get(self, "ipv6_ipam_pool_id")

    @property
    @pulumi.getter(name="ipv6Native")
    def ipv6_native(self) -> Optional[bool]:
        """
        Indicates whether this is an IPv6 only subnet. For more information, see [Subnet basics](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics) in the *User Guide*.
        """
        return pulumi.get(self, "ipv6_native")

    @property
    @pulumi.getter(name="ipv6NetmaskLength")
    def ipv6_netmask_length(self) -> Optional[int]:
        """
        An IPv6 netmask length for the subnet.
        """
        return pulumi.get(self, "ipv6_netmask_length")

    @property
    @pulumi.getter(name="mapPublicIpOnLaunch")
    def map_public_ip_on_launch(self) -> Optional[bool]:
        """
        Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false``.  AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/).
        """
        return pulumi.get(self, "map_public_ip_on_launch")

    @property
    @pulumi.getter(name="networkAclAssociationId")
    def network_acl_association_id(self) -> Optional[str]:
        """
        Property networkAclAssociationId
        """
        return pulumi.get(self, "network_acl_association_id")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the Outpost.
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter(name="privateDnsNameOptionsOnLaunch")
    def private_dns_name_options_on_launch(self) -> Optional['outputs.PrivateDnsNameOptionsOnLaunchModelPropertiesResponse']:
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*. Available options:  +  EnableResourceNameDnsAAAARecord (true | false)  +  EnableResourceNameDnsARecord (true | false)  +  HostnameType (ip-name | resource-name)
        """
        return pulumi.get(self, "private_dns_name_options_on_launch")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        Property subnetId
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Any tags assigned to the subnet.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        The ID of the VPC the subnet is in. If you update this property, you must also update the ``CidrBlock`` property.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsEc2VPCEndpointPropertiesResponse(dict):
    """
    Definition of awsEc2VPCEndpoint
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationTimestamp":
            suggest = "creation_timestamp"
        elif key == "dnsEntries":
            suggest = "dns_entries"
        elif key == "networkInterfaceIds":
            suggest = "network_interface_ids"
        elif key == "policyDocument":
            suggest = "policy_document"
        elif key == "privateDnsEnabled":
            suggest = "private_dns_enabled"
        elif key == "routeTableIds":
            suggest = "route_table_ids"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcEndpointType":
            suggest = "vpc_endpoint_type"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2VPCEndpointPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2VPCEndpointPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2VPCEndpointPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_timestamp: Optional[str] = None,
                 dns_entries: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 network_interface_ids: Optional[Sequence[str]] = None,
                 policy_document: Optional[Any] = None,
                 private_dns_enabled: Optional[bool] = None,
                 route_table_ids: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None,
                 subnet_ids: Optional[Sequence[str]] = None,
                 vpc_endpoint_type: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsEc2VPCEndpoint
        :param str creation_timestamp: Property creationTimestamp
        :param Sequence[str] dns_entries: Property dnsEntries
        :param str id: Property id
        :param Sequence[str] network_interface_ids: Property networkInterfaceIds
        :param Any policy_document: An endpoint policy, which controls access to the service from the VPC. The default endpoint policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints. For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. CFNlong converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.
        :param bool private_dns_enabled: Indicate whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com``), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service. To use a private hosted zone, you must set the following VPC attributes to ``true``: ``enableDnsHostnames`` and ``enableDnsSupport``. This property is supported only for interface endpoints. Default: ``false``
        :param Sequence[str] route_table_ids: The IDs of the route tables. Routing is supported only for gateway endpoints.
        :param Sequence[str] security_group_ids: The IDs of the security groups to associate with the endpoint network interfaces. If this parameter is not specified, we use the default security group for the VPC. Security groups are supported only for interface endpoints.
        :param str service_name: The name of the endpoint service.
        :param Sequence[str] subnet_ids: The IDs of the subnets in which to create endpoint network interfaces. You must specify this property for an interface endpoint or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.
        :param str vpc_endpoint_type: The type of endpoint. Default: Gateway
        :param str vpc_id: The ID of the VPC.
        """
        if creation_timestamp is not None:
            pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        if dns_entries is not None:
            pulumi.set(__self__, "dns_entries", dns_entries)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if network_interface_ids is not None:
            pulumi.set(__self__, "network_interface_ids", network_interface_ids)
        if policy_document is not None:
            pulumi.set(__self__, "policy_document", policy_document)
        if private_dns_enabled is not None:
            pulumi.set(__self__, "private_dns_enabled", private_dns_enabled)
        if route_table_ids is not None:
            pulumi.set(__self__, "route_table_ids", route_table_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_endpoint_type is not None:
            pulumi.set(__self__, "vpc_endpoint_type", vpc_endpoint_type)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> Optional[str]:
        """
        Property creationTimestamp
        """
        return pulumi.get(self, "creation_timestamp")

    @property
    @pulumi.getter(name="dnsEntries")
    def dns_entries(self) -> Optional[Sequence[str]]:
        """
        Property dnsEntries
        """
        return pulumi.get(self, "dns_entries")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="networkInterfaceIds")
    def network_interface_ids(self) -> Optional[Sequence[str]]:
        """
        Property networkInterfaceIds
        """
        return pulumi.get(self, "network_interface_ids")

    @property
    @pulumi.getter(name="policyDocument")
    def policy_document(self) -> Optional[Any]:
        """
        An endpoint policy, which controls access to the service from the VPC. The default endpoint policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints. For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. CFNlong converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.
        """
        return pulumi.get(self, "policy_document")

    @property
    @pulumi.getter(name="privateDnsEnabled")
    def private_dns_enabled(self) -> Optional[bool]:
        """
        Indicate whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com``), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service. To use a private hosted zone, you must set the following VPC attributes to ``true``: ``enableDnsHostnames`` and ``enableDnsSupport``. This property is supported only for interface endpoints. Default: ``false``
        """
        return pulumi.get(self, "private_dns_enabled")

    @property
    @pulumi.getter(name="routeTableIds")
    def route_table_ids(self) -> Optional[Sequence[str]]:
        """
        The IDs of the route tables. Routing is supported only for gateway endpoints.
        """
        return pulumi.get(self, "route_table_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        The IDs of the security groups to associate with the endpoint network interfaces. If this parameter is not specified, we use the default security group for the VPC. Security groups are supported only for interface endpoints.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        The name of the endpoint service.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        The IDs of the subnets in which to create endpoint network interfaces. You must specify this property for an interface endpoint or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcEndpointType")
    def vpc_endpoint_type(self) -> Optional[str]:
        """
        The type of endpoint. Default: Gateway
        """
        return pulumi.get(self, "vpc_endpoint_type")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsEc2VPCPeeringConnectionPropertiesResponse(dict):
    """
    Definition of awsEc2VPCPeeringConnection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerOwnerId":
            suggest = "peer_owner_id"
        elif key == "peerRegion":
            suggest = "peer_region"
        elif key == "peerRoleArn":
            suggest = "peer_role_arn"
        elif key == "peerVpcId":
            suggest = "peer_vpc_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2VPCPeeringConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2VPCPeeringConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2VPCPeeringConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 peer_owner_id: Optional[str] = None,
                 peer_region: Optional[str] = None,
                 peer_role_arn: Optional[str] = None,
                 peer_vpc_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsEc2VPCPeeringConnection
        :param str id: Property id
        :param str peer_owner_id: The AWS account ID of the owner of the accepter VPC.
        :param str peer_region: The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
        :param str peer_role_arn: The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.
        :param str peer_vpc_id: The ID of the VPC with which you are creating the VPC peering connection. You must specify this parameter in the request.
        :param Sequence['TagResponse'] tags: Property tags
        :param str vpc_id: The ID of the VPC.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if peer_owner_id is not None:
            pulumi.set(__self__, "peer_owner_id", peer_owner_id)
        if peer_region is not None:
            pulumi.set(__self__, "peer_region", peer_region)
        if peer_role_arn is not None:
            pulumi.set(__self__, "peer_role_arn", peer_role_arn)
        if peer_vpc_id is not None:
            pulumi.set(__self__, "peer_vpc_id", peer_vpc_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="peerOwnerId")
    def peer_owner_id(self) -> Optional[str]:
        """
        The AWS account ID of the owner of the accepter VPC.
        """
        return pulumi.get(self, "peer_owner_id")

    @property
    @pulumi.getter(name="peerRegion")
    def peer_region(self) -> Optional[str]:
        """
        The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.
        """
        return pulumi.get(self, "peer_region")

    @property
    @pulumi.getter(name="peerRoleArn")
    def peer_role_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.
        """
        return pulumi.get(self, "peer_role_arn")

    @property
    @pulumi.getter(name="peerVpcId")
    def peer_vpc_id(self) -> Optional[str]:
        """
        The ID of the VPC with which you are creating the VPC peering connection. You must specify this parameter in the request.
        """
        return pulumi.get(self, "peer_vpc_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsEc2VolumePropertiesResponse(dict):
    """
    Definition of awsEc2Volume
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoEnableIO":
            suggest = "auto_enable_io"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "multiAttachEnabled":
            suggest = "multi_attach_enabled"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2VolumePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2VolumePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2VolumePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_enable_io: Optional[bool] = None,
                 availability_zone: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 multi_attach_enabled: Optional[bool] = None,
                 outpost_arn: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 throughput: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_type: Optional[str] = None):
        """
        Definition of awsEc2Volume
        :param bool auto_enable_io: Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.
        :param str availability_zone: The ID of the Availability Zone in which to create the volume. For example, ``us-east-1a``.
        :param bool encrypted: Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default) in the *Amazon Elastic Compute Cloud User Guide*. Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances).
        :param int iops: The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type:  +   ``gp3``: 3,000 - 16,000 IOPS  +   ``io1``: 100 - 64,000 IOPS  +   ``io2``: 100 - 256,000 IOPS   For ``io2`` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances). On other instances, you can achieve performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2``, ``st1``, ``sc1``, or ``standard`` volumes.
        :param str kms_key_id: The identifier of the kms-key-long to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true``. If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true``, then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the aws-managed-key. Alternatively, if you want to specify a different key, you can specify one of the following:  +  Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.  +  Key alias. Specify the alias for the key, prefixed with ``alias/``. For example, for a key with the alias ``my_cmk``, use ``alias/my_cmk``. Or to specify the aws-managed-key, use ``alias/aws/ebs``.  +  Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.  +  Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
        :param bool multi_attach_enabled: Indicates whether Amazon EBS Multi-Attach is enabled. CFNlong does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.
        :param str outpost_arn: The Amazon Resource Name (ARN) of the Outpost.
        :param int size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type:  +   ``gp2`` and ``gp3``: 1 - 16,384 GiB  +   ``io1``: 4 - 16,384 GiB  +   ``io2``: 4 - 65,536 GiB  +   ``st1`` and ``sc1``: 125 - 16,384 GiB  +   ``standard``: 1 - 1024 GiB
        :param str snapshot_id: The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size.
        :param Sequence['TagResponse'] tags: The tags to apply to the volume during creation.
        :param int throughput: The throughput to provision for a volume, with a maximum of 1,000 MiB/s. This parameter is valid only for ``gp3`` volumes. The default value is 125. Valid Range: Minimum value of 125. Maximum value of 1000.
        :param str volume_id: Property volumeId
        :param str volume_type: The volume type. This parameter can be one of the following values:  +  General Purpose SSD: ``gp2`` | ``gp3``   +  Provisioned IOPS SSD: ``io1`` | ``io2``   +  Throughput Optimized HDD: ``st1``   +  Cold HDD: ``sc1``   +  Magnetic: ``standard``    For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon Elastic Compute Cloud User Guide*. Default: ``gp2``
        """
        if auto_enable_io is not None:
            pulumi.set(__self__, "auto_enable_io", auto_enable_io)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if multi_attach_enabled is not None:
            pulumi.set(__self__, "multi_attach_enabled", multi_attach_enabled)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="autoEnableIO")
    def auto_enable_io(self) -> Optional[bool]:
        """
        Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.
        """
        return pulumi.get(self, "auto_enable_io")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The ID of the Availability Zone in which to create the volume. For example, ``us-east-1a``.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Encryption by default](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default) in the *Amazon Elastic Compute Cloud User Guide*. Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances).
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type:  +   ``gp3``: 3,000 - 16,000 IOPS  +   ``io1``: 100 - 64,000 IOPS  +   ``io2``: 100 - 256,000 IOPS   For ``io2`` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances). On other instances, you can achieve performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2``, ``st1``, ``sc1``, or ``standard`` volumes.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The identifier of the kms-key-long to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true``. If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true``, then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the aws-managed-key. Alternatively, if you want to specify a different key, you can specify one of the following:  +  Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.  +  Key alias. Specify the alias for the key, prefixed with ``alias/``. For example, for a key with the alias ``my_cmk``, use ``alias/my_cmk``. Or to specify the aws-managed-key, use ``alias/aws/ebs``.  +  Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.  +  Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="multiAttachEnabled")
    def multi_attach_enabled(self) -> Optional[bool]:
        """
        Indicates whether Amazon EBS Multi-Attach is enabled. CFNlong does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.
        """
        return pulumi.get(self, "multi_attach_enabled")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the Outpost.
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type:  +   ``gp2`` and ``gp3``: 1 - 16,384 GiB  +   ``io1``: 4 - 16,384 GiB  +   ``io2``: 4 - 65,536 GiB  +   ``st1`` and ``sc1``: 125 - 16,384 GiB  +   ``standard``: 1 - 1024 GiB
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The tags to apply to the volume during creation.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        The throughput to provision for a volume, with a maximum of 1,000 MiB/s. This parameter is valid only for ``gp3`` volumes. The default value is 125. Valid Range: Minimum value of 125. Maximum value of 1000.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        Property volumeId
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The volume type. This parameter can be one of the following values:  +  General Purpose SSD: ``gp2`` | ``gp3``   +  Provisioned IOPS SSD: ``io1`` | ``io2``   +  Throughput Optimized HDD: ``st1``   +  Cold HDD: ``sc1``   +  Magnetic: ``standard``    For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html) in the *Amazon Elastic Compute Cloud User Guide*. Default: ``gp2``
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AwsEc2VpcPropertiesResponse(dict):
    """
    Definition of awsEc2Vpc
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "cidrBlockAssociations":
            suggest = "cidr_block_associations"
        elif key == "defaultNetworkAcl":
            suggest = "default_network_acl"
        elif key == "defaultSecurityGroup":
            suggest = "default_security_group"
        elif key == "enableDnsHostnames":
            suggest = "enable_dns_hostnames"
        elif key == "enableDnsSupport":
            suggest = "enable_dns_support"
        elif key == "instanceTenancy":
            suggest = "instance_tenancy"
        elif key == "ipv4IpamPoolId":
            suggest = "ipv4_ipam_pool_id"
        elif key == "ipv4NetmaskLength":
            suggest = "ipv4_netmask_length"
        elif key == "ipv6CidrBlocks":
            suggest = "ipv6_cidr_blocks"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEc2VpcPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEc2VpcPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEc2VpcPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: Optional[str] = None,
                 cidr_block_associations: Optional[Sequence[str]] = None,
                 default_network_acl: Optional[str] = None,
                 default_security_group: Optional[str] = None,
                 enable_dns_hostnames: Optional[bool] = None,
                 enable_dns_support: Optional[bool] = None,
                 instance_tenancy: Optional[str] = None,
                 ipv4_ipam_pool_id: Optional[str] = None,
                 ipv4_netmask_length: Optional[int] = None,
                 ipv6_cidr_blocks: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsEc2Vpc
        :param str cidr_block: The IPv4 network range for the VPC, in CIDR notation. For example, ``10.0.0.0/16``. We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18``, we modify it to ``100.68.0.0/18``. You must specify either``CidrBlock`` or ``Ipv4IpamPoolId``.
        :param Sequence[str] cidr_block_associations: Property cidrBlockAssociations
        :param str default_network_acl: Property defaultNetworkAcl
        :param str default_security_group: Property defaultSecurityGroup
        :param bool enable_dns_hostnames: Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support). You can only enable DNS hostnames if you've enabled DNS support.
        :param bool enable_dns_support: Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range 'plus two' succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support).
        :param str instance_tenancy: The allowed tenancy of instances launched into the VPC.  +  ``default``: An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch.  +  ``dedicated``: An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of ``host`` during instance launch. You cannot specify a tenancy of ``default`` during instance launch.   Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``dedicated`` to ``default``. Updating ``InstanceTenancy`` from ``default`` to ``dedicated`` requires replacement.
        :param str ipv4_ipam_pool_id: The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR. For more information, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide*. You must specify either``CidrBlock`` or ``Ipv4IpamPoolId``.
        :param int ipv4_netmask_length: The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide*.
        :param Sequence[str] ipv6_cidr_blocks: Property ipv6CidrBlocks
        :param Sequence['TagResponse'] tags: The tags for the VPC.
        :param str vpc_id: Property vpcId
        """
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if cidr_block_associations is not None:
            pulumi.set(__self__, "cidr_block_associations", cidr_block_associations)
        if default_network_acl is not None:
            pulumi.set(__self__, "default_network_acl", default_network_acl)
        if default_security_group is not None:
            pulumi.set(__self__, "default_security_group", default_security_group)
        if enable_dns_hostnames is not None:
            pulumi.set(__self__, "enable_dns_hostnames", enable_dns_hostnames)
        if enable_dns_support is not None:
            pulumi.set(__self__, "enable_dns_support", enable_dns_support)
        if instance_tenancy is not None:
            pulumi.set(__self__, "instance_tenancy", instance_tenancy)
        if ipv4_ipam_pool_id is not None:
            pulumi.set(__self__, "ipv4_ipam_pool_id", ipv4_ipam_pool_id)
        if ipv4_netmask_length is not None:
            pulumi.set(__self__, "ipv4_netmask_length", ipv4_netmask_length)
        if ipv6_cidr_blocks is not None:
            pulumi.set(__self__, "ipv6_cidr_blocks", ipv6_cidr_blocks)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The IPv4 network range for the VPC, in CIDR notation. For example, ``10.0.0.0/16``. We modify the specified CIDR block to its canonical form; for example, if you specify ``100.68.0.18/18``, we modify it to ``100.68.0.0/18``. You must specify either``CidrBlock`` or ``Ipv4IpamPoolId``.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter(name="cidrBlockAssociations")
    def cidr_block_associations(self) -> Optional[Sequence[str]]:
        """
        Property cidrBlockAssociations
        """
        return pulumi.get(self, "cidr_block_associations")

    @property
    @pulumi.getter(name="defaultNetworkAcl")
    def default_network_acl(self) -> Optional[str]:
        """
        Property defaultNetworkAcl
        """
        return pulumi.get(self, "default_network_acl")

    @property
    @pulumi.getter(name="defaultSecurityGroup")
    def default_security_group(self) -> Optional[str]:
        """
        Property defaultSecurityGroup
        """
        return pulumi.get(self, "default_security_group")

    @property
    @pulumi.getter(name="enableDnsHostnames")
    def enable_dns_hostnames(self) -> Optional[bool]:
        """
        Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support). You can only enable DNS hostnames if you've enabled DNS support.
        """
        return pulumi.get(self, "enable_dns_hostnames")

    @property
    @pulumi.getter(name="enableDnsSupport")
    def enable_dns_support(self) -> Optional[bool]:
        """
        Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range 'plus two' succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see [DNS attributes in your VPC](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support).
        """
        return pulumi.get(self, "enable_dns_support")

    @property
    @pulumi.getter(name="instanceTenancy")
    def instance_tenancy(self) -> Optional[str]:
        """
        The allowed tenancy of instances launched into the VPC.  +  ``default``: An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch.  +  ``dedicated``: An instance launched into the VPC runs on dedicated hardware by default, unless you explicitly specify a tenancy of ``host`` during instance launch. You cannot specify a tenancy of ``default`` during instance launch.   Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``dedicated`` to ``default``. Updating ``InstanceTenancy`` from ``default`` to ``dedicated`` requires replacement.
        """
        return pulumi.get(self, "instance_tenancy")

    @property
    @pulumi.getter(name="ipv4IpamPoolId")
    def ipv4_ipam_pool_id(self) -> Optional[str]:
        """
        The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR. For more information, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide*. You must specify either``CidrBlock`` or ``Ipv4IpamPoolId``.
        """
        return pulumi.get(self, "ipv4_ipam_pool_id")

    @property
    @pulumi.getter(name="ipv4NetmaskLength")
    def ipv4_netmask_length(self) -> Optional[int]:
        """
        The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see [What is IPAM?](https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html) in the *Amazon VPC IPAM User Guide*.
        """
        return pulumi.get(self, "ipv4_netmask_length")

    @property
    @pulumi.getter(name="ipv6CidrBlocks")
    def ipv6_cidr_blocks(self) -> Optional[Sequence[str]]:
        """
        Property ipv6CidrBlocks
        """
        return pulumi.get(self, "ipv6_cidr_blocks")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The tags for the VPC.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        Property vpcId
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsEcrImageDetailPropertiesResponse(dict):
    """
    Definition of awsEcrImageDetail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactMediaType":
            suggest = "artifact_media_type"
        elif key == "imageDigest":
            suggest = "image_digest"
        elif key == "imageManifestMediaType":
            suggest = "image_manifest_media_type"
        elif key == "imagePushedAt":
            suggest = "image_pushed_at"
        elif key == "imageScanFindingsSummary":
            suggest = "image_scan_findings_summary"
        elif key == "imageScanStatus":
            suggest = "image_scan_status"
        elif key == "imageSizeInBytes":
            suggest = "image_size_in_bytes"
        elif key == "imageTags":
            suggest = "image_tags"
        elif key == "lastRecordedPullTime":
            suggest = "last_recorded_pull_time"
        elif key == "registryId":
            suggest = "registry_id"
        elif key == "repositoryName":
            suggest = "repository_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEcrImageDetailPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEcrImageDetailPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEcrImageDetailPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_media_type: Optional[str] = None,
                 image_digest: Optional[str] = None,
                 image_manifest_media_type: Optional[str] = None,
                 image_pushed_at: Optional[str] = None,
                 image_scan_findings_summary: Optional['outputs.ImageScanFindingsSummaryResponse'] = None,
                 image_scan_status: Optional['outputs.ImageScanStatusResponse'] = None,
                 image_size_in_bytes: Optional[float] = None,
                 image_tags: Optional[Sequence[str]] = None,
                 last_recorded_pull_time: Optional[str] = None,
                 registry_id: Optional[str] = None,
                 repository_name: Optional[str] = None):
        """
        Definition of awsEcrImageDetail
        :param str artifact_media_type: <p>The artifact media type of the image.</p>
        :param str image_digest: <p>The <code>sha256</code> digest of the image manifest.</p>
        :param str image_manifest_media_type: <p>The media type of the image manifest.</p>
        :param str image_pushed_at: <p>The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository. </p>
        :param 'ImageScanFindingsSummaryResponse' image_scan_findings_summary: <p>A summary of the last completed image scan.</p>
        :param 'ImageScanStatusResponse' image_scan_status: <p>The current state of the scan.</p>
        :param float image_size_in_bytes: <p>The size, in bytes, of the image in the repository.</p> <p>If the image is a manifest list, this will be the max size of all manifests in the list.</p> <note> <p>Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the <code>docker images</code> command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by <a>DescribeImages</a>.</p> </note>
        :param Sequence[str] image_tags: <p>The list of tags associated with this image.</p>
        :param str last_recorded_pull_time: <p>The date and time, expressed in standard JavaScript date format, when Amazon ECR recorded the last image pull.</p> <note> <p>Amazon ECR refreshes the last image pull timestamp at least once every 24 hours. For example, if you pull an image once a day then the <code>lastRecordedPullTime</code> timestamp will indicate the exact time that the image was last pulled. However, if you pull an image once an hour, because Amazon ECR refreshes the <code>lastRecordedPullTime</code> timestamp at least once every 24 hours, the result may not be the exact time that the image was last pulled.</p> </note>
        :param str registry_id: <p>The Amazon Web Services account ID associated with the registry to which this image belongs.</p>
        :param str repository_name: <p>The name of the repository to which this image belongs.</p>
        """
        if artifact_media_type is not None:
            pulumi.set(__self__, "artifact_media_type", artifact_media_type)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_manifest_media_type is not None:
            pulumi.set(__self__, "image_manifest_media_type", image_manifest_media_type)
        if image_pushed_at is not None:
            pulumi.set(__self__, "image_pushed_at", image_pushed_at)
        if image_scan_findings_summary is not None:
            pulumi.set(__self__, "image_scan_findings_summary", image_scan_findings_summary)
        if image_scan_status is not None:
            pulumi.set(__self__, "image_scan_status", image_scan_status)
        if image_size_in_bytes is not None:
            pulumi.set(__self__, "image_size_in_bytes", image_size_in_bytes)
        if image_tags is not None:
            pulumi.set(__self__, "image_tags", image_tags)
        if last_recorded_pull_time is not None:
            pulumi.set(__self__, "last_recorded_pull_time", last_recorded_pull_time)
        if registry_id is not None:
            pulumi.set(__self__, "registry_id", registry_id)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)

    @property
    @pulumi.getter(name="artifactMediaType")
    def artifact_media_type(self) -> Optional[str]:
        """
        <p>The artifact media type of the image.</p>
        """
        return pulumi.get(self, "artifact_media_type")

    @property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[str]:
        """
        <p>The <code>sha256</code> digest of the image manifest.</p>
        """
        return pulumi.get(self, "image_digest")

    @property
    @pulumi.getter(name="imageManifestMediaType")
    def image_manifest_media_type(self) -> Optional[str]:
        """
        <p>The media type of the image manifest.</p>
        """
        return pulumi.get(self, "image_manifest_media_type")

    @property
    @pulumi.getter(name="imagePushedAt")
    def image_pushed_at(self) -> Optional[str]:
        """
        <p>The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository. </p>
        """
        return pulumi.get(self, "image_pushed_at")

    @property
    @pulumi.getter(name="imageScanFindingsSummary")
    def image_scan_findings_summary(self) -> Optional['outputs.ImageScanFindingsSummaryResponse']:
        """
        <p>A summary of the last completed image scan.</p>
        """
        return pulumi.get(self, "image_scan_findings_summary")

    @property
    @pulumi.getter(name="imageScanStatus")
    def image_scan_status(self) -> Optional['outputs.ImageScanStatusResponse']:
        """
        <p>The current state of the scan.</p>
        """
        return pulumi.get(self, "image_scan_status")

    @property
    @pulumi.getter(name="imageSizeInBytes")
    def image_size_in_bytes(self) -> Optional[float]:
        """
        <p>The size, in bytes, of the image in the repository.</p> <p>If the image is a manifest list, this will be the max size of all manifests in the list.</p> <note> <p>Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the <code>docker images</code> command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by <a>DescribeImages</a>.</p> </note>
        """
        return pulumi.get(self, "image_size_in_bytes")

    @property
    @pulumi.getter(name="imageTags")
    def image_tags(self) -> Optional[Sequence[str]]:
        """
        <p>The list of tags associated with this image.</p>
        """
        return pulumi.get(self, "image_tags")

    @property
    @pulumi.getter(name="lastRecordedPullTime")
    def last_recorded_pull_time(self) -> Optional[str]:
        """
        <p>The date and time, expressed in standard JavaScript date format, when Amazon ECR recorded the last image pull.</p> <note> <p>Amazon ECR refreshes the last image pull timestamp at least once every 24 hours. For example, if you pull an image once a day then the <code>lastRecordedPullTime</code> timestamp will indicate the exact time that the image was last pulled. However, if you pull an image once an hour, because Amazon ECR refreshes the <code>lastRecordedPullTime</code> timestamp at least once every 24 hours, the result may not be the exact time that the image was last pulled.</p> </note>
        """
        return pulumi.get(self, "last_recorded_pull_time")

    @property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> Optional[str]:
        """
        <p>The Amazon Web Services account ID associated with the registry to which this image belongs.</p>
        """
        return pulumi.get(self, "registry_id")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[str]:
        """
        <p>The name of the repository to which this image belongs.</p>
        """
        return pulumi.get(self, "repository_name")


@pulumi.output_type
class AwsEcrRepositoryPropertiesResponse(dict):
    """
    Definition of awsEcrRepository
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emptyOnDelete":
            suggest = "empty_on_delete"
        elif key == "encryptionConfiguration":
            suggest = "encryption_configuration"
        elif key == "imageScanningConfiguration":
            suggest = "image_scanning_configuration"
        elif key == "imageTagMutability":
            suggest = "image_tag_mutability"
        elif key == "lifecyclePolicy":
            suggest = "lifecycle_policy"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "repositoryPolicyText":
            suggest = "repository_policy_text"
        elif key == "repositoryUri":
            suggest = "repository_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEcrRepositoryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEcrRepositoryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEcrRepositoryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 empty_on_delete: Optional[bool] = None,
                 encryption_configuration: Optional['outputs.EncryptionConfigurationResponse'] = None,
                 image_scanning_configuration: Optional['outputs.ImageScanningConfigurationResponse'] = None,
                 image_tag_mutability: Optional[str] = None,
                 lifecycle_policy: Optional['outputs.LifecyclePolicyResponse'] = None,
                 repository_name: Optional[str] = None,
                 repository_policy_text: Optional[Any] = None,
                 repository_uri: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsEcrRepository
        :param str arn: Property arn
        :param bool empty_on_delete: If true, deleting the repository force deletes the contents of the repository. If false, the repository must be empty before attempting to delete it. If true, deleting the repository force deletes the contents of the repository. Without a force delete, you can only delete empty repositories.
        :param 'EncryptionConfigurationResponse' encryption_configuration: The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest. The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest. By default, when no encryption configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES-256 encryption algorithm. This does not require any action on your part. For more control over the encryption of the contents of your repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
        :param 'ImageScanningConfigurationResponse' image_scanning_configuration: The image scanning configuration for the repository. This determines whether images are scanned for known vulnerabilities after being pushed to the repository. The image scanning configuration for a repository.
        :param str image_tag_mutability: The tag mutability setting for the repository. If this parameter is omitted, the default setting of ``MUTABLE`` will be used which will allow image tags to be overwritten. If ``IMMUTABLE`` is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
        :param 'LifecyclePolicyResponse' lifecycle_policy: Creates or updates a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html). The ``LifecyclePolicy`` property type specifies a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html) in the *Amazon ECR User Guide*.
        :param str repository_name: The name to use for the repository. The repository name may be specified on its own (such as ``nginx-web-app``) or it can be prepended with a namespace to group the repository into a category (such as ``project-a/nginx-web-app``). If you don't specify a name, CFNlong generates a unique physical ID and uses that ID for the repository name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html). The repository name must start with a letter and can only contain lowercase letters, numbers, hyphens, underscores, and forward slashes.  If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        :param Any repository_policy_text: The JSON repository policy text to apply to the repository. For more information, see [Amazon ECR repository policies](https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html) in the *Amazon Elastic Container Registry User Guide*.
        :param str repository_uri: Property repositoryUri
        :param Sequence['TagResponse'] tags: An array of key-value pairs to apply to this resource.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if empty_on_delete is not None:
            pulumi.set(__self__, "empty_on_delete", empty_on_delete)
        if encryption_configuration is not None:
            pulumi.set(__self__, "encryption_configuration", encryption_configuration)
        if image_scanning_configuration is not None:
            pulumi.set(__self__, "image_scanning_configuration", image_scanning_configuration)
        if image_tag_mutability is not None:
            pulumi.set(__self__, "image_tag_mutability", image_tag_mutability)
        if lifecycle_policy is not None:
            pulumi.set(__self__, "lifecycle_policy", lifecycle_policy)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)
        if repository_policy_text is not None:
            pulumi.set(__self__, "repository_policy_text", repository_policy_text)
        if repository_uri is not None:
            pulumi.set(__self__, "repository_uri", repository_uri)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="emptyOnDelete")
    def empty_on_delete(self) -> Optional[bool]:
        """
        If true, deleting the repository force deletes the contents of the repository. If false, the repository must be empty before attempting to delete it. If true, deleting the repository force deletes the contents of the repository. Without a force delete, you can only delete empty repositories.
        """
        return pulumi.get(self, "empty_on_delete")

    @property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional['outputs.EncryptionConfigurationResponse']:
        """
        The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest. The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest. By default, when no encryption configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES-256 encryption algorithm. This does not require any action on your part. For more control over the encryption of the contents of your repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
        """
        return pulumi.get(self, "encryption_configuration")

    @property
    @pulumi.getter(name="imageScanningConfiguration")
    def image_scanning_configuration(self) -> Optional['outputs.ImageScanningConfigurationResponse']:
        """
        The image scanning configuration for the repository. This determines whether images are scanned for known vulnerabilities after being pushed to the repository. The image scanning configuration for a repository.
        """
        return pulumi.get(self, "image_scanning_configuration")

    @property
    @pulumi.getter(name="imageTagMutability")
    def image_tag_mutability(self) -> Optional[str]:
        """
        The tag mutability setting for the repository. If this parameter is omitted, the default setting of ``MUTABLE`` will be used which will allow image tags to be overwritten. If ``IMMUTABLE`` is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
        """
        return pulumi.get(self, "image_tag_mutability")

    @property
    @pulumi.getter(name="lifecyclePolicy")
    def lifecycle_policy(self) -> Optional['outputs.LifecyclePolicyResponse']:
        """
        Creates or updates a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html). The ``LifecyclePolicy`` property type specifies a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html) in the *Amazon ECR User Guide*.
        """
        return pulumi.get(self, "lifecycle_policy")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[str]:
        """
        The name to use for the repository. The repository name may be specified on its own (such as ``nginx-web-app``) or it can be prepended with a namespace to group the repository into a category (such as ``project-a/nginx-web-app``). If you don't specify a name, CFNlong generates a unique physical ID and uses that ID for the repository name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html). The repository name must start with a letter and can only contain lowercase letters, numbers, hyphens, underscores, and forward slashes.  If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="repositoryPolicyText")
    def repository_policy_text(self) -> Optional[Any]:
        """
        The JSON repository policy text to apply to the repository. For more information, see [Amazon ECR repository policies](https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html) in the *Amazon Elastic Container Registry User Guide*.
        """
        return pulumi.get(self, "repository_policy_text")

    @property
    @pulumi.getter(name="repositoryUri")
    def repository_uri(self) -> Optional[str]:
        """
        Property repositoryUri
        """
        return pulumi.get(self, "repository_uri")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An array of key-value pairs to apply to this resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsEcsClusterPropertiesResponse(dict):
    """
    Definition of awsEcsCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProviders":
            suggest = "capacity_providers"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "clusterSettings":
            suggest = "cluster_settings"
        elif key == "defaultCapacityProviderStrategy":
            suggest = "default_capacity_provider_strategy"
        elif key == "serviceConnectDefaults":
            suggest = "service_connect_defaults"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEcsClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEcsClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEcsClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 capacity_providers: Optional[Sequence[str]] = None,
                 cluster_name: Optional[str] = None,
                 cluster_settings: Optional[Sequence['outputs.ClusterSettingsResponse']] = None,
                 configuration: Optional['outputs.ClusterConfigurationResponse'] = None,
                 default_capacity_provider_strategy: Optional[Sequence['outputs.CapacityProviderStrategyItemResponse']] = None,
                 service_connect_defaults: Optional['outputs.ServiceConnectDefaultsResponse'] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsEcsCluster
        :param str arn: Property arn
        :param Sequence[str] capacity_providers: The short name of one or more capacity providers to associate with the cluster. A capacity provider must be associated with a cluster before it can be included as part of the default capacity provider strategy of the cluster or used in a capacity provider strategy when calling the [CreateService](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html) or [RunTask](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) actions. If specifying a capacity provider that uses an Auto Scaling group, the capacity provider must be created but not associated with another cluster. New Auto Scaling group capacity providers can be created with the [CreateCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateCapacityProvider.html) API operation. To use a FARGATElong capacity provider, specify either the ``FARGATE`` or ``FARGATE_SPOT`` capacity providers. The FARGATElong capacity providers are available to all accounts and only need to be associated with a cluster to be used. The [PutCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutCapacityProvider.html) API operation is used to update the list of available capacity providers for a cluster after the cluster is created.
        :param str cluster_name: A user-generated string that you use to identify your cluster. If you don't specify a name, CFNlong generates a unique physical ID for the name.
        :param Sequence['ClusterSettingsResponse'] cluster_settings: The settings to use when creating a cluster. This parameter is used to turn on CloudWatch Container Insights for a cluster.
        :param 'ClusterConfigurationResponse' configuration: The execute command configuration for the cluster. The execute command configuration for the cluster.
        :param Sequence['CapacityProviderStrategyItemResponse'] default_capacity_provider_strategy: The default capacity provider strategy for the cluster. When services or tasks are run in the cluster with no launch type or capacity provider strategy specified, the default capacity provider strategy is used.
        :param 'ServiceConnectDefaultsResponse' service_connect_defaults: Use this parameter to set a default Service Connect namespace. After you set a default Service Connect namespace, any new services with Service Connect turned on that are created in the cluster are added as client services in the namespace. This setting only applies to new services that set the ``enabled`` parameter to ``true`` in the ``ServiceConnectConfiguration``. You can set the namespace of each service individually in the ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*. Use this parameter to set a default Service Connect namespace. After you set a default Service Connect namespace, any new services with Service Connect turned on that are created in the cluster are added as client services in the namespace. This setting only applies to new services that set the ``enabled`` parameter to ``true`` in the ``ServiceConnectConfiguration``. You can set the namespace of each service individually in the ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param Sequence['TagResponse'] tags: The metadata that you apply to the cluster to help you categorize and organize them. Each tag consists of a key and an optional value. You define both. The following basic restrictions apply to tags:  +  Maximum number of tags per resource - 50  +  For each resource, each tag key must be unique, and each tag key can have only one value.  +  Maximum key length - 128 Unicode characters in UTF-8  +  Maximum value length - 256 Unicode characters in UTF-8  +  If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.  +  Tag keys and values are case-sensitive.  +  Do not use ``aws:``, ``AWS:``, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if capacity_providers is not None:
            pulumi.set(__self__, "capacity_providers", capacity_providers)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_settings is not None:
            pulumi.set(__self__, "cluster_settings", cluster_settings)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if default_capacity_provider_strategy is not None:
            pulumi.set(__self__, "default_capacity_provider_strategy", default_capacity_provider_strategy)
        if service_connect_defaults is not None:
            pulumi.set(__self__, "service_connect_defaults", service_connect_defaults)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="capacityProviders")
    def capacity_providers(self) -> Optional[Sequence[str]]:
        """
        The short name of one or more capacity providers to associate with the cluster. A capacity provider must be associated with a cluster before it can be included as part of the default capacity provider strategy of the cluster or used in a capacity provider strategy when calling the [CreateService](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html) or [RunTask](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) actions. If specifying a capacity provider that uses an Auto Scaling group, the capacity provider must be created but not associated with another cluster. New Auto Scaling group capacity providers can be created with the [CreateCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateCapacityProvider.html) API operation. To use a FARGATElong capacity provider, specify either the ``FARGATE`` or ``FARGATE_SPOT`` capacity providers. The FARGATElong capacity providers are available to all accounts and only need to be associated with a cluster to be used. The [PutCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutCapacityProvider.html) API operation is used to update the list of available capacity providers for a cluster after the cluster is created.
        """
        return pulumi.get(self, "capacity_providers")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        A user-generated string that you use to identify your cluster. If you don't specify a name, CFNlong generates a unique physical ID for the name.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterSettings")
    def cluster_settings(self) -> Optional[Sequence['outputs.ClusterSettingsResponse']]:
        """
        The settings to use when creating a cluster. This parameter is used to turn on CloudWatch Container Insights for a cluster.
        """
        return pulumi.get(self, "cluster_settings")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.ClusterConfigurationResponse']:
        """
        The execute command configuration for the cluster. The execute command configuration for the cluster.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="defaultCapacityProviderStrategy")
    def default_capacity_provider_strategy(self) -> Optional[Sequence['outputs.CapacityProviderStrategyItemResponse']]:
        """
        The default capacity provider strategy for the cluster. When services or tasks are run in the cluster with no launch type or capacity provider strategy specified, the default capacity provider strategy is used.
        """
        return pulumi.get(self, "default_capacity_provider_strategy")

    @property
    @pulumi.getter(name="serviceConnectDefaults")
    def service_connect_defaults(self) -> Optional['outputs.ServiceConnectDefaultsResponse']:
        """
        Use this parameter to set a default Service Connect namespace. After you set a default Service Connect namespace, any new services with Service Connect turned on that are created in the cluster are added as client services in the namespace. This setting only applies to new services that set the ``enabled`` parameter to ``true`` in the ``ServiceConnectConfiguration``. You can set the namespace of each service individually in the ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*. Use this parameter to set a default Service Connect namespace. After you set a default Service Connect namespace, any new services with Service Connect turned on that are created in the cluster are added as client services in the namespace. This setting only applies to new services that set the ``enabled`` parameter to ``true`` in the ``ServiceConnectConfiguration``. You can set the namespace of each service individually in the ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "service_connect_defaults")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The metadata that you apply to the cluster to help you categorize and organize them. Each tag consists of a key and an optional value. You define both. The following basic restrictions apply to tags:  +  Maximum number of tags per resource - 50  +  For each resource, each tag key must be unique, and each tag key can have only one value.  +  Maximum key length - 128 Unicode characters in UTF-8  +  Maximum value length - 256 Unicode characters in UTF-8  +  If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.  +  Tag keys and values are case-sensitive.  +  Do not use ``aws:``, ``AWS:``, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsEcsServicePropertiesResponse(dict):
    """
    Definition of awsEcsService
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProviderStrategy":
            suggest = "capacity_provider_strategy"
        elif key == "deploymentConfiguration":
            suggest = "deployment_configuration"
        elif key == "deploymentController":
            suggest = "deployment_controller"
        elif key == "desiredCount":
            suggest = "desired_count"
        elif key == "enableECSManagedTags":
            suggest = "enable_ecs_managed_tags"
        elif key == "enableExecuteCommand":
            suggest = "enable_execute_command"
        elif key == "healthCheckGracePeriodSeconds":
            suggest = "health_check_grace_period_seconds"
        elif key == "launchType":
            suggest = "launch_type"
        elif key == "loadBalancers":
            suggest = "load_balancers"
        elif key == "networkConfiguration":
            suggest = "network_configuration"
        elif key == "placementConstraints":
            suggest = "placement_constraints"
        elif key == "placementStrategies":
            suggest = "placement_strategies"
        elif key == "platformVersion":
            suggest = "platform_version"
        elif key == "propagateTags":
            suggest = "propagate_tags"
        elif key == "schedulingStrategy":
            suggest = "scheduling_strategy"
        elif key == "serviceArn":
            suggest = "service_arn"
        elif key == "serviceConnectConfiguration":
            suggest = "service_connect_configuration"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceRegistries":
            suggest = "service_registries"
        elif key == "taskDefinition":
            suggest = "task_definition"
        elif key == "volumeConfigurations":
            suggest = "volume_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEcsServicePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEcsServicePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEcsServicePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_provider_strategy: Optional[Sequence['outputs.CapacityProviderStrategyItemResponse']] = None,
                 cluster: Optional[str] = None,
                 deployment_configuration: Optional['outputs.DeploymentConfigurationResponse'] = None,
                 deployment_controller: Optional['outputs.DeploymentControllerResponse'] = None,
                 desired_count: Optional[int] = None,
                 enable_ecs_managed_tags: Optional[bool] = None,
                 enable_execute_command: Optional[bool] = None,
                 health_check_grace_period_seconds: Optional[int] = None,
                 launch_type: Optional[str] = None,
                 load_balancers: Optional[Sequence['outputs.LoadBalancerResponse']] = None,
                 name: Optional[str] = None,
                 network_configuration: Optional['outputs.NetworkConfigurationResponse'] = None,
                 placement_constraints: Optional[Sequence['outputs.PlacementConstraintResponse']] = None,
                 placement_strategies: Optional[Sequence['outputs.PlacementStrategyResponse']] = None,
                 platform_version: Optional[str] = None,
                 propagate_tags: Optional[str] = None,
                 role: Optional[str] = None,
                 scheduling_strategy: Optional[str] = None,
                 service_arn: Optional[str] = None,
                 service_connect_configuration: Optional['outputs.ServiceConnectConfigurationResponse'] = None,
                 service_name: Optional[str] = None,
                 service_registries: Optional[Sequence['outputs.ServiceRegistryResponse']] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 task_definition: Optional[str] = None,
                 volume_configurations: Optional[Sequence['outputs.ServiceVolumeConfigurationResponse']] = None):
        """
        Definition of awsEcsService
        :param Sequence['CapacityProviderStrategyItemResponse'] capacity_provider_strategy: The capacity provider strategy to use for the service. If a ``capacityProviderStrategy`` is specified, the ``launchType`` parameter must be omitted. If no ``capacityProviderStrategy`` or ``launchType`` is specified, the ``defaultCapacityProviderStrategy`` for the cluster is used. A capacity provider strategy may contain a maximum of 6 capacity providers.
        :param str cluster: The short name or full Amazon Resource Name (ARN) of the cluster that you run your service on. If you do not specify a cluster, the default cluster is assumed.
        :param 'DeploymentConfigurationResponse' deployment_configuration: Optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping and starting tasks. The ``DeploymentConfiguration`` property specifies optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping and starting tasks.
        :param 'DeploymentControllerResponse' deployment_controller: The deployment controller to use for the service. If no deployment controller is specified, the default value of ``ECS`` is used. The deployment controller to use for the service. For more information, see [Amazon ECS deployment types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param int desired_count: The number of instantiations of the specified task definition to place and keep running in your service. For new services, if a desired count is not specified, a default value of ``1`` is used. When using the ``DAEMON`` scheduling strategy, the desired count is not required. For existing services, if a desired count is not specified, it is omitted from the operation.
        :param bool enable_ecs_managed_tags: Specifies whether to turn on Amazon ECS managed tags for the tasks within the service. For more information, see [Tagging your Amazon ECS resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the *Amazon Elastic Container Service Developer Guide*. When you use Amazon ECS managed tags, you need to set the ``propagateTags`` request parameter.
        :param bool enable_execute_command: Determines whether the execute command functionality is turned on for the service. If ``true``, the execute command functionality is turned on for all containers in tasks as part of the service.
        :param int health_check_grace_period_seconds: The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. This is only used when your service is configured to use a load balancer. If your service has a load balancer defined and you don't specify a health check grace period value, the default value of ``0`` is used. If you do not use an Elastic Load Balancing, we recommend that you use the ``startPeriod`` in the task definition health check parameters. For more information, see [Health check](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_HealthCheck.html). If your service's tasks take a while to start and respond to Elastic Load Balancing health checks, you can specify a health check grace period of up to 2,147,483,647 seconds (about 69 years). During that time, the Amazon ECS service scheduler ignores health check status. This grace period can prevent the service scheduler from marking tasks as unhealthy and stopping them before they have time to come up.
        :param str launch_type: The launch type on which to run your service. For more information, see [Amazon ECS Launch Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param Sequence['LoadBalancerResponse'] load_balancers: A list of load balancer objects to associate with the service. If you specify the ``Role`` property, ``LoadBalancers`` must be specified as well. For information about the number of load balancers that you can specify per service, see [Service Load Balancing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param str name: Property name
        :param 'NetworkConfigurationResponse' network_configuration: The network configuration for the service. This parameter is required for task definitions that use the ``awsvpc`` network mode to receive their own elastic network interface, and it is not supported for other network modes. For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the *Amazon Elastic Container Service Developer Guide*. The ``NetworkConfiguration`` property specifies an object representing the network configuration for a task or service.
        :param Sequence['PlacementConstraintResponse'] placement_constraints: An array of placement constraint objects to use for tasks in your service. You can specify a maximum of 10 constraints for each task. This limit includes constraints in the task definition and those specified at runtime.
        :param Sequence['PlacementStrategyResponse'] placement_strategies: The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules for each service.
        :param str platform_version: The platform version that your tasks in the service are running on. A platform version is specified only for tasks using the Fargate launch type. If one isn't specified, the ``LATEST`` platform version is used. For more information, see [platform versions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param str propagate_tags: Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the [TagResource](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action. The default is ``NONE``.
        :param str role: The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is only permitted if you are using a load balancer with your service and your task definition doesn't use the ``awsvpc`` network mode. If you specify the ``role`` parameter, you must also specify a load balancer object with the ``loadBalancers`` parameter.  If your account has already created the Amazon ECS service-linked role, that role is used for your service unless you specify a role here. The service-linked role is required if your task definition uses the ``awsvpc`` network mode or if the service is configured to use service discovery, an external deployment controller, multiple target groups, or Elastic Inference accelerators in which case you don't specify a role here. For more information, see [Using service-linked roles for Amazon ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html) in the *Amazon Elastic Container Service Developer Guide*.  If your specified role has a path other than ``/``, then you must either specify the full role ARN (this is recommended) or prefix the role name with the path. For example, if a role with the name ``bar`` has a path of ``/foo/`` then you would specify ``/foo/bar`` as the role name. For more information, see [Friendly names and paths](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) in the *IAM User Guide*.
        :param str scheduling_strategy: The scheduling strategy to use for the service. For more information, see [Services](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html). There are two service scheduler strategies available:  +   ``REPLICA``-The replica scheduling strategy places and maintains the desired number of tasks across your cluster. By default, the service scheduler spreads tasks across Availability Zones. You can use task placement strategies and constraints to customize task placement decisions. This scheduler strategy is required if the service uses the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types.  +   ``DAEMON``-The daemon scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that you specify in your cluster. The service scheduler also evaluates the task placement constraints for running tasks and will stop tasks that don't meet the placement constraints. When you're using this strategy, you don't need to specify a desired number of tasks, a task placement strategy, or use Service Auto Scaling policies.  Tasks using the Fargate launch type or the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types don't support the ``DAEMON`` scheduling strategy.
        :param str service_arn: Property serviceArn
        :param 'ServiceConnectConfigurationResponse' service_connect_configuration: The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*. The Service Connect configuration of your Amazon ECS service. The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param str service_name: The name of your service. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. Service names must be unique within a cluster, but you can have similarly named services in multiple clusters within a Region or across multiple Regions.  The stack update fails if you change any properties that require replacement and the ``ServiceName`` is configured. This is because AWS CloudFormation creates the replacement service first, but each ``ServiceName`` must be unique in the cluster.
        :param Sequence['ServiceRegistryResponse'] service_registries: The details of the service discovery registry to associate with this service. For more information, see [Service discovery](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html).  Each service may be associated with one service registry. Multiple service registries for each service isn't supported.
        :param Sequence['TagResponse'] tags: The metadata that you apply to the service to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. When a service is deleted, the tags are deleted as well. The following basic restrictions apply to tags:  +  Maximum number of tags per resource - 50  +  For each resource, each tag key must be unique, and each tag key can have only one value.  +  Maximum key length - 128 Unicode characters in UTF-8  +  Maximum value length - 256 Unicode characters in UTF-8  +  If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.  +  Tag keys and values are case-sensitive.  +  Do not use ``aws:``, ``AWS:``, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.
        :param str task_definition: The ``family`` and ``revision`` (``family:revision``) or full ARN of the task definition to run in your service. If a ``revision`` isn't specified, the latest ``ACTIVE`` revision is used. A task definition must be specified if the service uses either the ``ECS`` or ``CODE_DEPLOY`` deployment controllers. For more information about deployment types, see [Amazon ECS deployment types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html).
        :param Sequence['ServiceVolumeConfigurationResponse'] volume_configurations: The configuration for a volume specified in the task definition as a volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume.
        """
        if capacity_provider_strategy is not None:
            pulumi.set(__self__, "capacity_provider_strategy", capacity_provider_strategy)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if deployment_configuration is not None:
            pulumi.set(__self__, "deployment_configuration", deployment_configuration)
        if deployment_controller is not None:
            pulumi.set(__self__, "deployment_controller", deployment_controller)
        if desired_count is not None:
            pulumi.set(__self__, "desired_count", desired_count)
        if enable_ecs_managed_tags is not None:
            pulumi.set(__self__, "enable_ecs_managed_tags", enable_ecs_managed_tags)
        if enable_execute_command is not None:
            pulumi.set(__self__, "enable_execute_command", enable_execute_command)
        if health_check_grace_period_seconds is not None:
            pulumi.set(__self__, "health_check_grace_period_seconds", health_check_grace_period_seconds)
        if launch_type is not None:
            pulumi.set(__self__, "launch_type", launch_type)
        if load_balancers is not None:
            pulumi.set(__self__, "load_balancers", load_balancers)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_configuration is not None:
            pulumi.set(__self__, "network_configuration", network_configuration)
        if placement_constraints is not None:
            pulumi.set(__self__, "placement_constraints", placement_constraints)
        if placement_strategies is not None:
            pulumi.set(__self__, "placement_strategies", placement_strategies)
        if platform_version is None:
            platform_version = 'LATEST'
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if scheduling_strategy is not None:
            pulumi.set(__self__, "scheduling_strategy", scheduling_strategy)
        if service_arn is not None:
            pulumi.set(__self__, "service_arn", service_arn)
        if service_connect_configuration is not None:
            pulumi.set(__self__, "service_connect_configuration", service_connect_configuration)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_registries is not None:
            pulumi.set(__self__, "service_registries", service_registries)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_definition is not None:
            pulumi.set(__self__, "task_definition", task_definition)
        if volume_configurations is not None:
            pulumi.set(__self__, "volume_configurations", volume_configurations)

    @property
    @pulumi.getter(name="capacityProviderStrategy")
    def capacity_provider_strategy(self) -> Optional[Sequence['outputs.CapacityProviderStrategyItemResponse']]:
        """
        The capacity provider strategy to use for the service. If a ``capacityProviderStrategy`` is specified, the ``launchType`` parameter must be omitted. If no ``capacityProviderStrategy`` or ``launchType`` is specified, the ``defaultCapacityProviderStrategy`` for the cluster is used. A capacity provider strategy may contain a maximum of 6 capacity providers.
        """
        return pulumi.get(self, "capacity_provider_strategy")

    @property
    @pulumi.getter
    def cluster(self) -> Optional[str]:
        """
        The short name or full Amazon Resource Name (ARN) of the cluster that you run your service on. If you do not specify a cluster, the default cluster is assumed.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="deploymentConfiguration")
    def deployment_configuration(self) -> Optional['outputs.DeploymentConfigurationResponse']:
        """
        Optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping and starting tasks. The ``DeploymentConfiguration`` property specifies optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping and starting tasks.
        """
        return pulumi.get(self, "deployment_configuration")

    @property
    @pulumi.getter(name="deploymentController")
    def deployment_controller(self) -> Optional['outputs.DeploymentControllerResponse']:
        """
        The deployment controller to use for the service. If no deployment controller is specified, the default value of ``ECS`` is used. The deployment controller to use for the service. For more information, see [Amazon ECS deployment types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "deployment_controller")

    @property
    @pulumi.getter(name="desiredCount")
    def desired_count(self) -> Optional[int]:
        """
        The number of instantiations of the specified task definition to place and keep running in your service. For new services, if a desired count is not specified, a default value of ``1`` is used. When using the ``DAEMON`` scheduling strategy, the desired count is not required. For existing services, if a desired count is not specified, it is omitted from the operation.
        """
        return pulumi.get(self, "desired_count")

    @property
    @pulumi.getter(name="enableECSManagedTags")
    def enable_ecs_managed_tags(self) -> Optional[bool]:
        """
        Specifies whether to turn on Amazon ECS managed tags for the tasks within the service. For more information, see [Tagging your Amazon ECS resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the *Amazon Elastic Container Service Developer Guide*. When you use Amazon ECS managed tags, you need to set the ``propagateTags`` request parameter.
        """
        return pulumi.get(self, "enable_ecs_managed_tags")

    @property
    @pulumi.getter(name="enableExecuteCommand")
    def enable_execute_command(self) -> Optional[bool]:
        """
        Determines whether the execute command functionality is turned on for the service. If ``true``, the execute command functionality is turned on for all containers in tasks as part of the service.
        """
        return pulumi.get(self, "enable_execute_command")

    @property
    @pulumi.getter(name="healthCheckGracePeriodSeconds")
    def health_check_grace_period_seconds(self) -> Optional[int]:
        """
        The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. This is only used when your service is configured to use a load balancer. If your service has a load balancer defined and you don't specify a health check grace period value, the default value of ``0`` is used. If you do not use an Elastic Load Balancing, we recommend that you use the ``startPeriod`` in the task definition health check parameters. For more information, see [Health check](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_HealthCheck.html). If your service's tasks take a while to start and respond to Elastic Load Balancing health checks, you can specify a health check grace period of up to 2,147,483,647 seconds (about 69 years). During that time, the Amazon ECS service scheduler ignores health check status. This grace period can prevent the service scheduler from marking tasks as unhealthy and stopping them before they have time to come up.
        """
        return pulumi.get(self, "health_check_grace_period_seconds")

    @property
    @pulumi.getter(name="launchType")
    def launch_type(self) -> Optional[str]:
        """
        The launch type on which to run your service. For more information, see [Amazon ECS Launch Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "launch_type")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[Sequence['outputs.LoadBalancerResponse']]:
        """
        A list of load balancer objects to associate with the service. If you specify the ``Role`` property, ``LoadBalancers`` must be specified as well. For information about the number of load balancers that you can specify per service, see [Service Load Balancing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "load_balancers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Property name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkConfiguration")
    def network_configuration(self) -> Optional['outputs.NetworkConfigurationResponse']:
        """
        The network configuration for the service. This parameter is required for task definitions that use the ``awsvpc`` network mode to receive their own elastic network interface, and it is not supported for other network modes. For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the *Amazon Elastic Container Service Developer Guide*. The ``NetworkConfiguration`` property specifies an object representing the network configuration for a task or service.
        """
        return pulumi.get(self, "network_configuration")

    @property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Optional[Sequence['outputs.PlacementConstraintResponse']]:
        """
        An array of placement constraint objects to use for tasks in your service. You can specify a maximum of 10 constraints for each task. This limit includes constraints in the task definition and those specified at runtime.
        """
        return pulumi.get(self, "placement_constraints")

    @property
    @pulumi.getter(name="placementStrategies")
    def placement_strategies(self) -> Optional[Sequence['outputs.PlacementStrategyResponse']]:
        """
        The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules for each service.
        """
        return pulumi.get(self, "placement_strategies")

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[str]:
        """
        The platform version that your tasks in the service are running on. A platform version is specified only for tasks using the Fargate launch type. If one isn't specified, the ``LATEST`` platform version is used. For more information, see [platform versions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "platform_version")

    @property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[str]:
        """
        Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the [TagResource](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action. The default is ``NONE``.
        """
        return pulumi.get(self, "propagate_tags")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is only permitted if you are using a load balancer with your service and your task definition doesn't use the ``awsvpc`` network mode. If you specify the ``role`` parameter, you must also specify a load balancer object with the ``loadBalancers`` parameter.  If your account has already created the Amazon ECS service-linked role, that role is used for your service unless you specify a role here. The service-linked role is required if your task definition uses the ``awsvpc`` network mode or if the service is configured to use service discovery, an external deployment controller, multiple target groups, or Elastic Inference accelerators in which case you don't specify a role here. For more information, see [Using service-linked roles for Amazon ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html) in the *Amazon Elastic Container Service Developer Guide*.  If your specified role has a path other than ``/``, then you must either specify the full role ARN (this is recommended) or prefix the role name with the path. For example, if a role with the name ``bar`` has a path of ``/foo/`` then you would specify ``/foo/bar`` as the role name. For more information, see [Friendly names and paths](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) in the *IAM User Guide*.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="schedulingStrategy")
    def scheduling_strategy(self) -> Optional[str]:
        """
        The scheduling strategy to use for the service. For more information, see [Services](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html). There are two service scheduler strategies available:  +   ``REPLICA``-The replica scheduling strategy places and maintains the desired number of tasks across your cluster. By default, the service scheduler spreads tasks across Availability Zones. You can use task placement strategies and constraints to customize task placement decisions. This scheduler strategy is required if the service uses the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types.  +   ``DAEMON``-The daemon scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that you specify in your cluster. The service scheduler also evaluates the task placement constraints for running tasks and will stop tasks that don't meet the placement constraints. When you're using this strategy, you don't need to specify a desired number of tasks, a task placement strategy, or use Service Auto Scaling policies.  Tasks using the Fargate launch type or the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types don't support the ``DAEMON`` scheduling strategy.
        """
        return pulumi.get(self, "scheduling_strategy")

    @property
    @pulumi.getter(name="serviceArn")
    def service_arn(self) -> Optional[str]:
        """
        Property serviceArn
        """
        return pulumi.get(self, "service_arn")

    @property
    @pulumi.getter(name="serviceConnectConfiguration")
    def service_connect_configuration(self) -> Optional['outputs.ServiceConnectConfigurationResponse']:
        """
        The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*. The Service Connect configuration of your Amazon ECS service. The configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "service_connect_configuration")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        The name of your service. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. Service names must be unique within a cluster, but you can have similarly named services in multiple clusters within a Region or across multiple Regions.  The stack update fails if you change any properties that require replacement and the ``ServiceName`` is configured. This is because AWS CloudFormation creates the replacement service first, but each ``ServiceName`` must be unique in the cluster.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceRegistries")
    def service_registries(self) -> Optional[Sequence['outputs.ServiceRegistryResponse']]:
        """
        The details of the service discovery registry to associate with this service. For more information, see [Service discovery](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html).  Each service may be associated with one service registry. Multiple service registries for each service isn't supported.
        """
        return pulumi.get(self, "service_registries")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The metadata that you apply to the service to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. When a service is deleted, the tags are deleted as well. The following basic restrictions apply to tags:  +  Maximum number of tags per resource - 50  +  For each resource, each tag key must be unique, and each tag key can have only one value.  +  Maximum key length - 128 Unicode characters in UTF-8  +  Maximum value length - 256 Unicode characters in UTF-8  +  If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.  +  Tag keys and values are case-sensitive.  +  Do not use ``aws:``, ``AWS:``, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="taskDefinition")
    def task_definition(self) -> Optional[str]:
        """
        The ``family`` and ``revision`` (``family:revision``) or full ARN of the task definition to run in your service. If a ``revision`` isn't specified, the latest ``ACTIVE`` revision is used. A task definition must be specified if the service uses either the ``ECS`` or ``CODE_DEPLOY`` deployment controllers. For more information about deployment types, see [Amazon ECS deployment types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html).
        """
        return pulumi.get(self, "task_definition")

    @property
    @pulumi.getter(name="volumeConfigurations")
    def volume_configurations(self) -> Optional[Sequence['outputs.ServiceVolumeConfigurationResponse']]:
        """
        The configuration for a volume specified in the task definition as a volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume.
        """
        return pulumi.get(self, "volume_configurations")


@pulumi.output_type
class AwsEcsTaskDefinitionPropertiesResponse(dict):
    """
    Definition of awsEcsTaskDefinition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerDefinitions":
            suggest = "container_definitions"
        elif key == "ephemeralStorage":
            suggest = "ephemeral_storage"
        elif key == "executionRoleArn":
            suggest = "execution_role_arn"
        elif key == "inferenceAccelerators":
            suggest = "inference_accelerators"
        elif key == "ipcMode":
            suggest = "ipc_mode"
        elif key == "networkMode":
            suggest = "network_mode"
        elif key == "pidMode":
            suggest = "pid_mode"
        elif key == "placementConstraints":
            suggest = "placement_constraints"
        elif key == "proxyConfiguration":
            suggest = "proxy_configuration"
        elif key == "requiresCompatibilities":
            suggest = "requires_compatibilities"
        elif key == "runtimePlatform":
            suggest = "runtime_platform"
        elif key == "taskDefinitionArn":
            suggest = "task_definition_arn"
        elif key == "taskRoleArn":
            suggest = "task_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEcsTaskDefinitionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEcsTaskDefinitionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEcsTaskDefinitionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_definitions: Optional[Sequence['outputs.ContainerDefinitionResponse']] = None,
                 cpu: Optional[str] = None,
                 ephemeral_storage: Optional['outputs.EphemeralStorageResponse'] = None,
                 execution_role_arn: Optional[str] = None,
                 family: Optional[str] = None,
                 inference_accelerators: Optional[Sequence['outputs.InferenceAcceleratorResponse']] = None,
                 ipc_mode: Optional[str] = None,
                 memory: Optional[str] = None,
                 network_mode: Optional[str] = None,
                 pid_mode: Optional[str] = None,
                 placement_constraints: Optional[Sequence['outputs.TaskDefinitionPlacementConstraintResponse']] = None,
                 proxy_configuration: Optional['outputs.ProxyConfigurationResponse'] = None,
                 requires_compatibilities: Optional[Sequence[str]] = None,
                 runtime_platform: Optional['outputs.RuntimePlatformResponse'] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 task_definition_arn: Optional[str] = None,
                 task_role_arn: Optional[str] = None,
                 volumes: Optional[Sequence['outputs.VolumeResponse']] = None):
        """
        Definition of awsEcsTaskDefinition
        :param Sequence['ContainerDefinitionResponse'] container_definitions: A list of container definitions in JSON format that describe the different containers that make up your task. For more information about container definition parameters and defaults, see [Amazon ECS Task Definitions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param str cpu: The number of ``cpu`` units used by the task. If you use the EC2 launch type, this field is optional. Any value can be used. If you use the Fargate launch type, this field is required. You must use one of the following values. The value that you choose determines your range of valid values for the ``memory`` parameter. The CPU units cannot be less than 1 vCPU when you use Windows containers on Fargate.  +  256 (.25 vCPU) - Available ``memory`` values: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB)  +  512 (.5 vCPU) - Available ``memory`` values: 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB)  +  1024 (1 vCPU) - Available ``memory`` values: 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB)  +  2048 (2 vCPU) - Available ``memory`` values: 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB)  +  4096 (4 vCPU) - Available ``memory`` values: 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB)  +  8192 (8 vCPU) - Available ``memory`` values: 16 GB and 60 GB in 4 GB increments This option requires Linux platform ``1.4.0`` or later.  +  16384 (16vCPU) - Available ``memory`` values: 32GB and 120 GB in 8 GB increments This option requires Linux platform ``1.4.0`` or later.
        :param 'EphemeralStorageResponse' ephemeral_storage: The ephemeral storage settings to use for tasks run with the task definition. The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on FARGATElong. For more information, see [Using data volumes in tasks](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_data_volumes.html) in the *Amazon ECS Developer Guide;*.  For tasks using the Fargate launch type, the task requires the following platforms:  +  Linux platform version ``1.4.0`` or later.  +  Windows platform version ``1.0.0`` or later.
        :param str execution_role_arn: The Amazon Resource Name (ARN) of the task execution role that grants the Amazon ECS container agent permission to make AWS API calls on your behalf. The task execution IAM role is required depending on the requirements of your task. For more information, see [Amazon ECS task execution IAM role](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_execution_IAM_role.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param str family: The name of a family that this task definition is registered to. Up to 255 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed. A family groups multiple versions of a task definition. Amazon ECS gives the first task definition that you registered to a family a revision number of 1. Amazon ECS gives sequential revision numbers to each task definition that you add.  To use revision numbers when you update a task definition, specify this property. If you don't specify a value, CFNlong generates a new task definition each time that you update it.
        :param Sequence['InferenceAcceleratorResponse'] inference_accelerators: The Elastic Inference accelerators to use for the containers in the task.
        :param str ipc_mode: The IPC resource namespace to use for the containers in the task. The valid values are ``host``, ``task``, or ``none``. If ``host`` is specified, then all containers within the tasks that specified the ``host`` IPC mode on the same container instance share the same IPC resources with the host Amazon EC2 instance. If ``task`` is specified, all containers within the specified task share the same IPC resources. If ``none`` is specified, then IPC resources within the containers of a task are private and not shared with other containers in a task or on the container instance. If no value is specified, then the IPC resource namespace sharing depends on the Docker daemon setting on the container instance. For more information, see [IPC settings](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#ipc-settings---ipc) in the *Docker run reference*. If the ``host`` IPC mode is used, be aware that there is a heightened risk of undesired IPC namespace expose. For more information, see [Docker security](https://docs.aws.amazon.com/https://docs.docker.com/engine/security/security/). If you are setting namespaced kernel parameters using ``systemControls`` for the containers in the task, the following will apply to your IPC resource namespace. For more information, see [System Controls](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html) in the *Amazon Elastic Container Service Developer Guide*.  +  For tasks that use the ``host`` IPC mode, IPC namespace related ``systemControls`` are not supported.  +  For tasks that use the ``task`` IPC mode, IPC namespace related ``systemControls`` will apply to all containers within a task.    This parameter is not supported for Windows containers or tasks run on FARGATElong.
        :param str memory: The amount (in MiB) of memory used by the task. If your tasks runs on Amazon EC2 instances, you must specify either a task-level memory value or a container-level memory value. This field is optional and any value can be used. If a task-level memory value is specified, the container-level memory value is optional. For more information regarding container-level memory and memory reservation, see [ContainerDefinition](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html). If your tasks runs on FARGATElong, this field is required. You must use one of the following values. The value you choose determines your range of valid values for the ``cpu`` parameter.  +  512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available ``cpu`` values: 256 (.25 vCPU)  +  1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available ``cpu`` values: 512 (.5 vCPU)  +  2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available ``cpu`` values: 1024 (1 vCPU)  +  Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available ``cpu`` values: 2048 (2 vCPU)  +  Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available ``cpu`` values: 4096 (4 vCPU)  +  Between 16 GB and 60 GB in 4 GB increments - Available ``cpu`` values: 8192 (8 vCPU) This option requires Linux platform ``1.4.0`` or later.  +  Between 32GB and 120 GB in 8 GB increments - Available ``cpu`` values: 16384 (16 vCPU) This option requires Linux platform ``1.4.0`` or later.
        :param str network_mode: The Docker networking mode to use for the containers in the task. The valid values are ``none``, ``bridge``, ``awsvpc``, and ``host``. If no network mode is specified, the default is ``bridge``. For Amazon ECS tasks on Fargate, the ``awsvpc`` network mode is required. For Amazon ECS tasks on Amazon EC2 Linux instances, any network mode can be used. For Amazon ECS tasks on Amazon EC2 Windows instances, ``<default>`` or ``awsvpc`` can be used. If the network mode is set to ``none``, you cannot specify port mappings in your container definitions, and the tasks containers do not have external connectivity. The ``host`` and ``awsvpc`` network modes offer the highest networking performance for containers because they use the EC2 network stack instead of the virtualized network stack provided by the ``bridge`` mode. With the ``host`` and ``awsvpc`` network modes, exposed container ports are mapped directly to the corresponding host port (for the ``host`` network mode) or the attached elastic network interface port (for the ``awsvpc`` network mode), so you cannot take advantage of dynamic host port mappings.   When using the ``host`` network mode, you should not run containers using the root user (UID 0). It is considered best practice to use a non-root user.  If the network mode is ``awsvpc``, the task is allocated an elastic network interface, and you must specify a NetworkConfiguration value when you create a service or run a task with the task definition. For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the *Amazon Elastic Container Service Developer Guide*. If the network mode is ``host``, you cannot run multiple instantiations of the same task on a single container instance when port mappings are used. For more information, see [Network settings](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#network-settings) in the *Docker run reference*.
        :param str pid_mode: The process namespace to use for the containers in the task. The valid values are ``host`` or ``task``. On Fargate for Linux containers, the only valid value is ``task``. For example, monitoring sidecars might need ``pidMode`` to access information about other containers running in the same task. If ``host`` is specified, all containers within the tasks that specified the ``host`` PID mode on the same container instance share the same process namespace with the host Amazon EC2 instance. If ``task`` is specified, all containers within the specified task share the same process namespace. If no value is specified, the default is a private namespace for each container. For more information, see [PID settings](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#pid-settings---pid) in the *Docker run reference*. If the ``host`` PID mode is used, there's a heightened risk of undesired process namespace exposure. For more information, see [Docker security](https://docs.aws.amazon.com/https://docs.docker.com/engine/security/security/).  This parameter is not supported for Windows containers.   This parameter is only supported for tasks that are hosted on FARGATElong if the tasks are using platform version ``1.4.0`` or later (Linux). This isn't supported for Windows containers on Fargate.
        :param Sequence['TaskDefinitionPlacementConstraintResponse'] placement_constraints: An array of placement constraint objects to use for tasks.  This parameter isn't supported for tasks run on FARGATElong.
        :param 'ProxyConfigurationResponse' proxy_configuration: The configuration details for the App Mesh proxy. Your Amazon ECS container instances require at least version 1.26.0 of the container agent and at least version 1.26.0-1 of the ``ecs-init`` package to use a proxy configuration. If your container instances are launched from the Amazon ECS optimized AMI version ``20190301`` or later, they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html) in the *Amazon Elastic Container Service Developer Guide*. The configuration details for the App Mesh proxy. For tasks that use the EC2 launch type, the container instances require at least version 1.26.0 of the container agent and at least version 1.26.0-1 of the ``ecs-init`` package to use a proxy configuration. If your container instances are launched from the Amazon ECS optimized AMI version ``20190301`` or later, then they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html)
        :param Sequence[str] requires_compatibilities: The task launch types the task definition was validated against. The valid values are ``EC2``, ``FARGATE``, and ``EXTERNAL``. For more information, see [Amazon ECS launch types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param 'RuntimePlatformResponse' runtime_platform: The operating system that your tasks definitions run on. A platform family is specified only for tasks using the Fargate launch type.  When you specify a task definition in a service, this value must match the ``runtimePlatform`` value of the service. Information about the platform for the Amazon ECS service or task. For more information about ``RuntimePlatform``, see [RuntimePlatform](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#runtime-platform) in the *Amazon Elastic Container Service Developer Guide*.
        :param Sequence['TagResponse'] tags: The metadata that you apply to the task definition to help you categorize and organize them. Each tag consists of a key and an optional value. You define both of them. The following basic restrictions apply to tags:  +  Maximum number of tags per resource - 50  +  For each resource, each tag key must be unique, and each tag key can have only one value.  +  Maximum key length - 128 Unicode characters in UTF-8  +  Maximum value length - 256 Unicode characters in UTF-8  +  If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.  +  Tag keys and values are case-sensitive.  +  Do not use ``aws:``, ``AWS:``, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.
        :param str task_definition_arn: Property taskDefinitionArn
        :param str task_role_arn: The short name or full Amazon Resource Name (ARN) of the IAMlong role that grants containers in the task permission to call AWS APIs on your behalf. For more information, see [Amazon ECS Task Role](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html) in the *Amazon Elastic Container Service Developer Guide*. IAM roles for tasks on Windows require that the ``-EnableTaskIAMRole`` option is set when you launch the Amazon ECS-optimized Windows AMI. Your containers must also run some configuration code to use the feature. For more information, see [Windows IAM roles for tasks](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/windows_task_IAM_roles.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param Sequence['VolumeResponse'] volumes: The list of data volume definitions for the task. For more information, see [Using data volumes in tasks](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_data_volumes.html) in the *Amazon Elastic Container Service Developer Guide*.  The ``host`` and ``sourcePath`` parameters aren't supported for tasks run on FARGATElong.
        """
        if container_definitions is not None:
            pulumi.set(__self__, "container_definitions", container_definitions)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if ephemeral_storage is not None:
            pulumi.set(__self__, "ephemeral_storage", ephemeral_storage)
        if execution_role_arn is not None:
            pulumi.set(__self__, "execution_role_arn", execution_role_arn)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if inference_accelerators is not None:
            pulumi.set(__self__, "inference_accelerators", inference_accelerators)
        if ipc_mode is not None:
            pulumi.set(__self__, "ipc_mode", ipc_mode)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if pid_mode is not None:
            pulumi.set(__self__, "pid_mode", pid_mode)
        if placement_constraints is not None:
            pulumi.set(__self__, "placement_constraints", placement_constraints)
        if proxy_configuration is not None:
            pulumi.set(__self__, "proxy_configuration", proxy_configuration)
        if requires_compatibilities is not None:
            pulumi.set(__self__, "requires_compatibilities", requires_compatibilities)
        if runtime_platform is not None:
            pulumi.set(__self__, "runtime_platform", runtime_platform)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_definition_arn is not None:
            pulumi.set(__self__, "task_definition_arn", task_definition_arn)
        if task_role_arn is not None:
            pulumi.set(__self__, "task_role_arn", task_role_arn)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="containerDefinitions")
    def container_definitions(self) -> Optional[Sequence['outputs.ContainerDefinitionResponse']]:
        """
        A list of container definitions in JSON format that describe the different containers that make up your task. For more information about container definition parameters and defaults, see [Amazon ECS Task Definitions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "container_definitions")

    @property
    @pulumi.getter
    def cpu(self) -> Optional[str]:
        """
        The number of ``cpu`` units used by the task. If you use the EC2 launch type, this field is optional. Any value can be used. If you use the Fargate launch type, this field is required. You must use one of the following values. The value that you choose determines your range of valid values for the ``memory`` parameter. The CPU units cannot be less than 1 vCPU when you use Windows containers on Fargate.  +  256 (.25 vCPU) - Available ``memory`` values: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB)  +  512 (.5 vCPU) - Available ``memory`` values: 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB)  +  1024 (1 vCPU) - Available ``memory`` values: 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB)  +  2048 (2 vCPU) - Available ``memory`` values: 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB)  +  4096 (4 vCPU) - Available ``memory`` values: 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB)  +  8192 (8 vCPU) - Available ``memory`` values: 16 GB and 60 GB in 4 GB increments This option requires Linux platform ``1.4.0`` or later.  +  16384 (16vCPU) - Available ``memory`` values: 32GB and 120 GB in 8 GB increments This option requires Linux platform ``1.4.0`` or later.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="ephemeralStorage")
    def ephemeral_storage(self) -> Optional['outputs.EphemeralStorageResponse']:
        """
        The ephemeral storage settings to use for tasks run with the task definition. The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on FARGATElong. For more information, see [Using data volumes in tasks](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_data_volumes.html) in the *Amazon ECS Developer Guide;*.  For tasks using the Fargate launch type, the task requires the following platforms:  +  Linux platform version ``1.4.0`` or later.  +  Windows platform version ``1.0.0`` or later.
        """
        return pulumi.get(self, "ephemeral_storage")

    @property
    @pulumi.getter(name="executionRoleArn")
    def execution_role_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the task execution role that grants the Amazon ECS container agent permission to make AWS API calls on your behalf. The task execution IAM role is required depending on the requirements of your task. For more information, see [Amazon ECS task execution IAM role](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_execution_IAM_role.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "execution_role_arn")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        The name of a family that this task definition is registered to. Up to 255 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed. A family groups multiple versions of a task definition. Amazon ECS gives the first task definition that you registered to a family a revision number of 1. Amazon ECS gives sequential revision numbers to each task definition that you add.  To use revision numbers when you update a task definition, specify this property. If you don't specify a value, CFNlong generates a new task definition each time that you update it.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter(name="inferenceAccelerators")
    def inference_accelerators(self) -> Optional[Sequence['outputs.InferenceAcceleratorResponse']]:
        """
        The Elastic Inference accelerators to use for the containers in the task.
        """
        return pulumi.get(self, "inference_accelerators")

    @property
    @pulumi.getter(name="ipcMode")
    def ipc_mode(self) -> Optional[str]:
        """
        The IPC resource namespace to use for the containers in the task. The valid values are ``host``, ``task``, or ``none``. If ``host`` is specified, then all containers within the tasks that specified the ``host`` IPC mode on the same container instance share the same IPC resources with the host Amazon EC2 instance. If ``task`` is specified, all containers within the specified task share the same IPC resources. If ``none`` is specified, then IPC resources within the containers of a task are private and not shared with other containers in a task or on the container instance. If no value is specified, then the IPC resource namespace sharing depends on the Docker daemon setting on the container instance. For more information, see [IPC settings](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#ipc-settings---ipc) in the *Docker run reference*. If the ``host`` IPC mode is used, be aware that there is a heightened risk of undesired IPC namespace expose. For more information, see [Docker security](https://docs.aws.amazon.com/https://docs.docker.com/engine/security/security/). If you are setting namespaced kernel parameters using ``systemControls`` for the containers in the task, the following will apply to your IPC resource namespace. For more information, see [System Controls](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html) in the *Amazon Elastic Container Service Developer Guide*.  +  For tasks that use the ``host`` IPC mode, IPC namespace related ``systemControls`` are not supported.  +  For tasks that use the ``task`` IPC mode, IPC namespace related ``systemControls`` will apply to all containers within a task.    This parameter is not supported for Windows containers or tasks run on FARGATElong.
        """
        return pulumi.get(self, "ipc_mode")

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        """
        The amount (in MiB) of memory used by the task. If your tasks runs on Amazon EC2 instances, you must specify either a task-level memory value or a container-level memory value. This field is optional and any value can be used. If a task-level memory value is specified, the container-level memory value is optional. For more information regarding container-level memory and memory reservation, see [ContainerDefinition](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerDefinition.html). If your tasks runs on FARGATElong, this field is required. You must use one of the following values. The value you choose determines your range of valid values for the ``cpu`` parameter.  +  512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available ``cpu`` values: 256 (.25 vCPU)  +  1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available ``cpu`` values: 512 (.5 vCPU)  +  2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available ``cpu`` values: 1024 (1 vCPU)  +  Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available ``cpu`` values: 2048 (2 vCPU)  +  Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available ``cpu`` values: 4096 (4 vCPU)  +  Between 16 GB and 60 GB in 4 GB increments - Available ``cpu`` values: 8192 (8 vCPU) This option requires Linux platform ``1.4.0`` or later.  +  Between 32GB and 120 GB in 8 GB increments - Available ``cpu`` values: 16384 (16 vCPU) This option requires Linux platform ``1.4.0`` or later.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[str]:
        """
        The Docker networking mode to use for the containers in the task. The valid values are ``none``, ``bridge``, ``awsvpc``, and ``host``. If no network mode is specified, the default is ``bridge``. For Amazon ECS tasks on Fargate, the ``awsvpc`` network mode is required. For Amazon ECS tasks on Amazon EC2 Linux instances, any network mode can be used. For Amazon ECS tasks on Amazon EC2 Windows instances, ``<default>`` or ``awsvpc`` can be used. If the network mode is set to ``none``, you cannot specify port mappings in your container definitions, and the tasks containers do not have external connectivity. The ``host`` and ``awsvpc`` network modes offer the highest networking performance for containers because they use the EC2 network stack instead of the virtualized network stack provided by the ``bridge`` mode. With the ``host`` and ``awsvpc`` network modes, exposed container ports are mapped directly to the corresponding host port (for the ``host`` network mode) or the attached elastic network interface port (for the ``awsvpc`` network mode), so you cannot take advantage of dynamic host port mappings.   When using the ``host`` network mode, you should not run containers using the root user (UID 0). It is considered best practice to use a non-root user.  If the network mode is ``awsvpc``, the task is allocated an elastic network interface, and you must specify a NetworkConfiguration value when you create a service or run a task with the task definition. For more information, see [Task Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the *Amazon Elastic Container Service Developer Guide*. If the network mode is ``host``, you cannot run multiple instantiations of the same task on a single container instance when port mappings are used. For more information, see [Network settings](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#network-settings) in the *Docker run reference*.
        """
        return pulumi.get(self, "network_mode")

    @property
    @pulumi.getter(name="pidMode")
    def pid_mode(self) -> Optional[str]:
        """
        The process namespace to use for the containers in the task. The valid values are ``host`` or ``task``. On Fargate for Linux containers, the only valid value is ``task``. For example, monitoring sidecars might need ``pidMode`` to access information about other containers running in the same task. If ``host`` is specified, all containers within the tasks that specified the ``host`` PID mode on the same container instance share the same process namespace with the host Amazon EC2 instance. If ``task`` is specified, all containers within the specified task share the same process namespace. If no value is specified, the default is a private namespace for each container. For more information, see [PID settings](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#pid-settings---pid) in the *Docker run reference*. If the ``host`` PID mode is used, there's a heightened risk of undesired process namespace exposure. For more information, see [Docker security](https://docs.aws.amazon.com/https://docs.docker.com/engine/security/security/).  This parameter is not supported for Windows containers.   This parameter is only supported for tasks that are hosted on FARGATElong if the tasks are using platform version ``1.4.0`` or later (Linux). This isn't supported for Windows containers on Fargate.
        """
        return pulumi.get(self, "pid_mode")

    @property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Optional[Sequence['outputs.TaskDefinitionPlacementConstraintResponse']]:
        """
        An array of placement constraint objects to use for tasks.  This parameter isn't supported for tasks run on FARGATElong.
        """
        return pulumi.get(self, "placement_constraints")

    @property
    @pulumi.getter(name="proxyConfiguration")
    def proxy_configuration(self) -> Optional['outputs.ProxyConfigurationResponse']:
        """
        The configuration details for the App Mesh proxy. Your Amazon ECS container instances require at least version 1.26.0 of the container agent and at least version 1.26.0-1 of the ``ecs-init`` package to use a proxy configuration. If your container instances are launched from the Amazon ECS optimized AMI version ``20190301`` or later, they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html) in the *Amazon Elastic Container Service Developer Guide*. The configuration details for the App Mesh proxy. For tasks that use the EC2 launch type, the container instances require at least version 1.26.0 of the container agent and at least version 1.26.0-1 of the ``ecs-init`` package to use a proxy configuration. If your container instances are launched from the Amazon ECS optimized AMI version ``20190301`` or later, then they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html)
        """
        return pulumi.get(self, "proxy_configuration")

    @property
    @pulumi.getter(name="requiresCompatibilities")
    def requires_compatibilities(self) -> Optional[Sequence[str]]:
        """
        The task launch types the task definition was validated against. The valid values are ``EC2``, ``FARGATE``, and ``EXTERNAL``. For more information, see [Amazon ECS launch types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "requires_compatibilities")

    @property
    @pulumi.getter(name="runtimePlatform")
    def runtime_platform(self) -> Optional['outputs.RuntimePlatformResponse']:
        """
        The operating system that your tasks definitions run on. A platform family is specified only for tasks using the Fargate launch type.  When you specify a task definition in a service, this value must match the ``runtimePlatform`` value of the service. Information about the platform for the Amazon ECS service or task. For more information about ``RuntimePlatform``, see [RuntimePlatform](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#runtime-platform) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "runtime_platform")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The metadata that you apply to the task definition to help you categorize and organize them. Each tag consists of a key and an optional value. You define both of them. The following basic restrictions apply to tags:  +  Maximum number of tags per resource - 50  +  For each resource, each tag key must be unique, and each tag key can have only one value.  +  Maximum key length - 128 Unicode characters in UTF-8  +  Maximum value length - 256 Unicode characters in UTF-8  +  If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.  +  Tag keys and values are case-sensitive.  +  Do not use ``aws:``, ``AWS:``, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved for AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags per resource limit.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="taskDefinitionArn")
    def task_definition_arn(self) -> Optional[str]:
        """
        Property taskDefinitionArn
        """
        return pulumi.get(self, "task_definition_arn")

    @property
    @pulumi.getter(name="taskRoleArn")
    def task_role_arn(self) -> Optional[str]:
        """
        The short name or full Amazon Resource Name (ARN) of the IAMlong role that grants containers in the task permission to call AWS APIs on your behalf. For more information, see [Amazon ECS Task Role](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html) in the *Amazon Elastic Container Service Developer Guide*. IAM roles for tasks on Windows require that the ``-EnableTaskIAMRole`` option is set when you launch the Amazon ECS-optimized Windows AMI. Your containers must also run some configuration code to use the feature. For more information, see [Windows IAM roles for tasks](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/windows_task_IAM_roles.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "task_role_arn")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.VolumeResponse']]:
        """
        The list of data volume definitions for the task. For more information, see [Using data volumes in tasks](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_data_volumes.html) in the *Amazon Elastic Container Service Developer Guide*.  The ``host`` and ``sourcePath`` parameters aren't supported for tasks run on FARGATElong.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class AwsEfsFileSystemPropertiesResponse(dict):
    """
    Definition of awsEfsFileSystem
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneName":
            suggest = "availability_zone_name"
        elif key == "backupPolicy":
            suggest = "backup_policy"
        elif key == "bypassPolicyLockoutSafetyCheck":
            suggest = "bypass_policy_lockout_safety_check"
        elif key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "fileSystemPolicy":
            suggest = "file_system_policy"
        elif key == "fileSystemProtection":
            suggest = "file_system_protection"
        elif key == "fileSystemTags":
            suggest = "file_system_tags"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "lifecyclePolicies":
            suggest = "lifecycle_policies"
        elif key == "performanceMode":
            suggest = "performance_mode"
        elif key == "provisionedThroughputInMibps":
            suggest = "provisioned_throughput_in_mibps"
        elif key == "replicationConfiguration":
            suggest = "replication_configuration"
        elif key == "throughputMode":
            suggest = "throughput_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEfsFileSystemPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEfsFileSystemPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEfsFileSystemPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 availability_zone_name: Optional[str] = None,
                 backup_policy: Optional['outputs.BackupPolicyResponse'] = None,
                 bypass_policy_lockout_safety_check: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 file_system_id: Optional[str] = None,
                 file_system_policy: Optional[Any] = None,
                 file_system_protection: Optional['outputs.FileSystemProtectionResponse'] = None,
                 file_system_tags: Optional[Sequence['outputs.ElasticFileSystemTagResponse']] = None,
                 kms_key_id: Optional[str] = None,
                 lifecycle_policies: Optional[Sequence['outputs.LifecyclePolicyResponse']] = None,
                 performance_mode: Optional[str] = None,
                 provisioned_throughput_in_mibps: Optional[int] = None,
                 replication_configuration: Optional['outputs.ReplicationConfigurationResponse'] = None,
                 throughput_mode: Optional[str] = None):
        """
        Definition of awsEfsFileSystem
        :param str arn: Property arn
        :param str availability_zone_name: For One Zone file systems, specify the AWS Availability Zone in which to create the file system. Use the format ``us-east-1a`` to specify the Availability Zone. For more information about One Zone file systems, see [EFS file system types](https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html#file-system-type) in the *Amazon EFS User Guide*.  One Zone file systems are not available in all Availability Zones in AWS-Regions where Amazon EFS is available.
        :param 'BackupPolicyResponse' backup_policy: Use the ``BackupPolicy`` to turn automatic backups on or off for the file system. The backup policy turns automatic backups for the file system on or off.
        :param bool bypass_policy_lockout_safety_check: (Optional) A boolean that specifies whether or not to bypass the ``FileSystemPolicy`` lockout safety check. The lockout safety check determines whether the policy in the request will lock out, or prevent, the IAM principal that is making the request from making future ``PutFileSystemPolicy`` requests on this file system. Set ``BypassPolicyLockoutSafetyCheck`` to ``True`` only when you intend to prevent the IAM principal that is making the request from making subsequent ``PutFileSystemPolicy`` requests on this file system. The default value is ``False``.
        :param bool encrypted: A Boolean value that, if true, creates an encrypted file system. When creating an encrypted file system, you have the option of specifying a KmsKeyId for an existing kms-key-long. If you don't specify a kms-key, then the default kms-key for EFS, ``/aws/elasticfilesystem``, is used to protect the encrypted file system.
        :param str file_system_id: Property fileSystemId
        :param Any file_system_policy: The ``FileSystemPolicy`` for the EFS file system. A file system policy is an IAM resource policy used to control NFS access to an EFS file system. For more information, see [Using to control NFS access to Amazon EFS](https://docs.aws.amazon.com/efs/latest/ug/iam-access-control-nfs-efs.html) in the *Amazon EFS User Guide*.
        :param 'FileSystemProtectionResponse' file_system_protection: Describes the protection on the file system. Describes the protection on the file system.
        :param Sequence['ElasticFileSystemTagResponse'] file_system_tags: Use to create one or more tags associated with the file system. Each tag is a user-defined key-value pair. Name your file system on creation by including a ``'Key':'Name','Value':'{value}'`` key-value pair. Each key must be unique. For more information, see [Tagging resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the *General Reference Guide*.
        :param str kms_key_id: The ID of the kms-key-long to be used to protect the encrypted file system. This parameter is only required if you want to use a nondefault kms-key. If this parameter is not specified, the default kms-key for EFS is used. This ID can be in one of the following formats:  +  Key ID - A unique identifier of the key, for example ``1234abcd-12ab-34cd-56ef-1234567890ab``.  +  ARN - An Amazon Resource Name (ARN) for the key, for example ``arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab``.  +  Key alias - A previously created display name for a key, for example ``alias/projectKey1``.  +  Key alias ARN - An ARN for a key alias, for example ``arn:aws:kms:us-west-2:444455556666:alias/projectKey1``.   If ``KmsKeyId`` is specified, the ``Encrypted`` parameter must be set to true.
        :param Sequence['LifecyclePolicyResponse'] lifecycle_policies: An array of ``LifecyclePolicy`` objects that define the file system's ``LifecycleConfiguration`` object. A ``LifecycleConfiguration`` object informs Lifecycle management of the following:  +  When to move files in the file system from primary storage to IA storage.  + When to move files in the file system from primary storage or IA storage to Archive storage. +  When to move files that are in IA or Archive storage to primary storage.    EFS requires that each ``LifecyclePolicy`` object have only a single transition. This means that in a request body, ``LifecyclePolicies`` needs to be structured as an array of ``LifecyclePolicy`` objects, one object for each transition, ``TransitionToIA``, ``TransitionToArchive`` ``TransitionToPrimaryStorageClass``. See the example requests in the following section for more information.
        :param str performance_mode: The Performance mode of the file system. We recommend ``generalPurpose`` performance mode for all file systems. File systems using the ``maxIO`` performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can't be changed after the file system has been created. The ``maxIO`` mode is not supported on One Zone file systems.  Due to the higher per-operation latencies with Max I/O, we recommend using General Purpose performance mode for all file systems.  Default is ``generalPurpose``.
        :param int provisioned_throughput_in_mibps: The throughput, measured in mebibytes per second (MiBps), that you want to provision for a file system that you're creating. Required if ``ThroughputMode`` is set to ``provisioned``. Valid values are 1-3414 MiBps, with the upper limit depending on Region. To increase this limit, contact SUP. For more information, see [Amazon EFS quotas that you can increase](https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits) in the *Amazon EFS User Guide*.
        :param 'ReplicationConfigurationResponse' replication_configuration: Describes the replication configuration for a specific file system. Describes the replication configuration for a specific file system.
        :param str throughput_mode: Specifies the throughput mode for the file system. The mode can be ``bursting``, ``provisioned``, or ``elastic``. If you set ``ThroughputMode`` to ``provisioned``, you must also set a value for ``ProvisionedThroughputInMibps``. After you create the file system, you can decrease your file system's Provisioned throughput or change between the throughput modes, with certain time restrictions. For more information, see [Specifying throughput with provisioned mode](https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput) in the *Amazon EFS User Guide*.  Default is ``bursting``.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if availability_zone_name is not None:
            pulumi.set(__self__, "availability_zone_name", availability_zone_name)
        if backup_policy is not None:
            pulumi.set(__self__, "backup_policy", backup_policy)
        if bypass_policy_lockout_safety_check is not None:
            pulumi.set(__self__, "bypass_policy_lockout_safety_check", bypass_policy_lockout_safety_check)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if file_system_id is not None:
            pulumi.set(__self__, "file_system_id", file_system_id)
        if file_system_policy is not None:
            pulumi.set(__self__, "file_system_policy", file_system_policy)
        if file_system_protection is not None:
            pulumi.set(__self__, "file_system_protection", file_system_protection)
        if file_system_tags is not None:
            pulumi.set(__self__, "file_system_tags", file_system_tags)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if lifecycle_policies is not None:
            pulumi.set(__self__, "lifecycle_policies", lifecycle_policies)
        if performance_mode is not None:
            pulumi.set(__self__, "performance_mode", performance_mode)
        if provisioned_throughput_in_mibps is not None:
            pulumi.set(__self__, "provisioned_throughput_in_mibps", provisioned_throughput_in_mibps)
        if replication_configuration is not None:
            pulumi.set(__self__, "replication_configuration", replication_configuration)
        if throughput_mode is not None:
            pulumi.set(__self__, "throughput_mode", throughput_mode)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="availabilityZoneName")
    def availability_zone_name(self) -> Optional[str]:
        """
        For One Zone file systems, specify the AWS Availability Zone in which to create the file system. Use the format ``us-east-1a`` to specify the Availability Zone. For more information about One Zone file systems, see [EFS file system types](https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html#file-system-type) in the *Amazon EFS User Guide*.  One Zone file systems are not available in all Availability Zones in AWS-Regions where Amazon EFS is available.
        """
        return pulumi.get(self, "availability_zone_name")

    @property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional['outputs.BackupPolicyResponse']:
        """
        Use the ``BackupPolicy`` to turn automatic backups on or off for the file system. The backup policy turns automatic backups for the file system on or off.
        """
        return pulumi.get(self, "backup_policy")

    @property
    @pulumi.getter(name="bypassPolicyLockoutSafetyCheck")
    def bypass_policy_lockout_safety_check(self) -> Optional[bool]:
        """
        (Optional) A boolean that specifies whether or not to bypass the ``FileSystemPolicy`` lockout safety check. The lockout safety check determines whether the policy in the request will lock out, or prevent, the IAM principal that is making the request from making future ``PutFileSystemPolicy`` requests on this file system. Set ``BypassPolicyLockoutSafetyCheck`` to ``True`` only when you intend to prevent the IAM principal that is making the request from making subsequent ``PutFileSystemPolicy`` requests on this file system. The default value is ``False``.
        """
        return pulumi.get(self, "bypass_policy_lockout_safety_check")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        A Boolean value that, if true, creates an encrypted file system. When creating an encrypted file system, you have the option of specifying a KmsKeyId for an existing kms-key-long. If you don't specify a kms-key, then the default kms-key for EFS, ``/aws/elasticfilesystem``, is used to protect the encrypted file system.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> Optional[str]:
        """
        Property fileSystemId
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter(name="fileSystemPolicy")
    def file_system_policy(self) -> Optional[Any]:
        """
        The ``FileSystemPolicy`` for the EFS file system. A file system policy is an IAM resource policy used to control NFS access to an EFS file system. For more information, see [Using to control NFS access to Amazon EFS](https://docs.aws.amazon.com/efs/latest/ug/iam-access-control-nfs-efs.html) in the *Amazon EFS User Guide*.
        """
        return pulumi.get(self, "file_system_policy")

    @property
    @pulumi.getter(name="fileSystemProtection")
    def file_system_protection(self) -> Optional['outputs.FileSystemProtectionResponse']:
        """
        Describes the protection on the file system. Describes the protection on the file system.
        """
        return pulumi.get(self, "file_system_protection")

    @property
    @pulumi.getter(name="fileSystemTags")
    def file_system_tags(self) -> Optional[Sequence['outputs.ElasticFileSystemTagResponse']]:
        """
        Use to create one or more tags associated with the file system. Each tag is a user-defined key-value pair. Name your file system on creation by including a ``'Key':'Name','Value':'{value}'`` key-value pair. Each key must be unique. For more information, see [Tagging resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the *General Reference Guide*.
        """
        return pulumi.get(self, "file_system_tags")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ID of the kms-key-long to be used to protect the encrypted file system. This parameter is only required if you want to use a nondefault kms-key. If this parameter is not specified, the default kms-key for EFS is used. This ID can be in one of the following formats:  +  Key ID - A unique identifier of the key, for example ``1234abcd-12ab-34cd-56ef-1234567890ab``.  +  ARN - An Amazon Resource Name (ARN) for the key, for example ``arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab``.  +  Key alias - A previously created display name for a key, for example ``alias/projectKey1``.  +  Key alias ARN - An ARN for a key alias, for example ``arn:aws:kms:us-west-2:444455556666:alias/projectKey1``.   If ``KmsKeyId`` is specified, the ``Encrypted`` parameter must be set to true.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="lifecyclePolicies")
    def lifecycle_policies(self) -> Optional[Sequence['outputs.LifecyclePolicyResponse']]:
        """
        An array of ``LifecyclePolicy`` objects that define the file system's ``LifecycleConfiguration`` object. A ``LifecycleConfiguration`` object informs Lifecycle management of the following:  +  When to move files in the file system from primary storage to IA storage.  + When to move files in the file system from primary storage or IA storage to Archive storage. +  When to move files that are in IA or Archive storage to primary storage.    EFS requires that each ``LifecyclePolicy`` object have only a single transition. This means that in a request body, ``LifecyclePolicies`` needs to be structured as an array of ``LifecyclePolicy`` objects, one object for each transition, ``TransitionToIA``, ``TransitionToArchive`` ``TransitionToPrimaryStorageClass``. See the example requests in the following section for more information.
        """
        return pulumi.get(self, "lifecycle_policies")

    @property
    @pulumi.getter(name="performanceMode")
    def performance_mode(self) -> Optional[str]:
        """
        The Performance mode of the file system. We recommend ``generalPurpose`` performance mode for all file systems. File systems using the ``maxIO`` performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can't be changed after the file system has been created. The ``maxIO`` mode is not supported on One Zone file systems.  Due to the higher per-operation latencies with Max I/O, we recommend using General Purpose performance mode for all file systems.  Default is ``generalPurpose``.
        """
        return pulumi.get(self, "performance_mode")

    @property
    @pulumi.getter(name="provisionedThroughputInMibps")
    def provisioned_throughput_in_mibps(self) -> Optional[int]:
        """
        The throughput, measured in mebibytes per second (MiBps), that you want to provision for a file system that you're creating. Required if ``ThroughputMode`` is set to ``provisioned``. Valid values are 1-3414 MiBps, with the upper limit depending on Region. To increase this limit, contact SUP. For more information, see [Amazon EFS quotas that you can increase](https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits) in the *Amazon EFS User Guide*.
        """
        return pulumi.get(self, "provisioned_throughput_in_mibps")

    @property
    @pulumi.getter(name="replicationConfiguration")
    def replication_configuration(self) -> Optional['outputs.ReplicationConfigurationResponse']:
        """
        Describes the replication configuration for a specific file system. Describes the replication configuration for a specific file system.
        """
        return pulumi.get(self, "replication_configuration")

    @property
    @pulumi.getter(name="throughputMode")
    def throughput_mode(self) -> Optional[str]:
        """
        Specifies the throughput mode for the file system. The mode can be ``bursting``, ``provisioned``, or ``elastic``. If you set ``ThroughputMode`` to ``provisioned``, you must also set a value for ``ProvisionedThroughputInMibps``. After you create the file system, you can decrease your file system's Provisioned throughput or change between the throughput modes, with certain time restrictions. For more information, see [Specifying throughput with provisioned mode](https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput) in the *Amazon EFS User Guide*.  Default is ``bursting``.
        """
        return pulumi.get(self, "throughput_mode")


@pulumi.output_type
class AwsEfsMountTargetPropertiesResponse(dict):
    """
    Definition of awsEfsMountTarget
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEfsMountTargetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEfsMountTargetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEfsMountTargetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_id: Optional[str] = None,
                 id: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None):
        """
        Definition of awsEfsMountTarget
        :param str file_system_id: The ID of the file system for which to create the mount target.
        :param str id: Property id
        :param str ip_address: Valid IPv4 address within the address range of the specified subnet.
        :param Sequence[str] security_groups: Up to five VPC security group IDs, of the form ``sg-xxxxxxxx``. These must be for the same VPC as subnet specified.
        :param str subnet_id: The ID of the subnet to add the mount target in. For One Zone file systems, use the subnet that is associated with the file system's Availability Zone.
        """
        if file_system_id is not None:
            pulumi.set(__self__, "file_system_id", file_system_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> Optional[str]:
        """
        The ID of the file system for which to create the mount target.
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        Valid IPv4 address within the address range of the specified subnet.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        Up to five VPC security group IDs, of the form ``sg-xxxxxxxx``. These must be for the same VPC as subnet specified.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet to add the mount target in. For One Zone file systems, use the subnet that is associated with the file system's Availability Zone.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AwsEksClusterPropertiesResponse(dict):
    """
    Definition of awsEksCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfig":
            suggest = "access_config"
        elif key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "clientRequestToken":
            suggest = "client_request_token"
        elif key == "connectorConfig":
            suggest = "connector_config"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "encryptionConfig":
            suggest = "encryption_config"
        elif key == "kubernetesNetworkConfig":
            suggest = "kubernetes_network_config"
        elif key == "outpostConfig":
            suggest = "outpost_config"
        elif key == "platformVersion":
            suggest = "platform_version"
        elif key == "resourcesVpcConfig":
            suggest = "resources_vpc_config"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEksClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEksClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEksClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_config: Optional['outputs.AccessConfigResponseResponse'] = None,
                 arn: Optional[str] = None,
                 certificate_authority: Optional['outputs.CertificateResponse'] = None,
                 client_request_token: Optional[str] = None,
                 connector_config: Optional['outputs.ConnectorConfigResponseResponse'] = None,
                 created_at: Optional[str] = None,
                 encryption_config: Optional[Sequence['outputs.EncryptionConfigResponse']] = None,
                 endpoint: Optional[str] = None,
                 health: Optional['outputs.ClusterHealthResponse'] = None,
                 id: Optional[str] = None,
                 identity: Optional['outputs.IdentityResponse'] = None,
                 kubernetes_network_config: Optional['outputs.KubernetesNetworkConfigResponseResponse'] = None,
                 logging: Optional['outputs.LoggingResponse'] = None,
                 name: Optional[str] = None,
                 outpost_config: Optional['outputs.OutpostConfigResponseResponse'] = None,
                 platform_version: Optional[str] = None,
                 resources_vpc_config: Optional['outputs.VpcConfigResponseResponse'] = None,
                 role_arn: Optional[str] = None,
                 status: Optional['outputs.ClusterStatusEnumValueResponse'] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 version: Optional[str] = None):
        """
        Definition of awsEksCluster
        :param 'AccessConfigResponseResponse' access_config: <p>The access configuration for the cluster.</p>
        :param str arn: <p>The Amazon Resource Name (ARN) of the cluster.</p>
        :param 'CertificateResponse' certificate_authority: <p>The <code>certificate-authority-data</code> for your cluster.</p>
        :param str client_request_token: <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        :param 'ConnectorConfigResponseResponse' connector_config: <p>The configuration used to connect to a cluster for registration.</p>
        :param str created_at: <p>The Unix epoch timestamp at object creation.</p>
        :param Sequence['EncryptionConfigResponse'] encryption_config: <p>The encryption configuration for the cluster.</p>
        :param str endpoint: <p>The endpoint for your Kubernetes API server.</p>
        :param 'ClusterHealthResponse' health: <p>An object representing the health of your local Amazon EKS cluster on an Amazon Web Services Outpost. This object isn't available for clusters on the Amazon Web Services cloud.</p>
        :param str id: <p>The ID of your local Amazon EKS cluster on an Amazon Web Services Outpost. This property isn't available for an Amazon EKS cluster on the Amazon Web Services cloud.</p>
        :param 'IdentityResponse' identity: <p>The identity provider information for the cluster.</p>
        :param 'KubernetesNetworkConfigResponseResponse' kubernetes_network_config: <p>The Kubernetes network configuration for the cluster.</p>
        :param 'LoggingResponse' logging: <p>The logging configuration for your cluster.</p>
        :param str name: <p>The name of your cluster.</p>
        :param 'OutpostConfigResponseResponse' outpost_config: <p>An object representing the configuration of your local Amazon EKS cluster on an Amazon Web Services Outpost. This object isn't available for clusters on the Amazon Web Services cloud.</p>
        :param str platform_version: <p>The platform version of your Amazon EKS cluster. For more information about clusters deployed on the Amazon Web Services Cloud, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/platform-versions.html'>Platform versions</a> in the <i> <i>Amazon EKS User Guide</i> </i>. For more information about local clusters deployed on an Outpost, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-platform-versions.html'>Amazon EKS local cluster platform versions</a> in the <i> <i>Amazon EKS User Guide</i> </i>.</p>
        :param 'VpcConfigResponseResponse' resources_vpc_config: <p>The VPC configuration used by the cluster control plane. Amazon EKS VPC resources have specific requirements to work properly with Kubernetes. For more information, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html'>Cluster VPC considerations</a> and <a href='https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html'>Cluster security group considerations</a> in the <i>Amazon EKS User Guide</i>.</p>
        :param str role_arn: <p>The Amazon Resource Name (ARN) of the IAM role that provides permissions for the Kubernetes control plane to make calls to Amazon Web Services API operations on your behalf.</p>
        :param 'ClusterStatusEnumValueResponse' status: <p>The current status of the cluster.</p>
        :param Mapping[str, str] tags: <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
        :param str version: <p>The Kubernetes server version for the cluster.</p>
        """
        if access_config is not None:
            pulumi.set(__self__, "access_config", access_config)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)
        if client_request_token is not None:
            pulumi.set(__self__, "client_request_token", client_request_token)
        if connector_config is not None:
            pulumi.set(__self__, "connector_config", connector_config)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if encryption_config is not None:
            pulumi.set(__self__, "encryption_config", encryption_config)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if kubernetes_network_config is not None:
            pulumi.set(__self__, "kubernetes_network_config", kubernetes_network_config)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if outpost_config is not None:
            pulumi.set(__self__, "outpost_config", outpost_config)
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if resources_vpc_config is not None:
            pulumi.set(__self__, "resources_vpc_config", resources_vpc_config)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="accessConfig")
    def access_config(self) -> Optional['outputs.AccessConfigResponseResponse']:
        """
        <p>The access configuration for the cluster.</p>
        """
        return pulumi.get(self, "access_config")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the cluster.</p>
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional['outputs.CertificateResponse']:
        """
        <p>The <code>certificate-authority-data</code> for your cluster.</p>
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="clientRequestToken")
    def client_request_token(self) -> Optional[str]:
        """
        <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        """
        return pulumi.get(self, "client_request_token")

    @property
    @pulumi.getter(name="connectorConfig")
    def connector_config(self) -> Optional['outputs.ConnectorConfigResponseResponse']:
        """
        <p>The configuration used to connect to a cluster for registration.</p>
        """
        return pulumi.get(self, "connector_config")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        <p>The Unix epoch timestamp at object creation.</p>
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> Optional[Sequence['outputs.EncryptionConfigResponse']]:
        """
        <p>The encryption configuration for the cluster.</p>
        """
        return pulumi.get(self, "encryption_config")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        <p>The endpoint for your Kubernetes API server.</p>
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def health(self) -> Optional['outputs.ClusterHealthResponse']:
        """
        <p>An object representing the health of your local Amazon EKS cluster on an Amazon Web Services Outpost. This object isn't available for clusters on the Amazon Web Services cloud.</p>
        """
        return pulumi.get(self, "health")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        <p>The ID of your local Amazon EKS cluster on an Amazon Web Services Outpost. This property isn't available for an Amazon EKS cluster on the Amazon Web Services cloud.</p>
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.IdentityResponse']:
        """
        <p>The identity provider information for the cluster.</p>
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="kubernetesNetworkConfig")
    def kubernetes_network_config(self) -> Optional['outputs.KubernetesNetworkConfigResponseResponse']:
        """
        <p>The Kubernetes network configuration for the cluster.</p>
        """
        return pulumi.get(self, "kubernetes_network_config")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.LoggingResponse']:
        """
        <p>The logging configuration for your cluster.</p>
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of your cluster.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="outpostConfig")
    def outpost_config(self) -> Optional['outputs.OutpostConfigResponseResponse']:
        """
        <p>An object representing the configuration of your local Amazon EKS cluster on an Amazon Web Services Outpost. This object isn't available for clusters on the Amazon Web Services cloud.</p>
        """
        return pulumi.get(self, "outpost_config")

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[str]:
        """
        <p>The platform version of your Amazon EKS cluster. For more information about clusters deployed on the Amazon Web Services Cloud, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/platform-versions.html'>Platform versions</a> in the <i> <i>Amazon EKS User Guide</i> </i>. For more information about local clusters deployed on an Outpost, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-platform-versions.html'>Amazon EKS local cluster platform versions</a> in the <i> <i>Amazon EKS User Guide</i> </i>.</p>
        """
        return pulumi.get(self, "platform_version")

    @property
    @pulumi.getter(name="resourcesVpcConfig")
    def resources_vpc_config(self) -> Optional['outputs.VpcConfigResponseResponse']:
        """
        <p>The VPC configuration used by the cluster control plane. Amazon EKS VPC resources have specific requirements to work properly with Kubernetes. For more information, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html'>Cluster VPC considerations</a> and <a href='https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html'>Cluster security group considerations</a> in the <i>Amazon EKS User Guide</i>.</p>
        """
        return pulumi.get(self, "resources_vpc_config")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the IAM role that provides permissions for the Kubernetes control plane to make calls to Amazon Web Services API operations on your behalf.</p>
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.ClusterStatusEnumValueResponse']:
        """
        <p>The current status of the cluster.</p>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        <p>The Kubernetes server version for the cluster.</p>
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AwsEksNodegroupPropertiesResponse(dict):
    """
    Definition of awsEksNodegroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amiType":
            suggest = "ami_type"
        elif key == "capacityType":
            suggest = "capacity_type"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "forceUpdateEnabled":
            suggest = "force_update_enabled"
        elif key == "instanceTypes":
            suggest = "instance_types"
        elif key == "launchTemplate":
            suggest = "launch_template"
        elif key == "nodeRole":
            suggest = "node_role"
        elif key == "nodegroupName":
            suggest = "nodegroup_name"
        elif key == "releaseVersion":
            suggest = "release_version"
        elif key == "remoteAccess":
            suggest = "remote_access"
        elif key == "scalingConfig":
            suggest = "scaling_config"
        elif key == "updateConfig":
            suggest = "update_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEksNodegroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEksNodegroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEksNodegroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ami_type: Optional[str] = None,
                 arn: Optional[str] = None,
                 capacity_type: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 disk_size: Optional[int] = None,
                 force_update_enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 instance_types: Optional[Sequence[str]] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 launch_template: Optional['outputs.LaunchTemplateSpecificationResponse'] = None,
                 node_role: Optional[str] = None,
                 nodegroup_name: Optional[str] = None,
                 release_version: Optional[str] = None,
                 remote_access: Optional['outputs.RemoteAccessResponse'] = None,
                 scaling_config: Optional['outputs.ScalingConfigResponse'] = None,
                 subnets: Optional[Sequence[str]] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.TaintResponse']] = None,
                 update_config: Optional['outputs.UpdateConfigResponse'] = None,
                 version: Optional[str] = None):
        """
        Definition of awsEksNodegroup
        :param str ami_type: The AMI type for your node group.
        :param str arn: Property arn
        :param str capacity_type: The capacity type of your managed node group.
        :param str cluster_name: Name of the cluster to create the node group in.
        :param int disk_size: The root device disk size (in GiB) for your node group instances.
        :param bool force_update_enabled: Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue.
        :param str id: Property id
        :param Sequence[str] instance_types: Specify the instance types for a node group.
        :param Mapping[str, str] labels: The Kubernetes labels to be applied to the nodes in the node group when they are created.
        :param 'LaunchTemplateSpecificationResponse' launch_template: An object representing a node group's launch template specification. An object representing a launch template specification for AWS EKS Nodegroup.
        :param str node_role: The Amazon Resource Name (ARN) of the IAM role to associate with your node group.
        :param str nodegroup_name: The unique name to give your node group.
        :param str release_version: The AMI version of the Amazon EKS-optimized AMI to use with your node group.
        :param 'RemoteAccessResponse' remote_access: The remote access (SSH) configuration to use with your node group. An object representing a remote access configuration specification for AWS EKS Nodegroup.
        :param 'ScalingConfigResponse' scaling_config: The scaling configuration details for the Auto Scaling group that is created for your node group. An object representing a auto scaling group specification for AWS EKS Nodegroup.
        :param Sequence[str] subnets: The subnets to use for the Auto Scaling group that is created for your node group.
        :param Mapping[str, str] tags: The metadata, as key-value pairs, to apply to the node group to assist with categorization and organization. Follows same schema as Labels for consistency.
        :param Sequence['TaintResponse'] taints: The Kubernetes taints to be applied to the nodes in the node group when they are created.
        :param 'UpdateConfigResponse' update_config: The node group update configuration. The node group update configuration.
        :param str version: The Kubernetes version to use for your managed nodes.
        """
        if ami_type is not None:
            pulumi.set(__self__, "ami_type", ami_type)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if capacity_type is not None:
            pulumi.set(__self__, "capacity_type", capacity_type)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if force_update_enabled is not None:
            pulumi.set(__self__, "force_update_enabled", force_update_enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_types is not None:
            pulumi.set(__self__, "instance_types", instance_types)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if launch_template is not None:
            pulumi.set(__self__, "launch_template", launch_template)
        if node_role is not None:
            pulumi.set(__self__, "node_role", node_role)
        if nodegroup_name is not None:
            pulumi.set(__self__, "nodegroup_name", nodegroup_name)
        if release_version is not None:
            pulumi.set(__self__, "release_version", release_version)
        if remote_access is not None:
            pulumi.set(__self__, "remote_access", remote_access)
        if scaling_config is not None:
            pulumi.set(__self__, "scaling_config", scaling_config)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if update_config is not None:
            pulumi.set(__self__, "update_config", update_config)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="amiType")
    def ami_type(self) -> Optional[str]:
        """
        The AMI type for your node group.
        """
        return pulumi.get(self, "ami_type")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="capacityType")
    def capacity_type(self) -> Optional[str]:
        """
        The capacity type of your managed node group.
        """
        return pulumi.get(self, "capacity_type")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        Name of the cluster to create the node group in.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        The root device disk size (in GiB) for your node group instances.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="forceUpdateEnabled")
    def force_update_enabled(self) -> Optional[bool]:
        """
        Force the update if the existing node group's pods are unable to be drained due to a pod disruption budget issue.
        """
        return pulumi.get(self, "force_update_enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Optional[Sequence[str]]:
        """
        Specify the instance types for a node group.
        """
        return pulumi.get(self, "instance_types")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The Kubernetes labels to be applied to the nodes in the node group when they are created.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="launchTemplate")
    def launch_template(self) -> Optional['outputs.LaunchTemplateSpecificationResponse']:
        """
        An object representing a node group's launch template specification. An object representing a launch template specification for AWS EKS Nodegroup.
        """
        return pulumi.get(self, "launch_template")

    @property
    @pulumi.getter(name="nodeRole")
    def node_role(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the IAM role to associate with your node group.
        """
        return pulumi.get(self, "node_role")

    @property
    @pulumi.getter(name="nodegroupName")
    def nodegroup_name(self) -> Optional[str]:
        """
        The unique name to give your node group.
        """
        return pulumi.get(self, "nodegroup_name")

    @property
    @pulumi.getter(name="releaseVersion")
    def release_version(self) -> Optional[str]:
        """
        The AMI version of the Amazon EKS-optimized AMI to use with your node group.
        """
        return pulumi.get(self, "release_version")

    @property
    @pulumi.getter(name="remoteAccess")
    def remote_access(self) -> Optional['outputs.RemoteAccessResponse']:
        """
        The remote access (SSH) configuration to use with your node group. An object representing a remote access configuration specification for AWS EKS Nodegroup.
        """
        return pulumi.get(self, "remote_access")

    @property
    @pulumi.getter(name="scalingConfig")
    def scaling_config(self) -> Optional['outputs.ScalingConfigResponse']:
        """
        The scaling configuration details for the Auto Scaling group that is created for your node group. An object representing a auto scaling group specification for AWS EKS Nodegroup.
        """
        return pulumi.get(self, "scaling_config")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        """
        The subnets to use for the Auto Scaling group that is created for your node group.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        The metadata, as key-value pairs, to apply to the node group to assist with categorization and organization. Follows same schema as Labels for consistency.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.TaintResponse']]:
        """
        The Kubernetes taints to be applied to the nodes in the node group when they are created.
        """
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="updateConfig")
    def update_config(self) -> Optional['outputs.UpdateConfigResponse']:
        """
        The node group update configuration. The node group update configuration.
        """
        return pulumi.get(self, "update_config")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Kubernetes version to use for your managed nodes.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AwsElasticBeanstalkApplicationPropertiesResponse(dict):
    """
    Definition of awsElasticBeanstalkApplication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "resourceLifecycleConfig":
            suggest = "resource_lifecycle_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticBeanstalkApplicationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticBeanstalkApplicationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticBeanstalkApplicationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: Optional[str] = None,
                 description: Optional[str] = None,
                 resource_lifecycle_config: Optional['outputs.ApplicationResourceLifecycleConfigResponse'] = None):
        """
        Definition of awsElasticBeanstalkApplication
        :param str application_name: A name for the Elastic Beanstalk application. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the application name.
        :param str description: Your description of the application.
        :param 'ApplicationResourceLifecycleConfigResponse' resource_lifecycle_config: Specifies an application resource lifecycle configuration to prevent your application from accumulating too many versions.
        """
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resource_lifecycle_config is not None:
            pulumi.set(__self__, "resource_lifecycle_config", resource_lifecycle_config)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[str]:
        """
        A name for the Elastic Beanstalk application. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the application name.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Your description of the application.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="resourceLifecycleConfig")
    def resource_lifecycle_config(self) -> Optional['outputs.ApplicationResourceLifecycleConfigResponse']:
        """
        Specifies an application resource lifecycle configuration to prevent your application from accumulating too many versions.
        """
        return pulumi.get(self, "resource_lifecycle_config")


@pulumi.output_type
class AwsElasticBeanstalkConfigurationTemplatePropertiesResponse(dict):
    """
    Definition of awsElasticBeanstalkConfigurationTemplate
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "optionSettings":
            suggest = "option_settings"
        elif key == "platformArn":
            suggest = "platform_arn"
        elif key == "solutionStackName":
            suggest = "solution_stack_name"
        elif key == "sourceConfiguration":
            suggest = "source_configuration"
        elif key == "templateName":
            suggest = "template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticBeanstalkConfigurationTemplatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticBeanstalkConfigurationTemplatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticBeanstalkConfigurationTemplatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: Optional[str] = None,
                 description: Optional[str] = None,
                 environment_id: Optional[str] = None,
                 option_settings: Optional[Sequence['outputs.ConfigurationOptionSettingResponse']] = None,
                 platform_arn: Optional[str] = None,
                 solution_stack_name: Optional[str] = None,
                 source_configuration: Optional['outputs.SourceConfigurationResponse'] = None,
                 template_name: Optional[str] = None):
        """
        Definition of awsElasticBeanstalkConfigurationTemplate
        :param str application_name: The name of the Elastic Beanstalk application to associate with this configuration template.
        :param str description: An optional description for this configuration.
        :param str environment_id: The ID of an environment whose settings you want to use to create the configuration template. You must specify EnvironmentId if you don't specify PlatformArn, SolutionStackName, or SourceConfiguration.
        :param Sequence['ConfigurationOptionSettingResponse'] option_settings: Option values for the Elastic Beanstalk configuration, such as the instance type. If specified, these values override the values obtained from the solution stack or the source configuration template. For a complete list of Elastic Beanstalk configuration options, see [Option Values](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/command-options.html) in the AWS Elastic Beanstalk Developer Guide.
        :param str platform_arn: The Amazon Resource Name (ARN) of the custom platform. For more information, see [Custom Platforms](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/custom-platforms.html) in the AWS Elastic Beanstalk Developer Guide.
        :param str solution_stack_name: The name of an Elastic Beanstalk solution stack (platform version) that this configuration uses. For example, 64bit Amazon Linux 2013.09 running Tomcat 7 Java 7. A solution stack specifies the operating system, runtime, and application server for a configuration template. It also determines the set of configuration options as well as the possible and default values. For more information, see [Supported Platforms](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/concepts.platforms.html) in the AWS Elastic Beanstalk Developer Guide. You must specify SolutionStackName if you don't specify PlatformArn, EnvironmentId, or SourceConfiguration. Use the ListAvailableSolutionStacks API to obtain a list of available solution stacks.
        :param 'SourceConfigurationResponse' source_configuration: An Elastic Beanstalk configuration template to base this one on. If specified, Elastic Beanstalk uses the configuration values from the specified configuration template to create a new configuration.Values specified in OptionSettings override any values obtained from the SourceConfiguration.You must specify SourceConfiguration if you don't specify PlatformArn, EnvironmentId, or SolutionStackName.Constraint: If both solution stack name and source configuration are specified, the solution stack of the source configuration template must match the specified solution stack name.
        :param str template_name: The name of the configuration template
        """
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if option_settings is not None:
            pulumi.set(__self__, "option_settings", option_settings)
        if platform_arn is not None:
            pulumi.set(__self__, "platform_arn", platform_arn)
        if solution_stack_name is not None:
            pulumi.set(__self__, "solution_stack_name", solution_stack_name)
        if source_configuration is not None:
            pulumi.set(__self__, "source_configuration", source_configuration)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[str]:
        """
        The name of the Elastic Beanstalk application to associate with this configuration template.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        An optional description for this configuration.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        """
        The ID of an environment whose settings you want to use to create the configuration template. You must specify EnvironmentId if you don't specify PlatformArn, SolutionStackName, or SourceConfiguration.
        """
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="optionSettings")
    def option_settings(self) -> Optional[Sequence['outputs.ConfigurationOptionSettingResponse']]:
        """
        Option values for the Elastic Beanstalk configuration, such as the instance type. If specified, these values override the values obtained from the solution stack or the source configuration template. For a complete list of Elastic Beanstalk configuration options, see [Option Values](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/command-options.html) in the AWS Elastic Beanstalk Developer Guide.
        """
        return pulumi.get(self, "option_settings")

    @property
    @pulumi.getter(name="platformArn")
    def platform_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the custom platform. For more information, see [Custom Platforms](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/custom-platforms.html) in the AWS Elastic Beanstalk Developer Guide.
        """
        return pulumi.get(self, "platform_arn")

    @property
    @pulumi.getter(name="solutionStackName")
    def solution_stack_name(self) -> Optional[str]:
        """
        The name of an Elastic Beanstalk solution stack (platform version) that this configuration uses. For example, 64bit Amazon Linux 2013.09 running Tomcat 7 Java 7. A solution stack specifies the operating system, runtime, and application server for a configuration template. It also determines the set of configuration options as well as the possible and default values. For more information, see [Supported Platforms](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/concepts.platforms.html) in the AWS Elastic Beanstalk Developer Guide. You must specify SolutionStackName if you don't specify PlatformArn, EnvironmentId, or SourceConfiguration. Use the ListAvailableSolutionStacks API to obtain a list of available solution stacks.
        """
        return pulumi.get(self, "solution_stack_name")

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Optional['outputs.SourceConfigurationResponse']:
        """
        An Elastic Beanstalk configuration template to base this one on. If specified, Elastic Beanstalk uses the configuration values from the specified configuration template to create a new configuration.Values specified in OptionSettings override any values obtained from the SourceConfiguration.You must specify SourceConfiguration if you don't specify PlatformArn, EnvironmentId, or SolutionStackName.Constraint: If both solution stack name and source configuration are specified, the solution stack of the source configuration template must match the specified solution stack name.
        """
        return pulumi.get(self, "source_configuration")

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[str]:
        """
        The name of the configuration template
        """
        return pulumi.get(self, "template_name")


@pulumi.output_type
class AwsElasticBeanstalkEnvironmentPropertiesResponse(dict):
    """
    Definition of awsElasticBeanstalkEnvironment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "cnamePrefix":
            suggest = "cname_prefix"
        elif key == "endpointURL":
            suggest = "endpoint_url"
        elif key == "environmentName":
            suggest = "environment_name"
        elif key == "operationsRole":
            suggest = "operations_role"
        elif key == "optionSettings":
            suggest = "option_settings"
        elif key == "platformArn":
            suggest = "platform_arn"
        elif key == "solutionStackName":
            suggest = "solution_stack_name"
        elif key == "templateName":
            suggest = "template_name"
        elif key == "versionLabel":
            suggest = "version_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticBeanstalkEnvironmentPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticBeanstalkEnvironmentPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticBeanstalkEnvironmentPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: Optional[str] = None,
                 cname_prefix: Optional[str] = None,
                 description: Optional[str] = None,
                 endpoint_url: Optional[str] = None,
                 environment_name: Optional[str] = None,
                 operations_role: Optional[str] = None,
                 option_settings: Optional[Sequence['outputs.OptionSettingResponse']] = None,
                 platform_arn: Optional[str] = None,
                 solution_stack_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 template_name: Optional[str] = None,
                 tier: Optional['outputs.TierResponse'] = None,
                 version_label: Optional[str] = None):
        """
        Definition of awsElasticBeanstalkEnvironment
        :param str application_name: The name of the application that is associated with this environment.
        :param str cname_prefix: If specified, the environment attempts to use this value as the prefix for the CNAME in your Elastic Beanstalk environment URL. If not specified, the CNAME is generated automatically by appending a random alphanumeric string to the environment name.
        :param str description: Your description for this environment.
        :param str endpoint_url: Property endpointURL
        :param str environment_name: A unique name for the environment.
        :param str operations_role: The Amazon Resource Name (ARN) of an existing IAM role to be used as the environment's operations role.
        :param Sequence['OptionSettingResponse'] option_settings: Key-value pairs defining configuration options for this environment, such as the instance type.
        :param str platform_arn: The Amazon Resource Name (ARN) of the custom platform to use with the environment.
        :param str solution_stack_name: The name of an Elastic Beanstalk solution stack (platform version) to use with the environment.
        :param Sequence['TagResponse'] tags: Specifies the tags applied to resources in the environment.
        :param str template_name: The name of the Elastic Beanstalk configuration template to use with the environment.
        :param 'TierResponse' tier: Specifies the tier to use in creating this environment. The environment tier that you choose determines whether Elastic Beanstalk provisions resources to support a web application that handles HTTP(S) requests or a web application that handles background-processing tasks.
        :param str version_label: The name of the application version to deploy.
        """
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if cname_prefix is not None:
            pulumi.set(__self__, "cname_prefix", cname_prefix)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if environment_name is not None:
            pulumi.set(__self__, "environment_name", environment_name)
        if operations_role is not None:
            pulumi.set(__self__, "operations_role", operations_role)
        if option_settings is not None:
            pulumi.set(__self__, "option_settings", option_settings)
        if platform_arn is not None:
            pulumi.set(__self__, "platform_arn", platform_arn)
        if solution_stack_name is not None:
            pulumi.set(__self__, "solution_stack_name", solution_stack_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if version_label is not None:
            pulumi.set(__self__, "version_label", version_label)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[str]:
        """
        The name of the application that is associated with this environment.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="cnamePrefix")
    def cname_prefix(self) -> Optional[str]:
        """
        If specified, the environment attempts to use this value as the prefix for the CNAME in your Elastic Beanstalk environment URL. If not specified, the CNAME is generated automatically by appending a random alphanumeric string to the environment name.
        """
        return pulumi.get(self, "cname_prefix")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Your description for this environment.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endpointURL")
    def endpoint_url(self) -> Optional[str]:
        """
        Property endpointURL
        """
        return pulumi.get(self, "endpoint_url")

    @property
    @pulumi.getter(name="environmentName")
    def environment_name(self) -> Optional[str]:
        """
        A unique name for the environment.
        """
        return pulumi.get(self, "environment_name")

    @property
    @pulumi.getter(name="operationsRole")
    def operations_role(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of an existing IAM role to be used as the environment's operations role.
        """
        return pulumi.get(self, "operations_role")

    @property
    @pulumi.getter(name="optionSettings")
    def option_settings(self) -> Optional[Sequence['outputs.OptionSettingResponse']]:
        """
        Key-value pairs defining configuration options for this environment, such as the instance type.
        """
        return pulumi.get(self, "option_settings")

    @property
    @pulumi.getter(name="platformArn")
    def platform_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the custom platform to use with the environment.
        """
        return pulumi.get(self, "platform_arn")

    @property
    @pulumi.getter(name="solutionStackName")
    def solution_stack_name(self) -> Optional[str]:
        """
        The name of an Elastic Beanstalk solution stack (platform version) to use with the environment.
        """
        return pulumi.get(self, "solution_stack_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Specifies the tags applied to resources in the environment.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[str]:
        """
        The name of the Elastic Beanstalk configuration template to use with the environment.
        """
        return pulumi.get(self, "template_name")

    @property
    @pulumi.getter
    def tier(self) -> Optional['outputs.TierResponse']:
        """
        Specifies the tier to use in creating this environment. The environment tier that you choose determines whether Elastic Beanstalk provisions resources to support a web application that handles HTTP(S) requests or a web application that handles background-processing tasks.
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter(name="versionLabel")
    def version_label(self) -> Optional[str]:
        """
        The name of the application version to deploy.
        """
        return pulumi.get(self, "version_label")


@pulumi.output_type
class AwsElasticLoadBalancingV2ListenerPropertiesResponse(dict):
    """
    Definition of awsElasticLoadBalancingV2Listener
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alpnPolicy":
            suggest = "alpn_policy"
        elif key == "defaultActions":
            suggest = "default_actions"
        elif key == "listenerArn":
            suggest = "listener_arn"
        elif key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "mutualAuthentication":
            suggest = "mutual_authentication"
        elif key == "sslPolicy":
            suggest = "ssl_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticLoadBalancingV2ListenerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticLoadBalancingV2ListenerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticLoadBalancingV2ListenerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alpn_policy: Optional[Sequence[str]] = None,
                 certificates: Optional[Sequence['outputs.CertificateResponse']] = None,
                 default_actions: Optional[Sequence['outputs.ActionResponse']] = None,
                 listener_arn: Optional[str] = None,
                 load_balancer_arn: Optional[str] = None,
                 mutual_authentication: Optional['outputs.MutualAuthenticationResponse'] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 ssl_policy: Optional[str] = None):
        """
        Definition of awsElasticLoadBalancingV2Listener
        :param Sequence[str] alpn_policy: [TLS listener] The name of the Application-Layer Protocol Negotiation (ALPN) policy.
        :param Sequence['CertificateResponse'] certificates: The default SSL server certificate for a secure listener. You must provide exactly one certificate if the listener protocol is HTTPS or TLS. To create a certificate list for a secure listener, use [AWS::ElasticLoadBalancingV2::ListenerCertificate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listenercertificate.html).
        :param Sequence['ActionResponse'] default_actions: The actions for the default rule. You cannot define a condition for a default rule. To create additional rules for an Application Load Balancer, use [AWS::ElasticLoadBalancingV2::ListenerRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listenerrule.html).
        :param str listener_arn: Property listenerArn
        :param str load_balancer_arn: The Amazon Resource Name (ARN) of the load balancer.
        :param 'MutualAuthenticationResponse' mutual_authentication: The mutual authentication configuration information. Specifies the configuration information for mutual authentication.
        :param int port: The port on which the load balancer is listening. You cannot specify a port for a Gateway Load Balancer.
        :param str protocol: The protocol for connections from clients to the load balancer. For Application Load Balancers, the supported protocols are HTTP and HTTPS. For Network Load Balancers, the supported protocols are TCP, TLS, UDP, and TCP_UDP. You cant specify the UDP or TCP_UDP protocol if dual-stack mode is enabled. You cannot specify a protocol for a Gateway Load Balancer.
        :param str ssl_policy: [HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are supported. Updating the security policy can result in interruptions if the load balancer is handling a high volume of traffic. For more information, see [Security policies](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies) in the *Application Load Balancers Guide* and [Security policies](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies) in the *Network Load Balancers Guide*.
        """
        if alpn_policy is not None:
            pulumi.set(__self__, "alpn_policy", alpn_policy)
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)
        if default_actions is not None:
            pulumi.set(__self__, "default_actions", default_actions)
        if listener_arn is not None:
            pulumi.set(__self__, "listener_arn", listener_arn)
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if mutual_authentication is not None:
            pulumi.set(__self__, "mutual_authentication", mutual_authentication)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if ssl_policy is not None:
            pulumi.set(__self__, "ssl_policy", ssl_policy)

    @property
    @pulumi.getter(name="alpnPolicy")
    def alpn_policy(self) -> Optional[Sequence[str]]:
        """
        [TLS listener] The name of the Application-Layer Protocol Negotiation (ALPN) policy.
        """
        return pulumi.get(self, "alpn_policy")

    @property
    @pulumi.getter
    def certificates(self) -> Optional[Sequence['outputs.CertificateResponse']]:
        """
        The default SSL server certificate for a secure listener. You must provide exactly one certificate if the listener protocol is HTTPS or TLS. To create a certificate list for a secure listener, use [AWS::ElasticLoadBalancingV2::ListenerCertificate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listenercertificate.html).
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="defaultActions")
    def default_actions(self) -> Optional[Sequence['outputs.ActionResponse']]:
        """
        The actions for the default rule. You cannot define a condition for a default rule. To create additional rules for an Application Load Balancer, use [AWS::ElasticLoadBalancingV2::ListenerRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listenerrule.html).
        """
        return pulumi.get(self, "default_actions")

    @property
    @pulumi.getter(name="listenerArn")
    def listener_arn(self) -> Optional[str]:
        """
        Property listenerArn
        """
        return pulumi.get(self, "listener_arn")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the load balancer.
        """
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="mutualAuthentication")
    def mutual_authentication(self) -> Optional['outputs.MutualAuthenticationResponse']:
        """
        The mutual authentication configuration information. Specifies the configuration information for mutual authentication.
        """
        return pulumi.get(self, "mutual_authentication")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port on which the load balancer is listening. You cannot specify a port for a Gateway Load Balancer.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol for connections from clients to the load balancer. For Application Load Balancers, the supported protocols are HTTP and HTTPS. For Network Load Balancers, the supported protocols are TCP, TLS, UDP, and TCP_UDP. You cant specify the UDP or TCP_UDP protocol if dual-stack mode is enabled. You cannot specify a protocol for a Gateway Load Balancer.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sslPolicy")
    def ssl_policy(self) -> Optional[str]:
        """
        [HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are supported. Updating the security policy can result in interruptions if the load balancer is handling a high volume of traffic. For more information, see [Security policies](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies) in the *Application Load Balancers Guide* and [Security policies](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies) in the *Network Load Balancers Guide*.
        """
        return pulumi.get(self, "ssl_policy")


@pulumi.output_type
class AwsElasticLoadBalancingV2LoadBalancerPropertiesResponse(dict):
    """
    Definition of awsElasticLoadBalancingV2LoadBalancer
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canonicalHostedZoneID":
            suggest = "canonical_hosted_zone_id"
        elif key == "dnsName":
            suggest = "dns_name"
        elif key == "enforceSecurityGroupInboundRulesOnPrivateLinkTraffic":
            suggest = "enforce_security_group_inbound_rules_on_private_link_traffic"
        elif key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "loadBalancerAttributes":
            suggest = "load_balancer_attributes"
        elif key == "loadBalancerFullName":
            suggest = "load_balancer_full_name"
        elif key == "loadBalancerName":
            suggest = "load_balancer_name"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetMappings":
            suggest = "subnet_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticLoadBalancingV2LoadBalancerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticLoadBalancingV2LoadBalancerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticLoadBalancingV2LoadBalancerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canonical_hosted_zone_id: Optional[str] = None,
                 dns_name: Optional[str] = None,
                 enforce_security_group_inbound_rules_on_private_link_traffic: Optional[str] = None,
                 ip_address_type: Optional[str] = None,
                 load_balancer_arn: Optional[str] = None,
                 load_balancer_attributes: Optional[Sequence['outputs.LoadBalancerAttributeResponse']] = None,
                 load_balancer_full_name: Optional[str] = None,
                 load_balancer_name: Optional[str] = None,
                 name: Optional[str] = None,
                 scheme: Optional[str] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 subnet_mappings: Optional[Sequence['outputs.SubnetMappingResponse']] = None,
                 subnets: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 type: Optional[str] = None):
        """
        Definition of awsElasticLoadBalancingV2LoadBalancer
        :param str canonical_hosted_zone_id: Property canonicalHostedZoneID
        :param str dns_name: Property dnsName
        :param str enforce_security_group_inbound_rules_on_private_link_traffic: Indicates whether to evaluate inbound security group rules for traffic sent to a Network Load Balancer through privatelink.
        :param str ip_address_type: The IP address type. The possible values are ``ipv4`` (for IPv4 addresses) and ``dualstack`` (for IPv4 and IPv6 addresses). You cant specify ``dualstack`` for a load balancer with a UDP or TCP_UDP listener.
        :param str load_balancer_arn: Property loadBalancerArn
        :param Sequence['LoadBalancerAttributeResponse'] load_balancer_attributes: The load balancer attributes.
        :param str load_balancer_full_name: Property loadBalancerFullName
        :param str load_balancer_name: Property loadBalancerName
        :param str name: The name of the load balancer. This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, must not begin or end with a hyphen, and must not begin with 'internal-'. If you don't specify a name, AWS CloudFormation generates a unique physical ID for the load balancer. If you specify a name, you cannot perform updates that require replacement of this resource, but you can perform other updates. To replace the resource, specify a new name.
        :param str scheme: The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes. Therefore, Internet-facing load balancers can route requests from clients over the internet. The nodes of an internal load balancer have only private IP addresses. The DNS name of an internal load balancer is publicly resolvable to the private IP addresses of the nodes. Therefore, internal load balancers can route requests only from clients with access to the VPC for the load balancer. The default is an Internet-facing load balancer. You cannot specify a scheme for a Gateway Load Balancer.
        :param Sequence[str] security_groups: [Application Load Balancers and Network Load Balancers] The IDs of the security groups for the load balancer.
        :param Sequence['SubnetMappingResponse'] subnet_mappings: The IDs of the subnets. You can specify only one subnet per Availability Zone. You must specify either subnets or subnet mappings, but not both. [Application Load Balancers] You must specify subnets from at least two Availability Zones. You cannot specify Elastic IP addresses for your subnets. [Application Load Balancers on Outposts] You must specify one Outpost subnet. [Application Load Balancers on Local Zones] You can specify subnets from one or more Local Zones. [Network Load Balancers] You can specify subnets from one or more Availability Zones. You can specify one Elastic IP address per subnet if you need static IP addresses for your internet-facing load balancer. For internal load balancers, you can specify one private IP address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you can specify one IPv6 address per subnet. [Gateway Load Balancers] You can specify subnets from one or more Availability Zones. You cannot specify Elastic IP addresses for your subnets.
        :param Sequence[str] subnets: The IDs of the subnets. You can specify only one subnet per Availability Zone. You must specify either subnets or subnet mappings, but not both. To specify an Elastic IP address, specify subnet mappings instead of subnets. [Application Load Balancers] You must specify subnets from at least two Availability Zones. [Application Load Balancers on Outposts] You must specify one Outpost subnet. [Application Load Balancers on Local Zones] You can specify subnets from one or more Local Zones. [Network Load Balancers] You can specify subnets from one or more Availability Zones. [Gateway Load Balancers] You can specify subnets from one or more Availability Zones.
        :param Sequence['TagResponse'] tags: The tags to assign to the load balancer.
        :param str type: The type of load balancer. The default is ``application``.
        """
        if canonical_hosted_zone_id is not None:
            pulumi.set(__self__, "canonical_hosted_zone_id", canonical_hosted_zone_id)
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if enforce_security_group_inbound_rules_on_private_link_traffic is not None:
            pulumi.set(__self__, "enforce_security_group_inbound_rules_on_private_link_traffic", enforce_security_group_inbound_rules_on_private_link_traffic)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if load_balancer_attributes is not None:
            pulumi.set(__self__, "load_balancer_attributes", load_balancer_attributes)
        if load_balancer_full_name is not None:
            pulumi.set(__self__, "load_balancer_full_name", load_balancer_full_name)
        if load_balancer_name is not None:
            pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_mappings is not None:
            pulumi.set(__self__, "subnet_mappings", subnet_mappings)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="canonicalHostedZoneID")
    def canonical_hosted_zone_id(self) -> Optional[str]:
        """
        Property canonicalHostedZoneID
        """
        return pulumi.get(self, "canonical_hosted_zone_id")

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[str]:
        """
        Property dnsName
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="enforceSecurityGroupInboundRulesOnPrivateLinkTraffic")
    def enforce_security_group_inbound_rules_on_private_link_traffic(self) -> Optional[str]:
        """
        Indicates whether to evaluate inbound security group rules for traffic sent to a Network Load Balancer through privatelink.
        """
        return pulumi.get(self, "enforce_security_group_inbound_rules_on_private_link_traffic")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[str]:
        """
        The IP address type. The possible values are ``ipv4`` (for IPv4 addresses) and ``dualstack`` (for IPv4 and IPv6 addresses). You cant specify ``dualstack`` for a load balancer with a UDP or TCP_UDP listener.
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[str]:
        """
        Property loadBalancerArn
        """
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="loadBalancerAttributes")
    def load_balancer_attributes(self) -> Optional[Sequence['outputs.LoadBalancerAttributeResponse']]:
        """
        The load balancer attributes.
        """
        return pulumi.get(self, "load_balancer_attributes")

    @property
    @pulumi.getter(name="loadBalancerFullName")
    def load_balancer_full_name(self) -> Optional[str]:
        """
        Property loadBalancerFullName
        """
        return pulumi.get(self, "load_balancer_full_name")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> Optional[str]:
        """
        Property loadBalancerName
        """
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the load balancer. This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, must not begin or end with a hyphen, and must not begin with 'internal-'. If you don't specify a name, AWS CloudFormation generates a unique physical ID for the load balancer. If you specify a name, you cannot perform updates that require replacement of this resource, but you can perform other updates. To replace the resource, specify a new name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes. Therefore, Internet-facing load balancers can route requests from clients over the internet. The nodes of an internal load balancer have only private IP addresses. The DNS name of an internal load balancer is publicly resolvable to the private IP addresses of the nodes. Therefore, internal load balancers can route requests only from clients with access to the VPC for the load balancer. The default is an Internet-facing load balancer. You cannot specify a scheme for a Gateway Load Balancer.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        [Application Load Balancers and Network Load Balancers] The IDs of the security groups for the load balancer.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="subnetMappings")
    def subnet_mappings(self) -> Optional[Sequence['outputs.SubnetMappingResponse']]:
        """
        The IDs of the subnets. You can specify only one subnet per Availability Zone. You must specify either subnets or subnet mappings, but not both. [Application Load Balancers] You must specify subnets from at least two Availability Zones. You cannot specify Elastic IP addresses for your subnets. [Application Load Balancers on Outposts] You must specify one Outpost subnet. [Application Load Balancers on Local Zones] You can specify subnets from one or more Local Zones. [Network Load Balancers] You can specify subnets from one or more Availability Zones. You can specify one Elastic IP address per subnet if you need static IP addresses for your internet-facing load balancer. For internal load balancers, you can specify one private IP address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you can specify one IPv6 address per subnet. [Gateway Load Balancers] You can specify subnets from one or more Availability Zones. You cannot specify Elastic IP addresses for your subnets.
        """
        return pulumi.get(self, "subnet_mappings")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        """
        The IDs of the subnets. You can specify only one subnet per Availability Zone. You must specify either subnets or subnet mappings, but not both. To specify an Elastic IP address, specify subnet mappings instead of subnets. [Application Load Balancers] You must specify subnets from at least two Availability Zones. [Application Load Balancers on Outposts] You must specify one Outpost subnet. [Application Load Balancers on Local Zones] You can specify subnets from one or more Local Zones. [Network Load Balancers] You can specify subnets from one or more Availability Zones. [Gateway Load Balancers] You can specify subnets from one or more Availability Zones.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The tags to assign to the load balancer.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. The default is ``application``.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AwsElasticLoadBalancingV2TargetGroupPropertiesResponse(dict):
    """
    Definition of awsElasticLoadBalancingV2TargetGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckEnabled":
            suggest = "health_check_enabled"
        elif key == "healthCheckIntervalSeconds":
            suggest = "health_check_interval_seconds"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "healthCheckPort":
            suggest = "health_check_port"
        elif key == "healthCheckProtocol":
            suggest = "health_check_protocol"
        elif key == "healthCheckTimeoutSeconds":
            suggest = "health_check_timeout_seconds"
        elif key == "healthyThresholdCount":
            suggest = "healthy_threshold_count"
        elif key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "loadBalancerArns":
            suggest = "load_balancer_arns"
        elif key == "protocolVersion":
            suggest = "protocol_version"
        elif key == "targetGroupArn":
            suggest = "target_group_arn"
        elif key == "targetGroupAttributes":
            suggest = "target_group_attributes"
        elif key == "targetGroupFullName":
            suggest = "target_group_full_name"
        elif key == "targetGroupName":
            suggest = "target_group_name"
        elif key == "targetType":
            suggest = "target_type"
        elif key == "unhealthyThresholdCount":
            suggest = "unhealthy_threshold_count"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticLoadBalancingV2TargetGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticLoadBalancingV2TargetGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticLoadBalancingV2TargetGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check_enabled: Optional[bool] = None,
                 health_check_interval_seconds: Optional[int] = None,
                 health_check_path: Optional[str] = None,
                 health_check_port: Optional[str] = None,
                 health_check_protocol: Optional[str] = None,
                 health_check_timeout_seconds: Optional[int] = None,
                 healthy_threshold_count: Optional[int] = None,
                 ip_address_type: Optional[str] = None,
                 load_balancer_arns: Optional[Sequence[str]] = None,
                 matcher: Optional['outputs.MatcherResponse'] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 protocol_version: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 target_group_arn: Optional[str] = None,
                 target_group_attributes: Optional[Sequence['outputs.TargetGroupAttributeResponse']] = None,
                 target_group_full_name: Optional[str] = None,
                 target_group_name: Optional[str] = None,
                 target_type: Optional[str] = None,
                 targets: Optional[Sequence['outputs.TargetDescriptionResponse']] = None,
                 unhealthy_threshold_count: Optional[int] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsElasticLoadBalancingV2TargetGroup
        :param bool health_check_enabled: Indicates whether health checks are enabled. If the target type is lambda, health checks are disabled by default but can be enabled. If the target type is instance, ip, or alb, health checks are always enabled and cannot be disabled.
        :param int health_check_interval_seconds: The approximate amount of time, in seconds, between health checks of an individual target.
        :param str health_check_path: [HTTP/HTTPS health checks] The destination for health checks on the targets. [HTTP1 or HTTP2 protocol version] The ping path. The default is /. [GRPC protocol version] The path of a custom health check method with the format /package.service/method. The default is /AWS.ALB/healthcheck.
        :param str health_check_port: The port the load balancer uses when performing health checks on targets.
        :param str health_check_protocol: The protocol the load balancer uses when performing health checks on targets.
        :param int health_check_timeout_seconds: The amount of time, in seconds, during which no response from a target means a failed health check.
        :param int healthy_threshold_count: The number of consecutive health checks successes required before considering an unhealthy target healthy.
        :param str ip_address_type: The type of IP address used for this target group. The possible values are ipv4 and ipv6.
        :param Sequence[str] load_balancer_arns: The Amazon Resource Names (ARNs) of the load balancers that route traffic to this target group.
        :param 'MatcherResponse' matcher: [HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful response from a target.
        :param str name: The name of the target group.
        :param int port: The port on which the targets receive traffic. This port is used unless you specify a port override when registering the target. If the target is a Lambda function, this parameter does not apply. If the protocol is GENEVE, the supported port is 6081.
        :param str protocol: The protocol to use for routing traffic to the targets.
        :param str protocol_version: [HTTP/HTTPS protocol] The protocol version. The possible values are GRPC, HTTP1, and HTTP2.
        :param Sequence['TagResponse'] tags: The tags.
        :param str target_group_arn: The ARN of the Target Group
        :param Sequence['TargetGroupAttributeResponse'] target_group_attributes: The attributes.
        :param str target_group_full_name: The full name of the target group.
        :param str target_group_name: The name of the target group.
        :param str target_type: The type of target that you must specify when registering targets with this target group. You can't specify targets for a target group using more than one target type.
        :param Sequence['TargetDescriptionResponse'] targets: The targets.
        :param int unhealthy_threshold_count: The number of consecutive health check failures required before considering a target unhealthy.
        :param str vpc_id: The identifier of the virtual private cloud (VPC). If the target is a Lambda function, this parameter does not apply.
        """
        if health_check_enabled is not None:
            pulumi.set(__self__, "health_check_enabled", health_check_enabled)
        if health_check_interval_seconds is not None:
            pulumi.set(__self__, "health_check_interval_seconds", health_check_interval_seconds)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if health_check_port is not None:
            pulumi.set(__self__, "health_check_port", health_check_port)
        if health_check_protocol is not None:
            pulumi.set(__self__, "health_check_protocol", health_check_protocol)
        if health_check_timeout_seconds is not None:
            pulumi.set(__self__, "health_check_timeout_seconds", health_check_timeout_seconds)
        if healthy_threshold_count is not None:
            pulumi.set(__self__, "healthy_threshold_count", healthy_threshold_count)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if load_balancer_arns is not None:
            pulumi.set(__self__, "load_balancer_arns", load_balancer_arns)
        if matcher is not None:
            pulumi.set(__self__, "matcher", matcher)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)
        if target_group_attributes is not None:
            pulumi.set(__self__, "target_group_attributes", target_group_attributes)
        if target_group_full_name is not None:
            pulumi.set(__self__, "target_group_full_name", target_group_full_name)
        if target_group_name is not None:
            pulumi.set(__self__, "target_group_name", target_group_name)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if unhealthy_threshold_count is not None:
            pulumi.set(__self__, "unhealthy_threshold_count", unhealthy_threshold_count)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="healthCheckEnabled")
    def health_check_enabled(self) -> Optional[bool]:
        """
        Indicates whether health checks are enabled. If the target type is lambda, health checks are disabled by default but can be enabled. If the target type is instance, ip, or alb, health checks are always enabled and cannot be disabled.
        """
        return pulumi.get(self, "health_check_enabled")

    @property
    @pulumi.getter(name="healthCheckIntervalSeconds")
    def health_check_interval_seconds(self) -> Optional[int]:
        """
        The approximate amount of time, in seconds, between health checks of an individual target.
        """
        return pulumi.get(self, "health_check_interval_seconds")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[str]:
        """
        [HTTP/HTTPS health checks] The destination for health checks on the targets. [HTTP1 or HTTP2 protocol version] The ping path. The default is /. [GRPC protocol version] The path of a custom health check method with the format /package.service/method. The default is /AWS.ALB/healthcheck.
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> Optional[str]:
        """
        The port the load balancer uses when performing health checks on targets.
        """
        return pulumi.get(self, "health_check_port")

    @property
    @pulumi.getter(name="healthCheckProtocol")
    def health_check_protocol(self) -> Optional[str]:
        """
        The protocol the load balancer uses when performing health checks on targets.
        """
        return pulumi.get(self, "health_check_protocol")

    @property
    @pulumi.getter(name="healthCheckTimeoutSeconds")
    def health_check_timeout_seconds(self) -> Optional[int]:
        """
        The amount of time, in seconds, during which no response from a target means a failed health check.
        """
        return pulumi.get(self, "health_check_timeout_seconds")

    @property
    @pulumi.getter(name="healthyThresholdCount")
    def healthy_threshold_count(self) -> Optional[int]:
        """
        The number of consecutive health checks successes required before considering an unhealthy target healthy.
        """
        return pulumi.get(self, "healthy_threshold_count")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[str]:
        """
        The type of IP address used for this target group. The possible values are ipv4 and ipv6.
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="loadBalancerArns")
    def load_balancer_arns(self) -> Optional[Sequence[str]]:
        """
        The Amazon Resource Names (ARNs) of the load balancers that route traffic to this target group.
        """
        return pulumi.get(self, "load_balancer_arns")

    @property
    @pulumi.getter
    def matcher(self) -> Optional['outputs.MatcherResponse']:
        """
        [HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful response from a target.
        """
        return pulumi.get(self, "matcher")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the target group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port on which the targets receive traffic. This port is used unless you specify a port override when registering the target. If the target is a Lambda function, this parameter does not apply. If the protocol is GENEVE, the supported port is 6081.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol to use for routing traffic to the targets.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[str]:
        """
        [HTTP/HTTPS protocol] The protocol version. The possible values are GRPC, HTTP1, and HTTP2.
        """
        return pulumi.get(self, "protocol_version")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[str]:
        """
        The ARN of the Target Group
        """
        return pulumi.get(self, "target_group_arn")

    @property
    @pulumi.getter(name="targetGroupAttributes")
    def target_group_attributes(self) -> Optional[Sequence['outputs.TargetGroupAttributeResponse']]:
        """
        The attributes.
        """
        return pulumi.get(self, "target_group_attributes")

    @property
    @pulumi.getter(name="targetGroupFullName")
    def target_group_full_name(self) -> Optional[str]:
        """
        The full name of the target group.
        """
        return pulumi.get(self, "target_group_full_name")

    @property
    @pulumi.getter(name="targetGroupName")
    def target_group_name(self) -> Optional[str]:
        """
        The name of the target group.
        """
        return pulumi.get(self, "target_group_name")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[str]:
        """
        The type of target that you must specify when registering targets with this target group. You can't specify targets for a target group using more than one target type.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter
    def targets(self) -> Optional[Sequence['outputs.TargetDescriptionResponse']]:
        """
        The targets.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="unhealthyThresholdCount")
    def unhealthy_threshold_count(self) -> Optional[int]:
        """
        The number of consecutive health check failures required before considering a target unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold_count")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        The identifier of the virtual private cloud (VPC). If the target is a Lambda function, this parameter does not apply.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse(dict):
    """
    Definition of awsElasticLoadBalancingv2TargetHealthDescription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anomalyDetection":
            suggest = "anomaly_detection"
        elif key == "healthCheckPort":
            suggest = "health_check_port"
        elif key == "targetHealth":
            suggest = "target_health"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anomaly_detection: Optional['outputs.AnomalyDetectionResponse'] = None,
                 health_check_port: Optional[str] = None,
                 target: Optional['outputs.TargetDescriptionResponse'] = None,
                 target_health: Optional['outputs.TargetHealthResponse'] = None):
        """
        Definition of awsElasticLoadBalancingv2TargetHealthDescription
        :param 'AnomalyDetectionResponse' anomaly_detection: <p>The anomaly detection result for the target.</p> <p>If no anomalies were detected, the result is <code>normal</code>.</p> <p>If anomalies were detected, the result is <code>anomalous</code>.</p>
        :param str health_check_port: <p>The port to use to connect with the target.</p>
        :param 'TargetDescriptionResponse' target: <p>The description of the target.</p>
        :param 'TargetHealthResponse' target_health: <p>The health information for the target.</p>
        """
        if anomaly_detection is not None:
            pulumi.set(__self__, "anomaly_detection", anomaly_detection)
        if health_check_port is not None:
            pulumi.set(__self__, "health_check_port", health_check_port)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if target_health is not None:
            pulumi.set(__self__, "target_health", target_health)

    @property
    @pulumi.getter(name="anomalyDetection")
    def anomaly_detection(self) -> Optional['outputs.AnomalyDetectionResponse']:
        """
        <p>The anomaly detection result for the target.</p> <p>If no anomalies were detected, the result is <code>normal</code>.</p> <p>If anomalies were detected, the result is <code>anomalous</code>.</p>
        """
        return pulumi.get(self, "anomaly_detection")

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> Optional[str]:
        """
        <p>The port to use to connect with the target.</p>
        """
        return pulumi.get(self, "health_check_port")

    @property
    @pulumi.getter
    def target(self) -> Optional['outputs.TargetDescriptionResponse']:
        """
        <p>The description of the target.</p>
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetHealth")
    def target_health(self) -> Optional['outputs.TargetHealthResponse']:
        """
        <p>The health information for the target.</p>
        """
        return pulumi.get(self, "target_health")


@pulumi.output_type
class AwsEmrClusterPropertiesResponse(dict):
    """
    Definition of awsEmrCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoScalingRole":
            suggest = "auto_scaling_role"
        elif key == "autoTerminate":
            suggest = "auto_terminate"
        elif key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "customAmiId":
            suggest = "custom_ami_id"
        elif key == "ebsRootVolumeIops":
            suggest = "ebs_root_volume_iops"
        elif key == "ebsRootVolumeSize":
            suggest = "ebs_root_volume_size"
        elif key == "ebsRootVolumeThroughput":
            suggest = "ebs_root_volume_throughput"
        elif key == "ec2InstanceAttributes":
            suggest = "ec2_instance_attributes"
        elif key == "instanceCollectionType":
            suggest = "instance_collection_type"
        elif key == "kerberosAttributes":
            suggest = "kerberos_attributes"
        elif key == "logEncryptionKmsKeyId":
            suggest = "log_encryption_kms_key_id"
        elif key == "logUri":
            suggest = "log_uri"
        elif key == "masterPublicDnsName":
            suggest = "master_public_dns_name"
        elif key == "normalizedInstanceHours":
            suggest = "normalized_instance_hours"
        elif key == "osReleaseLabel":
            suggest = "os_release_label"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "placementGroups":
            suggest = "placement_groups"
        elif key == "releaseLabel":
            suggest = "release_label"
        elif key == "repoUpgradeOnBoot":
            suggest = "repo_upgrade_on_boot"
        elif key == "requestedAmiVersion":
            suggest = "requested_ami_version"
        elif key == "runningAmiVersion":
            suggest = "running_ami_version"
        elif key == "scaleDownBehavior":
            suggest = "scale_down_behavior"
        elif key == "securityConfiguration":
            suggest = "security_configuration"
        elif key == "serviceRole":
            suggest = "service_role"
        elif key == "stepConcurrencyLevel":
            suggest = "step_concurrency_level"
        elif key == "terminationProtected":
            suggest = "termination_protected"
        elif key == "unhealthyNodeReplacement":
            suggest = "unhealthy_node_replacement"
        elif key == "visibleToAllUsers":
            suggest = "visible_to_all_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEmrClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEmrClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEmrClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applications: Optional[Sequence['outputs.ApplicationResponse']] = None,
                 auto_scaling_role: Optional[str] = None,
                 auto_terminate: Optional[bool] = None,
                 cluster_arn: Optional[str] = None,
                 configurations: Optional[Sequence['outputs.ConfigurationResponse']] = None,
                 custom_ami_id: Optional[str] = None,
                 ebs_root_volume_iops: Optional[int] = None,
                 ebs_root_volume_size: Optional[int] = None,
                 ebs_root_volume_throughput: Optional[int] = None,
                 ec2_instance_attributes: Optional['outputs.Ec2InstanceAttributesResponse'] = None,
                 id: Optional[str] = None,
                 instance_collection_type: Optional['outputs.InstanceCollectionTypeEnumValueResponse'] = None,
                 kerberos_attributes: Optional['outputs.KerberosAttributesResponse'] = None,
                 log_encryption_kms_key_id: Optional[str] = None,
                 log_uri: Optional[str] = None,
                 master_public_dns_name: Optional[str] = None,
                 name: Optional[str] = None,
                 normalized_instance_hours: Optional[int] = None,
                 os_release_label: Optional[str] = None,
                 outpost_arn: Optional[str] = None,
                 placement_groups: Optional[Sequence['outputs.PlacementGroupConfigResponse']] = None,
                 release_label: Optional[str] = None,
                 repo_upgrade_on_boot: Optional['outputs.RepoUpgradeOnBootEnumValueResponse'] = None,
                 requested_ami_version: Optional[str] = None,
                 running_ami_version: Optional[str] = None,
                 scale_down_behavior: Optional['outputs.ScaleDownBehaviorEnumValueResponse'] = None,
                 security_configuration: Optional[str] = None,
                 service_role: Optional[str] = None,
                 status: Optional['outputs.EmrClusterStatusResponse'] = None,
                 step_concurrency_level: Optional[int] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 termination_protected: Optional[bool] = None,
                 unhealthy_node_replacement: Optional[bool] = None,
                 visible_to_all_users: Optional[bool] = None):
        """
        Definition of awsEmrCluster
        :param Sequence['ApplicationResponse'] applications: <p>The applications installed on this cluster.</p>
        :param str auto_scaling_role: <p>An IAM role for automatic scaling policies. The default role is <code>EMR_AutoScaling_DefaultRole</code>. The IAM role provides permissions that the automatic scaling feature requires to launch and terminate Amazon EC2 instances in an instance group.</p>
        :param bool auto_terminate: <p>Specifies whether the cluster should terminate after completing all steps.</p>
        :param str cluster_arn: <p>The Amazon Resource Name of the cluster.</p>
        :param Sequence['ConfigurationResponse'] configurations: <p>Applies only to Amazon EMR releases 4.x and later. The list of configurations that are supplied to the Amazon EMR cluster.</p>
        :param str custom_ami_id: <p>Available only in Amazon EMR releases 5.7.0 and later. The ID of a custom Amazon EBS-backed Linux AMI if the cluster uses a custom AMI.</p>
        :param int ebs_root_volume_iops: <p>The IOPS, of the Amazon EBS root device volume of the Linux AMI that is used for each Amazon EC2 instance. Available in Amazon EMR releases 6.15.0 and later.</p>
        :param int ebs_root_volume_size: <p>The size, in GiB, of the Amazon EBS root device volume of the Linux AMI that is used for each Amazon EC2 instance. Available in Amazon EMR releases 4.x and later.</p>
        :param int ebs_root_volume_throughput: <p>The throughput, in MiB/s, of the Amazon EBS root device volume of the Linux AMI that is used for each Amazon EC2 instance. Available in Amazon EMR releases 6.15.0 and later.</p>
        :param 'Ec2InstanceAttributesResponse' ec2_instance_attributes: <p>Provides information about the Amazon EC2 instances in a cluster grouped by category. For example, key name, subnet ID, IAM instance profile, and so on.</p>
        :param str id: <p>The unique identifier for the cluster.</p>
        :param 'InstanceCollectionTypeEnumValueResponse' instance_collection_type: <note> <p>The instance fleet configuration is available only in Amazon EMR releases 4.8.0 and later, excluding 5.0.x versions.</p> </note> <p>The instance group configuration of the cluster. A value of <code>INSTANCE_GROUP</code> indicates a uniform instance group configuration. A value of <code>INSTANCE_FLEET</code> indicates an instance fleets configuration.</p>
        :param 'KerberosAttributesResponse' kerberos_attributes: <p>Attributes for Kerberos configuration when Kerberos authentication is enabled using a security configuration. For more information see <a href='https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-kerberos.html'>Use Kerberos Authentication</a> in the <i>Amazon EMR Management Guide</i>.</p>
        :param str log_encryption_kms_key_id: <p> The KMS key used for encrypting log files. This attribute is only available with Amazon EMR 5.30.0 and later, excluding Amazon EMR 6.0.0. </p>
        :param str log_uri: <p>The path to the Amazon S3 location where logs for this cluster are stored.</p>
        :param str master_public_dns_name: <p>The DNS name of the master node. If the cluster is on a private subnet, this is the private DNS name. On a public subnet, this is the public DNS name.</p>
        :param str name: <p>The name of the cluster. This parameter can't contain the characters &lt;, &gt;, $, |, or ` (backtick).</p>
        :param int normalized_instance_hours: <p>An approximation of the cost of the cluster, represented in m1.small/hours. This value is incremented one time for every hour an m1.small instance runs. Larger instances are weighted more, so an Amazon EC2 instance that is roughly four times more expensive would result in the normalized instance hours being incremented by four. This result is only an approximation and does not reflect the actual billing rate.</p>
        :param str os_release_label: <p>The Amazon Linux release specified in a cluster launch RunJobFlow request. If no Amazon Linux release was specified, the default Amazon Linux release is shown in the response.</p>
        :param str outpost_arn: <p> The Amazon Resource Name (ARN) of the Outpost where the cluster is launched. </p>
        :param Sequence['PlacementGroupConfigResponse'] placement_groups: <p>Placement group configured for an Amazon EMR cluster.</p>
        :param str release_label: <p>The Amazon EMR release label, which determines the version of open-source application packages installed on the cluster. Release labels are in the form <code>emr-x.x.x</code>, where x.x.x is an Amazon EMR release version such as <code>emr-5.14.0</code>. For more information about Amazon EMR release versions and included application versions and features, see <a href='https://docs.aws.amazon.com/emr/latest/ReleaseGuide/'>https://docs.aws.amazon.com/emr/latest/ReleaseGuide/</a>. The release label applies only to Amazon EMR releases version 4.0 and later. Earlier versions use <code>AmiVersion</code>.</p>
        :param 'RepoUpgradeOnBootEnumValueResponse' repo_upgrade_on_boot: <p>Applies only when <code>CustomAmiID</code> is used. Specifies the type of updates that the Amazon Linux AMI package repositories apply when an instance boots using the AMI.</p>
        :param str requested_ami_version: <p>The AMI version requested for this cluster.</p>
        :param str running_ami_version: <p>The AMI version running on this cluster.</p>
        :param 'ScaleDownBehaviorEnumValueResponse' scale_down_behavior: <p>The way that individual Amazon EC2 instances terminate when an automatic scale-in activity occurs or an instance group is resized. <code>TERMINATE_AT_INSTANCE_HOUR</code> indicates that Amazon EMR terminates nodes at the instance-hour boundary, regardless of when the request to terminate the instance was submitted. This option is only available with Amazon EMR 5.1.0 and later and is the default for clusters created using that version. <code>TERMINATE_AT_TASK_COMPLETION</code> indicates that Amazon EMR adds nodes to a deny list and drains tasks from nodes before terminating the Amazon EC2 instances, regardless of the instance-hour boundary. With either behavior, Amazon EMR removes the least active nodes first and blocks instance termination if it could lead to HDFS corruption. <code>TERMINATE_AT_TASK_COMPLETION</code> is available only in Amazon EMR releases 4.1.0 and later, and is the default for versions of Amazon EMR earlier than 5.1.0.</p>
        :param str security_configuration: <p>The name of the security configuration applied to the cluster.</p>
        :param str service_role: <p>The IAM role that Amazon EMR assumes in order to access Amazon Web Services resources on your behalf.</p>
        :param 'EmrClusterStatusResponse' status: <p>The current status details about the cluster.</p>
        :param int step_concurrency_level: <p>Specifies the number of steps that can be executed concurrently.</p>
        :param Sequence['TagResponse'] tags: <p>A list of tags associated with a cluster.</p>
        :param bool termination_protected: <p>Indicates whether Amazon EMR will lock the cluster to prevent the Amazon EC2 instances from being terminated by an API call or user intervention, or in the event of a cluster error.</p>
        :param bool unhealthy_node_replacement: <p>Indicates whether Amazon EMR should gracefully replace Amazon EC2 core instances that have degraded within the cluster.</p>
        :param bool visible_to_all_users: <p>Indicates whether the cluster is visible to IAM principals in the Amazon Web Services account associated with the cluster. When <code>true</code>, IAM principals in the Amazon Web Services account can perform Amazon EMR cluster actions on the cluster that their IAM policies allow. When <code>false</code>, only the IAM principal that created the cluster and the Amazon Web Services account root user can perform Amazon EMR actions, regardless of IAM permissions policies attached to other IAM principals.</p> <p>The default value is <code>true</code> if a value is not provided when creating a cluster using the Amazon EMR API <a>RunJobFlow</a> command, the CLI <a href='https://docs.aws.amazon.com/cli/latest/reference/emr/create-cluster.html'>create-cluster</a> command, or the Amazon Web Services Management Console.</p>
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if auto_scaling_role is not None:
            pulumi.set(__self__, "auto_scaling_role", auto_scaling_role)
        if auto_terminate is not None:
            pulumi.set(__self__, "auto_terminate", auto_terminate)
        if cluster_arn is not None:
            pulumi.set(__self__, "cluster_arn", cluster_arn)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if custom_ami_id is not None:
            pulumi.set(__self__, "custom_ami_id", custom_ami_id)
        if ebs_root_volume_iops is not None:
            pulumi.set(__self__, "ebs_root_volume_iops", ebs_root_volume_iops)
        if ebs_root_volume_size is not None:
            pulumi.set(__self__, "ebs_root_volume_size", ebs_root_volume_size)
        if ebs_root_volume_throughput is not None:
            pulumi.set(__self__, "ebs_root_volume_throughput", ebs_root_volume_throughput)
        if ec2_instance_attributes is not None:
            pulumi.set(__self__, "ec2_instance_attributes", ec2_instance_attributes)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_collection_type is not None:
            pulumi.set(__self__, "instance_collection_type", instance_collection_type)
        if kerberos_attributes is not None:
            pulumi.set(__self__, "kerberos_attributes", kerberos_attributes)
        if log_encryption_kms_key_id is not None:
            pulumi.set(__self__, "log_encryption_kms_key_id", log_encryption_kms_key_id)
        if log_uri is not None:
            pulumi.set(__self__, "log_uri", log_uri)
        if master_public_dns_name is not None:
            pulumi.set(__self__, "master_public_dns_name", master_public_dns_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalized_instance_hours is not None:
            pulumi.set(__self__, "normalized_instance_hours", normalized_instance_hours)
        if os_release_label is not None:
            pulumi.set(__self__, "os_release_label", os_release_label)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if placement_groups is not None:
            pulumi.set(__self__, "placement_groups", placement_groups)
        if release_label is not None:
            pulumi.set(__self__, "release_label", release_label)
        if repo_upgrade_on_boot is not None:
            pulumi.set(__self__, "repo_upgrade_on_boot", repo_upgrade_on_boot)
        if requested_ami_version is not None:
            pulumi.set(__self__, "requested_ami_version", requested_ami_version)
        if running_ami_version is not None:
            pulumi.set(__self__, "running_ami_version", running_ami_version)
        if scale_down_behavior is not None:
            pulumi.set(__self__, "scale_down_behavior", scale_down_behavior)
        if security_configuration is not None:
            pulumi.set(__self__, "security_configuration", security_configuration)
        if service_role is not None:
            pulumi.set(__self__, "service_role", service_role)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if step_concurrency_level is not None:
            pulumi.set(__self__, "step_concurrency_level", step_concurrency_level)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if termination_protected is not None:
            pulumi.set(__self__, "termination_protected", termination_protected)
        if unhealthy_node_replacement is not None:
            pulumi.set(__self__, "unhealthy_node_replacement", unhealthy_node_replacement)
        if visible_to_all_users is not None:
            pulumi.set(__self__, "visible_to_all_users", visible_to_all_users)

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.ApplicationResponse']]:
        """
        <p>The applications installed on this cluster.</p>
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="autoScalingRole")
    def auto_scaling_role(self) -> Optional[str]:
        """
        <p>An IAM role for automatic scaling policies. The default role is <code>EMR_AutoScaling_DefaultRole</code>. The IAM role provides permissions that the automatic scaling feature requires to launch and terminate Amazon EC2 instances in an instance group.</p>
        """
        return pulumi.get(self, "auto_scaling_role")

    @property
    @pulumi.getter(name="autoTerminate")
    def auto_terminate(self) -> Optional[bool]:
        """
        <p>Specifies whether the cluster should terminate after completing all steps.</p>
        """
        return pulumi.get(self, "auto_terminate")

    @property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name of the cluster.</p>
        """
        return pulumi.get(self, "cluster_arn")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.ConfigurationResponse']]:
        """
        <p>Applies only to Amazon EMR releases 4.x and later. The list of configurations that are supplied to the Amazon EMR cluster.</p>
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="customAmiId")
    def custom_ami_id(self) -> Optional[str]:
        """
        <p>Available only in Amazon EMR releases 5.7.0 and later. The ID of a custom Amazon EBS-backed Linux AMI if the cluster uses a custom AMI.</p>
        """
        return pulumi.get(self, "custom_ami_id")

    @property
    @pulumi.getter(name="ebsRootVolumeIops")
    def ebs_root_volume_iops(self) -> Optional[int]:
        """
        <p>The IOPS, of the Amazon EBS root device volume of the Linux AMI that is used for each Amazon EC2 instance. Available in Amazon EMR releases 6.15.0 and later.</p>
        """
        return pulumi.get(self, "ebs_root_volume_iops")

    @property
    @pulumi.getter(name="ebsRootVolumeSize")
    def ebs_root_volume_size(self) -> Optional[int]:
        """
        <p>The size, in GiB, of the Amazon EBS root device volume of the Linux AMI that is used for each Amazon EC2 instance. Available in Amazon EMR releases 4.x and later.</p>
        """
        return pulumi.get(self, "ebs_root_volume_size")

    @property
    @pulumi.getter(name="ebsRootVolumeThroughput")
    def ebs_root_volume_throughput(self) -> Optional[int]:
        """
        <p>The throughput, in MiB/s, of the Amazon EBS root device volume of the Linux AMI that is used for each Amazon EC2 instance. Available in Amazon EMR releases 6.15.0 and later.</p>
        """
        return pulumi.get(self, "ebs_root_volume_throughput")

    @property
    @pulumi.getter(name="ec2InstanceAttributes")
    def ec2_instance_attributes(self) -> Optional['outputs.Ec2InstanceAttributesResponse']:
        """
        <p>Provides information about the Amazon EC2 instances in a cluster grouped by category. For example, key name, subnet ID, IAM instance profile, and so on.</p>
        """
        return pulumi.get(self, "ec2_instance_attributes")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        <p>The unique identifier for the cluster.</p>
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceCollectionType")
    def instance_collection_type(self) -> Optional['outputs.InstanceCollectionTypeEnumValueResponse']:
        """
        <note> <p>The instance fleet configuration is available only in Amazon EMR releases 4.8.0 and later, excluding 5.0.x versions.</p> </note> <p>The instance group configuration of the cluster. A value of <code>INSTANCE_GROUP</code> indicates a uniform instance group configuration. A value of <code>INSTANCE_FLEET</code> indicates an instance fleets configuration.</p>
        """
        return pulumi.get(self, "instance_collection_type")

    @property
    @pulumi.getter(name="kerberosAttributes")
    def kerberos_attributes(self) -> Optional['outputs.KerberosAttributesResponse']:
        """
        <p>Attributes for Kerberos configuration when Kerberos authentication is enabled using a security configuration. For more information see <a href='https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-kerberos.html'>Use Kerberos Authentication</a> in the <i>Amazon EMR Management Guide</i>.</p>
        """
        return pulumi.get(self, "kerberos_attributes")

    @property
    @pulumi.getter(name="logEncryptionKmsKeyId")
    def log_encryption_kms_key_id(self) -> Optional[str]:
        """
        <p> The KMS key used for encrypting log files. This attribute is only available with Amazon EMR 5.30.0 and later, excluding Amazon EMR 6.0.0. </p>
        """
        return pulumi.get(self, "log_encryption_kms_key_id")

    @property
    @pulumi.getter(name="logUri")
    def log_uri(self) -> Optional[str]:
        """
        <p>The path to the Amazon S3 location where logs for this cluster are stored.</p>
        """
        return pulumi.get(self, "log_uri")

    @property
    @pulumi.getter(name="masterPublicDnsName")
    def master_public_dns_name(self) -> Optional[str]:
        """
        <p>The DNS name of the master node. If the cluster is on a private subnet, this is the private DNS name. On a public subnet, this is the public DNS name.</p>
        """
        return pulumi.get(self, "master_public_dns_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the cluster. This parameter can't contain the characters &lt;, &gt;, $, |, or ` (backtick).</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizedInstanceHours")
    def normalized_instance_hours(self) -> Optional[int]:
        """
        <p>An approximation of the cost of the cluster, represented in m1.small/hours. This value is incremented one time for every hour an m1.small instance runs. Larger instances are weighted more, so an Amazon EC2 instance that is roughly four times more expensive would result in the normalized instance hours being incremented by four. This result is only an approximation and does not reflect the actual billing rate.</p>
        """
        return pulumi.get(self, "normalized_instance_hours")

    @property
    @pulumi.getter(name="osReleaseLabel")
    def os_release_label(self) -> Optional[str]:
        """
        <p>The Amazon Linux release specified in a cluster launch RunJobFlow request. If no Amazon Linux release was specified, the default Amazon Linux release is shown in the response.</p>
        """
        return pulumi.get(self, "os_release_label")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        <p> The Amazon Resource Name (ARN) of the Outpost where the cluster is launched. </p>
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter(name="placementGroups")
    def placement_groups(self) -> Optional[Sequence['outputs.PlacementGroupConfigResponse']]:
        """
        <p>Placement group configured for an Amazon EMR cluster.</p>
        """
        return pulumi.get(self, "placement_groups")

    @property
    @pulumi.getter(name="releaseLabel")
    def release_label(self) -> Optional[str]:
        """
        <p>The Amazon EMR release label, which determines the version of open-source application packages installed on the cluster. Release labels are in the form <code>emr-x.x.x</code>, where x.x.x is an Amazon EMR release version such as <code>emr-5.14.0</code>. For more information about Amazon EMR release versions and included application versions and features, see <a href='https://docs.aws.amazon.com/emr/latest/ReleaseGuide/'>https://docs.aws.amazon.com/emr/latest/ReleaseGuide/</a>. The release label applies only to Amazon EMR releases version 4.0 and later. Earlier versions use <code>AmiVersion</code>.</p>
        """
        return pulumi.get(self, "release_label")

    @property
    @pulumi.getter(name="repoUpgradeOnBoot")
    def repo_upgrade_on_boot(self) -> Optional['outputs.RepoUpgradeOnBootEnumValueResponse']:
        """
        <p>Applies only when <code>CustomAmiID</code> is used. Specifies the type of updates that the Amazon Linux AMI package repositories apply when an instance boots using the AMI.</p>
        """
        return pulumi.get(self, "repo_upgrade_on_boot")

    @property
    @pulumi.getter(name="requestedAmiVersion")
    def requested_ami_version(self) -> Optional[str]:
        """
        <p>The AMI version requested for this cluster.</p>
        """
        return pulumi.get(self, "requested_ami_version")

    @property
    @pulumi.getter(name="runningAmiVersion")
    def running_ami_version(self) -> Optional[str]:
        """
        <p>The AMI version running on this cluster.</p>
        """
        return pulumi.get(self, "running_ami_version")

    @property
    @pulumi.getter(name="scaleDownBehavior")
    def scale_down_behavior(self) -> Optional['outputs.ScaleDownBehaviorEnumValueResponse']:
        """
        <p>The way that individual Amazon EC2 instances terminate when an automatic scale-in activity occurs or an instance group is resized. <code>TERMINATE_AT_INSTANCE_HOUR</code> indicates that Amazon EMR terminates nodes at the instance-hour boundary, regardless of when the request to terminate the instance was submitted. This option is only available with Amazon EMR 5.1.0 and later and is the default for clusters created using that version. <code>TERMINATE_AT_TASK_COMPLETION</code> indicates that Amazon EMR adds nodes to a deny list and drains tasks from nodes before terminating the Amazon EC2 instances, regardless of the instance-hour boundary. With either behavior, Amazon EMR removes the least active nodes first and blocks instance termination if it could lead to HDFS corruption. <code>TERMINATE_AT_TASK_COMPLETION</code> is available only in Amazon EMR releases 4.1.0 and later, and is the default for versions of Amazon EMR earlier than 5.1.0.</p>
        """
        return pulumi.get(self, "scale_down_behavior")

    @property
    @pulumi.getter(name="securityConfiguration")
    def security_configuration(self) -> Optional[str]:
        """
        <p>The name of the security configuration applied to the cluster.</p>
        """
        return pulumi.get(self, "security_configuration")

    @property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> Optional[str]:
        """
        <p>The IAM role that Amazon EMR assumes in order to access Amazon Web Services resources on your behalf.</p>
        """
        return pulumi.get(self, "service_role")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.EmrClusterStatusResponse']:
        """
        <p>The current status details about the cluster.</p>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stepConcurrencyLevel")
    def step_concurrency_level(self) -> Optional[int]:
        """
        <p>Specifies the number of steps that can be executed concurrently.</p>
        """
        return pulumi.get(self, "step_concurrency_level")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        <p>A list of tags associated with a cluster.</p>
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationProtected")
    def termination_protected(self) -> Optional[bool]:
        """
        <p>Indicates whether Amazon EMR will lock the cluster to prevent the Amazon EC2 instances from being terminated by an API call or user intervention, or in the event of a cluster error.</p>
        """
        return pulumi.get(self, "termination_protected")

    @property
    @pulumi.getter(name="unhealthyNodeReplacement")
    def unhealthy_node_replacement(self) -> Optional[bool]:
        """
        <p>Indicates whether Amazon EMR should gracefully replace Amazon EC2 core instances that have degraded within the cluster.</p>
        """
        return pulumi.get(self, "unhealthy_node_replacement")

    @property
    @pulumi.getter(name="visibleToAllUsers")
    def visible_to_all_users(self) -> Optional[bool]:
        """
        <p>Indicates whether the cluster is visible to IAM principals in the Amazon Web Services account associated with the cluster. When <code>true</code>, IAM principals in the Amazon Web Services account can perform Amazon EMR cluster actions on the cluster that their IAM policies allow. When <code>false</code>, only the IAM principal that created the cluster and the Amazon Web Services account root user can perform Amazon EMR actions, regardless of IAM permissions policies attached to other IAM principals.</p> <p>The default value is <code>true</code> if a value is not provided when creating a cluster using the Amazon EMR API <a>RunJobFlow</a> command, the CLI <a href='https://docs.aws.amazon.com/cli/latest/reference/emr/create-cluster.html'>create-cluster</a> command, or the Amazon Web Services Management Console.</p>
        """
        return pulumi.get(self, "visible_to_all_users")


@pulumi.output_type
class AwsEmrClusterSummaryPropertiesResponse(dict):
    """
    Definition of awsEmrClusterSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "normalizedInstanceHours":
            suggest = "normalized_instance_hours"
        elif key == "outpostArn":
            suggest = "outpost_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEmrClusterSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEmrClusterSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEmrClusterSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 normalized_instance_hours: Optional[int] = None,
                 outpost_arn: Optional[str] = None,
                 status: Optional['outputs.EmrClusterStatusResponse'] = None):
        """
        Definition of awsEmrClusterSummary
        :param str cluster_arn: <p>The Amazon Resource Name of the cluster.</p>
        :param str id: <p>The unique identifier for the cluster.</p>
        :param str name: <p>The name of the cluster.</p>
        :param int normalized_instance_hours: <p>An approximation of the cost of the cluster, represented in m1.small/hours. This value is incremented one time for every hour an m1.small instance runs. Larger instances are weighted more, so an Amazon EC2 instance that is roughly four times more expensive would result in the normalized instance hours being incremented by four. This result is only an approximation and does not reflect the actual billing rate.</p>
        :param str outpost_arn: <p> The Amazon Resource Name (ARN) of the Outpost where the cluster is launched. </p>
        :param 'EmrClusterStatusResponse' status: <p>The details about the current status of the cluster.</p>
        """
        if cluster_arn is not None:
            pulumi.set(__self__, "cluster_arn", cluster_arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalized_instance_hours is not None:
            pulumi.set(__self__, "normalized_instance_hours", normalized_instance_hours)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name of the cluster.</p>
        """
        return pulumi.get(self, "cluster_arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        <p>The unique identifier for the cluster.</p>
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the cluster.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizedInstanceHours")
    def normalized_instance_hours(self) -> Optional[int]:
        """
        <p>An approximation of the cost of the cluster, represented in m1.small/hours. This value is incremented one time for every hour an m1.small instance runs. Larger instances are weighted more, so an Amazon EC2 instance that is roughly four times more expensive would result in the normalized instance hours being incremented by four. This result is only an approximation and does not reflect the actual billing rate.</p>
        """
        return pulumi.get(self, "normalized_instance_hours")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        <p> The Amazon Resource Name (ARN) of the Outpost where the cluster is launched. </p>
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.EmrClusterStatusResponse']:
        """
        <p>The details about the current status of the cluster.</p>
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AwsGuardDutyDetectorPropertiesResponse(dict):
    """
    Definition of awsGuardDutyDetector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSources":
            suggest = "data_sources"
        elif key == "findingPublishingFrequency":
            suggest = "finding_publishing_frequency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsGuardDutyDetectorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsGuardDutyDetectorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsGuardDutyDetectorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_sources: Optional['outputs.CFNDataSourceConfigurationsResponse'] = None,
                 enable: Optional[bool] = None,
                 features: Optional[Sequence['outputs.CFNFeatureConfigurationResponse']] = None,
                 finding_publishing_frequency: Optional[str] = None,
                 id: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagItemResponse']] = None):
        """
        Definition of awsGuardDutyDetector
        :param 'CFNDataSourceConfigurationsResponse' data_sources: Property dataSources
        :param bool enable: Property enable
        :param Sequence['CFNFeatureConfigurationResponse'] features: Property features
        :param str finding_publishing_frequency: Property findingPublishingFrequency
        :param str id: Property id
        :param Sequence['TagItemResponse'] tags: Property tags
        """
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if finding_publishing_frequency is not None:
            pulumi.set(__self__, "finding_publishing_frequency", finding_publishing_frequency)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional['outputs.CFNDataSourceConfigurationsResponse']:
        """
        Property dataSources
        """
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Property enable
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def features(self) -> Optional[Sequence['outputs.CFNFeatureConfigurationResponse']]:
        """
        Property features
        """
        return pulumi.get(self, "features")

    @property
    @pulumi.getter(name="findingPublishingFrequency")
    def finding_publishing_frequency(self) -> Optional[str]:
        """
        Property findingPublishingFrequency
        """
        return pulumi.get(self, "finding_publishing_frequency")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagItemResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsIamAccessKeyLastUsedPropertiesResponse(dict):
    """
    Definition of awsIamAccessKeyLastUsed
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastUsedDate":
            suggest = "last_used_date"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamAccessKeyLastUsedPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamAccessKeyLastUsedPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamAccessKeyLastUsedPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_used_date: Optional[str] = None,
                 region: Optional[str] = None,
                 service_name: Optional[str] = None):
        """
        Definition of awsIamAccessKeyLastUsed
        :param str last_used_date: <p>The date and time, in <a href='http://www.iso.org/iso/iso8601'>ISO 8601 date-time format</a>, when the access key was most recently used. This field is null in the following situations:</p> <ul> <li> <p>The user does not have an access key.</p> </li> <li> <p>An access key exists but has not been used since IAM began tracking this information.</p> </li> <li> <p>There is no sign-in data associated with the user.</p> </li> </ul>
        :param str region: <p>The Amazon Web Services Region where this access key was most recently used. The value for this field is 'N/A' in the following situations:</p> <ul> <li> <p>The user does not have an access key.</p> </li> <li> <p>An access key exists but has not been used since IAM began tracking this information.</p> </li> <li> <p>There is no sign-in data associated with the user.</p> </li> </ul> <p>For more information about Amazon Web Services Regions, see <a href='https://docs.aws.amazon.com/general/latest/gr/rande.html'>Regions and endpoints</a> in the Amazon Web Services General Reference.</p>
        :param str service_name: <p>The name of the Amazon Web Services service with which this access key was most recently used. The value of this field is 'N/A' in the following situations:</p> <ul> <li> <p>The user does not have an access key.</p> </li> <li> <p>An access key exists but has not been used since IAM started tracking this information.</p> </li> <li> <p>There is no sign-in data associated with the user.</p> </li> </ul>
        """
        if last_used_date is not None:
            pulumi.set(__self__, "last_used_date", last_used_date)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="lastUsedDate")
    def last_used_date(self) -> Optional[str]:
        """
        <p>The date and time, in <a href='http://www.iso.org/iso/iso8601'>ISO 8601 date-time format</a>, when the access key was most recently used. This field is null in the following situations:</p> <ul> <li> <p>The user does not have an access key.</p> </li> <li> <p>An access key exists but has not been used since IAM began tracking this information.</p> </li> <li> <p>There is no sign-in data associated with the user.</p> </li> </ul>
        """
        return pulumi.get(self, "last_used_date")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        <p>The Amazon Web Services Region where this access key was most recently used. The value for this field is 'N/A' in the following situations:</p> <ul> <li> <p>The user does not have an access key.</p> </li> <li> <p>An access key exists but has not been used since IAM began tracking this information.</p> </li> <li> <p>There is no sign-in data associated with the user.</p> </li> </ul> <p>For more information about Amazon Web Services Regions, see <a href='https://docs.aws.amazon.com/general/latest/gr/rande.html'>Regions and endpoints</a> in the Amazon Web Services General Reference.</p>
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        <p>The name of the Amazon Web Services service with which this access key was most recently used. The value of this field is 'N/A' in the following situations:</p> <ul> <li> <p>The user does not have an access key.</p> </li> <li> <p>An access key exists but has not been used since IAM started tracking this information.</p> </li> <li> <p>There is no sign-in data associated with the user.</p> </li> </ul>
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AwsIamAccessKeyMetadataPropertiesResponse(dict):
    """
    Definition of awsIamAccessKeyMetadata
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "createDate":
            suggest = "create_date"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamAccessKeyMetadataPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamAccessKeyMetadataPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamAccessKeyMetadataPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: Optional[str] = None,
                 create_date: Optional[str] = None,
                 status: Optional['outputs.StatusTypeEnumValueResponse'] = None,
                 user_name: Optional[str] = None):
        """
        Definition of awsIamAccessKeyMetadata
        :param str access_key_id: <p>The ID for this access key.</p>
        :param str create_date: <p>The date when the access key was created.</p>
        :param 'StatusTypeEnumValueResponse' status: <p>The status of the access key. <code>Active</code> means that the key is valid for API calls; <code>Inactive</code> means it is not.</p>
        :param str user_name: <p>The name of the IAM user that the key is associated with.</p>
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if create_date is not None:
            pulumi.set(__self__, "create_date", create_date)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        """
        <p>The ID for this access key.</p>
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="createDate")
    def create_date(self) -> Optional[str]:
        """
        <p>The date when the access key was created.</p>
        """
        return pulumi.get(self, "create_date")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.StatusTypeEnumValueResponse']:
        """
        <p>The status of the access key. <code>Active</code> means that the key is valid for API calls; <code>Inactive</code> means it is not.</p>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        <p>The name of the IAM user that the key is associated with.</p>
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class AwsIamGroupPropertiesResponse(dict):
    """
    Definition of awsIamGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "managedPolicyArns":
            suggest = "managed_policy_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 group_name: Optional[str] = None,
                 managed_policy_arns: Optional[Sequence[str]] = None,
                 path: Optional[str] = None,
                 policies: Optional[Sequence['outputs.PolicyResponse']] = None):
        """
        Definition of awsIamGroup
        :param str arn: Property arn
        :param str group_name: The name of the group to create. Do not include the path in this value. The group name must be unique within the account. Group names are not distinguished by case. For example, you cannot create groups named both 'ADMINS' and 'admins'. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the group name.  If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.  If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template's capabilities. For more information, see [Acknowledging Resources in Templates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities).  Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{'Fn::Join': ['', [{'Ref': 'AWS::Region'}, {'Ref': 'MyResourceName'}]]}``.
        :param Sequence[str] managed_policy_arns: The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the *General Reference*.
        :param str path: The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the *IAM User Guide*. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (``\\u0021``) through the DEL character (``\\u007F``), including most punctuation characters, digits, and upper and lowercased letters.
        :param Sequence['PolicyResponse'] policies: Adds or updates an inline policy document that is embedded in the specified IAM group. To view AWS::IAM::Group snippets, see [Declaring an Group Resource](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-iam-group).  The name of each inline policy for a role, user, or group must be unique. If you don't choose unique names, updates to the IAM identity will fail.   For information about limits on the number of inline policies that you can embed in a group, see [Limitations on Entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html) in the *User Guide*.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if managed_policy_arns is not None:
            pulumi.set(__self__, "managed_policy_arns", managed_policy_arns)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        The name of the group to create. Do not include the path in this value. The group name must be unique within the account. Group names are not distinguished by case. For example, you cannot create groups named both 'ADMINS' and 'admins'. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the group name.  If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.  If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template's capabilities. For more information, see [Acknowledging Resources in Templates](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-template.html#using-iam-capabilities).  Naming an IAM resource can cause an unrecoverable error if you reuse the same template in multiple Regions. To prevent this, we recommend using ``Fn::Join`` and ``AWS::Region`` to create a Region-specific name, as in the following example: ``{'Fn::Join': ['', [{'Ref': 'AWS::Region'}, {'Ref': 'MyResourceName'}]]}``.
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="managedPolicyArns")
    def managed_policy_arns(self) -> Optional[Sequence[str]]:
        """
        The Amazon Resource Name (ARN) of the IAM policy you want to attach. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the *General Reference*.
        """
        return pulumi.get(self, "managed_policy_arns")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the group. For more information about paths, see [IAM identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the *IAM User Guide*. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (``\\u0021``) through the DEL character (``\\u007F``), including most punctuation characters, digits, and upper and lowercased letters.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.PolicyResponse']]:
        """
        Adds or updates an inline policy document that is embedded in the specified IAM group. To view AWS::IAM::Group snippets, see [Declaring an Group Resource](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-iam.html#scenario-iam-group).  The name of each inline policy for a role, user, or group must be unique. If you don't choose unique names, updates to the IAM identity will fail.   For information about limits on the number of inline policies that you can embed in a group, see [Limitations on Entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html) in the *User Guide*.
        """
        return pulumi.get(self, "policies")


@pulumi.output_type
class AwsIamInstanceProfilePropertiesResponse(dict):
    """
    Definition of awsIamInstanceProfile
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceProfileName":
            suggest = "instance_profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamInstanceProfilePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamInstanceProfilePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamInstanceProfilePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 instance_profile_name: Optional[str] = None,
                 path: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        """
        Definition of awsIamInstanceProfile
        :param str arn: Property arn
        :param str instance_profile_name: The name of the instance profile to create. This parameter allows (through its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
        :param str path: The path to the instance profile. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the *IAM User Guide*. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (``\\u0021``) through the DEL character (``\\u007F``), including most punctuation characters, digits, and upper and lowercased letters.
        :param Sequence[str] roles: The name of the role to associate with the instance profile. Only one role can be assigned to an EC2 instance at a time, and all applications on the instance share the same role and permissions.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if instance_profile_name is not None:
            pulumi.set(__self__, "instance_profile_name", instance_profile_name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="instanceProfileName")
    def instance_profile_name(self) -> Optional[str]:
        """
        The name of the instance profile to create. This parameter allows (through its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-
        """
        return pulumi.get(self, "instance_profile_name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the instance profile. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the *IAM User Guide*. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (``\\u0021``) through the DEL character (``\\u007F``), including most punctuation characters, digits, and upper and lowercased letters.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        The name of the role to associate with the instance profile. Only one role can be assigned to an EC2 instance at a time, and all applications on the instance share the same role and permissions.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class AwsIamMFADevicePropertiesResponse(dict):
    """
    Definition of awsIamMFADevice
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableDate":
            suggest = "enable_date"
        elif key == "serialNumber":
            suggest = "serial_number"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamMFADevicePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamMFADevicePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamMFADevicePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_date: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        Definition of awsIamMFADevice
        :param str enable_date: <p>The date when the MFA device was enabled for the user.</p>
        :param str serial_number: <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN.</p>
        :param str user_name: <p>The user with whom the MFA device is associated.</p>
        """
        if enable_date is not None:
            pulumi.set(__self__, "enable_date", enable_date)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="enableDate")
    def enable_date(self) -> Optional[str]:
        """
        <p>The date when the MFA device was enabled for the user.</p>
        """
        return pulumi.get(self, "enable_date")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        """
        <p>The serial number that uniquely identifies the MFA device. For virtual MFA devices, the serial number is the device ARN.</p>
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        <p>The user with whom the MFA device is associated.</p>
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class AwsIamPasswordPolicyPropertiesResponse(dict):
    """
    Definition of awsIamPasswordPolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowUsersToChangePassword":
            suggest = "allow_users_to_change_password"
        elif key == "expirePasswords":
            suggest = "expire_passwords"
        elif key == "hardExpiry":
            suggest = "hard_expiry"
        elif key == "maxPasswordAge":
            suggest = "max_password_age"
        elif key == "minimumPasswordLength":
            suggest = "minimum_password_length"
        elif key == "passwordReusePrevention":
            suggest = "password_reuse_prevention"
        elif key == "requireLowercaseCharacters":
            suggest = "require_lowercase_characters"
        elif key == "requireNumbers":
            suggest = "require_numbers"
        elif key == "requireSymbols":
            suggest = "require_symbols"
        elif key == "requireUppercaseCharacters":
            suggest = "require_uppercase_characters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamPasswordPolicyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamPasswordPolicyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamPasswordPolicyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_users_to_change_password: Optional[bool] = None,
                 expire_passwords: Optional[bool] = None,
                 hard_expiry: Optional[bool] = None,
                 max_password_age: Optional[int] = None,
                 minimum_password_length: Optional[int] = None,
                 password_reuse_prevention: Optional[int] = None,
                 require_lowercase_characters: Optional[bool] = None,
                 require_numbers: Optional[bool] = None,
                 require_symbols: Optional[bool] = None,
                 require_uppercase_characters: Optional[bool] = None):
        """
        Definition of awsIamPasswordPolicy
        :param bool allow_users_to_change_password: <p>Specifies whether IAM users are allowed to change their own password. Gives IAM users permissions to <code>iam:ChangePassword</code> for only their user and to the <code>iam:GetAccountPasswordPolicy</code> action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM.</p>
        :param bool expire_passwords: <p>Indicates whether passwords in the account expire. Returns true if <code>MaxPasswordAge</code> contains a value greater than 0. Returns false if MaxPasswordAge is 0 or not present.</p>
        :param bool hard_expiry: <p>Specifies whether IAM users are prevented from setting a new password via the Amazon Web Services Management Console after their password has expired. The IAM user cannot access the console until an administrator resets the password. IAM users with <code>iam:ChangePassword</code> permission and active access keys can reset their own expired console password using the CLI or API.</p>
        :param int max_password_age: <p>The number of days that an IAM user password is valid.</p>
        :param int minimum_password_length: <p>Minimum length to require for IAM user passwords.</p>
        :param int password_reuse_prevention: <p>Specifies the number of previous passwords that IAM users are prevented from reusing.</p>
        :param bool require_lowercase_characters: <p>Specifies whether IAM user passwords must contain at least one lowercase character (a to z).</p>
        :param bool require_numbers: <p>Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).</p>
        :param bool require_symbols: <p>Specifies whether IAM user passwords must contain at least one of the following symbols:</p> <p>! @ # $ % ^ &amp; * ( ) _ + - = [ ] { } | '</p>
        :param bool require_uppercase_characters: <p>Specifies whether IAM user passwords must contain at least one uppercase character (A to Z).</p>
        """
        if allow_users_to_change_password is not None:
            pulumi.set(__self__, "allow_users_to_change_password", allow_users_to_change_password)
        if expire_passwords is not None:
            pulumi.set(__self__, "expire_passwords", expire_passwords)
        if hard_expiry is not None:
            pulumi.set(__self__, "hard_expiry", hard_expiry)
        if max_password_age is not None:
            pulumi.set(__self__, "max_password_age", max_password_age)
        if minimum_password_length is not None:
            pulumi.set(__self__, "minimum_password_length", minimum_password_length)
        if password_reuse_prevention is not None:
            pulumi.set(__self__, "password_reuse_prevention", password_reuse_prevention)
        if require_lowercase_characters is not None:
            pulumi.set(__self__, "require_lowercase_characters", require_lowercase_characters)
        if require_numbers is not None:
            pulumi.set(__self__, "require_numbers", require_numbers)
        if require_symbols is not None:
            pulumi.set(__self__, "require_symbols", require_symbols)
        if require_uppercase_characters is not None:
            pulumi.set(__self__, "require_uppercase_characters", require_uppercase_characters)

    @property
    @pulumi.getter(name="allowUsersToChangePassword")
    def allow_users_to_change_password(self) -> Optional[bool]:
        """
        <p>Specifies whether IAM users are allowed to change their own password. Gives IAM users permissions to <code>iam:ChangePassword</code> for only their user and to the <code>iam:GetAccountPasswordPolicy</code> action. This option does not attach a permissions policy to each user, rather the permissions are applied at the account-level for all users by IAM.</p>
        """
        return pulumi.get(self, "allow_users_to_change_password")

    @property
    @pulumi.getter(name="expirePasswords")
    def expire_passwords(self) -> Optional[bool]:
        """
        <p>Indicates whether passwords in the account expire. Returns true if <code>MaxPasswordAge</code> contains a value greater than 0. Returns false if MaxPasswordAge is 0 or not present.</p>
        """
        return pulumi.get(self, "expire_passwords")

    @property
    @pulumi.getter(name="hardExpiry")
    def hard_expiry(self) -> Optional[bool]:
        """
        <p>Specifies whether IAM users are prevented from setting a new password via the Amazon Web Services Management Console after their password has expired. The IAM user cannot access the console until an administrator resets the password. IAM users with <code>iam:ChangePassword</code> permission and active access keys can reset their own expired console password using the CLI or API.</p>
        """
        return pulumi.get(self, "hard_expiry")

    @property
    @pulumi.getter(name="maxPasswordAge")
    def max_password_age(self) -> Optional[int]:
        """
        <p>The number of days that an IAM user password is valid.</p>
        """
        return pulumi.get(self, "max_password_age")

    @property
    @pulumi.getter(name="minimumPasswordLength")
    def minimum_password_length(self) -> Optional[int]:
        """
        <p>Minimum length to require for IAM user passwords.</p>
        """
        return pulumi.get(self, "minimum_password_length")

    @property
    @pulumi.getter(name="passwordReusePrevention")
    def password_reuse_prevention(self) -> Optional[int]:
        """
        <p>Specifies the number of previous passwords that IAM users are prevented from reusing.</p>
        """
        return pulumi.get(self, "password_reuse_prevention")

    @property
    @pulumi.getter(name="requireLowercaseCharacters")
    def require_lowercase_characters(self) -> Optional[bool]:
        """
        <p>Specifies whether IAM user passwords must contain at least one lowercase character (a to z).</p>
        """
        return pulumi.get(self, "require_lowercase_characters")

    @property
    @pulumi.getter(name="requireNumbers")
    def require_numbers(self) -> Optional[bool]:
        """
        <p>Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).</p>
        """
        return pulumi.get(self, "require_numbers")

    @property
    @pulumi.getter(name="requireSymbols")
    def require_symbols(self) -> Optional[bool]:
        """
        <p>Specifies whether IAM user passwords must contain at least one of the following symbols:</p> <p>! @ # $ % ^ &amp; * ( ) _ + - = [ ] { } | '</p>
        """
        return pulumi.get(self, "require_symbols")

    @property
    @pulumi.getter(name="requireUppercaseCharacters")
    def require_uppercase_characters(self) -> Optional[bool]:
        """
        <p>Specifies whether IAM user passwords must contain at least one uppercase character (A to Z).</p>
        """
        return pulumi.get(self, "require_uppercase_characters")


@pulumi.output_type
class AwsIamPolicyVersionPropertiesResponse(dict):
    """
    Definition of awsIamPolicyVersion
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createDate":
            suggest = "create_date"
        elif key == "isDefaultVersion":
            suggest = "is_default_version"
        elif key == "versionId":
            suggest = "version_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamPolicyVersionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamPolicyVersionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamPolicyVersionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_date: Optional[str] = None,
                 document: Optional[str] = None,
                 is_default_version: Optional[bool] = None,
                 version_id: Optional[str] = None):
        """
        Definition of awsIamPolicyVersion
        :param str create_date: <p>The date and time, in <a href='http://www.iso.org/iso/iso8601'>ISO 8601 date-time format</a>, when the policy version was created.</p>
        :param str document: <p>The policy document.</p> <p>The policy document is returned in the response to the <a>GetPolicyVersion</a> and <a>GetAccountAuthorizationDetails</a> operations. It is not returned in the response to the <a>CreatePolicyVersion</a> or <a>ListPolicyVersions</a> operations. </p> <p>The policy document returned in this structure is URL-encoded compliant with <a href='https://tools.ietf.org/html/rfc3986'>RFC 3986</a>. You can use a URL decoding method to convert the policy back to plain JSON text. For example, if you use Java, you can use the <code>decode</code> method of the <code>java.net.URLDecoder</code> utility class in the Java SDK. Other languages and SDKs provide similar functionality.</p>
        :param bool is_default_version: <p>Specifies whether the policy version is set as the policy's default version.</p>
        :param str version_id: <p>The identifier for the policy version.</p> <p>Policy version identifiers always begin with <code>v</code> (always lowercase). When a policy is created, the first policy version is <code>v1</code>. </p>
        """
        if create_date is not None:
            pulumi.set(__self__, "create_date", create_date)
        if document is not None:
            pulumi.set(__self__, "document", document)
        if is_default_version is not None:
            pulumi.set(__self__, "is_default_version", is_default_version)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="createDate")
    def create_date(self) -> Optional[str]:
        """
        <p>The date and time, in <a href='http://www.iso.org/iso/iso8601'>ISO 8601 date-time format</a>, when the policy version was created.</p>
        """
        return pulumi.get(self, "create_date")

    @property
    @pulumi.getter
    def document(self) -> Optional[str]:
        """
        <p>The policy document.</p> <p>The policy document is returned in the response to the <a>GetPolicyVersion</a> and <a>GetAccountAuthorizationDetails</a> operations. It is not returned in the response to the <a>CreatePolicyVersion</a> or <a>ListPolicyVersions</a> operations. </p> <p>The policy document returned in this structure is URL-encoded compliant with <a href='https://tools.ietf.org/html/rfc3986'>RFC 3986</a>. You can use a URL decoding method to convert the policy back to plain JSON text. For example, if you use Java, you can use the <code>decode</code> method of the <code>java.net.URLDecoder</code> utility class in the Java SDK. Other languages and SDKs provide similar functionality.</p>
        """
        return pulumi.get(self, "document")

    @property
    @pulumi.getter(name="isDefaultVersion")
    def is_default_version(self) -> Optional[bool]:
        """
        <p>Specifies whether the policy version is set as the policy's default version.</p>
        """
        return pulumi.get(self, "is_default_version")

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[str]:
        """
        <p>The identifier for the policy version.</p> <p>Policy version identifiers always begin with <code>v</code> (always lowercase). When a policy is created, the first policy version is <code>v1</code>. </p>
        """
        return pulumi.get(self, "version_id")


@pulumi.output_type
class AwsIamRolePropertiesResponse(dict):
    """
    Definition of awsIamRole
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assumeRolePolicyDocument":
            suggest = "assume_role_policy_document"
        elif key == "managedPolicyArns":
            suggest = "managed_policy_arns"
        elif key == "maxSessionDuration":
            suggest = "max_session_duration"
        elif key == "permissionsBoundary":
            suggest = "permissions_boundary"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamRolePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamRolePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamRolePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 assume_role_policy_document: Optional[Any] = None,
                 description: Optional[str] = None,
                 managed_policy_arns: Optional[Sequence[str]] = None,
                 max_session_duration: Optional[int] = None,
                 path: Optional[str] = None,
                 permissions_boundary: Optional[str] = None,
                 policies: Optional[Sequence['outputs.PolicyResponse']] = None,
                 role_id: Optional[str] = None,
                 role_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsIamRole
        :param str arn: Property arn
        :param Any assume_role_policy_document: The trust policy that is associated with this role. Trust policies define which entities can assume the role. You can associate only one trust policy with a role. For an example of a policy that can be used to assume a role, see [Template Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#aws-resource-iam-role--examples). For more information about the elements that you can use in an IAM policy, see [Policy Elements Reference](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html) in the *User Guide*.
        :param str description: A description of the role that you provide.
        :param Sequence[str] managed_policy_arns: A list of Amazon Resource Names (ARNs) of the IAM managed policies that you want to attach to the role. For more information about ARNs, see [Amazon Resource Names (ARNs) and Service Namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the *General Reference*.
        :param int max_session_duration: The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the ``DurationSeconds`` API parameter or the ``duration-seconds`` CLI parameter to request a longer session. The ``MaxSessionDuration`` setting determines the maximum duration that can be requested using the ``DurationSeconds`` parameter. If users don't specify a value for the ``DurationSeconds`` parameter, their security credentials are valid for one hour by default. This applies when you use the ``AssumeRole*`` API operations or the ``assume-role*`` CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the *IAM User Guide*.
        :param str path: The path to the role. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the *IAM User Guide*. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (``\\u0021``) through the DEL character (``\\u007F``), including most punctuation characters, digits, and upper and lowercased letters.
        :param str permissions_boundary: The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the *IAM User Guide*.
        :param Sequence['PolicyResponse'] policies: Adds or updates an inline policy document that is embedded in the specified IAM role. When you embed an inline policy in a role, the inline policy is used as part of the role's access (permissions) policy. The role's trust policy is created at the same time as the role. You can update a role's trust policy later. For more information about IAM roles, go to [Using Roles to Delegate Permissions and Federate Identities](https://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html). A role can also have an attached managed policy. For information about policies, see [Managed Policies and Inline Policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the *User Guide*. For information about limits on the number of inline policies that you can embed with a role, see [Limitations on Entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html) in the *User Guide*.  If an external policy (such as ``AWS::IAM::Policy`` or
        :param str role_id: Property roleId
        :param str role_name: A name for the IAM role, up to 64 characters in length. For valid values, see the ``RoleName`` parameter for the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) action in the *User Guide*. This parameter allows (per its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-. The role name must be unique within the account. Role names are not distinguished by case. For example, you cannot create roles named both 'Role1' and 'role1'. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the role name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template's capabilities. For more information, see [Acknowledging Resources in Templates](https://docs.aws.amazon.com/AWSCloudFormation/latest/Use
        :param Sequence['TagResponse'] tags: A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the *IAM User Guide*.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if assume_role_policy_document is not None:
            pulumi.set(__self__, "assume_role_policy_document", assume_role_policy_document)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if managed_policy_arns is not None:
            pulumi.set(__self__, "managed_policy_arns", managed_policy_arns)
        if max_session_duration is not None:
            pulumi.set(__self__, "max_session_duration", max_session_duration)
        if path is None:
            path = '/'
        if path is not None:
            pulumi.set(__self__, "path", path)
        if permissions_boundary is not None:
            pulumi.set(__self__, "permissions_boundary", permissions_boundary)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="assumeRolePolicyDocument")
    def assume_role_policy_document(self) -> Optional[Any]:
        """
        The trust policy that is associated with this role. Trust policies define which entities can assume the role. You can associate only one trust policy with a role. For an example of a policy that can be used to assume a role, see [Template Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html#aws-resource-iam-role--examples). For more information about the elements that you can use in an IAM policy, see [Policy Elements Reference](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html) in the *User Guide*.
        """
        return pulumi.get(self, "assume_role_policy_document")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the role that you provide.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="managedPolicyArns")
    def managed_policy_arns(self) -> Optional[Sequence[str]]:
        """
        A list of Amazon Resource Names (ARNs) of the IAM managed policies that you want to attach to the role. For more information about ARNs, see [Amazon Resource Names (ARNs) and Service Namespaces](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the *General Reference*.
        """
        return pulumi.get(self, "managed_policy_arns")

    @property
    @pulumi.getter(name="maxSessionDuration")
    def max_session_duration(self) -> Optional[int]:
        """
        The maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default value of one hour is applied. This setting can have a value from 1 hour to 12 hours. Anyone who assumes the role from the CLI or API can use the ``DurationSeconds`` API parameter or the ``duration-seconds`` CLI parameter to request a longer session. The ``MaxSessionDuration`` setting determines the maximum duration that can be requested using the ``DurationSeconds`` parameter. If users don't specify a value for the ``DurationSeconds`` parameter, their security credentials are valid for one hour by default. This applies when you use the ``AssumeRole*`` API operations or the ``assume-role*`` CLI operations but does not apply when you use those operations to create a console URL. For more information, see [Using IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) in the *IAM User Guide*.
        """
        return pulumi.get(self, "max_session_duration")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the role. For more information about paths, see [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) in the *IAM User Guide*. This parameter is optional. If it is not included, it defaults to a slash (/). This parameter allows (through its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of either a forward slash (/) by itself or a string that must begin and end with forward slashes. In addition, it can contain any ASCII character from the ! (``\\u0021``) through the DEL character (``\\u007F``), including most punctuation characters, digits, and upper and lowercased letters.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="permissionsBoundary")
    def permissions_boundary(self) -> Optional[str]:
        """
        The ARN of the policy used to set the permissions boundary for the role. For more information about permissions boundaries, see [Permissions boundaries for IAM identities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the *IAM User Guide*.
        """
        return pulumi.get(self, "permissions_boundary")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.PolicyResponse']]:
        """
        Adds or updates an inline policy document that is embedded in the specified IAM role. When you embed an inline policy in a role, the inline policy is used as part of the role's access (permissions) policy. The role's trust policy is created at the same time as the role. You can update a role's trust policy later. For more information about IAM roles, go to [Using Roles to Delegate Permissions and Federate Identities](https://docs.aws.amazon.com/IAM/latest/UserGuide/roles-toplevel.html). A role can also have an attached managed policy. For information about policies, see [Managed Policies and Inline Policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/policies-managed-vs-inline.html) in the *User Guide*. For information about limits on the number of inline policies that you can embed with a role, see [Limitations on Entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/LimitationsOnEntities.html) in the *User Guide*.  If an external policy (such as ``AWS::IAM::Policy`` or
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[str]:
        """
        Property roleId
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[str]:
        """
        A name for the IAM role, up to 64 characters in length. For valid values, see the ``RoleName`` parameter for the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) action in the *User Guide*. This parameter allows (per its [regex pattern](https://docs.aws.amazon.com/http://wikipedia.org/wiki/regex)) a string of characters consisting of upper and lowercase alphanumeric characters with no spaces. You can also include any of the following characters: _+=,.@-. The role name must be unique within the account. Role names are not distinguished by case. For example, you cannot create roles named both 'Role1' and 'role1'. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the role name. If you specify a name, you must specify the ``CAPABILITY_NAMED_IAM`` value to acknowledge your template's capabilities. For more information, see [Acknowledging Resources in Templates](https://docs.aws.amazon.com/AWSCloudFormation/latest/Use
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        A list of tags that are attached to the role. For more information about tagging, see [Tagging IAM resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_tags.html) in the *IAM User Guide*.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsIamServerCertificatePropertiesResponse(dict):
    """
    Definition of awsIamServerCertificate
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateBody":
            suggest = "certificate_body"
        elif key == "certificateChain":
            suggest = "certificate_chain"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "serverCertificateName":
            suggest = "server_certificate_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamServerCertificatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamServerCertificatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamServerCertificatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 certificate_body: Optional[str] = None,
                 certificate_chain: Optional[str] = None,
                 path: Optional[str] = None,
                 private_key: Optional[str] = None,
                 server_certificate_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsIamServerCertificate
        :param str arn: Amazon Resource Name (ARN) of the server certificate
        :param str certificate_body: Property certificateBody
        :param str certificate_chain: Property certificateChain
        :param str path: Property path
        :param str private_key: Property privateKey
        :param str server_certificate_name: Property serverCertificateName
        :param Sequence['TagResponse'] tags: Property tags
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if certificate_body is not None:
            pulumi.set(__self__, "certificate_body", certificate_body)
        if certificate_chain is not None:
            pulumi.set(__self__, "certificate_chain", certificate_chain)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if server_certificate_name is not None:
            pulumi.set(__self__, "server_certificate_name", server_certificate_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the server certificate
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="certificateBody")
    def certificate_body(self) -> Optional[str]:
        """
        Property certificateBody
        """
        return pulumi.get(self, "certificate_body")

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> Optional[str]:
        """
        Property certificateChain
        """
        return pulumi.get(self, "certificate_chain")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Property path
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        Property privateKey
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="serverCertificateName")
    def server_certificate_name(self) -> Optional[str]:
        """
        Property serverCertificateName
        """
        return pulumi.get(self, "server_certificate_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsIamVirtualMFADevicePropertiesResponse(dict):
    """
    Definition of awsIamVirtualMFADevice
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serialNumber":
            suggest = "serial_number"
        elif key == "virtualMfaDeviceName":
            suggest = "virtual_mfa_device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsIamVirtualMFADevicePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsIamVirtualMFADevicePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsIamVirtualMFADevicePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 users: Optional[Sequence[str]] = None,
                 virtual_mfa_device_name: Optional[str] = None):
        """
        Definition of awsIamVirtualMFADevice
        :param str path: Property path
        :param str serial_number: Property serialNumber
        :param Sequence['TagResponse'] tags: Property tags
        :param Sequence[str] users: Property users
        :param str virtual_mfa_device_name: Property virtualMfaDeviceName
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if virtual_mfa_device_name is not None:
            pulumi.set(__self__, "virtual_mfa_device_name", virtual_mfa_device_name)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Property path
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[str]:
        """
        Property serialNumber
        """
        return pulumi.get(self, "serial_number")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence[str]]:
        """
        Property users
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="virtualMfaDeviceName")
    def virtual_mfa_device_name(self) -> Optional[str]:
        """
        Property virtualMfaDeviceName
        """
        return pulumi.get(self, "virtual_mfa_device_name")


@pulumi.output_type
class AwsKmsAliasPropertiesResponse(dict):
    """
    Definition of awsKmsAlias
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasName":
            suggest = "alias_name"
        elif key == "targetKeyId":
            suggest = "target_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsKmsAliasPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsKmsAliasPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsKmsAliasPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_name: Optional[str] = None,
                 target_key_id: Optional[str] = None):
        """
        Definition of awsKmsAlias
        :param str alias_name: Specifies the alias name. This value must begin with ``alias/`` followed by a name, such as ``alias/ExampleAlias``.   If you change the value of the ``AliasName`` property, the existing alias is deleted and a new alias is created for the specified KMS key. This change can disrupt applications that use the alias. It can also allow or deny access to a KMS key affected by attribute-based access control (ABAC).  The alias must be string of 1-256 characters. It can contain only alphanumeric characters, forward slashes (/), underscores (_), and dashes (-). The alias name cannot begin with ``alias/aws/``. The ``alias/aws/`` prefix is reserved for [](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
        :param str target_key_id: Associates the alias with the specified [](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk). The KMS key must be in the same AWS-account and Region. A valid key ID is required. If you supply a null or empty string value, this operation returns an error. For help finding the key ID and ARN, see [Finding the key ID and ARN](https://docs.aws.amazon.com/kms/latest/developerguide/viewing-keys.html#find-cmk-id-arn) in the *Developer Guide*. Specify the key ID or the key ARN of the KMS key. For example:  +  Key ID: ``1234abcd-12ab-34cd-56ef-1234567890ab``   +  Key ARN: ``arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab``    To get the key ID and key ARN for a KMS key, use [ListKeys](https://docs.aws.amazon.com/kms/latest/APIReference/API_ListKeys.html) or [DescribeKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html).
        """
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)
        if target_key_id is not None:
            pulumi.set(__self__, "target_key_id", target_key_id)

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        """
        Specifies the alias name. This value must begin with ``alias/`` followed by a name, such as ``alias/ExampleAlias``.   If you change the value of the ``AliasName`` property, the existing alias is deleted and a new alias is created for the specified KMS key. This change can disrupt applications that use the alias. It can also allow or deny access to a KMS key affected by attribute-based access control (ABAC).  The alias must be string of 1-256 characters. It can contain only alphanumeric characters, forward slashes (/), underscores (_), and dashes (-). The alias name cannot begin with ``alias/aws/``. The ``alias/aws/`` prefix is reserved for [](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
        """
        return pulumi.get(self, "alias_name")

    @property
    @pulumi.getter(name="targetKeyId")
    def target_key_id(self) -> Optional[str]:
        """
        Associates the alias with the specified [](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#customer-cmk). The KMS key must be in the same AWS-account and Region. A valid key ID is required. If you supply a null or empty string value, this operation returns an error. For help finding the key ID and ARN, see [Finding the key ID and ARN](https://docs.aws.amazon.com/kms/latest/developerguide/viewing-keys.html#find-cmk-id-arn) in the *Developer Guide*. Specify the key ID or the key ARN of the KMS key. For example:  +  Key ID: ``1234abcd-12ab-34cd-56ef-1234567890ab``   +  Key ARN: ``arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab``    To get the key ID and key ARN for a KMS key, use [ListKeys](https://docs.aws.amazon.com/kms/latest/APIReference/API_ListKeys.html) or [DescribeKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html).
        """
        return pulumi.get(self, "target_key_id")


@pulumi.output_type
class AwsKmsKeyPropertiesResponse(dict):
    """
    Definition of awsKmsKey
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bypassPolicyLockoutSafetyCheck":
            suggest = "bypass_policy_lockout_safety_check"
        elif key == "enableKeyRotation":
            suggest = "enable_key_rotation"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "keyPolicy":
            suggest = "key_policy"
        elif key == "keySpec":
            suggest = "key_spec"
        elif key == "keyUsage":
            suggest = "key_usage"
        elif key == "multiRegion":
            suggest = "multi_region"
        elif key == "pendingWindowInDays":
            suggest = "pending_window_in_days"
        elif key == "rotationPeriodInDays":
            suggest = "rotation_period_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsKmsKeyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsKmsKeyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsKmsKeyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 bypass_policy_lockout_safety_check: Optional[bool] = None,
                 description: Optional[str] = None,
                 enable_key_rotation: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 key_id: Optional[str] = None,
                 key_policy: Optional[Any] = None,
                 key_spec: Optional[str] = None,
                 key_usage: Optional[str] = None,
                 multi_region: Optional[bool] = None,
                 origin: Optional[str] = None,
                 pending_window_in_days: Optional[int] = None,
                 rotation_period_in_days: Optional[int] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsKmsKey
        :param str arn: Property arn
        :param bool bypass_policy_lockout_safety_check: Skips ('bypasses') the key policy lockout safety check. The default value is false.  Setting this value to true increases the risk that the KMS key becomes unmanageable. Do not set this value to true indiscriminately. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-default.html#prevent-unmanageable-key) in the *Developer Guide*.  Use this parameter only when you intend to prevent the principal that is making the request from making a subsequent [PutKeyPolicy](https://docs.aws.amazon.com/kms/latest/APIReference/API_PutKeyPolicy.html) request on the KMS key.
        :param str description: A description of the KMS key. Use a description that helps you to distinguish this KMS key from others in the account, such as its intended use.
        :param bool enable_key_rotation: Enables automatic rotation of the key material for the specified KMS key. By default, automatic key rotation is not enabled.  KMS supports automatic rotation only for symmetric encryption KMS keys (``KeySpec`` = ``SYMMETRIC_DEFAULT``). For asymmetric KMS keys, HMAC KMS keys, and KMS keys with Origin ``EXTERNAL``, omit the ``EnableKeyRotation`` property or set it to ``false``. To enable automatic key rotation of the key material for a multi-Region KMS key, set ``EnableKeyRotation`` to ``true`` on the primary key (created by using ``AWS::KMS::Key``). KMS copies the rotation status to all replica keys. For details, see [Rotating multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-manage.html#multi-region-rotate) in the *Developer Guide*. When you enable automatic rotation, KMS automatically creates new key material for the KMS key one year after the enable date and every year thereafter. KMS retains all key material until you delete the KMS key. For detailed information about automatic key rotation, see [Rotating KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html) in the *Developer Guide*.
        :param bool enabled: Specifies whether the KMS key is enabled. Disabled KMS keys cannot be used in cryptographic operations. When ``Enabled`` is ``true``, the *key state* of the KMS key is ``Enabled``. When ``Enabled`` is ``false``, the key state of the KMS key is ``Disabled``. The default value is ``true``. The actual key state of the KMS key might be affected by actions taken outside of CloudFormation, such as running the [EnableKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_EnableKey.html), [DisableKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DisableKey.html), or [ScheduleKeyDeletion](https://docs.aws.amazon.com/kms/latest/APIReference/API_ScheduleKeyDeletion.html) operations. For information about the key states of a KMS key, see [Key state: Effect on your KMS key](https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html) in the *Developer Guide*.
        :param str key_id: Property keyId
        :param Any key_policy: The key policy to attach to the KMS key. If you provide a key policy, it must meet the following criteria:  +  The key policy must allow the caller to make a subsequent [PutKeyPolicy](https://docs.aws.amazon.com/kms/latest/APIReference/API_PutKeyPolicy.html) request on the KMS key. This reduces the risk that the KMS key becomes unmanageable. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam) in the *Developer Guide*. (To omit this condition, set ``BypassPolicyLockoutSafetyCheck`` to true.)  +  Each statement in the key policy must contain one or more principals. The principals in the key policy must exist and be visible to KMS. When you create a new AWS principal (for example, an IAM user or role), you might need to enforce a delay before including the new principal in a key policy because the new principal might not be immediately visible to KMS. For more information, see [Changes that I make are not always immediately visible](https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_general.html#troubleshoot_general_eventual-consistency) in the *User Guide*.   If you do not provide a key policy, KMS attaches a default key policy to the KMS key. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default) in the *Developer Guide*. A key policy document can include only the following characters:  +  Printable ASCII characters  +  Printable characters in the Basic Latin and Latin-1 Supplement character set  +  The tab (``\\u0009``), line feed (``\\u000A``), and carriage return (``\\u000D``) special characters    *Minimum*: ``1``   *Maximum*: ``32768``
        :param str key_spec: Specifies the type of KMS key to create. The default value, ``SYMMETRIC_DEFAULT``, creates a KMS key with a 256-bit symmetric key for encryption and decryption. In China Regions, ``SYMMETRIC_DEFAULT`` creates a 128-bit symmetric key that uses SM4 encryption. You can't change the ``KeySpec`` value after the KMS key is created. For help choosing a key spec for your KMS key, see [Choosing a KMS key type](https://docs.aws.amazon.com/kms/latest/developerguide/symm-asymm-choose.html) in the *Developer Guide*. The ``KeySpec`` property determines the type of key material in the KMS key and the algorithms that the KMS key supports. To further restrict the algorithms that can be used with the KMS key, use a condition key in its key policy or IAM policy. For more information, see [condition keys](https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms) in the *Developer Guide*.  If you change the value of the ``KeySpec`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.    [services that are integrated with](https://docs.aws.amazon.com/kms/features/#AWS_Service_Integration) use symmetric encryption KMS keys to protect your data. These services do not support encryption with asymmetric KMS keys. For help determining whether a KMS key is asymmetric, see [Identifying asymmetric KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/find-symm-asymm.html) in the *Developer Guide*.   KMS supports the following key specs for KMS keys:  +  Symmetric encryption key (default)  +   ``SYMMETRIC_DEFAULT`` (AES-256-GCM)    +  HMAC keys (symmetric)  +   ``HMAC_224``   +   ``HMAC_256``   +   ``HMAC_384``   +   ``HMAC_512``     +  Asymmetric RSA key pairs  +   ``RSA_2048``   +   ``RSA_3072``   +   ``RSA_4096``     +  Asymmetric NIST-recommended elliptic curve key pairs  +   ``ECC_NIST_P256`` (secp256r1)  +   ``ECC_NIST_P384`` (secp384r1)  +   ``ECC_NIST_P521`` (secp521r1)    +  Other asymmetric elliptic curve key pairs  +   ``ECC_SECG_P256K1`` (secp256k1), commonly used for cryptocurrencies.    +  SM2 key pairs (China Regions only)  +   ``SM2``
        :param str key_usage: Determines the [cryptographic operations](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) for which you can use the KMS key. The default value is ``ENCRYPT_DECRYPT``. This property is required for asymmetric KMS keys and HMAC KMS keys. You can't change the ``KeyUsage`` value after the KMS key is created.  If you change the value of the ``KeyUsage`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.  Select only one valid value.  +  For symmetric encryption KMS keys, omit the property or specify ``ENCRYPT_DECRYPT``.  +  For asymmetric KMS keys with RSA key material, specify ``ENCRYPT_DECRYPT`` or ``SIGN_VERIFY``.  +  For asymmetric KMS keys with ECC key material, specify ``SIGN_VERIFY``.  +  For asymmetric KMS keys with SM2 (China Regions only) key material, specify ``ENCRYPT_DECRYPT`` or ``SIGN_VERIFY``.  +  For HMAC KMS keys, specify ``GENERATE_VERIFY_MAC``.
        :param bool multi_region: Creates a multi-Region primary key that you can replicate in other AWS-Regions. You can't change the ``MultiRegion`` value after the KMS key is created. For a list of AWS-Regions in which multi-Region keys are supported, see [Multi-Region keys in](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the **.  If you change the value of the ``MultiRegion`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.  For a multi-Region key, set to this property to ``true``. For a single-Region key, omit this property or set it to ``false``. The default value is ``false``.  *Multi-Region keys* are an KMS feature that lets you create multiple interoperable KMS keys in different AWS-Regions. Because these KMS keys have the same key ID, key material, and other metadata, you can use them to encrypt data in one AWS-Region and decrypt it in a different AWS-Region without making a cross-Region call or exposing the plaintext data. For more information, see [Multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the *Developer Guide*. You can create a symmetric encryption, HMAC, or asymmetric multi-Region KMS key, and you can create a multi-Region key with imported key material. However, you cannot create a multi-Region key in a custom key store. To create a replica of this primary key in a different AWS-Region , create an [AWS::KMS::ReplicaKey](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-replicakey.html) resource in a CloudFormation stack in the replica Region. Specify the key ARN of this primary key.
        :param str origin: The source of the key material for the KMS key. You cannot change the origin after you create the KMS key. The default is ``AWS_KMS``, which means that KMS creates the key material. To [create a KMS key with no key material](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys-create-cmk.html) (for imported key material), set this value to ``EXTERNAL``. For more information about importing key material into KMS, see [Importing Key Material](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html) in the *Developer Guide*. You can ignore ``ENABLED`` when Origin is ``EXTERNAL``. When a KMS key with Origin ``EXTERNAL`` is created, the key state is ``PENDING_IMPORT`` and ``ENABLED`` is ``false``. After you import the key material, ``ENABLED`` updated to ``true``. The KMS key can then be used for Cryptographic Operations.    CFN doesn't support creating an ``Origin`` parameter of the ``AWS_CLOUDHSM`` or ``EXTERNAL_KEY_STORE`` values.
        :param int pending_window_in_days: Specifies the number of days in the waiting period before KMS deletes a KMS key that has been removed from a CloudFormation stack. Enter a value between 7 and 30 days. The default value is 30 days. When you remove a KMS key from a CloudFormation stack, KMS schedules the KMS key for deletion and starts the mandatory waiting period. The ``PendingWindowInDays`` property determines the length of waiting period. During the waiting period, the key state of KMS key is ``Pending Deletion`` or ``Pending Replica Deletion``, which prevents the KMS key from being used in cryptographic operations. When the waiting period expires, KMS permanently deletes the KMS key.  KMS will not delete a [multi-Region primary key](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) that has replica keys. If you remove a multi-Region primary key from a CloudFormation stack, its key state changes to ``PendingReplicaDeletion`` so it cannot be replicated or used in cryptographic operations. This state can persist indefinitely. When the last of its replica keys is deleted, the key state of the primary key changes to ``PendingDeletion`` and the waiting period specified by ``PendingWindowInDays`` begins. When this waiting period expires, KMS deletes the primary key. For details, see [Deleting multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-delete.html) in the *Developer Guide*. You cannot use a CloudFormation template to cancel deletion of the KMS key after you remove it from the stack, regardless of the waiting period. If you specify a KMS key in your template, even one with the same name, CloudFormation creates a new KMS key. To cancel deletion of a KMS key, use the KMS console or the [CancelKeyDeletion](https://docs.aws.amazon.com/kms/latest/APIReference/API_CancelKeyDeletion.html) operation. For information about the ``Pending Deletion`` and ``Pending Replica Deletion`` key states, see [Key state: Effect on your KMS key](https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html) in the *Developer Guide*. For more information about deleting KMS keys, see the [ScheduleKeyDeletion](https://docs.aws.amazon.com/kms/latest/APIReference/API_ScheduleKeyDeletion.html) operation in the *API Reference* and [Deleting KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/deleting-keys.html) in the *Developer Guide*.
        :param int rotation_period_in_days: Property rotationPeriodInDays
        :param Sequence['TagResponse'] tags: Assigns one or more tags to the replica key.  Tagging or untagging a KMS key can allow or deny permission to the KMS key. For details, see [ABAC for](https://docs.aws.amazon.com/kms/latest/developerguide/abac.html) in the *Developer Guide*.  For information about tags in KMS, see [Tagging keys](https://docs.aws.amazon.com/kms/latest/developerguide/tagging-keys.html) in the *Developer Guide*. For information about tags in CloudFormation, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if bypass_policy_lockout_safety_check is not None:
            pulumi.set(__self__, "bypass_policy_lockout_safety_check", bypass_policy_lockout_safety_check)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_key_rotation is not None:
            pulumi.set(__self__, "enable_key_rotation", enable_key_rotation)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if key_policy is not None:
            pulumi.set(__self__, "key_policy", key_policy)
        if key_spec is None:
            key_spec = 'SYMMETRIC_DEFAULT'
        if key_spec is not None:
            pulumi.set(__self__, "key_spec", key_spec)
        if key_usage is None:
            key_usage = 'ENCRYPT_DECRYPT'
        if key_usage is not None:
            pulumi.set(__self__, "key_usage", key_usage)
        if multi_region is not None:
            pulumi.set(__self__, "multi_region", multi_region)
        if origin is None:
            origin = 'AWS_KMS'
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if pending_window_in_days is not None:
            pulumi.set(__self__, "pending_window_in_days", pending_window_in_days)
        if rotation_period_in_days is None:
            rotation_period_in_days = 365
        if rotation_period_in_days is not None:
            pulumi.set(__self__, "rotation_period_in_days", rotation_period_in_days)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="bypassPolicyLockoutSafetyCheck")
    def bypass_policy_lockout_safety_check(self) -> Optional[bool]:
        """
        Skips ('bypasses') the key policy lockout safety check. The default value is false.  Setting this value to true increases the risk that the KMS key becomes unmanageable. Do not set this value to true indiscriminately. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-default.html#prevent-unmanageable-key) in the *Developer Guide*.  Use this parameter only when you intend to prevent the principal that is making the request from making a subsequent [PutKeyPolicy](https://docs.aws.amazon.com/kms/latest/APIReference/API_PutKeyPolicy.html) request on the KMS key.
        """
        return pulumi.get(self, "bypass_policy_lockout_safety_check")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the KMS key. Use a description that helps you to distinguish this KMS key from others in the account, such as its intended use.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableKeyRotation")
    def enable_key_rotation(self) -> Optional[bool]:
        """
        Enables automatic rotation of the key material for the specified KMS key. By default, automatic key rotation is not enabled.  KMS supports automatic rotation only for symmetric encryption KMS keys (``KeySpec`` = ``SYMMETRIC_DEFAULT``). For asymmetric KMS keys, HMAC KMS keys, and KMS keys with Origin ``EXTERNAL``, omit the ``EnableKeyRotation`` property or set it to ``false``. To enable automatic key rotation of the key material for a multi-Region KMS key, set ``EnableKeyRotation`` to ``true`` on the primary key (created by using ``AWS::KMS::Key``). KMS copies the rotation status to all replica keys. For details, see [Rotating multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-manage.html#multi-region-rotate) in the *Developer Guide*. When you enable automatic rotation, KMS automatically creates new key material for the KMS key one year after the enable date and every year thereafter. KMS retains all key material until you delete the KMS key. For detailed information about automatic key rotation, see [Rotating KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html) in the *Developer Guide*.
        """
        return pulumi.get(self, "enable_key_rotation")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether the KMS key is enabled. Disabled KMS keys cannot be used in cryptographic operations. When ``Enabled`` is ``true``, the *key state* of the KMS key is ``Enabled``. When ``Enabled`` is ``false``, the key state of the KMS key is ``Disabled``. The default value is ``true``. The actual key state of the KMS key might be affected by actions taken outside of CloudFormation, such as running the [EnableKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_EnableKey.html), [DisableKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DisableKey.html), or [ScheduleKeyDeletion](https://docs.aws.amazon.com/kms/latest/APIReference/API_ScheduleKeyDeletion.html) operations. For information about the key states of a KMS key, see [Key state: Effect on your KMS key](https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html) in the *Developer Guide*.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        Property keyId
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter(name="keyPolicy")
    def key_policy(self) -> Optional[Any]:
        """
        The key policy to attach to the KMS key. If you provide a key policy, it must meet the following criteria:  +  The key policy must allow the caller to make a subsequent [PutKeyPolicy](https://docs.aws.amazon.com/kms/latest/APIReference/API_PutKeyPolicy.html) request on the KMS key. This reduces the risk that the KMS key becomes unmanageable. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default-allow-root-enable-iam) in the *Developer Guide*. (To omit this condition, set ``BypassPolicyLockoutSafetyCheck`` to true.)  +  Each statement in the key policy must contain one or more principals. The principals in the key policy must exist and be visible to KMS. When you create a new AWS principal (for example, an IAM user or role), you might need to enforce a delay before including the new principal in a key policy because the new principal might not be immediately visible to KMS. For more information, see [Changes that I make are not always immediately visible](https://docs.aws.amazon.com/IAM/latest/UserGuide/troubleshoot_general.html#troubleshoot_general_eventual-consistency) in the *User Guide*.   If you do not provide a key policy, KMS attaches a default key policy to the KMS key. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default) in the *Developer Guide*. A key policy document can include only the following characters:  +  Printable ASCII characters  +  Printable characters in the Basic Latin and Latin-1 Supplement character set  +  The tab (``\\u0009``), line feed (``\\u000A``), and carriage return (``\\u000D``) special characters    *Minimum*: ``1``   *Maximum*: ``32768``
        """
        return pulumi.get(self, "key_policy")

    @property
    @pulumi.getter(name="keySpec")
    def key_spec(self) -> Optional[str]:
        """
        Specifies the type of KMS key to create. The default value, ``SYMMETRIC_DEFAULT``, creates a KMS key with a 256-bit symmetric key for encryption and decryption. In China Regions, ``SYMMETRIC_DEFAULT`` creates a 128-bit symmetric key that uses SM4 encryption. You can't change the ``KeySpec`` value after the KMS key is created. For help choosing a key spec for your KMS key, see [Choosing a KMS key type](https://docs.aws.amazon.com/kms/latest/developerguide/symm-asymm-choose.html) in the *Developer Guide*. The ``KeySpec`` property determines the type of key material in the KMS key and the algorithms that the KMS key supports. To further restrict the algorithms that can be used with the KMS key, use a condition key in its key policy or IAM policy. For more information, see [condition keys](https://docs.aws.amazon.com/kms/latest/developerguide/policy-conditions.html#conditions-kms) in the *Developer Guide*.  If you change the value of the ``KeySpec`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.    [services that are integrated with](https://docs.aws.amazon.com/kms/features/#AWS_Service_Integration) use symmetric encryption KMS keys to protect your data. These services do not support encryption with asymmetric KMS keys. For help determining whether a KMS key is asymmetric, see [Identifying asymmetric KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/find-symm-asymm.html) in the *Developer Guide*.   KMS supports the following key specs for KMS keys:  +  Symmetric encryption key (default)  +   ``SYMMETRIC_DEFAULT`` (AES-256-GCM)    +  HMAC keys (symmetric)  +   ``HMAC_224``   +   ``HMAC_256``   +   ``HMAC_384``   +   ``HMAC_512``     +  Asymmetric RSA key pairs  +   ``RSA_2048``   +   ``RSA_3072``   +   ``RSA_4096``     +  Asymmetric NIST-recommended elliptic curve key pairs  +   ``ECC_NIST_P256`` (secp256r1)  +   ``ECC_NIST_P384`` (secp384r1)  +   ``ECC_NIST_P521`` (secp521r1)    +  Other asymmetric elliptic curve key pairs  +   ``ECC_SECG_P256K1`` (secp256k1), commonly used for cryptocurrencies.    +  SM2 key pairs (China Regions only)  +   ``SM2``
        """
        return pulumi.get(self, "key_spec")

    @property
    @pulumi.getter(name="keyUsage")
    def key_usage(self) -> Optional[str]:
        """
        Determines the [cryptographic operations](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) for which you can use the KMS key. The default value is ``ENCRYPT_DECRYPT``. This property is required for asymmetric KMS keys and HMAC KMS keys. You can't change the ``KeyUsage`` value after the KMS key is created.  If you change the value of the ``KeyUsage`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.  Select only one valid value.  +  For symmetric encryption KMS keys, omit the property or specify ``ENCRYPT_DECRYPT``.  +  For asymmetric KMS keys with RSA key material, specify ``ENCRYPT_DECRYPT`` or ``SIGN_VERIFY``.  +  For asymmetric KMS keys with ECC key material, specify ``SIGN_VERIFY``.  +  For asymmetric KMS keys with SM2 (China Regions only) key material, specify ``ENCRYPT_DECRYPT`` or ``SIGN_VERIFY``.  +  For HMAC KMS keys, specify ``GENERATE_VERIFY_MAC``.
        """
        return pulumi.get(self, "key_usage")

    @property
    @pulumi.getter(name="multiRegion")
    def multi_region(self) -> Optional[bool]:
        """
        Creates a multi-Region primary key that you can replicate in other AWS-Regions. You can't change the ``MultiRegion`` value after the KMS key is created. For a list of AWS-Regions in which multi-Region keys are supported, see [Multi-Region keys in](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the **.  If you change the value of the ``MultiRegion`` property on an existing KMS key, the update request fails, regardless of the value of the [UpdateReplacePolicy attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatereplacepolicy.html). This prevents you from accidentally deleting a KMS key by changing an immutable property value.  For a multi-Region key, set to this property to ``true``. For a single-Region key, omit this property or set it to ``false``. The default value is ``false``.  *Multi-Region keys* are an KMS feature that lets you create multiple interoperable KMS keys in different AWS-Regions. Because these KMS keys have the same key ID, key material, and other metadata, you can use them to encrypt data in one AWS-Region and decrypt it in a different AWS-Region without making a cross-Region call or exposing the plaintext data. For more information, see [Multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the *Developer Guide*. You can create a symmetric encryption, HMAC, or asymmetric multi-Region KMS key, and you can create a multi-Region key with imported key material. However, you cannot create a multi-Region key in a custom key store. To create a replica of this primary key in a different AWS-Region , create an [AWS::KMS::ReplicaKey](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-replicakey.html) resource in a CloudFormation stack in the replica Region. Specify the key ARN of this primary key.
        """
        return pulumi.get(self, "multi_region")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        """
        The source of the key material for the KMS key. You cannot change the origin after you create the KMS key. The default is ``AWS_KMS``, which means that KMS creates the key material. To [create a KMS key with no key material](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys-create-cmk.html) (for imported key material), set this value to ``EXTERNAL``. For more information about importing key material into KMS, see [Importing Key Material](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html) in the *Developer Guide*. You can ignore ``ENABLED`` when Origin is ``EXTERNAL``. When a KMS key with Origin ``EXTERNAL`` is created, the key state is ``PENDING_IMPORT`` and ``ENABLED`` is ``false``. After you import the key material, ``ENABLED`` updated to ``true``. The KMS key can then be used for Cryptographic Operations.    CFN doesn't support creating an ``Origin`` parameter of the ``AWS_CLOUDHSM`` or ``EXTERNAL_KEY_STORE`` values.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="pendingWindowInDays")
    def pending_window_in_days(self) -> Optional[int]:
        """
        Specifies the number of days in the waiting period before KMS deletes a KMS key that has been removed from a CloudFormation stack. Enter a value between 7 and 30 days. The default value is 30 days. When you remove a KMS key from a CloudFormation stack, KMS schedules the KMS key for deletion and starts the mandatory waiting period. The ``PendingWindowInDays`` property determines the length of waiting period. During the waiting period, the key state of KMS key is ``Pending Deletion`` or ``Pending Replica Deletion``, which prevents the KMS key from being used in cryptographic operations. When the waiting period expires, KMS permanently deletes the KMS key.  KMS will not delete a [multi-Region primary key](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) that has replica keys. If you remove a multi-Region primary key from a CloudFormation stack, its key state changes to ``PendingReplicaDeletion`` so it cannot be replicated or used in cryptographic operations. This state can persist indefinitely. When the last of its replica keys is deleted, the key state of the primary key changes to ``PendingDeletion`` and the waiting period specified by ``PendingWindowInDays`` begins. When this waiting period expires, KMS deletes the primary key. For details, see [Deleting multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-delete.html) in the *Developer Guide*. You cannot use a CloudFormation template to cancel deletion of the KMS key after you remove it from the stack, regardless of the waiting period. If you specify a KMS key in your template, even one with the same name, CloudFormation creates a new KMS key. To cancel deletion of a KMS key, use the KMS console or the [CancelKeyDeletion](https://docs.aws.amazon.com/kms/latest/APIReference/API_CancelKeyDeletion.html) operation. For information about the ``Pending Deletion`` and ``Pending Replica Deletion`` key states, see [Key state: Effect on your KMS key](https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html) in the *Developer Guide*. For more information about deleting KMS keys, see the [ScheduleKeyDeletion](https://docs.aws.amazon.com/kms/latest/APIReference/API_ScheduleKeyDeletion.html) operation in the *API Reference* and [Deleting KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/deleting-keys.html) in the *Developer Guide*.
        """
        return pulumi.get(self, "pending_window_in_days")

    @property
    @pulumi.getter(name="rotationPeriodInDays")
    def rotation_period_in_days(self) -> Optional[int]:
        """
        Property rotationPeriodInDays
        """
        return pulumi.get(self, "rotation_period_in_days")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Assigns one or more tags to the replica key.  Tagging or untagging a KMS key can allow or deny permission to the KMS key. For details, see [ABAC for](https://docs.aws.amazon.com/kms/latest/developerguide/abac.html) in the *Developer Guide*.  For information about tags in KMS, see [Tagging keys](https://docs.aws.amazon.com/kms/latest/developerguide/tagging-keys.html) in the *Developer Guide*. For information about tags in CloudFormation, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsLambdaFunctionCodeLocationPropertiesResponse(dict):
    """
    Definition of awsLambdaFunctionCodeLocation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUri":
            suggest = "image_uri"
        elif key == "repositoryType":
            suggest = "repository_type"
        elif key == "resolvedImageUri":
            suggest = "resolved_image_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLambdaFunctionCodeLocationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLambdaFunctionCodeLocationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLambdaFunctionCodeLocationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_uri: Optional[str] = None,
                 location: Optional[str] = None,
                 repository_type: Optional[str] = None,
                 resolved_image_uri: Optional[str] = None):
        """
        Definition of awsLambdaFunctionCodeLocation
        :param str image_uri: <p>URI of a container image in the Amazon ECR registry.</p>
        :param str location: <p>A presigned URL that you can use to download the deployment package.</p>
        :param str repository_type: <p>The service that's hosting the file.</p>
        :param str resolved_image_uri: <p>The resolved URI for the image.</p>
        """
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if repository_type is not None:
            pulumi.set(__self__, "repository_type", repository_type)
        if resolved_image_uri is not None:
            pulumi.set(__self__, "resolved_image_uri", resolved_image_uri)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[str]:
        """
        <p>URI of a container image in the Amazon ECR registry.</p>
        """
        return pulumi.get(self, "image_uri")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        <p>A presigned URL that you can use to download the deployment package.</p>
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="repositoryType")
    def repository_type(self) -> Optional[str]:
        """
        <p>The service that's hosting the file.</p>
        """
        return pulumi.get(self, "repository_type")

    @property
    @pulumi.getter(name="resolvedImageUri")
    def resolved_image_uri(self) -> Optional[str]:
        """
        <p>The resolved URI for the image.</p>
        """
        return pulumi.get(self, "resolved_image_uri")


@pulumi.output_type
class AwsLambdaFunctionPropertiesResponse(dict):
    """
    Definition of awsLambdaFunction
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeSigningConfigArn":
            suggest = "code_signing_config_arn"
        elif key == "deadLetterConfig":
            suggest = "dead_letter_config"
        elif key == "ephemeralStorage":
            suggest = "ephemeral_storage"
        elif key == "fileSystemConfigs":
            suggest = "file_system_configs"
        elif key == "functionName":
            suggest = "function_name"
        elif key == "imageConfig":
            suggest = "image_config"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"
        elif key == "loggingConfig":
            suggest = "logging_config"
        elif key == "memorySize":
            suggest = "memory_size"
        elif key == "packageType":
            suggest = "package_type"
        elif key == "reservedConcurrentExecutions":
            suggest = "reserved_concurrent_executions"
        elif key == "runtimeManagementConfig":
            suggest = "runtime_management_config"
        elif key == "snapStart":
            suggest = "snap_start"
        elif key == "snapStartResponse":
            suggest = "snap_start_response"
        elif key == "tracingConfig":
            suggest = "tracing_config"
        elif key == "vpcConfig":
            suggest = "vpc_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLambdaFunctionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLambdaFunctionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLambdaFunctionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architectures: Optional[Sequence[str]] = None,
                 arn: Optional[str] = None,
                 code: Optional['outputs.CodeResponse'] = None,
                 code_signing_config_arn: Optional[str] = None,
                 dead_letter_config: Optional['outputs.DeadLetterConfigResponse'] = None,
                 description: Optional[str] = None,
                 environment: Optional['outputs.EnvironmentResponse'] = None,
                 ephemeral_storage: Optional['outputs.EphemeralStorageResponse'] = None,
                 file_system_configs: Optional[Sequence['outputs.FileSystemConfigResponse']] = None,
                 function_name: Optional[str] = None,
                 handler: Optional[str] = None,
                 image_config: Optional['outputs.ImageConfigResponse'] = None,
                 kms_key_arn: Optional[str] = None,
                 layers: Optional[Sequence[str]] = None,
                 logging_config: Optional['outputs.LoggingConfigResponse'] = None,
                 memory_size: Optional[int] = None,
                 package_type: Optional[str] = None,
                 reserved_concurrent_executions: Optional[int] = None,
                 role: Optional[str] = None,
                 runtime: Optional[str] = None,
                 runtime_management_config: Optional['outputs.RuntimeManagementConfigResponse'] = None,
                 snap_start: Optional['outputs.SnapStartResponse'] = None,
                 snap_start_response: Optional['outputs.SnapStartResponseResponse'] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 timeout: Optional[int] = None,
                 tracing_config: Optional['outputs.TracingConfigResponse'] = None,
                 vpc_config: Optional['outputs.VpcConfigResponse'] = None):
        """
        Definition of awsLambdaFunction
        :param Sequence[str] architectures: The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is ``x86_64``.
        :param str arn: Property arn
        :param 'CodeResponse' code: The code for the function. The [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html) for a Lambda function. To deploy a function defined as a container image, you specify the location of a container image in the Amazon ECR registry. For a .zip file deployment package, you can specify the location of an object in Amazon S3. For Node.js and Python functions, you can specify the function code inline in the template. Changes to a deployment package in Amazon S3 or a container image in ECR are not detected automatically during stack updates. To update the function code, change the object key or version in the template.
        :param str code_signing_config_arn: To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
        :param 'DeadLetterConfigResponse' dead_letter_config: A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead-letter queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq). The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq) for failed asynchronous invocations.
        :param str description: A description of the function.
        :param 'EnvironmentResponse' environment: Environment variables that are accessible from function code during execution. A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.
        :param 'EphemeralStorageResponse' ephemeral_storage: The size of the function's ``/tmp`` directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB. The size of the function's ``/tmp`` directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
        :param Sequence['FileSystemConfigResponse'] file_system_configs: Connection settings for an Amazon EFS file system. To connect a function to a file system, a mount target must be available in every Availability Zone that your function connects to. If your template contains an [AWS::EFS::MountTarget](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-mounttarget.html) resource, you must also specify a ``DependsOn`` attribute to ensure that the mount target is created or updated before the function. For more information about using the ``DependsOn`` attribute, see [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html).
        :param str function_name: The name of the Lambda function, up to 64 characters in length. If you don't specify a name, CFN generates one. If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        :param str handler: The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
        :param 'ImageConfigResponse' image_config: Configuration values that override the container image Dockerfile settings. For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms). Configuration values that override the container image Dockerfile settings. For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms).
        :param str kms_key_arn: The ARN of the KMSlong (KMS) customer managed key that's used to encrypt your function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, Lambda also uses this key is to encrypt your function's snapshot. If you deploy your function using a container image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
        :param Sequence[str] layers: A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
        :param 'LoggingConfigResponse' logging_config: The function's Amazon CloudWatch Logs configuration settings. The function's Amazon CloudWatch Logs configuration settings.
        :param int memory_size: The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB. Note that new AWS accounts have reduced concurrency and memory quotas. AWS raises these quotas automatically based on your usage. You can also request a quota increase.
        :param str package_type: The type of deployment package. Set to ``Image`` for container image and set ``Zip`` for .zip file archive.
        :param int reserved_concurrent_executions: The number of simultaneous executions to reserve for the function.
        :param str role: The Amazon Resource Name (ARN) of the function's execution role.
        :param str runtime: The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
        :param 'RuntimeManagementConfigResponse' runtime_management_config: Sets the runtime management configuration for a function's version. For more information, see [Runtime updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html). Sets the runtime management configuration for a function's version. For more information, see [Runtime updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html).
        :param 'SnapStartResponse' snap_start: The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting. The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
        :param 'SnapStartResponseResponse' snap_start_response: The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
        :param Sequence['TagResponse'] tags: A list of [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
        :param int timeout: The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
        :param 'TracingConfigResponse' tracing_config: Set ``Mode`` to ``Active`` to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html). The function's [](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) tracing configuration. To sample and record incoming requests, set ``Mode`` to ``Active``.
        :param 'VpcConfigResponse' vpc_config: For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html). The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).  When you delete a function, CFN monitors the state of its network interfaces and waits for Lambda to delete them before proceeding. If the VPC is defined in the same stack, the network interfaces need to be deleted by Lambda before CFN can delete the VPC's resources. To monitor network interfaces, CFN needs the ``ec2:DescribeNetworkInterfaces`` permission. It obtains this from the user or role that modifies the stack. If you don't provide this permission, CFN does not wait for network interfaces to be deleted.
        """
        if architectures is not None:
            pulumi.set(__self__, "architectures", architectures)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if code_signing_config_arn is not None:
            pulumi.set(__self__, "code_signing_config_arn", code_signing_config_arn)
        if dead_letter_config is not None:
            pulumi.set(__self__, "dead_letter_config", dead_letter_config)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if ephemeral_storage is not None:
            pulumi.set(__self__, "ephemeral_storage", ephemeral_storage)
        if file_system_configs is not None:
            pulumi.set(__self__, "file_system_configs", file_system_configs)
        if function_name is not None:
            pulumi.set(__self__, "function_name", function_name)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if image_config is not None:
            pulumi.set(__self__, "image_config", image_config)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if layers is not None:
            pulumi.set(__self__, "layers", layers)
        if logging_config is not None:
            pulumi.set(__self__, "logging_config", logging_config)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)
        if package_type is not None:
            pulumi.set(__self__, "package_type", package_type)
        if reserved_concurrent_executions is not None:
            pulumi.set(__self__, "reserved_concurrent_executions", reserved_concurrent_executions)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if runtime_management_config is not None:
            pulumi.set(__self__, "runtime_management_config", runtime_management_config)
        if snap_start is not None:
            pulumi.set(__self__, "snap_start", snap_start)
        if snap_start_response is not None:
            pulumi.set(__self__, "snap_start_response", snap_start_response)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tracing_config is not None:
            pulumi.set(__self__, "tracing_config", tracing_config)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @property
    @pulumi.getter
    def architectures(self) -> Optional[Sequence[str]]:
        """
        The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is ``x86_64``.
        """
        return pulumi.get(self, "architectures")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def code(self) -> Optional['outputs.CodeResponse']:
        """
        The code for the function. The [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html) for a Lambda function. To deploy a function defined as a container image, you specify the location of a container image in the Amazon ECR registry. For a .zip file deployment package, you can specify the location of an object in Amazon S3. For Node.js and Python functions, you can specify the function code inline in the template. Changes to a deployment package in Amazon S3 or a container image in ECR are not detected automatically during stack updates. To update the function code, change the object key or version in the template.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="codeSigningConfigArn")
    def code_signing_config_arn(self) -> Optional[str]:
        """
        To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
        """
        return pulumi.get(self, "code_signing_config_arn")

    @property
    @pulumi.getter(name="deadLetterConfig")
    def dead_letter_config(self) -> Optional['outputs.DeadLetterConfigResponse']:
        """
        A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see [Dead-letter queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq). The [dead-letter queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq) for failed asynchronous invocations.
        """
        return pulumi.get(self, "dead_letter_config")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the function.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def environment(self) -> Optional['outputs.EnvironmentResponse']:
        """
        Environment variables that are accessible from function code during execution. A function's environment variable settings. You can use environment variables to adjust your function's behavior without updating code. An environment variable is a pair of strings that are stored in a function's version-specific configuration.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="ephemeralStorage")
    def ephemeral_storage(self) -> Optional['outputs.EphemeralStorageResponse']:
        """
        The size of the function's ``/tmp`` directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB. The size of the function's ``/tmp`` directory in MB. The default value is 512, but it can be any whole number between 512 and 10,240 MB.
        """
        return pulumi.get(self, "ephemeral_storage")

    @property
    @pulumi.getter(name="fileSystemConfigs")
    def file_system_configs(self) -> Optional[Sequence['outputs.FileSystemConfigResponse']]:
        """
        Connection settings for an Amazon EFS file system. To connect a function to a file system, a mount target must be available in every Availability Zone that your function connects to. If your template contains an [AWS::EFS::MountTarget](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-mounttarget.html) resource, you must also specify a ``DependsOn`` attribute to ensure that the mount target is created or updated before the function. For more information about using the ``DependsOn`` attribute, see [DependsOn Attribute](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html).
        """
        return pulumi.get(self, "file_system_configs")

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> Optional[str]:
        """
        The name of the Lambda function, up to 64 characters in length. If you don't specify a name, CFN generates one. If you specify a name, you cannot perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        """
        return pulumi.get(self, "function_name")

    @property
    @pulumi.getter
    def handler(self) -> Optional[str]:
        """
        The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see [Lambda programming model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
        """
        return pulumi.get(self, "handler")

    @property
    @pulumi.getter(name="imageConfig")
    def image_config(self) -> Optional['outputs.ImageConfigResponse']:
        """
        Configuration values that override the container image Dockerfile settings. For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms). Configuration values that override the container image Dockerfile settings. For more information, see [Container image settings](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms).
        """
        return pulumi.get(self, "image_config")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        The ARN of the KMSlong (KMS) customer managed key that's used to encrypt your function's [environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption). When [Lambda SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html) is activated, Lambda also uses this key is to encrypt your function's snapshot. If you deploy your function using a container image, Lambda also uses this key to encrypt your function when it's deployed. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). If you don't provide a customer managed key, Lambda uses a default service key.
        """
        return pulumi.get(self, "kms_key_arn")

    @property
    @pulumi.getter
    def layers(self) -> Optional[Sequence[str]]:
        """
        A list of [function layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) to add to the function's execution environment. Specify each layer by its ARN, including the version.
        """
        return pulumi.get(self, "layers")

    @property
    @pulumi.getter(name="loggingConfig")
    def logging_config(self) -> Optional['outputs.LoggingConfigResponse']:
        """
        The function's Amazon CloudWatch Logs configuration settings. The function's Amazon CloudWatch Logs configuration settings.
        """
        return pulumi.get(self, "logging_config")

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[int]:
        """
        The amount of [memory available to the function](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console) at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB. Note that new AWS accounts have reduced concurrency and memory quotas. AWS raises these quotas automatically based on your usage. You can also request a quota increase.
        """
        return pulumi.get(self, "memory_size")

    @property
    @pulumi.getter(name="packageType")
    def package_type(self) -> Optional[str]:
        """
        The type of deployment package. Set to ``Image`` for container image and set ``Zip`` for .zip file archive.
        """
        return pulumi.get(self, "package_type")

    @property
    @pulumi.getter(name="reservedConcurrentExecutions")
    def reserved_concurrent_executions(self) -> Optional[int]:
        """
        The number of simultaneous executions to reserve for the function.
        """
        return pulumi.get(self, "reserved_concurrent_executions")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the function's execution role.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def runtime(self) -> Optional[str]:
        """
        The identifier of the function's [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). Runtime is required if the deployment package is a .zip file archive. The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
        """
        return pulumi.get(self, "runtime")

    @property
    @pulumi.getter(name="runtimeManagementConfig")
    def runtime_management_config(self) -> Optional['outputs.RuntimeManagementConfigResponse']:
        """
        Sets the runtime management configuration for a function's version. For more information, see [Runtime updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html). Sets the runtime management configuration for a function's version. For more information, see [Runtime updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html).
        """
        return pulumi.get(self, "runtime_management_config")

    @property
    @pulumi.getter(name="snapStart")
    def snap_start(self) -> Optional['outputs.SnapStartResponse']:
        """
        The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting. The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
        """
        return pulumi.get(self, "snap_start")

    @property
    @pulumi.getter(name="snapStartResponse")
    def snap_start_response(self) -> Optional['outputs.SnapStartResponseResponse']:
        """
        The function's [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html) setting.
        """
        return pulumi.get(self, "snap_start_response")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        A list of [tags](https://docs.aws.amazon.com/lambda/latest/dg/tagging.html) to apply to the function.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see [Lambda execution environment](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html).
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tracingConfig")
    def tracing_config(self) -> Optional['outputs.TracingConfigResponse']:
        """
        Set ``Mode`` to ``Active`` to sample and trace a subset of incoming requests with [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html). The function's [](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html) tracing configuration. To sample and record incoming requests, set ``Mode`` to ``Active``.
        """
        return pulumi.get(self, "tracing_config")

    @property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional['outputs.VpcConfigResponse']:
        """
        For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see [Configuring a Lambda function to access resources in a VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html). The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC. For more information, see [VPC Settings](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).  When you delete a function, CFN monitors the state of its network interfaces and waits for Lambda to delete them before proceeding. If the VPC is defined in the same stack, the network interfaces need to be deleted by Lambda before CFN can delete the VPC's resources. To monitor network interfaces, CFN needs the ``ec2:DescribeNetworkInterfaces`` permission. It obtains this from the user or role that modifies the stack. If you don't provide this permission, CFN does not wait for network interfaces to be deleted.
        """
        return pulumi.get(self, "vpc_config")


@pulumi.output_type
class AwsLightsailBucketPropertiesResponse(dict):
    """
    Definition of awsLightsailBucket
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ableToUpdateBundle":
            suggest = "able_to_update_bundle"
        elif key == "accessRules":
            suggest = "access_rules"
        elif key == "bucketArn":
            suggest = "bucket_arn"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "bundleId":
            suggest = "bundle_id"
        elif key == "objectVersioning":
            suggest = "object_versioning"
        elif key == "readOnlyAccessAccounts":
            suggest = "read_only_access_accounts"
        elif key == "resourcesReceivingAccess":
            suggest = "resources_receiving_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLightsailBucketPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLightsailBucketPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLightsailBucketPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 able_to_update_bundle: Optional[bool] = None,
                 access_rules: Optional['outputs.AccessRulesResponse'] = None,
                 bucket_arn: Optional[str] = None,
                 bucket_name: Optional[str] = None,
                 bundle_id: Optional[str] = None,
                 object_versioning: Optional[bool] = None,
                 read_only_access_accounts: Optional[Sequence[str]] = None,
                 resources_receiving_access: Optional[Sequence[str]] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 url: Optional[str] = None):
        """
        Definition of awsLightsailBucket
        :param bool able_to_update_bundle: Indicates whether the bundle that is currently applied to a bucket can be changed to another bundle. You can update a bucket's bundle only one time within a monthly AWS billing cycle.
        :param 'AccessRulesResponse' access_rules: An object that sets the public accessibility of objects in the specified bucket.
        :param str bucket_arn: Property bucketArn
        :param str bucket_name: The name for the bucket.
        :param str bundle_id: The ID of the bundle to use for the bucket.
        :param bool object_versioning: Specifies whether to enable or disable versioning of objects in the bucket.
        :param Sequence[str] read_only_access_accounts: An array of strings to specify the AWS account IDs that can access the bucket.
        :param Sequence[str] resources_receiving_access: The names of the Lightsail resources for which to set bucket access.
        :param Sequence['TagResponse'] tags: An array of key-value pairs to apply to this resource.
        :param str url: The URL of the bucket.
        """
        if able_to_update_bundle is not None:
            pulumi.set(__self__, "able_to_update_bundle", able_to_update_bundle)
        if access_rules is not None:
            pulumi.set(__self__, "access_rules", access_rules)
        if bucket_arn is not None:
            pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bundle_id is not None:
            pulumi.set(__self__, "bundle_id", bundle_id)
        if object_versioning is not None:
            pulumi.set(__self__, "object_versioning", object_versioning)
        if read_only_access_accounts is not None:
            pulumi.set(__self__, "read_only_access_accounts", read_only_access_accounts)
        if resources_receiving_access is not None:
            pulumi.set(__self__, "resources_receiving_access", resources_receiving_access)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="ableToUpdateBundle")
    def able_to_update_bundle(self) -> Optional[bool]:
        """
        Indicates whether the bundle that is currently applied to a bucket can be changed to another bundle. You can update a bucket's bundle only one time within a monthly AWS billing cycle.
        """
        return pulumi.get(self, "able_to_update_bundle")

    @property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> Optional['outputs.AccessRulesResponse']:
        """
        An object that sets the public accessibility of objects in the specified bucket.
        """
        return pulumi.get(self, "access_rules")

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> Optional[str]:
        """
        Property bucketArn
        """
        return pulumi.get(self, "bucket_arn")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The name for the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bundleId")
    def bundle_id(self) -> Optional[str]:
        """
        The ID of the bundle to use for the bucket.
        """
        return pulumi.get(self, "bundle_id")

    @property
    @pulumi.getter(name="objectVersioning")
    def object_versioning(self) -> Optional[bool]:
        """
        Specifies whether to enable or disable versioning of objects in the bucket.
        """
        return pulumi.get(self, "object_versioning")

    @property
    @pulumi.getter(name="readOnlyAccessAccounts")
    def read_only_access_accounts(self) -> Optional[Sequence[str]]:
        """
        An array of strings to specify the AWS account IDs that can access the bucket.
        """
        return pulumi.get(self, "read_only_access_accounts")

    @property
    @pulumi.getter(name="resourcesReceivingAccess")
    def resources_receiving_access(self) -> Optional[Sequence[str]]:
        """
        The names of the Lightsail resources for which to set bucket access.
        """
        return pulumi.get(self, "resources_receiving_access")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An array of key-value pairs to apply to this resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the bucket.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AwsLightsailInstancePropertiesResponse(dict):
    """
    Definition of awsLightsailInstance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addOns":
            suggest = "add_ons"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "blueprintId":
            suggest = "blueprint_id"
        elif key == "bundleId":
            suggest = "bundle_id"
        elif key == "instanceArn":
            suggest = "instance_arn"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "isStaticIp":
            suggest = "is_static_ip"
        elif key == "keyPairName":
            suggest = "key_pair_name"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "sshKeyName":
            suggest = "ssh_key_name"
        elif key == "supportCode":
            suggest = "support_code"
        elif key == "userData":
            suggest = "user_data"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLightsailInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLightsailInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLightsailInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_ons: Optional[Sequence['outputs.AddOnResponse']] = None,
                 availability_zone: Optional[str] = None,
                 blueprint_id: Optional[str] = None,
                 bundle_id: Optional[str] = None,
                 hardware: Optional['outputs.HardwareResponse'] = None,
                 instance_arn: Optional[str] = None,
                 instance_name: Optional[str] = None,
                 is_static_ip: Optional[bool] = None,
                 key_pair_name: Optional[str] = None,
                 location: Optional['outputs.LocationResponse'] = None,
                 networking: Optional['outputs.NetworkingResponse'] = None,
                 private_ip_address: Optional[str] = None,
                 public_ip_address: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 ssh_key_name: Optional[str] = None,
                 state: Optional['outputs.StateResponse'] = None,
                 support_code: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 user_data: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        Definition of awsLightsailInstance
        :param Sequence['AddOnResponse'] add_ons: An array of objects representing the add-ons to enable for the new instance.
        :param str availability_zone: The Availability Zone in which to create your instance. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
        :param str blueprint_id: The ID for a virtual private server image (e.g., app_wordpress_4_4 or app_lamp_7_0 ). Use the get blueprints operation to return a list of available images (or blueprints ).
        :param str bundle_id: The bundle of specification information for your virtual private server (or instance ), including the pricing plan (e.g., micro_1_0 ).
        :param 'HardwareResponse' hardware: Hardware of the Instance.
        :param str instance_arn: Property instanceArn
        :param str instance_name: The names to use for your new Lightsail instance.
        :param bool is_static_ip: Is the IP Address of the Instance is the static IP
        :param str key_pair_name: The name of your key pair.
        :param 'LocationResponse' location: Location of a resource.
        :param 'NetworkingResponse' networking: Networking of the Instance.
        :param str private_ip_address: Private IP Address of the Instance
        :param str public_ip_address: Public IP Address of the Instance
        :param str resource_type: Resource type of Lightsail instance.
        :param str ssh_key_name: SSH Key Name of the  Lightsail instance.
        :param 'StateResponse' state: Current State of the Instance.
        :param str support_code: Support code to help identify any issues
        :param Sequence['TagResponse'] tags: An array of key-value pairs to apply to this resource.
        :param str user_data: A launch script you can create that configures a server with additional user data. For example, you might want to run apt-get -y update.
        :param str user_name: Username of the  Lightsail instance.
        """
        if add_ons is not None:
            pulumi.set(__self__, "add_ons", add_ons)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if blueprint_id is not None:
            pulumi.set(__self__, "blueprint_id", blueprint_id)
        if bundle_id is not None:
            pulumi.set(__self__, "bundle_id", bundle_id)
        if hardware is not None:
            pulumi.set(__self__, "hardware", hardware)
        if instance_arn is not None:
            pulumi.set(__self__, "instance_arn", instance_arn)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if is_static_ip is not None:
            pulumi.set(__self__, "is_static_ip", is_static_ip)
        if key_pair_name is not None:
            pulumi.set(__self__, "key_pair_name", key_pair_name)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if ssh_key_name is not None:
            pulumi.set(__self__, "ssh_key_name", ssh_key_name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if support_code is not None:
            pulumi.set(__self__, "support_code", support_code)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="addOns")
    def add_ons(self) -> Optional[Sequence['outputs.AddOnResponse']]:
        """
        An array of objects representing the add-ons to enable for the new instance.
        """
        return pulumi.get(self, "add_ons")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone in which to create your instance. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="blueprintId")
    def blueprint_id(self) -> Optional[str]:
        """
        The ID for a virtual private server image (e.g., app_wordpress_4_4 or app_lamp_7_0 ). Use the get blueprints operation to return a list of available images (or blueprints ).
        """
        return pulumi.get(self, "blueprint_id")

    @property
    @pulumi.getter(name="bundleId")
    def bundle_id(self) -> Optional[str]:
        """
        The bundle of specification information for your virtual private server (or instance ), including the pricing plan (e.g., micro_1_0 ).
        """
        return pulumi.get(self, "bundle_id")

    @property
    @pulumi.getter
    def hardware(self) -> Optional['outputs.HardwareResponse']:
        """
        Hardware of the Instance.
        """
        return pulumi.get(self, "hardware")

    @property
    @pulumi.getter(name="instanceArn")
    def instance_arn(self) -> Optional[str]:
        """
        Property instanceArn
        """
        return pulumi.get(self, "instance_arn")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[str]:
        """
        The names to use for your new Lightsail instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="isStaticIp")
    def is_static_ip(self) -> Optional[bool]:
        """
        Is the IP Address of the Instance is the static IP
        """
        return pulumi.get(self, "is_static_ip")

    @property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> Optional[str]:
        """
        The name of your key pair.
        """
        return pulumi.get(self, "key_pair_name")

    @property
    @pulumi.getter
    def location(self) -> Optional['outputs.LocationResponse']:
        """
        Location of a resource.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def networking(self) -> Optional['outputs.NetworkingResponse']:
        """
        Networking of the Instance.
        """
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        Private IP Address of the Instance
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[str]:
        """
        Public IP Address of the Instance
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        Resource type of Lightsail instance.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="sshKeyName")
    def ssh_key_name(self) -> Optional[str]:
        """
        SSH Key Name of the  Lightsail instance.
        """
        return pulumi.get(self, "ssh_key_name")

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.StateResponse']:
        """
        Current State of the Instance.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="supportCode")
    def support_code(self) -> Optional[str]:
        """
        Support code to help identify any issues
        """
        return pulumi.get(self, "support_code")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An array of key-value pairs to apply to this resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        A launch script you can create that configures a server with additional user data. For example, you might want to run apt-get -y update.
        """
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        Username of the  Lightsail instance.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class AwsLogsLogGroupPropertiesResponse(dict):
    """
    Definition of awsLogsLogGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataProtectionPolicy":
            suggest = "data_protection_policy"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "logGroupClass":
            suggest = "log_group_class"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "retentionInDays":
            suggest = "retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLogsLogGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLogsLogGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLogsLogGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 data_protection_policy: Optional[Any] = None,
                 kms_key_id: Optional[str] = None,
                 log_group_class: Optional[str] = None,
                 log_group_name: Optional[str] = None,
                 retention_in_days: Optional[int] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsLogsLogGroup
        :param str arn: Property arn
        :param Any data_protection_policy: Creates a data protection policy and assigns it to the log group. A data protection policy can help safeguard sensitive data that's ingested by the log group by auditing and masking the sensitive log data. When a user who does not have permission to view masked data views a log event that includes masked data, the sensitive data is replaced by asterisks. For more information, including a list of types of data that can be audited and masked, see [Protect sensitive log data with masking](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/mask-sensitive-log-data.html).
        :param str kms_key_id: The Amazon Resource Name (ARN) of the KMS key to use when encrypting log data. To associate an KMS key with the log group, specify the ARN of that KMS key here. If you do so, ingested data is encrypted using this key. This association is stored as long as the data encrypted with the KMS key is still within CWL. This enables CWL to decrypt this data whenever it is requested. If you attempt to associate a KMS key with the log group but the KMS key doesn't exist or is deactivated, you will receive an ``InvalidParameterException`` error. Log group data is always encrypted in CWL. If you omit this key, the encryption does not use KMS. For more information, see [Encrypt log data in using](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/encrypt-log-data-kms.html)
        :param str log_group_class: Specifies the log group class for this log group. There are two classes:  +  The ``Standard`` log class supports all CWL features.  +  The ``Infrequent Access`` log class supports a subset of CWL features and incurs lower costs.   For details about the features supported by each class, see [Log classes](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html)
        :param str log_group_name: The name of the log group. If you don't specify a name, CFNlong generates a unique ID for the log group.
        :param int retention_in_days: The number of days to retain the log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1096, 1827, 2192, 2557, 2922, 3288, and 3653. To set a log group so that its log events do not expire, use [DeleteRetentionPolicy](https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html).
        :param Sequence['TagResponse'] tags: An array of key-value pairs to apply to the log group. For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if data_protection_policy is not None:
            pulumi.set(__self__, "data_protection_policy", data_protection_policy)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if log_group_class is None:
            log_group_class = 'STANDARD'
        if log_group_class is not None:
            pulumi.set(__self__, "log_group_class", log_group_class)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="dataProtectionPolicy")
    def data_protection_policy(self) -> Optional[Any]:
        """
        Creates a data protection policy and assigns it to the log group. A data protection policy can help safeguard sensitive data that's ingested by the log group by auditing and masking the sensitive log data. When a user who does not have permission to view masked data views a log event that includes masked data, the sensitive data is replaced by asterisks. For more information, including a list of types of data that can be audited and masked, see [Protect sensitive log data with masking](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/mask-sensitive-log-data.html).
        """
        return pulumi.get(self, "data_protection_policy")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the KMS key to use when encrypting log data. To associate an KMS key with the log group, specify the ARN of that KMS key here. If you do so, ingested data is encrypted using this key. This association is stored as long as the data encrypted with the KMS key is still within CWL. This enables CWL to decrypt this data whenever it is requested. If you attempt to associate a KMS key with the log group but the KMS key doesn't exist or is deactivated, you will receive an ``InvalidParameterException`` error. Log group data is always encrypted in CWL. If you omit this key, the encryption does not use KMS. For more information, see [Encrypt log data in using](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/encrypt-log-data-kms.html)
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="logGroupClass")
    def log_group_class(self) -> Optional[str]:
        """
        Specifies the log group class for this log group. There are two classes:  +  The ``Standard`` log class supports all CWL features.  +  The ``Infrequent Access`` log class supports a subset of CWL features and incurs lower costs.   For details about the features supported by each class, see [Log classes](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html)
        """
        return pulumi.get(self, "log_group_class")

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[str]:
        """
        The name of the log group. If you don't specify a name, CFNlong generates a unique ID for the log group.
        """
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[int]:
        """
        The number of days to retain the log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1096, 1827, 2192, 2557, 2922, 3288, and 3653. To set a log group so that its log events do not expire, use [DeleteRetentionPolicy](https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DeleteRetentionPolicy.html).
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An array of key-value pairs to apply to the log group. For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsLogsLogStreamPropertiesResponse(dict):
    """
    Definition of awsLogsLogStream
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupName":
            suggest = "log_group_name"
        elif key == "logStreamName":
            suggest = "log_stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLogsLogStreamPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLogsLogStreamPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLogsLogStreamPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_name: Optional[str] = None,
                 log_stream_name: Optional[str] = None):
        """
        Definition of awsLogsLogStream
        :param str log_group_name: The name of the log group where the log stream is created.
        :param str log_stream_name: The name of the log stream. The name must be unique wihtin the log group.
        """
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name is not None:
            pulumi.set(__self__, "log_stream_name", log_stream_name)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[str]:
        """
        The name of the log group where the log stream is created.
        """
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> Optional[str]:
        """
        The name of the log stream. The name must be unique wihtin the log group.
        """
        return pulumi.get(self, "log_stream_name")


@pulumi.output_type
class AwsLogsMetricFilterPropertiesResponse(dict):
    """
    Definition of awsLogsMetricFilter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterName":
            suggest = "filter_name"
        elif key == "filterPattern":
            suggest = "filter_pattern"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "metricTransformations":
            suggest = "metric_transformations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLogsMetricFilterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLogsMetricFilterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLogsMetricFilterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_name: Optional[str] = None,
                 filter_pattern: Optional[str] = None,
                 log_group_name: Optional[str] = None,
                 metric_transformations: Optional[Sequence['outputs.MetricTransformationResponse']] = None):
        """
        Definition of awsLogsMetricFilter
        :param str filter_name: The name of the metric filter.
        :param str filter_pattern: A filter pattern for extracting metric data out of ingested log events. For more information, see [Filter and Pattern Syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html).
        :param str log_group_name: The name of an existing log group that you want to associate with this metric filter.
        :param Sequence['MetricTransformationResponse'] metric_transformations: The metric transformations.
        """
        if filter_name is not None:
            pulumi.set(__self__, "filter_name", filter_name)
        if filter_pattern is not None:
            pulumi.set(__self__, "filter_pattern", filter_pattern)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if metric_transformations is not None:
            pulumi.set(__self__, "metric_transformations", metric_transformations)

    @property
    @pulumi.getter(name="filterName")
    def filter_name(self) -> Optional[str]:
        """
        The name of the metric filter.
        """
        return pulumi.get(self, "filter_name")

    @property
    @pulumi.getter(name="filterPattern")
    def filter_pattern(self) -> Optional[str]:
        """
        A filter pattern for extracting metric data out of ingested log events. For more information, see [Filter and Pattern Syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html).
        """
        return pulumi.get(self, "filter_pattern")

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[str]:
        """
        The name of an existing log group that you want to associate with this metric filter.
        """
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter(name="metricTransformations")
    def metric_transformations(self) -> Optional[Sequence['outputs.MetricTransformationResponse']]:
        """
        The metric transformations.
        """
        return pulumi.get(self, "metric_transformations")


@pulumi.output_type
class AwsLogsSubscriptionFilterPropertiesResponse(dict):
    """
    Definition of awsLogsSubscriptionFilter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationArn":
            suggest = "destination_arn"
        elif key == "filterName":
            suggest = "filter_name"
        elif key == "filterPattern":
            suggest = "filter_pattern"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLogsSubscriptionFilterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLogsSubscriptionFilterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLogsSubscriptionFilterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_arn: Optional[str] = None,
                 distribution: Optional[str] = None,
                 filter_name: Optional[str] = None,
                 filter_pattern: Optional[str] = None,
                 log_group_name: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        Definition of awsLogsSubscriptionFilter
        :param str destination_arn: The Amazon Resource Name (ARN) of the destination.
        :param str distribution: The method used to distribute log data to the destination, which can be either random or grouped by log stream.
        :param str filter_name: The name of the subscription filter.
        :param str filter_pattern: The filtering expressions that restrict what gets delivered to the destination AWS resource. For more information about the filter pattern syntax, see [Filter and Pattern Syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html).
        :param str log_group_name: The log group to associate with the subscription filter. All log events that are uploaded to this log group are filtered and delivered to the specified AWS resource if the filter pattern matches the log events.
        :param str role_arn: The ARN of an IAM role that grants CWL permissions to deliver ingested log events to the destination stream. You don't need to provide the ARN when you are working with a logical destination for cross-account delivery.
        """
        if destination_arn is not None:
            pulumi.set(__self__, "destination_arn", destination_arn)
        if distribution is not None:
            pulumi.set(__self__, "distribution", distribution)
        if filter_name is not None:
            pulumi.set(__self__, "filter_name", filter_name)
        if filter_pattern is not None:
            pulumi.set(__self__, "filter_pattern", filter_pattern)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the destination.
        """
        return pulumi.get(self, "destination_arn")

    @property
    @pulumi.getter
    def distribution(self) -> Optional[str]:
        """
        The method used to distribute log data to the destination, which can be either random or grouped by log stream.
        """
        return pulumi.get(self, "distribution")

    @property
    @pulumi.getter(name="filterName")
    def filter_name(self) -> Optional[str]:
        """
        The name of the subscription filter.
        """
        return pulumi.get(self, "filter_name")

    @property
    @pulumi.getter(name="filterPattern")
    def filter_pattern(self) -> Optional[str]:
        """
        The filtering expressions that restrict what gets delivered to the destination AWS resource. For more information about the filter pattern syntax, see [Filter and Pattern Syntax](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html).
        """
        return pulumi.get(self, "filter_pattern")

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[str]:
        """
        The log group to associate with the subscription filter. All log events that are uploaded to this log group are filtered and delivered to the specified AWS resource if the filter pattern matches the log events.
        """
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The ARN of an IAM role that grants CWL permissions to deliver ingested log events to the destination stream. You don't need to provide the ARN when you are working with a logical destination for cross-account delivery.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class AwsMacie2JobSummaryPropertiesResponse(dict):
    """
    Definition of awsMacie2JobSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketCriteria":
            suggest = "bucket_criteria"
        elif key == "bucketDefinitions":
            suggest = "bucket_definitions"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "jobId":
            suggest = "job_id"
        elif key == "jobStatus":
            suggest = "job_status"
        elif key == "jobType":
            suggest = "job_type"
        elif key == "lastRunErrorStatus":
            suggest = "last_run_error_status"
        elif key == "userPausedDetails":
            suggest = "user_paused_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsMacie2JobSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsMacie2JobSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsMacie2JobSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_criteria: Optional['outputs.S3BucketCriteriaForJobResponse'] = None,
                 bucket_definitions: Optional[Sequence['outputs.S3BucketDefinitionForJobResponse']] = None,
                 created_at: Optional[str] = None,
                 job_id: Optional[str] = None,
                 job_status: Optional['outputs.JobStatusEnumValueResponse'] = None,
                 job_type: Optional['outputs.JobTypeEnumValueResponse'] = None,
                 last_run_error_status: Optional['outputs.LastRunErrorStatusResponse'] = None,
                 name: Optional[str] = None,
                 user_paused_details: Optional['outputs.UserPausedDetailsResponse'] = None):
        """
        Definition of awsMacie2JobSummary
        :param 'S3BucketCriteriaForJobResponse' bucket_criteria: <p>The property- and tag-based conditions that determine which S3 buckets are included or excluded from the job's analysis. Each time the job runs, the job uses these criteria to determine which buckets to analyze. A job's definition can contain a bucketCriteria object or a bucketDefinitions array, not both.</p>
        :param Sequence['S3BucketDefinitionForJobResponse'] bucket_definitions: <p>An array of objects, one for each Amazon Web Services account that owns specific S3 buckets for the job to analyze. Each object specifies the account ID for an account and one or more buckets to analyze for that account. A job's definition can contain a bucketDefinitions array or a bucketCriteria object, not both.</p>
        :param str created_at: <p>The date and time, in UTC and extended ISO 8601 format, when the job was created.</p>
        :param str job_id: <p>The unique identifier for the job.</p>
        :param 'JobStatusEnumValueResponse' job_status: <p>The current status of the job. Possible values are:</p> <ul><li><p>CANCELLED - You cancelled the job or, if it's a one-time job, you paused the job and didn't resume it within 30 days.</p></li> <li><p>COMPLETE - For a one-time job, Amazon Macie finished processing the data specified for the job. This value doesn't apply to recurring jobs.</p></li> <li><p>IDLE - For a recurring job, the previous scheduled run is complete and the next scheduled run is pending. This value doesn't apply to one-time jobs.</p></li> <li><p>PAUSED - Macie started running the job but additional processing would exceed the monthly sensitive data discovery quota for your account or one or more member accounts that the job analyzes data for.</p></li> <li><p>RUNNING - For a one-time job, the job is in progress. For a recurring job, a scheduled run is in progress.</p></li> <li><p>USER_PAUSED - You paused the job. If you paused the job while it had a status of RUNNING and you don't resume it within 30 days of pausing it, the job or job run will expire and be cancelled, depending on the job's type. To check the expiration date, refer to the UserPausedDetails.jobExpiresAt property.</p></li></ul>
        :param 'JobTypeEnumValueResponse' job_type: <p>The schedule for running the job. Possible values are:</p> <ul><li><p>ONE_TIME - The job runs only once.</p></li> <li><p>SCHEDULED - The job runs on a daily, weekly, or monthly basis.</p></li></ul>
        :param 'LastRunErrorStatusResponse' last_run_error_status: <p>Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run.</p>
        :param str name: <p>The custom name of the job.</p>
        :param 'UserPausedDetailsResponse' user_paused_details: <p>If the current status of the job is USER_PAUSED, specifies when the job was paused and when the job or job run will expire and be cancelled if it isn't resumed. This value is present only if the value for jobStatus is USER_PAUSED.</p>
        """
        if bucket_criteria is not None:
            pulumi.set(__self__, "bucket_criteria", bucket_criteria)
        if bucket_definitions is not None:
            pulumi.set(__self__, "bucket_definitions", bucket_definitions)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if job_status is not None:
            pulumi.set(__self__, "job_status", job_status)
        if job_type is not None:
            pulumi.set(__self__, "job_type", job_type)
        if last_run_error_status is not None:
            pulumi.set(__self__, "last_run_error_status", last_run_error_status)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if user_paused_details is not None:
            pulumi.set(__self__, "user_paused_details", user_paused_details)

    @property
    @pulumi.getter(name="bucketCriteria")
    def bucket_criteria(self) -> Optional['outputs.S3BucketCriteriaForJobResponse']:
        """
        <p>The property- and tag-based conditions that determine which S3 buckets are included or excluded from the job's analysis. Each time the job runs, the job uses these criteria to determine which buckets to analyze. A job's definition can contain a bucketCriteria object or a bucketDefinitions array, not both.</p>
        """
        return pulumi.get(self, "bucket_criteria")

    @property
    @pulumi.getter(name="bucketDefinitions")
    def bucket_definitions(self) -> Optional[Sequence['outputs.S3BucketDefinitionForJobResponse']]:
        """
        <p>An array of objects, one for each Amazon Web Services account that owns specific S3 buckets for the job to analyze. Each object specifies the account ID for an account and one or more buckets to analyze for that account. A job's definition can contain a bucketDefinitions array or a bucketCriteria object, not both.</p>
        """
        return pulumi.get(self, "bucket_definitions")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        <p>The date and time, in UTC and extended ISO 8601 format, when the job was created.</p>
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[str]:
        """
        <p>The unique identifier for the job.</p>
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="jobStatus")
    def job_status(self) -> Optional['outputs.JobStatusEnumValueResponse']:
        """
        <p>The current status of the job. Possible values are:</p> <ul><li><p>CANCELLED - You cancelled the job or, if it's a one-time job, you paused the job and didn't resume it within 30 days.</p></li> <li><p>COMPLETE - For a one-time job, Amazon Macie finished processing the data specified for the job. This value doesn't apply to recurring jobs.</p></li> <li><p>IDLE - For a recurring job, the previous scheduled run is complete and the next scheduled run is pending. This value doesn't apply to one-time jobs.</p></li> <li><p>PAUSED - Macie started running the job but additional processing would exceed the monthly sensitive data discovery quota for your account or one or more member accounts that the job analyzes data for.</p></li> <li><p>RUNNING - For a one-time job, the job is in progress. For a recurring job, a scheduled run is in progress.</p></li> <li><p>USER_PAUSED - You paused the job. If you paused the job while it had a status of RUNNING and you don't resume it within 30 days of pausing it, the job or job run will expire and be cancelled, depending on the job's type. To check the expiration date, refer to the UserPausedDetails.jobExpiresAt property.</p></li></ul>
        """
        return pulumi.get(self, "job_status")

    @property
    @pulumi.getter(name="jobType")
    def job_type(self) -> Optional['outputs.JobTypeEnumValueResponse']:
        """
        <p>The schedule for running the job. Possible values are:</p> <ul><li><p>ONE_TIME - The job runs only once.</p></li> <li><p>SCHEDULED - The job runs on a daily, weekly, or monthly basis.</p></li></ul>
        """
        return pulumi.get(self, "job_type")

    @property
    @pulumi.getter(name="lastRunErrorStatus")
    def last_run_error_status(self) -> Optional['outputs.LastRunErrorStatusResponse']:
        """
        <p>Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run.</p>
        """
        return pulumi.get(self, "last_run_error_status")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The custom name of the job.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="userPausedDetails")
    def user_paused_details(self) -> Optional['outputs.UserPausedDetailsResponse']:
        """
        <p>If the current status of the job is USER_PAUSED, specifies when the job was paused and when the job or job run will expire and be cancelled if it isn't resumed. This value is present only if the value for jobStatus is USER_PAUSED.</p>
        """
        return pulumi.get(self, "user_paused_details")


@pulumi.output_type
class AwsMacieAllowListPropertiesResponse(dict):
    """
    Definition of awsMacieAllowList
    """
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 criteria: Optional['outputs.CriteriaResponse'] = None,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 status: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsMacieAllowList
        :param str arn: AllowList ARN.
        :param 'CriteriaResponse' criteria: AllowList criteria. The regex or s3 object to use for the AllowList.
        :param str description: Description of AllowList.
        :param str id: AllowList ID.
        :param str name: Name of AllowList.
        :param str status: AllowList status. The status for the AllowList
        :param Sequence['TagResponse'] tags: A collection of tags associated with a resource
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        AllowList ARN.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def criteria(self) -> Optional['outputs.CriteriaResponse']:
        """
        AllowList criteria. The regex or s3 object to use for the AllowList.
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of AllowList.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        AllowList ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of AllowList.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        AllowList status. The status for the AllowList
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        A collection of tags associated with a resource
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsNetworkFirewallFirewallPolicyPropertiesResponse(dict):
    """
    Definition of awsNetworkFirewallFirewallPolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firewallPolicy":
            suggest = "firewall_policy"
        elif key == "firewallPolicyArn":
            suggest = "firewall_policy_arn"
        elif key == "firewallPolicyId":
            suggest = "firewall_policy_id"
        elif key == "firewallPolicyName":
            suggest = "firewall_policy_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsNetworkFirewallFirewallPolicyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsNetworkFirewallFirewallPolicyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsNetworkFirewallFirewallPolicyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 firewall_policy: Optional['outputs.FirewallPolicyResponse'] = None,
                 firewall_policy_arn: Optional[str] = None,
                 firewall_policy_id: Optional[str] = None,
                 firewall_policy_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsNetworkFirewallFirewallPolicy
        :param str description: Property description
        :param 'FirewallPolicyResponse' firewall_policy: Property firewallPolicy
        :param str firewall_policy_arn: A resource ARN.
        :param str firewall_policy_id: Property firewallPolicyId
        :param str firewall_policy_name: Property firewallPolicyName
        :param Sequence['TagResponse'] tags: Property tags
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if firewall_policy is not None:
            pulumi.set(__self__, "firewall_policy", firewall_policy)
        if firewall_policy_arn is not None:
            pulumi.set(__self__, "firewall_policy_arn", firewall_policy_arn)
        if firewall_policy_id is not None:
            pulumi.set(__self__, "firewall_policy_id", firewall_policy_id)
        if firewall_policy_name is not None:
            pulumi.set(__self__, "firewall_policy_name", firewall_policy_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Property description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="firewallPolicy")
    def firewall_policy(self) -> Optional['outputs.FirewallPolicyResponse']:
        """
        Property firewallPolicy
        """
        return pulumi.get(self, "firewall_policy")

    @property
    @pulumi.getter(name="firewallPolicyArn")
    def firewall_policy_arn(self) -> Optional[str]:
        """
        A resource ARN.
        """
        return pulumi.get(self, "firewall_policy_arn")

    @property
    @pulumi.getter(name="firewallPolicyId")
    def firewall_policy_id(self) -> Optional[str]:
        """
        Property firewallPolicyId
        """
        return pulumi.get(self, "firewall_policy_id")

    @property
    @pulumi.getter(name="firewallPolicyName")
    def firewall_policy_name(self) -> Optional[str]:
        """
        Property firewallPolicyName
        """
        return pulumi.get(self, "firewall_policy_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsNetworkFirewallFirewallPropertiesResponse(dict):
    """
    Definition of awsNetworkFirewallFirewall
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteProtection":
            suggest = "delete_protection"
        elif key == "endpointIds":
            suggest = "endpoint_ids"
        elif key == "firewallArn":
            suggest = "firewall_arn"
        elif key == "firewallId":
            suggest = "firewall_id"
        elif key == "firewallName":
            suggest = "firewall_name"
        elif key == "firewallPolicyArn":
            suggest = "firewall_policy_arn"
        elif key == "firewallPolicyChangeProtection":
            suggest = "firewall_policy_change_protection"
        elif key == "subnetChangeProtection":
            suggest = "subnet_change_protection"
        elif key == "subnetMappings":
            suggest = "subnet_mappings"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsNetworkFirewallFirewallPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsNetworkFirewallFirewallPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsNetworkFirewallFirewallPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_protection: Optional[bool] = None,
                 description: Optional[str] = None,
                 endpoint_ids: Optional[Sequence[str]] = None,
                 firewall_arn: Optional[str] = None,
                 firewall_id: Optional[str] = None,
                 firewall_name: Optional[str] = None,
                 firewall_policy_arn: Optional[str] = None,
                 firewall_policy_change_protection: Optional[bool] = None,
                 subnet_change_protection: Optional[bool] = None,
                 subnet_mappings: Optional[Sequence['outputs.SubnetMappingResponse']] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsNetworkFirewallFirewall
        :param bool delete_protection: Property deleteProtection
        :param str description: Property description
        :param Sequence[str] endpoint_ids: Property endpointIds
        :param str firewall_arn: A resource ARN.
        :param str firewall_id: Property firewallId
        :param str firewall_name: Property firewallName
        :param str firewall_policy_arn: A resource ARN.
        :param bool firewall_policy_change_protection: Property firewallPolicyChangeProtection
        :param bool subnet_change_protection: Property subnetChangeProtection
        :param Sequence['SubnetMappingResponse'] subnet_mappings: Property subnetMappings
        :param Sequence['TagResponse'] tags: Property tags
        :param str vpc_id: Property vpcId
        """
        if delete_protection is not None:
            pulumi.set(__self__, "delete_protection", delete_protection)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint_ids is not None:
            pulumi.set(__self__, "endpoint_ids", endpoint_ids)
        if firewall_arn is not None:
            pulumi.set(__self__, "firewall_arn", firewall_arn)
        if firewall_id is not None:
            pulumi.set(__self__, "firewall_id", firewall_id)
        if firewall_name is not None:
            pulumi.set(__self__, "firewall_name", firewall_name)
        if firewall_policy_arn is not None:
            pulumi.set(__self__, "firewall_policy_arn", firewall_policy_arn)
        if firewall_policy_change_protection is not None:
            pulumi.set(__self__, "firewall_policy_change_protection", firewall_policy_change_protection)
        if subnet_change_protection is not None:
            pulumi.set(__self__, "subnet_change_protection", subnet_change_protection)
        if subnet_mappings is not None:
            pulumi.set(__self__, "subnet_mappings", subnet_mappings)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="deleteProtection")
    def delete_protection(self) -> Optional[bool]:
        """
        Property deleteProtection
        """
        return pulumi.get(self, "delete_protection")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Property description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="endpointIds")
    def endpoint_ids(self) -> Optional[Sequence[str]]:
        """
        Property endpointIds
        """
        return pulumi.get(self, "endpoint_ids")

    @property
    @pulumi.getter(name="firewallArn")
    def firewall_arn(self) -> Optional[str]:
        """
        A resource ARN.
        """
        return pulumi.get(self, "firewall_arn")

    @property
    @pulumi.getter(name="firewallId")
    def firewall_id(self) -> Optional[str]:
        """
        Property firewallId
        """
        return pulumi.get(self, "firewall_id")

    @property
    @pulumi.getter(name="firewallName")
    def firewall_name(self) -> Optional[str]:
        """
        Property firewallName
        """
        return pulumi.get(self, "firewall_name")

    @property
    @pulumi.getter(name="firewallPolicyArn")
    def firewall_policy_arn(self) -> Optional[str]:
        """
        A resource ARN.
        """
        return pulumi.get(self, "firewall_policy_arn")

    @property
    @pulumi.getter(name="firewallPolicyChangeProtection")
    def firewall_policy_change_protection(self) -> Optional[bool]:
        """
        Property firewallPolicyChangeProtection
        """
        return pulumi.get(self, "firewall_policy_change_protection")

    @property
    @pulumi.getter(name="subnetChangeProtection")
    def subnet_change_protection(self) -> Optional[bool]:
        """
        Property subnetChangeProtection
        """
        return pulumi.get(self, "subnet_change_protection")

    @property
    @pulumi.getter(name="subnetMappings")
    def subnet_mappings(self) -> Optional[Sequence['outputs.SubnetMappingResponse']]:
        """
        Property subnetMappings
        """
        return pulumi.get(self, "subnet_mappings")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        Property vpcId
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsNetworkFirewallRuleGroupPropertiesResponse(dict):
    """
    Definition of awsNetworkFirewallRuleGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleGroup":
            suggest = "rule_group"
        elif key == "ruleGroupArn":
            suggest = "rule_group_arn"
        elif key == "ruleGroupId":
            suggest = "rule_group_id"
        elif key == "ruleGroupName":
            suggest = "rule_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsNetworkFirewallRuleGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsNetworkFirewallRuleGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsNetworkFirewallRuleGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity: Optional[int] = None,
                 description: Optional[str] = None,
                 rule_group: Optional['outputs.RuleGroupResponse'] = None,
                 rule_group_arn: Optional[str] = None,
                 rule_group_id: Optional[str] = None,
                 rule_group_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 type: Optional[str] = None):
        """
        Definition of awsNetworkFirewallRuleGroup
        :param int capacity: Property capacity
        :param str description: Property description
        :param 'RuleGroupResponse' rule_group: Property ruleGroup
        :param str rule_group_arn: A resource ARN.
        :param str rule_group_id: Property ruleGroupId
        :param str rule_group_name: Property ruleGroupName
        :param Sequence['TagResponse'] tags: Property tags
        :param str type: Property type
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if rule_group is not None:
            pulumi.set(__self__, "rule_group", rule_group)
        if rule_group_arn is not None:
            pulumi.set(__self__, "rule_group_arn", rule_group_arn)
        if rule_group_id is not None:
            pulumi.set(__self__, "rule_group_id", rule_group_id)
        if rule_group_name is not None:
            pulumi.set(__self__, "rule_group_name", rule_group_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        Property capacity
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Property description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ruleGroup")
    def rule_group(self) -> Optional['outputs.RuleGroupResponse']:
        """
        Property ruleGroup
        """
        return pulumi.get(self, "rule_group")

    @property
    @pulumi.getter(name="ruleGroupArn")
    def rule_group_arn(self) -> Optional[str]:
        """
        A resource ARN.
        """
        return pulumi.get(self, "rule_group_arn")

    @property
    @pulumi.getter(name="ruleGroupId")
    def rule_group_id(self) -> Optional[str]:
        """
        Property ruleGroupId
        """
        return pulumi.get(self, "rule_group_id")

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> Optional[str]:
        """
        Property ruleGroupName
        """
        return pulumi.get(self, "rule_group_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Property type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AwsOpenSearchDomainStatusPropertiesResponse(dict):
    """
    Definition of awsOpenSearchDomainStatus
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPolicies":
            suggest = "access_policies"
        elif key == "advancedOptions":
            suggest = "advanced_options"
        elif key == "advancedSecurityOptions":
            suggest = "advanced_security_options"
        elif key == "autoTuneOptions":
            suggest = "auto_tune_options"
        elif key == "changeProgressDetails":
            suggest = "change_progress_details"
        elif key == "clusterConfig":
            suggest = "cluster_config"
        elif key == "cognitoOptions":
            suggest = "cognito_options"
        elif key == "domainEndpointOptions":
            suggest = "domain_endpoint_options"
        elif key == "domainId":
            suggest = "domain_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "domainProcessingStatus":
            suggest = "domain_processing_status"
        elif key == "ebsOptions":
            suggest = "ebs_options"
        elif key == "encryptionAtRestOptions":
            suggest = "encryption_at_rest_options"
        elif key == "endpointV2":
            suggest = "endpoint_v2"
        elif key == "engineVersion":
            suggest = "engine_version"
        elif key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "logPublishingOptions":
            suggest = "log_publishing_options"
        elif key == "modifyingProperties":
            suggest = "modifying_properties"
        elif key == "nodeToNodeEncryptionOptions":
            suggest = "node_to_node_encryption_options"
        elif key == "offPeakWindowOptions":
            suggest = "off_peak_window_options"
        elif key == "serviceSoftwareOptions":
            suggest = "service_software_options"
        elif key == "snapshotOptions":
            suggest = "snapshot_options"
        elif key == "softwareUpdateOptions":
            suggest = "software_update_options"
        elif key == "upgradeProcessing":
            suggest = "upgrade_processing"
        elif key == "vpcOptions":
            suggest = "vpc_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsOpenSearchDomainStatusPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsOpenSearchDomainStatusPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsOpenSearchDomainStatusPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_policies: Optional[str] = None,
                 advanced_options: Optional[Mapping[str, str]] = None,
                 advanced_security_options: Optional['outputs.AdvancedSecurityOptionsResponse'] = None,
                 arn: Optional[str] = None,
                 auto_tune_options: Optional['outputs.AutoTuneOptionsOutputResponse'] = None,
                 change_progress_details: Optional['outputs.ChangeProgressDetailsResponse'] = None,
                 cluster_config: Optional['outputs.ClusterConfigResponse'] = None,
                 cognito_options: Optional['outputs.CognitoOptionsResponse'] = None,
                 created: Optional[bool] = None,
                 deleted: Optional[bool] = None,
                 domain_endpoint_options: Optional['outputs.DomainEndpointOptionsResponse'] = None,
                 domain_id: Optional[str] = None,
                 domain_name: Optional[str] = None,
                 domain_processing_status: Optional['outputs.DomainProcessingStatusTypeEnumValueResponse'] = None,
                 ebs_options: Optional['outputs.EBSOptionsResponse'] = None,
                 encryption_at_rest_options: Optional['outputs.EncryptionAtRestOptionsResponse'] = None,
                 endpoint: Optional[str] = None,
                 endpoint_v2: Optional[str] = None,
                 endpoints: Optional[Mapping[str, str]] = None,
                 engine_version: Optional[str] = None,
                 ip_address_type: Optional['outputs.IPAddressTypeEnumValueResponse'] = None,
                 log_publishing_options: Optional[Mapping[str, 'outputs.LogPublishingOptionResponse']] = None,
                 modifying_properties: Optional[Sequence['outputs.ModifyingPropertiesResponse']] = None,
                 node_to_node_encryption_options: Optional['outputs.NodeToNodeEncryptionOptionsResponse'] = None,
                 off_peak_window_options: Optional['outputs.OffPeakWindowOptionsResponse'] = None,
                 processing: Optional[bool] = None,
                 service_software_options: Optional['outputs.ServiceSoftwareOptionsResponse'] = None,
                 snapshot_options: Optional['outputs.SnapshotOptionsResponse'] = None,
                 software_update_options: Optional['outputs.SoftwareUpdateOptionsResponse'] = None,
                 upgrade_processing: Optional[bool] = None,
                 vpc_options: Optional['outputs.VPCDerivedInfoResponse'] = None):
        """
        Definition of awsOpenSearchDomainStatus
        :param str access_policies: <p>Identity and Access Management (IAM) policy document specifying the access policies for the domain.</p>
        :param Mapping[str, str] advanced_options: <p>Key-value pairs that specify advanced configuration options.</p>
        :param 'AdvancedSecurityOptionsResponse' advanced_security_options: <p>Settings for fine-grained access control.</p>
        :param str arn: <p>The Amazon Resource Name (ARN) of the domain. For more information, see <a href='https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html'>IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i>.</p>
        :param 'AutoTuneOptionsOutputResponse' auto_tune_options: <p>Auto-Tune settings for the domain.</p>
        :param 'ChangeProgressDetailsResponse' change_progress_details: <p>Information about a configuration change happening on the domain.</p>
        :param 'ClusterConfigResponse' cluster_config: <p>Container for the cluster configuration of the domain.</p>
        :param 'CognitoOptionsResponse' cognito_options: <p>Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.</p>
        :param bool created: <p>Creation status of an OpenSearch Service domain. True if domain creation is complete. False if domain creation is still in progress.</p>
        :param bool deleted: <p>Deletion status of an OpenSearch Service domain. True if domain deletion is complete. False if domain deletion is still in progress. Once deletion is complete, the status of the domain is no longer returned.</p>
        :param 'DomainEndpointOptionsResponse' domain_endpoint_options: <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
        :param str domain_id: <p>Unique identifier for the domain.</p>
        :param str domain_name: <p>Name of the domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
        :param 'DomainProcessingStatusTypeEnumValueResponse' domain_processing_status: <p>The status of any changes that are currently in progress for the domain.</p>
        :param 'EBSOptionsResponse' ebs_options: <p>Container for EBS-based storage settings for the domain.</p>
        :param 'EncryptionAtRestOptionsResponse' encryption_at_rest_options: <p>Encryption at rest settings for the domain.</p>
        :param str endpoint: <p>Domain-specific endpoint used to submit index, search, and data upload requests to the domain.</p>
        :param str endpoint_v2: <p>If <code>IPAddressType</code> to set to <code>dualstack</code>, a version 2 domain endpoint is provisioned. This endpoint functions like a normal endpoint, except that it works with both IPv4 and IPv6 IP addresses. Normal endpoints work only with IPv4 IP addresses. </p>
        :param Mapping[str, str] endpoints: <p>The key-value pair that exists if the OpenSearch Service domain uses VPC endpoints. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>.</p>
        :param str engine_version: <p>Version of OpenSearch or Elasticsearch that the domain is running, in the format <code>Elasticsearch_X.Y</code> or <code>OpenSearch_X.Y</code>.</p>
        :param 'IPAddressTypeEnumValueResponse' ip_address_type: <p>The type of IP addresses supported by the endpoint for the domain.</p>
        :param Mapping[str, 'LogPublishingOptionResponse'] log_publishing_options: <p>Log publishing options for the domain.</p>
        :param Sequence['ModifyingPropertiesResponse'] modifying_properties: <p>Information about the domain properties that are currently being modified.</p>
        :param 'NodeToNodeEncryptionOptionsResponse' node_to_node_encryption_options: <p>Whether node-to-node encryption is enabled or disabled.</p>
        :param 'OffPeakWindowOptionsResponse' off_peak_window_options: <p>Options that specify a custom 10-hour window during which OpenSearch Service can perform configuration changes on the domain.</p>
        :param bool processing: <p>The status of the domain configuration. True if OpenSearch Service is processing configuration changes. False if the configuration is active.</p>
        :param 'ServiceSoftwareOptionsResponse' service_software_options: <p>The current status of the domain's service software.</p>
        :param 'SnapshotOptionsResponse' snapshot_options: <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
        :param 'SoftwareUpdateOptionsResponse' software_update_options: <p>Service software update options for the domain.</p>
        :param bool upgrade_processing: <p>The status of a domain version upgrade to a new version of OpenSearch or Elasticsearch. True if OpenSearch Service is in the process of a version upgrade. False if the configuration is active.</p>
        :param 'VPCDerivedInfoResponse' vpc_options: <p>The VPC configuration for the domain.</p>
        """
        if access_policies is not None:
            pulumi.set(__self__, "access_policies", access_policies)
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if advanced_security_options is not None:
            pulumi.set(__self__, "advanced_security_options", advanced_security_options)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if auto_tune_options is not None:
            pulumi.set(__self__, "auto_tune_options", auto_tune_options)
        if change_progress_details is not None:
            pulumi.set(__self__, "change_progress_details", change_progress_details)
        if cluster_config is not None:
            pulumi.set(__self__, "cluster_config", cluster_config)
        if cognito_options is not None:
            pulumi.set(__self__, "cognito_options", cognito_options)
        if created is not None:
            pulumi.set(__self__, "created", created)
        if deleted is not None:
            pulumi.set(__self__, "deleted", deleted)
        if domain_endpoint_options is not None:
            pulumi.set(__self__, "domain_endpoint_options", domain_endpoint_options)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if domain_processing_status is not None:
            pulumi.set(__self__, "domain_processing_status", domain_processing_status)
        if ebs_options is not None:
            pulumi.set(__self__, "ebs_options", ebs_options)
        if encryption_at_rest_options is not None:
            pulumi.set(__self__, "encryption_at_rest_options", encryption_at_rest_options)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if endpoint_v2 is not None:
            pulumi.set(__self__, "endpoint_v2", endpoint_v2)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if engine_version is not None:
            pulumi.set(__self__, "engine_version", engine_version)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if log_publishing_options is not None:
            pulumi.set(__self__, "log_publishing_options", log_publishing_options)
        if modifying_properties is not None:
            pulumi.set(__self__, "modifying_properties", modifying_properties)
        if node_to_node_encryption_options is not None:
            pulumi.set(__self__, "node_to_node_encryption_options", node_to_node_encryption_options)
        if off_peak_window_options is not None:
            pulumi.set(__self__, "off_peak_window_options", off_peak_window_options)
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if service_software_options is not None:
            pulumi.set(__self__, "service_software_options", service_software_options)
        if snapshot_options is not None:
            pulumi.set(__self__, "snapshot_options", snapshot_options)
        if software_update_options is not None:
            pulumi.set(__self__, "software_update_options", software_update_options)
        if upgrade_processing is not None:
            pulumi.set(__self__, "upgrade_processing", upgrade_processing)
        if vpc_options is not None:
            pulumi.set(__self__, "vpc_options", vpc_options)

    @property
    @pulumi.getter(name="accessPolicies")
    def access_policies(self) -> Optional[str]:
        """
        <p>Identity and Access Management (IAM) policy document specifying the access policies for the domain.</p>
        """
        return pulumi.get(self, "access_policies")

    @property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional[Mapping[str, str]]:
        """
        <p>Key-value pairs that specify advanced configuration options.</p>
        """
        return pulumi.get(self, "advanced_options")

    @property
    @pulumi.getter(name="advancedSecurityOptions")
    def advanced_security_options(self) -> Optional['outputs.AdvancedSecurityOptionsResponse']:
        """
        <p>Settings for fine-grained access control.</p>
        """
        return pulumi.get(self, "advanced_security_options")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the domain. For more information, see <a href='https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html'>IAM identifiers </a> in the <i>AWS Identity and Access Management User Guide</i>.</p>
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="autoTuneOptions")
    def auto_tune_options(self) -> Optional['outputs.AutoTuneOptionsOutputResponse']:
        """
        <p>Auto-Tune settings for the domain.</p>
        """
        return pulumi.get(self, "auto_tune_options")

    @property
    @pulumi.getter(name="changeProgressDetails")
    def change_progress_details(self) -> Optional['outputs.ChangeProgressDetailsResponse']:
        """
        <p>Information about a configuration change happening on the domain.</p>
        """
        return pulumi.get(self, "change_progress_details")

    @property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> Optional['outputs.ClusterConfigResponse']:
        """
        <p>Container for the cluster configuration of the domain.</p>
        """
        return pulumi.get(self, "cluster_config")

    @property
    @pulumi.getter(name="cognitoOptions")
    def cognito_options(self) -> Optional['outputs.CognitoOptionsResponse']:
        """
        <p>Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.</p>
        """
        return pulumi.get(self, "cognito_options")

    @property
    @pulumi.getter
    def created(self) -> Optional[bool]:
        """
        <p>Creation status of an OpenSearch Service domain. True if domain creation is complete. False if domain creation is still in progress.</p>
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def deleted(self) -> Optional[bool]:
        """
        <p>Deletion status of an OpenSearch Service domain. True if domain deletion is complete. False if domain deletion is still in progress. Once deletion is complete, the status of the domain is no longer returned.</p>
        """
        return pulumi.get(self, "deleted")

    @property
    @pulumi.getter(name="domainEndpointOptions")
    def domain_endpoint_options(self) -> Optional['outputs.DomainEndpointOptionsResponse']:
        """
        <p>Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.</p>
        """
        return pulumi.get(self, "domain_endpoint_options")

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[str]:
        """
        <p>Unique identifier for the domain.</p>
        """
        return pulumi.get(self, "domain_id")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        <p>Name of the domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.</p>
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainProcessingStatus")
    def domain_processing_status(self) -> Optional['outputs.DomainProcessingStatusTypeEnumValueResponse']:
        """
        <p>The status of any changes that are currently in progress for the domain.</p>
        """
        return pulumi.get(self, "domain_processing_status")

    @property
    @pulumi.getter(name="ebsOptions")
    def ebs_options(self) -> Optional['outputs.EBSOptionsResponse']:
        """
        <p>Container for EBS-based storage settings for the domain.</p>
        """
        return pulumi.get(self, "ebs_options")

    @property
    @pulumi.getter(name="encryptionAtRestOptions")
    def encryption_at_rest_options(self) -> Optional['outputs.EncryptionAtRestOptionsResponse']:
        """
        <p>Encryption at rest settings for the domain.</p>
        """
        return pulumi.get(self, "encryption_at_rest_options")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        <p>Domain-specific endpoint used to submit index, search, and data upload requests to the domain.</p>
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="endpointV2")
    def endpoint_v2(self) -> Optional[str]:
        """
        <p>If <code>IPAddressType</code> to set to <code>dualstack</code>, a version 2 domain endpoint is provisioned. This endpoint functions like a normal endpoint, except that it works with both IPv4 and IPv6 IP addresses. Normal endpoints work only with IPv4 IP addresses. </p>
        """
        return pulumi.get(self, "endpoint_v2")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Mapping[str, str]]:
        """
        <p>The key-value pair that exists if the OpenSearch Service domain uses VPC endpoints. Example <code>key, value</code>: <code>'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'</code>.</p>
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> Optional[str]:
        """
        <p>Version of OpenSearch or Elasticsearch that the domain is running, in the format <code>Elasticsearch_X.Y</code> or <code>OpenSearch_X.Y</code>.</p>
        """
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional['outputs.IPAddressTypeEnumValueResponse']:
        """
        <p>The type of IP addresses supported by the endpoint for the domain.</p>
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="logPublishingOptions")
    def log_publishing_options(self) -> Optional[Mapping[str, 'outputs.LogPublishingOptionResponse']]:
        """
        <p>Log publishing options for the domain.</p>
        """
        return pulumi.get(self, "log_publishing_options")

    @property
    @pulumi.getter(name="modifyingProperties")
    def modifying_properties(self) -> Optional[Sequence['outputs.ModifyingPropertiesResponse']]:
        """
        <p>Information about the domain properties that are currently being modified.</p>
        """
        return pulumi.get(self, "modifying_properties")

    @property
    @pulumi.getter(name="nodeToNodeEncryptionOptions")
    def node_to_node_encryption_options(self) -> Optional['outputs.NodeToNodeEncryptionOptionsResponse']:
        """
        <p>Whether node-to-node encryption is enabled or disabled.</p>
        """
        return pulumi.get(self, "node_to_node_encryption_options")

    @property
    @pulumi.getter(name="offPeakWindowOptions")
    def off_peak_window_options(self) -> Optional['outputs.OffPeakWindowOptionsResponse']:
        """
        <p>Options that specify a custom 10-hour window during which OpenSearch Service can perform configuration changes on the domain.</p>
        """
        return pulumi.get(self, "off_peak_window_options")

    @property
    @pulumi.getter
    def processing(self) -> Optional[bool]:
        """
        <p>The status of the domain configuration. True if OpenSearch Service is processing configuration changes. False if the configuration is active.</p>
        """
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="serviceSoftwareOptions")
    def service_software_options(self) -> Optional['outputs.ServiceSoftwareOptionsResponse']:
        """
        <p>The current status of the domain's service software.</p>
        """
        return pulumi.get(self, "service_software_options")

    @property
    @pulumi.getter(name="snapshotOptions")
    def snapshot_options(self) -> Optional['outputs.SnapshotOptionsResponse']:
        """
        <p>DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.</p>
        """
        return pulumi.get(self, "snapshot_options")

    @property
    @pulumi.getter(name="softwareUpdateOptions")
    def software_update_options(self) -> Optional['outputs.SoftwareUpdateOptionsResponse']:
        """
        <p>Service software update options for the domain.</p>
        """
        return pulumi.get(self, "software_update_options")

    @property
    @pulumi.getter(name="upgradeProcessing")
    def upgrade_processing(self) -> Optional[bool]:
        """
        <p>The status of a domain version upgrade to a new version of OpenSearch or Elasticsearch. True if OpenSearch Service is in the process of a version upgrade. False if the configuration is active.</p>
        """
        return pulumi.get(self, "upgrade_processing")

    @property
    @pulumi.getter(name="vpcOptions")
    def vpc_options(self) -> Optional['outputs.VPCDerivedInfoResponse']:
        """
        <p>The VPC configuration for the domain.</p>
        """
        return pulumi.get(self, "vpc_options")


@pulumi.output_type
class AwsOrganizationsAccountPropertiesResponse(dict):
    """
    Definition of awsOrganizationsAccount
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "joinedMethod":
            suggest = "joined_method"
        elif key == "joinedTimestamp":
            suggest = "joined_timestamp"
        elif key == "parentIds":
            suggest = "parent_ids"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsOrganizationsAccountPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsOrganizationsAccountPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsOrganizationsAccountPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 account_name: Optional[str] = None,
                 arn: Optional[str] = None,
                 email: Optional[str] = None,
                 joined_method: Optional[str] = None,
                 joined_timestamp: Optional[str] = None,
                 parent_ids: Optional[Sequence[str]] = None,
                 role_name: Optional[str] = None,
                 status: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsOrganizationsAccount
        :param str account_id: If the account was created successfully, the unique identifier (ID) of the new account.
        :param str account_name: The friendly name of the member account.
        :param str arn: The Amazon Resource Name (ARN) of the account.
        :param str email: The email address of the owner to assign to the new member account.
        :param str joined_method: The method by which the account joined the organization.
        :param str joined_timestamp: The date the account became a part of the organization.
        :param Sequence[str] parent_ids: List of parent nodes for the member account. Currently only one parent at a time is supported. Default is root.
        :param str role_name: The name of an IAM role that AWS Organizations automatically preconfigures in the new member account. Default name is OrganizationAccountAccessRole if not specified.
        :param str status: The status of the account in the organization.
        :param Sequence['TagResponse'] tags: A list of tags that you want to attach to the newly created account. For each tag in the list, you must specify both a tag key and a value.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if joined_method is not None:
            pulumi.set(__self__, "joined_method", joined_method)
        if joined_timestamp is not None:
            pulumi.set(__self__, "joined_timestamp", joined_timestamp)
        if parent_ids is not None:
            pulumi.set(__self__, "parent_ids", parent_ids)
        if role_name is None:
            role_name = 'OrganizationAccountAccessRole'
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        If the account was created successfully, the unique identifier (ID) of the new account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[str]:
        """
        The friendly name of the member account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the account.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The email address of the owner to assign to the new member account.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="joinedMethod")
    def joined_method(self) -> Optional[str]:
        """
        The method by which the account joined the organization.
        """
        return pulumi.get(self, "joined_method")

    @property
    @pulumi.getter(name="joinedTimestamp")
    def joined_timestamp(self) -> Optional[str]:
        """
        The date the account became a part of the organization.
        """
        return pulumi.get(self, "joined_timestamp")

    @property
    @pulumi.getter(name="parentIds")
    def parent_ids(self) -> Optional[Sequence[str]]:
        """
        List of parent nodes for the member account. Currently only one parent at a time is supported. Default is root.
        """
        return pulumi.get(self, "parent_ids")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[str]:
        """
        The name of an IAM role that AWS Organizations automatically preconfigures in the new member account. Default name is OrganizationAccountAccessRole if not specified.
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the account in the organization.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        A list of tags that you want to attach to the newly created account. For each tag in the list, you must specify both a tag key and a value.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsOrganizationsOrganizationPropertiesResponse(dict):
    """
    Definition of awsOrganizationsOrganization
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureSet":
            suggest = "feature_set"
        elif key == "managementAccountArn":
            suggest = "management_account_arn"
        elif key == "managementAccountEmail":
            suggest = "management_account_email"
        elif key == "managementAccountId":
            suggest = "management_account_id"
        elif key == "rootId":
            suggest = "root_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsOrganizationsOrganizationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsOrganizationsOrganizationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsOrganizationsOrganizationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 feature_set: Optional[str] = None,
                 id: Optional[str] = None,
                 management_account_arn: Optional[str] = None,
                 management_account_email: Optional[str] = None,
                 management_account_id: Optional[str] = None,
                 root_id: Optional[str] = None):
        """
        Definition of awsOrganizationsOrganization
        :param str arn: The Amazon Resource Name (ARN) of an organization.
        :param str feature_set: Specifies the feature set supported by the new organization. Each feature set supports different levels of functionality.
        :param str id: The unique identifier (ID) of an organization.
        :param str management_account_arn: The Amazon Resource Name (ARN) of the account that is designated as the management account for the organization.
        :param str management_account_email: The email address that is associated with the AWS account that is designated as the management account for the organization.
        :param str management_account_id: The unique identifier (ID) of the management account of an organization.
        :param str root_id: The unique identifier (ID) for the root.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if feature_set is None:
            feature_set = 'ALL'
        if feature_set is not None:
            pulumi.set(__self__, "feature_set", feature_set)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if management_account_arn is not None:
            pulumi.set(__self__, "management_account_arn", management_account_arn)
        if management_account_email is not None:
            pulumi.set(__self__, "management_account_email", management_account_email)
        if management_account_id is not None:
            pulumi.set(__self__, "management_account_id", management_account_id)
        if root_id is not None:
            pulumi.set(__self__, "root_id", root_id)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of an organization.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="featureSet")
    def feature_set(self) -> Optional[str]:
        """
        Specifies the feature set supported by the new organization. Each feature set supports different levels of functionality.
        """
        return pulumi.get(self, "feature_set")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The unique identifier (ID) of an organization.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="managementAccountArn")
    def management_account_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the account that is designated as the management account for the organization.
        """
        return pulumi.get(self, "management_account_arn")

    @property
    @pulumi.getter(name="managementAccountEmail")
    def management_account_email(self) -> Optional[str]:
        """
        The email address that is associated with the AWS account that is designated as the management account for the organization.
        """
        return pulumi.get(self, "management_account_email")

    @property
    @pulumi.getter(name="managementAccountId")
    def management_account_id(self) -> Optional[str]:
        """
        The unique identifier (ID) of the management account of an organization.
        """
        return pulumi.get(self, "management_account_id")

    @property
    @pulumi.getter(name="rootId")
    def root_id(self) -> Optional[str]:
        """
        The unique identifier (ID) for the root.
        """
        return pulumi.get(self, "root_id")


@pulumi.output_type
class AwsRdsDBClusterPropertiesResponse(dict):
    """
    Definition of awsRdsDBCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedStorage":
            suggest = "allocated_storage"
        elif key == "associatedRoles":
            suggest = "associated_roles"
        elif key == "autoMinorVersionUpgrade":
            suggest = "auto_minor_version_upgrade"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "backtrackWindow":
            suggest = "backtrack_window"
        elif key == "backupRetentionPeriod":
            suggest = "backup_retention_period"
        elif key == "copyTagsToSnapshot":
            suggest = "copy_tags_to_snapshot"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "dbClusterArn":
            suggest = "db_cluster_arn"
        elif key == "dbClusterIdentifier":
            suggest = "db_cluster_identifier"
        elif key == "dbClusterInstanceClass":
            suggest = "db_cluster_instance_class"
        elif key == "dbClusterParameterGroupName":
            suggest = "db_cluster_parameter_group_name"
        elif key == "dbClusterResourceId":
            suggest = "db_cluster_resource_id"
        elif key == "dbInstanceParameterGroupName":
            suggest = "db_instance_parameter_group_name"
        elif key == "dbSubnetGroupName":
            suggest = "db_subnet_group_name"
        elif key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "deletionProtection":
            suggest = "deletion_protection"
        elif key == "domainIAMRoleName":
            suggest = "domain_iam_role_name"
        elif key == "enableCloudwatchLogsExports":
            suggest = "enable_cloudwatch_logs_exports"
        elif key == "enableGlobalWriteForwarding":
            suggest = "enable_global_write_forwarding"
        elif key == "enableHttpEndpoint":
            suggest = "enable_http_endpoint"
        elif key == "enableIAMDatabaseAuthentication":
            suggest = "enable_iam_database_authentication"
        elif key == "engineMode":
            suggest = "engine_mode"
        elif key == "engineVersion":
            suggest = "engine_version"
        elif key == "globalClusterIdentifier":
            suggest = "global_cluster_identifier"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "manageMasterUserPassword":
            suggest = "manage_master_user_password"
        elif key == "masterUserPassword":
            suggest = "master_user_password"
        elif key == "masterUserSecret":
            suggest = "master_user_secret"
        elif key == "masterUsername":
            suggest = "master_username"
        elif key == "monitoringInterval":
            suggest = "monitoring_interval"
        elif key == "monitoringRoleArn":
            suggest = "monitoring_role_arn"
        elif key == "networkType":
            suggest = "network_type"
        elif key == "performanceInsightsEnabled":
            suggest = "performance_insights_enabled"
        elif key == "performanceInsightsKmsKeyId":
            suggest = "performance_insights_kms_key_id"
        elif key == "performanceInsightsRetentionPeriod":
            suggest = "performance_insights_retention_period"
        elif key == "preferredBackupWindow":
            suggest = "preferred_backup_window"
        elif key == "preferredMaintenanceWindow":
            suggest = "preferred_maintenance_window"
        elif key == "publiclyAccessible":
            suggest = "publicly_accessible"
        elif key == "readEndpoint":
            suggest = "read_endpoint"
        elif key == "replicationSourceIdentifier":
            suggest = "replication_source_identifier"
        elif key == "restoreToTime":
            suggest = "restore_to_time"
        elif key == "restoreType":
            suggest = "restore_type"
        elif key == "scalingConfiguration":
            suggest = "scaling_configuration"
        elif key == "serverlessV2ScalingConfiguration":
            suggest = "serverless_v2_scaling_configuration"
        elif key == "snapshotIdentifier":
            suggest = "snapshot_identifier"
        elif key == "sourceDBClusterIdentifier":
            suggest = "source_db_cluster_identifier"
        elif key == "sourceRegion":
            suggest = "source_region"
        elif key == "storageEncrypted":
            suggest = "storage_encrypted"
        elif key == "storageThroughput":
            suggest = "storage_throughput"
        elif key == "storageType":
            suggest = "storage_type"
        elif key == "useLatestRestorableTime":
            suggest = "use_latest_restorable_time"
        elif key == "vpcSecurityGroupIds":
            suggest = "vpc_security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRdsDBClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRdsDBClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRdsDBClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_storage: Optional[int] = None,
                 associated_roles: Optional[Sequence['outputs.DBClusterRoleResponse']] = None,
                 auto_minor_version_upgrade: Optional[bool] = None,
                 availability_zones: Optional[Sequence[str]] = None,
                 backtrack_window: Optional[int] = None,
                 backup_retention_period: Optional[int] = None,
                 copy_tags_to_snapshot: Optional[bool] = None,
                 database_name: Optional[str] = None,
                 db_cluster_arn: Optional[str] = None,
                 db_cluster_identifier: Optional[str] = None,
                 db_cluster_instance_class: Optional[str] = None,
                 db_cluster_parameter_group_name: Optional[str] = None,
                 db_cluster_resource_id: Optional[str] = None,
                 db_instance_parameter_group_name: Optional[str] = None,
                 db_subnet_group_name: Optional[str] = None,
                 db_system_id: Optional[str] = None,
                 deletion_protection: Optional[bool] = None,
                 domain: Optional[str] = None,
                 domain_iam_role_name: Optional[str] = None,
                 enable_cloudwatch_logs_exports: Optional[Sequence[str]] = None,
                 enable_global_write_forwarding: Optional[bool] = None,
                 enable_http_endpoint: Optional[bool] = None,
                 enable_iam_database_authentication: Optional[bool] = None,
                 endpoint: Optional['outputs.RdsDbClusterEndpointResponse'] = None,
                 engine: Optional[str] = None,
                 engine_mode: Optional[str] = None,
                 engine_version: Optional[str] = None,
                 global_cluster_identifier: Optional[str] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 manage_master_user_password: Optional[bool] = None,
                 master_user_password: Optional[str] = None,
                 master_user_secret: Optional['outputs.MasterUserSecretResponse'] = None,
                 master_username: Optional[str] = None,
                 monitoring_interval: Optional[int] = None,
                 monitoring_role_arn: Optional[str] = None,
                 network_type: Optional[str] = None,
                 performance_insights_enabled: Optional[bool] = None,
                 performance_insights_kms_key_id: Optional[str] = None,
                 performance_insights_retention_period: Optional[int] = None,
                 port: Optional[int] = None,
                 preferred_backup_window: Optional[str] = None,
                 preferred_maintenance_window: Optional[str] = None,
                 publicly_accessible: Optional[bool] = None,
                 read_endpoint: Optional['outputs.ReadEndpointResponse'] = None,
                 replication_source_identifier: Optional[str] = None,
                 restore_to_time: Optional[str] = None,
                 restore_type: Optional[str] = None,
                 scaling_configuration: Optional['outputs.ScalingConfigurationResponse'] = None,
                 serverless_v2_scaling_configuration: Optional['outputs.ServerlessV2ScalingConfigurationResponse'] = None,
                 snapshot_identifier: Optional[str] = None,
                 source_db_cluster_identifier: Optional[str] = None,
                 source_region: Optional[str] = None,
                 storage_encrypted: Optional[bool] = None,
                 storage_throughput: Optional[int] = None,
                 storage_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 use_latest_restorable_time: Optional[bool] = None,
                 vpc_security_group_ids: Optional[Sequence[str]] = None):
        """
        Definition of awsRdsDBCluster
        :param int allocated_storage: The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
        :param Sequence['DBClusterRoleResponse'] associated_roles: Provides a list of the AWS Identity and Access Management (IAM) roles that are associated with the DB cluster. IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other AWS services on your behalf.
        :param bool auto_minor_version_upgrade: A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window. By default, minor engine upgrades are applied automatically.
        :param Sequence[str] availability_zones: A list of Availability Zones (AZs) where instances in the DB cluster can be created. For information on AWS Regions and Availability Zones, see Choosing the Regions and Availability Zones in the Amazon Aurora User Guide.
        :param int backtrack_window: The target backtrack window, in seconds. To disable backtracking, set this value to 0.
        :param int backup_retention_period: The number of days for which automated backups are retained.
        :param bool copy_tags_to_snapshot: A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster. The default is not to copy them.
        :param str database_name: The name of your database. If you don't provide a name, then Amazon RDS won't create a database in this DB cluster. For naming constraints, see Naming Constraints in the Amazon RDS User Guide.
        :param str db_cluster_arn: The Amazon Resource Name (ARN) for the DB cluster.
        :param str db_cluster_identifier: The DB cluster identifier. This parameter is stored as a lowercase string.
        :param str db_cluster_instance_class: The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge.
        :param str db_cluster_parameter_group_name: The name of the DB cluster parameter group to associate with this DB cluster.
        :param str db_cluster_resource_id: The AWS Region-unique, immutable identifier for the DB cluster.
        :param str db_instance_parameter_group_name: The name of the DB parameter group to apply to all instances of the DB cluster.
        :param str db_subnet_group_name: A DB subnet group that you want to associate with this DB cluster.
        :param str db_system_id: Reserved for future use.
        :param bool deletion_protection: A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled.
        :param str domain: The Active Directory directory ID to create the DB cluster in.
        :param str domain_iam_role_name: Specify the name of the IAM role to be used when making API calls to the Directory Service.
        :param Sequence[str] enable_cloudwatch_logs_exports: The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide.
        :param bool enable_global_write_forwarding: Specifies whether to enable this DB cluster to forward write operations to the primary cluster of a global cluster (Aurora global database). By default, write operations are not allowed on Aurora DB clusters that are secondary clusters in an Aurora global database.
        :param bool enable_http_endpoint: A value that indicates whether to enable the HTTP endpoint for DB cluster. By default, the HTTP endpoint is disabled.
        :param bool enable_iam_database_authentication: A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled.
        :param 'RdsDbClusterEndpointResponse' endpoint: Property endpoint
        :param str engine: The name of the database engine to be used for this DB cluster. Valid Values: aurora (for MySQL 5.6-compatible Aurora), aurora-mysql (for MySQL 5.7-compatible Aurora), and aurora-postgresql
        :param str engine_mode: The DB engine mode of the DB cluster, either provisioned, serverless, parallelquery, global, or multimaster.
        :param str engine_version: The version number of the database engine to use.
        :param str global_cluster_identifier: If you are configuring an Aurora global database cluster and want your Aurora DB cluster to be a secondary member in the global database cluster, specify the global cluster ID of the global database cluster. To define the primary database cluster of the global cluster, use the AWS::RDS::GlobalCluster resource.If you aren't configuring a global database cluster, don't specify this property.
        :param int iops: The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster.
        :param str kms_key_id: The Amazon Resource Name (ARN) of the AWS Key Management Service master key that is used to encrypt the database instances in the DB cluster, such as arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. If you enable the StorageEncrypted property but don't specify this property, the default master key is used. If you specify this property, you must set the StorageEncrypted property to true.
        :param bool manage_master_user_password: A value that indicates whether to manage the master user password with AWS Secrets Manager.
        :param str master_user_password: The master password for the DB instance.
        :param 'MasterUserSecretResponse' master_user_secret: Contains the secret managed by RDS in AWS Secrets Manager for the master user password.
        :param str master_username: The name of the master user for the DB cluster. You must specify MasterUsername, unless you specify SnapshotIdentifier. In that case, don't specify MasterUsername.
        :param int monitoring_interval: The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. To turn off collecting Enhanced Monitoring metrics, specify 0. The default is 0.
        :param str monitoring_role_arn: The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.
        :param str network_type: The network type of the DB cluster.
        :param bool performance_insights_enabled: A value that indicates whether to turn on Performance Insights for the DB cluster.
        :param str performance_insights_kms_key_id: The Amazon Web Services KMS key identifier for encryption of Performance Insights data.
        :param int performance_insights_retention_period: The amount of time, in days, to retain Performance Insights data.
        :param int port: The port number on which the instances in the DB cluster accept connections. Default: 3306 if engine is set as aurora or 5432 if set to aurora-postgresql.
        :param str preferred_backup_window: The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see Adjusting the Preferred DB Cluster Maintenance Window in the Amazon Aurora User Guide.
        :param str preferred_maintenance_window: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred DB Cluster Maintenance Window in the Amazon Aurora User Guide.
        :param bool publicly_accessible: A value that indicates whether the DB cluster is publicly accessible.
        :param 'ReadEndpointResponse' read_endpoint: Property readEndpoint
        :param str replication_source_identifier: The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a Read Replica.
        :param str restore_to_time: The date and time to restore the DB cluster to. Value must be a time in Universal Coordinated Time (UTC) format. An example: 2015-03-07T23:45:00Z
        :param str restore_type: The type of restore to be performed. You can specify one of the following values:full-copy - The new DB cluster is restored as a full copy of the source DB cluster.copy-on-write - The new DB cluster is restored as a clone of the source DB cluster.
        :param 'ScalingConfigurationResponse' scaling_configuration: The ScalingConfiguration property type specifies the scaling configuration of an Aurora Serverless DB cluster. The ScalingConfiguration property type specifies the scaling configuration of an Aurora Serverless DB cluster.
        :param 'ServerlessV2ScalingConfigurationResponse' serverless_v2_scaling_configuration: Contains the scaling configuration of an Aurora Serverless v2 DB cluster. Contains the scaling configuration of an Aurora Serverless v2 DB cluster.
        :param str snapshot_identifier: The identifier for the DB snapshot or DB cluster snapshot to restore from.You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB snapshot.After you restore a DB cluster with a SnapshotIdentifier property, you must specify the same SnapshotIdentifier property for any future updates to the DB cluster. When you specify this property for an update, the DB cluster is not restored from the snapshot again, and the data in the database is not changed. However, if you don't specify the SnapshotIdentifier property, an empty DB cluster is created, and the original DB cluster is deleted. If you specify a property that is different from the previous snapshot restore property, the DB cluster is restored from the specified SnapshotIdentifier property, and the original DB cluster is deleted.
        :param str source_db_cluster_identifier: The identifier of the source DB cluster from which to restore.
        :param str source_region: The AWS Region which contains the source DB cluster when replicating a DB cluster. For example, us-east-1.
        :param bool storage_encrypted: Indicates whether the DB instance is encrypted.If you specify the DBClusterIdentifier, SnapshotIdentifier, or SourceDBInstanceIdentifier property, don't specify this property. The value is inherited from the cluster, snapshot, or source DB instance.
        :param int storage_throughput: Specifies the storage throughput value for the DB cluster. This setting applies only to the gp3 storage type.
        :param str storage_type: Specifies the storage type to be associated with the DB cluster.
        :param Sequence['TagResponse'] tags: An array of key-value pairs to apply to this resource.
        :param bool use_latest_restorable_time: A value that indicates whether to restore the DB cluster to the latest restorable backup time. By default, the DB cluster is not restored to the latest restorable backup time.
        :param Sequence[str] vpc_security_group_ids: A list of EC2 VPC security groups to associate with this DB cluster.
        """
        if allocated_storage is not None:
            pulumi.set(__self__, "allocated_storage", allocated_storage)
        if associated_roles is not None:
            pulumi.set(__self__, "associated_roles", associated_roles)
        if auto_minor_version_upgrade is not None:
            pulumi.set(__self__, "auto_minor_version_upgrade", auto_minor_version_upgrade)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if backtrack_window is not None:
            pulumi.set(__self__, "backtrack_window", backtrack_window)
        if backup_retention_period is None:
            backup_retention_period = 1
        if backup_retention_period is not None:
            pulumi.set(__self__, "backup_retention_period", backup_retention_period)
        if copy_tags_to_snapshot is not None:
            pulumi.set(__self__, "copy_tags_to_snapshot", copy_tags_to_snapshot)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if db_cluster_arn is not None:
            pulumi.set(__self__, "db_cluster_arn", db_cluster_arn)
        if db_cluster_identifier is not None:
            pulumi.set(__self__, "db_cluster_identifier", db_cluster_identifier)
        if db_cluster_instance_class is not None:
            pulumi.set(__self__, "db_cluster_instance_class", db_cluster_instance_class)
        if db_cluster_parameter_group_name is None:
            db_cluster_parameter_group_name = 'default.aurora5.6'
        if db_cluster_parameter_group_name is not None:
            pulumi.set(__self__, "db_cluster_parameter_group_name", db_cluster_parameter_group_name)
        if db_cluster_resource_id is not None:
            pulumi.set(__self__, "db_cluster_resource_id", db_cluster_resource_id)
        if db_instance_parameter_group_name is not None:
            pulumi.set(__self__, "db_instance_parameter_group_name", db_instance_parameter_group_name)
        if db_subnet_group_name is not None:
            pulumi.set(__self__, "db_subnet_group_name", db_subnet_group_name)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if deletion_protection is not None:
            pulumi.set(__self__, "deletion_protection", deletion_protection)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if domain_iam_role_name is not None:
            pulumi.set(__self__, "domain_iam_role_name", domain_iam_role_name)
        if enable_cloudwatch_logs_exports is not None:
            pulumi.set(__self__, "enable_cloudwatch_logs_exports", enable_cloudwatch_logs_exports)
        if enable_global_write_forwarding is not None:
            pulumi.set(__self__, "enable_global_write_forwarding", enable_global_write_forwarding)
        if enable_http_endpoint is not None:
            pulumi.set(__self__, "enable_http_endpoint", enable_http_endpoint)
        if enable_iam_database_authentication is not None:
            pulumi.set(__self__, "enable_iam_database_authentication", enable_iam_database_authentication)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if engine_mode is not None:
            pulumi.set(__self__, "engine_mode", engine_mode)
        if engine_version is not None:
            pulumi.set(__self__, "engine_version", engine_version)
        if global_cluster_identifier is not None:
            pulumi.set(__self__, "global_cluster_identifier", global_cluster_identifier)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if manage_master_user_password is not None:
            pulumi.set(__self__, "manage_master_user_password", manage_master_user_password)
        if master_user_password is not None:
            pulumi.set(__self__, "master_user_password", master_user_password)
        if master_user_secret is not None:
            pulumi.set(__self__, "master_user_secret", master_user_secret)
        if master_username is not None:
            pulumi.set(__self__, "master_username", master_username)
        if monitoring_interval is not None:
            pulumi.set(__self__, "monitoring_interval", monitoring_interval)
        if monitoring_role_arn is not None:
            pulumi.set(__self__, "monitoring_role_arn", monitoring_role_arn)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if performance_insights_enabled is not None:
            pulumi.set(__self__, "performance_insights_enabled", performance_insights_enabled)
        if performance_insights_kms_key_id is not None:
            pulumi.set(__self__, "performance_insights_kms_key_id", performance_insights_kms_key_id)
        if performance_insights_retention_period is not None:
            pulumi.set(__self__, "performance_insights_retention_period", performance_insights_retention_period)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if preferred_backup_window is not None:
            pulumi.set(__self__, "preferred_backup_window", preferred_backup_window)
        if preferred_maintenance_window is not None:
            pulumi.set(__self__, "preferred_maintenance_window", preferred_maintenance_window)
        if publicly_accessible is not None:
            pulumi.set(__self__, "publicly_accessible", publicly_accessible)
        if read_endpoint is not None:
            pulumi.set(__self__, "read_endpoint", read_endpoint)
        if replication_source_identifier is not None:
            pulumi.set(__self__, "replication_source_identifier", replication_source_identifier)
        if restore_to_time is not None:
            pulumi.set(__self__, "restore_to_time", restore_to_time)
        if restore_type is None:
            restore_type = 'full-copy'
        if restore_type is not None:
            pulumi.set(__self__, "restore_type", restore_type)
        if scaling_configuration is not None:
            pulumi.set(__self__, "scaling_configuration", scaling_configuration)
        if serverless_v2_scaling_configuration is not None:
            pulumi.set(__self__, "serverless_v2_scaling_configuration", serverless_v2_scaling_configuration)
        if snapshot_identifier is not None:
            pulumi.set(__self__, "snapshot_identifier", snapshot_identifier)
        if source_db_cluster_identifier is not None:
            pulumi.set(__self__, "source_db_cluster_identifier", source_db_cluster_identifier)
        if source_region is not None:
            pulumi.set(__self__, "source_region", source_region)
        if storage_encrypted is not None:
            pulumi.set(__self__, "storage_encrypted", storage_encrypted)
        if storage_throughput is not None:
            pulumi.set(__self__, "storage_throughput", storage_throughput)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_latest_restorable_time is not None:
            pulumi.set(__self__, "use_latest_restorable_time", use_latest_restorable_time)
        if vpc_security_group_ids is not None:
            pulumi.set(__self__, "vpc_security_group_ids", vpc_security_group_ids)

    @property
    @pulumi.getter(name="allocatedStorage")
    def allocated_storage(self) -> Optional[int]:
        """
        The amount of storage in gibibytes (GiB) to allocate to each DB instance in the Multi-AZ DB cluster.
        """
        return pulumi.get(self, "allocated_storage")

    @property
    @pulumi.getter(name="associatedRoles")
    def associated_roles(self) -> Optional[Sequence['outputs.DBClusterRoleResponse']]:
        """
        Provides a list of the AWS Identity and Access Management (IAM) roles that are associated with the DB cluster. IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other AWS services on your behalf.
        """
        return pulumi.get(self, "associated_roles")

    @property
    @pulumi.getter(name="autoMinorVersionUpgrade")
    def auto_minor_version_upgrade(self) -> Optional[bool]:
        """
        A value that indicates whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window. By default, minor engine upgrades are applied automatically.
        """
        return pulumi.get(self, "auto_minor_version_upgrade")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        """
        A list of Availability Zones (AZs) where instances in the DB cluster can be created. For information on AWS Regions and Availability Zones, see Choosing the Regions and Availability Zones in the Amazon Aurora User Guide.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="backtrackWindow")
    def backtrack_window(self) -> Optional[int]:
        """
        The target backtrack window, in seconds. To disable backtracking, set this value to 0.
        """
        return pulumi.get(self, "backtrack_window")

    @property
    @pulumi.getter(name="backupRetentionPeriod")
    def backup_retention_period(self) -> Optional[int]:
        """
        The number of days for which automated backups are retained.
        """
        return pulumi.get(self, "backup_retention_period")

    @property
    @pulumi.getter(name="copyTagsToSnapshot")
    def copy_tags_to_snapshot(self) -> Optional[bool]:
        """
        A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster. The default is not to copy them.
        """
        return pulumi.get(self, "copy_tags_to_snapshot")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The name of your database. If you don't provide a name, then Amazon RDS won't create a database in this DB cluster. For naming constraints, see Naming Constraints in the Amazon RDS User Guide.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="dbClusterArn")
    def db_cluster_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) for the DB cluster.
        """
        return pulumi.get(self, "db_cluster_arn")

    @property
    @pulumi.getter(name="dbClusterIdentifier")
    def db_cluster_identifier(self) -> Optional[str]:
        """
        The DB cluster identifier. This parameter is stored as a lowercase string.
        """
        return pulumi.get(self, "db_cluster_identifier")

    @property
    @pulumi.getter(name="dbClusterInstanceClass")
    def db_cluster_instance_class(self) -> Optional[str]:
        """
        The compute and memory capacity of each DB instance in the Multi-AZ DB cluster, for example db.m6g.xlarge.
        """
        return pulumi.get(self, "db_cluster_instance_class")

    @property
    @pulumi.getter(name="dbClusterParameterGroupName")
    def db_cluster_parameter_group_name(self) -> Optional[str]:
        """
        The name of the DB cluster parameter group to associate with this DB cluster.
        """
        return pulumi.get(self, "db_cluster_parameter_group_name")

    @property
    @pulumi.getter(name="dbClusterResourceId")
    def db_cluster_resource_id(self) -> Optional[str]:
        """
        The AWS Region-unique, immutable identifier for the DB cluster.
        """
        return pulumi.get(self, "db_cluster_resource_id")

    @property
    @pulumi.getter(name="dbInstanceParameterGroupName")
    def db_instance_parameter_group_name(self) -> Optional[str]:
        """
        The name of the DB parameter group to apply to all instances of the DB cluster.
        """
        return pulumi.get(self, "db_instance_parameter_group_name")

    @property
    @pulumi.getter(name="dbSubnetGroupName")
    def db_subnet_group_name(self) -> Optional[str]:
        """
        A DB subnet group that you want to associate with this DB cluster.
        """
        return pulumi.get(self, "db_subnet_group_name")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[str]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> Optional[bool]:
        """
        A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled.
        """
        return pulumi.get(self, "deletion_protection")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The Active Directory directory ID to create the DB cluster in.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="domainIAMRoleName")
    def domain_iam_role_name(self) -> Optional[str]:
        """
        Specify the name of the IAM role to be used when making API calls to the Directory Service.
        """
        return pulumi.get(self, "domain_iam_role_name")

    @property
    @pulumi.getter(name="enableCloudwatchLogsExports")
    def enable_cloudwatch_logs_exports(self) -> Optional[Sequence[str]]:
        """
        The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide.
        """
        return pulumi.get(self, "enable_cloudwatch_logs_exports")

    @property
    @pulumi.getter(name="enableGlobalWriteForwarding")
    def enable_global_write_forwarding(self) -> Optional[bool]:
        """
        Specifies whether to enable this DB cluster to forward write operations to the primary cluster of a global cluster (Aurora global database). By default, write operations are not allowed on Aurora DB clusters that are secondary clusters in an Aurora global database.
        """
        return pulumi.get(self, "enable_global_write_forwarding")

    @property
    @pulumi.getter(name="enableHttpEndpoint")
    def enable_http_endpoint(self) -> Optional[bool]:
        """
        A value that indicates whether to enable the HTTP endpoint for DB cluster. By default, the HTTP endpoint is disabled.
        """
        return pulumi.get(self, "enable_http_endpoint")

    @property
    @pulumi.getter(name="enableIAMDatabaseAuthentication")
    def enable_iam_database_authentication(self) -> Optional[bool]:
        """
        A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled.
        """
        return pulumi.get(self, "enable_iam_database_authentication")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional['outputs.RdsDbClusterEndpointResponse']:
        """
        Property endpoint
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def engine(self) -> Optional[str]:
        """
        The name of the database engine to be used for this DB cluster. Valid Values: aurora (for MySQL 5.6-compatible Aurora), aurora-mysql (for MySQL 5.7-compatible Aurora), and aurora-postgresql
        """
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter(name="engineMode")
    def engine_mode(self) -> Optional[str]:
        """
        The DB engine mode of the DB cluster, either provisioned, serverless, parallelquery, global, or multimaster.
        """
        return pulumi.get(self, "engine_mode")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> Optional[str]:
        """
        The version number of the database engine to use.
        """
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter(name="globalClusterIdentifier")
    def global_cluster_identifier(self) -> Optional[str]:
        """
        If you are configuring an Aurora global database cluster and want your Aurora DB cluster to be a secondary member in the global database cluster, specify the global cluster ID of the global database cluster. To define the primary database cluster of the global cluster, use the AWS::RDS::GlobalCluster resource.If you aren't configuring a global database cluster, don't specify this property.
        """
        return pulumi.get(self, "global_cluster_identifier")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for each DB instance in the Multi-AZ DB cluster.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the AWS Key Management Service master key that is used to encrypt the database instances in the DB cluster, such as arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef. If you enable the StorageEncrypted property but don't specify this property, the default master key is used. If you specify this property, you must set the StorageEncrypted property to true.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="manageMasterUserPassword")
    def manage_master_user_password(self) -> Optional[bool]:
        """
        A value that indicates whether to manage the master user password with AWS Secrets Manager.
        """
        return pulumi.get(self, "manage_master_user_password")

    @property
    @pulumi.getter(name="masterUserPassword")
    def master_user_password(self) -> Optional[str]:
        """
        The master password for the DB instance.
        """
        return pulumi.get(self, "master_user_password")

    @property
    @pulumi.getter(name="masterUserSecret")
    def master_user_secret(self) -> Optional['outputs.MasterUserSecretResponse']:
        """
        Contains the secret managed by RDS in AWS Secrets Manager for the master user password.
        """
        return pulumi.get(self, "master_user_secret")

    @property
    @pulumi.getter(name="masterUsername")
    def master_username(self) -> Optional[str]:
        """
        The name of the master user for the DB cluster. You must specify MasterUsername, unless you specify SnapshotIdentifier. In that case, don't specify MasterUsername.
        """
        return pulumi.get(self, "master_username")

    @property
    @pulumi.getter(name="monitoringInterval")
    def monitoring_interval(self) -> Optional[int]:
        """
        The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB cluster. To turn off collecting Enhanced Monitoring metrics, specify 0. The default is 0.
        """
        return pulumi.get(self, "monitoring_interval")

    @property
    @pulumi.getter(name="monitoringRoleArn")
    def monitoring_role_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.
        """
        return pulumi.get(self, "monitoring_role_arn")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[str]:
        """
        The network type of the DB cluster.
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="performanceInsightsEnabled")
    def performance_insights_enabled(self) -> Optional[bool]:
        """
        A value that indicates whether to turn on Performance Insights for the DB cluster.
        """
        return pulumi.get(self, "performance_insights_enabled")

    @property
    @pulumi.getter(name="performanceInsightsKmsKeyId")
    def performance_insights_kms_key_id(self) -> Optional[str]:
        """
        The Amazon Web Services KMS key identifier for encryption of Performance Insights data.
        """
        return pulumi.get(self, "performance_insights_kms_key_id")

    @property
    @pulumi.getter(name="performanceInsightsRetentionPeriod")
    def performance_insights_retention_period(self) -> Optional[int]:
        """
        The amount of time, in days, to retain Performance Insights data.
        """
        return pulumi.get(self, "performance_insights_retention_period")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number on which the instances in the DB cluster accept connections. Default: 3306 if engine is set as aurora or 5432 if set to aurora-postgresql.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="preferredBackupWindow")
    def preferred_backup_window(self) -> Optional[str]:
        """
        The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter. The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see Adjusting the Preferred DB Cluster Maintenance Window in the Amazon Aurora User Guide.
        """
        return pulumi.get(self, "preferred_backup_window")

    @property
    @pulumi.getter(name="preferredMaintenanceWindow")
    def preferred_maintenance_window(self) -> Optional[str]:
        """
        The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see Adjusting the Preferred DB Cluster Maintenance Window in the Amazon Aurora User Guide.
        """
        return pulumi.get(self, "preferred_maintenance_window")

    @property
    @pulumi.getter(name="publiclyAccessible")
    def publicly_accessible(self) -> Optional[bool]:
        """
        A value that indicates whether the DB cluster is publicly accessible.
        """
        return pulumi.get(self, "publicly_accessible")

    @property
    @pulumi.getter(name="readEndpoint")
    def read_endpoint(self) -> Optional['outputs.ReadEndpointResponse']:
        """
        Property readEndpoint
        """
        return pulumi.get(self, "read_endpoint")

    @property
    @pulumi.getter(name="replicationSourceIdentifier")
    def replication_source_identifier(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a Read Replica.
        """
        return pulumi.get(self, "replication_source_identifier")

    @property
    @pulumi.getter(name="restoreToTime")
    def restore_to_time(self) -> Optional[str]:
        """
        The date and time to restore the DB cluster to. Value must be a time in Universal Coordinated Time (UTC) format. An example: 2015-03-07T23:45:00Z
        """
        return pulumi.get(self, "restore_to_time")

    @property
    @pulumi.getter(name="restoreType")
    def restore_type(self) -> Optional[str]:
        """
        The type of restore to be performed. You can specify one of the following values:full-copy - The new DB cluster is restored as a full copy of the source DB cluster.copy-on-write - The new DB cluster is restored as a clone of the source DB cluster.
        """
        return pulumi.get(self, "restore_type")

    @property
    @pulumi.getter(name="scalingConfiguration")
    def scaling_configuration(self) -> Optional['outputs.ScalingConfigurationResponse']:
        """
        The ScalingConfiguration property type specifies the scaling configuration of an Aurora Serverless DB cluster. The ScalingConfiguration property type specifies the scaling configuration of an Aurora Serverless DB cluster.
        """
        return pulumi.get(self, "scaling_configuration")

    @property
    @pulumi.getter(name="serverlessV2ScalingConfiguration")
    def serverless_v2_scaling_configuration(self) -> Optional['outputs.ServerlessV2ScalingConfigurationResponse']:
        """
        Contains the scaling configuration of an Aurora Serverless v2 DB cluster. Contains the scaling configuration of an Aurora Serverless v2 DB cluster.
        """
        return pulumi.get(self, "serverless_v2_scaling_configuration")

    @property
    @pulumi.getter(name="snapshotIdentifier")
    def snapshot_identifier(self) -> Optional[str]:
        """
        The identifier for the DB snapshot or DB cluster snapshot to restore from.You can use either the name or the Amazon Resource Name (ARN) to specify a DB cluster snapshot. However, you can use only the ARN to specify a DB snapshot.After you restore a DB cluster with a SnapshotIdentifier property, you must specify the same SnapshotIdentifier property for any future updates to the DB cluster. When you specify this property for an update, the DB cluster is not restored from the snapshot again, and the data in the database is not changed. However, if you don't specify the SnapshotIdentifier property, an empty DB cluster is created, and the original DB cluster is deleted. If you specify a property that is different from the previous snapshot restore property, the DB cluster is restored from the specified SnapshotIdentifier property, and the original DB cluster is deleted.
        """
        return pulumi.get(self, "snapshot_identifier")

    @property
    @pulumi.getter(name="sourceDBClusterIdentifier")
    def source_db_cluster_identifier(self) -> Optional[str]:
        """
        The identifier of the source DB cluster from which to restore.
        """
        return pulumi.get(self, "source_db_cluster_identifier")

    @property
    @pulumi.getter(name="sourceRegion")
    def source_region(self) -> Optional[str]:
        """
        The AWS Region which contains the source DB cluster when replicating a DB cluster. For example, us-east-1.
        """
        return pulumi.get(self, "source_region")

    @property
    @pulumi.getter(name="storageEncrypted")
    def storage_encrypted(self) -> Optional[bool]:
        """
        Indicates whether the DB instance is encrypted.If you specify the DBClusterIdentifier, SnapshotIdentifier, or SourceDBInstanceIdentifier property, don't specify this property. The value is inherited from the cluster, snapshot, or source DB instance.
        """
        return pulumi.get(self, "storage_encrypted")

    @property
    @pulumi.getter(name="storageThroughput")
    def storage_throughput(self) -> Optional[int]:
        """
        Specifies the storage throughput value for the DB cluster. This setting applies only to the gp3 storage type.
        """
        return pulumi.get(self, "storage_throughput")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[str]:
        """
        Specifies the storage type to be associated with the DB cluster.
        """
        return pulumi.get(self, "storage_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An array of key-value pairs to apply to this resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="useLatestRestorableTime")
    def use_latest_restorable_time(self) -> Optional[bool]:
        """
        A value that indicates whether to restore the DB cluster to the latest restorable backup time. By default, the DB cluster is not restored to the latest restorable backup time.
        """
        return pulumi.get(self, "use_latest_restorable_time")

    @property
    @pulumi.getter(name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of EC2 VPC security groups to associate with this DB cluster.
        """
        return pulumi.get(self, "vpc_security_group_ids")


@pulumi.output_type
class AwsRdsDBInstancePropertiesResponse(dict):
    """
    Definition of awsRdsDBInstance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedStorage":
            suggest = "allocated_storage"
        elif key == "allowMajorVersionUpgrade":
            suggest = "allow_major_version_upgrade"
        elif key == "associatedRoles":
            suggest = "associated_roles"
        elif key == "autoMinorVersionUpgrade":
            suggest = "auto_minor_version_upgrade"
        elif key == "automaticBackupReplicationKmsKeyId":
            suggest = "automatic_backup_replication_kms_key_id"
        elif key == "automaticBackupReplicationRegion":
            suggest = "automatic_backup_replication_region"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "backupRetentionPeriod":
            suggest = "backup_retention_period"
        elif key == "caCertificateIdentifier":
            suggest = "ca_certificate_identifier"
        elif key == "certificateDetails":
            suggest = "certificate_details"
        elif key == "certificateRotationRestart":
            suggest = "certificate_rotation_restart"
        elif key == "characterSetName":
            suggest = "character_set_name"
        elif key == "copyTagsToSnapshot":
            suggest = "copy_tags_to_snapshot"
        elif key == "customIAMInstanceProfile":
            suggest = "custom_iam_instance_profile"
        elif key == "dbClusterIdentifier":
            suggest = "db_cluster_identifier"
        elif key == "dbClusterSnapshotIdentifier":
            suggest = "db_cluster_snapshot_identifier"
        elif key == "dbInstanceArn":
            suggest = "db_instance_arn"
        elif key == "dbInstanceClass":
            suggest = "db_instance_class"
        elif key == "dbInstanceIdentifier":
            suggest = "db_instance_identifier"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "dbParameterGroupName":
            suggest = "db_parameter_group_name"
        elif key == "dbSecurityGroups":
            suggest = "db_security_groups"
        elif key == "dbSnapshotIdentifier":
            suggest = "db_snapshot_identifier"
        elif key == "dbSubnetGroupName":
            suggest = "db_subnet_group_name"
        elif key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "dbiResourceId":
            suggest = "dbi_resource_id"
        elif key == "dedicatedLogVolume":
            suggest = "dedicated_log_volume"
        elif key == "deleteAutomatedBackups":
            suggest = "delete_automated_backups"
        elif key == "deletionProtection":
            suggest = "deletion_protection"
        elif key == "domainAuthSecretArn":
            suggest = "domain_auth_secret_arn"
        elif key == "domainDnsIps":
            suggest = "domain_dns_ips"
        elif key == "domainFqdn":
            suggest = "domain_fqdn"
        elif key == "domainIAMRoleName":
            suggest = "domain_iam_role_name"
        elif key == "domainOu":
            suggest = "domain_ou"
        elif key == "enableCloudwatchLogsExports":
            suggest = "enable_cloudwatch_logs_exports"
        elif key == "enableIAMDatabaseAuthentication":
            suggest = "enable_iam_database_authentication"
        elif key == "enablePerformanceInsights":
            suggest = "enable_performance_insights"
        elif key == "engineVersion":
            suggest = "engine_version"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "licenseModel":
            suggest = "license_model"
        elif key == "manageMasterUserPassword":
            suggest = "manage_master_user_password"
        elif key == "masterUserPassword":
            suggest = "master_user_password"
        elif key == "masterUserSecret":
            suggest = "master_user_secret"
        elif key == "masterUsername":
            suggest = "master_username"
        elif key == "maxAllocatedStorage":
            suggest = "max_allocated_storage"
        elif key == "monitoringInterval":
            suggest = "monitoring_interval"
        elif key == "monitoringRoleArn":
            suggest = "monitoring_role_arn"
        elif key == "multiAZ":
            suggest = "multi_az"
        elif key == "ncharCharacterSetName":
            suggest = "nchar_character_set_name"
        elif key == "networkType":
            suggest = "network_type"
        elif key == "optionGroupName":
            suggest = "option_group_name"
        elif key == "performanceInsightsKMSKeyId":
            suggest = "performance_insights_kms_key_id"
        elif key == "performanceInsightsRetentionPeriod":
            suggest = "performance_insights_retention_period"
        elif key == "preferredBackupWindow":
            suggest = "preferred_backup_window"
        elif key == "preferredMaintenanceWindow":
            suggest = "preferred_maintenance_window"
        elif key == "processorFeatures":
            suggest = "processor_features"
        elif key == "promotionTier":
            suggest = "promotion_tier"
        elif key == "publiclyAccessible":
            suggest = "publicly_accessible"
        elif key == "replicaMode":
            suggest = "replica_mode"
        elif key == "restoreTime":
            suggest = "restore_time"
        elif key == "sourceDBClusterIdentifier":
            suggest = "source_db_cluster_identifier"
        elif key == "sourceDBInstanceAutomatedBackupsArn":
            suggest = "source_db_instance_automated_backups_arn"
        elif key == "sourceDBInstanceIdentifier":
            suggest = "source_db_instance_identifier"
        elif key == "sourceDbiResourceId":
            suggest = "source_dbi_resource_id"
        elif key == "sourceRegion":
            suggest = "source_region"
        elif key == "storageEncrypted":
            suggest = "storage_encrypted"
        elif key == "storageThroughput":
            suggest = "storage_throughput"
        elif key == "storageType":
            suggest = "storage_type"
        elif key == "tdeCredentialArn":
            suggest = "tde_credential_arn"
        elif key == "tdeCredentialPassword":
            suggest = "tde_credential_password"
        elif key == "useDefaultProcessorFeatures":
            suggest = "use_default_processor_features"
        elif key == "useLatestRestorableTime":
            suggest = "use_latest_restorable_time"
        elif key == "vpcSecurityGroups":
            suggest = "vpc_security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRdsDBInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRdsDBInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRdsDBInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_storage: Optional[str] = None,
                 allow_major_version_upgrade: Optional[bool] = None,
                 associated_roles: Optional[Sequence['outputs.DBInstanceRoleResponse']] = None,
                 auto_minor_version_upgrade: Optional[bool] = None,
                 automatic_backup_replication_kms_key_id: Optional[str] = None,
                 automatic_backup_replication_region: Optional[str] = None,
                 availability_zone: Optional[str] = None,
                 backup_retention_period: Optional[int] = None,
                 ca_certificate_identifier: Optional[str] = None,
                 certificate_details: Optional['outputs.CertificateDetailsResponse'] = None,
                 certificate_rotation_restart: Optional[bool] = None,
                 character_set_name: Optional[str] = None,
                 copy_tags_to_snapshot: Optional[bool] = None,
                 custom_iam_instance_profile: Optional[str] = None,
                 db_cluster_identifier: Optional[str] = None,
                 db_cluster_snapshot_identifier: Optional[str] = None,
                 db_instance_arn: Optional[str] = None,
                 db_instance_class: Optional[str] = None,
                 db_instance_identifier: Optional[str] = None,
                 db_name: Optional[str] = None,
                 db_parameter_group_name: Optional[str] = None,
                 db_security_groups: Optional[Sequence[str]] = None,
                 db_snapshot_identifier: Optional[str] = None,
                 db_subnet_group_name: Optional[str] = None,
                 db_system_id: Optional[str] = None,
                 dbi_resource_id: Optional[str] = None,
                 dedicated_log_volume: Optional[bool] = None,
                 delete_automated_backups: Optional[bool] = None,
                 deletion_protection: Optional[bool] = None,
                 domain: Optional[str] = None,
                 domain_auth_secret_arn: Optional[str] = None,
                 domain_dns_ips: Optional[Sequence[str]] = None,
                 domain_fqdn: Optional[str] = None,
                 domain_iam_role_name: Optional[str] = None,
                 domain_ou: Optional[str] = None,
                 enable_cloudwatch_logs_exports: Optional[Sequence[str]] = None,
                 enable_iam_database_authentication: Optional[bool] = None,
                 enable_performance_insights: Optional[bool] = None,
                 endpoint: Optional['outputs.RdsDbInstanceEndpointResponse'] = None,
                 engine: Optional[str] = None,
                 engine_version: Optional[str] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 license_model: Optional[str] = None,
                 manage_master_user_password: Optional[bool] = None,
                 master_user_password: Optional[str] = None,
                 master_user_secret: Optional['outputs.MasterUserSecretResponse'] = None,
                 master_username: Optional[str] = None,
                 max_allocated_storage: Optional[int] = None,
                 monitoring_interval: Optional[int] = None,
                 monitoring_role_arn: Optional[str] = None,
                 multi_az: Optional[bool] = None,
                 nchar_character_set_name: Optional[str] = None,
                 network_type: Optional[str] = None,
                 option_group_name: Optional[str] = None,
                 performance_insights_kms_key_id: Optional[str] = None,
                 performance_insights_retention_period: Optional[int] = None,
                 port: Optional[str] = None,
                 preferred_backup_window: Optional[str] = None,
                 preferred_maintenance_window: Optional[str] = None,
                 processor_features: Optional[Sequence['outputs.ProcessorFeatureResponse']] = None,
                 promotion_tier: Optional[int] = None,
                 publicly_accessible: Optional[bool] = None,
                 replica_mode: Optional[str] = None,
                 restore_time: Optional[str] = None,
                 source_db_cluster_identifier: Optional[str] = None,
                 source_db_instance_automated_backups_arn: Optional[str] = None,
                 source_db_instance_identifier: Optional[str] = None,
                 source_dbi_resource_id: Optional[str] = None,
                 source_region: Optional[str] = None,
                 storage_encrypted: Optional[bool] = None,
                 storage_throughput: Optional[int] = None,
                 storage_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 tde_credential_arn: Optional[str] = None,
                 tde_credential_password: Optional[str] = None,
                 timezone: Optional[str] = None,
                 use_default_processor_features: Optional[bool] = None,
                 use_latest_restorable_time: Optional[bool] = None,
                 vpc_security_groups: Optional[Sequence[str]] = None):
        """
        Definition of awsRdsDBInstance
        :param str allocated_storage: The amount of storage in gibibytes (GiB) to be initially allocated for the database instance.  If any value is set in the ``Iops`` parameter, ``AllocatedStorage`` must be at least 100 GiB, which corresponds to the minimum Iops value of 1,000. If you increase the ``Iops`` value (in 1,000 IOPS increments), then you must also increase the ``AllocatedStorage`` value (in 100-GiB increments).    *Amazon Aurora*  Not applicable. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume.  *Db2*  Constraints to the amount of storage for each storage type are the following:  +  General Purpose (SSD) storage (gp3): Must be an integer from 20 to 64000.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 64000.    *MySQL*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.  +  Magnetic storage (standard): Must be an integer from 5 to 3072.    *MariaDB*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.  +  Magnetic storage (standard): Must be an integer from 5 to 3072.    *PostgreSQL*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.  +  Magnetic storage (standard): Must be an integer from 5 to 3072.    *Oracle*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.  +  Magnetic storage (standard): Must be an integer from 10 to 3072.    *SQL Server*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2):  +  Enterprise and Standard editions: Must be an integer from 20 to 16384.  +  Web and Express editions: Must be an integer from 20 to 16384.    +  Provisioned IOPS storage (io1):  +  Enterprise and Standard editions: Must be an integer from 20 to 16384.  +  Web and Express editions: Must be an integer from 20 to 16384.    +  Magnetic storage (standard):  +  Enterprise and Standard editions: Must be an integer from 20 to 1024.  +  Web and Express editions: Must be an integer from 20 to 1024.
        :param bool allow_major_version_upgrade: A value that indicates whether major version upgrades are allowed. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible. Constraints: Major version upgrades must be allowed when specifying a value for the ``EngineVersion`` parameter that is a different major version than the DB instance's current version.
        :param Sequence['DBInstanceRoleResponse'] associated_roles: The IAMlong (IAM) roles associated with the DB instance.   *Amazon Aurora*  Not applicable. The associated roles are managed by the DB cluster.
        :param bool auto_minor_version_upgrade: A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window. By default, minor engine upgrades are applied automatically.
        :param str automatic_backup_replication_kms_key_id: Property automaticBackupReplicationKmsKeyId
        :param str automatic_backup_replication_region: The destination region for the backup replication of the DB instance. For more info, see [Replicating automated backups to another Region](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ReplicateBackups.html) in the *Amazon RDS User Guide*.
        :param str availability_zone: The Availability Zone (AZ) where the database will be created. For information on AWS-Regions and Availability Zones, see [Regions and Availability Zones](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html). For Amazon Aurora, each Aurora DB cluster hosts copies of its storage in three separate Availability Zones. Specify one of these Availability Zones. Aurora automatically chooses an appropriate Availability Zone if you don't specify one. Default: A random, system-chosen Availability Zone in the endpoint's AWS-Region. Constraints:  +  The ``AvailabilityZone`` parameter can't be specified if the DB instance is a Multi-AZ deployment.  +  The specified Availability Zone must be in the same AWS-Region as the current endpoint.   Example: ``us-east-1d``
        :param int backup_retention_period: The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.  *Amazon Aurora*  Not applicable. The retention period for automated backups is managed by the DB cluster. Default: 1 Constraints:  +  Must be a value from 0 to 35  +  Can't be set to 0 if the DB instance is a source to read replicas
        :param str ca_certificate_identifier: The identifier of the CA certificate for this DB instance. For more information, see [Using SSL/TLS to encrypt a connection to a DB instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html) in the *Amazon RDS User Guide* and [Using SSL/TLS to encrypt a connection to a DB cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL.html) in the *Amazon Aurora User Guide*.
        :param 'CertificateDetailsResponse' certificate_details: The details of the DB instance's server certificate. Returns the details of the DB instances server certificate. For more information, see [Using SSL/TLS to encrypt a connection to a DB instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html) in the *Amazon RDS User Guide* and [Using SSL/TLS to encrypt a connection to a DB cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL.html) in the *Amazon Aurora User Guide*.
        :param bool certificate_rotation_restart: Specifies whether the DB instance is restarted when you rotate your SSL/TLS certificate. By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate is not updated until the DB instance is restarted.  Set this parameter only if you are *not* using SSL/TLS to connect to the DB instance.  If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your DB engine to rotate your SSL/TLS certificate:  +  For more information about rotating your SSL/TLS certificate for RDS DB engines, see [Rotating Your SSL/TLS Certificate.](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html) in the *Amazon RDS User Guide.*   +  For more information about rotating your SSL/TLS certificate for Aurora DB engines, see [Rotating Your SSL/TLS Certificate](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html) in the *Amazon Aurora User Guide*.   This setting doesn't apply to RDS Custom DB instances.
        :param str character_set_name: For supported engines, indicates that the DB instance should be associated with the specified character set.  *Amazon Aurora*  Not applicable. The character set is managed by the DB cluster. For more information, see [AWS::RDS::DBCluster](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html).
        :param bool copy_tags_to_snapshot: Specifies whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied. This setting doesn't apply to Amazon Aurora DB instances. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting.
        :param str custom_iam_instance_profile: The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance. This setting is required for RDS Custom. Constraints:  +  The profile must exist in your account.  +  The profile must have an IAM role that Amazon EC2 has permissions to assume.  +  The instance profile name and the associated IAM role name must start with the prefix ``AWSRDSCustom``.   For the list of permissions required for the IAM role, see [Configure IAM and your VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc) in the *Amazon RDS User Guide*.
        :param str db_cluster_identifier: The identifier of the DB cluster that the instance will belong to.
        :param str db_cluster_snapshot_identifier: The identifier for the Multi-AZ DB cluster snapshot to restore from. For more information on Multi-AZ DB clusters, see [Multi-AZ DB cluster deployments](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the *Amazon RDS User Guide*. Constraints:  +  Must match the identifier of an existing Multi-AZ DB cluster snapshot.  +  Can't be specified when ``DBSnapshotIdentifier`` is specified.  +  Must be specified when ``DBSnapshotIdentifier`` isn't specified.  +  If you are restoring from a shared manual Multi-AZ DB cluster snapshot, the ``DBClusterSnapshotIdentifier`` must be the ARN of the shared snapshot.  +  Can't be the identifier of an Aurora DB cluster snapshot.
        :param str db_instance_arn: Property dbInstanceArn
        :param str db_instance_class: The compute and memory capacity of the DB instance, for example ``db.m5.large``. Not all DB instance classes are available in all AWS-Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB instance classes](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the *Amazon RDS User Guide* or [Aurora DB instance classes](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.DBInstanceClass.html) in the *Amazon Aurora User Guide*.
        :param str db_instance_identifier: A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the DB instance. For more information, see [Name Type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html). For information about constraints that apply to DB instance identifiers, see [Naming constraints in Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints) in the *Amazon RDS User Guide*.  If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        :param str db_name: The meaning of this parameter differs according to the database engine you use.  If you specify the ``DBSnapshotIdentifier`` property, this property only applies to RDS for Oracle.   *Amazon Aurora*  Not applicable. The database name is managed by the DB cluster.  *Db2*  The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance. Constraints:  +  Must contain 1 to 64 letters or numbers.  +  Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).  +  Can't be a word reserved by the specified database engine.    *MySQL*  The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints:  +  Must contain 1 to 64 letters or numbers.  +  Can't be a word reserved by the specified database engine    *MariaDB*  The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints:  +  Must contain 1 to 64 letters or numbers.  +  Can't be a word reserved by the specified database engine    *PostgreSQL*  The name of the database to create when the DB instance is created. If this parameter is not specified, the default ``postgres`` database is created in the DB instance. Constraints:  +  Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).  +  Must contain 1 to 63 characters.  +  Can't be a word reserved by the specified database engine    *Oracle*  The Oracle System ID (SID) of the created DB instance. If you specify ``null``, the default value ``ORCL`` is used. You can't specify the string NULL, or any other reserved word, for ``DBName``.  Default: ``ORCL``  Constraints:  +  Can't be longer than 8 characters    *SQL Server*  Not applicable. Must be null.
        :param str db_parameter_group_name: The name of an existing DB parameter group or a reference to an [AWS::RDS::DBParameterGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbparametergroup.html) resource created in the template. To list all of the available DB parameter group names, use the following command:  ``aws rds describe-db-parameter-groups --query 'DBParameterGroups[].DBParameterGroupName' --output text``   If any of the data members of the referenced parameter group are changed during an update, the DB instance might need to be restarted, which causes some interruption. If the parameter group contains static parameters, whether they were changed or not, an update triggers a reboot.  If you don't specify a value for ``DBParameterGroupName`` property, the default DB parameter group for the specified engine and engine version is used.
        :param Sequence[str] db_security_groups: A list of the DB security groups to assign to the DB instance. The list can include both the name of existing DB security groups or references to AWS::RDS::DBSecurityGroup resources created in the template.  If you set DBSecurityGroups, you must not set VPCSecurityGroups, and vice versa. Also, note that the DBSecurityGroups property exists only for backwards compatibility with older regions and is no longer recommended for providing security information to an RDS DB instance. Instead, use VPCSecurityGroups.  If you specify this property, AWS CloudFormation sends only the following properties (if specified) to Amazon RDS during create operations:  +   ``AllocatedStorage``   +   ``AutoMinorVersionUpgrade``   +   ``AvailabilityZone``   +   ``BackupRetentionPeriod``   +   ``CharacterSetName``   +   ``DBInstanceClass``   +   ``DBName``   +   ``DBParameterGroupName``   +   ``DBSecurityGroups``   +   ``DBSubnetGroupName``   +   ``Engine``   +   ``EngineVersion``   +   ``Iops``   +   ``LicenseModel``   +   ``MasterUsername``   +   ``MasterUserPassword``   +   ``MultiAZ``   +   ``OptionGroupName``   +   ``PreferredBackupWindow``   +   ``PreferredMaintenanceWindow``    All other properties are ignored. Specify a virtual private cloud (VPC) security group if you want to submit other properties, such as ``StorageType``, ``StorageEncrypted``, or ``KmsKeyId``. If you're already using the ``DBSecurityGroups`` property, you can't use these other properties by updating your DB instance to use a VPC security group. You must recreate the DB instance.
        :param str db_snapshot_identifier: The name or Amazon Resource Name (ARN) of the DB snapshot that's used to restore the DB instance. If you're restoring from a shared manual DB snapshot, you must specify the ARN of the snapshot. By specifying this property, you can create a DB instance from the specified DB snapshot. If the ``DBSnapshotIdentifier`` property is an empty string or the ``AWS::RDS::DBInstance`` declaration has no ``DBSnapshotIdentifier`` property, AWS CloudFormation creates a new database. If the property contains a value (other than an empty string), AWS CloudFormation creates a database from the specified snapshot. If a snapshot with the specified name doesn't exist, AWS CloudFormation can't create the database and it rolls back the stack. Some DB instance properties aren't valid when you restore from a snapshot, such as the ``MasterUsername`` and ``MasterUserPassword`` properties. For information about the properties that you can specify, see the ``RestoreDBInstanceFromDBSnapshot`` action in the *Amazon RDS API Reference*. After you restore a DB instance with a ``DBSnapshotIdentifier`` property, you must specify the same ``DBSnapshotIdentifier`` property for any future updates to the DB instance. When you specify this property for an update, the DB instance is not restored from the DB snapshot again, and the data in the database is not changed. However, if you don't specify the ``DBSnapshotIdentifier`` property, an empty DB instance is created, and the original DB instance is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB instance is restored from the specified ``DBSnapshotIdentifier`` property, and the original DB instance is deleted. If you specify the ``DBSnapshotIdentifier`` property to restore a DB instance (as opposed to specifying it for DB instance updates), then don't specify the following properties:  +   ``CharacterSetName``   +   ``DBClusterIdentifier``   +   ``DBName``   +   ``DeleteAutomatedBackups``   +   ``EnablePerformanceInsights``   +   ``KmsKeyId``   +   ``MasterUsername``   +   ``MasterUserPassword``   +   ``PerformanceInsightsKMSKeyId``   +   ``PerformanceInsightsRetentionPeriod``   +   ``PromotionTier``   +   ``SourceDBInstanceIdentifier``   +   ``SourceRegion``   +   ``StorageEncrypted`` (for an encrypted snapshot)  +   ``Timezone``     *Amazon Aurora*  Not applicable. Snapshot restore is managed by the DB cluster.
        :param str db_subnet_group_name: A DB subnet group to associate with the DB instance. If you update this value, the new subnet group must be a subnet group in a new VPC.  If there's no DB subnet group, then the DB instance isn't a VPC DB instance. For more information about using Amazon RDS in a VPC, see [Using Amazon RDS with Amazon Virtual Private Cloud (VPC)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html) in the *Amazon RDS User Guide*.   *Amazon Aurora*  Not applicable. The DB subnet group is managed by the DB cluster. If specified, the setting must match the DB cluster setting.
        :param str db_system_id: The Oracle system identifier (SID), which is the name of the Oracle database instance that manages your database files. In this context, the term 'Oracle database instance' refers exclusively to the system global area (SGA) and Oracle background processes. If you don't specify a SID, the value defaults to ``RDSCDB``. The Oracle SID is also the name of your CDB.
        :param str dbi_resource_id: Property dbiResourceId
        :param bool dedicated_log_volume: Indicates whether the DB instance has a dedicated log volume (DLV) enabled.
        :param bool delete_automated_backups: A value that indicates whether to remove automated backups immediately after the DB instance is deleted. This parameter isn't case-sensitive. The default is to remove automated backups immediately after the DB instance is deleted.  *Amazon Aurora*  Not applicable. When you delete a DB cluster, all automated backups for that DB cluster are deleted and can't be recovered. Manual DB cluster snapshots of the DB cluster are not deleted.
        :param bool deletion_protection: A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled. For more information, see [Deleting a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html).   *Amazon Aurora*  Not applicable. You can enable or disable deletion protection for the DB cluster. For more information, see ``CreateDBCluster``. DB instances in a DB cluster can be deleted even when deletion protection is enabled for the DB cluster.
        :param str domain: The Active Directory directory ID to create the DB instance in. Currently, only Db2, MySQL, Microsoft SQL Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain. For more information, see [Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) in the *Amazon RDS User Guide*.
        :param str domain_auth_secret_arn: The ARN for the Secrets Manager secret with the credentials for the user joining the domain. Example: ``arn:aws:secretsmanager:region:account-number:secret:myselfmanagedADtestsecret-123456``
        :param Sequence[str] domain_dns_ips: The IPv4 DNS IP addresses of your primary and secondary Active Directory domain controllers. Constraints:  +  Two IP addresses must be provided. If there isn't a secondary domain controller, use the IP address of the primary domain controller for both entries in the list.   Example: ``123.124.125.126,234.235.236.237``
        :param str domain_fqdn: The fully qualified domain name (FQDN) of an Active Directory domain. Constraints:  +  Can't be longer than 64 characters.   Example: ``mymanagedADtest.mymanagedAD.mydomain``
        :param str domain_iam_role_name: The name of the IAM role to use when making API calls to the Directory Service. This setting doesn't apply to the following DB instances:  +  Amazon Aurora (The domain is managed by the DB cluster.)  +  RDS Custom
        :param str domain_ou: The Active Directory organizational unit for your DB instance to join. Constraints:  +  Must be in the distinguished name format.  +  Can't be longer than 64 characters.   Example: ``OU=mymanagedADtestOU,DC=mymanagedADtest,DC=mymanagedAD,DC=mydomain``
        :param Sequence[str] enable_cloudwatch_logs_exports: The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the *Amazon Relational Database Service User Guide*.  *Amazon Aurora*  Not applicable. CloudWatch Logs exports are managed by the DB cluster.   *Db2*  Valid values: ``diag.log``, ``notify.log``   *MariaDB*  Valid values: ``audit``, ``error``, ``general``, ``slowquery``   *Microsoft SQL Server*  Valid values: ``agent``, ``error``   *MySQL*  Valid values: ``audit``, ``error``, ``general``, ``slowquery``   *Oracle*  Valid values: ``alert``, ``audit``, ``listener``, ``trace``, ``oemagent``   *PostgreSQL*  Valid values: ``postgresql``, ``upgrade``
        :param bool enable_iam_database_authentication: A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled. This property is supported for RDS for MariaDB, RDS for MySQL, and RDS for PostgreSQL. For more information, see [IAM Database Authentication for MariaDB, MySQL, and PostgreSQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) in the *Amazon RDS User Guide.*   *Amazon Aurora*  Not applicable. Mapping AWS IAM accounts to database accounts is managed by the DB cluster.
        :param bool enable_performance_insights: Specifies whether to enable Performance Insights for the DB instance. For more information, see [Using Amazon Performance Insights](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the *Amazon RDS User Guide*. This setting doesn't apply to RDS Custom DB instances.
        :param 'RdsDbInstanceEndpointResponse' endpoint: The connection endpoint for the DB instance.  The endpoint might not be shown for instances with the status of ``creating``. This data type represents the information you need to connect to an Amazon RDS DB instance. This data type is used as a response element in the following actions:  +   ``CreateDBInstance``   +   ``DescribeDBInstances``   +   ``DeleteDBInstance``    For the data structure that represents Amazon Aurora DB cluster endpoints, see ``DBClusterEndpoint``.
        :param str engine: The name of the database engine to use for this DB instance. Not every database engine is available in every AWS Region. This property is required when creating a DB instance.  You can change the architecture of an Oracle database from the non-container database (CDB) architecture to the CDB architecture by updating the ``Engine`` value in your templates from ``oracle-ee`` or ``oracle-ee-cdb`` to ``oracle-se2-cdb``. Converting to the CDB architecture requires an interruption.  Valid Values:  +   ``aurora-mysql`` (for Aurora MySQL DB instances)  +   ``aurora-postgresql`` (for Aurora PostgreSQL DB instances)  +   ``custom-oracle-ee`` (for RDS Custom for Oracle DB instances)  +   ``custom-oracle-ee-cdb`` (for RDS Custom for Oracle DB instances)  +   ``custom-sqlserver-ee`` (for RDS Custom for SQL Server DB instances)  +   ``custom-sqlserver-se`` (for RDS Custom for SQL Server DB instances)  +   ``custom-sqlserver-web`` (for RDS Custom for SQL Server DB instances)  +   ``db2-ae``   +   ``db2-se``   +   ``mariadb``   +   ``mysql``   +   ``oracle-ee``   +   ``oracle-ee-cdb``   +   ``oracle-se2``   +   ``oracle-se2-cdb``   +   ``postgres``   +   ``sqlserver-ee``   +   ``sqlserver-se``   +   ``sqlserver-ex``   +   ``sqlserver-web``
        :param str engine_version: The version number of the database engine to use. For a list of valid engine versions, use the ``DescribeDBEngineVersions`` action. The following are the database engines and links to information about the major and minor versions that are available with Amazon RDS. Not every database engine is available for every AWS Region.  *Amazon Aurora*  Not applicable. The version number of the database engine to be used by the DB instance is managed by the DB cluster.  *Db2*  See [Amazon RDS for Db2](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Db2.html#Db2.Concepts.VersionMgmt) in the *Amazon RDS User Guide.*   *MariaDB*  See [MariaDB on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt) in the *Amazon RDS User Guide.*   *Microsoft SQL Server*  See [Microsoft SQL Server Versions on Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport) in the *Amazon RDS User Guide.*   *MySQL*  See [MySQL on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt) in the *Amazon RDS User Guide.*   *Oracle*  See [Oracle Database Engine Release Notes](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html) in the *Amazon RDS User Guide.*   *PostgreSQL*  See [Supported PostgreSQL Database Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts.General.DBVersions) in the *Amazon RDS User Guide.*
        :param int iops: The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000.  If you specify this property, you must follow the range of allowed ratios of your requested IOPS rate to the amount of storage that you allocate (IOPS to allocated storage). For example, you can provision an Oracle database instance with 1000 IOPS and 200 GiB of storage (a ratio of 5:1), or specify 2000 IOPS with 200 GiB of storage (a ratio of 10:1). For more information, see [Amazon RDS Provisioned IOPS Storage to Improve Performance](https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/CHAP_Storage.html#USER_PIOPS) in the *Amazon RDS User Guide*.  If you specify ``io1`` for the ``StorageType`` property, then you must also specify the ``Iops`` property.  Constraints:  +  For RDS for Db2, MariaDB, MySQL, Oracle, and PostgreSQL - Must be a multiple between .5 and 50 of the storage amount for the DB instance.  +  For RDS for SQL Server - Must be a multiple between 1 and 50 of the storage amount for the DB instance.
        :param str kms_key_id: The ARN of the AWS KMS key that's used to encrypt the DB instance, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef``. If you enable the StorageEncrypted property but don't specify this property, AWS CloudFormation uses the default KMS key. If you specify this property, you must set the StorageEncrypted property to true.  If you specify the ``SourceDBInstanceIdentifier`` property, the value is inherited from the source DB instance if the read replica is created in the same region. If you create an encrypted read replica in a different AWS Region, then you must specify a KMS key for the destination AWS Region. KMS encryption keys are specific to the region that they're created in, and you can't use encryption keys from one region in another region. If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used. If you specify ``DBSecurityGroups``, AWS CloudFormation ignores this property. To specify both a security group and this property, you must use a VPC security group. For more information about Amazon RDS and VPC, see [Using Amazon RDS with Amazon VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html) in the *Amazon RDS User Guide*.  *Amazon Aurora*  Not applicable. The KMS key identifier is managed by the DB cluster.
        :param str license_model: License model information for this DB instance.  Valid Values:  +  Aurora MySQL - ``general-public-license``   +  Aurora PostgreSQL - ``postgresql-license``   +  RDS for Db2 - ``bring-your-own-license``. For more information about RDS for Db2 licensing, see [](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/db2-licensing.html) in the *Amazon RDS User Guide.*   +  RDS for MariaDB - ``general-public-license``   +  RDS for Microsoft SQL Server - ``license-included``   +  RDS for MySQL - ``general-public-license``   +  RDS for Oracle - ``bring-your-own-license`` or ``license-included``   +  RDS for PostgreSQL - ``postgresql-license``     If you've specified ``DBSecurityGroups`` and then you update the license model, AWS CloudFormation replaces the underlying DB instance. This will incur some interruptions to database availability.
        :param bool manage_master_user_password: Specifies whether to manage the master user password with AWS Secrets Manager. For more information, see [Password management with Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the *Amazon RDS User Guide.*  Constraints:  +  Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified.
        :param str master_user_password: The password for the master user. The password can include any printable ASCII character except '/', ''', or '@'.  *Amazon Aurora*  Not applicable. The password for the master user is managed by the DB cluster.  *RDS for Db2*  Must contain from 8 to 255 characters.  *RDS for MariaDB*  Constraints: Must contain from 8 to 41 characters.  *RDS for Microsoft SQL Server*  Constraints: Must contain from 8 to 128 characters.  *RDS for MySQL*  Constraints: Must contain from 8 to 41 characters.  *RDS for Oracle*  Constraints: Must contain from 8 to 30 characters.  *RDS for PostgreSQL*  Constraints: Must contain from 8 to 128 characters.
        :param 'MasterUserSecretResponse' master_user_secret: The secret managed by RDS in AWS Secrets Manager for the master user password. For more information, see [Password management with Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the *Amazon RDS User Guide.* The ``MasterUserSecret`` return value specifies the secret managed by RDS in AWS Secrets Manager for the master user password. For more information, see [Password management with Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the *Amazon RDS User Guide* and [Password management with Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html) in the *Amazon Aurora User Guide.*
        :param str master_username: The master user name for the DB instance.  If you specify the ``SourceDBInstanceIdentifier`` or ``DBSnapshotIdentifier`` property, don't specify this property. The value is inherited from the source DB instance or snapshot. When migrating a self-managed Db2 database, we recommend that you use the same master username as your self-managed Db2 instance name.   *Amazon Aurora*  Not applicable. The name for the master user is managed by the DB cluster.   *RDS for Db2*  Constraints:  +  Must be 1 to 16 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.    *RDS for MariaDB*  Constraints:   +  Must be 1 to 16 letters or numbers.  +  Can't be a reserved word for the chosen database engine.    *RDS for Microsoft SQL Server*  Constraints:   +  Must be 1 to 128 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.    *RDS for MySQL*  Constraints:   +  Must be 1 to 16 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.    *RDS for Oracle*  Constraints:   +  Must be 1 to 30 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.    *RDS for PostgreSQL*  Constraints:   +  Must be 1 to 63 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.
        :param int max_allocated_storage: The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see [Managing capacity automatically with Amazon RDS storage autoscaling](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling) in the *Amazon RDS User Guide*. This setting doesn't apply to the following DB instances:  +  Amazon Aurora (Storage is managed by the DB cluster.)  +  RDS Custom
        :param int monitoring_interval: The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collection of Enhanced Monitoring metrics, specify 0. The default is 0. If ``MonitoringRoleArn`` is specified, then you must set ``MonitoringInterval`` to a value other than 0. This setting doesn't apply to RDS Custom. Valid Values: ``0, 1, 5, 10, 15, 30, 60``
        :param str monitoring_role_arn: The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, ``arn:aws:iam:123456789012:role/emaccess``. For information on creating a monitoring role, see [Setting Up and Enabling Enhanced Monitoring](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling) in the *Amazon RDS User Guide*. If ``MonitoringInterval`` is set to a value other than ``0``, then you must supply a ``MonitoringRoleArn`` value. This setting doesn't apply to RDS Custom DB instances.
        :param bool multi_az: Specifies whether the database instance is a Multi-AZ DB instance deployment. You can't set the ``AvailabilityZone`` parameter if the ``MultiAZ`` parameter is set to true.   For more information, see [Multi-AZ deployments for high availability](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.MultiAZ.html) in the *Amazon RDS User Guide*.  *Amazon Aurora*  Not applicable. Amazon Aurora storage is replicated across all of the Availability Zones and doesn't require the ``MultiAZ`` option to be set.
        :param str nchar_character_set_name: The name of the NCHAR character set for the Oracle DB instance. This setting doesn't apply to RDS Custom DB instances.
        :param str network_type: The network type of the DB instance. Valid values:  +   ``IPV4``   +   ``DUAL``    The network type is determined by the ``DBSubnetGroup`` specified for the DB instance. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols (``DUAL``). For more information, see [Working with a DB instance in a VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html) in the *Amazon RDS User Guide.*
        :param str option_group_name: Indicates that the DB instance should be associated with the specified option group. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance once it is associated with a DB instance.
        :param str performance_insights_kms_key_id: The AWS KMS key identifier for encryption of Performance Insights data. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for ``PerformanceInsightsKMSKeyId``, then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account. Your AWS account has a different default KMS key for each AWS Region. For information about enabling Performance Insights, see [EnablePerformanceInsights](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-enableperformanceinsights).
        :param int performance_insights_retention_period: The number of days to retain Performance Insights data. This setting doesn't apply to RDS Custom DB instances. Valid Values:  +   ``7``   +   *month* * 31, where *month* is a number of months from 1-23. Examples: ``93`` (3 months * 31), ``341`` (11 months * 31), ``589`` (19 months * 31)  +   ``731``    Default: ``7`` days If you specify a retention period that isn't valid, such as ``94``, Amazon RDS returns an error.
        :param str port: The port number on which the database accepts connections.  *Amazon Aurora*  Not applicable. The port number is managed by the DB cluster.  *Db2*  Default value: ``50000``
        :param str preferred_backup_window: The daily time range during which automated backups are created if automated backups are enabled, using the ``BackupRetentionPeriod`` parameter. For more information, see [Backup Window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow) in the *Amazon RDS User Guide.*  Constraints:  +  Must be in the format ``hh24:mi-hh24:mi``.  +  Must be in Universal Coordinated Time (UTC).  +  Must not conflict with the preferred maintenance window.  +  Must be at least 30 minutes.    *Amazon Aurora*  Not applicable. The daily time range for creating automated backups is managed by the DB cluster.
        :param str preferred_maintenance_window: The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi``  The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see [Adjusting the Preferred DB Instance Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow) in the *Amazon RDS User Guide.*   This property applies when AWS CloudFormation initially creates the DB instance. If you use AWS CloudFormation to update the DB instance, those updates are applied immediately.  Constraints: Minimum 30-minute window.
        :param Sequence['ProcessorFeatureResponse'] processor_features: The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
        :param int promotion_tier: The order of priority in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see [Fault Tolerance for an Aurora DB Cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.AuroraHighAvailability.html#Aurora.Managing.FaultTolerance) in the *Amazon Aurora User Guide*. This setting doesn't apply to RDS Custom DB instances. Default: ``1``  Valid Values: ``0 - 15``
        :param bool publicly_accessible: Indicates whether the DB instance is an internet-facing instance. If you specify true, AWS CloudFormation creates an instance with a publicly resolvable DNS name, which resolves to a public IP address. If you specify false, AWS CloudFormation creates an internal instance with a DNS name that resolves to a private IP address.  The default behavior value depends on your VPC setup and the database subnet group. For more information, see the ``PubliclyAccessible`` parameter in the [CreateDBInstance](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html) in the *Amazon RDS API Reference*.
        :param str replica_mode: The open mode of an Oracle read replica. For more information, see [Working with Oracle Read Replicas for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html) in the *Amazon RDS User Guide*. This setting is only supported in RDS for Oracle. Default: ``open-read-only``  Valid Values: ``open-read-only`` or ``mounted``
        :param str restore_time: The date and time to restore from. Constraints:  +  Must be a time in Universal Coordinated Time (UTC) format.  +  Must be before the latest restorable time for the DB instance.  +  Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled.   Example: ``2009-09-07T23:45:00Z``
        :param str source_db_cluster_identifier: The identifier of the Multi-AZ DB cluster that will act as the source for the read replica. Each DB cluster can have up to 15 read replicas. Constraints:  +  Must be the identifier of an existing Multi-AZ DB cluster.  +  Can't be specified if the ``SourceDBInstanceIdentifier`` parameter is also specified.  +  The specified DB cluster must have automatic backups enabled, that is, its backup retention period must be greater than 0.  +  The source DB cluster must be in the same AWS-Region as the read replica. Cross-Region replication isn't supported.
        :param str source_db_instance_automated_backups_arn: The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example, ``arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE``. This setting doesn't apply to RDS Custom.
        :param str source_db_instance_identifier: If you want to create a read replica DB instance, specify the ID of the source DB instance. Each DB instance can have a limited number of read replicas. For more information, see [Working with Read Replicas](https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/USER_ReadRepl.html) in the *Amazon RDS User Guide*. For information about constraints that apply to DB instance identifiers, see [Naming constraints in Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints) in the *Amazon RDS User Guide*. The ``SourceDBInstanceIdentifier`` property determines whether a DB instance is a read replica. If you remove the ``SourceDBInstanceIdentifier`` property from your template and then update your stack, AWS CloudFormation promotes the Read Replica to a standalone DB instance.   +  If you specify a source DB instance that uses VPC security groups, we recommend that you specify the ``VPCSecurityGroups`` property. If you don't specify the property, the read replica inherits the value of the ``VPCSecurityGroups`` property from the source DB when you create the replica. However, if you update the stack, AWS CloudFormation reverts the replica's ``VPCSecurityGroups`` property to the default value because it's not defined in the stack's template. This change might cause unexpected issues.  +  Read replicas don't support deletion policies. AWS CloudFormation ignores any deletion policy that's associated with a read replica.  +  If you specify ``SourceDBInstanceIdentifier``, don't specify the ``DBSnapshotIdentifier`` property. You can't create a read replica from a snapshot.  +  Don't set the ``BackupRetentionPeriod``, ``DBName``, ``MasterUsername``, ``MasterUserPassword``, and ``PreferredBackupWindow`` properties. The database attributes are inherited from the source DB instance, and backups are disabled for read replicas.  +  If the source DB instance is in a different region than the read replica, specify the source region in ``SourceRegion``, and specify an ARN for a valid DB instance in ``SourceDBInstanceIdentifier``. For more information, see [Constructing a Amazon RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html#USER_Tagging.ARN) in the *Amazon RDS User Guide*.  +  For DB instances in Amazon Aurora clusters, don't specify this property. Amazon RDS automatically assigns writer and reader DB instances.
        :param str source_dbi_resource_id: The resource ID of the source DB instance from which to restore.
        :param str source_region: The ID of the region that contains the source DB instance for the read replica.
        :param bool storage_encrypted: A value that indicates whether the DB instance is encrypted. By default, it isn't encrypted. If you specify the ``KmsKeyId`` property, then you must enable encryption. If you specify the ``SourceDBInstanceIdentifier`` property, don't specify this property. The value is inherited from the source DB instance, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used. If you specify the ``DBSnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used. If you specify the ``DBSnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB instance is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB instance to be encrypted, then don't set this property or set it to ``false``.  *Amazon Aurora*  Not applicable. The encryption for DB instances is managed by the DB cluster.
        :param int storage_throughput: Specifies the storage throughput value for the DB instance. This setting applies only to the ``gp3`` storage type.  This setting doesn't apply to RDS Custom or Amazon Aurora.
        :param str storage_type: The storage type to associate with the DB instance. If you specify ``io1``, ``io2``, or ``gp3``, you must also include a value for the ``Iops`` parameter. This setting doesn't apply to Amazon Aurora DB instances. Storage is managed by the DB cluster. Valid Values: ``gp2 | gp3 | io1 | io2 | standard``  Default: ``io1``, if the ``Iops`` parameter is specified. Otherwise, ``gp2``.
        :param Sequence['TagResponse'] tags: An optional array of key-value pairs to apply to this DB instance.
        :param str tde_credential_arn: Property tdeCredentialArn
        :param str tde_credential_password: Property tdeCredentialPassword
        :param str timezone: The time zone of the DB instance. The time zone parameter is currently supported only by [Microsoft SQL Server](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone).
        :param bool use_default_processor_features: Specifies whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom DB instances.
        :param bool use_latest_restorable_time: Specifies whether the DB instance is restored from the latest backup time. By default, the DB instance isn't restored from the latest backup time. Constraints:  +  Can't be specified if the ``RestoreTime`` parameter is provided.
        :param Sequence[str] vpc_security_groups: A list of the VPC security group IDs to assign to the DB instance. The list can include both the physical IDs of existing VPC security groups and references to [AWS::EC2::SecurityGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html) resources created in the template. If you plan to update the resource, don't specify VPC security groups in a shared VPC.  If you set ``VPCSecurityGroups``, you must not set [DBSecurityGroups](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups), and vice versa.  You can migrate a DB instance in your stack from an RDS DB security group to a VPC security group, but keep the following in mind:  +  You can't revert to using an RDS security group after you establish a VPC security group membership.  +  When you migrate your DB instance to VPC security groups, if your stack update rolls back because the DB instance update fails or because an update fails in another AWS CloudFormation resource, the rollback fails because it can't revert to an RDS security group.  +  To use the properties that are available when you use a VPC security group, you must recreate the DB instance. If you don't, AWS CloudFormation submits only the property values that are listed in the [DBSecurityGroups](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups) property.    To avoid this situation, migrate your DB instance to using VPC security groups only when that is the only change in your stack template.   *Amazon Aurora*  Not applicable. The associated list of EC2 VPC security groups is managed by the DB cluster. If specified, the setting must match the DB cluster setting.
        """
        if allocated_storage is not None:
            pulumi.set(__self__, "allocated_storage", allocated_storage)
        if allow_major_version_upgrade is not None:
            pulumi.set(__self__, "allow_major_version_upgrade", allow_major_version_upgrade)
        if associated_roles is not None:
            pulumi.set(__self__, "associated_roles", associated_roles)
        if auto_minor_version_upgrade is not None:
            pulumi.set(__self__, "auto_minor_version_upgrade", auto_minor_version_upgrade)
        if automatic_backup_replication_kms_key_id is not None:
            pulumi.set(__self__, "automatic_backup_replication_kms_key_id", automatic_backup_replication_kms_key_id)
        if automatic_backup_replication_region is not None:
            pulumi.set(__self__, "automatic_backup_replication_region", automatic_backup_replication_region)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_retention_period is None:
            backup_retention_period = 1
        if backup_retention_period is not None:
            pulumi.set(__self__, "backup_retention_period", backup_retention_period)
        if ca_certificate_identifier is not None:
            pulumi.set(__self__, "ca_certificate_identifier", ca_certificate_identifier)
        if certificate_details is not None:
            pulumi.set(__self__, "certificate_details", certificate_details)
        if certificate_rotation_restart is not None:
            pulumi.set(__self__, "certificate_rotation_restart", certificate_rotation_restart)
        if character_set_name is not None:
            pulumi.set(__self__, "character_set_name", character_set_name)
        if copy_tags_to_snapshot is not None:
            pulumi.set(__self__, "copy_tags_to_snapshot", copy_tags_to_snapshot)
        if custom_iam_instance_profile is not None:
            pulumi.set(__self__, "custom_iam_instance_profile", custom_iam_instance_profile)
        if db_cluster_identifier is not None:
            pulumi.set(__self__, "db_cluster_identifier", db_cluster_identifier)
        if db_cluster_snapshot_identifier is not None:
            pulumi.set(__self__, "db_cluster_snapshot_identifier", db_cluster_snapshot_identifier)
        if db_instance_arn is not None:
            pulumi.set(__self__, "db_instance_arn", db_instance_arn)
        if db_instance_class is not None:
            pulumi.set(__self__, "db_instance_class", db_instance_class)
        if db_instance_identifier is not None:
            pulumi.set(__self__, "db_instance_identifier", db_instance_identifier)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_parameter_group_name is not None:
            pulumi.set(__self__, "db_parameter_group_name", db_parameter_group_name)
        if db_security_groups is not None:
            pulumi.set(__self__, "db_security_groups", db_security_groups)
        if db_snapshot_identifier is not None:
            pulumi.set(__self__, "db_snapshot_identifier", db_snapshot_identifier)
        if db_subnet_group_name is not None:
            pulumi.set(__self__, "db_subnet_group_name", db_subnet_group_name)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if dbi_resource_id is not None:
            pulumi.set(__self__, "dbi_resource_id", dbi_resource_id)
        if dedicated_log_volume is not None:
            pulumi.set(__self__, "dedicated_log_volume", dedicated_log_volume)
        if delete_automated_backups is not None:
            pulumi.set(__self__, "delete_automated_backups", delete_automated_backups)
        if deletion_protection is not None:
            pulumi.set(__self__, "deletion_protection", deletion_protection)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if domain_auth_secret_arn is not None:
            pulumi.set(__self__, "domain_auth_secret_arn", domain_auth_secret_arn)
        if domain_dns_ips is not None:
            pulumi.set(__self__, "domain_dns_ips", domain_dns_ips)
        if domain_fqdn is not None:
            pulumi.set(__self__, "domain_fqdn", domain_fqdn)
        if domain_iam_role_name is not None:
            pulumi.set(__self__, "domain_iam_role_name", domain_iam_role_name)
        if domain_ou is not None:
            pulumi.set(__self__, "domain_ou", domain_ou)
        if enable_cloudwatch_logs_exports is not None:
            pulumi.set(__self__, "enable_cloudwatch_logs_exports", enable_cloudwatch_logs_exports)
        if enable_iam_database_authentication is not None:
            pulumi.set(__self__, "enable_iam_database_authentication", enable_iam_database_authentication)
        if enable_performance_insights is not None:
            pulumi.set(__self__, "enable_performance_insights", enable_performance_insights)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if engine_version is not None:
            pulumi.set(__self__, "engine_version", engine_version)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)
        if manage_master_user_password is not None:
            pulumi.set(__self__, "manage_master_user_password", manage_master_user_password)
        if master_user_password is not None:
            pulumi.set(__self__, "master_user_password", master_user_password)
        if master_user_secret is not None:
            pulumi.set(__self__, "master_user_secret", master_user_secret)
        if master_username is not None:
            pulumi.set(__self__, "master_username", master_username)
        if max_allocated_storage is not None:
            pulumi.set(__self__, "max_allocated_storage", max_allocated_storage)
        if monitoring_interval is not None:
            pulumi.set(__self__, "monitoring_interval", monitoring_interval)
        if monitoring_role_arn is not None:
            pulumi.set(__self__, "monitoring_role_arn", monitoring_role_arn)
        if multi_az is not None:
            pulumi.set(__self__, "multi_az", multi_az)
        if nchar_character_set_name is not None:
            pulumi.set(__self__, "nchar_character_set_name", nchar_character_set_name)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if option_group_name is not None:
            pulumi.set(__self__, "option_group_name", option_group_name)
        if performance_insights_kms_key_id is not None:
            pulumi.set(__self__, "performance_insights_kms_key_id", performance_insights_kms_key_id)
        if performance_insights_retention_period is not None:
            pulumi.set(__self__, "performance_insights_retention_period", performance_insights_retention_period)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if preferred_backup_window is not None:
            pulumi.set(__self__, "preferred_backup_window", preferred_backup_window)
        if preferred_maintenance_window is not None:
            pulumi.set(__self__, "preferred_maintenance_window", preferred_maintenance_window)
        if processor_features is not None:
            pulumi.set(__self__, "processor_features", processor_features)
        if promotion_tier is None:
            promotion_tier = 1
        if promotion_tier is not None:
            pulumi.set(__self__, "promotion_tier", promotion_tier)
        if publicly_accessible is not None:
            pulumi.set(__self__, "publicly_accessible", publicly_accessible)
        if replica_mode is not None:
            pulumi.set(__self__, "replica_mode", replica_mode)
        if restore_time is not None:
            pulumi.set(__self__, "restore_time", restore_time)
        if source_db_cluster_identifier is not None:
            pulumi.set(__self__, "source_db_cluster_identifier", source_db_cluster_identifier)
        if source_db_instance_automated_backups_arn is not None:
            pulumi.set(__self__, "source_db_instance_automated_backups_arn", source_db_instance_automated_backups_arn)
        if source_db_instance_identifier is not None:
            pulumi.set(__self__, "source_db_instance_identifier", source_db_instance_identifier)
        if source_dbi_resource_id is not None:
            pulumi.set(__self__, "source_dbi_resource_id", source_dbi_resource_id)
        if source_region is not None:
            pulumi.set(__self__, "source_region", source_region)
        if storage_encrypted is not None:
            pulumi.set(__self__, "storage_encrypted", storage_encrypted)
        if storage_throughput is not None:
            pulumi.set(__self__, "storage_throughput", storage_throughput)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tde_credential_arn is not None:
            pulumi.set(__self__, "tde_credential_arn", tde_credential_arn)
        if tde_credential_password is not None:
            pulumi.set(__self__, "tde_credential_password", tde_credential_password)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if use_default_processor_features is not None:
            pulumi.set(__self__, "use_default_processor_features", use_default_processor_features)
        if use_latest_restorable_time is not None:
            pulumi.set(__self__, "use_latest_restorable_time", use_latest_restorable_time)
        if vpc_security_groups is not None:
            pulumi.set(__self__, "vpc_security_groups", vpc_security_groups)

    @property
    @pulumi.getter(name="allocatedStorage")
    def allocated_storage(self) -> Optional[str]:
        """
        The amount of storage in gibibytes (GiB) to be initially allocated for the database instance.  If any value is set in the ``Iops`` parameter, ``AllocatedStorage`` must be at least 100 GiB, which corresponds to the minimum Iops value of 1,000. If you increase the ``Iops`` value (in 1,000 IOPS increments), then you must also increase the ``AllocatedStorage`` value (in 100-GiB increments).    *Amazon Aurora*  Not applicable. Aurora cluster volumes automatically grow as the amount of data in your database increases, though you are only charged for the space that you use in an Aurora cluster volume.  *Db2*  Constraints to the amount of storage for each storage type are the following:  +  General Purpose (SSD) storage (gp3): Must be an integer from 20 to 64000.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 64000.    *MySQL*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.  +  Magnetic storage (standard): Must be an integer from 5 to 3072.    *MariaDB*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.  +  Magnetic storage (standard): Must be an integer from 5 to 3072.    *PostgreSQL*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.  +  Magnetic storage (standard): Must be an integer from 5 to 3072.    *Oracle*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.  +  Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.  +  Magnetic storage (standard): Must be an integer from 10 to 3072.    *SQL Server*  Constraints to the amount of storage for each storage type are the following:   +  General Purpose (SSD) storage (gp2):  +  Enterprise and Standard editions: Must be an integer from 20 to 16384.  +  Web and Express editions: Must be an integer from 20 to 16384.    +  Provisioned IOPS storage (io1):  +  Enterprise and Standard editions: Must be an integer from 20 to 16384.  +  Web and Express editions: Must be an integer from 20 to 16384.    +  Magnetic storage (standard):  +  Enterprise and Standard editions: Must be an integer from 20 to 1024.  +  Web and Express editions: Must be an integer from 20 to 1024.
        """
        return pulumi.get(self, "allocated_storage")

    @property
    @pulumi.getter(name="allowMajorVersionUpgrade")
    def allow_major_version_upgrade(self) -> Optional[bool]:
        """
        A value that indicates whether major version upgrades are allowed. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible. Constraints: Major version upgrades must be allowed when specifying a value for the ``EngineVersion`` parameter that is a different major version than the DB instance's current version.
        """
        return pulumi.get(self, "allow_major_version_upgrade")

    @property
    @pulumi.getter(name="associatedRoles")
    def associated_roles(self) -> Optional[Sequence['outputs.DBInstanceRoleResponse']]:
        """
        The IAMlong (IAM) roles associated with the DB instance.   *Amazon Aurora*  Not applicable. The associated roles are managed by the DB cluster.
        """
        return pulumi.get(self, "associated_roles")

    @property
    @pulumi.getter(name="autoMinorVersionUpgrade")
    def auto_minor_version_upgrade(self) -> Optional[bool]:
        """
        A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window. By default, minor engine upgrades are applied automatically.
        """
        return pulumi.get(self, "auto_minor_version_upgrade")

    @property
    @pulumi.getter(name="automaticBackupReplicationKmsKeyId")
    def automatic_backup_replication_kms_key_id(self) -> Optional[str]:
        """
        Property automaticBackupReplicationKmsKeyId
        """
        return pulumi.get(self, "automatic_backup_replication_kms_key_id")

    @property
    @pulumi.getter(name="automaticBackupReplicationRegion")
    def automatic_backup_replication_region(self) -> Optional[str]:
        """
        The destination region for the backup replication of the DB instance. For more info, see [Replicating automated backups to another Region](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ReplicateBackups.html) in the *Amazon RDS User Guide*.
        """
        return pulumi.get(self, "automatic_backup_replication_region")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone (AZ) where the database will be created. For information on AWS-Regions and Availability Zones, see [Regions and Availability Zones](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html). For Amazon Aurora, each Aurora DB cluster hosts copies of its storage in three separate Availability Zones. Specify one of these Availability Zones. Aurora automatically chooses an appropriate Availability Zone if you don't specify one. Default: A random, system-chosen Availability Zone in the endpoint's AWS-Region. Constraints:  +  The ``AvailabilityZone`` parameter can't be specified if the DB instance is a Multi-AZ deployment.  +  The specified Availability Zone must be in the same AWS-Region as the current endpoint.   Example: ``us-east-1d``
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="backupRetentionPeriod")
    def backup_retention_period(self) -> Optional[int]:
        """
        The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.  *Amazon Aurora*  Not applicable. The retention period for automated backups is managed by the DB cluster. Default: 1 Constraints:  +  Must be a value from 0 to 35  +  Can't be set to 0 if the DB instance is a source to read replicas
        """
        return pulumi.get(self, "backup_retention_period")

    @property
    @pulumi.getter(name="caCertificateIdentifier")
    def ca_certificate_identifier(self) -> Optional[str]:
        """
        The identifier of the CA certificate for this DB instance. For more information, see [Using SSL/TLS to encrypt a connection to a DB instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html) in the *Amazon RDS User Guide* and [Using SSL/TLS to encrypt a connection to a DB cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL.html) in the *Amazon Aurora User Guide*.
        """
        return pulumi.get(self, "ca_certificate_identifier")

    @property
    @pulumi.getter(name="certificateDetails")
    def certificate_details(self) -> Optional['outputs.CertificateDetailsResponse']:
        """
        The details of the DB instance's server certificate. Returns the details of the DB instances server certificate. For more information, see [Using SSL/TLS to encrypt a connection to a DB instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html) in the *Amazon RDS User Guide* and [Using SSL/TLS to encrypt a connection to a DB cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL.html) in the *Amazon Aurora User Guide*.
        """
        return pulumi.get(self, "certificate_details")

    @property
    @pulumi.getter(name="certificateRotationRestart")
    def certificate_rotation_restart(self) -> Optional[bool]:
        """
        Specifies whether the DB instance is restarted when you rotate your SSL/TLS certificate. By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate is not updated until the DB instance is restarted.  Set this parameter only if you are *not* using SSL/TLS to connect to the DB instance.  If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your DB engine to rotate your SSL/TLS certificate:  +  For more information about rotating your SSL/TLS certificate for RDS DB engines, see [Rotating Your SSL/TLS Certificate.](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html) in the *Amazon RDS User Guide.*   +  For more information about rotating your SSL/TLS certificate for Aurora DB engines, see [Rotating Your SSL/TLS Certificate](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html) in the *Amazon Aurora User Guide*.   This setting doesn't apply to RDS Custom DB instances.
        """
        return pulumi.get(self, "certificate_rotation_restart")

    @property
    @pulumi.getter(name="characterSetName")
    def character_set_name(self) -> Optional[str]:
        """
        For supported engines, indicates that the DB instance should be associated with the specified character set.  *Amazon Aurora*  Not applicable. The character set is managed by the DB cluster. For more information, see [AWS::RDS::DBCluster](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rds-dbcluster.html).
        """
        return pulumi.get(self, "character_set_name")

    @property
    @pulumi.getter(name="copyTagsToSnapshot")
    def copy_tags_to_snapshot(self) -> Optional[bool]:
        """
        Specifies whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied. This setting doesn't apply to Amazon Aurora DB instances. Copying tags to snapshots is managed by the DB cluster. Setting this value for an Aurora DB instance has no effect on the DB cluster setting.
        """
        return pulumi.get(self, "copy_tags_to_snapshot")

    @property
    @pulumi.getter(name="customIAMInstanceProfile")
    def custom_iam_instance_profile(self) -> Optional[str]:
        """
        The instance profile associated with the underlying Amazon EC2 instance of an RDS Custom DB instance. This setting is required for RDS Custom. Constraints:  +  The profile must exist in your account.  +  The profile must have an IAM role that Amazon EC2 has permissions to assume.  +  The instance profile name and the associated IAM role name must start with the prefix ``AWSRDSCustom``.   For the list of permissions required for the IAM role, see [Configure IAM and your VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/custom-setup-orcl.html#custom-setup-orcl.iam-vpc) in the *Amazon RDS User Guide*.
        """
        return pulumi.get(self, "custom_iam_instance_profile")

    @property
    @pulumi.getter(name="dbClusterIdentifier")
    def db_cluster_identifier(self) -> Optional[str]:
        """
        The identifier of the DB cluster that the instance will belong to.
        """
        return pulumi.get(self, "db_cluster_identifier")

    @property
    @pulumi.getter(name="dbClusterSnapshotIdentifier")
    def db_cluster_snapshot_identifier(self) -> Optional[str]:
        """
        The identifier for the Multi-AZ DB cluster snapshot to restore from. For more information on Multi-AZ DB clusters, see [Multi-AZ DB cluster deployments](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/multi-az-db-clusters-concepts.html) in the *Amazon RDS User Guide*. Constraints:  +  Must match the identifier of an existing Multi-AZ DB cluster snapshot.  +  Can't be specified when ``DBSnapshotIdentifier`` is specified.  +  Must be specified when ``DBSnapshotIdentifier`` isn't specified.  +  If you are restoring from a shared manual Multi-AZ DB cluster snapshot, the ``DBClusterSnapshotIdentifier`` must be the ARN of the shared snapshot.  +  Can't be the identifier of an Aurora DB cluster snapshot.
        """
        return pulumi.get(self, "db_cluster_snapshot_identifier")

    @property
    @pulumi.getter(name="dbInstanceArn")
    def db_instance_arn(self) -> Optional[str]:
        """
        Property dbInstanceArn
        """
        return pulumi.get(self, "db_instance_arn")

    @property
    @pulumi.getter(name="dbInstanceClass")
    def db_instance_class(self) -> Optional[str]:
        """
        The compute and memory capacity of the DB instance, for example ``db.m5.large``. Not all DB instance classes are available in all AWS-Regions, or for all database engines. For the full list of DB instance classes, and availability for your engine, see [DB instance classes](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html) in the *Amazon RDS User Guide* or [Aurora DB instance classes](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.DBInstanceClass.html) in the *Amazon Aurora User Guide*.
        """
        return pulumi.get(self, "db_instance_class")

    @property
    @pulumi.getter(name="dbInstanceIdentifier")
    def db_instance_identifier(self) -> Optional[str]:
        """
        A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the DB instance. For more information, see [Name Type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html). For information about constraints that apply to DB instance identifiers, see [Naming constraints in Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints) in the *Amazon RDS User Guide*.  If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        """
        return pulumi.get(self, "db_instance_identifier")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[str]:
        """
        The meaning of this parameter differs according to the database engine you use.  If you specify the ``DBSnapshotIdentifier`` property, this property only applies to RDS for Oracle.   *Amazon Aurora*  Not applicable. The database name is managed by the DB cluster.  *Db2*  The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance. Constraints:  +  Must contain 1 to 64 letters or numbers.  +  Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).  +  Can't be a word reserved by the specified database engine.    *MySQL*  The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints:  +  Must contain 1 to 64 letters or numbers.  +  Can't be a word reserved by the specified database engine    *MariaDB*  The name of the database to create when the DB instance is created. If this parameter is not specified, no database is created in the DB instance. Constraints:  +  Must contain 1 to 64 letters or numbers.  +  Can't be a word reserved by the specified database engine    *PostgreSQL*  The name of the database to create when the DB instance is created. If this parameter is not specified, the default ``postgres`` database is created in the DB instance. Constraints:  +  Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).  +  Must contain 1 to 63 characters.  +  Can't be a word reserved by the specified database engine    *Oracle*  The Oracle System ID (SID) of the created DB instance. If you specify ``null``, the default value ``ORCL`` is used. You can't specify the string NULL, or any other reserved word, for ``DBName``.  Default: ``ORCL``  Constraints:  +  Can't be longer than 8 characters    *SQL Server*  Not applicable. Must be null.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbParameterGroupName")
    def db_parameter_group_name(self) -> Optional[str]:
        """
        The name of an existing DB parameter group or a reference to an [AWS::RDS::DBParameterGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-dbparametergroup.html) resource created in the template. To list all of the available DB parameter group names, use the following command:  ``aws rds describe-db-parameter-groups --query 'DBParameterGroups[].DBParameterGroupName' --output text``   If any of the data members of the referenced parameter group are changed during an update, the DB instance might need to be restarted, which causes some interruption. If the parameter group contains static parameters, whether they were changed or not, an update triggers a reboot.  If you don't specify a value for ``DBParameterGroupName`` property, the default DB parameter group for the specified engine and engine version is used.
        """
        return pulumi.get(self, "db_parameter_group_name")

    @property
    @pulumi.getter(name="dbSecurityGroups")
    def db_security_groups(self) -> Optional[Sequence[str]]:
        """
        A list of the DB security groups to assign to the DB instance. The list can include both the name of existing DB security groups or references to AWS::RDS::DBSecurityGroup resources created in the template.  If you set DBSecurityGroups, you must not set VPCSecurityGroups, and vice versa. Also, note that the DBSecurityGroups property exists only for backwards compatibility with older regions and is no longer recommended for providing security information to an RDS DB instance. Instead, use VPCSecurityGroups.  If you specify this property, AWS CloudFormation sends only the following properties (if specified) to Amazon RDS during create operations:  +   ``AllocatedStorage``   +   ``AutoMinorVersionUpgrade``   +   ``AvailabilityZone``   +   ``BackupRetentionPeriod``   +   ``CharacterSetName``   +   ``DBInstanceClass``   +   ``DBName``   +   ``DBParameterGroupName``   +   ``DBSecurityGroups``   +   ``DBSubnetGroupName``   +   ``Engine``   +   ``EngineVersion``   +   ``Iops``   +   ``LicenseModel``   +   ``MasterUsername``   +   ``MasterUserPassword``   +   ``MultiAZ``   +   ``OptionGroupName``   +   ``PreferredBackupWindow``   +   ``PreferredMaintenanceWindow``    All other properties are ignored. Specify a virtual private cloud (VPC) security group if you want to submit other properties, such as ``StorageType``, ``StorageEncrypted``, or ``KmsKeyId``. If you're already using the ``DBSecurityGroups`` property, you can't use these other properties by updating your DB instance to use a VPC security group. You must recreate the DB instance.
        """
        return pulumi.get(self, "db_security_groups")

    @property
    @pulumi.getter(name="dbSnapshotIdentifier")
    def db_snapshot_identifier(self) -> Optional[str]:
        """
        The name or Amazon Resource Name (ARN) of the DB snapshot that's used to restore the DB instance. If you're restoring from a shared manual DB snapshot, you must specify the ARN of the snapshot. By specifying this property, you can create a DB instance from the specified DB snapshot. If the ``DBSnapshotIdentifier`` property is an empty string or the ``AWS::RDS::DBInstance`` declaration has no ``DBSnapshotIdentifier`` property, AWS CloudFormation creates a new database. If the property contains a value (other than an empty string), AWS CloudFormation creates a database from the specified snapshot. If a snapshot with the specified name doesn't exist, AWS CloudFormation can't create the database and it rolls back the stack. Some DB instance properties aren't valid when you restore from a snapshot, such as the ``MasterUsername`` and ``MasterUserPassword`` properties. For information about the properties that you can specify, see the ``RestoreDBInstanceFromDBSnapshot`` action in the *Amazon RDS API Reference*. After you restore a DB instance with a ``DBSnapshotIdentifier`` property, you must specify the same ``DBSnapshotIdentifier`` property for any future updates to the DB instance. When you specify this property for an update, the DB instance is not restored from the DB snapshot again, and the data in the database is not changed. However, if you don't specify the ``DBSnapshotIdentifier`` property, an empty DB instance is created, and the original DB instance is deleted. If you specify a property that is different from the previous snapshot restore property, a new DB instance is restored from the specified ``DBSnapshotIdentifier`` property, and the original DB instance is deleted. If you specify the ``DBSnapshotIdentifier`` property to restore a DB instance (as opposed to specifying it for DB instance updates), then don't specify the following properties:  +   ``CharacterSetName``   +   ``DBClusterIdentifier``   +   ``DBName``   +   ``DeleteAutomatedBackups``   +   ``EnablePerformanceInsights``   +   ``KmsKeyId``   +   ``MasterUsername``   +   ``MasterUserPassword``   +   ``PerformanceInsightsKMSKeyId``   +   ``PerformanceInsightsRetentionPeriod``   +   ``PromotionTier``   +   ``SourceDBInstanceIdentifier``   +   ``SourceRegion``   +   ``StorageEncrypted`` (for an encrypted snapshot)  +   ``Timezone``     *Amazon Aurora*  Not applicable. Snapshot restore is managed by the DB cluster.
        """
        return pulumi.get(self, "db_snapshot_identifier")

    @property
    @pulumi.getter(name="dbSubnetGroupName")
    def db_subnet_group_name(self) -> Optional[str]:
        """
        A DB subnet group to associate with the DB instance. If you update this value, the new subnet group must be a subnet group in a new VPC.  If there's no DB subnet group, then the DB instance isn't a VPC DB instance. For more information about using Amazon RDS in a VPC, see [Using Amazon RDS with Amazon Virtual Private Cloud (VPC)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html) in the *Amazon RDS User Guide*.   *Amazon Aurora*  Not applicable. The DB subnet group is managed by the DB cluster. If specified, the setting must match the DB cluster setting.
        """
        return pulumi.get(self, "db_subnet_group_name")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[str]:
        """
        The Oracle system identifier (SID), which is the name of the Oracle database instance that manages your database files. In this context, the term 'Oracle database instance' refers exclusively to the system global area (SGA) and Oracle background processes. If you don't specify a SID, the value defaults to ``RDSCDB``. The Oracle SID is also the name of your CDB.
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="dbiResourceId")
    def dbi_resource_id(self) -> Optional[str]:
        """
        Property dbiResourceId
        """
        return pulumi.get(self, "dbi_resource_id")

    @property
    @pulumi.getter(name="dedicatedLogVolume")
    def dedicated_log_volume(self) -> Optional[bool]:
        """
        Indicates whether the DB instance has a dedicated log volume (DLV) enabled.
        """
        return pulumi.get(self, "dedicated_log_volume")

    @property
    @pulumi.getter(name="deleteAutomatedBackups")
    def delete_automated_backups(self) -> Optional[bool]:
        """
        A value that indicates whether to remove automated backups immediately after the DB instance is deleted. This parameter isn't case-sensitive. The default is to remove automated backups immediately after the DB instance is deleted.  *Amazon Aurora*  Not applicable. When you delete a DB cluster, all automated backups for that DB cluster are deleted and can't be recovered. Manual DB cluster snapshots of the DB cluster are not deleted.
        """
        return pulumi.get(self, "delete_automated_backups")

    @property
    @pulumi.getter(name="deletionProtection")
    def deletion_protection(self) -> Optional[bool]:
        """
        A value that indicates whether the DB instance has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled. For more information, see [Deleting a DB Instance](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html).   *Amazon Aurora*  Not applicable. You can enable or disable deletion protection for the DB cluster. For more information, see ``CreateDBCluster``. DB instances in a DB cluster can be deleted even when deletion protection is enabled for the DB cluster.
        """
        return pulumi.get(self, "deletion_protection")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The Active Directory directory ID to create the DB instance in. Currently, only Db2, MySQL, Microsoft SQL Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain. For more information, see [Kerberos Authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html) in the *Amazon RDS User Guide*.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="domainAuthSecretArn")
    def domain_auth_secret_arn(self) -> Optional[str]:
        """
        The ARN for the Secrets Manager secret with the credentials for the user joining the domain. Example: ``arn:aws:secretsmanager:region:account-number:secret:myselfmanagedADtestsecret-123456``
        """
        return pulumi.get(self, "domain_auth_secret_arn")

    @property
    @pulumi.getter(name="domainDnsIps")
    def domain_dns_ips(self) -> Optional[Sequence[str]]:
        """
        The IPv4 DNS IP addresses of your primary and secondary Active Directory domain controllers. Constraints:  +  Two IP addresses must be provided. If there isn't a secondary domain controller, use the IP address of the primary domain controller for both entries in the list.   Example: ``123.124.125.126,234.235.236.237``
        """
        return pulumi.get(self, "domain_dns_ips")

    @property
    @pulumi.getter(name="domainFqdn")
    def domain_fqdn(self) -> Optional[str]:
        """
        The fully qualified domain name (FQDN) of an Active Directory domain. Constraints:  +  Can't be longer than 64 characters.   Example: ``mymanagedADtest.mymanagedAD.mydomain``
        """
        return pulumi.get(self, "domain_fqdn")

    @property
    @pulumi.getter(name="domainIAMRoleName")
    def domain_iam_role_name(self) -> Optional[str]:
        """
        The name of the IAM role to use when making API calls to the Directory Service. This setting doesn't apply to the following DB instances:  +  Amazon Aurora (The domain is managed by the DB cluster.)  +  RDS Custom
        """
        return pulumi.get(self, "domain_iam_role_name")

    @property
    @pulumi.getter(name="domainOu")
    def domain_ou(self) -> Optional[str]:
        """
        The Active Directory organizational unit for your DB instance to join. Constraints:  +  Must be in the distinguished name format.  +  Can't be longer than 64 characters.   Example: ``OU=mymanagedADtestOU,DC=mymanagedADtest,DC=mymanagedAD,DC=mydomain``
        """
        return pulumi.get(self, "domain_ou")

    @property
    @pulumi.getter(name="enableCloudwatchLogsExports")
    def enable_cloudwatch_logs_exports(self) -> Optional[Sequence[str]]:
        """
        The list of log types that need to be enabled for exporting to CloudWatch Logs. The values in the list depend on the DB engine being used. For more information, see [Publishing Database Logs to Amazon CloudWatch Logs](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch) in the *Amazon Relational Database Service User Guide*.  *Amazon Aurora*  Not applicable. CloudWatch Logs exports are managed by the DB cluster.   *Db2*  Valid values: ``diag.log``, ``notify.log``   *MariaDB*  Valid values: ``audit``, ``error``, ``general``, ``slowquery``   *Microsoft SQL Server*  Valid values: ``agent``, ``error``   *MySQL*  Valid values: ``audit``, ``error``, ``general``, ``slowquery``   *Oracle*  Valid values: ``alert``, ``audit``, ``listener``, ``trace``, ``oemagent``   *PostgreSQL*  Valid values: ``postgresql``, ``upgrade``
        """
        return pulumi.get(self, "enable_cloudwatch_logs_exports")

    @property
    @pulumi.getter(name="enableIAMDatabaseAuthentication")
    def enable_iam_database_authentication(self) -> Optional[bool]:
        """
        A value that indicates whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. By default, mapping is disabled. This property is supported for RDS for MariaDB, RDS for MySQL, and RDS for PostgreSQL. For more information, see [IAM Database Authentication for MariaDB, MySQL, and PostgreSQL](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) in the *Amazon RDS User Guide.*   *Amazon Aurora*  Not applicable. Mapping AWS IAM accounts to database accounts is managed by the DB cluster.
        """
        return pulumi.get(self, "enable_iam_database_authentication")

    @property
    @pulumi.getter(name="enablePerformanceInsights")
    def enable_performance_insights(self) -> Optional[bool]:
        """
        Specifies whether to enable Performance Insights for the DB instance. For more information, see [Using Amazon Performance Insights](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html) in the *Amazon RDS User Guide*. This setting doesn't apply to RDS Custom DB instances.
        """
        return pulumi.get(self, "enable_performance_insights")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional['outputs.RdsDbInstanceEndpointResponse']:
        """
        The connection endpoint for the DB instance.  The endpoint might not be shown for instances with the status of ``creating``. This data type represents the information you need to connect to an Amazon RDS DB instance. This data type is used as a response element in the following actions:  +   ``CreateDBInstance``   +   ``DescribeDBInstances``   +   ``DeleteDBInstance``    For the data structure that represents Amazon Aurora DB cluster endpoints, see ``DBClusterEndpoint``.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def engine(self) -> Optional[str]:
        """
        The name of the database engine to use for this DB instance. Not every database engine is available in every AWS Region. This property is required when creating a DB instance.  You can change the architecture of an Oracle database from the non-container database (CDB) architecture to the CDB architecture by updating the ``Engine`` value in your templates from ``oracle-ee`` or ``oracle-ee-cdb`` to ``oracle-se2-cdb``. Converting to the CDB architecture requires an interruption.  Valid Values:  +   ``aurora-mysql`` (for Aurora MySQL DB instances)  +   ``aurora-postgresql`` (for Aurora PostgreSQL DB instances)  +   ``custom-oracle-ee`` (for RDS Custom for Oracle DB instances)  +   ``custom-oracle-ee-cdb`` (for RDS Custom for Oracle DB instances)  +   ``custom-sqlserver-ee`` (for RDS Custom for SQL Server DB instances)  +   ``custom-sqlserver-se`` (for RDS Custom for SQL Server DB instances)  +   ``custom-sqlserver-web`` (for RDS Custom for SQL Server DB instances)  +   ``db2-ae``   +   ``db2-se``   +   ``mariadb``   +   ``mysql``   +   ``oracle-ee``   +   ``oracle-ee-cdb``   +   ``oracle-se2``   +   ``oracle-se2-cdb``   +   ``postgres``   +   ``sqlserver-ee``   +   ``sqlserver-se``   +   ``sqlserver-ex``   +   ``sqlserver-web``
        """
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> Optional[str]:
        """
        The version number of the database engine to use. For a list of valid engine versions, use the ``DescribeDBEngineVersions`` action. The following are the database engines and links to information about the major and minor versions that are available with Amazon RDS. Not every database engine is available for every AWS Region.  *Amazon Aurora*  Not applicable. The version number of the database engine to be used by the DB instance is managed by the DB cluster.  *Db2*  See [Amazon RDS for Db2](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Db2.html#Db2.Concepts.VersionMgmt) in the *Amazon RDS User Guide.*   *MariaDB*  See [MariaDB on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt) in the *Amazon RDS User Guide.*   *Microsoft SQL Server*  See [Microsoft SQL Server Versions on Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport) in the *Amazon RDS User Guide.*   *MySQL*  See [MySQL on Amazon RDS Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt) in the *Amazon RDS User Guide.*   *Oracle*  See [Oracle Database Engine Release Notes](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html) in the *Amazon RDS User Guide.*   *PostgreSQL*  See [Supported PostgreSQL Database Versions](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts.General.DBVersions) in the *Amazon RDS User Guide.*
        """
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000.  If you specify this property, you must follow the range of allowed ratios of your requested IOPS rate to the amount of storage that you allocate (IOPS to allocated storage). For example, you can provision an Oracle database instance with 1000 IOPS and 200 GiB of storage (a ratio of 5:1), or specify 2000 IOPS with 200 GiB of storage (a ratio of 10:1). For more information, see [Amazon RDS Provisioned IOPS Storage to Improve Performance](https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/CHAP_Storage.html#USER_PIOPS) in the *Amazon RDS User Guide*.  If you specify ``io1`` for the ``StorageType`` property, then you must also specify the ``Iops`` property.  Constraints:  +  For RDS for Db2, MariaDB, MySQL, Oracle, and PostgreSQL - Must be a multiple between .5 and 50 of the storage amount for the DB instance.  +  For RDS for SQL Server - Must be a multiple between 1 and 50 of the storage amount for the DB instance.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ARN of the AWS KMS key that's used to encrypt the DB instance, such as ``arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef``. If you enable the StorageEncrypted property but don't specify this property, AWS CloudFormation uses the default KMS key. If you specify this property, you must set the StorageEncrypted property to true.  If you specify the ``SourceDBInstanceIdentifier`` property, the value is inherited from the source DB instance if the read replica is created in the same region. If you create an encrypted read replica in a different AWS Region, then you must specify a KMS key for the destination AWS Region. KMS encryption keys are specific to the region that they're created in, and you can't use encryption keys from one region in another region. If you specify the ``SnapshotIdentifier`` property, the ``StorageEncrypted`` property value is inherited from the snapshot, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used. If you specify ``DBSecurityGroups``, AWS CloudFormation ignores this property. To specify both a security group and this property, you must use a VPC security group. For more information about Amazon RDS and VPC, see [Using Amazon RDS with Amazon VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.html) in the *Amazon RDS User Guide*.  *Amazon Aurora*  Not applicable. The KMS key identifier is managed by the DB cluster.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[str]:
        """
        License model information for this DB instance.  Valid Values:  +  Aurora MySQL - ``general-public-license``   +  Aurora PostgreSQL - ``postgresql-license``   +  RDS for Db2 - ``bring-your-own-license``. For more information about RDS for Db2 licensing, see [](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/db2-licensing.html) in the *Amazon RDS User Guide.*   +  RDS for MariaDB - ``general-public-license``   +  RDS for Microsoft SQL Server - ``license-included``   +  RDS for MySQL - ``general-public-license``   +  RDS for Oracle - ``bring-your-own-license`` or ``license-included``   +  RDS for PostgreSQL - ``postgresql-license``     If you've specified ``DBSecurityGroups`` and then you update the license model, AWS CloudFormation replaces the underlying DB instance. This will incur some interruptions to database availability.
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="manageMasterUserPassword")
    def manage_master_user_password(self) -> Optional[bool]:
        """
        Specifies whether to manage the master user password with AWS Secrets Manager. For more information, see [Password management with Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the *Amazon RDS User Guide.*  Constraints:  +  Can't manage the master user password with AWS Secrets Manager if ``MasterUserPassword`` is specified.
        """
        return pulumi.get(self, "manage_master_user_password")

    @property
    @pulumi.getter(name="masterUserPassword")
    def master_user_password(self) -> Optional[str]:
        """
        The password for the master user. The password can include any printable ASCII character except '/', ''', or '@'.  *Amazon Aurora*  Not applicable. The password for the master user is managed by the DB cluster.  *RDS for Db2*  Must contain from 8 to 255 characters.  *RDS for MariaDB*  Constraints: Must contain from 8 to 41 characters.  *RDS for Microsoft SQL Server*  Constraints: Must contain from 8 to 128 characters.  *RDS for MySQL*  Constraints: Must contain from 8 to 41 characters.  *RDS for Oracle*  Constraints: Must contain from 8 to 30 characters.  *RDS for PostgreSQL*  Constraints: Must contain from 8 to 128 characters.
        """
        return pulumi.get(self, "master_user_password")

    @property
    @pulumi.getter(name="masterUserSecret")
    def master_user_secret(self) -> Optional['outputs.MasterUserSecretResponse']:
        """
        The secret managed by RDS in AWS Secrets Manager for the master user password. For more information, see [Password management with Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the *Amazon RDS User Guide.* The ``MasterUserSecret`` return value specifies the secret managed by RDS in AWS Secrets Manager for the master user password. For more information, see [Password management with Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-secrets-manager.html) in the *Amazon RDS User Guide* and [Password management with Secrets Manager](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-secrets-manager.html) in the *Amazon Aurora User Guide.*
        """
        return pulumi.get(self, "master_user_secret")

    @property
    @pulumi.getter(name="masterUsername")
    def master_username(self) -> Optional[str]:
        """
        The master user name for the DB instance.  If you specify the ``SourceDBInstanceIdentifier`` or ``DBSnapshotIdentifier`` property, don't specify this property. The value is inherited from the source DB instance or snapshot. When migrating a self-managed Db2 database, we recommend that you use the same master username as your self-managed Db2 instance name.   *Amazon Aurora*  Not applicable. The name for the master user is managed by the DB cluster.   *RDS for Db2*  Constraints:  +  Must be 1 to 16 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.    *RDS for MariaDB*  Constraints:   +  Must be 1 to 16 letters or numbers.  +  Can't be a reserved word for the chosen database engine.    *RDS for Microsoft SQL Server*  Constraints:   +  Must be 1 to 128 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.    *RDS for MySQL*  Constraints:   +  Must be 1 to 16 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.    *RDS for Oracle*  Constraints:   +  Must be 1 to 30 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.    *RDS for PostgreSQL*  Constraints:   +  Must be 1 to 63 letters or numbers.  +  First character must be a letter.  +  Can't be a reserved word for the chosen database engine.
        """
        return pulumi.get(self, "master_username")

    @property
    @pulumi.getter(name="maxAllocatedStorage")
    def max_allocated_storage(self) -> Optional[int]:
        """
        The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance. For more information about this setting, including limitations that apply to it, see [Managing capacity automatically with Amazon RDS storage autoscaling](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling) in the *Amazon RDS User Guide*. This setting doesn't apply to the following DB instances:  +  Amazon Aurora (Storage is managed by the DB cluster.)  +  RDS Custom
        """
        return pulumi.get(self, "max_allocated_storage")

    @property
    @pulumi.getter(name="monitoringInterval")
    def monitoring_interval(self) -> Optional[int]:
        """
        The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collection of Enhanced Monitoring metrics, specify 0. The default is 0. If ``MonitoringRoleArn`` is specified, then you must set ``MonitoringInterval`` to a value other than 0. This setting doesn't apply to RDS Custom. Valid Values: ``0, 1, 5, 10, 15, 30, 60``
        """
        return pulumi.get(self, "monitoring_interval")

    @property
    @pulumi.getter(name="monitoringRoleArn")
    def monitoring_role_arn(self) -> Optional[str]:
        """
        The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For example, ``arn:aws:iam:123456789012:role/emaccess``. For information on creating a monitoring role, see [Setting Up and Enabling Enhanced Monitoring](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling) in the *Amazon RDS User Guide*. If ``MonitoringInterval`` is set to a value other than ``0``, then you must supply a ``MonitoringRoleArn`` value. This setting doesn't apply to RDS Custom DB instances.
        """
        return pulumi.get(self, "monitoring_role_arn")

    @property
    @pulumi.getter(name="multiAZ")
    def multi_az(self) -> Optional[bool]:
        """
        Specifies whether the database instance is a Multi-AZ DB instance deployment. You can't set the ``AvailabilityZone`` parameter if the ``MultiAZ`` parameter is set to true.   For more information, see [Multi-AZ deployments for high availability](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.MultiAZ.html) in the *Amazon RDS User Guide*.  *Amazon Aurora*  Not applicable. Amazon Aurora storage is replicated across all of the Availability Zones and doesn't require the ``MultiAZ`` option to be set.
        """
        return pulumi.get(self, "multi_az")

    @property
    @pulumi.getter(name="ncharCharacterSetName")
    def nchar_character_set_name(self) -> Optional[str]:
        """
        The name of the NCHAR character set for the Oracle DB instance. This setting doesn't apply to RDS Custom DB instances.
        """
        return pulumi.get(self, "nchar_character_set_name")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[str]:
        """
        The network type of the DB instance. Valid values:  +   ``IPV4``   +   ``DUAL``    The network type is determined by the ``DBSubnetGroup`` specified for the DB instance. A ``DBSubnetGroup`` can support only the IPv4 protocol or the IPv4 and IPv6 protocols (``DUAL``). For more information, see [Working with a DB instance in a VPC](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html) in the *Amazon RDS User Guide.*
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="optionGroupName")
    def option_group_name(self) -> Optional[str]:
        """
        Indicates that the DB instance should be associated with the specified option group. Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance once it is associated with a DB instance.
        """
        return pulumi.get(self, "option_group_name")

    @property
    @pulumi.getter(name="performanceInsightsKMSKeyId")
    def performance_insights_kms_key_id(self) -> Optional[str]:
        """
        The AWS KMS key identifier for encryption of Performance Insights data. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for ``PerformanceInsightsKMSKeyId``, then Amazon RDS uses your default KMS key. There is a default KMS key for your AWS account. Your AWS account has a different default KMS key for each AWS Region. For information about enabling Performance Insights, see [EnablePerformanceInsights](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-enableperformanceinsights).
        """
        return pulumi.get(self, "performance_insights_kms_key_id")

    @property
    @pulumi.getter(name="performanceInsightsRetentionPeriod")
    def performance_insights_retention_period(self) -> Optional[int]:
        """
        The number of days to retain Performance Insights data. This setting doesn't apply to RDS Custom DB instances. Valid Values:  +   ``7``   +   *month* * 31, where *month* is a number of months from 1-23. Examples: ``93`` (3 months * 31), ``341`` (11 months * 31), ``589`` (19 months * 31)  +   ``731``    Default: ``7`` days If you specify a retention period that isn't valid, such as ``94``, Amazon RDS returns an error.
        """
        return pulumi.get(self, "performance_insights_retention_period")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        The port number on which the database accepts connections.  *Amazon Aurora*  Not applicable. The port number is managed by the DB cluster.  *Db2*  Default value: ``50000``
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="preferredBackupWindow")
    def preferred_backup_window(self) -> Optional[str]:
        """
        The daily time range during which automated backups are created if automated backups are enabled, using the ``BackupRetentionPeriod`` parameter. For more information, see [Backup Window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow) in the *Amazon RDS User Guide.*  Constraints:  +  Must be in the format ``hh24:mi-hh24:mi``.  +  Must be in Universal Coordinated Time (UTC).  +  Must not conflict with the preferred maintenance window.  +  Must be at least 30 minutes.    *Amazon Aurora*  Not applicable. The daily time range for creating automated backups is managed by the DB cluster.
        """
        return pulumi.get(self, "preferred_backup_window")

    @property
    @pulumi.getter(name="preferredMaintenanceWindow")
    def preferred_maintenance_window(self) -> Optional[str]:
        """
        The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ``ddd:hh24:mi-ddd:hh24:mi``  The default is a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see [Adjusting the Preferred DB Instance Maintenance Window](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow) in the *Amazon RDS User Guide.*   This property applies when AWS CloudFormation initially creates the DB instance. If you use AWS CloudFormation to update the DB instance, those updates are applied immediately.  Constraints: Minimum 30-minute window.
        """
        return pulumi.get(self, "preferred_maintenance_window")

    @property
    @pulumi.getter(name="processorFeatures")
    def processor_features(self) -> Optional[Sequence['outputs.ProcessorFeatureResponse']]:
        """
        The number of CPU cores and the number of threads per core for the DB instance class of the DB instance. This setting doesn't apply to Amazon Aurora or RDS Custom DB instances.
        """
        return pulumi.get(self, "processor_features")

    @property
    @pulumi.getter(name="promotionTier")
    def promotion_tier(self) -> Optional[int]:
        """
        The order of priority in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance. For more information, see [Fault Tolerance for an Aurora DB Cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.AuroraHighAvailability.html#Aurora.Managing.FaultTolerance) in the *Amazon Aurora User Guide*. This setting doesn't apply to RDS Custom DB instances. Default: ``1``  Valid Values: ``0 - 15``
        """
        return pulumi.get(self, "promotion_tier")

    @property
    @pulumi.getter(name="publiclyAccessible")
    def publicly_accessible(self) -> Optional[bool]:
        """
        Indicates whether the DB instance is an internet-facing instance. If you specify true, AWS CloudFormation creates an instance with a publicly resolvable DNS name, which resolves to a public IP address. If you specify false, AWS CloudFormation creates an internal instance with a DNS name that resolves to a private IP address.  The default behavior value depends on your VPC setup and the database subnet group. For more information, see the ``PubliclyAccessible`` parameter in the [CreateDBInstance](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html) in the *Amazon RDS API Reference*.
        """
        return pulumi.get(self, "publicly_accessible")

    @property
    @pulumi.getter(name="replicaMode")
    def replica_mode(self) -> Optional[str]:
        """
        The open mode of an Oracle read replica. For more information, see [Working with Oracle Read Replicas for Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html) in the *Amazon RDS User Guide*. This setting is only supported in RDS for Oracle. Default: ``open-read-only``  Valid Values: ``open-read-only`` or ``mounted``
        """
        return pulumi.get(self, "replica_mode")

    @property
    @pulumi.getter(name="restoreTime")
    def restore_time(self) -> Optional[str]:
        """
        The date and time to restore from. Constraints:  +  Must be a time in Universal Coordinated Time (UTC) format.  +  Must be before the latest restorable time for the DB instance.  +  Can't be specified if the ``UseLatestRestorableTime`` parameter is enabled.   Example: ``2009-09-07T23:45:00Z``
        """
        return pulumi.get(self, "restore_time")

    @property
    @pulumi.getter(name="sourceDBClusterIdentifier")
    def source_db_cluster_identifier(self) -> Optional[str]:
        """
        The identifier of the Multi-AZ DB cluster that will act as the source for the read replica. Each DB cluster can have up to 15 read replicas. Constraints:  +  Must be the identifier of an existing Multi-AZ DB cluster.  +  Can't be specified if the ``SourceDBInstanceIdentifier`` parameter is also specified.  +  The specified DB cluster must have automatic backups enabled, that is, its backup retention period must be greater than 0.  +  The source DB cluster must be in the same AWS-Region as the read replica. Cross-Region replication isn't supported.
        """
        return pulumi.get(self, "source_db_cluster_identifier")

    @property
    @pulumi.getter(name="sourceDBInstanceAutomatedBackupsArn")
    def source_db_instance_automated_backups_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example, ``arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE``. This setting doesn't apply to RDS Custom.
        """
        return pulumi.get(self, "source_db_instance_automated_backups_arn")

    @property
    @pulumi.getter(name="sourceDBInstanceIdentifier")
    def source_db_instance_identifier(self) -> Optional[str]:
        """
        If you want to create a read replica DB instance, specify the ID of the source DB instance. Each DB instance can have a limited number of read replicas. For more information, see [Working with Read Replicas](https://docs.aws.amazon.com/AmazonRDS/latest/DeveloperGuide/USER_ReadRepl.html) in the *Amazon RDS User Guide*. For information about constraints that apply to DB instance identifiers, see [Naming constraints in Amazon RDS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html#RDS_Limits.Constraints) in the *Amazon RDS User Guide*. The ``SourceDBInstanceIdentifier`` property determines whether a DB instance is a read replica. If you remove the ``SourceDBInstanceIdentifier`` property from your template and then update your stack, AWS CloudFormation promotes the Read Replica to a standalone DB instance.   +  If you specify a source DB instance that uses VPC security groups, we recommend that you specify the ``VPCSecurityGroups`` property. If you don't specify the property, the read replica inherits the value of the ``VPCSecurityGroups`` property from the source DB when you create the replica. However, if you update the stack, AWS CloudFormation reverts the replica's ``VPCSecurityGroups`` property to the default value because it's not defined in the stack's template. This change might cause unexpected issues.  +  Read replicas don't support deletion policies. AWS CloudFormation ignores any deletion policy that's associated with a read replica.  +  If you specify ``SourceDBInstanceIdentifier``, don't specify the ``DBSnapshotIdentifier`` property. You can't create a read replica from a snapshot.  +  Don't set the ``BackupRetentionPeriod``, ``DBName``, ``MasterUsername``, ``MasterUserPassword``, and ``PreferredBackupWindow`` properties. The database attributes are inherited from the source DB instance, and backups are disabled for read replicas.  +  If the source DB instance is in a different region than the read replica, specify the source region in ``SourceRegion``, and specify an ARN for a valid DB instance in ``SourceDBInstanceIdentifier``. For more information, see [Constructing a Amazon RDS Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html#USER_Tagging.ARN) in the *Amazon RDS User Guide*.  +  For DB instances in Amazon Aurora clusters, don't specify this property. Amazon RDS automatically assigns writer and reader DB instances.
        """
        return pulumi.get(self, "source_db_instance_identifier")

    @property
    @pulumi.getter(name="sourceDbiResourceId")
    def source_dbi_resource_id(self) -> Optional[str]:
        """
        The resource ID of the source DB instance from which to restore.
        """
        return pulumi.get(self, "source_dbi_resource_id")

    @property
    @pulumi.getter(name="sourceRegion")
    def source_region(self) -> Optional[str]:
        """
        The ID of the region that contains the source DB instance for the read replica.
        """
        return pulumi.get(self, "source_region")

    @property
    @pulumi.getter(name="storageEncrypted")
    def storage_encrypted(self) -> Optional[bool]:
        """
        A value that indicates whether the DB instance is encrypted. By default, it isn't encrypted. If you specify the ``KmsKeyId`` property, then you must enable encryption. If you specify the ``SourceDBInstanceIdentifier`` property, don't specify this property. The value is inherited from the source DB instance, and if the DB instance is encrypted, the specified ``KmsKeyId`` property is used. If you specify the ``DBSnapshotIdentifier`` and the specified snapshot is encrypted, don't specify this property. The value is inherited from the snapshot, and the specified ``KmsKeyId`` property is used. If you specify the ``DBSnapshotIdentifier`` and the specified snapshot isn't encrypted, you can use this property to specify that the restored DB instance is encrypted. Specify the ``KmsKeyId`` property for the KMS key to use for encryption. If you don't want the restored DB instance to be encrypted, then don't set this property or set it to ``false``.  *Amazon Aurora*  Not applicable. The encryption for DB instances is managed by the DB cluster.
        """
        return pulumi.get(self, "storage_encrypted")

    @property
    @pulumi.getter(name="storageThroughput")
    def storage_throughput(self) -> Optional[int]:
        """
        Specifies the storage throughput value for the DB instance. This setting applies only to the ``gp3`` storage type.  This setting doesn't apply to RDS Custom or Amazon Aurora.
        """
        return pulumi.get(self, "storage_throughput")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[str]:
        """
        The storage type to associate with the DB instance. If you specify ``io1``, ``io2``, or ``gp3``, you must also include a value for the ``Iops`` parameter. This setting doesn't apply to Amazon Aurora DB instances. Storage is managed by the DB cluster. Valid Values: ``gp2 | gp3 | io1 | io2 | standard``  Default: ``io1``, if the ``Iops`` parameter is specified. Otherwise, ``gp2``.
        """
        return pulumi.get(self, "storage_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An optional array of key-value pairs to apply to this DB instance.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tdeCredentialArn")
    def tde_credential_arn(self) -> Optional[str]:
        """
        Property tdeCredentialArn
        """
        return pulumi.get(self, "tde_credential_arn")

    @property
    @pulumi.getter(name="tdeCredentialPassword")
    def tde_credential_password(self) -> Optional[str]:
        """
        Property tdeCredentialPassword
        """
        return pulumi.get(self, "tde_credential_password")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        The time zone of the DB instance. The time zone parameter is currently supported only by [Microsoft SQL Server](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone).
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="useDefaultProcessorFeatures")
    def use_default_processor_features(self) -> Optional[bool]:
        """
        Specifies whether the DB instance class of the DB instance uses its default processor features. This setting doesn't apply to RDS Custom DB instances.
        """
        return pulumi.get(self, "use_default_processor_features")

    @property
    @pulumi.getter(name="useLatestRestorableTime")
    def use_latest_restorable_time(self) -> Optional[bool]:
        """
        Specifies whether the DB instance is restored from the latest backup time. By default, the DB instance isn't restored from the latest backup time. Constraints:  +  Can't be specified if the ``RestoreTime`` parameter is provided.
        """
        return pulumi.get(self, "use_latest_restorable_time")

    @property
    @pulumi.getter(name="vpcSecurityGroups")
    def vpc_security_groups(self) -> Optional[Sequence[str]]:
        """
        A list of the VPC security group IDs to assign to the DB instance. The list can include both the physical IDs of existing VPC security groups and references to [AWS::EC2::SecurityGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html) resources created in the template. If you plan to update the resource, don't specify VPC security groups in a shared VPC.  If you set ``VPCSecurityGroups``, you must not set [DBSecurityGroups](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups), and vice versa.  You can migrate a DB instance in your stack from an RDS DB security group to a VPC security group, but keep the following in mind:  +  You can't revert to using an RDS security group after you establish a VPC security group membership.  +  When you migrate your DB instance to VPC security groups, if your stack update rolls back because the DB instance update fails or because an update fails in another AWS CloudFormation resource, the rollback fails because it can't revert to an RDS security group.  +  To use the properties that are available when you use a VPC security group, you must recreate the DB instance. If you don't, AWS CloudFormation submits only the property values that are listed in the [DBSecurityGroups](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html#cfn-rds-dbinstance-dbsecuritygroups) property.    To avoid this situation, migrate your DB instance to using VPC security groups only when that is the only change in your stack template.   *Amazon Aurora*  Not applicable. The associated list of EC2 VPC security groups is managed by the DB cluster. If specified, the setting must match the DB cluster setting.
        """
        return pulumi.get(self, "vpc_security_groups")


@pulumi.output_type
class AwsRdsDBSnapshotAttributesResultPropertiesResponse(dict):
    """
    Definition of awsRdsDBSnapshotAttributesResult
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbSnapshotAttributes":
            suggest = "db_snapshot_attributes"
        elif key == "dbSnapshotIdentifier":
            suggest = "db_snapshot_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRdsDBSnapshotAttributesResultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRdsDBSnapshotAttributesResultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRdsDBSnapshotAttributesResultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_snapshot_attributes: Optional[Sequence['outputs.DBSnapshotAttributeResponse']] = None,
                 db_snapshot_identifier: Optional[str] = None):
        """
        Definition of awsRdsDBSnapshotAttributesResult
        :param Sequence['DBSnapshotAttributeResponse'] db_snapshot_attributes: <p>The list of attributes and values for the manual DB snapshot.</p>
        :param str db_snapshot_identifier: <p>The identifier of the manual DB snapshot that the attributes apply to.</p>
        """
        if db_snapshot_attributes is not None:
            pulumi.set(__self__, "db_snapshot_attributes", db_snapshot_attributes)
        if db_snapshot_identifier is not None:
            pulumi.set(__self__, "db_snapshot_identifier", db_snapshot_identifier)

    @property
    @pulumi.getter(name="dbSnapshotAttributes")
    def db_snapshot_attributes(self) -> Optional[Sequence['outputs.DBSnapshotAttributeResponse']]:
        """
        <p>The list of attributes and values for the manual DB snapshot.</p>
        """
        return pulumi.get(self, "db_snapshot_attributes")

    @property
    @pulumi.getter(name="dbSnapshotIdentifier")
    def db_snapshot_identifier(self) -> Optional[str]:
        """
        <p>The identifier of the manual DB snapshot that the attributes apply to.</p>
        """
        return pulumi.get(self, "db_snapshot_identifier")


@pulumi.output_type
class AwsRdsDBSnapshotPropertiesResponse(dict):
    """
    Definition of awsRdsDBSnapshot
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedStorage":
            suggest = "allocated_storage"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "dbInstanceIdentifier":
            suggest = "db_instance_identifier"
        elif key == "dbSnapshotArn":
            suggest = "db_snapshot_arn"
        elif key == "dbSnapshotIdentifier":
            suggest = "db_snapshot_identifier"
        elif key == "dbSystemId":
            suggest = "db_system_id"
        elif key == "dbiResourceId":
            suggest = "dbi_resource_id"
        elif key == "dedicatedLogVolume":
            suggest = "dedicated_log_volume"
        elif key == "engineVersion":
            suggest = "engine_version"
        elif key == "iamDatabaseAuthenticationEnabled":
            suggest = "iam_database_authentication_enabled"
        elif key == "instanceCreateTime":
            suggest = "instance_create_time"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "licenseModel":
            suggest = "license_model"
        elif key == "masterUsername":
            suggest = "master_username"
        elif key == "multiTenant":
            suggest = "multi_tenant"
        elif key == "optionGroupName":
            suggest = "option_group_name"
        elif key == "originalSnapshotCreateTime":
            suggest = "original_snapshot_create_time"
        elif key == "percentProgress":
            suggest = "percent_progress"
        elif key == "processorFeatures":
            suggest = "processor_features"
        elif key == "snapshotCreateTime":
            suggest = "snapshot_create_time"
        elif key == "snapshotDatabaseTime":
            suggest = "snapshot_database_time"
        elif key == "snapshotTarget":
            suggest = "snapshot_target"
        elif key == "snapshotType":
            suggest = "snapshot_type"
        elif key == "sourceDBSnapshotIdentifier":
            suggest = "source_db_snapshot_identifier"
        elif key == "sourceRegion":
            suggest = "source_region"
        elif key == "storageThroughput":
            suggest = "storage_throughput"
        elif key == "storageType":
            suggest = "storage_type"
        elif key == "tagList":
            suggest = "tag_list"
        elif key == "tdeCredentialArn":
            suggest = "tde_credential_arn"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRdsDBSnapshotPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRdsDBSnapshotPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRdsDBSnapshotPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_storage: Optional[int] = None,
                 availability_zone: Optional[str] = None,
                 db_instance_identifier: Optional[str] = None,
                 db_snapshot_arn: Optional[str] = None,
                 db_snapshot_identifier: Optional[str] = None,
                 db_system_id: Optional[str] = None,
                 dbi_resource_id: Optional[str] = None,
                 dedicated_log_volume: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 engine: Optional[str] = None,
                 engine_version: Optional[str] = None,
                 iam_database_authentication_enabled: Optional[bool] = None,
                 instance_create_time: Optional[str] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 license_model: Optional[str] = None,
                 master_username: Optional[str] = None,
                 multi_tenant: Optional[bool] = None,
                 option_group_name: Optional[str] = None,
                 original_snapshot_create_time: Optional[str] = None,
                 percent_progress: Optional[int] = None,
                 port: Optional[int] = None,
                 processor_features: Optional[Sequence['outputs.ProcessorFeatureResponse']] = None,
                 snapshot_create_time: Optional[str] = None,
                 snapshot_database_time: Optional[str] = None,
                 snapshot_target: Optional[str] = None,
                 snapshot_type: Optional[str] = None,
                 source_db_snapshot_identifier: Optional[str] = None,
                 source_region: Optional[str] = None,
                 status: Optional[str] = None,
                 storage_throughput: Optional[int] = None,
                 storage_type: Optional[str] = None,
                 tag_list: Optional[Sequence['outputs.TagResponse']] = None,
                 tde_credential_arn: Optional[str] = None,
                 timezone: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of awsRdsDBSnapshot
        :param int allocated_storage: <p>Specifies the allocated storage size in gibibytes (GiB).</p>
        :param str availability_zone: <p>Specifies the name of the Availability Zone the DB instance was located in at the time of the DB snapshot.</p>
        :param str db_instance_identifier: <p>Specifies the DB instance identifier of the DB instance this DB snapshot was created from.</p>
        :param str db_snapshot_arn: <p>The Amazon Resource Name (ARN) for the DB snapshot.</p>
        :param str db_snapshot_identifier: <p>Specifies the identifier for the DB snapshot.</p>
        :param str db_system_id: <p>The Oracle system identifier (SID), which is the name of the Oracle database instance that manages your database files. The Oracle SID is also the name of your CDB.</p>
        :param str dbi_resource_id: <p>The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.</p>
        :param bool dedicated_log_volume: <p>Indicates whether the DB instance has a dedicated log volume (DLV) enabled.</p>
        :param bool encrypted: <p>Indicates whether the DB snapshot is encrypted.</p>
        :param str engine: <p>Specifies the name of the database engine.</p>
        :param str engine_version: <p>Specifies the version of the database engine.</p>
        :param bool iam_database_authentication_enabled: <p>Indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.</p>
        :param str instance_create_time: <p>Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.</p>
        :param int iops: <p>Specifies the Provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.</p>
        :param str kms_key_id: <p>If <code>Encrypted</code> is true, the Amazon Web Services KMS key identifier for the encrypted DB snapshot.</p> <p>The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.</p>
        :param str license_model: <p>License model information for the restored DB instance.</p>
        :param str master_username: <p>Provides the master username for the DB snapshot.</p>
        :param bool multi_tenant: <p>Indicates whether the snapshot is of a DB instance using the multi-tenant configuration (TRUE) or the single-tenant configuration (FALSE).</p>
        :param str option_group_name: <p>Provides the option group name for the DB snapshot.</p>
        :param str original_snapshot_create_time: <p>Specifies the time of the CreateDBSnapshot operation in Coordinated Universal Time (UTC). Doesn't change when the snapshot is copied.</p>
        :param int percent_progress: <p>The percentage of the estimated data that has been transferred.</p>
        :param int port: <p>Specifies the port that the database engine was listening on at the time of the snapshot.</p>
        :param Sequence['ProcessorFeatureResponse'] processor_features: <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance when the DB snapshot was created.</p>
        :param str snapshot_create_time: <p>Specifies when the snapshot was taken in Coordinated Universal Time (UTC). Changes for the copy when the snapshot is copied.</p>
        :param str snapshot_database_time: <p>The timestamp of the most recent transaction applied to the database that you're backing up. Thus, if you restore a snapshot, SnapshotDatabaseTime is the most recent transaction in the restored DB instance. In contrast, originalSnapshotCreateTime specifies the system time that the snapshot completed.</p> <p>If you back up a read replica, you can determine the replica lag by comparing SnapshotDatabaseTime with originalSnapshotCreateTime. For example, if originalSnapshotCreateTime is two hours later than SnapshotDatabaseTime, then the replica lag is two hours.</p>
        :param str snapshot_target: <p>Specifies where manual snapshots are stored: Amazon Web Services Outposts or the Amazon Web Services Region.</p>
        :param str snapshot_type: <p>Provides the type of the DB snapshot.</p>
        :param str source_db_snapshot_identifier: <p>The DB snapshot Amazon Resource Name (ARN) that the DB snapshot was copied from. It only has a value in the case of a cross-account or cross-Region copy.</p>
        :param str source_region: <p>The Amazon Web Services Region that the DB snapshot was created in or copied from.</p>
        :param str status: <p>Specifies the status of this DB snapshot.</p>
        :param int storage_throughput: <p>Specifies the storage throughput for the DB snapshot.</p>
        :param str storage_type: <p>Specifies the storage type associated with DB snapshot.</p>
        :param Sequence['TagResponse'] tag_list: Property tagList
        :param str tde_credential_arn: <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
        :param str timezone: <p>The time zone of the DB snapshot. In most cases, the <code>Timezone</code> element is empty. <code>Timezone</code> content appears only for snapshots taken from Microsoft SQL Server DB instances that were created with a time zone specified.</p>
        :param str vpc_id: <p>Provides the VPC ID associated with the DB snapshot.</p>
        """
        if allocated_storage is not None:
            pulumi.set(__self__, "allocated_storage", allocated_storage)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if db_instance_identifier is not None:
            pulumi.set(__self__, "db_instance_identifier", db_instance_identifier)
        if db_snapshot_arn is not None:
            pulumi.set(__self__, "db_snapshot_arn", db_snapshot_arn)
        if db_snapshot_identifier is not None:
            pulumi.set(__self__, "db_snapshot_identifier", db_snapshot_identifier)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if dbi_resource_id is not None:
            pulumi.set(__self__, "dbi_resource_id", dbi_resource_id)
        if dedicated_log_volume is not None:
            pulumi.set(__self__, "dedicated_log_volume", dedicated_log_volume)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if engine_version is not None:
            pulumi.set(__self__, "engine_version", engine_version)
        if iam_database_authentication_enabled is not None:
            pulumi.set(__self__, "iam_database_authentication_enabled", iam_database_authentication_enabled)
        if instance_create_time is not None:
            pulumi.set(__self__, "instance_create_time", instance_create_time)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)
        if master_username is not None:
            pulumi.set(__self__, "master_username", master_username)
        if multi_tenant is not None:
            pulumi.set(__self__, "multi_tenant", multi_tenant)
        if option_group_name is not None:
            pulumi.set(__self__, "option_group_name", option_group_name)
        if original_snapshot_create_time is not None:
            pulumi.set(__self__, "original_snapshot_create_time", original_snapshot_create_time)
        if percent_progress is not None:
            pulumi.set(__self__, "percent_progress", percent_progress)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if processor_features is not None:
            pulumi.set(__self__, "processor_features", processor_features)
        if snapshot_create_time is not None:
            pulumi.set(__self__, "snapshot_create_time", snapshot_create_time)
        if snapshot_database_time is not None:
            pulumi.set(__self__, "snapshot_database_time", snapshot_database_time)
        if snapshot_target is not None:
            pulumi.set(__self__, "snapshot_target", snapshot_target)
        if snapshot_type is not None:
            pulumi.set(__self__, "snapshot_type", snapshot_type)
        if source_db_snapshot_identifier is not None:
            pulumi.set(__self__, "source_db_snapshot_identifier", source_db_snapshot_identifier)
        if source_region is not None:
            pulumi.set(__self__, "source_region", source_region)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_throughput is not None:
            pulumi.set(__self__, "storage_throughput", storage_throughput)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)
        if tag_list is not None:
            pulumi.set(__self__, "tag_list", tag_list)
        if tde_credential_arn is not None:
            pulumi.set(__self__, "tde_credential_arn", tde_credential_arn)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="allocatedStorage")
    def allocated_storage(self) -> Optional[int]:
        """
        <p>Specifies the allocated storage size in gibibytes (GiB).</p>
        """
        return pulumi.get(self, "allocated_storage")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        <p>Specifies the name of the Availability Zone the DB instance was located in at the time of the DB snapshot.</p>
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="dbInstanceIdentifier")
    def db_instance_identifier(self) -> Optional[str]:
        """
        <p>Specifies the DB instance identifier of the DB instance this DB snapshot was created from.</p>
        """
        return pulumi.get(self, "db_instance_identifier")

    @property
    @pulumi.getter(name="dbSnapshotArn")
    def db_snapshot_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) for the DB snapshot.</p>
        """
        return pulumi.get(self, "db_snapshot_arn")

    @property
    @pulumi.getter(name="dbSnapshotIdentifier")
    def db_snapshot_identifier(self) -> Optional[str]:
        """
        <p>Specifies the identifier for the DB snapshot.</p>
        """
        return pulumi.get(self, "db_snapshot_identifier")

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[str]:
        """
        <p>The Oracle system identifier (SID), which is the name of the Oracle database instance that manages your database files. The Oracle SID is also the name of your CDB.</p>
        """
        return pulumi.get(self, "db_system_id")

    @property
    @pulumi.getter(name="dbiResourceId")
    def dbi_resource_id(self) -> Optional[str]:
        """
        <p>The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.</p>
        """
        return pulumi.get(self, "dbi_resource_id")

    @property
    @pulumi.getter(name="dedicatedLogVolume")
    def dedicated_log_volume(self) -> Optional[bool]:
        """
        <p>Indicates whether the DB instance has a dedicated log volume (DLV) enabled.</p>
        """
        return pulumi.get(self, "dedicated_log_volume")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        <p>Indicates whether the DB snapshot is encrypted.</p>
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def engine(self) -> Optional[str]:
        """
        <p>Specifies the name of the database engine.</p>
        """
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> Optional[str]:
        """
        <p>Specifies the version of the database engine.</p>
        """
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter(name="iamDatabaseAuthenticationEnabled")
    def iam_database_authentication_enabled(self) -> Optional[bool]:
        """
        <p>Indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.</p>
        """
        return pulumi.get(self, "iam_database_authentication_enabled")

    @property
    @pulumi.getter(name="instanceCreateTime")
    def instance_create_time(self) -> Optional[str]:
        """
        <p>Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.</p>
        """
        return pulumi.get(self, "instance_create_time")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        <p>Specifies the Provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.</p>
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        <p>If <code>Encrypted</code> is true, the Amazon Web Services KMS key identifier for the encrypted DB snapshot.</p> <p>The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.</p>
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[str]:
        """
        <p>License model information for the restored DB instance.</p>
        """
        return pulumi.get(self, "license_model")

    @property
    @pulumi.getter(name="masterUsername")
    def master_username(self) -> Optional[str]:
        """
        <p>Provides the master username for the DB snapshot.</p>
        """
        return pulumi.get(self, "master_username")

    @property
    @pulumi.getter(name="multiTenant")
    def multi_tenant(self) -> Optional[bool]:
        """
        <p>Indicates whether the snapshot is of a DB instance using the multi-tenant configuration (TRUE) or the single-tenant configuration (FALSE).</p>
        """
        return pulumi.get(self, "multi_tenant")

    @property
    @pulumi.getter(name="optionGroupName")
    def option_group_name(self) -> Optional[str]:
        """
        <p>Provides the option group name for the DB snapshot.</p>
        """
        return pulumi.get(self, "option_group_name")

    @property
    @pulumi.getter(name="originalSnapshotCreateTime")
    def original_snapshot_create_time(self) -> Optional[str]:
        """
        <p>Specifies the time of the CreateDBSnapshot operation in Coordinated Universal Time (UTC). Doesn't change when the snapshot is copied.</p>
        """
        return pulumi.get(self, "original_snapshot_create_time")

    @property
    @pulumi.getter(name="percentProgress")
    def percent_progress(self) -> Optional[int]:
        """
        <p>The percentage of the estimated data that has been transferred.</p>
        """
        return pulumi.get(self, "percent_progress")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        <p>Specifies the port that the database engine was listening on at the time of the snapshot.</p>
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="processorFeatures")
    def processor_features(self) -> Optional[Sequence['outputs.ProcessorFeatureResponse']]:
        """
        <p>The number of CPU cores and the number of threads per core for the DB instance class of the DB instance when the DB snapshot was created.</p>
        """
        return pulumi.get(self, "processor_features")

    @property
    @pulumi.getter(name="snapshotCreateTime")
    def snapshot_create_time(self) -> Optional[str]:
        """
        <p>Specifies when the snapshot was taken in Coordinated Universal Time (UTC). Changes for the copy when the snapshot is copied.</p>
        """
        return pulumi.get(self, "snapshot_create_time")

    @property
    @pulumi.getter(name="snapshotDatabaseTime")
    def snapshot_database_time(self) -> Optional[str]:
        """
        <p>The timestamp of the most recent transaction applied to the database that you're backing up. Thus, if you restore a snapshot, SnapshotDatabaseTime is the most recent transaction in the restored DB instance. In contrast, originalSnapshotCreateTime specifies the system time that the snapshot completed.</p> <p>If you back up a read replica, you can determine the replica lag by comparing SnapshotDatabaseTime with originalSnapshotCreateTime. For example, if originalSnapshotCreateTime is two hours later than SnapshotDatabaseTime, then the replica lag is two hours.</p>
        """
        return pulumi.get(self, "snapshot_database_time")

    @property
    @pulumi.getter(name="snapshotTarget")
    def snapshot_target(self) -> Optional[str]:
        """
        <p>Specifies where manual snapshots are stored: Amazon Web Services Outposts or the Amazon Web Services Region.</p>
        """
        return pulumi.get(self, "snapshot_target")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> Optional[str]:
        """
        <p>Provides the type of the DB snapshot.</p>
        """
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter(name="sourceDBSnapshotIdentifier")
    def source_db_snapshot_identifier(self) -> Optional[str]:
        """
        <p>The DB snapshot Amazon Resource Name (ARN) that the DB snapshot was copied from. It only has a value in the case of a cross-account or cross-Region copy.</p>
        """
        return pulumi.get(self, "source_db_snapshot_identifier")

    @property
    @pulumi.getter(name="sourceRegion")
    def source_region(self) -> Optional[str]:
        """
        <p>The Amazon Web Services Region that the DB snapshot was created in or copied from.</p>
        """
        return pulumi.get(self, "source_region")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        <p>Specifies the status of this DB snapshot.</p>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageThroughput")
    def storage_throughput(self) -> Optional[int]:
        """
        <p>Specifies the storage throughput for the DB snapshot.</p>
        """
        return pulumi.get(self, "storage_throughput")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[str]:
        """
        <p>Specifies the storage type associated with DB snapshot.</p>
        """
        return pulumi.get(self, "storage_type")

    @property
    @pulumi.getter(name="tagList")
    def tag_list(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        Property tagList
        """
        return pulumi.get(self, "tag_list")

    @property
    @pulumi.getter(name="tdeCredentialArn")
    def tde_credential_arn(self) -> Optional[str]:
        """
        <p>The ARN from the key store with which to associate the instance for TDE encryption.</p>
        """
        return pulumi.get(self, "tde_credential_arn")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        <p>The time zone of the DB snapshot. In most cases, the <code>Timezone</code> element is empty. <code>Timezone</code> content appears only for snapshots taken from Microsoft SQL Server DB instances that were created with a time zone specified.</p>
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        <p>Provides the VPC ID associated with the DB snapshot.</p>
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsRdsEventSubscriptionPropertiesResponse(dict):
    """
    Definition of awsRdsEventSubscription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventCategories":
            suggest = "event_categories"
        elif key == "snsTopicArn":
            suggest = "sns_topic_arn"
        elif key == "sourceIds":
            suggest = "source_ids"
        elif key == "sourceType":
            suggest = "source_type"
        elif key == "subscriptionName":
            suggest = "subscription_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRdsEventSubscriptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRdsEventSubscriptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRdsEventSubscriptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 event_categories: Optional[Sequence[str]] = None,
                 sns_topic_arn: Optional[str] = None,
                 source_ids: Optional[Sequence[str]] = None,
                 source_type: Optional[str] = None,
                 subscription_name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsRdsEventSubscription
        :param bool enabled: A Boolean value; set to true to activate the subscription, set to false to create the subscription but not active it.
        :param Sequence[str] event_categories: A list of event categories for a SourceType that you want to subscribe to. You can see a list of the categories for a given SourceType in the Events topic in the Amazon RDS User Guide or by using the DescribeEventCategories action.
        :param str sns_topic_arn: The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        :param Sequence[str] source_ids: The list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it cannot end with a hyphen or contain two consecutive hyphens.
        :param str source_type: The type of source that will be generating the events. For example, if you want to be notified of events generated by a DB instance, you would set this parameter to db-instance. if this value is not specified, all events are returned.
        :param str subscription_name: The name of the subscription.
        :param Sequence['TagResponse'] tags: An array of key-value pairs to apply to this resource.
        """
        if enabled is None:
            enabled = True
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if event_categories is not None:
            pulumi.set(__self__, "event_categories", event_categories)
        if sns_topic_arn is not None:
            pulumi.set(__self__, "sns_topic_arn", sns_topic_arn)
        if source_ids is not None:
            pulumi.set(__self__, "source_ids", source_ids)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        A Boolean value; set to true to activate the subscription, set to false to create the subscription but not active it.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="eventCategories")
    def event_categories(self) -> Optional[Sequence[str]]:
        """
        A list of event categories for a SourceType that you want to subscribe to. You can see a list of the categories for a given SourceType in the Events topic in the Amazon RDS User Guide or by using the DescribeEventCategories action.
        """
        return pulumi.get(self, "event_categories")

    @property
    @pulumi.getter(name="snsTopicArn")
    def sns_topic_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        """
        return pulumi.get(self, "sns_topic_arn")

    @property
    @pulumi.getter(name="sourceIds")
    def source_ids(self) -> Optional[Sequence[str]]:
        """
        The list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it cannot end with a hyphen or contain two consecutive hyphens.
        """
        return pulumi.get(self, "source_ids")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[str]:
        """
        The type of source that will be generating the events. For example, if you want to be notified of events generated by a DB instance, you would set this parameter to db-instance. if this value is not specified, all events are returned.
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[str]:
        """
        The name of the subscription.
        """
        return pulumi.get(self, "subscription_name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An array of key-value pairs to apply to this resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsRdsExportTaskPropertiesResponse(dict):
    """
    Definition of awsRdsExportTask
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportOnly":
            suggest = "export_only"
        elif key == "exportTaskIdentifier":
            suggest = "export_task_identifier"
        elif key == "failureCause":
            suggest = "failure_cause"
        elif key == "iamRoleArn":
            suggest = "iam_role_arn"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "percentProgress":
            suggest = "percent_progress"
        elif key == "s3Bucket":
            suggest = "s3_bucket"
        elif key == "s3Prefix":
            suggest = "s3_prefix"
        elif key == "snapshotTime":
            suggest = "snapshot_time"
        elif key == "sourceArn":
            suggest = "source_arn"
        elif key == "sourceType":
            suggest = "source_type"
        elif key == "taskEndTime":
            suggest = "task_end_time"
        elif key == "taskStartTime":
            suggest = "task_start_time"
        elif key == "totalExtractedDataInGB":
            suggest = "total_extracted_data_in_gb"
        elif key == "warningMessage":
            suggest = "warning_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRdsExportTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRdsExportTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRdsExportTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_only: Optional[Sequence[str]] = None,
                 export_task_identifier: Optional[str] = None,
                 failure_cause: Optional[str] = None,
                 iam_role_arn: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 percent_progress: Optional[int] = None,
                 s3_bucket: Optional[str] = None,
                 s3_prefix: Optional[str] = None,
                 snapshot_time: Optional[str] = None,
                 source_arn: Optional[str] = None,
                 source_type: Optional['outputs.ExportSourceTypeEnumValueResponse'] = None,
                 status: Optional[str] = None,
                 task_end_time: Optional[str] = None,
                 task_start_time: Optional[str] = None,
                 total_extracted_data_in_gb: Optional[int] = None,
                 warning_message: Optional[str] = None):
        """
        Definition of awsRdsExportTask
        :param Sequence[str] export_only: <p>The data exported from the snapshot or cluster.</p> <p>Valid Values:</p> <ul> <li> <p> <code>database</code> - Export all the data from a specified database.</p> </li> <li> <p> <code>database.table</code> <i>table-name</i> - Export a table of the snapshot or cluster. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.</p> </li> <li> <p> <code>database.schema</code> <i>schema-name</i> - Export a database schema of the snapshot or cluster. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p> </li> <li> <p> <code>database.schema.table</code> <i>table-name</i> - Export a table of the database schema. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p> </li> </ul>
        :param str export_task_identifier: <p>A unique identifier for the snapshot or cluster export task. This ID isn't an identifier for the Amazon S3 bucket where the data is exported.</p>
        :param str failure_cause: <p>The reason the export failed, if it failed.</p>
        :param str iam_role_arn: <p>The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot or cluster.</p>
        :param str kms_key_id: <p>The key identifier of the Amazon Web Services KMS key that is used to encrypt the data when it's exported to Amazon S3. The KMS key identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the export must have encryption and decryption permissions to use this KMS key.</p>
        :param int percent_progress: <p>The progress of the snapshot or cluster export task as a percentage.</p>
        :param str s3_bucket: <p>The Amazon S3 bucket where the snapshot or cluster is exported to.</p>
        :param str s3_prefix: <p>The Amazon S3 bucket prefix that is the file name and path of the exported data.</p>
        :param str snapshot_time: <p>The time when the snapshot was created.</p>
        :param str source_arn: <p>The Amazon Resource Name (ARN) of the snapshot or cluster exported to Amazon S3.</p>
        :param 'ExportSourceTypeEnumValueResponse' source_type: <p>The type of source for the export.</p>
        :param str status: <p>The progress status of the export task. The status can be one of the following:</p> <ul> <li> <p> <code>CANCELED</code> </p> </li> <li> <p> <code>CANCELING</code> </p> </li> <li> <p> <code>COMPLETE</code> </p> </li> <li> <p> <code>FAILED</code> </p> </li> <li> <p> <code>IN_PROGRESS</code> </p> </li> <li> <p> <code>STARTING</code> </p> </li> </ul>
        :param str task_end_time: <p>The time when the snapshot or cluster export task ended.</p>
        :param str task_start_time: <p>The time when the snapshot or cluster export task started.</p>
        :param int total_extracted_data_in_gb: <p>The total amount of data exported, in gigabytes.</p>
        :param str warning_message: <p>A warning about the snapshot or cluster export task.</p>
        """
        if export_only is not None:
            pulumi.set(__self__, "export_only", export_only)
        if export_task_identifier is not None:
            pulumi.set(__self__, "export_task_identifier", export_task_identifier)
        if failure_cause is not None:
            pulumi.set(__self__, "failure_cause", failure_cause)
        if iam_role_arn is not None:
            pulumi.set(__self__, "iam_role_arn", iam_role_arn)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if percent_progress is not None:
            pulumi.set(__self__, "percent_progress", percent_progress)
        if s3_bucket is not None:
            pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_prefix is not None:
            pulumi.set(__self__, "s3_prefix", s3_prefix)
        if snapshot_time is not None:
            pulumi.set(__self__, "snapshot_time", snapshot_time)
        if source_arn is not None:
            pulumi.set(__self__, "source_arn", source_arn)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if task_end_time is not None:
            pulumi.set(__self__, "task_end_time", task_end_time)
        if task_start_time is not None:
            pulumi.set(__self__, "task_start_time", task_start_time)
        if total_extracted_data_in_gb is not None:
            pulumi.set(__self__, "total_extracted_data_in_gb", total_extracted_data_in_gb)
        if warning_message is not None:
            pulumi.set(__self__, "warning_message", warning_message)

    @property
    @pulumi.getter(name="exportOnly")
    def export_only(self) -> Optional[Sequence[str]]:
        """
        <p>The data exported from the snapshot or cluster.</p> <p>Valid Values:</p> <ul> <li> <p> <code>database</code> - Export all the data from a specified database.</p> </li> <li> <p> <code>database.table</code> <i>table-name</i> - Export a table of the snapshot or cluster. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.</p> </li> <li> <p> <code>database.schema</code> <i>schema-name</i> - Export a database schema of the snapshot or cluster. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p> </li> <li> <p> <code>database.schema.table</code> <i>table-name</i> - Export a table of the database schema. This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.</p> </li> </ul>
        """
        return pulumi.get(self, "export_only")

    @property
    @pulumi.getter(name="exportTaskIdentifier")
    def export_task_identifier(self) -> Optional[str]:
        """
        <p>A unique identifier for the snapshot or cluster export task. This ID isn't an identifier for the Amazon S3 bucket where the data is exported.</p>
        """
        return pulumi.get(self, "export_task_identifier")

    @property
    @pulumi.getter(name="failureCause")
    def failure_cause(self) -> Optional[str]:
        """
        <p>The reason the export failed, if it failed.</p>
        """
        return pulumi.get(self, "failure_cause")

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> Optional[str]:
        """
        <p>The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot or cluster.</p>
        """
        return pulumi.get(self, "iam_role_arn")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        <p>The key identifier of the Amazon Web Services KMS key that is used to encrypt the data when it's exported to Amazon S3. The KMS key identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the export must have encryption and decryption permissions to use this KMS key.</p>
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="percentProgress")
    def percent_progress(self) -> Optional[int]:
        """
        <p>The progress of the snapshot or cluster export task as a percentage.</p>
        """
        return pulumi.get(self, "percent_progress")

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> Optional[str]:
        """
        <p>The Amazon S3 bucket where the snapshot or cluster is exported to.</p>
        """
        return pulumi.get(self, "s3_bucket")

    @property
    @pulumi.getter(name="s3Prefix")
    def s3_prefix(self) -> Optional[str]:
        """
        <p>The Amazon S3 bucket prefix that is the file name and path of the exported data.</p>
        """
        return pulumi.get(self, "s3_prefix")

    @property
    @pulumi.getter(name="snapshotTime")
    def snapshot_time(self) -> Optional[str]:
        """
        <p>The time when the snapshot was created.</p>
        """
        return pulumi.get(self, "snapshot_time")

    @property
    @pulumi.getter(name="sourceArn")
    def source_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the snapshot or cluster exported to Amazon S3.</p>
        """
        return pulumi.get(self, "source_arn")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional['outputs.ExportSourceTypeEnumValueResponse']:
        """
        <p>The type of source for the export.</p>
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        <p>The progress status of the export task. The status can be one of the following:</p> <ul> <li> <p> <code>CANCELED</code> </p> </li> <li> <p> <code>CANCELING</code> </p> </li> <li> <p> <code>COMPLETE</code> </p> </li> <li> <p> <code>FAILED</code> </p> </li> <li> <p> <code>IN_PROGRESS</code> </p> </li> <li> <p> <code>STARTING</code> </p> </li> </ul>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="taskEndTime")
    def task_end_time(self) -> Optional[str]:
        """
        <p>The time when the snapshot or cluster export task ended.</p>
        """
        return pulumi.get(self, "task_end_time")

    @property
    @pulumi.getter(name="taskStartTime")
    def task_start_time(self) -> Optional[str]:
        """
        <p>The time when the snapshot or cluster export task started.</p>
        """
        return pulumi.get(self, "task_start_time")

    @property
    @pulumi.getter(name="totalExtractedDataInGB")
    def total_extracted_data_in_gb(self) -> Optional[int]:
        """
        <p>The total amount of data exported, in gigabytes.</p>
        """
        return pulumi.get(self, "total_extracted_data_in_gb")

    @property
    @pulumi.getter(name="warningMessage")
    def warning_message(self) -> Optional[str]:
        """
        <p>A warning about the snapshot or cluster export task.</p>
        """
        return pulumi.get(self, "warning_message")


@pulumi.output_type
class AwsRedshiftClusterParameterGroupPropertiesResponse(dict):
    """
    Definition of awsRedshiftClusterParameterGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterGroupFamily":
            suggest = "parameter_group_family"
        elif key == "parameterGroupName":
            suggest = "parameter_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRedshiftClusterParameterGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRedshiftClusterParameterGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRedshiftClusterParameterGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 parameter_group_family: Optional[str] = None,
                 parameter_group_name: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.ParameterResponse']] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsRedshiftClusterParameterGroup
        :param str description: A description of the parameter group.
        :param str parameter_group_family: The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.
        :param str parameter_group_name: The name of the cluster parameter group.
        :param Sequence['ParameterResponse'] parameters: An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.
        :param Sequence['TagResponse'] tags: An array of key-value pairs to apply to this resource.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameter_group_family is not None:
            pulumi.set(__self__, "parameter_group_family", parameter_group_family)
        if parameter_group_name is not None:
            pulumi.set(__self__, "parameter_group_name", parameter_group_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description of the parameter group.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="parameterGroupFamily")
    def parameter_group_family(self) -> Optional[str]:
        """
        The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.
        """
        return pulumi.get(self, "parameter_group_family")

    @property
    @pulumi.getter(name="parameterGroupName")
    def parameter_group_name(self) -> Optional[str]:
        """
        The name of the cluster parameter group.
        """
        return pulumi.get(self, "parameter_group_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.ParameterResponse']]:
        """
        An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An array of key-value pairs to apply to this resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsRedshiftClusterPropertiesResponse(dict):
    """
    Definition of awsRedshiftCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowVersionUpgrade":
            suggest = "allow_version_upgrade"
        elif key == "aquaConfigurationStatus":
            suggest = "aqua_configuration_status"
        elif key == "automatedSnapshotRetentionPeriod":
            suggest = "automated_snapshot_retention_period"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "availabilityZoneRelocation":
            suggest = "availability_zone_relocation"
        elif key == "availabilityZoneRelocationStatus":
            suggest = "availability_zone_relocation_status"
        elif key == "clusterIdentifier":
            suggest = "cluster_identifier"
        elif key == "clusterNamespaceArn":
            suggest = "cluster_namespace_arn"
        elif key == "clusterParameterGroupName":
            suggest = "cluster_parameter_group_name"
        elif key == "clusterSecurityGroups":
            suggest = "cluster_security_groups"
        elif key == "clusterSubnetGroupName":
            suggest = "cluster_subnet_group_name"
        elif key == "clusterType":
            suggest = "cluster_type"
        elif key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "deferMaintenance":
            suggest = "defer_maintenance"
        elif key == "deferMaintenanceDuration":
            suggest = "defer_maintenance_duration"
        elif key == "deferMaintenanceEndTime":
            suggest = "defer_maintenance_end_time"
        elif key == "deferMaintenanceIdentifier":
            suggest = "defer_maintenance_identifier"
        elif key == "deferMaintenanceStartTime":
            suggest = "defer_maintenance_start_time"
        elif key == "destinationRegion":
            suggest = "destination_region"
        elif key == "elasticIp":
            suggest = "elastic_ip"
        elif key == "enhancedVpcRouting":
            suggest = "enhanced_vpc_routing"
        elif key == "hsmClientCertificateIdentifier":
            suggest = "hsm_client_certificate_identifier"
        elif key == "hsmConfigurationIdentifier":
            suggest = "hsm_configuration_identifier"
        elif key == "iamRoles":
            suggest = "iam_roles"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "loggingProperties":
            suggest = "logging_properties"
        elif key == "maintenanceTrackName":
            suggest = "maintenance_track_name"
        elif key == "manageMasterPassword":
            suggest = "manage_master_password"
        elif key == "manualSnapshotRetentionPeriod":
            suggest = "manual_snapshot_retention_period"
        elif key == "masterPasswordSecretArn":
            suggest = "master_password_secret_arn"
        elif key == "masterPasswordSecretKmsKeyId":
            suggest = "master_password_secret_kms_key_id"
        elif key == "masterUserPassword":
            suggest = "master_user_password"
        elif key == "masterUsername":
            suggest = "master_username"
        elif key == "multiAZ":
            suggest = "multi_az"
        elif key == "namespaceResourcePolicy":
            suggest = "namespace_resource_policy"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "numberOfNodes":
            suggest = "number_of_nodes"
        elif key == "ownerAccount":
            suggest = "owner_account"
        elif key == "preferredMaintenanceWindow":
            suggest = "preferred_maintenance_window"
        elif key == "publiclyAccessible":
            suggest = "publicly_accessible"
        elif key == "resourceAction":
            suggest = "resource_action"
        elif key == "revisionTarget":
            suggest = "revision_target"
        elif key == "rotateEncryptionKey":
            suggest = "rotate_encryption_key"
        elif key == "snapshotClusterIdentifier":
            suggest = "snapshot_cluster_identifier"
        elif key == "snapshotCopyGrantName":
            suggest = "snapshot_copy_grant_name"
        elif key == "snapshotCopyManual":
            suggest = "snapshot_copy_manual"
        elif key == "snapshotCopyRetentionPeriod":
            suggest = "snapshot_copy_retention_period"
        elif key == "snapshotIdentifier":
            suggest = "snapshot_identifier"
        elif key == "vpcSecurityGroupIds":
            suggest = "vpc_security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRedshiftClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRedshiftClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRedshiftClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_version_upgrade: Optional[bool] = None,
                 aqua_configuration_status: Optional[str] = None,
                 automated_snapshot_retention_period: Optional[int] = None,
                 availability_zone: Optional[str] = None,
                 availability_zone_relocation: Optional[bool] = None,
                 availability_zone_relocation_status: Optional[str] = None,
                 classic: Optional[bool] = None,
                 cluster_identifier: Optional[str] = None,
                 cluster_namespace_arn: Optional[str] = None,
                 cluster_parameter_group_name: Optional[str] = None,
                 cluster_security_groups: Optional[Sequence[str]] = None,
                 cluster_subnet_group_name: Optional[str] = None,
                 cluster_type: Optional[str] = None,
                 cluster_version: Optional[str] = None,
                 db_name: Optional[str] = None,
                 defer_maintenance: Optional[bool] = None,
                 defer_maintenance_duration: Optional[int] = None,
                 defer_maintenance_end_time: Optional[str] = None,
                 defer_maintenance_identifier: Optional[str] = None,
                 defer_maintenance_start_time: Optional[str] = None,
                 destination_region: Optional[str] = None,
                 elastic_ip: Optional[str] = None,
                 encrypted: Optional[bool] = None,
                 endpoint: Optional['outputs.RedshiftClusterEndpointResponse'] = None,
                 enhanced_vpc_routing: Optional[bool] = None,
                 hsm_client_certificate_identifier: Optional[str] = None,
                 hsm_configuration_identifier: Optional[str] = None,
                 iam_roles: Optional[Sequence[str]] = None,
                 kms_key_id: Optional[str] = None,
                 logging_properties: Optional['outputs.LoggingPropertiesResponse'] = None,
                 maintenance_track_name: Optional[str] = None,
                 manage_master_password: Optional[bool] = None,
                 manual_snapshot_retention_period: Optional[int] = None,
                 master_password_secret_arn: Optional[str] = None,
                 master_password_secret_kms_key_id: Optional[str] = None,
                 master_user_password: Optional[str] = None,
                 master_username: Optional[str] = None,
                 multi_az: Optional[bool] = None,
                 namespace_resource_policy: Optional[Any] = None,
                 node_type: Optional[str] = None,
                 number_of_nodes: Optional[int] = None,
                 owner_account: Optional[str] = None,
                 port: Optional[int] = None,
                 preferred_maintenance_window: Optional[str] = None,
                 publicly_accessible: Optional[bool] = None,
                 resource_action: Optional[str] = None,
                 revision_target: Optional[str] = None,
                 rotate_encryption_key: Optional[bool] = None,
                 snapshot_cluster_identifier: Optional[str] = None,
                 snapshot_copy_grant_name: Optional[str] = None,
                 snapshot_copy_manual: Optional[bool] = None,
                 snapshot_copy_retention_period: Optional[int] = None,
                 snapshot_identifier: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 vpc_security_group_ids: Optional[Sequence[str]] = None):
        """
        Definition of awsRedshiftCluster
        :param bool allow_version_upgrade: Major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. Default value is True
        :param str aqua_configuration_status: The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) after the cluster is restored. Possible values include the following.enabled - Use AQUA if it is available for the current Region and Amazon Redshift node type.disabled - Don't use AQUA.auto - Amazon Redshift determines whether to use AQUA.
        :param int automated_snapshot_retention_period: The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Default value is 1
        :param str availability_zone: The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint
        :param bool availability_zone_relocation: The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete.
        :param str availability_zone_relocation_status: The availability zone relocation status of the cluster
        :param bool classic: A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to false , the resize type is elastic.
        :param str cluster_identifier: A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. All alphabetical characters must be lower case, no hypens at the end, no two consecutive hyphens. Cluster name should be unique for all clusters within an AWS account
        :param str cluster_namespace_arn: The Amazon Resource Name (ARN) of the cluster namespace.
        :param str cluster_parameter_group_name: The name of the parameter group to be associated with this cluster.
        :param Sequence[str] cluster_security_groups: A list of security groups to be associated with this cluster.
        :param str cluster_subnet_group_name: The name of a cluster subnet group to be associated with this cluster.
        :param str cluster_type: The type of the cluster. When cluster type is specified as single-node, the NumberOfNodes parameter is not required and if multi-node, the NumberOfNodes parameter is required
        :param str cluster_version: The version of the Amazon Redshift engine software that you want to deploy on the cluster.The version selected runs on all the nodes in the cluster.
        :param str db_name: The name of the first database to be created when the cluster is created. To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database.
        :param bool defer_maintenance: A boolean indicating whether to enable the deferred maintenance window.
        :param int defer_maintenance_duration: An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
        :param str defer_maintenance_end_time: A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
        :param str defer_maintenance_identifier: A unique identifier for the deferred maintenance window.
        :param str defer_maintenance_start_time: A timestamp indicating the start time for the deferred maintenance window.
        :param str destination_region: The destination AWS Region that you want to copy snapshots to. Constraints: Must be the name of a valid AWS Region. For more information, see Regions and Endpoints in the Amazon Web Services [https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region] General Reference
        :param str elastic_ip: The Elastic IP (EIP) address for the cluster.
        :param bool encrypted: If true, the data in the cluster is encrypted at rest.
        :param 'RedshiftClusterEndpointResponse' endpoint: Property endpoint
        :param bool enhanced_vpc_routing: An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see Enhanced VPC Routing in the Amazon Redshift Cluster Management Guide.If this option is true , enhanced VPC routing is enabled.Default: false
        :param str hsm_client_certificate_identifier: Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM
        :param str hsm_configuration_identifier: Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
        :param Sequence[str] iam_roles: A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 50 IAM roles in a single request
        :param str kms_key_id: The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
        :param 'LoggingPropertiesResponse' logging_properties: Property loggingProperties
        :param str maintenance_track_name: The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the PendingModifiedValues for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
        :param bool manage_master_password: A boolean indicating if the redshift cluster's admin user credentials is managed by Redshift or not. You can't use MasterUserPassword if ManageMasterPassword is true. If ManageMasterPassword is false or not set, Amazon Redshift uses MasterUserPassword for the admin user account's password.
        :param int manual_snapshot_retention_period: The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely.The value must be either -1 or an integer between 1 and 3,653.
        :param str master_password_secret_arn: The Amazon Resource Name (ARN) for the cluster's admin user credentials secret.
        :param str master_password_secret_kms_key_id: The ID of the Key Management Service (KMS) key used to encrypt and store the cluster's admin user credentials secret.
        :param str master_user_password: The password associated with the master user account for the cluster that is being created. You can't use MasterUserPassword if ManageMasterPassword is true. Password must be between 8 and 64 characters in length, should have at least one uppercase letter.Must contain at least one lowercase letter.Must contain one number.Can be any printable ASCII character.
        :param str master_username: The user name associated with the master user account for the cluster that is being created. The user name can't be PUBLIC and first character must be a letter.
        :param bool multi_az: A boolean indicating if the redshift cluster is multi-az or not. If you don't provide this parameter or set the value to false, the redshift cluster will be single-az.
        :param Any namespace_resource_policy: The namespace resource policy document that will be attached to a Redshift cluster.
        :param str node_type: The node type to be provisioned for the cluster.Valid Values: ds2.xlarge | ds2.8xlarge | dc1.large | dc1.8xlarge | dc2.large | dc2.8xlarge | ra3.4xlarge | ra3.16xlarge
        :param int number_of_nodes: The number of compute nodes in the cluster. This parameter is required when the ClusterType parameter is specified as multi-node.
        :param str owner_account: Property ownerAccount
        :param int port: The port number on which the cluster accepts incoming connections. The cluster is accessible only via the JDBC and ODBC connection strings
        :param str preferred_maintenance_window: The weekly time range (in UTC) during which automated cluster maintenance can occur.
        :param bool publicly_accessible: If true, the cluster can be accessed from a public network.
        :param str resource_action: The Redshift operation to be performed. Resource Action supports pause-cluster, resume-cluster, failover-primary-compute APIs
        :param str revision_target: The identifier of the database revision. You can retrieve this value from the response to the DescribeClusterDbRevisions request.
        :param bool rotate_encryption_key: A boolean indicating if we want to rotate Encryption Keys.
        :param str snapshot_cluster_identifier: The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
        :param str snapshot_copy_grant_name: The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
        :param bool snapshot_copy_manual: Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
        :param int snapshot_copy_retention_period: The number of days to retain automated snapshots in the destination region after they are copied from the source region.  Default is 7.  Constraints: Must be at least 1 and no more than 35.
        :param str snapshot_identifier: The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.
        :param Sequence['TagResponse'] tags: The list of tags for the cluster parameter group.
        :param Sequence[str] vpc_security_group_ids: A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.
        """
        if allow_version_upgrade is not None:
            pulumi.set(__self__, "allow_version_upgrade", allow_version_upgrade)
        if aqua_configuration_status is not None:
            pulumi.set(__self__, "aqua_configuration_status", aqua_configuration_status)
        if automated_snapshot_retention_period is not None:
            pulumi.set(__self__, "automated_snapshot_retention_period", automated_snapshot_retention_period)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if availability_zone_relocation is not None:
            pulumi.set(__self__, "availability_zone_relocation", availability_zone_relocation)
        if availability_zone_relocation_status is not None:
            pulumi.set(__self__, "availability_zone_relocation_status", availability_zone_relocation_status)
        if classic is not None:
            pulumi.set(__self__, "classic", classic)
        if cluster_identifier is not None:
            pulumi.set(__self__, "cluster_identifier", cluster_identifier)
        if cluster_namespace_arn is not None:
            pulumi.set(__self__, "cluster_namespace_arn", cluster_namespace_arn)
        if cluster_parameter_group_name is not None:
            pulumi.set(__self__, "cluster_parameter_group_name", cluster_parameter_group_name)
        if cluster_security_groups is not None:
            pulumi.set(__self__, "cluster_security_groups", cluster_security_groups)
        if cluster_subnet_group_name is not None:
            pulumi.set(__self__, "cluster_subnet_group_name", cluster_subnet_group_name)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if defer_maintenance is not None:
            pulumi.set(__self__, "defer_maintenance", defer_maintenance)
        if defer_maintenance_duration is not None:
            pulumi.set(__self__, "defer_maintenance_duration", defer_maintenance_duration)
        if defer_maintenance_end_time is not None:
            pulumi.set(__self__, "defer_maintenance_end_time", defer_maintenance_end_time)
        if defer_maintenance_identifier is not None:
            pulumi.set(__self__, "defer_maintenance_identifier", defer_maintenance_identifier)
        if defer_maintenance_start_time is not None:
            pulumi.set(__self__, "defer_maintenance_start_time", defer_maintenance_start_time)
        if destination_region is not None:
            pulumi.set(__self__, "destination_region", destination_region)
        if elastic_ip is not None:
            pulumi.set(__self__, "elastic_ip", elastic_ip)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if enhanced_vpc_routing is not None:
            pulumi.set(__self__, "enhanced_vpc_routing", enhanced_vpc_routing)
        if hsm_client_certificate_identifier is not None:
            pulumi.set(__self__, "hsm_client_certificate_identifier", hsm_client_certificate_identifier)
        if hsm_configuration_identifier is not None:
            pulumi.set(__self__, "hsm_configuration_identifier", hsm_configuration_identifier)
        if iam_roles is not None:
            pulumi.set(__self__, "iam_roles", iam_roles)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if logging_properties is not None:
            pulumi.set(__self__, "logging_properties", logging_properties)
        if maintenance_track_name is not None:
            pulumi.set(__self__, "maintenance_track_name", maintenance_track_name)
        if manage_master_password is not None:
            pulumi.set(__self__, "manage_master_password", manage_master_password)
        if manual_snapshot_retention_period is not None:
            pulumi.set(__self__, "manual_snapshot_retention_period", manual_snapshot_retention_period)
        if master_password_secret_arn is not None:
            pulumi.set(__self__, "master_password_secret_arn", master_password_secret_arn)
        if master_password_secret_kms_key_id is not None:
            pulumi.set(__self__, "master_password_secret_kms_key_id", master_password_secret_kms_key_id)
        if master_user_password is not None:
            pulumi.set(__self__, "master_user_password", master_user_password)
        if master_username is not None:
            pulumi.set(__self__, "master_username", master_username)
        if multi_az is not None:
            pulumi.set(__self__, "multi_az", multi_az)
        if namespace_resource_policy is not None:
            pulumi.set(__self__, "namespace_resource_policy", namespace_resource_policy)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if number_of_nodes is not None:
            pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        if owner_account is not None:
            pulumi.set(__self__, "owner_account", owner_account)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if preferred_maintenance_window is not None:
            pulumi.set(__self__, "preferred_maintenance_window", preferred_maintenance_window)
        if publicly_accessible is not None:
            pulumi.set(__self__, "publicly_accessible", publicly_accessible)
        if resource_action is not None:
            pulumi.set(__self__, "resource_action", resource_action)
        if revision_target is not None:
            pulumi.set(__self__, "revision_target", revision_target)
        if rotate_encryption_key is not None:
            pulumi.set(__self__, "rotate_encryption_key", rotate_encryption_key)
        if snapshot_cluster_identifier is not None:
            pulumi.set(__self__, "snapshot_cluster_identifier", snapshot_cluster_identifier)
        if snapshot_copy_grant_name is not None:
            pulumi.set(__self__, "snapshot_copy_grant_name", snapshot_copy_grant_name)
        if snapshot_copy_manual is not None:
            pulumi.set(__self__, "snapshot_copy_manual", snapshot_copy_manual)
        if snapshot_copy_retention_period is not None:
            pulumi.set(__self__, "snapshot_copy_retention_period", snapshot_copy_retention_period)
        if snapshot_identifier is not None:
            pulumi.set(__self__, "snapshot_identifier", snapshot_identifier)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_security_group_ids is not None:
            pulumi.set(__self__, "vpc_security_group_ids", vpc_security_group_ids)

    @property
    @pulumi.getter(name="allowVersionUpgrade")
    def allow_version_upgrade(self) -> Optional[bool]:
        """
        Major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. Default value is True
        """
        return pulumi.get(self, "allow_version_upgrade")

    @property
    @pulumi.getter(name="aquaConfigurationStatus")
    def aqua_configuration_status(self) -> Optional[str]:
        """
        The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) after the cluster is restored. Possible values include the following.enabled - Use AQUA if it is available for the current Region and Amazon Redshift node type.disabled - Don't use AQUA.auto - Amazon Redshift determines whether to use AQUA.
        """
        return pulumi.get(self, "aqua_configuration_status")

    @property
    @pulumi.getter(name="automatedSnapshotRetentionPeriod")
    def automated_snapshot_retention_period(self) -> Optional[int]:
        """
        The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Default value is 1
        """
        return pulumi.get(self, "automated_snapshot_retention_period")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="availabilityZoneRelocation")
    def availability_zone_relocation(self) -> Optional[bool]:
        """
        The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete.
        """
        return pulumi.get(self, "availability_zone_relocation")

    @property
    @pulumi.getter(name="availabilityZoneRelocationStatus")
    def availability_zone_relocation_status(self) -> Optional[str]:
        """
        The availability zone relocation status of the cluster
        """
        return pulumi.get(self, "availability_zone_relocation_status")

    @property
    @pulumi.getter
    def classic(self) -> Optional[bool]:
        """
        A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to false , the resize type is elastic.
        """
        return pulumi.get(self, "classic")

    @property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> Optional[str]:
        """
        A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. All alphabetical characters must be lower case, no hypens at the end, no two consecutive hyphens. Cluster name should be unique for all clusters within an AWS account
        """
        return pulumi.get(self, "cluster_identifier")

    @property
    @pulumi.getter(name="clusterNamespaceArn")
    def cluster_namespace_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the cluster namespace.
        """
        return pulumi.get(self, "cluster_namespace_arn")

    @property
    @pulumi.getter(name="clusterParameterGroupName")
    def cluster_parameter_group_name(self) -> Optional[str]:
        """
        The name of the parameter group to be associated with this cluster.
        """
        return pulumi.get(self, "cluster_parameter_group_name")

    @property
    @pulumi.getter(name="clusterSecurityGroups")
    def cluster_security_groups(self) -> Optional[Sequence[str]]:
        """
        A list of security groups to be associated with this cluster.
        """
        return pulumi.get(self, "cluster_security_groups")

    @property
    @pulumi.getter(name="clusterSubnetGroupName")
    def cluster_subnet_group_name(self) -> Optional[str]:
        """
        The name of a cluster subnet group to be associated with this cluster.
        """
        return pulumi.get(self, "cluster_subnet_group_name")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[str]:
        """
        The type of the cluster. When cluster type is specified as single-node, the NumberOfNodes parameter is not required and if multi-node, the NumberOfNodes parameter is required
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        """
        The version of the Amazon Redshift engine software that you want to deploy on the cluster.The version selected runs on all the nodes in the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[str]:
        """
        The name of the first database to be created when the cluster is created. To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="deferMaintenance")
    def defer_maintenance(self) -> Optional[bool]:
        """
        A boolean indicating whether to enable the deferred maintenance window.
        """
        return pulumi.get(self, "defer_maintenance")

    @property
    @pulumi.getter(name="deferMaintenanceDuration")
    def defer_maintenance_duration(self) -> Optional[int]:
        """
        An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
        """
        return pulumi.get(self, "defer_maintenance_duration")

    @property
    @pulumi.getter(name="deferMaintenanceEndTime")
    def defer_maintenance_end_time(self) -> Optional[str]:
        """
        A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
        """
        return pulumi.get(self, "defer_maintenance_end_time")

    @property
    @pulumi.getter(name="deferMaintenanceIdentifier")
    def defer_maintenance_identifier(self) -> Optional[str]:
        """
        A unique identifier for the deferred maintenance window.
        """
        return pulumi.get(self, "defer_maintenance_identifier")

    @property
    @pulumi.getter(name="deferMaintenanceStartTime")
    def defer_maintenance_start_time(self) -> Optional[str]:
        """
        A timestamp indicating the start time for the deferred maintenance window.
        """
        return pulumi.get(self, "defer_maintenance_start_time")

    @property
    @pulumi.getter(name="destinationRegion")
    def destination_region(self) -> Optional[str]:
        """
        The destination AWS Region that you want to copy snapshots to. Constraints: Must be the name of a valid AWS Region. For more information, see Regions and Endpoints in the Amazon Web Services [https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region] General Reference
        """
        return pulumi.get(self, "destination_region")

    @property
    @pulumi.getter(name="elasticIp")
    def elastic_ip(self) -> Optional[str]:
        """
        The Elastic IP (EIP) address for the cluster.
        """
        return pulumi.get(self, "elastic_ip")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        If true, the data in the cluster is encrypted at rest.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional['outputs.RedshiftClusterEndpointResponse']:
        """
        Property endpoint
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="enhancedVpcRouting")
    def enhanced_vpc_routing(self) -> Optional[bool]:
        """
        An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see Enhanced VPC Routing in the Amazon Redshift Cluster Management Guide.If this option is true , enhanced VPC routing is enabled.Default: false
        """
        return pulumi.get(self, "enhanced_vpc_routing")

    @property
    @pulumi.getter(name="hsmClientCertificateIdentifier")
    def hsm_client_certificate_identifier(self) -> Optional[str]:
        """
        Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM
        """
        return pulumi.get(self, "hsm_client_certificate_identifier")

    @property
    @pulumi.getter(name="hsmConfigurationIdentifier")
    def hsm_configuration_identifier(self) -> Optional[str]:
        """
        Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
        """
        return pulumi.get(self, "hsm_configuration_identifier")

    @property
    @pulumi.getter(name="iamRoles")
    def iam_roles(self) -> Optional[Sequence[str]]:
        """
        A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 50 IAM roles in a single request
        """
        return pulumi.get(self, "iam_roles")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="loggingProperties")
    def logging_properties(self) -> Optional['outputs.LoggingPropertiesResponse']:
        """
        Property loggingProperties
        """
        return pulumi.get(self, "logging_properties")

    @property
    @pulumi.getter(name="maintenanceTrackName")
    def maintenance_track_name(self) -> Optional[str]:
        """
        The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the PendingModifiedValues for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
        """
        return pulumi.get(self, "maintenance_track_name")

    @property
    @pulumi.getter(name="manageMasterPassword")
    def manage_master_password(self) -> Optional[bool]:
        """
        A boolean indicating if the redshift cluster's admin user credentials is managed by Redshift or not. You can't use MasterUserPassword if ManageMasterPassword is true. If ManageMasterPassword is false or not set, Amazon Redshift uses MasterUserPassword for the admin user account's password.
        """
        return pulumi.get(self, "manage_master_password")

    @property
    @pulumi.getter(name="manualSnapshotRetentionPeriod")
    def manual_snapshot_retention_period(self) -> Optional[int]:
        """
        The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely.The value must be either -1 or an integer between 1 and 3,653.
        """
        return pulumi.get(self, "manual_snapshot_retention_period")

    @property
    @pulumi.getter(name="masterPasswordSecretArn")
    def master_password_secret_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) for the cluster's admin user credentials secret.
        """
        return pulumi.get(self, "master_password_secret_arn")

    @property
    @pulumi.getter(name="masterPasswordSecretKmsKeyId")
    def master_password_secret_kms_key_id(self) -> Optional[str]:
        """
        The ID of the Key Management Service (KMS) key used to encrypt and store the cluster's admin user credentials secret.
        """
        return pulumi.get(self, "master_password_secret_kms_key_id")

    @property
    @pulumi.getter(name="masterUserPassword")
    def master_user_password(self) -> Optional[str]:
        """
        The password associated with the master user account for the cluster that is being created. You can't use MasterUserPassword if ManageMasterPassword is true. Password must be between 8 and 64 characters in length, should have at least one uppercase letter.Must contain at least one lowercase letter.Must contain one number.Can be any printable ASCII character.
        """
        return pulumi.get(self, "master_user_password")

    @property
    @pulumi.getter(name="masterUsername")
    def master_username(self) -> Optional[str]:
        """
        The user name associated with the master user account for the cluster that is being created. The user name can't be PUBLIC and first character must be a letter.
        """
        return pulumi.get(self, "master_username")

    @property
    @pulumi.getter(name="multiAZ")
    def multi_az(self) -> Optional[bool]:
        """
        A boolean indicating if the redshift cluster is multi-az or not. If you don't provide this parameter or set the value to false, the redshift cluster will be single-az.
        """
        return pulumi.get(self, "multi_az")

    @property
    @pulumi.getter(name="namespaceResourcePolicy")
    def namespace_resource_policy(self) -> Optional[Any]:
        """
        The namespace resource policy document that will be attached to a Redshift cluster.
        """
        return pulumi.get(self, "namespace_resource_policy")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        The node type to be provisioned for the cluster.Valid Values: ds2.xlarge | ds2.8xlarge | dc1.large | dc1.8xlarge | dc2.large | dc2.8xlarge | ra3.4xlarge | ra3.16xlarge
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> Optional[int]:
        """
        The number of compute nodes in the cluster. This parameter is required when the ClusterType parameter is specified as multi-node.
        """
        return pulumi.get(self, "number_of_nodes")

    @property
    @pulumi.getter(name="ownerAccount")
    def owner_account(self) -> Optional[str]:
        """
        Property ownerAccount
        """
        return pulumi.get(self, "owner_account")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port number on which the cluster accepts incoming connections. The cluster is accessible only via the JDBC and ODBC connection strings
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="preferredMaintenanceWindow")
    def preferred_maintenance_window(self) -> Optional[str]:
        """
        The weekly time range (in UTC) during which automated cluster maintenance can occur.
        """
        return pulumi.get(self, "preferred_maintenance_window")

    @property
    @pulumi.getter(name="publiclyAccessible")
    def publicly_accessible(self) -> Optional[bool]:
        """
        If true, the cluster can be accessed from a public network.
        """
        return pulumi.get(self, "publicly_accessible")

    @property
    @pulumi.getter(name="resourceAction")
    def resource_action(self) -> Optional[str]:
        """
        The Redshift operation to be performed. Resource Action supports pause-cluster, resume-cluster, failover-primary-compute APIs
        """
        return pulumi.get(self, "resource_action")

    @property
    @pulumi.getter(name="revisionTarget")
    def revision_target(self) -> Optional[str]:
        """
        The identifier of the database revision. You can retrieve this value from the response to the DescribeClusterDbRevisions request.
        """
        return pulumi.get(self, "revision_target")

    @property
    @pulumi.getter(name="rotateEncryptionKey")
    def rotate_encryption_key(self) -> Optional[bool]:
        """
        A boolean indicating if we want to rotate Encryption Keys.
        """
        return pulumi.get(self, "rotate_encryption_key")

    @property
    @pulumi.getter(name="snapshotClusterIdentifier")
    def snapshot_cluster_identifier(self) -> Optional[str]:
        """
        The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
        """
        return pulumi.get(self, "snapshot_cluster_identifier")

    @property
    @pulumi.getter(name="snapshotCopyGrantName")
    def snapshot_copy_grant_name(self) -> Optional[str]:
        """
        The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
        """
        return pulumi.get(self, "snapshot_copy_grant_name")

    @property
    @pulumi.getter(name="snapshotCopyManual")
    def snapshot_copy_manual(self) -> Optional[bool]:
        """
        Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
        """
        return pulumi.get(self, "snapshot_copy_manual")

    @property
    @pulumi.getter(name="snapshotCopyRetentionPeriod")
    def snapshot_copy_retention_period(self) -> Optional[int]:
        """
        The number of days to retain automated snapshots in the destination region after they are copied from the source region.  Default is 7.  Constraints: Must be at least 1 and no more than 35.
        """
        return pulumi.get(self, "snapshot_copy_retention_period")

    @property
    @pulumi.getter(name="snapshotIdentifier")
    def snapshot_identifier(self) -> Optional[str]:
        """
        The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.
        """
        return pulumi.get(self, "snapshot_identifier")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The list of tags for the cluster parameter group.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcSecurityGroupIds")
    def vpc_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.
        """
        return pulumi.get(self, "vpc_security_group_ids")


@pulumi.output_type
class AwsRoute53DomainsDomainSummaryPropertiesResponse(dict):
    """
    Definition of awsRoute53DomainsDomainSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRenew":
            suggest = "auto_renew"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "transferLock":
            suggest = "transfer_lock"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRoute53DomainsDomainSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRoute53DomainsDomainSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRoute53DomainsDomainSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_renew: Optional[bool] = None,
                 domain_name: Optional[str] = None,
                 expiry: Optional[str] = None,
                 transfer_lock: Optional[bool] = None):
        """
        Definition of awsRoute53DomainsDomainSummary
        :param bool auto_renew: <p>Indicates whether the domain is automatically renewed upon expiration.</p>
        :param str domain_name: <p>The name of the domain that the summary information applies to.</p>
        :param str expiry: <p>Expiration date of the domain in Unix time format and Coordinated Universal Time (UTC).</p>
        :param bool transfer_lock: <p>Indicates whether a domain is locked from unauthorized transfer to another party.</p>
        """
        if auto_renew is not None:
            pulumi.set(__self__, "auto_renew", auto_renew)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if expiry is not None:
            pulumi.set(__self__, "expiry", expiry)
        if transfer_lock is not None:
            pulumi.set(__self__, "transfer_lock", transfer_lock)

    @property
    @pulumi.getter(name="autoRenew")
    def auto_renew(self) -> Optional[bool]:
        """
        <p>Indicates whether the domain is automatically renewed upon expiration.</p>
        """
        return pulumi.get(self, "auto_renew")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        <p>The name of the domain that the summary information applies to.</p>
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def expiry(self) -> Optional[str]:
        """
        <p>Expiration date of the domain in Unix time format and Coordinated Universal Time (UTC).</p>
        """
        return pulumi.get(self, "expiry")

    @property
    @pulumi.getter(name="transferLock")
    def transfer_lock(self) -> Optional[bool]:
        """
        <p>Indicates whether a domain is locked from unauthorized transfer to another party.</p>
        """
        return pulumi.get(self, "transfer_lock")


@pulumi.output_type
class AwsRoute53HostedZonePropertiesResponse(dict):
    """
    Definition of awsRoute53HostedZone
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostedZoneConfig":
            suggest = "hosted_zone_config"
        elif key == "hostedZoneTags":
            suggest = "hosted_zone_tags"
        elif key == "nameServers":
            suggest = "name_servers"
        elif key == "queryLoggingConfig":
            suggest = "query_logging_config"
        elif key == "vpCs":
            suggest = "vp_cs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRoute53HostedZonePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRoute53HostedZonePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRoute53HostedZonePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosted_zone_config: Optional['outputs.HostedZoneConfigResponse'] = None,
                 hosted_zone_tags: Optional[Sequence['outputs.HostedZoneTagResponse']] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 name_servers: Optional[Sequence[str]] = None,
                 query_logging_config: Optional['outputs.QueryLoggingConfigResponse'] = None,
                 vp_cs: Optional[Sequence['outputs.VPCResponse']] = None):
        """
        Definition of awsRoute53HostedZone
        :param 'HostedZoneConfigResponse' hosted_zone_config: A complex type that contains an optional comment. If you don't want to specify a comment, omit the ``HostedZoneConfig`` and ``Comment`` elements. A complex type that contains an optional comment about your hosted zone. If you don't want to specify a comment, omit both the ``HostedZoneConfig`` and ``Comment`` elements.
        :param Sequence['HostedZoneTagResponse'] hosted_zone_tags: Adds, edits, or deletes tags for a health check or a hosted zone. For information about using tags for cost allocation, see [Using Cost Allocation Tags](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html) in the *User Guide*.
        :param str id: Property id
        :param str name: The name of the domain. Specify a fully qualified domain name, for example, *www.example.com*. The trailing dot is optional; Amazon Route 53 assumes that the domain name is fully qualified. This means that Route 53 treats *www.example.com* (without a trailing dot) and *www.example.com.* (with a trailing dot) as identical. If you're creating a public hosted zone, this is the name you have registered with your DNS registrar. If your domain name is registered with a registrar other than Route 53, change the name servers for your domain to the set of ``NameServers`` that are returned by the ``Fn::GetAtt`` intrinsic function.
        :param Sequence[str] name_servers: Property nameServers
        :param 'QueryLoggingConfigResponse' query_logging_config: Creates a configuration for DNS query logging. After you create a query logging configuration, Amazon Route 53 begins to publish log data to an Amazon CloudWatch Logs log group. DNS query logs contain information about the queries that Route 53 receives for a specified public hosted zone, such as the following:  +  Route 53 edge location that responded to the DNS query  +  Domain or subdomain that was requested  +  DNS record type, such as A or AAAA  +  DNS response code, such as ``NoError`` or ``ServFail``     + Log Group and Resource Policy Before you create a query logging configuration, perform the following operations. If you create a query logging configuration using the Route 53 console, Route 53 performs these operations automatically. Create a CloudWatch Logs log group, and make note of the ARN, which you specify when you create a query logging configuration. Note the following: You must create the log group in the us-east-1 region. You must use the same to create the log group and the hosted zone that you want to configure query logging for. When you create log groups for query logging, we recommend that you use a consistent prefix, for example: /aws/route53/hosted zone name In the next step, you'll create a resource policy, which controls access to one or more log groups and the associated resources, such as Route 53 hosted zones. There's a limit on the number of resource policies that you can create, so we recommend that you use a consistent prefix so you can use the same resource policy for all the log groups that you create for query logging. Create a CloudWatch Logs resource policy, and give it the permissions that Route 53 needs to create log streams and to send query logs to log streams. For the value of Resource, specify the ARN for the log group that you created in the previous step. To use the same resource policy for all the CloudWatch Logs log groups that you created for query logging configurations, replace the hosted zone name with *, for example: arn:aws:logs:us-east-1:123412341234:log-group:/aws/route53/* To avoid the confused deputy problem, a security issue where an entity without a permission for an action can coerce a more-privileged entity to perform it, you can optionally limit the permissions that a service has to a resource in a resource-based policy by supplying the following values: For aws:SourceArn, supply the hosted zone ARN used in creating the query logging configuration. For example, aws:SourceArn: arn:aws:route53:::hostedzone/hosted zone ID. For aws:SourceAccount, supply the account ID for the account that creates the query logging configuration. For example, aws:SourceAccount:111111111111. For more information, see The confused deputy problem in the IAM User Guide. You can't use the CloudWatch console to create or edit a resource policy. You must use the CloudWatch API, one of the SDKs, or the . + Log Streams and Edge Locations When Route 53 finishes creating the configuration for DNS query logging, it does the following: Creates a log stream for an edge location the first time that the edge location responds to DNS queries for the specified hosted zone. That log stream is used to log all queries that Route 53 responds to for that edge location. Begins to send query logs to the applicable log stream. The name of each log stream is in the following format: hosted zone ID/edge location code The edge location code is a three-letter code and an arbitrarily assigned number, for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) For a list of edge locations, see 'The Route 53 Global Network' on the Route 53 Product Details page. + Queries That Are Logged Query logs contain only the queries that DNS resolvers forward to Route 53. If a DNS resolver has already cached the response to a query (such as the IP address for a load balancer for example.com), the resolver will continue to return the cached response. It doesn't forward another query to Route 53 until the TTL for the corresponding resource record set expires. Depending on how many DNS queries are submitted for a resource record set, and depending on the TTL for that resource record set, query logs might contain information about only one query out of every several thousand queries that are submitted to DNS. For more information about how DNS works, see Routing Internet Traffic to Your Website or Web Application in the Amazon Route 53 Developer Guide. + Log File Format For a list of the values in each query log and the format of each value, see Logging DNS Queries in the Amazon Route 53 Developer Guide. + Pricing For information about charges for query logs, see Amazon CloudWatch Pricing. + How to Stop Logging If you want Route 53 to stop sending query logs to CloudWatch Logs, delete the query logging configuration. For more information, see DeleteQueryLoggingConfig. A complex type that contains information about a configuration for DNS query logging.
        :param Sequence['VPCResponse'] vp_cs: *Private hosted zones:* A complex type that contains information about the VPCs that are associated with the specified hosted zone.  For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
        """
        if hosted_zone_config is not None:
            pulumi.set(__self__, "hosted_zone_config", hosted_zone_config)
        if hosted_zone_tags is not None:
            pulumi.set(__self__, "hosted_zone_tags", hosted_zone_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if name_servers is not None:
            pulumi.set(__self__, "name_servers", name_servers)
        if query_logging_config is not None:
            pulumi.set(__self__, "query_logging_config", query_logging_config)
        if vp_cs is not None:
            pulumi.set(__self__, "vp_cs", vp_cs)

    @property
    @pulumi.getter(name="hostedZoneConfig")
    def hosted_zone_config(self) -> Optional['outputs.HostedZoneConfigResponse']:
        """
        A complex type that contains an optional comment. If you don't want to specify a comment, omit the ``HostedZoneConfig`` and ``Comment`` elements. A complex type that contains an optional comment about your hosted zone. If you don't want to specify a comment, omit both the ``HostedZoneConfig`` and ``Comment`` elements.
        """
        return pulumi.get(self, "hosted_zone_config")

    @property
    @pulumi.getter(name="hostedZoneTags")
    def hosted_zone_tags(self) -> Optional[Sequence['outputs.HostedZoneTagResponse']]:
        """
        Adds, edits, or deletes tags for a health check or a hosted zone. For information about using tags for cost allocation, see [Using Cost Allocation Tags](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html) in the *User Guide*.
        """
        return pulumi.get(self, "hosted_zone_tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the domain. Specify a fully qualified domain name, for example, *www.example.com*. The trailing dot is optional; Amazon Route 53 assumes that the domain name is fully qualified. This means that Route 53 treats *www.example.com* (without a trailing dot) and *www.example.com.* (with a trailing dot) as identical. If you're creating a public hosted zone, this is the name you have registered with your DNS registrar. If your domain name is registered with a registrar other than Route 53, change the name servers for your domain to the set of ``NameServers`` that are returned by the ``Fn::GetAtt`` intrinsic function.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameServers")
    def name_servers(self) -> Optional[Sequence[str]]:
        """
        Property nameServers
        """
        return pulumi.get(self, "name_servers")

    @property
    @pulumi.getter(name="queryLoggingConfig")
    def query_logging_config(self) -> Optional['outputs.QueryLoggingConfigResponse']:
        """
        Creates a configuration for DNS query logging. After you create a query logging configuration, Amazon Route 53 begins to publish log data to an Amazon CloudWatch Logs log group. DNS query logs contain information about the queries that Route 53 receives for a specified public hosted zone, such as the following:  +  Route 53 edge location that responded to the DNS query  +  Domain or subdomain that was requested  +  DNS record type, such as A or AAAA  +  DNS response code, such as ``NoError`` or ``ServFail``     + Log Group and Resource Policy Before you create a query logging configuration, perform the following operations. If you create a query logging configuration using the Route 53 console, Route 53 performs these operations automatically. Create a CloudWatch Logs log group, and make note of the ARN, which you specify when you create a query logging configuration. Note the following: You must create the log group in the us-east-1 region. You must use the same to create the log group and the hosted zone that you want to configure query logging for. When you create log groups for query logging, we recommend that you use a consistent prefix, for example: /aws/route53/hosted zone name In the next step, you'll create a resource policy, which controls access to one or more log groups and the associated resources, such as Route 53 hosted zones. There's a limit on the number of resource policies that you can create, so we recommend that you use a consistent prefix so you can use the same resource policy for all the log groups that you create for query logging. Create a CloudWatch Logs resource policy, and give it the permissions that Route 53 needs to create log streams and to send query logs to log streams. For the value of Resource, specify the ARN for the log group that you created in the previous step. To use the same resource policy for all the CloudWatch Logs log groups that you created for query logging configurations, replace the hosted zone name with *, for example: arn:aws:logs:us-east-1:123412341234:log-group:/aws/route53/* To avoid the confused deputy problem, a security issue where an entity without a permission for an action can coerce a more-privileged entity to perform it, you can optionally limit the permissions that a service has to a resource in a resource-based policy by supplying the following values: For aws:SourceArn, supply the hosted zone ARN used in creating the query logging configuration. For example, aws:SourceArn: arn:aws:route53:::hostedzone/hosted zone ID. For aws:SourceAccount, supply the account ID for the account that creates the query logging configuration. For example, aws:SourceAccount:111111111111. For more information, see The confused deputy problem in the IAM User Guide. You can't use the CloudWatch console to create or edit a resource policy. You must use the CloudWatch API, one of the SDKs, or the . + Log Streams and Edge Locations When Route 53 finishes creating the configuration for DNS query logging, it does the following: Creates a log stream for an edge location the first time that the edge location responds to DNS queries for the specified hosted zone. That log stream is used to log all queries that Route 53 responds to for that edge location. Begins to send query logs to the applicable log stream. The name of each log stream is in the following format: hosted zone ID/edge location code The edge location code is a three-letter code and an arbitrarily assigned number, for example, DFW3. The three-letter code typically corresponds with the International Air Transport Association airport code for an airport near the edge location. (These abbreviations might change in the future.) For a list of edge locations, see 'The Route 53 Global Network' on the Route 53 Product Details page. + Queries That Are Logged Query logs contain only the queries that DNS resolvers forward to Route 53. If a DNS resolver has already cached the response to a query (such as the IP address for a load balancer for example.com), the resolver will continue to return the cached response. It doesn't forward another query to Route 53 until the TTL for the corresponding resource record set expires. Depending on how many DNS queries are submitted for a resource record set, and depending on the TTL for that resource record set, query logs might contain information about only one query out of every several thousand queries that are submitted to DNS. For more information about how DNS works, see Routing Internet Traffic to Your Website or Web Application in the Amazon Route 53 Developer Guide. + Log File Format For a list of the values in each query log and the format of each value, see Logging DNS Queries in the Amazon Route 53 Developer Guide. + Pricing For information about charges for query logs, see Amazon CloudWatch Pricing. + How to Stop Logging If you want Route 53 to stop sending query logs to CloudWatch Logs, delete the query logging configuration. For more information, see DeleteQueryLoggingConfig. A complex type that contains information about a configuration for DNS query logging.
        """
        return pulumi.get(self, "query_logging_config")

    @property
    @pulumi.getter(name="vpCs")
    def vp_cs(self) -> Optional[Sequence['outputs.VPCResponse']]:
        """
        *Private hosted zones:* A complex type that contains information about the VPCs that are associated with the specified hosted zone.  For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
        """
        return pulumi.get(self, "vp_cs")


@pulumi.output_type
class AwsRoute53ResourceRecordSetPropertiesResponse(dict):
    """
    Definition of awsRoute53ResourceRecordSet
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasTarget":
            suggest = "alias_target"
        elif key == "cidrRoutingConfig":
            suggest = "cidr_routing_config"
        elif key == "geoLocation":
            suggest = "geo_location"
        elif key == "geoProximityLocation":
            suggest = "geo_proximity_location"
        elif key == "healthCheckId":
            suggest = "health_check_id"
        elif key == "multiValueAnswer":
            suggest = "multi_value_answer"
        elif key == "resourceRecords":
            suggest = "resource_records"
        elif key == "setIdentifier":
            suggest = "set_identifier"
        elif key == "trafficPolicyInstanceId":
            suggest = "traffic_policy_instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsRoute53ResourceRecordSetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsRoute53ResourceRecordSetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsRoute53ResourceRecordSetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_target: Optional['outputs.AliasTargetResponse'] = None,
                 cidr_routing_config: Optional['outputs.CidrRoutingConfigResponse'] = None,
                 failover: Optional['outputs.ResourceRecordSetFailoverEnumValueResponse'] = None,
                 geo_location: Optional['outputs.GeoLocationResponse'] = None,
                 geo_proximity_location: Optional['outputs.GeoProximityLocationResponse'] = None,
                 health_check_id: Optional[str] = None,
                 multi_value_answer: Optional[bool] = None,
                 name: Optional[str] = None,
                 region: Optional['outputs.ResourceRecordSetRegionEnumValueResponse'] = None,
                 resource_records: Optional[Sequence['outputs.ResourceRecordResponse']] = None,
                 set_identifier: Optional[str] = None,
                 traffic_policy_instance_id: Optional[str] = None,
                 ttl: Optional[float] = None,
                 type: Optional['outputs.RRTypeEnumValueResponse'] = None,
                 weight: Optional[float] = None):
        """
        Definition of awsRoute53ResourceRecordSet
        :param 'AliasTargetResponse' alias_target: <p> <i>Alias resource record sets only:</i> Information about the Amazon Web Services resource, such as a CloudFront distribution or an Amazon S3 bucket, that you want to route traffic to. </p> <p>If you're creating resource records sets for a private hosted zone, note the following:</p> <ul> <li> <p>You can't create an alias resource record set in a private hosted zone to route traffic to a CloudFront distribution.</p> </li> <li> <p>For information about creating failover resource record sets in a private hosted zone, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html'>Configuring Failover in a Private Hosted Zone</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> </li> </ul>
        :param 'CidrRoutingConfigResponse' cidr_routing_config: Property cidrRoutingConfig
        :param 'ResourceRecordSetFailoverEnumValueResponse' failover: <p> <i>Failover resource record sets only:</i> To configure failover, you add the <code>Failover</code> element to two resource record sets. For one resource record set, you specify <code>PRIMARY</code> as the value for <code>Failover</code>; for the other resource record set, you specify <code>SECONDARY</code>. In addition, you include the <code>HealthCheckId</code> element and specify the health check that you want Amazon Route 53 to perform for each resource record set.</p> <p>Except where noted, the following failover behaviors assume that you have included the <code>HealthCheckId</code> element in both resource record sets:</p> <ul> <li> <p>When the primary resource record set is healthy, Route 53 responds to DNS queries with the applicable value from the primary resource record set regardless of the health of the secondary resource record set.</p> </li> <li> <p>When the primary resource record set is unhealthy and the secondary resource record set is healthy, Route 53 responds to DNS queries with the applicable value from the secondary resource record set.</p> </li> <li> <p>When the secondary resource record set is unhealthy, Route 53 responds to DNS queries with the applicable value from the primary resource record set regardless of the health of the primary resource record set.</p> </li> <li> <p>If you omit the <code>HealthCheckId</code> element for the secondary resource record set, and if the primary resource record set is unhealthy, Route 53 always responds to DNS queries with the applicable value from the secondary resource record set. This is true regardless of the health of the associated endpoint.</p> </li> </ul> <p>You can't create non-failover resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements as failover resource record sets.</p> <p>For failover alias resource record sets, you must also include the <code>EvaluateTargetHealth</code> element and set the value to true.</p> <p>For more information about configuring failover for Route 53, see the following topics in the <i>Amazon Route 53 Developer Guide</i>: </p> <ul> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html'>Route 53 Health Checks and DNS Failover</a> </p> </li> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html'>Configuring Failover in a Private Hosted Zone</a> </p> </li> </ul>
        :param 'GeoLocationResponse' geo_location: <p> <i>Geolocation resource record sets only:</i> A complex type that lets you control how Amazon Route 53 responds to DNS queries based on the geographic origin of the query. For example, if you want all queries from Africa to be routed to a web server with an IP address of <code>192.0.2.111</code>, create a resource record set with a <code>Type</code> of <code>A</code> and a <code>ContinentCode</code> of <code>AF</code>.</p> <p>If you create separate resource record sets for overlapping geographic regions (for example, one resource record set for a continent and one for a country on the same continent), priority goes to the smallest geographic region. This allows you to route most queries for a continent to one resource and to route queries for a country on that continent to a different resource.</p> <p>You can't create two geolocation resource record sets that specify the same geographic location.</p> <p>The value <code>*</code> in the <code>CountryCode</code> element matches all geographic locations that aren't specified in other geolocation resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements.</p> <important> <p>Geolocation works by mapping IP addresses to locations. However, some IP addresses aren't mapped to geographic locations, so even if you create geolocation resource record sets that cover all seven continents, Route 53 will receive some DNS queries from locations that it can't identify. We recommend that you create a resource record set for which the value of <code>CountryCode</code> is <code>*</code>. Two groups of queries are routed to the resource that you specify in this record: queries that come from locations for which you haven't created geolocation resource record sets and queries from IP addresses that aren't mapped to a location. If you don't create a <code>*</code> resource record set, Route 53 returns a 'no answer' response for queries from those locations.</p> </important> <p>You can't create non-geolocation resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements as geolocation resource record sets.</p>
        :param 'GeoProximityLocationResponse' geo_proximity_location: <p> <i> GeoproximityLocation resource record sets only:</i> A complex type that lets you control how Route53 responds to DNS queries based on the geographic origin of the query and your resources. </p>
        :param str health_check_id: <p>If you want Amazon Route 53 to return this resource record set in response to a DNS query only when the status of a health check is healthy, include the <code>HealthCheckId</code> element and specify the ID of the applicable health check.</p> <p>Route 53 determines whether a resource record set is healthy based on one of the following:</p> <ul> <li> <p>By periodically sending a request to the endpoint that is specified in the health check</p> </li> <li> <p>By aggregating the status of a specified group of health checks (calculated health checks)</p> </li> <li> <p>By determining the current state of a CloudWatch alarm (CloudWatch metric health checks)</p> </li> </ul> <important> <p>Route 53 doesn't check the health of the endpoint that is specified in the resource record set, for example, the endpoint specified by the IP address in the <code>Value</code> element. When you add a <code>HealthCheckId</code> element to a resource record set, Route 53 checks the health of the endpoint that you specified in the health check. </p> </important> <p>For more information, see the following topics in the <i>Amazon Route 53 Developer Guide</i>:</p> <ul> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html'>How Amazon Route 53 Determines Whether an Endpoint Is Healthy</a> </p> </li> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html'>Route 53 Health Checks and DNS Failover</a> </p> </li> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html'>Configuring Failover in a Private Hosted Zone</a> </p> </li> </ul> <p> <b>When to Specify HealthCheckId</b> </p> <p>Specifying a value for <code>HealthCheckId</code> is useful only when Route 53 is choosing between two or more resource record sets to respond to a DNS query, and you want Route 53 to base the choice in part on the status of a health check. Configuring health checks makes sense only in the following configurations:</p> <ul> <li> <p> <b>Non-alias resource record sets</b>: You're checking the health of a group of non-alias resource record sets that have the same routing policy, name, and type (such as multiple weighted records named www.example.com with a type of A) and you specify health check IDs for all the resource record sets. </p> <p>If the health check status for a resource record set is healthy, Route 53 includes the record among the records that it responds to DNS queries with.</p> <p>If the health check status for a resource record set is unhealthy, Route 53 stops responding to DNS queries using the value for that resource record set.</p> <p>If the health check status for all resource record sets in the group is unhealthy, Route 53 considers all resource record sets in the group healthy and responds to DNS queries accordingly. </p> </li> <li> <p> <b>Alias resource record sets</b>: You specify the following settings:</p> <ul> <li> <p>You set <code>EvaluateTargetHealth</code> to true for an alias resource record set in a group of resource record sets that have the same routing policy, name, and type (such as multiple weighted records named www.example.com with a type of A). </p> </li> <li> <p>You configure the alias resource record set to route traffic to a non-alias resource record set in the same hosted zone.</p> </li> <li> <p>You specify a health check ID for the non-alias resource record set. </p> </li> </ul> <p>If the health check status is healthy, Route 53 considers the alias resource record set to be healthy and includes the alias record among the records that it responds to DNS queries with.</p> <p>If the health check status is unhealthy, Route 53 stops responding to DNS queries using the alias resource record set.</p> <note> <p>The alias resource record set can also route traffic to a <i>group</i> of non-alias resource record sets that have the same routing policy, name, and type. In that configuration, associate health checks with all of the resource record sets in the group of non-alias resource record sets.</p> </note> </li> </ul> <p> <b>Geolocation Routing</b> </p> <p>For geolocation resource record sets, if an endpoint is unhealthy, Route 53 looks for a resource record set for the larger, associated geographic region. For example, suppose you have resource record sets for a state in the United States, for the entire United States, for North America, and a resource record set that has <code>*</code> for <code>CountryCode</code> is <code>*</code>, which applies to all locations. If the endpoint for the state resource record set is unhealthy, Route 53 checks for healthy resource record sets in the following order until it finds a resource record set for which the endpoint is healthy:</p> <ul> <li> <p>The United States</p> </li> <li> <p>North America</p> </li> <li> <p>The default resource record set</p> </li> </ul> <p> <b>Specifying the Health Check Endpoint by Domain Name</b> </p> <p>If your health checks specify the endpoint only by domain name, we recommend that you create a separate health check for each endpoint. For example, create a health check for each <code>HTTP</code> server that is serving content for <code>www.example.com</code>. For the value of <code>FullyQualifiedDomainName</code>, specify the domain name of the server (such as <code>us-east-2-www.example.com</code>), not the name of the resource record sets (<code>www.example.com</code>).</p> <important> <p>Health check results will be unpredictable if you do the following:</p> <ul> <li> <p>Create a health check that has the same value for <code>FullyQualifiedDomainName</code> as the name of a resource record set.</p> </li> <li> <p>Associate that health check with the resource record set.</p> </li> </ul> </important>
        :param bool multi_value_answer: <p> <i>Multivalue answer resource record sets only</i>: To route traffic approximately randomly to multiple resources, such as web servers, create one multivalue answer record for each resource and specify <code>true</code> for <code>MultiValueAnswer</code>. Note the following:</p> <ul> <li> <p>If you associate a health check with a multivalue answer resource record set, Amazon Route 53 responds to DNS queries with the corresponding IP address only when the health check is healthy.</p> </li> <li> <p>If you don't associate a health check with a multivalue answer record, Route 53 always considers the record to be healthy.</p> </li> <li> <p>Route 53 responds to DNS queries with up to eight healthy records; if you have eight or fewer healthy records, Route 53 responds to all DNS queries with all the healthy records.</p> </li> <li> <p>If you have more than eight healthy records, Route 53 responds to different DNS resolvers with different combinations of healthy records.</p> </li> <li> <p>When all records are unhealthy, Route 53 responds to DNS queries with up to eight unhealthy records.</p> </li> <li> <p>If a resource becomes unavailable after a resolver caches a response, client software typically tries another of the IP addresses in the response.</p> </li> </ul> <p>You can't create multivalue answer alias records.</p>
        :param str name: <p>For <code>ChangeResourceRecordSets</code> requests, the name of the record that you want to create, update, or delete. For <code>ListResourceRecordSets</code> responses, the name of a record in the specified hosted zone.</p> <p> <b>ChangeResourceRecordSets Only</b> </p> <p>Enter a fully qualified domain name, for example, <code>www.example.com</code>. You can optionally include a trailing dot. If you omit the trailing dot, Amazon Route 53 assumes that the domain name that you specify is fully qualified. This means that Route 53 treats <code>www.example.com</code> (without a trailing dot) and <code>www.example.com.</code> (with a trailing dot) as identical.</p> <p>For information about how to specify characters other than <code>a-z</code>, <code>0-9</code>, and <code>-</code> (hyphen) and how to specify internationalized domain names, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html'>DNS Domain Name Format</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>You can use the asterisk (*) wildcard to replace the leftmost label in a domain name, for example, <code>*.example.com</code>. Note the following:</p> <ul> <li> <p>The * must replace the entire label. For example, you can't specify <code>*prod.example.com</code> or <code>prod*.example.com</code>.</p> </li> <li> <p>The * can't replace any of the middle labels, for example, marketing.*.example.com.</p> </li> <li> <p>If you include * in any position other than the leftmost label in a domain name, DNS treats it as an * character (ASCII 42), not as a wildcard.</p> <important> <p>You can't use the * wildcard for resource records sets that have a type of NS.</p> </important> </li> </ul>
        :param 'ResourceRecordSetRegionEnumValueResponse' region: <p> <i>Latency-based resource record sets only:</i> The Amazon EC2 Region where you created the resource that this resource record set refers to. The resource typically is an Amazon Web Services resource, such as an EC2 instance or an ELB load balancer, and is referred to by an IP address or a DNS domain name, depending on the record type.</p> <p>When Amazon Route 53 receives a DNS query for a domain name and type for which you have created latency resource record sets, Route 53 selects the latency resource record set that has the lowest latency between the end user and the associated Amazon EC2 Region. Route 53 then returns the value that is associated with the selected resource record set.</p> <p>Note the following:</p> <ul> <li> <p>You can only specify one <code>ResourceRecord</code> per latency resource record set.</p> </li> <li> <p>You can only create one latency resource record set for each Amazon EC2 Region.</p> </li> <li> <p>You aren't required to create latency resource record sets for all Amazon EC2 Regions. Route 53 will choose the region with the best latency from among the regions that you create latency resource record sets for.</p> </li> <li> <p>You can't create non-latency resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements as latency resource record sets.</p> </li> </ul>
        :param Sequence['ResourceRecordResponse'] resource_records: <p>Information about the resource records to act upon.</p> <note> <p>If you're creating an alias resource record set, omit <code>ResourceRecords</code>.</p> </note>
        :param str set_identifier: <p> <i>Resource record sets that have a routing policy other than simple:</i> An identifier that differentiates among multiple resource record sets that have the same combination of name and type, such as multiple weighted resource record sets named acme.example.com that have a type of A. In a group of resource record sets that have the same name and type, the value of <code>SetIdentifier</code> must be unique for each resource record set. </p> <p>For information about routing policies, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html'>Choosing a Routing Policy</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
        :param str traffic_policy_instance_id: <p>When you create a traffic policy instance, Amazon Route 53 automatically creates a resource record set. <code>TrafficPolicyInstanceId</code> is the ID of the traffic policy instance that Route 53 created this resource record set for.</p> <important> <p>To delete the resource record set that is associated with a traffic policy instance, use <code>DeleteTrafficPolicyInstance</code>. Route 53 will delete the resource record set automatically. If you delete the resource record set by using <code>ChangeResourceRecordSets</code>, Route 53 doesn't automatically delete the traffic policy instance, and you'll continue to be charged for it even though it's no longer in use. </p> </important>
        :param float ttl: <p>The resource record cache time to live (TTL), in seconds. Note the following:</p> <ul> <li> <p>If you're creating or updating an alias resource record set, omit <code>TTL</code>. Amazon Route 53 uses the value of <code>TTL</code> for the alias target. </p> </li> <li> <p>If you're associating this resource record set with a health check (if you're adding a <code>HealthCheckId</code> element), we recommend that you specify a <code>TTL</code> of 60 seconds or less so clients respond quickly to changes in health status.</p> </li> <li> <p>All of the resource record sets in a group of weighted resource record sets must have the same value for <code>TTL</code>.</p> </li> <li> <p>If a group of weighted resource record sets includes one or more weighted alias resource record sets for which the alias target is an ELB load balancer, we recommend that you specify a <code>TTL</code> of 60 seconds for all of the non-alias weighted resource record sets that have the same name and type. Values other than 60 seconds (the TTL for load balancers) will change the effect of the values that you specify for <code>Weight</code>.</p> </li> </ul>
        :param 'RRTypeEnumValueResponse' type: <p>The DNS record type. For information about different record types and how data is encoded for them, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/ResourceRecordTypes.html'>Supported DNS Resource Record Types</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>Valid values for basic resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>DS</code> |<code>MX</code> | <code>NAPTR</code> | <code>NS</code> | <code>PTR</code> | <code>SOA</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p> <p>Values for weighted, latency, geolocation, and failover resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code>. When creating a group of weighted, latency, geolocation, or failover resource record sets, specify the same value for all of the resource record sets in the group.</p> <p>Valid values for multivalue answer resource record sets: <code>A</code> | <code>AAAA</code> | <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p> <note> <p>SPF records were formerly used to verify the identity of the sender of email messages. However, we no longer recommend that you create resource record sets for which the value of <code>Type</code> is <code>SPF</code>. RFC 7208, <i>Sender Policy Framework (SPF) for Authorizing Use of Domains in Email, Version 1</i>, has been updated to say, '...[I]ts existence and mechanism defined in [RFC4408] have led to some interoperability issues. Accordingly, its use is no longer appropriate for SPF version 1; implementations are not to use it.' In RFC 7208, see section 14.1, <a href='http://tools.ietf.org/html/rfc7208#section-14.1'>The SPF DNS Record Type</a>.</p> </note> <p>Values for alias resource record sets:</p> <ul> <li> <p> <b>Amazon API Gateway custom regional APIs and edge-optimized APIs:</b> <code>A</code> </p> </li> <li> <p> <b>CloudFront distributions:</b> <code>A</code> </p> <p>If IPv6 is enabled for the distribution, create two resource record sets to route traffic to your distribution, one with a value of <code>A</code> and one with a value of <code>AAAA</code>. </p> </li> <li> <p> <b>Amazon API Gateway environment that has a regionalized subdomain</b>: <code>A</code> </p> </li> <li> <p> <b>ELB load balancers:</b> <code>A</code> | <code>AAAA</code> </p> </li> <li> <p> <b>Amazon S3 buckets:</b> <code>A</code> </p> </li> <li> <p> <b>Amazon Virtual Private Cloud interface VPC endpoints</b> <code>A</code> </p> </li> <li> <p> <b>Another resource record set in this hosted zone:</b> Specify the type of the resource record set that you're creating the alias for. All values are supported except <code>NS</code> and <code>SOA</code>.</p> <note> <p>If you're creating an alias record that has the same name as the hosted zone (known as the zone apex), you can't route traffic to a record for which the value of <code>Type</code> is <code>CNAME</code>. This is because the alias record must have the same type as the record you're routing traffic to, and creating a CNAME record for the zone apex isn't supported even for an alias record.</p> </note> </li> </ul>
        :param float weight: <p> <i>Weighted resource record sets only:</i> Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set. Route 53 calculates the sum of the weights for the resource record sets that have the same combination of DNS name and type. Route 53 then responds to queries based on the ratio of a resource's weight to the total. Note the following:</p> <ul> <li> <p>You must specify a value for the <code>Weight</code> element for every weighted resource record set.</p> </li> <li> <p>You can only specify one <code>ResourceRecord</code> per weighted resource record set.</p> </li> <li> <p>You can't create latency, failover, or geolocation resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements as weighted resource record sets.</p> </li> <li> <p>You can create a maximum of 100 weighted resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements.</p> </li> <li> <p>For weighted (but not weighted alias) resource record sets, if you set <code>Weight</code> to <code>0</code> for a resource record set, Route 53 never responds to queries with the applicable value for that resource record set. However, if you set <code>Weight</code> to <code>0</code> for all resource record sets that have the same combination of DNS name and type, traffic is routed to all resources with equal probability.</p> <p>The effect of setting <code>Weight</code> to <code>0</code> is different when you associate health checks with weighted resource record sets. For more information, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html'>Options for Configuring Route 53 Active-Active and Active-Passive Failover</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> </li> </ul>
        """
        if alias_target is not None:
            pulumi.set(__self__, "alias_target", alias_target)
        if cidr_routing_config is not None:
            pulumi.set(__self__, "cidr_routing_config", cidr_routing_config)
        if failover is not None:
            pulumi.set(__self__, "failover", failover)
        if geo_location is not None:
            pulumi.set(__self__, "geo_location", geo_location)
        if geo_proximity_location is not None:
            pulumi.set(__self__, "geo_proximity_location", geo_proximity_location)
        if health_check_id is not None:
            pulumi.set(__self__, "health_check_id", health_check_id)
        if multi_value_answer is not None:
            pulumi.set(__self__, "multi_value_answer", multi_value_answer)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_records is not None:
            pulumi.set(__self__, "resource_records", resource_records)
        if set_identifier is not None:
            pulumi.set(__self__, "set_identifier", set_identifier)
        if traffic_policy_instance_id is not None:
            pulumi.set(__self__, "traffic_policy_instance_id", traffic_policy_instance_id)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="aliasTarget")
    def alias_target(self) -> Optional['outputs.AliasTargetResponse']:
        """
        <p> <i>Alias resource record sets only:</i> Information about the Amazon Web Services resource, such as a CloudFront distribution or an Amazon S3 bucket, that you want to route traffic to. </p> <p>If you're creating resource records sets for a private hosted zone, note the following:</p> <ul> <li> <p>You can't create an alias resource record set in a private hosted zone to route traffic to a CloudFront distribution.</p> </li> <li> <p>For information about creating failover resource record sets in a private hosted zone, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html'>Configuring Failover in a Private Hosted Zone</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> </li> </ul>
        """
        return pulumi.get(self, "alias_target")

    @property
    @pulumi.getter(name="cidrRoutingConfig")
    def cidr_routing_config(self) -> Optional['outputs.CidrRoutingConfigResponse']:
        """
        Property cidrRoutingConfig
        """
        return pulumi.get(self, "cidr_routing_config")

    @property
    @pulumi.getter
    def failover(self) -> Optional['outputs.ResourceRecordSetFailoverEnumValueResponse']:
        """
        <p> <i>Failover resource record sets only:</i> To configure failover, you add the <code>Failover</code> element to two resource record sets. For one resource record set, you specify <code>PRIMARY</code> as the value for <code>Failover</code>; for the other resource record set, you specify <code>SECONDARY</code>. In addition, you include the <code>HealthCheckId</code> element and specify the health check that you want Amazon Route 53 to perform for each resource record set.</p> <p>Except where noted, the following failover behaviors assume that you have included the <code>HealthCheckId</code> element in both resource record sets:</p> <ul> <li> <p>When the primary resource record set is healthy, Route 53 responds to DNS queries with the applicable value from the primary resource record set regardless of the health of the secondary resource record set.</p> </li> <li> <p>When the primary resource record set is unhealthy and the secondary resource record set is healthy, Route 53 responds to DNS queries with the applicable value from the secondary resource record set.</p> </li> <li> <p>When the secondary resource record set is unhealthy, Route 53 responds to DNS queries with the applicable value from the primary resource record set regardless of the health of the primary resource record set.</p> </li> <li> <p>If you omit the <code>HealthCheckId</code> element for the secondary resource record set, and if the primary resource record set is unhealthy, Route 53 always responds to DNS queries with the applicable value from the secondary resource record set. This is true regardless of the health of the associated endpoint.</p> </li> </ul> <p>You can't create non-failover resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements as failover resource record sets.</p> <p>For failover alias resource record sets, you must also include the <code>EvaluateTargetHealth</code> element and set the value to true.</p> <p>For more information about configuring failover for Route 53, see the following topics in the <i>Amazon Route 53 Developer Guide</i>: </p> <ul> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html'>Route 53 Health Checks and DNS Failover</a> </p> </li> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html'>Configuring Failover in a Private Hosted Zone</a> </p> </li> </ul>
        """
        return pulumi.get(self, "failover")

    @property
    @pulumi.getter(name="geoLocation")
    def geo_location(self) -> Optional['outputs.GeoLocationResponse']:
        """
        <p> <i>Geolocation resource record sets only:</i> A complex type that lets you control how Amazon Route 53 responds to DNS queries based on the geographic origin of the query. For example, if you want all queries from Africa to be routed to a web server with an IP address of <code>192.0.2.111</code>, create a resource record set with a <code>Type</code> of <code>A</code> and a <code>ContinentCode</code> of <code>AF</code>.</p> <p>If you create separate resource record sets for overlapping geographic regions (for example, one resource record set for a continent and one for a country on the same continent), priority goes to the smallest geographic region. This allows you to route most queries for a continent to one resource and to route queries for a country on that continent to a different resource.</p> <p>You can't create two geolocation resource record sets that specify the same geographic location.</p> <p>The value <code>*</code> in the <code>CountryCode</code> element matches all geographic locations that aren't specified in other geolocation resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements.</p> <important> <p>Geolocation works by mapping IP addresses to locations. However, some IP addresses aren't mapped to geographic locations, so even if you create geolocation resource record sets that cover all seven continents, Route 53 will receive some DNS queries from locations that it can't identify. We recommend that you create a resource record set for which the value of <code>CountryCode</code> is <code>*</code>. Two groups of queries are routed to the resource that you specify in this record: queries that come from locations for which you haven't created geolocation resource record sets and queries from IP addresses that aren't mapped to a location. If you don't create a <code>*</code> resource record set, Route 53 returns a 'no answer' response for queries from those locations.</p> </important> <p>You can't create non-geolocation resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements as geolocation resource record sets.</p>
        """
        return pulumi.get(self, "geo_location")

    @property
    @pulumi.getter(name="geoProximityLocation")
    def geo_proximity_location(self) -> Optional['outputs.GeoProximityLocationResponse']:
        """
        <p> <i> GeoproximityLocation resource record sets only:</i> A complex type that lets you control how Route53 responds to DNS queries based on the geographic origin of the query and your resources. </p>
        """
        return pulumi.get(self, "geo_proximity_location")

    @property
    @pulumi.getter(name="healthCheckId")
    def health_check_id(self) -> Optional[str]:
        """
        <p>If you want Amazon Route 53 to return this resource record set in response to a DNS query only when the status of a health check is healthy, include the <code>HealthCheckId</code> element and specify the ID of the applicable health check.</p> <p>Route 53 determines whether a resource record set is healthy based on one of the following:</p> <ul> <li> <p>By periodically sending a request to the endpoint that is specified in the health check</p> </li> <li> <p>By aggregating the status of a specified group of health checks (calculated health checks)</p> </li> <li> <p>By determining the current state of a CloudWatch alarm (CloudWatch metric health checks)</p> </li> </ul> <important> <p>Route 53 doesn't check the health of the endpoint that is specified in the resource record set, for example, the endpoint specified by the IP address in the <code>Value</code> element. When you add a <code>HealthCheckId</code> element to a resource record set, Route 53 checks the health of the endpoint that you specified in the health check. </p> </important> <p>For more information, see the following topics in the <i>Amazon Route 53 Developer Guide</i>:</p> <ul> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html'>How Amazon Route 53 Determines Whether an Endpoint Is Healthy</a> </p> </li> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html'>Route 53 Health Checks and DNS Failover</a> </p> </li> <li> <p> <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html'>Configuring Failover in a Private Hosted Zone</a> </p> </li> </ul> <p> <b>When to Specify HealthCheckId</b> </p> <p>Specifying a value for <code>HealthCheckId</code> is useful only when Route 53 is choosing between two or more resource record sets to respond to a DNS query, and you want Route 53 to base the choice in part on the status of a health check. Configuring health checks makes sense only in the following configurations:</p> <ul> <li> <p> <b>Non-alias resource record sets</b>: You're checking the health of a group of non-alias resource record sets that have the same routing policy, name, and type (such as multiple weighted records named www.example.com with a type of A) and you specify health check IDs for all the resource record sets. </p> <p>If the health check status for a resource record set is healthy, Route 53 includes the record among the records that it responds to DNS queries with.</p> <p>If the health check status for a resource record set is unhealthy, Route 53 stops responding to DNS queries using the value for that resource record set.</p> <p>If the health check status for all resource record sets in the group is unhealthy, Route 53 considers all resource record sets in the group healthy and responds to DNS queries accordingly. </p> </li> <li> <p> <b>Alias resource record sets</b>: You specify the following settings:</p> <ul> <li> <p>You set <code>EvaluateTargetHealth</code> to true for an alias resource record set in a group of resource record sets that have the same routing policy, name, and type (such as multiple weighted records named www.example.com with a type of A). </p> </li> <li> <p>You configure the alias resource record set to route traffic to a non-alias resource record set in the same hosted zone.</p> </li> <li> <p>You specify a health check ID for the non-alias resource record set. </p> </li> </ul> <p>If the health check status is healthy, Route 53 considers the alias resource record set to be healthy and includes the alias record among the records that it responds to DNS queries with.</p> <p>If the health check status is unhealthy, Route 53 stops responding to DNS queries using the alias resource record set.</p> <note> <p>The alias resource record set can also route traffic to a <i>group</i> of non-alias resource record sets that have the same routing policy, name, and type. In that configuration, associate health checks with all of the resource record sets in the group of non-alias resource record sets.</p> </note> </li> </ul> <p> <b>Geolocation Routing</b> </p> <p>For geolocation resource record sets, if an endpoint is unhealthy, Route 53 looks for a resource record set for the larger, associated geographic region. For example, suppose you have resource record sets for a state in the United States, for the entire United States, for North America, and a resource record set that has <code>*</code> for <code>CountryCode</code> is <code>*</code>, which applies to all locations. If the endpoint for the state resource record set is unhealthy, Route 53 checks for healthy resource record sets in the following order until it finds a resource record set for which the endpoint is healthy:</p> <ul> <li> <p>The United States</p> </li> <li> <p>North America</p> </li> <li> <p>The default resource record set</p> </li> </ul> <p> <b>Specifying the Health Check Endpoint by Domain Name</b> </p> <p>If your health checks specify the endpoint only by domain name, we recommend that you create a separate health check for each endpoint. For example, create a health check for each <code>HTTP</code> server that is serving content for <code>www.example.com</code>. For the value of <code>FullyQualifiedDomainName</code>, specify the domain name of the server (such as <code>us-east-2-www.example.com</code>), not the name of the resource record sets (<code>www.example.com</code>).</p> <important> <p>Health check results will be unpredictable if you do the following:</p> <ul> <li> <p>Create a health check that has the same value for <code>FullyQualifiedDomainName</code> as the name of a resource record set.</p> </li> <li> <p>Associate that health check with the resource record set.</p> </li> </ul> </important>
        """
        return pulumi.get(self, "health_check_id")

    @property
    @pulumi.getter(name="multiValueAnswer")
    def multi_value_answer(self) -> Optional[bool]:
        """
        <p> <i>Multivalue answer resource record sets only</i>: To route traffic approximately randomly to multiple resources, such as web servers, create one multivalue answer record for each resource and specify <code>true</code> for <code>MultiValueAnswer</code>. Note the following:</p> <ul> <li> <p>If you associate a health check with a multivalue answer resource record set, Amazon Route 53 responds to DNS queries with the corresponding IP address only when the health check is healthy.</p> </li> <li> <p>If you don't associate a health check with a multivalue answer record, Route 53 always considers the record to be healthy.</p> </li> <li> <p>Route 53 responds to DNS queries with up to eight healthy records; if you have eight or fewer healthy records, Route 53 responds to all DNS queries with all the healthy records.</p> </li> <li> <p>If you have more than eight healthy records, Route 53 responds to different DNS resolvers with different combinations of healthy records.</p> </li> <li> <p>When all records are unhealthy, Route 53 responds to DNS queries with up to eight unhealthy records.</p> </li> <li> <p>If a resource becomes unavailable after a resolver caches a response, client software typically tries another of the IP addresses in the response.</p> </li> </ul> <p>You can't create multivalue answer alias records.</p>
        """
        return pulumi.get(self, "multi_value_answer")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>For <code>ChangeResourceRecordSets</code> requests, the name of the record that you want to create, update, or delete. For <code>ListResourceRecordSets</code> responses, the name of a record in the specified hosted zone.</p> <p> <b>ChangeResourceRecordSets Only</b> </p> <p>Enter a fully qualified domain name, for example, <code>www.example.com</code>. You can optionally include a trailing dot. If you omit the trailing dot, Amazon Route 53 assumes that the domain name that you specify is fully qualified. This means that Route 53 treats <code>www.example.com</code> (without a trailing dot) and <code>www.example.com.</code> (with a trailing dot) as identical.</p> <p>For information about how to specify characters other than <code>a-z</code>, <code>0-9</code>, and <code>-</code> (hyphen) and how to specify internationalized domain names, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html'>DNS Domain Name Format</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>You can use the asterisk (*) wildcard to replace the leftmost label in a domain name, for example, <code>*.example.com</code>. Note the following:</p> <ul> <li> <p>The * must replace the entire label. For example, you can't specify <code>*prod.example.com</code> or <code>prod*.example.com</code>.</p> </li> <li> <p>The * can't replace any of the middle labels, for example, marketing.*.example.com.</p> </li> <li> <p>If you include * in any position other than the leftmost label in a domain name, DNS treats it as an * character (ASCII 42), not as a wildcard.</p> <important> <p>You can't use the * wildcard for resource records sets that have a type of NS.</p> </important> </li> </ul>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> Optional['outputs.ResourceRecordSetRegionEnumValueResponse']:
        """
        <p> <i>Latency-based resource record sets only:</i> The Amazon EC2 Region where you created the resource that this resource record set refers to. The resource typically is an Amazon Web Services resource, such as an EC2 instance or an ELB load balancer, and is referred to by an IP address or a DNS domain name, depending on the record type.</p> <p>When Amazon Route 53 receives a DNS query for a domain name and type for which you have created latency resource record sets, Route 53 selects the latency resource record set that has the lowest latency between the end user and the associated Amazon EC2 Region. Route 53 then returns the value that is associated with the selected resource record set.</p> <p>Note the following:</p> <ul> <li> <p>You can only specify one <code>ResourceRecord</code> per latency resource record set.</p> </li> <li> <p>You can only create one latency resource record set for each Amazon EC2 Region.</p> </li> <li> <p>You aren't required to create latency resource record sets for all Amazon EC2 Regions. Route 53 will choose the region with the best latency from among the regions that you create latency resource record sets for.</p> </li> <li> <p>You can't create non-latency resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements as latency resource record sets.</p> </li> </ul>
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceRecords")
    def resource_records(self) -> Optional[Sequence['outputs.ResourceRecordResponse']]:
        """
        <p>Information about the resource records to act upon.</p> <note> <p>If you're creating an alias resource record set, omit <code>ResourceRecords</code>.</p> </note>
        """
        return pulumi.get(self, "resource_records")

    @property
    @pulumi.getter(name="setIdentifier")
    def set_identifier(self) -> Optional[str]:
        """
        <p> <i>Resource record sets that have a routing policy other than simple:</i> An identifier that differentiates among multiple resource record sets that have the same combination of name and type, such as multiple weighted resource record sets named acme.example.com that have a type of A. In a group of resource record sets that have the same name and type, the value of <code>SetIdentifier</code> must be unique for each resource record set. </p> <p>For information about routing policies, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html'>Choosing a Routing Policy</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
        """
        return pulumi.get(self, "set_identifier")

    @property
    @pulumi.getter(name="trafficPolicyInstanceId")
    def traffic_policy_instance_id(self) -> Optional[str]:
        """
        <p>When you create a traffic policy instance, Amazon Route 53 automatically creates a resource record set. <code>TrafficPolicyInstanceId</code> is the ID of the traffic policy instance that Route 53 created this resource record set for.</p> <important> <p>To delete the resource record set that is associated with a traffic policy instance, use <code>DeleteTrafficPolicyInstance</code>. Route 53 will delete the resource record set automatically. If you delete the resource record set by using <code>ChangeResourceRecordSets</code>, Route 53 doesn't automatically delete the traffic policy instance, and you'll continue to be charged for it even though it's no longer in use. </p> </important>
        """
        return pulumi.get(self, "traffic_policy_instance_id")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[float]:
        """
        <p>The resource record cache time to live (TTL), in seconds. Note the following:</p> <ul> <li> <p>If you're creating or updating an alias resource record set, omit <code>TTL</code>. Amazon Route 53 uses the value of <code>TTL</code> for the alias target. </p> </li> <li> <p>If you're associating this resource record set with a health check (if you're adding a <code>HealthCheckId</code> element), we recommend that you specify a <code>TTL</code> of 60 seconds or less so clients respond quickly to changes in health status.</p> </li> <li> <p>All of the resource record sets in a group of weighted resource record sets must have the same value for <code>TTL</code>.</p> </li> <li> <p>If a group of weighted resource record sets includes one or more weighted alias resource record sets for which the alias target is an ELB load balancer, we recommend that you specify a <code>TTL</code> of 60 seconds for all of the non-alias weighted resource record sets that have the same name and type. Values other than 60 seconds (the TTL for load balancers) will change the effect of the values that you specify for <code>Weight</code>.</p> </li> </ul>
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.RRTypeEnumValueResponse']:
        """
        <p>The DNS record type. For information about different record types and how data is encoded for them, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/ResourceRecordTypes.html'>Supported DNS Resource Record Types</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>Valid values for basic resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>DS</code> |<code>MX</code> | <code>NAPTR</code> | <code>NS</code> | <code>PTR</code> | <code>SOA</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p> <p>Values for weighted, latency, geolocation, and failover resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code>. When creating a group of weighted, latency, geolocation, or failover resource record sets, specify the same value for all of the resource record sets in the group.</p> <p>Valid values for multivalue answer resource record sets: <code>A</code> | <code>AAAA</code> | <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p> <note> <p>SPF records were formerly used to verify the identity of the sender of email messages. However, we no longer recommend that you create resource record sets for which the value of <code>Type</code> is <code>SPF</code>. RFC 7208, <i>Sender Policy Framework (SPF) for Authorizing Use of Domains in Email, Version 1</i>, has been updated to say, '...[I]ts existence and mechanism defined in [RFC4408] have led to some interoperability issues. Accordingly, its use is no longer appropriate for SPF version 1; implementations are not to use it.' In RFC 7208, see section 14.1, <a href='http://tools.ietf.org/html/rfc7208#section-14.1'>The SPF DNS Record Type</a>.</p> </note> <p>Values for alias resource record sets:</p> <ul> <li> <p> <b>Amazon API Gateway custom regional APIs and edge-optimized APIs:</b> <code>A</code> </p> </li> <li> <p> <b>CloudFront distributions:</b> <code>A</code> </p> <p>If IPv6 is enabled for the distribution, create two resource record sets to route traffic to your distribution, one with a value of <code>A</code> and one with a value of <code>AAAA</code>. </p> </li> <li> <p> <b>Amazon API Gateway environment that has a regionalized subdomain</b>: <code>A</code> </p> </li> <li> <p> <b>ELB load balancers:</b> <code>A</code> | <code>AAAA</code> </p> </li> <li> <p> <b>Amazon S3 buckets:</b> <code>A</code> </p> </li> <li> <p> <b>Amazon Virtual Private Cloud interface VPC endpoints</b> <code>A</code> </p> </li> <li> <p> <b>Another resource record set in this hosted zone:</b> Specify the type of the resource record set that you're creating the alias for. All values are supported except <code>NS</code> and <code>SOA</code>.</p> <note> <p>If you're creating an alias record that has the same name as the hosted zone (known as the zone apex), you can't route traffic to a record for which the value of <code>Type</code> is <code>CNAME</code>. This is because the alias record must have the same type as the record you're routing traffic to, and creating a CNAME record for the zone apex isn't supported even for an alias record.</p> </note> </li> </ul>
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        <p> <i>Weighted resource record sets only:</i> Among resource record sets that have the same combination of DNS name and type, a value that determines the proportion of DNS queries that Amazon Route 53 responds to using the current resource record set. Route 53 calculates the sum of the weights for the resource record sets that have the same combination of DNS name and type. Route 53 then responds to queries based on the ratio of a resource's weight to the total. Note the following:</p> <ul> <li> <p>You must specify a value for the <code>Weight</code> element for every weighted resource record set.</p> </li> <li> <p>You can only specify one <code>ResourceRecord</code> per weighted resource record set.</p> </li> <li> <p>You can't create latency, failover, or geolocation resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements as weighted resource record sets.</p> </li> <li> <p>You can create a maximum of 100 weighted resource record sets that have the same values for the <code>Name</code> and <code>Type</code> elements.</p> </li> <li> <p>For weighted (but not weighted alias) resource record sets, if you set <code>Weight</code> to <code>0</code> for a resource record set, Route 53 never responds to queries with the applicable value for that resource record set. However, if you set <code>Weight</code> to <code>0</code> for all resource record sets that have the same combination of DNS name and type, traffic is routed to all resources with equal probability.</p> <p>The effect of setting <code>Weight</code> to <code>0</code> is different when you associate health checks with weighted resource record sets. For more information, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html'>Options for Configuring Route 53 Active-Active and Active-Passive Failover</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> </li> </ul>
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AwsS3AccessPointPropertiesResponse(dict):
    """
    Definition of awsS3AccessPoint
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketAccountId":
            suggest = "bucket_account_id"
        elif key == "networkOrigin":
            suggest = "network_origin"
        elif key == "publicAccessBlockConfiguration":
            suggest = "public_access_block_configuration"
        elif key == "vpcConfiguration":
            suggest = "vpc_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsS3AccessPointPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsS3AccessPointPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsS3AccessPointPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias: Optional[str] = None,
                 arn: Optional[str] = None,
                 bucket: Optional[str] = None,
                 bucket_account_id: Optional[str] = None,
                 name: Optional[str] = None,
                 network_origin: Optional[str] = None,
                 policy: Optional[Any] = None,
                 public_access_block_configuration: Optional['outputs.PublicAccessBlockConfigurationResponse'] = None,
                 vpc_configuration: Optional['outputs.VpcConfigurationResponse'] = None):
        """
        Definition of awsS3AccessPoint
        :param str alias: The alias of this Access Point. This alias can be used for compatibility purposes with other AWS services and third-party applications.
        :param str arn: The Amazon Resource Name (ARN) of the specified accesspoint. the Amazon Resource Name (ARN) of the specified accesspoint.
        :param str bucket: The name of the bucket that you want to associate this Access Point with.
        :param str bucket_account_id: The AWS account ID associated with the S3 bucket associated with this access point.
        :param str name: The name you want to assign to this Access Point. If you don't specify a name, AWS CloudFormation generates a unique ID and uses that ID for the access point name.
        :param str network_origin: Indicates whether this Access Point allows access from the public Internet. If VpcConfiguration is specified for this Access Point, then NetworkOrigin is VPC, and the Access Point doesn't allow access from the public Internet. Otherwise, NetworkOrigin is Internet, and the Access Point allows access from the public Internet, subject to the Access Point and bucket access policies.
        :param Any policy: The Access Point Policy you want to apply to this access point.
        :param 'PublicAccessBlockConfigurationResponse' public_access_block_configuration: The PublicAccessBlock configuration that you want to apply to this Access Point. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status 'The Meaning of Public' in the Amazon Simple Storage Service Developer Guide.
        :param 'VpcConfigurationResponse' vpc_configuration: If you include this field, Amazon S3 restricts access to this Access Point to requests from the specified Virtual Private Cloud (VPC). The Virtual Private Cloud (VPC) configuration for a bucket access point.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if bucket_account_id is not None:
            pulumi.set(__self__, "bucket_account_id", bucket_account_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_origin is not None:
            pulumi.set(__self__, "network_origin", network_origin)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if public_access_block_configuration is not None:
            pulumi.set(__self__, "public_access_block_configuration", public_access_block_configuration)
        if vpc_configuration is not None:
            pulumi.set(__self__, "vpc_configuration", vpc_configuration)

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        The alias of this Access Point. This alias can be used for compatibility purposes with other AWS services and third-party applications.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the specified accesspoint. the Amazon Resource Name (ARN) of the specified accesspoint.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The name of the bucket that you want to associate this Access Point with.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="bucketAccountId")
    def bucket_account_id(self) -> Optional[str]:
        """
        The AWS account ID associated with the S3 bucket associated with this access point.
        """
        return pulumi.get(self, "bucket_account_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name you want to assign to this Access Point. If you don't specify a name, AWS CloudFormation generates a unique ID and uses that ID for the access point name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkOrigin")
    def network_origin(self) -> Optional[str]:
        """
        Indicates whether this Access Point allows access from the public Internet. If VpcConfiguration is specified for this Access Point, then NetworkOrigin is VPC, and the Access Point doesn't allow access from the public Internet. Otherwise, NetworkOrigin is Internet, and the Access Point allows access from the public Internet, subject to the Access Point and bucket access policies.
        """
        return pulumi.get(self, "network_origin")

    @property
    @pulumi.getter
    def policy(self) -> Optional[Any]:
        """
        The Access Point Policy you want to apply to this access point.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter(name="publicAccessBlockConfiguration")
    def public_access_block_configuration(self) -> Optional['outputs.PublicAccessBlockConfigurationResponse']:
        """
        The PublicAccessBlock configuration that you want to apply to this Access Point. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status 'The Meaning of Public' in the Amazon Simple Storage Service Developer Guide.
        """
        return pulumi.get(self, "public_access_block_configuration")

    @property
    @pulumi.getter(name="vpcConfiguration")
    def vpc_configuration(self) -> Optional['outputs.VpcConfigurationResponse']:
        """
        If you include this field, Amazon S3 restricts access to this Access Point to requests from the specified Virtual Private Cloud (VPC). The Virtual Private Cloud (VPC) configuration for a bucket access point.
        """
        return pulumi.get(self, "vpc_configuration")


@pulumi.output_type
class AwsS3BucketPolicyPropertiesResponse(dict):
    """
    Definition of awsS3BucketPolicy
    """
    def __init__(__self__, *,
                 policy: Optional[str] = None):
        """
        Definition of awsS3BucketPolicy
        :param str policy: <p>The bucket policy as a JSON document.</p>
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        <p>The bucket policy as a JSON document.</p>
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class AwsS3BucketPropertiesResponse(dict):
    """
    Definition of awsS3Bucket
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accelerateConfiguration":
            suggest = "accelerate_configuration"
        elif key == "accessControl":
            suggest = "access_control"
        elif key == "analyticsConfigurations":
            suggest = "analytics_configurations"
        elif key == "bucketEncryption":
            suggest = "bucket_encryption"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "corsConfiguration":
            suggest = "cors_configuration"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "dualStackDomainName":
            suggest = "dual_stack_domain_name"
        elif key == "intelligentTieringConfigurations":
            suggest = "intelligent_tiering_configurations"
        elif key == "inventoryConfigurations":
            suggest = "inventory_configurations"
        elif key == "lifecycleConfiguration":
            suggest = "lifecycle_configuration"
        elif key == "loggingConfiguration":
            suggest = "logging_configuration"
        elif key == "metricsConfigurations":
            suggest = "metrics_configurations"
        elif key == "notificationConfiguration":
            suggest = "notification_configuration"
        elif key == "objectLockConfiguration":
            suggest = "object_lock_configuration"
        elif key == "objectLockEnabled":
            suggest = "object_lock_enabled"
        elif key == "ownershipControls":
            suggest = "ownership_controls"
        elif key == "publicAccessBlockConfiguration":
            suggest = "public_access_block_configuration"
        elif key == "regionalDomainName":
            suggest = "regional_domain_name"
        elif key == "replicationConfiguration":
            suggest = "replication_configuration"
        elif key == "versioningConfiguration":
            suggest = "versioning_configuration"
        elif key == "websiteConfiguration":
            suggest = "website_configuration"
        elif key == "websiteURL":
            suggest = "website_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsS3BucketPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsS3BucketPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsS3BucketPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerate_configuration: Optional['outputs.AccelerateConfigurationResponse'] = None,
                 access_control: Optional[str] = None,
                 analytics_configurations: Optional[Sequence['outputs.AnalyticsConfigurationResponse']] = None,
                 arn: Optional[str] = None,
                 bucket_encryption: Optional['outputs.BucketEncryptionResponse'] = None,
                 bucket_name: Optional[str] = None,
                 cors_configuration: Optional['outputs.CorsConfigurationResponse'] = None,
                 domain_name: Optional[str] = None,
                 dual_stack_domain_name: Optional[str] = None,
                 intelligent_tiering_configurations: Optional[Sequence['outputs.IntelligentTieringConfigurationResponse']] = None,
                 inventory_configurations: Optional[Sequence['outputs.InventoryConfigurationResponse']] = None,
                 lifecycle_configuration: Optional['outputs.LifecycleConfigurationResponse'] = None,
                 logging_configuration: Optional['outputs.LoggingConfigurationResponse'] = None,
                 metrics_configurations: Optional[Sequence['outputs.MetricsConfigurationResponse']] = None,
                 notification_configuration: Optional['outputs.NotificationConfigurationResponse'] = None,
                 object_lock_configuration: Optional['outputs.ObjectLockConfigurationResponse'] = None,
                 object_lock_enabled: Optional[bool] = None,
                 ownership_controls: Optional['outputs.OwnershipControlsResponse'] = None,
                 public_access_block_configuration: Optional['outputs.PublicAccessBlockConfigurationResponse'] = None,
                 regional_domain_name: Optional[str] = None,
                 replication_configuration: Optional['outputs.ReplicationConfigurationResponse'] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 versioning_configuration: Optional['outputs.VersioningConfigurationResponse'] = None,
                 website_configuration: Optional['outputs.WebsiteConfigurationResponse'] = None,
                 website_url: Optional[str] = None):
        """
        Definition of awsS3Bucket
        :param 'AccelerateConfigurationResponse' accelerate_configuration: Configures the transfer acceleration state for an Amazon S3 bucket. For more information, see [Amazon S3 Transfer Acceleration](https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in the *Amazon S3 User Guide*. Configures the transfer acceleration state for an Amazon S3 bucket. For more information, see [Amazon S3 Transfer Acceleration](https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in the *Amazon S3 User Guide*.
        :param str access_control: This is a legacy property, and it is not recommended for most use cases. A majority of modern use cases in Amazon S3 no longer require the use of ACLs, and we recommend that you keep ACLs disabled. For more information, see [Controlling object ownership](https://docs.aws.amazon.com//AmazonS3/latest/userguide/about-object-ownership.html) in the *Amazon S3 User Guide*.  A canned access control list (ACL) that grants predefined permissions to the bucket. For more information about canned ACLs, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) in the *Amazon S3 User Guide*.  S3 buckets are created with ACLs disabled by default. Therefore, unless you explicitly set the [AWS::S3::OwnershipControls](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ownershipcontrols.html) property to enable ACLs, your resource will fail to deploy with any value other than Private. Use cases requiring ACLs are uncommon.  The majority of access control configurations can be successfully and more easily achieved with bucket policies. For more information, see [AWS::S3::BucketPolicy](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html). For examples of common policy configurations, including S3 Server Access Logs buckets and more, see [Bucket policy examples](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.html) in the *Amazon S3 User Guide*.
        :param Sequence['AnalyticsConfigurationResponse'] analytics_configurations: Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
        :param str arn: the Amazon Resource Name (ARN) of the specified bucket.
        :param 'BucketEncryptionResponse' bucket_encryption: Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3), AWS KMS-managed keys (SSE-KMS), or dual-layer server-side encryption with KMS-managed keys (DSSE-KMS). For information about the Amazon S3 default encryption feature, see [Amazon S3 Default Encryption for S3 Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) in the *Amazon S3 User Guide*. Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3), AWS KMS-managed keys (SSE-KMS), or dual-layer server-side encryption with KMS-managed keys (DSSE-KMS). For information about the Amazon S3 default encryption feature, see [Amazon S3 Default Encryption for S3 Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) in the *Amazon S3 User Guide*.
        :param str bucket_name: A name for the bucket. If you don't specify a name, AWS CloudFormation generates a unique ID and uses that ID for the bucket name. The bucket name must contain only lowercase letters, numbers, periods (.), and dashes (-) and must follow [Amazon S3 bucket restrictions and limitations](https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html). For more information, see [Rules for naming Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html#bucketnamingrules) in the *Amazon S3 User Guide*.   If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you need to replace the resource, specify a new name.
        :param 'CorsConfigurationResponse' cors_configuration: Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see [Enabling Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the *Amazon S3 User Guide*. Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see [Enabling Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the *Amazon S3 User Guide*.
        :param str domain_name: Property domainName
        :param str dual_stack_domain_name: Property dualStackDomainName
        :param Sequence['IntelligentTieringConfigurationResponse'] intelligent_tiering_configurations: Defines how Amazon S3 handles Intelligent-Tiering storage.
        :param Sequence['InventoryConfigurationResponse'] inventory_configurations: Specifies the inventory configuration for an Amazon S3 bucket. For more information, see [GET Bucket inventory](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html) in the *Amazon S3 API Reference*.
        :param 'LifecycleConfigurationResponse' lifecycle_configuration: Specifies the lifecycle configuration for objects in an Amazon S3 bucket. For more information, see [Object Lifecycle Management](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html) in the *Amazon S3 User Guide*. Specifies the lifecycle configuration for objects in an Amazon S3 bucket. For more information, see [Object Lifecycle Management](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html) in the *Amazon S3 User Guide*.
        :param 'LoggingConfigurationResponse' logging_configuration: Settings that define where logs are stored. Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys for a bucket. For examples and more information, see [PUT Bucket logging](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html) in the *Amazon S3 API Reference*.  To successfully complete the ``AWS::S3::Bucket LoggingConfiguration`` request, you must have ``s3:PutObject`` and ``s3:PutObjectAcl`` in your IAM permissions.
        :param Sequence['MetricsConfigurationResponse'] metrics_configurations: Specifies a metrics configuration for the CloudWatch request metrics (specified by the metrics configuration ID) from an Amazon S3 bucket. If you're updating an existing metrics configuration, note that this is a full replacement of the existing metrics configuration. If you don't include the elements you want to keep, they are erased. For more information, see [PutBucketMetricsConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html).
        :param 'NotificationConfigurationResponse' notification_configuration: Configuration that defines how Amazon S3 handles bucket notifications. Describes the notification configuration for an Amazon S3 bucket.  If you create the target resource and related permissions in the same template, you might have a circular dependency. For example, you might use the ``AWS::Lambda::Permission`` resource to grant the bucket permission to invoke an AWS Lambda function. However, AWS CloudFormation can't create the bucket until the bucket has permission to invoke the function (AWS CloudFormation checks whether the bucket can invoke the function). If you're using Refs to pass the bucket name, this leads to a circular dependency. To avoid this dependency, you can create all resources without specifying the notification configuration. Then, update the stack with a notification configuration. For more information on permissions, see [AWS::Lambda::Permission](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html) and [Granting Permissions to Publish Event Notification Messages to a Destination](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#grant-destinations-permissions-to-s3).
        :param 'ObjectLockConfigurationResponse' object_lock_configuration: This operation is not supported by directory buckets.  Places an Object Lock configuration on the specified bucket. The rule specified in the Object Lock configuration will be applied by default to every new object placed in the specified bucket. For more information, see [Locking Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html).    +  The ``DefaultRetention`` settings require both a mode and a period.  +  The ``DefaultRetention`` period can be either ``Days`` or ``Years`` but you must select one. You cannot specify ``Days`` and ``Years`` at the same time.  +  You can enable Object Lock for new or existing buckets. For more information, see [Configuring Object Lock](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock-configure.html). Places an Object Lock configuration on the specified bucket. The rule specified in the Object Lock configuration will be applied by default to every new object placed in the specified bucket. For more information, see [Locking Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html).
        :param bool object_lock_enabled: Indicates whether this bucket has an Object Lock configuration enabled. Enable ``ObjectLockEnabled`` when you apply ``ObjectLockConfiguration`` to a bucket.
        :param 'OwnershipControlsResponse' ownership_controls: Configuration that defines how Amazon S3 handles Object Ownership rules. Specifies the container element for Object Ownership rules. S3 Object Ownership is an Amazon S3 bucket-level setting that you can use to disable access control lists (ACLs) and take ownership of every object in your bucket, simplifying access management for data stored in Amazon S3. For more information, see [Controlling ownership of objects and disabling ACLs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html) in the *Amazon S3 User Guide*.
        :param 'PublicAccessBlockConfigurationResponse' public_access_block_configuration: Configuration that defines how Amazon S3 handles public access. The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of 'Public'](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the *Amazon S3 User Guide*.
        :param str regional_domain_name: Property regionalDomainName
        :param 'ReplicationConfigurationResponse' replication_configuration: Configuration for replicating objects in an S3 bucket. To enable replication, you must also enable versioning by using the ``VersioningConfiguration`` property. Amazon S3 can store replicated objects in a single destination bucket or multiple destination buckets. The destination bucket or buckets must already exist. A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB. The latest version of the replication configuration XML is V2. For more information about XML V2 replication configurations, see [Replication configuration](https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication-add-config.html) in the *Amazon S3 User Guide*.
        :param Sequence['TagResponse'] tags: An arbitrary set of tags (key-value pairs) for this S3 bucket.
        :param 'VersioningConfigurationResponse' versioning_configuration: Enables multiple versions of all objects in this bucket. You might enable versioning to prevent objects from being deleted or overwritten by mistake or to archive objects so that you can retrieve previous versions of them. Describes the versioning state of an Amazon S3 bucket. For more information, see [PUT Bucket versioning](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html) in the *Amazon S3 API Reference*.
        :param 'WebsiteConfigurationResponse' website_configuration: Information used to configure the bucket as a static website. For more information, see [Hosting Websites on Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html). Specifies website configuration parameters for an Amazon S3 bucket.
        :param str website_url: Property websiteURL
        """
        if accelerate_configuration is not None:
            pulumi.set(__self__, "accelerate_configuration", accelerate_configuration)
        if access_control is not None:
            pulumi.set(__self__, "access_control", access_control)
        if analytics_configurations is not None:
            pulumi.set(__self__, "analytics_configurations", analytics_configurations)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if bucket_encryption is not None:
            pulumi.set(__self__, "bucket_encryption", bucket_encryption)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if cors_configuration is not None:
            pulumi.set(__self__, "cors_configuration", cors_configuration)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if dual_stack_domain_name is not None:
            pulumi.set(__self__, "dual_stack_domain_name", dual_stack_domain_name)
        if intelligent_tiering_configurations is not None:
            pulumi.set(__self__, "intelligent_tiering_configurations", intelligent_tiering_configurations)
        if inventory_configurations is not None:
            pulumi.set(__self__, "inventory_configurations", inventory_configurations)
        if lifecycle_configuration is not None:
            pulumi.set(__self__, "lifecycle_configuration", lifecycle_configuration)
        if logging_configuration is not None:
            pulumi.set(__self__, "logging_configuration", logging_configuration)
        if metrics_configurations is not None:
            pulumi.set(__self__, "metrics_configurations", metrics_configurations)
        if notification_configuration is not None:
            pulumi.set(__self__, "notification_configuration", notification_configuration)
        if object_lock_configuration is not None:
            pulumi.set(__self__, "object_lock_configuration", object_lock_configuration)
        if object_lock_enabled is not None:
            pulumi.set(__self__, "object_lock_enabled", object_lock_enabled)
        if ownership_controls is not None:
            pulumi.set(__self__, "ownership_controls", ownership_controls)
        if public_access_block_configuration is not None:
            pulumi.set(__self__, "public_access_block_configuration", public_access_block_configuration)
        if regional_domain_name is not None:
            pulumi.set(__self__, "regional_domain_name", regional_domain_name)
        if replication_configuration is not None:
            pulumi.set(__self__, "replication_configuration", replication_configuration)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if versioning_configuration is not None:
            pulumi.set(__self__, "versioning_configuration", versioning_configuration)
        if website_configuration is not None:
            pulumi.set(__self__, "website_configuration", website_configuration)
        if website_url is not None:
            pulumi.set(__self__, "website_url", website_url)

    @property
    @pulumi.getter(name="accelerateConfiguration")
    def accelerate_configuration(self) -> Optional['outputs.AccelerateConfigurationResponse']:
        """
        Configures the transfer acceleration state for an Amazon S3 bucket. For more information, see [Amazon S3 Transfer Acceleration](https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in the *Amazon S3 User Guide*. Configures the transfer acceleration state for an Amazon S3 bucket. For more information, see [Amazon S3 Transfer Acceleration](https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "accelerate_configuration")

    @property
    @pulumi.getter(name="accessControl")
    def access_control(self) -> Optional[str]:
        """
        This is a legacy property, and it is not recommended for most use cases. A majority of modern use cases in Amazon S3 no longer require the use of ACLs, and we recommend that you keep ACLs disabled. For more information, see [Controlling object ownership](https://docs.aws.amazon.com//AmazonS3/latest/userguide/about-object-ownership.html) in the *Amazon S3 User Guide*.  A canned access control list (ACL) that grants predefined permissions to the bucket. For more information about canned ACLs, see [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) in the *Amazon S3 User Guide*.  S3 buckets are created with ACLs disabled by default. Therefore, unless you explicitly set the [AWS::S3::OwnershipControls](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-ownershipcontrols.html) property to enable ACLs, your resource will fail to deploy with any value other than Private. Use cases requiring ACLs are uncommon.  The majority of access control configurations can be successfully and more easily achieved with bucket policies. For more information, see [AWS::S3::BucketPolicy](https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html). For examples of common policy configurations, including S3 Server Access Logs buckets and more, see [Bucket policy examples](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-bucket-policies.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "access_control")

    @property
    @pulumi.getter(name="analyticsConfigurations")
    def analytics_configurations(self) -> Optional[Sequence['outputs.AnalyticsConfigurationResponse']]:
        """
        Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
        """
        return pulumi.get(self, "analytics_configurations")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        the Amazon Resource Name (ARN) of the specified bucket.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="bucketEncryption")
    def bucket_encryption(self) -> Optional['outputs.BucketEncryptionResponse']:
        """
        Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3), AWS KMS-managed keys (SSE-KMS), or dual-layer server-side encryption with KMS-managed keys (DSSE-KMS). For information about the Amazon S3 default encryption feature, see [Amazon S3 Default Encryption for S3 Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) in the *Amazon S3 User Guide*. Specifies default encryption for a bucket using server-side encryption with Amazon S3-managed keys (SSE-S3), AWS KMS-managed keys (SSE-KMS), or dual-layer server-side encryption with KMS-managed keys (DSSE-KMS). For information about the Amazon S3 default encryption feature, see [Amazon S3 Default Encryption for S3 Buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "bucket_encryption")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        A name for the bucket. If you don't specify a name, AWS CloudFormation generates a unique ID and uses that ID for the bucket name. The bucket name must contain only lowercase letters, numbers, periods (.), and dashes (-) and must follow [Amazon S3 bucket restrictions and limitations](https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html). For more information, see [Rules for naming Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html#bucketnamingrules) in the *Amazon S3 User Guide*.   If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you need to replace the resource, specify a new name.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="corsConfiguration")
    def cors_configuration(self) -> Optional['outputs.CorsConfigurationResponse']:
        """
        Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see [Enabling Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the *Amazon S3 User Guide*. Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see [Enabling Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "cors_configuration")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        Property domainName
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="dualStackDomainName")
    def dual_stack_domain_name(self) -> Optional[str]:
        """
        Property dualStackDomainName
        """
        return pulumi.get(self, "dual_stack_domain_name")

    @property
    @pulumi.getter(name="intelligentTieringConfigurations")
    def intelligent_tiering_configurations(self) -> Optional[Sequence['outputs.IntelligentTieringConfigurationResponse']]:
        """
        Defines how Amazon S3 handles Intelligent-Tiering storage.
        """
        return pulumi.get(self, "intelligent_tiering_configurations")

    @property
    @pulumi.getter(name="inventoryConfigurations")
    def inventory_configurations(self) -> Optional[Sequence['outputs.InventoryConfigurationResponse']]:
        """
        Specifies the inventory configuration for an Amazon S3 bucket. For more information, see [GET Bucket inventory](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html) in the *Amazon S3 API Reference*.
        """
        return pulumi.get(self, "inventory_configurations")

    @property
    @pulumi.getter(name="lifecycleConfiguration")
    def lifecycle_configuration(self) -> Optional['outputs.LifecycleConfigurationResponse']:
        """
        Specifies the lifecycle configuration for objects in an Amazon S3 bucket. For more information, see [Object Lifecycle Management](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html) in the *Amazon S3 User Guide*. Specifies the lifecycle configuration for objects in an Amazon S3 bucket. For more information, see [Object Lifecycle Management](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "lifecycle_configuration")

    @property
    @pulumi.getter(name="loggingConfiguration")
    def logging_configuration(self) -> Optional['outputs.LoggingConfigurationResponse']:
        """
        Settings that define where logs are stored. Describes where logs are stored and the prefix that Amazon S3 assigns to all log object keys for a bucket. For examples and more information, see [PUT Bucket logging](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTlogging.html) in the *Amazon S3 API Reference*.  To successfully complete the ``AWS::S3::Bucket LoggingConfiguration`` request, you must have ``s3:PutObject`` and ``s3:PutObjectAcl`` in your IAM permissions.
        """
        return pulumi.get(self, "logging_configuration")

    @property
    @pulumi.getter(name="metricsConfigurations")
    def metrics_configurations(self) -> Optional[Sequence['outputs.MetricsConfigurationResponse']]:
        """
        Specifies a metrics configuration for the CloudWatch request metrics (specified by the metrics configuration ID) from an Amazon S3 bucket. If you're updating an existing metrics configuration, note that this is a full replacement of the existing metrics configuration. If you don't include the elements you want to keep, they are erased. For more information, see [PutBucketMetricsConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html).
        """
        return pulumi.get(self, "metrics_configurations")

    @property
    @pulumi.getter(name="notificationConfiguration")
    def notification_configuration(self) -> Optional['outputs.NotificationConfigurationResponse']:
        """
        Configuration that defines how Amazon S3 handles bucket notifications. Describes the notification configuration for an Amazon S3 bucket.  If you create the target resource and related permissions in the same template, you might have a circular dependency. For example, you might use the ``AWS::Lambda::Permission`` resource to grant the bucket permission to invoke an AWS Lambda function. However, AWS CloudFormation can't create the bucket until the bucket has permission to invoke the function (AWS CloudFormation checks whether the bucket can invoke the function). If you're using Refs to pass the bucket name, this leads to a circular dependency. To avoid this dependency, you can create all resources without specifying the notification configuration. Then, update the stack with a notification configuration. For more information on permissions, see [AWS::Lambda::Permission](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html) and [Granting Permissions to Publish Event Notification Messages to a Destination](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#grant-destinations-permissions-to-s3).
        """
        return pulumi.get(self, "notification_configuration")

    @property
    @pulumi.getter(name="objectLockConfiguration")
    def object_lock_configuration(self) -> Optional['outputs.ObjectLockConfigurationResponse']:
        """
        This operation is not supported by directory buckets.  Places an Object Lock configuration on the specified bucket. The rule specified in the Object Lock configuration will be applied by default to every new object placed in the specified bucket. For more information, see [Locking Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html).    +  The ``DefaultRetention`` settings require both a mode and a period.  +  The ``DefaultRetention`` period can be either ``Days`` or ``Years`` but you must select one. You cannot specify ``Days`` and ``Years`` at the same time.  +  You can enable Object Lock for new or existing buckets. For more information, see [Configuring Object Lock](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lock-configure.html). Places an Object Lock configuration on the specified bucket. The rule specified in the Object Lock configuration will be applied by default to every new object placed in the specified bucket. For more information, see [Locking Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html).
        """
        return pulumi.get(self, "object_lock_configuration")

    @property
    @pulumi.getter(name="objectLockEnabled")
    def object_lock_enabled(self) -> Optional[bool]:
        """
        Indicates whether this bucket has an Object Lock configuration enabled. Enable ``ObjectLockEnabled`` when you apply ``ObjectLockConfiguration`` to a bucket.
        """
        return pulumi.get(self, "object_lock_enabled")

    @property
    @pulumi.getter(name="ownershipControls")
    def ownership_controls(self) -> Optional['outputs.OwnershipControlsResponse']:
        """
        Configuration that defines how Amazon S3 handles Object Ownership rules. Specifies the container element for Object Ownership rules. S3 Object Ownership is an Amazon S3 bucket-level setting that you can use to disable access control lists (ACLs) and take ownership of every object in your bucket, simplifying access management for data stored in Amazon S3. For more information, see [Controlling ownership of objects and disabling ACLs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/about-object-ownership.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "ownership_controls")

    @property
    @pulumi.getter(name="publicAccessBlockConfiguration")
    def public_access_block_configuration(self) -> Optional['outputs.PublicAccessBlockConfigurationResponse']:
        """
        Configuration that defines how Amazon S3 handles public access. The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see [The Meaning of 'Public'](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "public_access_block_configuration")

    @property
    @pulumi.getter(name="regionalDomainName")
    def regional_domain_name(self) -> Optional[str]:
        """
        Property regionalDomainName
        """
        return pulumi.get(self, "regional_domain_name")

    @property
    @pulumi.getter(name="replicationConfiguration")
    def replication_configuration(self) -> Optional['outputs.ReplicationConfigurationResponse']:
        """
        Configuration for replicating objects in an S3 bucket. To enable replication, you must also enable versioning by using the ``VersioningConfiguration`` property. Amazon S3 can store replicated objects in a single destination bucket or multiple destination buckets. The destination bucket or buckets must already exist. A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB. The latest version of the replication configuration XML is V2. For more information about XML V2 replication configurations, see [Replication configuration](https://docs.aws.amazon.com/AmazonS3/latest/userguide/replication-add-config.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "replication_configuration")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        An arbitrary set of tags (key-value pairs) for this S3 bucket.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="versioningConfiguration")
    def versioning_configuration(self) -> Optional['outputs.VersioningConfigurationResponse']:
        """
        Enables multiple versions of all objects in this bucket. You might enable versioning to prevent objects from being deleted or overwritten by mistake or to archive objects so that you can retrieve previous versions of them. Describes the versioning state of an Amazon S3 bucket. For more information, see [PUT Bucket versioning](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html) in the *Amazon S3 API Reference*.
        """
        return pulumi.get(self, "versioning_configuration")

    @property
    @pulumi.getter(name="websiteConfiguration")
    def website_configuration(self) -> Optional['outputs.WebsiteConfigurationResponse']:
        """
        Information used to configure the bucket as a static website. For more information, see [Hosting Websites on Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html). Specifies website configuration parameters for an Amazon S3 bucket.
        """
        return pulumi.get(self, "website_configuration")

    @property
    @pulumi.getter(name="websiteURL")
    def website_url(self) -> Optional[str]:
        """
        Property websiteURL
        """
        return pulumi.get(self, "website_url")


@pulumi.output_type
class AwsS3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse(dict):
    """
    Definition of awsS3ControlMultiRegionAccessPointPolicyDocument
    """
    def __init__(__self__, *,
                 established: Optional['outputs.EstablishedMultiRegionAccessPointPolicyResponse'] = None,
                 proposed: Optional['outputs.ProposedMultiRegionAccessPointPolicyResponse'] = None):
        """
        Definition of awsS3ControlMultiRegionAccessPointPolicyDocument
        :param 'EstablishedMultiRegionAccessPointPolicyResponse' established: <p>The last established policy for the Multi-Region Access Point.</p>
        :param 'ProposedMultiRegionAccessPointPolicyResponse' proposed: <p>The proposed policy for the Multi-Region Access Point.</p>
        """
        if established is not None:
            pulumi.set(__self__, "established", established)
        if proposed is not None:
            pulumi.set(__self__, "proposed", proposed)

    @property
    @pulumi.getter
    def established(self) -> Optional['outputs.EstablishedMultiRegionAccessPointPolicyResponse']:
        """
        <p>The last established policy for the Multi-Region Access Point.</p>
        """
        return pulumi.get(self, "established")

    @property
    @pulumi.getter
    def proposed(self) -> Optional['outputs.ProposedMultiRegionAccessPointPolicyResponse']:
        """
        <p>The proposed policy for the Multi-Region Access Point.</p>
        """
        return pulumi.get(self, "proposed")


@pulumi.output_type
class AwsSageMakerAppPropertiesResponse(dict):
    """
    Definition of awsSageMakerApp
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appArn":
            suggest = "app_arn"
        elif key == "appName":
            suggest = "app_name"
        elif key == "appType":
            suggest = "app_type"
        elif key == "domainId":
            suggest = "domain_id"
        elif key == "resourceSpec":
            suggest = "resource_spec"
        elif key == "userProfileName":
            suggest = "user_profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSageMakerAppPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSageMakerAppPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSageMakerAppPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_arn: Optional[str] = None,
                 app_name: Optional[str] = None,
                 app_type: Optional[str] = None,
                 domain_id: Optional[str] = None,
                 resource_spec: Optional['outputs.ResourceSpecResponse'] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 user_profile_name: Optional[str] = None):
        """
        Definition of awsSageMakerApp
        :param str app_arn: The Amazon Resource Name (ARN) of the app.
        :param str app_name: The name of the app.
        :param str app_type: The type of app.
        :param str domain_id: The domain ID.
        :param 'ResourceSpecResponse' resource_spec: The instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.
        :param Sequence['TagResponse'] tags: A list of tags to apply to the app.
        :param str user_profile_name: The user profile name.
        """
        if app_arn is not None:
            pulumi.set(__self__, "app_arn", app_arn)
        if app_name is not None:
            pulumi.set(__self__, "app_name", app_name)
        if app_type is not None:
            pulumi.set(__self__, "app_type", app_type)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if resource_spec is not None:
            pulumi.set(__self__, "resource_spec", resource_spec)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_profile_name is not None:
            pulumi.set(__self__, "user_profile_name", user_profile_name)

    @property
    @pulumi.getter(name="appArn")
    def app_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the app.
        """
        return pulumi.get(self, "app_arn")

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[str]:
        """
        The name of the app.
        """
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter(name="appType")
    def app_type(self) -> Optional[str]:
        """
        The type of app.
        """
        return pulumi.get(self, "app_type")

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[str]:
        """
        The domain ID.
        """
        return pulumi.get(self, "domain_id")

    @property
    @pulumi.getter(name="resourceSpec")
    def resource_spec(self) -> Optional['outputs.ResourceSpecResponse']:
        """
        The instance type and the Amazon Resource Name (ARN) of the SageMaker image created on the instance.
        """
        return pulumi.get(self, "resource_spec")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        A list of tags to apply to the app.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="userProfileName")
    def user_profile_name(self) -> Optional[str]:
        """
        The user profile name.
        """
        return pulumi.get(self, "user_profile_name")


@pulumi.output_type
class AwsSageMakerNotebookInstanceSummaryPropertiesResponse(dict):
    """
    Definition of awsSageMakerNotebookInstanceSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalCodeRepositories":
            suggest = "additional_code_repositories"
        elif key == "creationTime":
            suggest = "creation_time"
        elif key == "defaultCodeRepository":
            suggest = "default_code_repository"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "lastModifiedTime":
            suggest = "last_modified_time"
        elif key == "notebookInstanceArn":
            suggest = "notebook_instance_arn"
        elif key == "notebookInstanceLifecycleConfigName":
            suggest = "notebook_instance_lifecycle_config_name"
        elif key == "notebookInstanceName":
            suggest = "notebook_instance_name"
        elif key == "notebookInstanceStatus":
            suggest = "notebook_instance_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSageMakerNotebookInstanceSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSageMakerNotebookInstanceSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSageMakerNotebookInstanceSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_code_repositories: Optional[Sequence[str]] = None,
                 creation_time: Optional[str] = None,
                 default_code_repository: Optional[str] = None,
                 instance_type: Optional['outputs.InstanceTypeEnumValueResponse'] = None,
                 last_modified_time: Optional[str] = None,
                 notebook_instance_arn: Optional[str] = None,
                 notebook_instance_lifecycle_config_name: Optional[str] = None,
                 notebook_instance_name: Optional[str] = None,
                 notebook_instance_status: Optional['outputs.NotebookInstanceStatusEnumValueResponse'] = None,
                 url: Optional[str] = None):
        """
        Definition of awsSageMakerNotebookInstanceSummary
        :param Sequence[str] additional_code_repositories: <p>An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in <a href='https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html'>Amazon Web Services CodeCommit</a> or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see <a href='https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html'>Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
        :param str creation_time: <p>A timestamp that shows when the notebook instance was created.</p>
        :param str default_code_repository: <p>The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in <a href='https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html'>Amazon Web Services CodeCommit</a> or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see <a href='https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html'>Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
        :param 'InstanceTypeEnumValueResponse' instance_type: <p>The type of ML compute instance that the notebook instance is running on.</p>
        :param str last_modified_time: <p>A timestamp that shows when the notebook instance was last modified.</p>
        :param str notebook_instance_arn: <p>The Amazon Resource Name (ARN) of the notebook instance.</p>
        :param str notebook_instance_lifecycle_config_name: <p>The name of a notebook instance lifecycle configuration associated with this notebook instance.</p> <p>For information about notebook instance lifestyle configurations, see <a href='https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html'>Step 2.1: (Optional) Customize a Notebook Instance</a>.</p>
        :param str notebook_instance_name: <p>The name of the notebook instance that you want a summary for.</p>
        :param 'NotebookInstanceStatusEnumValueResponse' notebook_instance_status: <p>The status of the notebook instance.</p>
        :param str url: <p>The URL that you use to connect to the Jupyter notebook running in your notebook instance. </p>
        """
        if additional_code_repositories is not None:
            pulumi.set(__self__, "additional_code_repositories", additional_code_repositories)
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if default_code_repository is not None:
            pulumi.set(__self__, "default_code_repository", default_code_repository)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if last_modified_time is not None:
            pulumi.set(__self__, "last_modified_time", last_modified_time)
        if notebook_instance_arn is not None:
            pulumi.set(__self__, "notebook_instance_arn", notebook_instance_arn)
        if notebook_instance_lifecycle_config_name is not None:
            pulumi.set(__self__, "notebook_instance_lifecycle_config_name", notebook_instance_lifecycle_config_name)
        if notebook_instance_name is not None:
            pulumi.set(__self__, "notebook_instance_name", notebook_instance_name)
        if notebook_instance_status is not None:
            pulumi.set(__self__, "notebook_instance_status", notebook_instance_status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="additionalCodeRepositories")
    def additional_code_repositories(self) -> Optional[Sequence[str]]:
        """
        <p>An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in <a href='https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html'>Amazon Web Services CodeCommit</a> or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see <a href='https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html'>Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
        """
        return pulumi.get(self, "additional_code_repositories")

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[str]:
        """
        <p>A timestamp that shows when the notebook instance was created.</p>
        """
        return pulumi.get(self, "creation_time")

    @property
    @pulumi.getter(name="defaultCodeRepository")
    def default_code_repository(self) -> Optional[str]:
        """
        <p>The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in <a href='https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html'>Amazon Web Services CodeCommit</a> or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see <a href='https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html'>Associating Git Repositories with SageMaker Notebook Instances</a>.</p>
        """
        return pulumi.get(self, "default_code_repository")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional['outputs.InstanceTypeEnumValueResponse']:
        """
        <p>The type of ML compute instance that the notebook instance is running on.</p>
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> Optional[str]:
        """
        <p>A timestamp that shows when the notebook instance was last modified.</p>
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="notebookInstanceArn")
    def notebook_instance_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the notebook instance.</p>
        """
        return pulumi.get(self, "notebook_instance_arn")

    @property
    @pulumi.getter(name="notebookInstanceLifecycleConfigName")
    def notebook_instance_lifecycle_config_name(self) -> Optional[str]:
        """
        <p>The name of a notebook instance lifecycle configuration associated with this notebook instance.</p> <p>For information about notebook instance lifestyle configurations, see <a href='https://docs.aws.amazon.com/sagemaker/latest/dg/notebook-lifecycle-config.html'>Step 2.1: (Optional) Customize a Notebook Instance</a>.</p>
        """
        return pulumi.get(self, "notebook_instance_lifecycle_config_name")

    @property
    @pulumi.getter(name="notebookInstanceName")
    def notebook_instance_name(self) -> Optional[str]:
        """
        <p>The name of the notebook instance that you want a summary for.</p>
        """
        return pulumi.get(self, "notebook_instance_name")

    @property
    @pulumi.getter(name="notebookInstanceStatus")
    def notebook_instance_status(self) -> Optional['outputs.NotebookInstanceStatusEnumValueResponse']:
        """
        <p>The status of the notebook instance.</p>
        """
        return pulumi.get(self, "notebook_instance_status")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        <p>The URL that you use to connect to the Jupyter notebook running in your notebook instance. </p>
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AwsSecretsManagerResourcePolicyPropertiesResponse(dict):
    """
    Definition of awsSecretsManagerResourcePolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockPublicPolicy":
            suggest = "block_public_policy"
        elif key == "resourcePolicy":
            suggest = "resource_policy"
        elif key == "secretId":
            suggest = "secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSecretsManagerResourcePolicyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSecretsManagerResourcePolicyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSecretsManagerResourcePolicyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_public_policy: Optional[bool] = None,
                 id: Optional[str] = None,
                 resource_policy: Optional[Any] = None,
                 secret_id: Optional[str] = None):
        """
        Definition of awsSecretsManagerResourcePolicy
        :param bool block_public_policy: Property blockPublicPolicy
        :param str id: Property id
        :param Any resource_policy: Property resourcePolicy
        :param str secret_id: Property secretId
        """
        if block_public_policy is not None:
            pulumi.set(__self__, "block_public_policy", block_public_policy)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if resource_policy is not None:
            pulumi.set(__self__, "resource_policy", resource_policy)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @property
    @pulumi.getter(name="blockPublicPolicy")
    def block_public_policy(self) -> Optional[bool]:
        """
        Property blockPublicPolicy
        """
        return pulumi.get(self, "block_public_policy")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="resourcePolicy")
    def resource_policy(self) -> Optional[Any]:
        """
        Property resourcePolicy
        """
        return pulumi.get(self, "resource_policy")

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[str]:
        """
        Property secretId
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class AwsSecretsManagerSecretPropertiesResponse(dict):
    """
    Definition of awsSecretsManagerSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generateSecretString":
            suggest = "generate_secret_string"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "replicaRegions":
            suggest = "replica_regions"
        elif key == "secretString":
            suggest = "secret_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSecretsManagerSecretPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSecretsManagerSecretPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSecretsManagerSecretPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 generate_secret_string: Optional['outputs.GenerateSecretStringResponse'] = None,
                 id: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 name: Optional[str] = None,
                 replica_regions: Optional[Sequence['outputs.ReplicaRegionResponse']] = None,
                 secret_string: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of awsSecretsManagerSecret
        :param str description: The description of the secret.
        :param 'GenerateSecretStringResponse' generate_secret_string: A structure that specifies how to generate a password to encrypt and store in the secret. To include a specific string in the secret, use ``SecretString`` instead. If you omit both ``GenerateSecretString`` and ``SecretString``, you create an empty secret. When you make a change to this property, a new secret version is created. We recommend that you specify the maximum length and include every character type that the system you are generating a password for can support. Generates a random password. We recommend that you specify the maximum length and include every character type that the system you are generating a password for can support.  *Required permissions:* ``secretsmanager:GetRandomPassword``. For more information, see [IAM policy actions for Secrets Manager](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awssecretsmanager.html#awssecretsmanager-actions-as-permissions) and [Authentication and access control in Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html).
        :param str id: Property id
        :param str kms_key_id: The ARN, key ID, or alias of the KMS key that Secrets Manager uses to encrypt the secret value in the secret. An alias is always prefixed by ``alias/``, for example ``alias/aws/secretsmanager``. For more information, see [About aliases](https://docs.aws.amazon.com/kms/latest/developerguide/alias-about.html). To use a KMS key in a different account, use the key ARN or the alias ARN. If you don't specify this value, then Secrets Manager uses the key ``aws/secretsmanager``. If that key doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value. If the secret is in a different AWS account from the credentials calling the API, then you can't use ``aws/secretsmanager`` to encrypt the secret, and you must create and use a customer managed KMS key.
        :param str name: The name of the new secret. The secret name can contain ASCII letters, numbers, and the following characters: /_+=.@- Do not end your secret name with a hyphen followed by six characters. If you do so, you risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager automatically adds a hyphen and six random characters after the secret name at the end of the ARN.
        :param Sequence['ReplicaRegionResponse'] replica_regions: A custom type that specifies a ``Region`` and the ``KmsKeyId`` for a replica secret.
        :param str secret_string: The text to encrypt and store in the secret. We recommend you use a JSON structure of key/value pairs for your secret value. To generate a random password, use ``GenerateSecretString`` instead. If you omit both ``GenerateSecretString`` and ``SecretString``, you create an empty secret. When you make a change to this property, a new secret version is created.
        :param Sequence['TagResponse'] tags: A list of tags to attach to the secret. Each tag is a key and value pair of strings in a JSON text string, for example:  ``[{'Key':'CostCenter','Value':'12345'},{'Key':'environment','Value':'production'}]``  Secrets Manager tag key names are case sensitive. A tag with the key 'ABC' is a different tag from one with key 'abc'. Stack-level tags, tags you apply to the CloudFormation stack, are also attached to the secret.  If you check tags in permissions policies as part of your security strategy, then adding or removing a tag can change permissions. If the completion of this operation would result in you losing your permissions for this secret, then Secrets Manager blocks the operation and returns an ``Access Denied`` error. For more information, see [Control access to secrets using tags](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#tag-secrets-abac) and [Limit access to identities with tags that match secrets' tags](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#auth-and-access_tags2). For information about how to format a JSON parameter for the various command line tool environments, see [Using JSON for Parameters](https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json). If your command-line tool or SDK requires quotation marks around the parameter, you should use single quotes to avoid confusion with the double quotes required in the JSON text. The following restrictions apply to tags:  +  Maximum number of tags per secret: 50  +  Maximum key length: 127 Unicode characters in UTF-8  +  Maximum value length: 255 Unicode characters in UTF-8  +  Tag keys and values are case sensitive.  +  Do not use the ``aws:`` prefix in your tag names or values because AWS reserves it for AWS use. You can't edit or delete tag names or values with this prefix. Tags with this prefix do not count against your tags per secret limit.  +  If you use your tagging schema across multiple services and resources, other services might have restrictions on allowed characters. Generally allowed characters: letters, spaces, and numbers representable in UTF-8, plus the following special characters: + - = . _ : / @.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if generate_secret_string is not None:
            pulumi.set(__self__, "generate_secret_string", generate_secret_string)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if replica_regions is not None:
            pulumi.set(__self__, "replica_regions", replica_regions)
        if secret_string is not None:
            pulumi.set(__self__, "secret_string", secret_string)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the secret.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="generateSecretString")
    def generate_secret_string(self) -> Optional['outputs.GenerateSecretStringResponse']:
        """
        A structure that specifies how to generate a password to encrypt and store in the secret. To include a specific string in the secret, use ``SecretString`` instead. If you omit both ``GenerateSecretString`` and ``SecretString``, you create an empty secret. When you make a change to this property, a new secret version is created. We recommend that you specify the maximum length and include every character type that the system you are generating a password for can support. Generates a random password. We recommend that you specify the maximum length and include every character type that the system you are generating a password for can support.  *Required permissions:* ``secretsmanager:GetRandomPassword``. For more information, see [IAM policy actions for Secrets Manager](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awssecretsmanager.html#awssecretsmanager-actions-as-permissions) and [Authentication and access control in Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html).
        """
        return pulumi.get(self, "generate_secret_string")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ARN, key ID, or alias of the KMS key that Secrets Manager uses to encrypt the secret value in the secret. An alias is always prefixed by ``alias/``, for example ``alias/aws/secretsmanager``. For more information, see [About aliases](https://docs.aws.amazon.com/kms/latest/developerguide/alias-about.html). To use a KMS key in a different account, use the key ARN or the alias ARN. If you don't specify this value, then Secrets Manager uses the key ``aws/secretsmanager``. If that key doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value. If the secret is in a different AWS account from the credentials calling the API, then you can't use ``aws/secretsmanager`` to encrypt the secret, and you must create and use a customer managed KMS key.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the new secret. The secret name can contain ASCII letters, numbers, and the following characters: /_+=.@- Do not end your secret name with a hyphen followed by six characters. If you do so, you risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager automatically adds a hyphen and six random characters after the secret name at the end of the ARN.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="replicaRegions")
    def replica_regions(self) -> Optional[Sequence['outputs.ReplicaRegionResponse']]:
        """
        A custom type that specifies a ``Region`` and the ``KmsKeyId`` for a replica secret.
        """
        return pulumi.get(self, "replica_regions")

    @property
    @pulumi.getter(name="secretString")
    def secret_string(self) -> Optional[str]:
        """
        The text to encrypt and store in the secret. We recommend you use a JSON structure of key/value pairs for your secret value. To generate a random password, use ``GenerateSecretString`` instead. If you omit both ``GenerateSecretString`` and ``SecretString``, you create an empty secret. When you make a change to this property, a new secret version is created.
        """
        return pulumi.get(self, "secret_string")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        A list of tags to attach to the secret. Each tag is a key and value pair of strings in a JSON text string, for example:  ``[{'Key':'CostCenter','Value':'12345'},{'Key':'environment','Value':'production'}]``  Secrets Manager tag key names are case sensitive. A tag with the key 'ABC' is a different tag from one with key 'abc'. Stack-level tags, tags you apply to the CloudFormation stack, are also attached to the secret.  If you check tags in permissions policies as part of your security strategy, then adding or removing a tag can change permissions. If the completion of this operation would result in you losing your permissions for this secret, then Secrets Manager blocks the operation and returns an ``Access Denied`` error. For more information, see [Control access to secrets using tags](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#tag-secrets-abac) and [Limit access to identities with tags that match secrets' tags](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_examples.html#auth-and-access_tags2). For information about how to format a JSON parameter for the various command line tool environments, see [Using JSON for Parameters](https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json). If your command-line tool or SDK requires quotation marks around the parameter, you should use single quotes to avoid confusion with the double quotes required in the JSON text. The following restrictions apply to tags:  +  Maximum number of tags per secret: 50  +  Maximum key length: 127 Unicode characters in UTF-8  +  Maximum value length: 255 Unicode characters in UTF-8  +  Tag keys and values are case sensitive.  +  Do not use the ``aws:`` prefix in your tag names or values because AWS reserves it for AWS use. You can't edit or delete tag names or values with this prefix. Tags with this prefix do not count against your tags per secret limit.  +  If you use your tagging schema across multiple services and resources, other services might have restrictions on allowed characters. Generally allowed characters: letters, spaces, and numbers representable in UTF-8, plus the following special characters: + - = . _ : / @.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsSnsSubscriptionPropertiesResponse(dict):
    """
    Definition of awsSnsSubscription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionArn":
            suggest = "subscription_arn"
        elif key == "topicArn":
            suggest = "topic_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSnsSubscriptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSnsSubscriptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSnsSubscriptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: Optional[str] = None,
                 owner: Optional[str] = None,
                 protocol: Optional[str] = None,
                 subscription_arn: Optional[str] = None,
                 topic_arn: Optional[str] = None):
        """
        Definition of awsSnsSubscription
        :param str endpoint: <p>The subscription's endpoint (format depends on the protocol).</p>
        :param str owner: <p>The subscription's owner.</p>
        :param str protocol: <p>The subscription's protocol.</p>
        :param str subscription_arn: <p>The subscription's ARN.</p>
        :param str topic_arn: <p>The ARN of the subscription's topic.</p>
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subscription_arn is not None:
            pulumi.set(__self__, "subscription_arn", subscription_arn)
        if topic_arn is not None:
            pulumi.set(__self__, "topic_arn", topic_arn)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        <p>The subscription's endpoint (format depends on the protocol).</p>
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        <p>The subscription's owner.</p>
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        <p>The subscription's protocol.</p>
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="subscriptionArn")
    def subscription_arn(self) -> Optional[str]:
        """
        <p>The subscription's ARN.</p>
        """
        return pulumi.get(self, "subscription_arn")

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> Optional[str]:
        """
        <p>The ARN of the subscription's topic.</p>
        """
        return pulumi.get(self, "topic_arn")


@pulumi.output_type
class AwsSnsTopicPropertiesResponse(dict):
    """
    Definition of awsSnsTopic
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archivePolicy":
            suggest = "archive_policy"
        elif key == "contentBasedDeduplication":
            suggest = "content_based_deduplication"
        elif key == "dataProtectionPolicy":
            suggest = "data_protection_policy"
        elif key == "deliveryStatusLogging":
            suggest = "delivery_status_logging"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "fifoTopic":
            suggest = "fifo_topic"
        elif key == "kmsMasterKeyId":
            suggest = "kms_master_key_id"
        elif key == "signatureVersion":
            suggest = "signature_version"
        elif key == "topicArn":
            suggest = "topic_arn"
        elif key == "topicName":
            suggest = "topic_name"
        elif key == "tracingConfig":
            suggest = "tracing_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSnsTopicPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSnsTopicPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSnsTopicPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_policy: Optional[Any] = None,
                 content_based_deduplication: Optional[bool] = None,
                 data_protection_policy: Optional[Any] = None,
                 delivery_status_logging: Optional[Sequence['outputs.LoggingConfigResponse']] = None,
                 display_name: Optional[str] = None,
                 fifo_topic: Optional[bool] = None,
                 kms_master_key_id: Optional[str] = None,
                 signature_version: Optional[str] = None,
                 subscription: Optional[Sequence['outputs.SubscriptionResponse']] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 topic_arn: Optional[str] = None,
                 topic_name: Optional[str] = None,
                 tracing_config: Optional[str] = None):
        """
        Definition of awsSnsTopic
        :param Any archive_policy: The archive policy determines the number of days SNS retains messages. You can set a retention period from 1 to 365 days.
        :param bool content_based_deduplication: Enables content-based deduplication for FIFO topics.  +  By default, ``ContentBasedDeduplication`` is set to ``false``. If you create a FIFO topic and this attribute is ``false``, you must specify a value for the ``MessageDeduplicationId`` parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.   +  When you set ``ContentBasedDeduplication`` to ``true``, SNS uses a SHA-256 hash to generate the ``MessageDeduplicationId`` using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the the ``MessageDeduplicationId`` parameter for the ``Publish`` action.
        :param Any data_protection_policy: The body of the policy document you want to use for this topic. You can only add one policy per topic. The policy must be in JSON string format. Length Constraints: Maximum length of 30,720.
        :param Sequence['LoggingConfigResponse'] delivery_status_logging: Property deliveryStatusLogging
        :param str display_name: The display name to use for an SNS topic with SMS subscriptions. The display name must be maximum 100 characters long, including hyphens (-), underscores (_), spaces, and tabs.
        :param bool fifo_topic: Set to true to create a FIFO topic.
        :param str kms_master_key_id: The ID of an AWS managed customer master key (CMK) for SNS or a custom CMK. For more information, see [Key terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see ``KeyId`` in the *API Reference*. This property applies only to [server-side-encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html).
        :param str signature_version: The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS. By default, ``SignatureVersion`` is set to ``1``.
        :param Sequence['SubscriptionResponse'] subscription: The SNS subscriptions (endpoints) for this topic.  If you specify the ``Subscription`` property in the ``AWS::SNS::Topic`` resource and it creates an associated subscription resource, the associated subscription is not deleted when the ``AWS::SNS::Topic`` resource is deleted.
        :param Sequence['TagResponse'] tags: The list of tags to add to a new topic.  To be able to tag a topic on creation, you must have the ``sns:CreateTopic`` and ``sns:TagResource`` permissions.
        :param str topic_arn: Property topicArn
        :param str topic_name: The name of the topic you want to create. Topic names must include only uppercase and lowercase ASCII letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters long. FIFO topic names must end with ``.fifo``. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the topic name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html).  If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        :param str tracing_config: Tracing mode of an SNS topic. By default ``TracingConfig`` is set to ``PassThrough``, and the topic passes through the tracing header it receives from an SNS publisher to its subscriptions. If set to ``Active``, SNS will vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true.
        """
        if archive_policy is not None:
            pulumi.set(__self__, "archive_policy", archive_policy)
        if content_based_deduplication is not None:
            pulumi.set(__self__, "content_based_deduplication", content_based_deduplication)
        if data_protection_policy is not None:
            pulumi.set(__self__, "data_protection_policy", data_protection_policy)
        if delivery_status_logging is not None:
            pulumi.set(__self__, "delivery_status_logging", delivery_status_logging)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if fifo_topic is not None:
            pulumi.set(__self__, "fifo_topic", fifo_topic)
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)
        if signature_version is not None:
            pulumi.set(__self__, "signature_version", signature_version)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if topic_arn is not None:
            pulumi.set(__self__, "topic_arn", topic_arn)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)
        if tracing_config is not None:
            pulumi.set(__self__, "tracing_config", tracing_config)

    @property
    @pulumi.getter(name="archivePolicy")
    def archive_policy(self) -> Optional[Any]:
        """
        The archive policy determines the number of days SNS retains messages. You can set a retention period from 1 to 365 days.
        """
        return pulumi.get(self, "archive_policy")

    @property
    @pulumi.getter(name="contentBasedDeduplication")
    def content_based_deduplication(self) -> Optional[bool]:
        """
        Enables content-based deduplication for FIFO topics.  +  By default, ``ContentBasedDeduplication`` is set to ``false``. If you create a FIFO topic and this attribute is ``false``, you must specify a value for the ``MessageDeduplicationId`` parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.   +  When you set ``ContentBasedDeduplication`` to ``true``, SNS uses a SHA-256 hash to generate the ``MessageDeduplicationId`` using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the the ``MessageDeduplicationId`` parameter for the ``Publish`` action.
        """
        return pulumi.get(self, "content_based_deduplication")

    @property
    @pulumi.getter(name="dataProtectionPolicy")
    def data_protection_policy(self) -> Optional[Any]:
        """
        The body of the policy document you want to use for this topic. You can only add one policy per topic. The policy must be in JSON string format. Length Constraints: Maximum length of 30,720.
        """
        return pulumi.get(self, "data_protection_policy")

    @property
    @pulumi.getter(name="deliveryStatusLogging")
    def delivery_status_logging(self) -> Optional[Sequence['outputs.LoggingConfigResponse']]:
        """
        Property deliveryStatusLogging
        """
        return pulumi.get(self, "delivery_status_logging")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name to use for an SNS topic with SMS subscriptions. The display name must be maximum 100 characters long, including hyphens (-), underscores (_), spaces, and tabs.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="fifoTopic")
    def fifo_topic(self) -> Optional[bool]:
        """
        Set to true to create a FIFO topic.
        """
        return pulumi.get(self, "fifo_topic")

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[str]:
        """
        The ID of an AWS managed customer master key (CMK) for SNS or a custom CMK. For more information, see [Key terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see ``KeyId`` in the *API Reference*. This property applies only to [server-side-encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html).
        """
        return pulumi.get(self, "kms_master_key_id")

    @property
    @pulumi.getter(name="signatureVersion")
    def signature_version(self) -> Optional[str]:
        """
        The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS. By default, ``SignatureVersion`` is set to ``1``.
        """
        return pulumi.get(self, "signature_version")

    @property
    @pulumi.getter
    def subscription(self) -> Optional[Sequence['outputs.SubscriptionResponse']]:
        """
        The SNS subscriptions (endpoints) for this topic.  If you specify the ``Subscription`` property in the ``AWS::SNS::Topic`` resource and it creates an associated subscription resource, the associated subscription is not deleted when the ``AWS::SNS::Topic`` resource is deleted.
        """
        return pulumi.get(self, "subscription")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The list of tags to add to a new topic.  To be able to tag a topic on creation, you must have the ``sns:CreateTopic`` and ``sns:TagResource`` permissions.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> Optional[str]:
        """
        Property topicArn
        """
        return pulumi.get(self, "topic_arn")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[str]:
        """
        The name of the topic you want to create. Topic names must include only uppercase and lowercase ASCII letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters long. FIFO topic names must end with ``.fifo``. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the topic name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html).  If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        """
        return pulumi.get(self, "topic_name")

    @property
    @pulumi.getter(name="tracingConfig")
    def tracing_config(self) -> Optional[str]:
        """
        Tracing mode of an SNS topic. By default ``TracingConfig`` is set to ``PassThrough``, and the topic passes through the tracing header it receives from an SNS publisher to its subscriptions. If set to ``Active``, SNS will vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true.
        """
        return pulumi.get(self, "tracing_config")


@pulumi.output_type
class AwsSqsQueuePropertiesResponse(dict):
    """
    Definition of awsSqsQueue
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentBasedDeduplication":
            suggest = "content_based_deduplication"
        elif key == "deduplicationScope":
            suggest = "deduplication_scope"
        elif key == "delaySeconds":
            suggest = "delay_seconds"
        elif key == "fifoQueue":
            suggest = "fifo_queue"
        elif key == "fifoThroughputLimit":
            suggest = "fifo_throughput_limit"
        elif key == "kmsDataKeyReusePeriodSeconds":
            suggest = "kms_data_key_reuse_period_seconds"
        elif key == "kmsMasterKeyId":
            suggest = "kms_master_key_id"
        elif key == "maximumMessageSize":
            suggest = "maximum_message_size"
        elif key == "messageRetentionPeriod":
            suggest = "message_retention_period"
        elif key == "queueName":
            suggest = "queue_name"
        elif key == "queueUrl":
            suggest = "queue_url"
        elif key == "receiveMessageWaitTimeSeconds":
            suggest = "receive_message_wait_time_seconds"
        elif key == "redriveAllowPolicy":
            suggest = "redrive_allow_policy"
        elif key == "redrivePolicy":
            suggest = "redrive_policy"
        elif key == "sqsManagedSseEnabled":
            suggest = "sqs_managed_sse_enabled"
        elif key == "visibilityTimeout":
            suggest = "visibility_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSqsQueuePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSqsQueuePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSqsQueuePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 content_based_deduplication: Optional[bool] = None,
                 deduplication_scope: Optional[str] = None,
                 delay_seconds: Optional[int] = None,
                 fifo_queue: Optional[bool] = None,
                 fifo_throughput_limit: Optional[str] = None,
                 kms_data_key_reuse_period_seconds: Optional[int] = None,
                 kms_master_key_id: Optional[str] = None,
                 maximum_message_size: Optional[int] = None,
                 message_retention_period: Optional[int] = None,
                 queue_name: Optional[str] = None,
                 queue_url: Optional[str] = None,
                 receive_message_wait_time_seconds: Optional[int] = None,
                 redrive_allow_policy: Optional[Any] = None,
                 redrive_policy: Optional[Any] = None,
                 sqs_managed_sse_enabled: Optional[bool] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None,
                 visibility_timeout: Optional[int] = None):
        """
        Definition of awsSqsQueue
        :param str arn: Property arn
        :param bool content_based_deduplication: For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication. During the deduplication interval, SQS treats messages that are sent with identical content as duplicates and delivers only one copy of the message. For more information, see the ``ContentBasedDeduplication`` attribute for the ``CreateQueue`` action in the *API Reference*.
        :param str deduplication_scope: For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level. Valid values are ``messageGroup`` and ``queue``. To enable high throughput for a FIFO queue, set this attribute to ``messageGroup`` *and* set the ``FifoThroughputLimit`` attribute to ``perMessageGroupId``. If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Developer Guide*.
        :param int delay_seconds: The time in seconds for which the delivery of all messages in the queue is delayed. You can specify an integer value of ``0`` to ``900`` (15 minutes). The default value is ``0``.
        :param bool fifo_queue: If set to true, creates a FIFO queue. If you don't specify this property, SQS creates a standard queue. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Developer Guide*.
        :param str fifo_throughput_limit: For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group. Valid values are ``perQueue`` and ``perMessageGroupId``. To enable high throughput for a FIFO queue, set this attribute to ``perMessageGroupId`` *and* set the ``DeduplicationScope`` attribute to ``messageGroup``. If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Developer Guide*.
        :param int kms_data_key_reuse_period_seconds: The length of time in seconds for which SQS can reuse a data key to encrypt or decrypt messages before calling KMS again. The value must be an integer between 60 (1 minute) and 86,400 (24 hours). The default is 300 (5 minutes).  A shorter time period provides better security, but results in more calls to KMS, which might incur charges after Free Tier. For more information, see [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-how-does-the-data-key-reuse-period-work) in the *Developer Guide*.
        :param str kms_master_key_id: The ID of an AWS Key Management Service (KMS) for SQS, or a custom KMS. To use the AWS managed KMS for SQS, specify a (default) alias ARN, alias name (e.g. ``alias/aws/sqs``), key ARN, or key ID. For more information, see the following:  +   [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html) in the *Developer Guide*   +   [CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html) in the *API Reference*   +   [Request Parameters](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the *Key Management Service API Reference*   +   The Key Management Service (KMS) section of the [Best Practices](https://docs.aws.amazon.com/https://d0.awsstatic.com/whitepapers/aws-kms-best-practices.pdf) whitepaper
        :param int maximum_message_size: The limit of how many bytes that a message can contain before SQS rejects it. You can specify an integer value from ``1,024`` bytes (1 KiB) to ``262,144`` bytes (256 KiB). The default value is ``262,144`` (256 KiB).
        :param int message_retention_period: The number of seconds that SQS retains a message. You can specify an integer value from ``60`` seconds (1 minute) to ``1,209,600`` seconds (14 days). The default value is ``345,600`` seconds (4 days).
        :param str queue_name: A name for the queue. To create a FIFO queue, the name of your FIFO queue must end with the ``.fifo`` suffix. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Developer Guide*. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the queue name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html) in the *User Guide*.   If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        :param str queue_url: Property queueUrl
        :param int receive_message_wait_time_seconds: Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available. You can specify an integer from 1 to 20. Short polling is used as the default or when you specify 0 for this property. For more information, see [Consuming messages using long polling](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html#sqs-long-polling) in the *Developer Guide*.
        :param Any redrive_allow_policy: The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object. The parameters are as follows:  +  ``redrivePermission``: The permission type that defines which source queues can specify the current queue as the dead-letter queue. Valid values are:  +  ``allowAll``: (Default) Any source queues in this AWS account in the same Region can specify this queue as the dead-letter queue.  +  ``denyAll``: No source queues can specify this queue as the dead-letter queue.  +  ``byQueue``: Only queues specified by the ``sourceQueueArns`` parameter can specify this queue as the dead-letter queue.    +  ``sourceQueueArns``: The Amazon Resource Names (ARN)s of the source queues that can specify this queue as the dead-letter queue and redrive messages. You can specify this parameter only when the ``redrivePermission`` parameter is set to ``byQueue``. You can specify up to 10 source queue ARNs. To allow more than 10 source queues to specify dead-letter queues, set the ``redrivePermission`` parameter to ``allowAll``.
        :param Any redrive_policy: The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object. The parameters are as follows:  +  ``deadLetterTargetArn``: The Amazon Resource Name (ARN) of the dead-letter queue to which SQS moves messages after the value of ``maxReceiveCount`` is exceeded.  +  ``maxReceiveCount``: The number of times a message is delivered to the source queue before being moved to the dead-letter queue. When the ``ReceiveCount`` for a message exceeds the ``maxReceiveCount`` for a queue, SQS moves the message to the dead-letter-queue.    The dead-letter queue of a FIFO queue must also be a FIFO queue. Similarly, the dead-letter queue of a standard queue must also be a standard queue.   *JSON*   ``{ 'deadLetterTargetArn' : String, 'maxReceiveCount' : Integer }``   *YAML*   ``deadLetterTargetArn : String``   ``maxReceiveCount : Integer``
        :param bool sqs_managed_sse_enabled: Enables server-side queue encryption using SQS owned encryption keys. Only one server-side encryption option is supported per queue (for example, [SSE-KMS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sse-existing-queue.html) or [SSE-SQS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sqs-sse-queue.html)). When ``SqsManagedSseEnabled`` is not defined, ``SSE-SQS`` encryption is enabled by default.
        :param Sequence['TagResponse'] tags: The tags that you attach to this queue. For more information, see [Resource tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) in the *User Guide*.
        :param int visibility_timeout: The length of time during which a message will be unavailable after a message is delivered from the queue. This blocks other components from receiving the same message and gives the initial component time to process and delete the message from the queue. Values must be from 0 to 43,200 seconds (12 hours). If you don't specify a value, AWS CloudFormation uses the default value of 30 seconds. For more information about SQS queue visibility timeouts, see [Visibility timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html) in the *Developer Guide*.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if content_based_deduplication is not None:
            pulumi.set(__self__, "content_based_deduplication", content_based_deduplication)
        if deduplication_scope is not None:
            pulumi.set(__self__, "deduplication_scope", deduplication_scope)
        if delay_seconds is not None:
            pulumi.set(__self__, "delay_seconds", delay_seconds)
        if fifo_queue is not None:
            pulumi.set(__self__, "fifo_queue", fifo_queue)
        if fifo_throughput_limit is not None:
            pulumi.set(__self__, "fifo_throughput_limit", fifo_throughput_limit)
        if kms_data_key_reuse_period_seconds is not None:
            pulumi.set(__self__, "kms_data_key_reuse_period_seconds", kms_data_key_reuse_period_seconds)
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)
        if maximum_message_size is not None:
            pulumi.set(__self__, "maximum_message_size", maximum_message_size)
        if message_retention_period is not None:
            pulumi.set(__self__, "message_retention_period", message_retention_period)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if queue_url is not None:
            pulumi.set(__self__, "queue_url", queue_url)
        if receive_message_wait_time_seconds is not None:
            pulumi.set(__self__, "receive_message_wait_time_seconds", receive_message_wait_time_seconds)
        if redrive_allow_policy is not None:
            pulumi.set(__self__, "redrive_allow_policy", redrive_allow_policy)
        if redrive_policy is not None:
            pulumi.set(__self__, "redrive_policy", redrive_policy)
        if sqs_managed_sse_enabled is not None:
            pulumi.set(__self__, "sqs_managed_sse_enabled", sqs_managed_sse_enabled)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if visibility_timeout is not None:
            pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Property arn
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="contentBasedDeduplication")
    def content_based_deduplication(self) -> Optional[bool]:
        """
        For first-in-first-out (FIFO) queues, specifies whether to enable content-based deduplication. During the deduplication interval, SQS treats messages that are sent with identical content as duplicates and delivers only one copy of the message. For more information, see the ``ContentBasedDeduplication`` attribute for the ``CreateQueue`` action in the *API Reference*.
        """
        return pulumi.get(self, "content_based_deduplication")

    @property
    @pulumi.getter(name="deduplicationScope")
    def deduplication_scope(self) -> Optional[str]:
        """
        For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level. Valid values are ``messageGroup`` and ``queue``. To enable high throughput for a FIFO queue, set this attribute to ``messageGroup`` *and* set the ``FifoThroughputLimit`` attribute to ``perMessageGroupId``. If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Developer Guide*.
        """
        return pulumi.get(self, "deduplication_scope")

    @property
    @pulumi.getter(name="delaySeconds")
    def delay_seconds(self) -> Optional[int]:
        """
        The time in seconds for which the delivery of all messages in the queue is delayed. You can specify an integer value of ``0`` to ``900`` (15 minutes). The default value is ``0``.
        """
        return pulumi.get(self, "delay_seconds")

    @property
    @pulumi.getter(name="fifoQueue")
    def fifo_queue(self) -> Optional[bool]:
        """
        If set to true, creates a FIFO queue. If you don't specify this property, SQS creates a standard queue. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Developer Guide*.
        """
        return pulumi.get(self, "fifo_queue")

    @property
    @pulumi.getter(name="fifoThroughputLimit")
    def fifo_throughput_limit(self) -> Optional[str]:
        """
        For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group. Valid values are ``perQueue`` and ``perMessageGroupId``. To enable high throughput for a FIFO queue, set this attribute to ``perMessageGroupId`` *and* set the ``DeduplicationScope`` attribute to ``messageGroup``. If you set these attributes to anything other than these values, normal throughput is in effect and deduplication occurs as specified. For more information, see [High throughput for FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/high-throughput-fifo.html) and [Quotas related to messages](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-messages.html) in the *Developer Guide*.
        """
        return pulumi.get(self, "fifo_throughput_limit")

    @property
    @pulumi.getter(name="kmsDataKeyReusePeriodSeconds")
    def kms_data_key_reuse_period_seconds(self) -> Optional[int]:
        """
        The length of time in seconds for which SQS can reuse a data key to encrypt or decrypt messages before calling KMS again. The value must be an integer between 60 (1 minute) and 86,400 (24 hours). The default is 300 (5 minutes).  A shorter time period provides better security, but results in more calls to KMS, which might incur charges after Free Tier. For more information, see [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html#sqs-how-does-the-data-key-reuse-period-work) in the *Developer Guide*.
        """
        return pulumi.get(self, "kms_data_key_reuse_period_seconds")

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[str]:
        """
        The ID of an AWS Key Management Service (KMS) for SQS, or a custom KMS. To use the AWS managed KMS for SQS, specify a (default) alias ARN, alias name (e.g. ``alias/aws/sqs``), key ARN, or key ID. For more information, see the following:  +   [Encryption at rest](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-server-side-encryption.html) in the *Developer Guide*   +   [CreateQueue](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html) in the *API Reference*   +   [Request Parameters](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the *Key Management Service API Reference*   +   The Key Management Service (KMS) section of the [Best Practices](https://docs.aws.amazon.com/https://d0.awsstatic.com/whitepapers/aws-kms-best-practices.pdf) whitepaper
        """
        return pulumi.get(self, "kms_master_key_id")

    @property
    @pulumi.getter(name="maximumMessageSize")
    def maximum_message_size(self) -> Optional[int]:
        """
        The limit of how many bytes that a message can contain before SQS rejects it. You can specify an integer value from ``1,024`` bytes (1 KiB) to ``262,144`` bytes (256 KiB). The default value is ``262,144`` (256 KiB).
        """
        return pulumi.get(self, "maximum_message_size")

    @property
    @pulumi.getter(name="messageRetentionPeriod")
    def message_retention_period(self) -> Optional[int]:
        """
        The number of seconds that SQS retains a message. You can specify an integer value from ``60`` seconds (1 minute) to ``1,209,600`` seconds (14 days). The default value is ``345,600`` seconds (4 days).
        """
        return pulumi.get(self, "message_retention_period")

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[str]:
        """
        A name for the queue. To create a FIFO queue, the name of your FIFO queue must end with the ``.fifo`` suffix. For more information, see [FIFO queues](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/FIFO-queues.html) in the *Developer Guide*. If you don't specify a name, CFN generates a unique physical ID and uses that ID for the queue name. For more information, see [Name type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html) in the *User Guide*.   If you specify a name, you can't perform updates that require replacement of this resource. You can perform updates that require no or some interruption. If you must replace the resource, specify a new name.
        """
        return pulumi.get(self, "queue_name")

    @property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> Optional[str]:
        """
        Property queueUrl
        """
        return pulumi.get(self, "queue_url")

    @property
    @pulumi.getter(name="receiveMessageWaitTimeSeconds")
    def receive_message_wait_time_seconds(self) -> Optional[int]:
        """
        Specifies the duration, in seconds, that the ReceiveMessage action call waits until a message is in the queue in order to include it in the response, rather than returning an empty response if a message isn't yet available. You can specify an integer from 1 to 20. Short polling is used as the default or when you specify 0 for this property. For more information, see [Consuming messages using long polling](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html#sqs-long-polling) in the *Developer Guide*.
        """
        return pulumi.get(self, "receive_message_wait_time_seconds")

    @property
    @pulumi.getter(name="redriveAllowPolicy")
    def redrive_allow_policy(self) -> Optional[Any]:
        """
        The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues as a JSON object. The parameters are as follows:  +  ``redrivePermission``: The permission type that defines which source queues can specify the current queue as the dead-letter queue. Valid values are:  +  ``allowAll``: (Default) Any source queues in this AWS account in the same Region can specify this queue as the dead-letter queue.  +  ``denyAll``: No source queues can specify this queue as the dead-letter queue.  +  ``byQueue``: Only queues specified by the ``sourceQueueArns`` parameter can specify this queue as the dead-letter queue.    +  ``sourceQueueArns``: The Amazon Resource Names (ARN)s of the source queues that can specify this queue as the dead-letter queue and redrive messages. You can specify this parameter only when the ``redrivePermission`` parameter is set to ``byQueue``. You can specify up to 10 source queue ARNs. To allow more than 10 source queues to specify dead-letter queues, set the ``redrivePermission`` parameter to ``allowAll``.
        """
        return pulumi.get(self, "redrive_allow_policy")

    @property
    @pulumi.getter(name="redrivePolicy")
    def redrive_policy(self) -> Optional[Any]:
        """
        The string that includes the parameters for the dead-letter queue functionality of the source queue as a JSON object. The parameters are as follows:  +  ``deadLetterTargetArn``: The Amazon Resource Name (ARN) of the dead-letter queue to which SQS moves messages after the value of ``maxReceiveCount`` is exceeded.  +  ``maxReceiveCount``: The number of times a message is delivered to the source queue before being moved to the dead-letter queue. When the ``ReceiveCount`` for a message exceeds the ``maxReceiveCount`` for a queue, SQS moves the message to the dead-letter-queue.    The dead-letter queue of a FIFO queue must also be a FIFO queue. Similarly, the dead-letter queue of a standard queue must also be a standard queue.   *JSON*   ``{ 'deadLetterTargetArn' : String, 'maxReceiveCount' : Integer }``   *YAML*   ``deadLetterTargetArn : String``   ``maxReceiveCount : Integer``
        """
        return pulumi.get(self, "redrive_policy")

    @property
    @pulumi.getter(name="sqsManagedSseEnabled")
    def sqs_managed_sse_enabled(self) -> Optional[bool]:
        """
        Enables server-side queue encryption using SQS owned encryption keys. Only one server-side encryption option is supported per queue (for example, [SSE-KMS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sse-existing-queue.html) or [SSE-SQS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-sqs-sse-queue.html)). When ``SqsManagedSseEnabled`` is not defined, ``SSE-SQS`` encryption is enabled by default.
        """
        return pulumi.get(self, "sqs_managed_sse_enabled")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The tags that you attach to this queue. For more information, see [Resource tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) in the *User Guide*.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> Optional[int]:
        """
        The length of time during which a message will be unavailable after a message is delivered from the queue. This blocks other components from receiving the same message and gives the initial component time to process and delete the message from the queue. Values must be from 0 to 43,200 seconds (12 hours). If you don't specify a value, AWS CloudFormation uses the default value of 30 seconds. For more information about SQS queue visibility timeouts, see [Visibility timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html) in the *Developer Guide*.
        """
        return pulumi.get(self, "visibility_timeout")


@pulumi.output_type
class AwsSsmInstanceInformationPropertiesResponse(dict):
    """
    Definition of awsSsmInstanceInformation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activationId":
            suggest = "activation_id"
        elif key == "agentVersion":
            suggest = "agent_version"
        elif key == "associationOverview":
            suggest = "association_overview"
        elif key == "associationStatus":
            suggest = "association_status"
        elif key == "computerName":
            suggest = "computer_name"
        elif key == "iamRole":
            suggest = "iam_role"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "isLatestVersion":
            suggest = "is_latest_version"
        elif key == "lastAssociationExecutionDate":
            suggest = "last_association_execution_date"
        elif key == "lastPingDateTime":
            suggest = "last_ping_date_time"
        elif key == "lastSuccessfulAssociationExecutionDate":
            suggest = "last_successful_association_execution_date"
        elif key == "pingStatus":
            suggest = "ping_status"
        elif key == "platformName":
            suggest = "platform_name"
        elif key == "platformType":
            suggest = "platform_type"
        elif key == "platformVersion":
            suggest = "platform_version"
        elif key == "registrationDate":
            suggest = "registration_date"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSsmInstanceInformationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSsmInstanceInformationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSsmInstanceInformationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activation_id: Optional[str] = None,
                 agent_version: Optional[str] = None,
                 association_overview: Optional['outputs.InstanceAggregatedAssociationOverviewResponse'] = None,
                 association_status: Optional[str] = None,
                 computer_name: Optional[str] = None,
                 iam_role: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 is_latest_version: Optional[bool] = None,
                 last_association_execution_date: Optional[str] = None,
                 last_ping_date_time: Optional[str] = None,
                 last_successful_association_execution_date: Optional[str] = None,
                 name: Optional[str] = None,
                 ping_status: Optional['outputs.PingStatusEnumValueResponse'] = None,
                 platform_name: Optional[str] = None,
                 platform_type: Optional['outputs.PlatformTypeEnumValueResponse'] = None,
                 platform_version: Optional[str] = None,
                 registration_date: Optional[str] = None,
                 resource_type: Optional['outputs.ResourceTypeEnumValueResponse'] = None,
                 source_id: Optional[str] = None,
                 source_type: Optional['outputs.SourceTypeEnumValueResponse'] = None):
        """
        Definition of awsSsmInstanceInformation
        :param str activation_id: <p>The activation ID created by Amazon Web Services Systems Manager when the server or virtual machine (VM) was registered.</p>
        :param str agent_version: <p>The version of SSM Agent running on your Linux managed node. </p>
        :param 'InstanceAggregatedAssociationOverviewResponse' association_overview: <p>Information about the association.</p>
        :param str association_status: <p>The status of the association.</p>
        :param str computer_name: <p>The fully qualified host name of the managed node.</p>
        :param str iam_role: <p>The Identity and Access Management (IAM) role assigned to the on-premises Systems Manager managed node. This call doesn't return the IAM role for Amazon Elastic Compute Cloud (Amazon EC2) instances. To retrieve the IAM role for an EC2 instance, use the Amazon EC2 <code>DescribeInstances</code> operation. For information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html'>DescribeInstances</a> in the <i>Amazon EC2 API Reference</i> or <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html'>describe-instances</a> in the <i>Amazon Web Services CLI Command Reference</i>.</p>
        :param str instance_id: <p>The managed node ID. </p>
        :param str ip_address: <p>The IP address of the managed node.</p>
        :param bool is_latest_version: <p>Indicates whether the latest version of SSM Agent is running on your Linux managed node. This field doesn't indicate whether or not the latest version is installed on Windows managed nodes, because some older versions of Windows Server use the EC2Config service to process Systems Manager requests.</p>
        :param str last_association_execution_date: <p>The date the association was last run.</p>
        :param str last_ping_date_time: <p>The date and time when the agent last pinged the Systems Manager service. </p>
        :param str last_successful_association_execution_date: <p>The last date the association was successfully run.</p>
        :param str name: <p>The name assigned to an on-premises server, edge device, or virtual machine (VM) when it is activated as a Systems Manager managed node. The name is specified as the <code>DefaultInstanceName</code> property using the <a>CreateActivation</a> command. It is applied to the managed node by specifying the Activation Code and Activation ID when you install SSM Agent on the node, as explained in <a href='https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-linux.html'>Install SSM Agent for a hybrid and multicloud environment (Linux)</a> and <a href='https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-win.html'>Install SSM Agent for a hybrid and multicloud environment (Windows)</a>. To retrieve the <code>Name</code> tag of an EC2 instance, use the Amazon EC2 <code>DescribeInstances</code> operation. For information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html'>DescribeInstances</a> in the <i>Amazon EC2 API Reference</i> or <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html'>describe-instances</a> in the <i>Amazon Web Services CLI Command Reference</i>.</p>
        :param 'PingStatusEnumValueResponse' ping_status: <p>Connection status of SSM Agent. </p> <note> <p>The status <code>Inactive</code> has been deprecated and is no longer in use.</p> </note>
        :param str platform_name: <p>The name of the operating system platform running on your managed node. </p>
        :param 'PlatformTypeEnumValueResponse' platform_type: <p>The operating system platform type. </p>
        :param str platform_version: <p>The version of the OS platform running on your managed node. </p>
        :param str registration_date: <p>The date the server or VM was registered with Amazon Web Services as a managed node.</p>
        :param 'ResourceTypeEnumValueResponse' resource_type: <p>The type of instance. Instances are either EC2 instances or managed instances. </p>
        :param str source_id: <p>The ID of the source resource. For IoT Greengrass devices, <code>SourceId</code> is the Thing name. </p>
        :param 'SourceTypeEnumValueResponse' source_type: <p>The type of the source resource. For IoT Greengrass devices, <code>SourceType</code> is <code>AWS::IoT::Thing</code>. </p>
        """
        if activation_id is not None:
            pulumi.set(__self__, "activation_id", activation_id)
        if agent_version is not None:
            pulumi.set(__self__, "agent_version", agent_version)
        if association_overview is not None:
            pulumi.set(__self__, "association_overview", association_overview)
        if association_status is not None:
            pulumi.set(__self__, "association_status", association_status)
        if computer_name is not None:
            pulumi.set(__self__, "computer_name", computer_name)
        if iam_role is not None:
            pulumi.set(__self__, "iam_role", iam_role)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_latest_version is not None:
            pulumi.set(__self__, "is_latest_version", is_latest_version)
        if last_association_execution_date is not None:
            pulumi.set(__self__, "last_association_execution_date", last_association_execution_date)
        if last_ping_date_time is not None:
            pulumi.set(__self__, "last_ping_date_time", last_ping_date_time)
        if last_successful_association_execution_date is not None:
            pulumi.set(__self__, "last_successful_association_execution_date", last_successful_association_execution_date)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ping_status is not None:
            pulumi.set(__self__, "ping_status", ping_status)
        if platform_name is not None:
            pulumi.set(__self__, "platform_name", platform_name)
        if platform_type is not None:
            pulumi.set(__self__, "platform_type", platform_type)
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if registration_date is not None:
            pulumi.set(__self__, "registration_date", registration_date)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> Optional[str]:
        """
        <p>The activation ID created by Amazon Web Services Systems Manager when the server or virtual machine (VM) was registered.</p>
        """
        return pulumi.get(self, "activation_id")

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> Optional[str]:
        """
        <p>The version of SSM Agent running on your Linux managed node. </p>
        """
        return pulumi.get(self, "agent_version")

    @property
    @pulumi.getter(name="associationOverview")
    def association_overview(self) -> Optional['outputs.InstanceAggregatedAssociationOverviewResponse']:
        """
        <p>Information about the association.</p>
        """
        return pulumi.get(self, "association_overview")

    @property
    @pulumi.getter(name="associationStatus")
    def association_status(self) -> Optional[str]:
        """
        <p>The status of the association.</p>
        """
        return pulumi.get(self, "association_status")

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> Optional[str]:
        """
        <p>The fully qualified host name of the managed node.</p>
        """
        return pulumi.get(self, "computer_name")

    @property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> Optional[str]:
        """
        <p>The Identity and Access Management (IAM) role assigned to the on-premises Systems Manager managed node. This call doesn't return the IAM role for Amazon Elastic Compute Cloud (Amazon EC2) instances. To retrieve the IAM role for an EC2 instance, use the Amazon EC2 <code>DescribeInstances</code> operation. For information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html'>DescribeInstances</a> in the <i>Amazon EC2 API Reference</i> or <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html'>describe-instances</a> in the <i>Amazon Web Services CLI Command Reference</i>.</p>
        """
        return pulumi.get(self, "iam_role")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        <p>The managed node ID. </p>
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        <p>The IP address of the managed node.</p>
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="isLatestVersion")
    def is_latest_version(self) -> Optional[bool]:
        """
        <p>Indicates whether the latest version of SSM Agent is running on your Linux managed node. This field doesn't indicate whether or not the latest version is installed on Windows managed nodes, because some older versions of Windows Server use the EC2Config service to process Systems Manager requests.</p>
        """
        return pulumi.get(self, "is_latest_version")

    @property
    @pulumi.getter(name="lastAssociationExecutionDate")
    def last_association_execution_date(self) -> Optional[str]:
        """
        <p>The date the association was last run.</p>
        """
        return pulumi.get(self, "last_association_execution_date")

    @property
    @pulumi.getter(name="lastPingDateTime")
    def last_ping_date_time(self) -> Optional[str]:
        """
        <p>The date and time when the agent last pinged the Systems Manager service. </p>
        """
        return pulumi.get(self, "last_ping_date_time")

    @property
    @pulumi.getter(name="lastSuccessfulAssociationExecutionDate")
    def last_successful_association_execution_date(self) -> Optional[str]:
        """
        <p>The last date the association was successfully run.</p>
        """
        return pulumi.get(self, "last_successful_association_execution_date")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name assigned to an on-premises server, edge device, or virtual machine (VM) when it is activated as a Systems Manager managed node. The name is specified as the <code>DefaultInstanceName</code> property using the <a>CreateActivation</a> command. It is applied to the managed node by specifying the Activation Code and Activation ID when you install SSM Agent on the node, as explained in <a href='https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-linux.html'>Install SSM Agent for a hybrid and multicloud environment (Linux)</a> and <a href='https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-install-managed-win.html'>Install SSM Agent for a hybrid and multicloud environment (Windows)</a>. To retrieve the <code>Name</code> tag of an EC2 instance, use the Amazon EC2 <code>DescribeInstances</code> operation. For information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html'>DescribeInstances</a> in the <i>Amazon EC2 API Reference</i> or <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html'>describe-instances</a> in the <i>Amazon Web Services CLI Command Reference</i>.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pingStatus")
    def ping_status(self) -> Optional['outputs.PingStatusEnumValueResponse']:
        """
        <p>Connection status of SSM Agent. </p> <note> <p>The status <code>Inactive</code> has been deprecated and is no longer in use.</p> </note>
        """
        return pulumi.get(self, "ping_status")

    @property
    @pulumi.getter(name="platformName")
    def platform_name(self) -> Optional[str]:
        """
        <p>The name of the operating system platform running on your managed node. </p>
        """
        return pulumi.get(self, "platform_name")

    @property
    @pulumi.getter(name="platformType")
    def platform_type(self) -> Optional['outputs.PlatformTypeEnumValueResponse']:
        """
        <p>The operating system platform type. </p>
        """
        return pulumi.get(self, "platform_type")

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[str]:
        """
        <p>The version of the OS platform running on your managed node. </p>
        """
        return pulumi.get(self, "platform_version")

    @property
    @pulumi.getter(name="registrationDate")
    def registration_date(self) -> Optional[str]:
        """
        <p>The date the server or VM was registered with Amazon Web Services as a managed node.</p>
        """
        return pulumi.get(self, "registration_date")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional['outputs.ResourceTypeEnumValueResponse']:
        """
        <p>The type of instance. Instances are either EC2 instances or managed instances. </p>
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[str]:
        """
        <p>The ID of the source resource. For IoT Greengrass devices, <code>SourceId</code> is the Thing name. </p>
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional['outputs.SourceTypeEnumValueResponse']:
        """
        <p>The type of the source resource. For IoT Greengrass devices, <code>SourceType</code> is <code>AWS::IoT::Thing</code>. </p>
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class AwsSsmParameterPropertiesResponse(dict):
    """
    Definition of awsSsmParameter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedPattern":
            suggest = "allowed_pattern"
        elif key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSsmParameterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSsmParameterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSsmParameterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_pattern: Optional[str] = None,
                 data_type: Optional[str] = None,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 policies: Optional[str] = None,
                 tags: Optional[Any] = None,
                 tier: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of awsSsmParameter
        :param str allowed_pattern: A regular expression used to validate the parameter value. For example, for ``String`` types with values restricted to numbers, you can specify the following: ``AllowedPattern=^\\d+$``
        :param str data_type: The data type of the parameter, such as ``text`` or ``aws:ec2:image``. The default is ``text``.
        :param str description: Information about the parameter.
        :param str name: The name of the parameter.  The maximum length constraint listed below includes capacity for additional system attributes that aren't part of the name. The maximum length for a parameter name, including the full length of the parameter Amazon Resource Name (ARN), is 1011 characters. For example, the length of the following parameter name is 65 characters, not 20 characters: ``arn:aws:ssm:us-east-2:111222333444:parameter/ExampleParameterName``
        :param str policies: Information about the policies assigned to a parameter.  [Assigning parameter policies](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html) in the *User Guide*.
        :param Any tags: Optional metadata that you assign to a resource in the form of an arbitrary set of tags (key-value pairs). Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a SYS parameter to identify the type of resource to which it applies, the environment, or the type of configuration data referenced by the parameter.
        :param str tier: The parameter tier.
        :param str type: The type of parameter.
        :param str value: The parameter value.  If type is ``StringList``, the system returns a comma-separated string with no spaces between commas in the ``Value`` field.
        """
        if allowed_pattern is not None:
            pulumi.set(__self__, "allowed_pattern", allowed_pattern)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="allowedPattern")
    def allowed_pattern(self) -> Optional[str]:
        """
        A regular expression used to validate the parameter value. For example, for ``String`` types with values restricted to numbers, you can specify the following: ``AllowedPattern=^\\d+$``
        """
        return pulumi.get(self, "allowed_pattern")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        The data type of the parameter, such as ``text`` or ``aws:ec2:image``. The default is ``text``.
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Information about the parameter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the parameter.  The maximum length constraint listed below includes capacity for additional system attributes that aren't part of the name. The maximum length for a parameter name, including the full length of the parameter Amazon Resource Name (ARN), is 1011 characters. For example, the length of the following parameter name is 65 characters, not 20 characters: ``arn:aws:ssm:us-east-2:111222333444:parameter/ExampleParameterName``
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def policies(self) -> Optional[str]:
        """
        Information about the policies assigned to a parameter.  [Assigning parameter policies](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html) in the *User Guide*.
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Any]:
        """
        Optional metadata that you assign to a resource in the form of an arbitrary set of tags (key-value pairs). Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a SYS parameter to identify the type of resource to which it applies, the environment, or the type of configuration data referenced by the parameter.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        The parameter tier.
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of parameter.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The parameter value.  If type is ``StringList``, the system returns a comma-separated string with no spaces between commas in the ``Value`` field.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsSsmResourceComplianceSummaryItemPropertiesResponse(dict):
    """
    Definition of awsSsmResourceComplianceSummaryItem
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "complianceType":
            suggest = "compliance_type"
        elif key == "compliantSummary":
            suggest = "compliant_summary"
        elif key == "executionSummary":
            suggest = "execution_summary"
        elif key == "nonCompliantSummary":
            suggest = "non_compliant_summary"
        elif key == "overallSeverity":
            suggest = "overall_severity"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSsmResourceComplianceSummaryItemPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSsmResourceComplianceSummaryItemPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSsmResourceComplianceSummaryItemPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compliance_type: Optional[str] = None,
                 compliant_summary: Optional['outputs.CompliantSummaryResponse'] = None,
                 execution_summary: Optional['outputs.ComplianceExecutionSummaryResponse'] = None,
                 non_compliant_summary: Optional['outputs.NonCompliantSummaryResponse'] = None,
                 overall_severity: Optional['outputs.ComplianceSeverityEnumValueResponse'] = None,
                 resource_id: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 status: Optional['outputs.ComplianceStatusEnumValueResponse'] = None):
        """
        Definition of awsSsmResourceComplianceSummaryItem
        :param str compliance_type: <p>The compliance type.</p>
        :param 'CompliantSummaryResponse' compliant_summary: <p>A list of items that are compliant for the resource.</p>
        :param 'ComplianceExecutionSummaryResponse' execution_summary: <p>Information about the execution.</p>
        :param 'NonCompliantSummaryResponse' non_compliant_summary: <p>A list of items that aren't compliant for the resource.</p>
        :param 'ComplianceSeverityEnumValueResponse' overall_severity: <p>The highest severity item found for the resource. The resource is compliant for this item.</p>
        :param str resource_id: <p>The resource ID.</p>
        :param str resource_type: <p>The resource type.</p>
        :param 'ComplianceStatusEnumValueResponse' status: <p>The compliance status for the resource.</p>
        """
        if compliance_type is not None:
            pulumi.set(__self__, "compliance_type", compliance_type)
        if compliant_summary is not None:
            pulumi.set(__self__, "compliant_summary", compliant_summary)
        if execution_summary is not None:
            pulumi.set(__self__, "execution_summary", execution_summary)
        if non_compliant_summary is not None:
            pulumi.set(__self__, "non_compliant_summary", non_compliant_summary)
        if overall_severity is not None:
            pulumi.set(__self__, "overall_severity", overall_severity)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="complianceType")
    def compliance_type(self) -> Optional[str]:
        """
        <p>The compliance type.</p>
        """
        return pulumi.get(self, "compliance_type")

    @property
    @pulumi.getter(name="compliantSummary")
    def compliant_summary(self) -> Optional['outputs.CompliantSummaryResponse']:
        """
        <p>A list of items that are compliant for the resource.</p>
        """
        return pulumi.get(self, "compliant_summary")

    @property
    @pulumi.getter(name="executionSummary")
    def execution_summary(self) -> Optional['outputs.ComplianceExecutionSummaryResponse']:
        """
        <p>Information about the execution.</p>
        """
        return pulumi.get(self, "execution_summary")

    @property
    @pulumi.getter(name="nonCompliantSummary")
    def non_compliant_summary(self) -> Optional['outputs.NonCompliantSummaryResponse']:
        """
        <p>A list of items that aren't compliant for the resource.</p>
        """
        return pulumi.get(self, "non_compliant_summary")

    @property
    @pulumi.getter(name="overallSeverity")
    def overall_severity(self) -> Optional['outputs.ComplianceSeverityEnumValueResponse']:
        """
        <p>The highest severity item found for the resource. The resource is compliant for this item.</p>
        """
        return pulumi.get(self, "overall_severity")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        <p>The resource ID.</p>
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        <p>The resource type.</p>
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.ComplianceStatusEnumValueResponse']:
        """
        <p>The compliance status for the resource.</p>
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AwsVpcConfigurationResponse(dict):
    """
    Definition of AwsVpcConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsVpcConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsVpcConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsVpcConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_public_ip: Optional[str] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 subnets: Optional[Sequence[str]] = None):
        """
        Definition of AwsVpcConfiguration
        :param str assign_public_ip: Whether the task's elastic network interface receives a public IP address. The default value is ``DISABLED``.
        :param Sequence[str] security_groups: The IDs of the security groups associated with the task or service. If you don't specify a security group, the default security group for the VPC is used. There's a limit of 5 security groups that can be specified per ``AwsVpcConfiguration``.  All specified security groups must be from the same VPC.
        :param Sequence[str] subnets: The IDs of the subnets associated with the task or service. There's a limit of 16 subnets that can be specified per ``AwsVpcConfiguration``.  All specified subnets must be from the same VPC.
        """
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[str]:
        """
        Whether the task's elastic network interface receives a public IP address. The default value is ``DISABLED``.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        The IDs of the security groups associated with the task or service. If you don't specify a security group, the default security group for the VPC is used. There's a limit of 5 security groups that can be specified per ``AwsVpcConfiguration``.  All specified security groups must be from the same VPC.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        """
        The IDs of the subnets associated with the task or service. There's a limit of 16 subnets that can be specified per ``AwsVpcConfiguration``.  All specified subnets must be from the same VPC.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class AwsWafWebACLSummaryPropertiesResponse(dict):
    """
    Definition of awsWafWebACLSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webACLId":
            suggest = "web_acl_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsWafWebACLSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsWafWebACLSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsWafWebACLSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 web_acl_id: Optional[str] = None):
        """
        Definition of awsWafWebACLSummary
        :param str name: <p>A friendly name or description of the <a>WebACL</a>. You can't change the name of a <code>WebACL</code> after you create it.</p>
        :param str web_acl_id: <p>A unique identifier for a <code>WebACL</code>. You use <code>WebACLId</code> to get information about a <code>WebACL</code> (see <a>GetWebACL</a>), update a <code>WebACL</code> (see <a>UpdateWebACL</a>), and delete a <code>WebACL</code> from AWS WAF (see <a>DeleteWebACL</a>).</p> <p> <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by <a>ListWebACLs</a>.</p>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if web_acl_id is not None:
            pulumi.set(__self__, "web_acl_id", web_acl_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>A friendly name or description of the <a>WebACL</a>. You can't change the name of a <code>WebACL</code> after you create it.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="webACLId")
    def web_acl_id(self) -> Optional[str]:
        """
        <p>A unique identifier for a <code>WebACL</code>. You use <code>WebACLId</code> to get information about a <code>WebACL</code> (see <a>GetWebACL</a>), update a <code>WebACL</code> (see <a>UpdateWebACL</a>), and delete a <code>WebACL</code> from AWS WAF (see <a>DeleteWebACL</a>).</p> <p> <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by <a>ListWebACLs</a>.</p>
        """
        return pulumi.get(self, "web_acl_id")


@pulumi.output_type
class AwsWafv2LoggingConfigurationPropertiesResponse(dict):
    """
    Definition of awsWafv2LoggingConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logDestinationConfigs":
            suggest = "log_destination_configs"
        elif key == "loggingFilter":
            suggest = "logging_filter"
        elif key == "managedByFirewallManager":
            suggest = "managed_by_firewall_manager"
        elif key == "redactedFields":
            suggest = "redacted_fields"
        elif key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsWafv2LoggingConfigurationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsWafv2LoggingConfigurationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsWafv2LoggingConfigurationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_destination_configs: Optional[Sequence[str]] = None,
                 logging_filter: Optional['outputs.LoggingFilterModelPropertiesResponse'] = None,
                 managed_by_firewall_manager: Optional[bool] = None,
                 redacted_fields: Optional[Sequence['outputs.FieldToMatchResponse']] = None,
                 resource_arn: Optional[str] = None):
        """
        Definition of awsWafv2LoggingConfiguration
        :param Sequence[str] log_destination_configs: The Amazon Resource Names (ARNs) of the logging destinations that you want to associate with the web ACL.
        :param 'LoggingFilterModelPropertiesResponse' logging_filter: Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
        :param bool managed_by_firewall_manager: Indicates whether the logging configuration was created by AWS Firewall Manager, as part of an AWS WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration.
        :param Sequence['FieldToMatchResponse'] redacted_fields: The parts of the request that you want to keep out of the logs. For example, if you redact the HEADER field, the HEADER field in the firehose will be xxx.
        :param str resource_arn: The Amazon Resource Name (ARN) of the web ACL that you want to associate with LogDestinationConfigs.
        """
        if log_destination_configs is not None:
            pulumi.set(__self__, "log_destination_configs", log_destination_configs)
        if logging_filter is not None:
            pulumi.set(__self__, "logging_filter", logging_filter)
        if managed_by_firewall_manager is not None:
            pulumi.set(__self__, "managed_by_firewall_manager", managed_by_firewall_manager)
        if redacted_fields is not None:
            pulumi.set(__self__, "redacted_fields", redacted_fields)
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)

    @property
    @pulumi.getter(name="logDestinationConfigs")
    def log_destination_configs(self) -> Optional[Sequence[str]]:
        """
        The Amazon Resource Names (ARNs) of the logging destinations that you want to associate with the web ACL.
        """
        return pulumi.get(self, "log_destination_configs")

    @property
    @pulumi.getter(name="loggingFilter")
    def logging_filter(self) -> Optional['outputs.LoggingFilterModelPropertiesResponse']:
        """
        Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
        """
        return pulumi.get(self, "logging_filter")

    @property
    @pulumi.getter(name="managedByFirewallManager")
    def managed_by_firewall_manager(self) -> Optional[bool]:
        """
        Indicates whether the logging configuration was created by AWS Firewall Manager, as part of an AWS WAF policy configuration. If true, only Firewall Manager can modify or delete the configuration.
        """
        return pulumi.get(self, "managed_by_firewall_manager")

    @property
    @pulumi.getter(name="redactedFields")
    def redacted_fields(self) -> Optional[Sequence['outputs.FieldToMatchResponse']]:
        """
        The parts of the request that you want to keep out of the logs. For example, if you redact the HEADER field, the HEADER field in the firehose will be xxx.
        """
        return pulumi.get(self, "redacted_fields")

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the web ACL that you want to associate with LogDestinationConfigs.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class BackupPolicyResponse(dict):
    """
    Definition of BackupPolicy
    """
    def __init__(__self__, *,
                 status: Optional[str] = None):
        """
        Definition of BackupPolicy
        :param str status: Set the backup policy status for the file system.  +   *ENABLED* - Turns automatic backups on for the file system.   +   *DISABLED* - Turns automatic backups off for the file system.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Set the backup policy status for the file system.  +   *ENABLED* - Turns automatic backups on for the file system.   +   *DISABLED* - Turns automatic backups off for the file system.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class BaselineEbsBandwidthMbpsRequestResponse(dict):
    """
    Definition of BaselineEbsBandwidthMbpsRequest
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Definition of BaselineEbsBandwidthMbpsRequest
        :param int max: The maximum value in Mbps.
        :param int min: The minimum value in Mbps.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum value in Mbps.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum value in Mbps.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class BatchReportModeTypeEnumValueResponse(dict):
    """
    Definition of BatchReportModeTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of BatchReportModeTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BatchRestrictionsResponse(dict):
    """
    Definition of BatchRestrictions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeTypesAllowed":
            suggest = "compute_types_allowed"
        elif key == "maximumBuildsAllowed":
            suggest = "maximum_builds_allowed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchRestrictionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchRestrictionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchRestrictionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_types_allowed: Optional[Sequence[str]] = None,
                 maximum_builds_allowed: Optional[int] = None):
        """
        Definition of BatchRestrictions
        :param Sequence[str] compute_types_allowed: <p>An array of strings that specify the compute types that are allowed for the batch build. See <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html'>Build environment compute types</a> in the <i>CodeBuild User Guide</i> for these values. </p>
        :param int maximum_builds_allowed: <p>Specifies the maximum number of builds allowed.</p>
        """
        if compute_types_allowed is not None:
            pulumi.set(__self__, "compute_types_allowed", compute_types_allowed)
        if maximum_builds_allowed is not None:
            pulumi.set(__self__, "maximum_builds_allowed", maximum_builds_allowed)

    @property
    @pulumi.getter(name="computeTypesAllowed")
    def compute_types_allowed(self) -> Optional[Sequence[str]]:
        """
        <p>An array of strings that specify the compute types that are allowed for the batch build. See <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html'>Build environment compute types</a> in the <i>CodeBuild User Guide</i> for these values. </p>
        """
        return pulumi.get(self, "compute_types_allowed")

    @property
    @pulumi.getter(name="maximumBuildsAllowed")
    def maximum_builds_allowed(self) -> Optional[int]:
        """
        <p>Specifies the maximum number of builds allowed.</p>
        """
        return pulumi.get(self, "maximum_builds_allowed")


@pulumi.output_type
class BlockDeviceMappingResponse(dict):
    """
    Definition of BlockDeviceMapping
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlockDeviceMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlockDeviceMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlockDeviceMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 ebs: Optional['outputs.EbsBlockDeviceResponse'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        """
        Definition of BlockDeviceMapping
        :param str device_name: <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        :param 'EbsBlockDeviceResponse' ebs: <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
        :param str no_device: <p>To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.</p>
        :param str virtual_name: <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.EbsBlockDeviceResponse']:
        """
        <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
        """
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        """
        <p>To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.</p>
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class BootModeValuesEnumValueResponse(dict):
    """
    Definition of BootModeValuesEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of BootModeValuesEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BucketEncryptionResponse(dict):
    """
    Definition of BucketEncryption
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverSideEncryptionConfiguration":
            suggest = "server_side_encryption_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BucketEncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BucketEncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BucketEncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_side_encryption_configuration: Optional[Sequence['outputs.ServerSideEncryptionRuleResponse']] = None):
        """
        Definition of BucketEncryption
        :param Sequence['ServerSideEncryptionRuleResponse'] server_side_encryption_configuration: Specifies the default server-side-encryption configuration.
        """
        if server_side_encryption_configuration is not None:
            pulumi.set(__self__, "server_side_encryption_configuration", server_side_encryption_configuration)

    @property
    @pulumi.getter(name="serverSideEncryptionConfiguration")
    def server_side_encryption_configuration(self) -> Optional[Sequence['outputs.ServerSideEncryptionRuleResponse']]:
        """
        Specifies the default server-side-encryption configuration.
        """
        return pulumi.get(self, "server_side_encryption_configuration")


@pulumi.output_type
class BucketOwnerAccessEnumValueResponse(dict):
    """
    Definition of BucketOwnerAccessEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of BucketOwnerAccessEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BuildStatusConfigResponse(dict):
    """
    Definition of BuildStatusConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetUrl":
            suggest = "target_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildStatusConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildStatusConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildStatusConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context: Optional[str] = None,
                 target_url: Optional[str] = None):
        """
        Definition of BuildStatusConfig
        :param str context: <p>Specifies the context of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.</p> <dl> <dt>Bitbucket</dt> <dd> <p>This parameter is used for the <code>name</code> parameter in the Bitbucket commit status. For more information, see <a href='https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build'>build</a> in the Bitbucket API documentation.</p> </dd> <dt>GitHub/GitHub Enterprise Server</dt> <dd> <p>This parameter is used for the <code>context</code> parameter in the GitHub commit status. For more information, see <a href='https://developer.github.com/v3/repos/statuses/#create-a-commit-status'>Create a commit status</a> in the GitHub developer guide.</p> </dd> </dl>
        :param str target_url: <p>Specifies the target url of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.</p> <dl> <dt>Bitbucket</dt> <dd> <p>This parameter is used for the <code>url</code> parameter in the Bitbucket commit status. For more information, see <a href='https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build'>build</a> in the Bitbucket API documentation.</p> </dd> <dt>GitHub/GitHub Enterprise Server</dt> <dd> <p>This parameter is used for the <code>target_url</code> parameter in the GitHub commit status. For more information, see <a href='https://developer.github.com/v3/repos/statuses/#create-a-commit-status'>Create a commit status</a> in the GitHub developer guide.</p> </dd> </dl>
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if target_url is not None:
            pulumi.set(__self__, "target_url", target_url)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        <p>Specifies the context of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.</p> <dl> <dt>Bitbucket</dt> <dd> <p>This parameter is used for the <code>name</code> parameter in the Bitbucket commit status. For more information, see <a href='https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build'>build</a> in the Bitbucket API documentation.</p> </dd> <dt>GitHub/GitHub Enterprise Server</dt> <dd> <p>This parameter is used for the <code>context</code> parameter in the GitHub commit status. For more information, see <a href='https://developer.github.com/v3/repos/statuses/#create-a-commit-status'>Create a commit status</a> in the GitHub developer guide.</p> </dd> </dl>
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> Optional[str]:
        """
        <p>Specifies the target url of the build status CodeBuild sends to the source provider. The usage of this parameter depends on the source provider.</p> <dl> <dt>Bitbucket</dt> <dd> <p>This parameter is used for the <code>url</code> parameter in the Bitbucket commit status. For more information, see <a href='https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Bworkspace%7D/%7Brepo_slug%7D/commit/%7Bnode%7D/statuses/build'>build</a> in the Bitbucket API documentation.</p> </dd> <dt>GitHub/GitHub Enterprise Server</dt> <dd> <p>This parameter is used for the <code>target_url</code> parameter in the GitHub commit status. For more information, see <a href='https://developer.github.com/v3/repos/statuses/#create-a-commit-status'>Create a commit status</a> in the GitHub developer guide.</p> </dd> </dl>
        """
        return pulumi.get(self, "target_url")


@pulumi.output_type
class CFNDataSourceConfigurationsResponse(dict):
    """
    Definition of CFNDataSourceConfigurations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "malwareProtection":
            suggest = "malware_protection"
        elif key == "s3Logs":
            suggest = "s3_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CFNDataSourceConfigurationsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CFNDataSourceConfigurationsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CFNDataSourceConfigurationsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kubernetes: Optional['outputs.CFNKubernetesConfigurationResponse'] = None,
                 malware_protection: Optional['outputs.CFNMalwareProtectionConfigurationResponse'] = None,
                 s3_logs: Optional['outputs.CFNS3LogsConfigurationResponse'] = None):
        """
        Definition of CFNDataSourceConfigurations
        :param 'CFNKubernetesConfigurationResponse' kubernetes: Property kubernetes
        :param 'CFNMalwareProtectionConfigurationResponse' malware_protection: Property malwareProtection
        :param 'CFNS3LogsConfigurationResponse' s3_logs: Property s3Logs
        """
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)
        if malware_protection is not None:
            pulumi.set(__self__, "malware_protection", malware_protection)
        if s3_logs is not None:
            pulumi.set(__self__, "s3_logs", s3_logs)

    @property
    @pulumi.getter
    def kubernetes(self) -> Optional['outputs.CFNKubernetesConfigurationResponse']:
        """
        Property kubernetes
        """
        return pulumi.get(self, "kubernetes")

    @property
    @pulumi.getter(name="malwareProtection")
    def malware_protection(self) -> Optional['outputs.CFNMalwareProtectionConfigurationResponse']:
        """
        Property malwareProtection
        """
        return pulumi.get(self, "malware_protection")

    @property
    @pulumi.getter(name="s3Logs")
    def s3_logs(self) -> Optional['outputs.CFNS3LogsConfigurationResponse']:
        """
        Property s3Logs
        """
        return pulumi.get(self, "s3_logs")


@pulumi.output_type
class CFNFeatureAdditionalConfigurationResponse(dict):
    """
    Definition of CFNFeatureAdditionalConfiguration
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 status: Optional[str] = None):
        """
        Definition of CFNFeatureAdditionalConfiguration
        :param str name: Property name
        :param str status: Property status
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Property name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Property status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class CFNFeatureConfigurationResponse(dict):
    """
    Definition of CFNFeatureConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalConfiguration":
            suggest = "additional_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CFNFeatureConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CFNFeatureConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CFNFeatureConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_configuration: Optional[Sequence['outputs.CFNFeatureAdditionalConfigurationResponse']] = None,
                 name: Optional[str] = None,
                 status: Optional[str] = None):
        """
        Definition of CFNFeatureConfiguration
        :param Sequence['CFNFeatureAdditionalConfigurationResponse'] additional_configuration: Property additionalConfiguration
        :param str name: Property name
        :param str status: Property status
        """
        if additional_configuration is not None:
            pulumi.set(__self__, "additional_configuration", additional_configuration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="additionalConfiguration")
    def additional_configuration(self) -> Optional[Sequence['outputs.CFNFeatureAdditionalConfigurationResponse']]:
        """
        Property additionalConfiguration
        """
        return pulumi.get(self, "additional_configuration")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Property name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Property status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class CFNKubernetesAuditLogsConfigurationResponse(dict):
    """
    Definition of CFNKubernetesAuditLogsConfiguration
    """
    def __init__(__self__, *,
                 enable: Optional[bool] = None):
        """
        Definition of CFNKubernetesAuditLogsConfiguration
        :param bool enable: Property enable
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Property enable
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class CFNKubernetesConfigurationResponse(dict):
    """
    Definition of CFNKubernetesConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditLogs":
            suggest = "audit_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CFNKubernetesConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CFNKubernetesConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CFNKubernetesConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_logs: Optional['outputs.CFNKubernetesAuditLogsConfigurationResponse'] = None):
        """
        Definition of CFNKubernetesConfiguration
        :param 'CFNKubernetesAuditLogsConfigurationResponse' audit_logs: Property auditLogs
        """
        if audit_logs is not None:
            pulumi.set(__self__, "audit_logs", audit_logs)

    @property
    @pulumi.getter(name="auditLogs")
    def audit_logs(self) -> Optional['outputs.CFNKubernetesAuditLogsConfigurationResponse']:
        """
        Property auditLogs
        """
        return pulumi.get(self, "audit_logs")


@pulumi.output_type
class CFNMalwareProtectionConfigurationResponse(dict):
    """
    Definition of CFNMalwareProtectionConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scanEc2InstanceWithFindings":
            suggest = "scan_ec2_instance_with_findings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CFNMalwareProtectionConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CFNMalwareProtectionConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CFNMalwareProtectionConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scan_ec2_instance_with_findings: Optional['outputs.CFNScanEc2InstanceWithFindingsConfigurationResponse'] = None):
        """
        Definition of CFNMalwareProtectionConfiguration
        :param 'CFNScanEc2InstanceWithFindingsConfigurationResponse' scan_ec2_instance_with_findings: Property scanEc2InstanceWithFindings
        """
        if scan_ec2_instance_with_findings is not None:
            pulumi.set(__self__, "scan_ec2_instance_with_findings", scan_ec2_instance_with_findings)

    @property
    @pulumi.getter(name="scanEc2InstanceWithFindings")
    def scan_ec2_instance_with_findings(self) -> Optional['outputs.CFNScanEc2InstanceWithFindingsConfigurationResponse']:
        """
        Property scanEc2InstanceWithFindings
        """
        return pulumi.get(self, "scan_ec2_instance_with_findings")


@pulumi.output_type
class CFNS3LogsConfigurationResponse(dict):
    """
    Definition of CFNS3LogsConfiguration
    """
    def __init__(__self__, *,
                 enable: Optional[bool] = None):
        """
        Definition of CFNS3LogsConfiguration
        :param bool enable: Property enable
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Property enable
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class CFNScanEc2InstanceWithFindingsConfigurationResponse(dict):
    """
    Definition of CFNScanEc2InstanceWithFindingsConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumes":
            suggest = "ebs_volumes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CFNScanEc2InstanceWithFindingsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CFNScanEc2InstanceWithFindingsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CFNScanEc2InstanceWithFindingsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ebs_volumes: Optional[bool] = None):
        """
        Definition of CFNScanEc2InstanceWithFindingsConfiguration
        :param bool ebs_volumes: Property ebsVolumes
        """
        if ebs_volumes is not None:
            pulumi.set(__self__, "ebs_volumes", ebs_volumes)

    @property
    @pulumi.getter(name="ebsVolumes")
    def ebs_volumes(self) -> Optional[bool]:
        """
        Property ebsVolumes
        """
        return pulumi.get(self, "ebs_volumes")


@pulumi.output_type
class CacheBehaviorResponse(dict):
    """
    Definition of CacheBehavior
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "cachePolicyId":
            suggest = "cache_policy_id"
        elif key == "cachedMethods":
            suggest = "cached_methods"
        elif key == "defaultTTL":
            suggest = "default_ttl"
        elif key == "fieldLevelEncryptionId":
            suggest = "field_level_encryption_id"
        elif key == "forwardedValues":
            suggest = "forwarded_values"
        elif key == "functionAssociations":
            suggest = "function_associations"
        elif key == "lambdaFunctionAssociations":
            suggest = "lambda_function_associations"
        elif key == "maxTTL":
            suggest = "max_ttl"
        elif key == "minTTL":
            suggest = "min_ttl"
        elif key == "originRequestPolicyId":
            suggest = "origin_request_policy_id"
        elif key == "pathPattern":
            suggest = "path_pattern"
        elif key == "realtimeLogConfigArn":
            suggest = "realtime_log_config_arn"
        elif key == "responseHeadersPolicyId":
            suggest = "response_headers_policy_id"
        elif key == "smoothStreaming":
            suggest = "smooth_streaming"
        elif key == "targetOriginId":
            suggest = "target_origin_id"
        elif key == "trustedKeyGroups":
            suggest = "trusted_key_groups"
        elif key == "trustedSigners":
            suggest = "trusted_signers"
        elif key == "viewerProtocolPolicy":
            suggest = "viewer_protocol_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheBehaviorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheBehaviorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheBehaviorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Optional[Sequence[str]] = None,
                 cache_policy_id: Optional[str] = None,
                 cached_methods: Optional[Sequence[str]] = None,
                 compress: Optional[bool] = None,
                 default_ttl: Optional[int] = None,
                 field_level_encryption_id: Optional[str] = None,
                 forwarded_values: Optional['outputs.ForwardedValuesResponse'] = None,
                 function_associations: Optional[Sequence['outputs.FunctionAssociationResponse']] = None,
                 lambda_function_associations: Optional[Sequence['outputs.LambdaFunctionAssociationResponse']] = None,
                 max_ttl: Optional[int] = None,
                 min_ttl: Optional[int] = None,
                 origin_request_policy_id: Optional[str] = None,
                 path_pattern: Optional[str] = None,
                 realtime_log_config_arn: Optional[str] = None,
                 response_headers_policy_id: Optional[str] = None,
                 smooth_streaming: Optional[bool] = None,
                 target_origin_id: Optional[str] = None,
                 trusted_key_groups: Optional[Sequence[str]] = None,
                 trusted_signers: Optional[Sequence[str]] = None,
                 viewer_protocol_policy: Optional[str] = None):
        """
        Definition of CacheBehavior
        :param Sequence[str] allowed_methods: A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:  +  CloudFront forwards only ``GET`` and ``HEAD`` requests.  +  CloudFront forwards only ``GET``, ``HEAD``, and ``OPTIONS`` requests.  +  CloudFront forwards ``GET, HEAD, OPTIONS, PUT, PATCH, POST``, and ``DELETE`` requests.   If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        :param str cache_policy_id: The unique identifier of the cache policy that is attached to this cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. A ``CacheBehavior`` must include either a ``CachePolicyId`` or ``ForwardedValues``. We recommend that you use a ``CachePolicyId``.
        :param Sequence[str] cached_methods: A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:  +  CloudFront caches responses to ``GET`` and ``HEAD`` requests.  +  CloudFront caches responses to ``GET``, ``HEAD``, and ``OPTIONS`` requests.   If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
        :param bool compress: Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the *Amazon CloudFront Developer Guide*.
        :param int default_ttl: This field is deprecated. We recommend that you use the ``DefaultTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as ``Cache-Control max-age``, ``Cache-Control s-maxage``, and ``Expires`` to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        :param str field_level_encryption_id: The value of ``ID`` for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for this cache behavior.
        :param 'ForwardedValuesResponse' forwarded_values: This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the *Amazon CloudFront Developer Guide*. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the *Amazon CloudFront Developer Guide*. A ``CacheBehavior`` must include either a ``CachePolicyId`` or ``ForwardedValues``. We recommend that you use a ``CachePolicyId``. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers. This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        :param Sequence['FunctionAssociationResponse'] function_associations: A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the ``LIVE`` stage to associate them with a cache behavior.
        :param Sequence['LambdaFunctionAssociationResponse'] lambda_function_associations: A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        :param int max_ttl: This field is deprecated. We recommend that you use the ``MaxTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as ``Cache-Control max-age``, ``Cache-Control s-maxage``, and ``Expires`` to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        :param int min_ttl: This field is deprecated. We recommend that you use the ``MinTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*. You must specify ``0`` for ``MinTTL`` if you configure CloudFront to forward all headers to your origin (under ``Headers``, if you specify ``1`` for ``Quantity`` and ``*`` for ``Name``).
        :param str origin_request_policy_id: The unique identifier of the origin request policy that is attached to this cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the *Amazon CloudFront Developer Guide*.
        :param str path_pattern: The pattern (for example, ``images/*.jpg``) that specifies which requests to apply the behavior to. When CloudFront receives a viewer request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution.  You can optionally include a slash (``/``) at the beginning of the path pattern. For example, ``/images/*.jpg``. CloudFront behavior is the same with or without the leading ``/``.  The path pattern for the default cache behavior is ``*`` and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior. For more information, see [Path Pattern](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern) in the *Amazon CloudFront Developer Guide*.
        :param str realtime_log_config_arn: The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the *Amazon CloudFront Developer Guide*.
        :param str response_headers_policy_id: The identifier for a response headers policy.
        :param bool smooth_streaming: Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify ``true``; if not, specify ``false``. If you specify ``true`` for ``SmoothStreaming``, you can still distribute other content using this cache behavior if the content matches the value of ``PathPattern``.
        :param str target_origin_id: The value of ``ID`` for the origin that you want CloudFront to route requests to when they match this cache behavior.
        :param Sequence[str] trusted_key_groups: A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        :param Sequence[str] trusted_signers: We recommend using ``TrustedKeyGroups`` instead of ``TrustedSigners``.  A list of AWS-account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in the trusted signer's AWS-account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        :param str viewer_protocol_policy: The protocol that viewers can use to access the files in the origin specified by ``TargetOriginId`` when a request matches the path pattern in ``PathPattern``. You can specify the following options:  +   ``allow-all``: Viewers can use HTTP or HTTPS.  +   ``redirect-to-https``: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.  +   ``https-only``: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).   For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the *Amazon CloudFront Developer Guide*.  The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        """
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if cached_methods is not None:
            pulumi.set(__self__, "cached_methods", cached_methods)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if default_ttl is None:
            default_ttl = 86400
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if forwarded_values is not None:
            pulumi.set(__self__, "forwarded_values", forwarded_values)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if max_ttl is None:
            max_ttl = 31536000
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if min_ttl is not None:
            pulumi.set(__self__, "min_ttl", min_ttl)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if path_pattern is not None:
            pulumi.set(__self__, "path_pattern", path_pattern)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if smooth_streaming is not None:
            pulumi.set(__self__, "smooth_streaming", smooth_streaming)
        if target_origin_id is not None:
            pulumi.set(__self__, "target_origin_id", target_origin_id)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)
        if trusted_signers is not None:
            pulumi.set(__self__, "trusted_signers", trusted_signers)
        if viewer_protocol_policy is not None:
            pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[str]]:
        """
        A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:  +  CloudFront forwards only ``GET`` and ``HEAD`` requests.  +  CloudFront forwards only ``GET``, ``HEAD``, and ``OPTIONS`` requests.  +  CloudFront forwards ``GET, HEAD, OPTIONS, PUT, PATCH, POST``, and ``DELETE`` requests.   If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[str]:
        """
        The unique identifier of the cache policy that is attached to this cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. A ``CacheBehavior`` must include either a ``CachePolicyId`` or ``ForwardedValues``. We recommend that you use a ``CachePolicyId``.
        """
        return pulumi.get(self, "cache_policy_id")

    @property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> Optional[Sequence[str]]:
        """
        A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:  +  CloudFront caches responses to ``GET`` and ``HEAD`` requests.  +  CloudFront caches responses to ``GET``, ``HEAD``, and ``OPTIONS`` requests.   If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
        """
        return pulumi.get(self, "cached_methods")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify true; if not, specify false. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="defaultTTL")
    def default_ttl(self) -> Optional[int]:
        """
        This field is deprecated. We recommend that you use the ``DefaultTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as ``Cache-Control max-age``, ``Cache-Control s-maxage``, and ``Expires`` to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[str]:
        """
        The value of ``ID`` for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for this cache behavior.
        """
        return pulumi.get(self, "field_level_encryption_id")

    @property
    @pulumi.getter(name="forwardedValues")
    def forwarded_values(self) -> Optional['outputs.ForwardedValuesResponse']:
        """
        This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the *Amazon CloudFront Developer Guide*. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the *Amazon CloudFront Developer Guide*. A ``CacheBehavior`` must include either a ``CachePolicyId`` or ``ForwardedValues``. We recommend that you use a ``CachePolicyId``. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers. This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        """
        return pulumi.get(self, "forwarded_values")

    @property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[Sequence['outputs.FunctionAssociationResponse']]:
        """
        A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the ``LIVE`` stage to associate them with a cache behavior.
        """
        return pulumi.get(self, "function_associations")

    @property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[Sequence['outputs.LambdaFunctionAssociationResponse']]:
        """
        A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        """
        return pulumi.get(self, "lambda_function_associations")

    @property
    @pulumi.getter(name="maxTTL")
    def max_ttl(self) -> Optional[int]:
        """
        This field is deprecated. We recommend that you use the ``MaxTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as ``Cache-Control max-age``, ``Cache-Control s-maxage``, and ``Expires`` to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "max_ttl")

    @property
    @pulumi.getter(name="minTTL")
    def min_ttl(self) -> Optional[int]:
        """
        This field is deprecated. We recommend that you use the ``MinTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*. You must specify ``0`` for ``MinTTL`` if you configure CloudFront to forward all headers to your origin (under ``Headers``, if you specify ``1`` for ``Quantity`` and ``*`` for ``Name``).
        """
        return pulumi.get(self, "min_ttl")

    @property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[str]:
        """
        The unique identifier of the origin request policy that is attached to this cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_request_policy_id")

    @property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> Optional[str]:
        """
        The pattern (for example, ``images/*.jpg``) that specifies which requests to apply the behavior to. When CloudFront receives a viewer request, the requested path is compared with path patterns in the order in which cache behaviors are listed in the distribution.  You can optionally include a slash (``/``) at the beginning of the path pattern. For example, ``/images/*.jpg``. CloudFront behavior is the same with or without the leading ``/``.  The path pattern for the default cache behavior is ``*`` and cannot be changed. If the request for an object does not match the path pattern for any cache behaviors, CloudFront applies the behavior in the default cache behavior. For more information, see [Path Pattern](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "path_pattern")

    @property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "realtime_log_config_arn")

    @property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[str]:
        """
        The identifier for a response headers policy.
        """
        return pulumi.get(self, "response_headers_policy_id")

    @property
    @pulumi.getter(name="smoothStreaming")
    def smooth_streaming(self) -> Optional[bool]:
        """
        Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify ``true``; if not, specify ``false``. If you specify ``true`` for ``SmoothStreaming``, you can still distribute other content using this cache behavior if the content matches the value of ``PathPattern``.
        """
        return pulumi.get(self, "smooth_streaming")

    @property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> Optional[str]:
        """
        The value of ``ID`` for the origin that you want CloudFront to route requests to when they match this cache behavior.
        """
        return pulumi.get(self, "target_origin_id")

    @property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[Sequence[str]]:
        """
        A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "trusted_key_groups")

    @property
    @pulumi.getter(name="trustedSigners")
    def trusted_signers(self) -> Optional[Sequence[str]]:
        """
        We recommend using ``TrustedKeyGroups`` instead of ``TrustedSigners``.  A list of AWS-account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in the trusted signer's AWS-account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "trusted_signers")

    @property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> Optional[str]:
        """
        The protocol that viewers can use to access the files in the origin specified by ``TargetOriginId`` when a request matches the path pattern in ``PathPattern``. You can specify the following options:  +   ``allow-all``: Viewers can use HTTP or HTTPS.  +   ``redirect-to-https``: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.  +   ``https-only``: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).   For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the *Amazon CloudFront Developer Guide*.  The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "viewer_protocol_policy")


@pulumi.output_type
class CacheTypeEnumValueResponse(dict):
    """
    Definition of CacheTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of CacheTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CanarySettingResponse(dict):
    """
    Definition of CanarySetting
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentId":
            suggest = "deployment_id"
        elif key == "percentTraffic":
            suggest = "percent_traffic"
        elif key == "stageVariableOverrides":
            suggest = "stage_variable_overrides"
        elif key == "useStageCache":
            suggest = "use_stage_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CanarySettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CanarySettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CanarySettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_id: Optional[str] = None,
                 percent_traffic: Optional[int] = None,
                 stage_variable_overrides: Optional[Mapping[str, str]] = None,
                 use_stage_cache: Optional[bool] = None):
        """
        Definition of CanarySetting
        :param str deployment_id: The ID of the canary deployment.
        :param int percent_traffic: The percent (0-100) of traffic diverted to a canary deployment.
        :param Mapping[str, str] stage_variable_overrides: Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.
        :param bool use_stage_cache: A Boolean flag to indicate whether the canary deployment uses the stage cache or not.
        """
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if percent_traffic is not None:
            pulumi.set(__self__, "percent_traffic", percent_traffic)
        if stage_variable_overrides is not None:
            pulumi.set(__self__, "stage_variable_overrides", stage_variable_overrides)
        if use_stage_cache is not None:
            pulumi.set(__self__, "use_stage_cache", use_stage_cache)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[str]:
        """
        The ID of the canary deployment.
        """
        return pulumi.get(self, "deployment_id")

    @property
    @pulumi.getter(name="percentTraffic")
    def percent_traffic(self) -> Optional[int]:
        """
        The percent (0-100) of traffic diverted to a canary deployment.
        """
        return pulumi.get(self, "percent_traffic")

    @property
    @pulumi.getter(name="stageVariableOverrides")
    def stage_variable_overrides(self) -> Optional[Mapping[str, str]]:
        """
        Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.
        """
        return pulumi.get(self, "stage_variable_overrides")

    @property
    @pulumi.getter(name="useStageCache")
    def use_stage_cache(self) -> Optional[bool]:
        """
        A Boolean flag to indicate whether the canary deployment uses the stage cache or not.
        """
        return pulumi.get(self, "use_stage_cache")


@pulumi.output_type
class CapacityProviderStrategyItemResponse(dict):
    """
    Definition of CapacityProviderStrategyItem
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProvider":
            suggest = "capacity_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityProviderStrategyItemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityProviderStrategyItemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityProviderStrategyItemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base: Optional[int] = None,
                 capacity_provider: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        Definition of CapacityProviderStrategyItem
        :param int base: The *base* value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a *base* defined. If no value is specified, the default value of ``0`` is used.
        :param str capacity_provider: The short name of the capacity provider.
        :param int weight: The *weight* value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The ``weight`` value is taken into consideration after the ``base`` value, if defined, is satisfied. If no ``weight`` value is specified, the default value of ``0`` is used. When multiple capacity providers are specified within a capacity provider strategy, at least one of the capacity providers must have a weight value greater than zero and any capacity providers with a weight of ``0`` can't be used to place tasks. If you specify multiple capacity providers in a strategy that all have a weight of ``0``, any ``RunTask`` or ``CreateService`` actions using the capacity provider strategy will fail. An example scenario for using weights is defining a strategy that contains two capacity providers and both have a weight of ``1``, then when the ``base`` is satisfied, the tasks will be split evenly across the two capacity providers. Using that same logic, if you specify a weight of ``1`` for *capacityProviderA* and a weight of ``4`` for *capacityProviderB*, then for every one task that's run using *capacityProviderA*, four tasks would use *capacityProviderB*.
        """
        if base is not None:
            pulumi.set(__self__, "base", base)
        if capacity_provider is not None:
            pulumi.set(__self__, "capacity_provider", capacity_provider)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def base(self) -> Optional[int]:
        """
        The *base* value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a *base* defined. If no value is specified, the default value of ``0`` is used.
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> Optional[str]:
        """
        The short name of the capacity provider.
        """
        return pulumi.get(self, "capacity_provider")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The *weight* value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The ``weight`` value is taken into consideration after the ``base`` value, if defined, is satisfied. If no ``weight`` value is specified, the default value of ``0`` is used. When multiple capacity providers are specified within a capacity provider strategy, at least one of the capacity providers must have a weight value greater than zero and any capacity providers with a weight of ``0`` can't be used to place tasks. If you specify multiple capacity providers in a strategy that all have a weight of ``0``, any ``RunTask`` or ``CreateService`` actions using the capacity provider strategy will fail. An example scenario for using weights is defining a strategy that contains two capacity providers and both have a weight of ``1``, then when the ``base`` is satisfied, the tasks will be split evenly across the two capacity providers. Using that same logic, if you specify a weight of ``1`` for *capacityProviderA* and a weight of ``4`` for *capacityProviderB*, then for every one task that's run using *capacityProviderA*, four tasks would use *capacityProviderB*.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class CapacityReservationPreferenceEnumValueResponse(dict):
    """
    Definition of CapacityReservationPreferenceEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of CapacityReservationPreferenceEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CapacityReservationSpecificationResponseResponse(dict):
    """
    Definition of CapacityReservationSpecificationResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationSpecificationResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationSpecificationResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationSpecificationResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional['outputs.CapacityReservationPreferenceEnumValueResponse'] = None,
                 capacity_reservation_target: Optional['outputs.CapacityReservationTargetResponseResponse'] = None):
        """
        Definition of CapacityReservationSpecificationResponse
        :param 'CapacityReservationPreferenceEnumValueResponse' capacity_reservation_preference: <p>Describes the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.</p> </li> </ul>
        :param 'CapacityReservationTargetResponseResponse' capacity_reservation_target: <p>Information about the targeted Capacity Reservation or Capacity Reservation group.</p>
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional['outputs.CapacityReservationPreferenceEnumValueResponse']:
        """
        <p>Describes the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.</p> </li> </ul>
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.CapacityReservationTargetResponseResponse']:
        """
        <p>Information about the targeted Capacity Reservation or Capacity Reservation group.</p>
        """
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class CapacityReservationTargetResponseResponse(dict):
    """
    Definition of CapacityReservationTargetResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationTargetResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationTargetResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationTargetResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[str] = None,
                 capacity_reservation_resource_group_arn: Optional[str] = None):
        """
        Definition of CapacityReservationTargetResponse
        :param str capacity_reservation_id: <p>The ID of the targeted Capacity Reservation.</p>
        :param str capacity_reservation_resource_group_arn: <p>The ARN of the targeted Capacity Reservation group.</p>
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[str]:
        """
        <p>The ID of the targeted Capacity Reservation.</p>
        """
        return pulumi.get(self, "capacity_reservation_id")

    @property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[str]:
        """
        <p>The ARN of the targeted Capacity Reservation group.</p>
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class CertificateDetailsResponse(dict):
    """
    Definition of CertificateDetails
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caIdentifier":
            suggest = "ca_identifier"
        elif key == "validTill":
            suggest = "valid_till"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_identifier: Optional[str] = None,
                 valid_till: Optional[str] = None):
        """
        Definition of CertificateDetails
        :param str ca_identifier: The CA identifier of the CA certificate used for the DB instance's server certificate.
        :param str valid_till: The expiration date of the DB instances server certificate.
        """
        if ca_identifier is not None:
            pulumi.set(__self__, "ca_identifier", ca_identifier)
        if valid_till is not None:
            pulumi.set(__self__, "valid_till", valid_till)

    @property
    @pulumi.getter(name="caIdentifier")
    def ca_identifier(self) -> Optional[str]:
        """
        The CA identifier of the CA certificate used for the DB instance's server certificate.
        """
        return pulumi.get(self, "ca_identifier")

    @property
    @pulumi.getter(name="validTill")
    def valid_till(self) -> Optional[str]:
        """
        The expiration date of the DB instances server certificate.
        """
        return pulumi.get(self, "valid_till")


@pulumi.output_type
class CertificateResponse(dict):
    """
    Definition of Certificate
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateArn":
            suggest = "certificate_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_arn: Optional[str] = None,
                 data: Optional[str] = None):
        """
        Definition of Certificate
        :param str certificate_arn: The Amazon Resource Name (ARN) of the certificate.
        :param str data: <p>The Base64-encoded certificate data required to communicate with your cluster. Add this to the <code>certificate-authority-data</code> section of the <code>kubeconfig</code> file for your cluster.</p>
        """
        if certificate_arn is not None:
            pulumi.set(__self__, "certificate_arn", certificate_arn)
        if data is not None:
            pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the certificate.
        """
        return pulumi.get(self, "certificate_arn")

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        <p>The Base64-encoded certificate data required to communicate with your cluster. Add this to the <code>certificate-authority-data</code> section of the <code>kubeconfig</code> file for your cluster.</p>
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class CertificateStatusEnumValueResponse(dict):
    """
    Definition of CertificateStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of CertificateStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CertificateTypeEnumValueResponse(dict):
    """
    Definition of CertificateTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of CertificateTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ChangeProgressDetailsResponse(dict):
    """
    Definition of ChangeProgressDetails
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeId":
            suggest = "change_id"
        elif key == "configChangeStatus":
            suggest = "config_change_status"
        elif key == "initiatedBy":
            suggest = "initiated_by"
        elif key == "lastUpdatedTime":
            suggest = "last_updated_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChangeProgressDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChangeProgressDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChangeProgressDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_id: Optional[str] = None,
                 config_change_status: Optional['outputs.ConfigChangeStatusEnumValueResponse'] = None,
                 initiated_by: Optional['outputs.InitiatedByEnumValueResponse'] = None,
                 last_updated_time: Optional[str] = None,
                 message: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        Definition of ChangeProgressDetails
        :param str change_id: <p>The ID of the configuration change.</p>
        :param 'ConfigChangeStatusEnumValueResponse' config_change_status: <p>The current status of the configuration change.</p>
        :param 'InitiatedByEnumValueResponse' initiated_by: <p>The IAM principal who initiated the configuration change.</p>
        :param str last_updated_time: <p>The last time that the configuration change was updated.</p>
        :param str message: <p>A message corresponding to the status of the configuration change.</p>
        :param str start_time: <p>The time that the configuration change was initiated, in Universal Coordinated Time (UTC).</p>
        """
        if change_id is not None:
            pulumi.set(__self__, "change_id", change_id)
        if config_change_status is not None:
            pulumi.set(__self__, "config_change_status", config_change_status)
        if initiated_by is not None:
            pulumi.set(__self__, "initiated_by", initiated_by)
        if last_updated_time is not None:
            pulumi.set(__self__, "last_updated_time", last_updated_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="changeId")
    def change_id(self) -> Optional[str]:
        """
        <p>The ID of the configuration change.</p>
        """
        return pulumi.get(self, "change_id")

    @property
    @pulumi.getter(name="configChangeStatus")
    def config_change_status(self) -> Optional['outputs.ConfigChangeStatusEnumValueResponse']:
        """
        <p>The current status of the configuration change.</p>
        """
        return pulumi.get(self, "config_change_status")

    @property
    @pulumi.getter(name="initiatedBy")
    def initiated_by(self) -> Optional['outputs.InitiatedByEnumValueResponse']:
        """
        <p>The IAM principal who initiated the configuration change.</p>
        """
        return pulumi.get(self, "initiated_by")

    @property
    @pulumi.getter(name="lastUpdatedTime")
    def last_updated_time(self) -> Optional[str]:
        """
        <p>The last time that the configuration change was updated.</p>
        """
        return pulumi.get(self, "last_updated_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        <p>A message corresponding to the status of the configuration change.</p>
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        <p>The time that the configuration change was initiated, in Universal Coordinated Time (UTC).</p>
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class CidrRoutingConfigResponse(dict):
    """
    Definition of CidrRoutingConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionId":
            suggest = "collection_id"
        elif key == "locationName":
            suggest = "location_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CidrRoutingConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CidrRoutingConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CidrRoutingConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_id: Optional[str] = None,
                 location_name: Optional[str] = None):
        """
        Definition of CidrRoutingConfig
        :param str collection_id: <p>The CIDR collection ID.</p>
        :param str location_name: <p>The CIDR collection location name.</p>
        """
        if collection_id is not None:
            pulumi.set(__self__, "collection_id", collection_id)
        if location_name is not None:
            pulumi.set(__self__, "location_name", location_name)

    @property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> Optional[str]:
        """
        <p>The CIDR collection ID.</p>
        """
        return pulumi.get(self, "collection_id")

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> Optional[str]:
        """
        <p>The CIDR collection location name.</p>
        """
        return pulumi.get(self, "location_name")


@pulumi.output_type
class CloudFormationStackPropertiesResponse(dict):
    """
    Definition of CloudFormationStack
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudFormationStackPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudFormationStackPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudFormationStackPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsCloudFormationStackPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of CloudFormationStack
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsCloudFormationStackPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsCloudFormationStackPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class CloudFormationStackSetPropertiesResponse(dict):
    """
    Definition of CloudFormationStackSet
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudFormationStackSetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudFormationStackSetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudFormationStackSetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsCloudFormationStackSetPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of CloudFormationStackSet
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsCloudFormationStackSetPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsCloudFormationStackSetPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class CloudFrontDistributionPropertiesResponse(dict):
    """
    Definition of CloudFrontDistribution
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudFrontDistributionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudFrontDistributionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudFrontDistributionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsCloudFrontDistributionPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of CloudFrontDistribution
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsCloudFrontDistributionPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsCloudFrontDistributionPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class CloudTrailTrailPropertiesResponse(dict):
    """
    Definition of CloudTrailTrail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudTrailTrailPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudTrailTrailPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudTrailTrailPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsCloudTrailTrailPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of CloudTrailTrail
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsCloudTrailTrailPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsCloudTrailTrailPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class CloudWatchAlarmPropertiesResponse(dict):
    """
    Definition of CloudWatchAlarm
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudWatchAlarmPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudWatchAlarmPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudWatchAlarmPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsCloudWatchAlarmPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of CloudWatchAlarm
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsCloudWatchAlarmPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsCloudWatchAlarmPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class CloudWatchLogsConfigResponse(dict):
    """
    Definition of CloudWatchLogsConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudWatchLogsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudWatchLogsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudWatchLogsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[str] = None,
                 status: Optional['outputs.LogsConfigStatusTypeEnumValueResponse'] = None,
                 stream_name: Optional[str] = None):
        """
        Definition of CloudWatchLogsConfig
        :param str group_name: <p> The group name of the logs in CloudWatch Logs. For more information, see <a href='https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html'>Working with Log Groups and Log Streams</a>. </p>
        :param 'LogsConfigStatusTypeEnumValueResponse' status: <p>The current status of the logs in CloudWatch Logs for a build project. Valid values are:</p> <ul> <li> <p> <code>ENABLED</code>: CloudWatch Logs are enabled for this build project.</p> </li> <li> <p> <code>DISABLED</code>: CloudWatch Logs are not enabled for this build project.</p> </li> </ul>
        :param str stream_name: <p> The prefix of the stream name of the CloudWatch Logs. For more information, see <a href='https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html'>Working with Log Groups and Log Streams</a>. </p>
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        <p> The group name of the logs in CloudWatch Logs. For more information, see <a href='https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html'>Working with Log Groups and Log Streams</a>. </p>
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.LogsConfigStatusTypeEnumValueResponse']:
        """
        <p>The current status of the logs in CloudWatch Logs for a build project. Valid values are:</p> <ul> <li> <p> <code>ENABLED</code>: CloudWatch Logs are enabled for this build project.</p> </li> <li> <p> <code>DISABLED</code>: CloudWatch Logs are not enabled for this build project.</p> </li> </ul>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[str]:
        """
        <p> The prefix of the stream name of the CloudWatch Logs. For more information, see <a href='https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html'>Working with Log Groups and Log Streams</a>. </p>
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class ClusterConfigResponse(dict):
    """
    Definition of ClusterConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coldStorageOptions":
            suggest = "cold_storage_options"
        elif key == "dedicatedMasterCount":
            suggest = "dedicated_master_count"
        elif key == "dedicatedMasterEnabled":
            suggest = "dedicated_master_enabled"
        elif key == "dedicatedMasterType":
            suggest = "dedicated_master_type"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "multiAZWithStandbyEnabled":
            suggest = "multi_az_with_standby_enabled"
        elif key == "warmCount":
            suggest = "warm_count"
        elif key == "warmEnabled":
            suggest = "warm_enabled"
        elif key == "warmType":
            suggest = "warm_type"
        elif key == "zoneAwarenessConfig":
            suggest = "zone_awareness_config"
        elif key == "zoneAwarenessEnabled":
            suggest = "zone_awareness_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cold_storage_options: Optional['outputs.ColdStorageOptionsResponse'] = None,
                 dedicated_master_count: Optional[int] = None,
                 dedicated_master_enabled: Optional[bool] = None,
                 dedicated_master_type: Optional['outputs.OpenSearchPartitionInstanceTypeEnumValueResponse'] = None,
                 instance_count: Optional[int] = None,
                 instance_type: Optional['outputs.OpenSearchPartitionInstanceTypeEnumValueResponse'] = None,
                 multi_az_with_standby_enabled: Optional[bool] = None,
                 warm_count: Optional[int] = None,
                 warm_enabled: Optional[bool] = None,
                 warm_type: Optional['outputs.OpenSearchWarmPartitionInstanceTypeEnumValueResponse'] = None,
                 zone_awareness_config: Optional['outputs.ZoneAwarenessConfigResponse'] = None,
                 zone_awareness_enabled: Optional[bool] = None):
        """
        Definition of ClusterConfig
        :param 'ColdStorageOptionsResponse' cold_storage_options: <p>Container for cold storage configuration options.</p>
        :param int dedicated_master_count: <p>Number of dedicated master nodes in the cluster. This number must be greater than 2 and not 4, otherwise you receive a validation exception.</p>
        :param bool dedicated_master_enabled: <p>Indicates whether dedicated master nodes are enabled for the cluster.<code>True</code> if the cluster will use a dedicated master node.<code>False</code> if the cluster will not.</p>
        :param 'OpenSearchPartitionInstanceTypeEnumValueResponse' dedicated_master_type: <p>OpenSearch Service instance type of the dedicated master nodes in the cluster.</p>
        :param int instance_count: <p>Number of data nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
        :param 'OpenSearchPartitionInstanceTypeEnumValueResponse' instance_type: <p>Instance type of data nodes in the cluster.</p>
        :param bool multi_az_with_standby_enabled: <p>A boolean that indicates whether a multi-AZ domain is turned on with a standby AZ. For more information, see <a href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'>Configuring a multi-AZ domain in Amazon OpenSearch Service</a>. </p>
        :param int warm_count: <p>The number of warm nodes in the cluster.</p>
        :param bool warm_enabled: <p>Whether to enable warm storage for the cluster.</p>
        :param 'OpenSearchWarmPartitionInstanceTypeEnumValueResponse' warm_type: <p>The instance type for the cluster's warm nodes.</p>
        :param 'ZoneAwarenessConfigResponse' zone_awareness_config: <p>Container for zone awareness configuration options. Only required if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
        :param bool zone_awareness_enabled: <p>Indicates whether multiple Availability Zones are enabled. For more information, see <a href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'>Configuring a multi-AZ domain in Amazon OpenSearch Service</a>.</p>
        """
        if cold_storage_options is not None:
            pulumi.set(__self__, "cold_storage_options", cold_storage_options)
        if dedicated_master_count is not None:
            pulumi.set(__self__, "dedicated_master_count", dedicated_master_count)
        if dedicated_master_enabled is not None:
            pulumi.set(__self__, "dedicated_master_enabled", dedicated_master_enabled)
        if dedicated_master_type is not None:
            pulumi.set(__self__, "dedicated_master_type", dedicated_master_type)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if multi_az_with_standby_enabled is not None:
            pulumi.set(__self__, "multi_az_with_standby_enabled", multi_az_with_standby_enabled)
        if warm_count is not None:
            pulumi.set(__self__, "warm_count", warm_count)
        if warm_enabled is not None:
            pulumi.set(__self__, "warm_enabled", warm_enabled)
        if warm_type is not None:
            pulumi.set(__self__, "warm_type", warm_type)
        if zone_awareness_config is not None:
            pulumi.set(__self__, "zone_awareness_config", zone_awareness_config)
        if zone_awareness_enabled is not None:
            pulumi.set(__self__, "zone_awareness_enabled", zone_awareness_enabled)

    @property
    @pulumi.getter(name="coldStorageOptions")
    def cold_storage_options(self) -> Optional['outputs.ColdStorageOptionsResponse']:
        """
        <p>Container for cold storage configuration options.</p>
        """
        return pulumi.get(self, "cold_storage_options")

    @property
    @pulumi.getter(name="dedicatedMasterCount")
    def dedicated_master_count(self) -> Optional[int]:
        """
        <p>Number of dedicated master nodes in the cluster. This number must be greater than 2 and not 4, otherwise you receive a validation exception.</p>
        """
        return pulumi.get(self, "dedicated_master_count")

    @property
    @pulumi.getter(name="dedicatedMasterEnabled")
    def dedicated_master_enabled(self) -> Optional[bool]:
        """
        <p>Indicates whether dedicated master nodes are enabled for the cluster.<code>True</code> if the cluster will use a dedicated master node.<code>False</code> if the cluster will not.</p>
        """
        return pulumi.get(self, "dedicated_master_enabled")

    @property
    @pulumi.getter(name="dedicatedMasterType")
    def dedicated_master_type(self) -> Optional['outputs.OpenSearchPartitionInstanceTypeEnumValueResponse']:
        """
        <p>OpenSearch Service instance type of the dedicated master nodes in the cluster.</p>
        """
        return pulumi.get(self, "dedicated_master_type")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[int]:
        """
        <p>Number of data nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.</p>
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional['outputs.OpenSearchPartitionInstanceTypeEnumValueResponse']:
        """
        <p>Instance type of data nodes in the cluster.</p>
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="multiAZWithStandbyEnabled")
    def multi_az_with_standby_enabled(self) -> Optional[bool]:
        """
        <p>A boolean that indicates whether a multi-AZ domain is turned on with a standby AZ. For more information, see <a href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'>Configuring a multi-AZ domain in Amazon OpenSearch Service</a>. </p>
        """
        return pulumi.get(self, "multi_az_with_standby_enabled")

    @property
    @pulumi.getter(name="warmCount")
    def warm_count(self) -> Optional[int]:
        """
        <p>The number of warm nodes in the cluster.</p>
        """
        return pulumi.get(self, "warm_count")

    @property
    @pulumi.getter(name="warmEnabled")
    def warm_enabled(self) -> Optional[bool]:
        """
        <p>Whether to enable warm storage for the cluster.</p>
        """
        return pulumi.get(self, "warm_enabled")

    @property
    @pulumi.getter(name="warmType")
    def warm_type(self) -> Optional['outputs.OpenSearchWarmPartitionInstanceTypeEnumValueResponse']:
        """
        <p>The instance type for the cluster's warm nodes.</p>
        """
        return pulumi.get(self, "warm_type")

    @property
    @pulumi.getter(name="zoneAwarenessConfig")
    def zone_awareness_config(self) -> Optional['outputs.ZoneAwarenessConfigResponse']:
        """
        <p>Container for zone awareness configuration options. Only required if <code>ZoneAwarenessEnabled</code> is <code>true</code>.</p>
        """
        return pulumi.get(self, "zone_awareness_config")

    @property
    @pulumi.getter(name="zoneAwarenessEnabled")
    def zone_awareness_enabled(self) -> Optional[bool]:
        """
        <p>Indicates whether multiple Availability Zones are enabled. For more information, see <a href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'>Configuring a multi-AZ domain in Amazon OpenSearch Service</a>.</p>
        """
        return pulumi.get(self, "zone_awareness_enabled")


@pulumi.output_type
class ClusterConfigurationResponse(dict):
    """
    Definition of ClusterConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executeCommandConfiguration":
            suggest = "execute_command_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execute_command_configuration: Optional['outputs.ExecuteCommandConfigurationResponse'] = None):
        """
        Definition of ClusterConfiguration
        :param 'ExecuteCommandConfigurationResponse' execute_command_configuration: The details of the execute command configuration. The details of the execute command configuration.
        """
        if execute_command_configuration is not None:
            pulumi.set(__self__, "execute_command_configuration", execute_command_configuration)

    @property
    @pulumi.getter(name="executeCommandConfiguration")
    def execute_command_configuration(self) -> Optional['outputs.ExecuteCommandConfigurationResponse']:
        """
        The details of the execute command configuration. The details of the execute command configuration.
        """
        return pulumi.get(self, "execute_command_configuration")


@pulumi.output_type
class ClusterEndpointEncryptionTypeEnumValueResponse(dict):
    """
    Definition of ClusterEndpointEncryptionTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ClusterEndpointEncryptionTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterHealthResponse(dict):
    """
    Definition of ClusterHealth
    """
    def __init__(__self__, *,
                 issues: Optional[Sequence['outputs.ClusterIssueResponse']] = None):
        """
        Definition of ClusterHealth
        :param Sequence['ClusterIssueResponse'] issues: <p>An object representing the health issues of your local Amazon EKS cluster on an Amazon Web Services Outpost.</p>
        """
        if issues is not None:
            pulumi.set(__self__, "issues", issues)

    @property
    @pulumi.getter
    def issues(self) -> Optional[Sequence['outputs.ClusterIssueResponse']]:
        """
        <p>An object representing the health issues of your local Amazon EKS cluster on an Amazon Web Services Outpost.</p>
        """
        return pulumi.get(self, "issues")


@pulumi.output_type
class ClusterIssueCodeEnumValueResponse(dict):
    """
    Definition of ClusterIssueCodeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ClusterIssueCodeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterIssueResponse(dict):
    """
    Definition of ClusterIssue
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceIds":
            suggest = "resource_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterIssueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterIssueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterIssueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional['outputs.ClusterIssueCodeEnumValueResponse'] = None,
                 message: Optional[str] = None,
                 resource_ids: Optional[Sequence[str]] = None):
        """
        Definition of ClusterIssue
        :param 'ClusterIssueCodeEnumValueResponse' code: <p>The error code of the issue.</p>
        :param str message: <p>A description of the issue.</p>
        :param Sequence[str] resource_ids: <p>The resource IDs that the issue relates to.</p>
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if resource_ids is not None:
            pulumi.set(__self__, "resource_ids", resource_ids)

    @property
    @pulumi.getter
    def code(self) -> Optional['outputs.ClusterIssueCodeEnumValueResponse']:
        """
        <p>The error code of the issue.</p>
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        <p>A description of the issue.</p>
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Optional[Sequence[str]]:
        """
        <p>The resource IDs that the issue relates to.</p>
        """
        return pulumi.get(self, "resource_ids")


@pulumi.output_type
class ClusterSettingsResponse(dict):
    """
    Definition of ClusterSettings
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of ClusterSettings
        :param str name: The name of the cluster setting. The value is ``containerInsights`` .
        :param str value: The value to set for the cluster setting. The supported values are ``enabled`` and ``disabled``.  If you set ``name`` to ``containerInsights`` and ``value`` to ``enabled``, CloudWatch Container Insights will be on for the cluster, otherwise it will be off unless the ``containerInsights`` account setting is turned on. If a cluster value is specified, it will override the ``containerInsights`` value set with [PutAccountSetting](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutAccountSetting.html) or [PutAccountSettingDefault](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutAccountSettingDefault.html).
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the cluster setting. The value is ``containerInsights`` .
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value to set for the cluster setting. The supported values are ``enabled`` and ``disabled``.  If you set ``name`` to ``containerInsights`` and ``value`` to ``enabled``, CloudWatch Container Insights will be on for the cluster, otherwise it will be off unless the ``containerInsights`` account setting is turned on. If a cluster value is specified, it will override the ``containerInsights`` value set with [PutAccountSetting](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutAccountSetting.html) or [PutAccountSettingDefault](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutAccountSettingDefault.html).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterStateChangeReasonCodeEnumValueResponse(dict):
    """
    Definition of ClusterStateChangeReasonCodeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ClusterStateChangeReasonCodeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterStateChangeReasonResponse(dict):
    """
    Definition of ClusterStateChangeReason
    """
    def __init__(__self__, *,
                 code: Optional['outputs.ClusterStateChangeReasonCodeEnumValueResponse'] = None,
                 message: Optional[str] = None):
        """
        Definition of ClusterStateChangeReason
        :param 'ClusterStateChangeReasonCodeEnumValueResponse' code: <p>The programmatic code for the state change reason.</p>
        :param str message: <p>The descriptive message for the state change reason.</p>
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional['outputs.ClusterStateChangeReasonCodeEnumValueResponse']:
        """
        <p>The programmatic code for the state change reason.</p>
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        <p>The descriptive message for the state change reason.</p>
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ClusterStateEnumValueResponse(dict):
    """
    Definition of ClusterStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ClusterStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterStatusEnumValueResponse(dict):
    """
    Definition of ClusterStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ClusterStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterTimelineResponse(dict):
    """
    Definition of ClusterTimeline
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationDateTime":
            suggest = "creation_date_time"
        elif key == "endDateTime":
            suggest = "end_date_time"
        elif key == "readyDateTime":
            suggest = "ready_date_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTimelineResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTimelineResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTimelineResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_date_time: Optional[str] = None,
                 end_date_time: Optional[str] = None,
                 ready_date_time: Optional[str] = None):
        """
        Definition of ClusterTimeline
        :param str creation_date_time: <p>The creation date and time of the cluster.</p>
        :param str end_date_time: <p>The date and time when the cluster was terminated.</p>
        :param str ready_date_time: <p>The date and time when the cluster was ready to run steps.</p>
        """
        if creation_date_time is not None:
            pulumi.set(__self__, "creation_date_time", creation_date_time)
        if end_date_time is not None:
            pulumi.set(__self__, "end_date_time", end_date_time)
        if ready_date_time is not None:
            pulumi.set(__self__, "ready_date_time", ready_date_time)

    @property
    @pulumi.getter(name="creationDateTime")
    def creation_date_time(self) -> Optional[str]:
        """
        <p>The creation date and time of the cluster.</p>
        """
        return pulumi.get(self, "creation_date_time")

    @property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[str]:
        """
        <p>The date and time when the cluster was terminated.</p>
        """
        return pulumi.get(self, "end_date_time")

    @property
    @pulumi.getter(name="readyDateTime")
    def ready_date_time(self) -> Optional[str]:
        """
        <p>The date and time when the cluster was ready to run steps.</p>
        """
        return pulumi.get(self, "ready_date_time")


@pulumi.output_type
class CodeBuildProjectPropertiesResponse(dict):
    """
    Definition of CodeBuildProject
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeBuildProjectPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeBuildProjectPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeBuildProjectPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsCodeBuildProjectPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of CodeBuildProject
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsCodeBuildProjectPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsCodeBuildProjectPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class CodeBuildSourceCredentialsInfoPropertiesResponse(dict):
    """
    Definition of CodeBuildSourceCredentialsInfo
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeBuildSourceCredentialsInfoPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeBuildSourceCredentialsInfoPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeBuildSourceCredentialsInfoPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsCodeBuildSourceCredentialsInfoPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of CodeBuildSourceCredentialsInfo
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsCodeBuildSourceCredentialsInfoPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsCodeBuildSourceCredentialsInfoPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class CodeResponse(dict):
    """
    Definition of Code
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUri":
            suggest = "image_uri"
        elif key == "s3Bucket":
            suggest = "s3_bucket"
        elif key == "s3Key":
            suggest = "s3_key"
        elif key == "s3ObjectVersion":
            suggest = "s3_object_version"
        elif key == "zipFile":
            suggest = "zip_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_uri: Optional[str] = None,
                 s3_bucket: Optional[str] = None,
                 s3_key: Optional[str] = None,
                 s3_object_version: Optional[str] = None,
                 zip_file: Optional[str] = None):
        """
        Definition of Code
        :param str image_uri: URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
        :param str s3_bucket: An Amazon S3 bucket in the same AWS-Region as your function. The bucket can be in a different AWS-account.
        :param str s3_key: The Amazon S3 key of the deployment package.
        :param str s3_object_version: For versioned objects, the version of the deployment package object to use.
        :param str zip_file: (Node.js and Python) The source code of your Lambda function. If you include your function source inline with this parameter, CFN places it in a file named ``index`` and zips it to create a [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html). This zip file cannot exceed 4MB. For the ``Handler`` property, the first part of the handler identifier must be ``index``. For example, ``index.handler``.  For JSON, you must escape quotes and special characters such as newline (``\\n``) with a backslash. If you specify a function that interacts with an AWS CloudFormation custom resource, you don't have to write your own functions to send responses to the custom resource that invoked the function. AWS CloudFormation provides a response module ([cfn-response](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-lambda-function-code-cfnresponsemodule.html)) that simplifies sending responses. See [Using Lambda with CloudFormation](https://docs.aws.amazon.com/lambda/latest/dg/services-cloudformation.html) for details.
        """
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if s3_bucket is not None:
            pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_key is not None:
            pulumi.set(__self__, "s3_key", s3_key)
        if s3_object_version is not None:
            pulumi.set(__self__, "s3_object_version", s3_object_version)
        if zip_file is not None:
            pulumi.set(__self__, "zip_file", zip_file)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[str]:
        """
        URI of a [container image](https://docs.aws.amazon.com/lambda/latest/dg/lambda-images.html) in the Amazon ECR registry.
        """
        return pulumi.get(self, "image_uri")

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> Optional[str]:
        """
        An Amazon S3 bucket in the same AWS-Region as your function. The bucket can be in a different AWS-account.
        """
        return pulumi.get(self, "s3_bucket")

    @property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> Optional[str]:
        """
        The Amazon S3 key of the deployment package.
        """
        return pulumi.get(self, "s3_key")

    @property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[str]:
        """
        For versioned objects, the version of the deployment package object to use.
        """
        return pulumi.get(self, "s3_object_version")

    @property
    @pulumi.getter(name="zipFile")
    def zip_file(self) -> Optional[str]:
        """
        (Node.js and Python) The source code of your Lambda function. If you include your function source inline with this parameter, CFN places it in a file named ``index`` and zips it to create a [deployment package](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-package.html). This zip file cannot exceed 4MB. For the ``Handler`` property, the first part of the handler identifier must be ``index``. For example, ``index.handler``.  For JSON, you must escape quotes and special characters such as newline (``\\n``) with a backslash. If you specify a function that interacts with an AWS CloudFormation custom resource, you don't have to write your own functions to send responses to the custom resource that invoked the function. AWS CloudFormation provides a response module ([cfn-response](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-lambda-function-code-cfnresponsemodule.html)) that simplifies sending responses. See [Using Lambda with CloudFormation](https://docs.aws.amazon.com/lambda/latest/dg/services-cloudformation.html) for details.
        """
        return pulumi.get(self, "zip_file")


@pulumi.output_type
class CognitoOptionsResponse(dict):
    """
    Definition of CognitoOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityPoolId":
            suggest = "identity_pool_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "userPoolId":
            suggest = "user_pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CognitoOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CognitoOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CognitoOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 identity_pool_id: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 user_pool_id: Optional[str] = None):
        """
        Definition of CognitoOptions
        :param bool enabled: <p>Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards.</p>
        :param str identity_pool_id: <p>The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
        :param str role_arn: <p>The <code>AmazonOpenSearchServiceCognitoAccess</code> role that allows OpenSearch Service to configure your user pool and identity pool.</p>
        :param str user_pool_id: <p>The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if identity_pool_id is not None:
            pulumi.set(__self__, "identity_pool_id", identity_pool_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if user_pool_id is not None:
            pulumi.set(__self__, "user_pool_id", user_pool_id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards.</p>
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="identityPoolId")
    def identity_pool_id(self) -> Optional[str]:
        """
        <p>The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
        """
        return pulumi.get(self, "identity_pool_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        <p>The <code>AmazonOpenSearchServiceCognitoAccess</code> role that allows OpenSearch Service to configure your user pool and identity pool.</p>
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> Optional[str]:
        """
        <p>The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.</p>
        """
        return pulumi.get(self, "user_pool_id")


@pulumi.output_type
class CognitoUserPoolConfigResponse(dict):
    """
    Definition of CognitoUserPoolConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appIdClientRegex":
            suggest = "app_id_client_regex"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "userPoolId":
            suggest = "user_pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CognitoUserPoolConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CognitoUserPoolConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CognitoUserPoolConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id_client_regex: Optional[str] = None,
                 aws_region: Optional[str] = None,
                 user_pool_id: Optional[str] = None):
        """
        Definition of CognitoUserPoolConfig
        :param str app_id_client_regex: <p>A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.</p>
        :param str aws_region: <p>The Amazon Web Services Region in which the user pool was created.</p>
        :param str user_pool_id: <p>The user pool ID.</p>
        """
        if app_id_client_regex is not None:
            pulumi.set(__self__, "app_id_client_regex", app_id_client_regex)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if user_pool_id is not None:
            pulumi.set(__self__, "user_pool_id", user_pool_id)

    @property
    @pulumi.getter(name="appIdClientRegex")
    def app_id_client_regex(self) -> Optional[str]:
        """
        <p>A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.</p>
        """
        return pulumi.get(self, "app_id_client_regex")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        <p>The Amazon Web Services Region in which the user pool was created.</p>
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> Optional[str]:
        """
        <p>The user pool ID.</p>
        """
        return pulumi.get(self, "user_pool_id")


@pulumi.output_type
class ColdStorageOptionsResponse(dict):
    """
    Definition of ColdStorageOptions
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Definition of ColdStorageOptions
        :param bool enabled: <p>Whether to enable or disable cold storage on the domain. You must enable UltraWarm storage to enable cold storage.</p>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>Whether to enable or disable cold storage on the domain. You must enable UltraWarm storage to enable cold storage.</p>
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ComplianceExecutionSummaryResponse(dict):
    """
    Definition of ComplianceExecutionSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionId":
            suggest = "execution_id"
        elif key == "executionTime":
            suggest = "execution_time"
        elif key == "executionType":
            suggest = "execution_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComplianceExecutionSummaryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComplianceExecutionSummaryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComplianceExecutionSummaryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_id: Optional[str] = None,
                 execution_time: Optional[str] = None,
                 execution_type: Optional[str] = None):
        """
        Definition of ComplianceExecutionSummary
        :param str execution_id: <p>An ID created by the system when <code>PutComplianceItems</code> was called. For example, <code>CommandID</code> is a valid execution ID. You can use this ID in subsequent calls.</p>
        :param str execution_time: <p>The time the execution ran as a datetime object that is saved in the following format: <code>yyyy-MM-dd'T'HH:mm:ss'Z'</code> </p>
        :param str execution_type: <p>The type of execution. For example, <code>Command</code> is a valid execution type.</p>
        """
        if execution_id is not None:
            pulumi.set(__self__, "execution_id", execution_id)
        if execution_time is not None:
            pulumi.set(__self__, "execution_time", execution_time)
        if execution_type is not None:
            pulumi.set(__self__, "execution_type", execution_type)

    @property
    @pulumi.getter(name="executionId")
    def execution_id(self) -> Optional[str]:
        """
        <p>An ID created by the system when <code>PutComplianceItems</code> was called. For example, <code>CommandID</code> is a valid execution ID. You can use this ID in subsequent calls.</p>
        """
        return pulumi.get(self, "execution_id")

    @property
    @pulumi.getter(name="executionTime")
    def execution_time(self) -> Optional[str]:
        """
        <p>The time the execution ran as a datetime object that is saved in the following format: <code>yyyy-MM-dd'T'HH:mm:ss'Z'</code> </p>
        """
        return pulumi.get(self, "execution_time")

    @property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> Optional[str]:
        """
        <p>The type of execution. For example, <code>Command</code> is a valid execution type.</p>
        """
        return pulumi.get(self, "execution_type")


@pulumi.output_type
class ComplianceSeverityEnumValueResponse(dict):
    """
    Definition of ComplianceSeverityEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ComplianceSeverityEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ComplianceStatusEnumValueResponse(dict):
    """
    Definition of ComplianceStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ComplianceStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CompliantSummaryResponse(dict):
    """
    Definition of CompliantSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compliantCount":
            suggest = "compliant_count"
        elif key == "severitySummary":
            suggest = "severity_summary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CompliantSummaryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CompliantSummaryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CompliantSummaryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compliant_count: Optional[int] = None,
                 severity_summary: Optional['outputs.SeveritySummaryResponse'] = None):
        """
        Definition of CompliantSummary
        :param int compliant_count: <p>The total number of resources that are compliant.</p>
        :param 'SeveritySummaryResponse' severity_summary: <p>A summary of the compliance severity by compliance type.</p>
        """
        if compliant_count is not None:
            pulumi.set(__self__, "compliant_count", compliant_count)
        if severity_summary is not None:
            pulumi.set(__self__, "severity_summary", severity_summary)

    @property
    @pulumi.getter(name="compliantCount")
    def compliant_count(self) -> Optional[int]:
        """
        <p>The total number of resources that are compliant.</p>
        """
        return pulumi.get(self, "compliant_count")

    @property
    @pulumi.getter(name="severitySummary")
    def severity_summary(self) -> Optional['outputs.SeveritySummaryResponse']:
        """
        <p>A summary of the compliance severity by compliance type.</p>
        """
        return pulumi.get(self, "severity_summary")


@pulumi.output_type
class ComputeTypeEnumValueResponse(dict):
    """
    Definition of ComputeTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ComputeTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ConditionResponse(dict):
    """
    Definition of Condition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCondition":
            suggest = "action_condition"
        elif key == "labelNameCondition":
            suggest = "label_name_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_condition: Optional['outputs.ActionConditionModelPropertiesResponse'] = None,
                 label_name_condition: Optional['outputs.LabelNameConditionModelPropertiesResponse'] = None):
        """
        Definition of Condition
        :param 'ActionConditionModelPropertiesResponse' action_condition: A single action condition.
        :param 'LabelNameConditionModelPropertiesResponse' label_name_condition: A single label name condition.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional['outputs.ActionConditionModelPropertiesResponse']:
        """
        A single action condition.
        """
        return pulumi.get(self, "action_condition")

    @property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional['outputs.LabelNameConditionModelPropertiesResponse']:
        """
        A single label name condition.
        """
        return pulumi.get(self, "label_name_condition")


@pulumi.output_type
class ConfigChangeStatusEnumValueResponse(dict):
    """
    Definition of ConfigChangeStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ConfigChangeStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ConfigServiceConfigurationRecorderPropertiesResponse(dict):
    """
    Definition of ConfigServiceConfigurationRecorder
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigServiceConfigurationRecorderPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigServiceConfigurationRecorderPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigServiceConfigurationRecorderPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsConfigServiceConfigurationRecorderPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ConfigServiceConfigurationRecorder
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsConfigServiceConfigurationRecorderPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsConfigServiceConfigurationRecorderPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ConfigServiceConfigurationRecorderStatusPropertiesResponse(dict):
    """
    Definition of ConfigServiceConfigurationRecorderStatus
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigServiceConfigurationRecorderStatusPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigServiceConfigurationRecorderStatusPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigServiceConfigurationRecorderStatusPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsConfigServiceConfigurationRecorderStatusPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ConfigServiceConfigurationRecorderStatus
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsConfigServiceConfigurationRecorderStatusPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsConfigServiceConfigurationRecorderStatusPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ConfigServiceDeliveryChannelPropertiesResponse(dict):
    """
    Definition of ConfigServiceDeliveryChannel
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigServiceDeliveryChannelPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigServiceDeliveryChannelPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigServiceDeliveryChannelPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsConfigServiceDeliveryChannelPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ConfigServiceDeliveryChannel
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsConfigServiceDeliveryChannelPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsConfigServiceDeliveryChannelPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ConfigSnapshotDeliveryPropertiesResponse(dict):
    """
    Definition of ConfigSnapshotDeliveryProperties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryFrequency":
            suggest = "delivery_frequency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigSnapshotDeliveryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigSnapshotDeliveryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigSnapshotDeliveryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_frequency: Optional['outputs.MaximumExecutionFrequencyEnumValueResponse'] = None):
        """
        Definition of ConfigSnapshotDeliveryProperties
        :param 'MaximumExecutionFrequencyEnumValueResponse' delivery_frequency: <p>The frequency with which Config delivers configuration snapshots.</p>
        """
        if delivery_frequency is not None:
            pulumi.set(__self__, "delivery_frequency", delivery_frequency)

    @property
    @pulumi.getter(name="deliveryFrequency")
    def delivery_frequency(self) -> Optional['outputs.MaximumExecutionFrequencyEnumValueResponse']:
        """
        <p>The frequency with which Config delivers configuration snapshots.</p>
        """
        return pulumi.get(self, "delivery_frequency")


@pulumi.output_type
class ConfigurationOptionSettingResponse(dict):
    """
    Definition of ConfigurationOptionSetting
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optionName":
            suggest = "option_name"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationOptionSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationOptionSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationOptionSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 option_name: Optional[str] = None,
                 resource_name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of ConfigurationOptionSetting
        :param str namespace: A unique namespace that identifies the option's associated AWS resource.
        :param str option_name: The name of the configuration option.
        :param str resource_name: A unique resource name for the option setting. Use it for a timebased scaling configuration option.
        :param str value: The current value for the configuration option.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if option_name is not None:
            pulumi.set(__self__, "option_name", option_name)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        A unique namespace that identifies the option's associated AWS resource.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="optionName")
    def option_name(self) -> Optional[str]:
        """
        The name of the configuration option.
        """
        return pulumi.get(self, "option_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        A unique resource name for the option setting. Use it for a timebased scaling configuration option.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The current value for the configuration option.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ConfigurationResponse(dict):
    """
    Definition of Configuration
    """
    def __init__(__self__, *,
                 classification: Optional[str] = None,
                 configurations: Optional[Sequence['outputs.ConfigurationResponse']] = None,
                 properties: Optional[Mapping[str, str]] = None):
        """
        Definition of Configuration
        :param str classification: <p>The classification within a configuration.</p>
        :param Sequence['ConfigurationResponse'] configurations: <p>A list of additional configurations to apply within a configuration object.</p>
        :param Mapping[str, str] properties: <p>A set of properties specified within a configuration classification.</p>
        """
        if classification is not None:
            pulumi.set(__self__, "classification", classification)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def classification(self) -> Optional[str]:
        """
        <p>The classification within a configuration.</p>
        """
        return pulumi.get(self, "classification")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.ConfigurationResponse']]:
        """
        <p>A list of additional configurations to apply within a configuration object.</p>
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        <p>A set of properties specified within a configuration classification.</p>
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class ConnectionTrackingSpecificationResponse(dict):
    """
    Definition of ConnectionTrackingSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tcpEstablishedTimeout":
            suggest = "tcp_established_timeout"
        elif key == "udpStreamTimeout":
            suggest = "udp_stream_timeout"
        elif key == "udpTimeout":
            suggest = "udp_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionTrackingSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionTrackingSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionTrackingSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tcp_established_timeout: Optional[int] = None,
                 udp_stream_timeout: Optional[int] = None,
                 udp_timeout: Optional[int] = None):
        """
        Definition of ConnectionTrackingSpecification
        :param int tcp_established_timeout: Property tcpEstablishedTimeout
        :param int udp_stream_timeout: Property udpStreamTimeout
        :param int udp_timeout: Property udpTimeout
        """
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[int]:
        """
        Property tcpEstablishedTimeout
        """
        return pulumi.get(self, "tcp_established_timeout")

    @property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[int]:
        """
        Property udpStreamTimeout
        """
        return pulumi.get(self, "udp_stream_timeout")

    @property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[int]:
        """
        Property udpTimeout
        """
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class ConnectionTrackingSpecificationResponseResponse(dict):
    """
    Definition of ConnectionTrackingSpecificationResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tcpEstablishedTimeout":
            suggest = "tcp_established_timeout"
        elif key == "udpStreamTimeout":
            suggest = "udp_stream_timeout"
        elif key == "udpTimeout":
            suggest = "udp_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionTrackingSpecificationResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionTrackingSpecificationResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionTrackingSpecificationResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tcp_established_timeout: Optional[int] = None,
                 udp_stream_timeout: Optional[int] = None,
                 udp_timeout: Optional[int] = None):
        """
        Definition of ConnectionTrackingSpecificationResponse
        :param int tcp_established_timeout: <p>Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.</p>
        :param int udp_stream_timeout: <p>Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.</p>
        :param int udp_timeout: <p>Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.</p>
        """
        if tcp_established_timeout is None:
            tcp_established_timeout = 432000
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is None:
            udp_stream_timeout = 180
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is None:
            udp_timeout = 30
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[int]:
        """
        <p>Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.</p>
        """
        return pulumi.get(self, "tcp_established_timeout")

    @property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[int]:
        """
        <p>Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.</p>
        """
        return pulumi.get(self, "udp_stream_timeout")

    @property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[int]:
        """
        <p>Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.</p>
        """
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class ConnectorConfigResponseResponse(dict):
    """
    Definition of ConnectorConfigResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activationCode":
            suggest = "activation_code"
        elif key == "activationExpiry":
            suggest = "activation_expiry"
        elif key == "activationId":
            suggest = "activation_id"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorConfigResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorConfigResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorConfigResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activation_code: Optional[str] = None,
                 activation_expiry: Optional[str] = None,
                 activation_id: Optional[str] = None,
                 provider: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        Definition of ConnectorConfigResponse
        :param str activation_code: <p>A unique code associated with the cluster for registration purposes.</p>
        :param str activation_expiry: <p>The expiration time of the connected cluster. The cluster's YAML file must be applied through the native provider.</p>
        :param str activation_id: <p>A unique ID associated with the cluster for registration purposes.</p>
        :param str provider: <p>The cluster's cloud service provider.</p>
        :param str role_arn: <p>The Amazon Resource Name (ARN) of the role to communicate with services from the connected Kubernetes cluster.</p>
        """
        if activation_code is not None:
            pulumi.set(__self__, "activation_code", activation_code)
        if activation_expiry is not None:
            pulumi.set(__self__, "activation_expiry", activation_expiry)
        if activation_id is not None:
            pulumi.set(__self__, "activation_id", activation_id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="activationCode")
    def activation_code(self) -> Optional[str]:
        """
        <p>A unique code associated with the cluster for registration purposes.</p>
        """
        return pulumi.get(self, "activation_code")

    @property
    @pulumi.getter(name="activationExpiry")
    def activation_expiry(self) -> Optional[str]:
        """
        <p>The expiration time of the connected cluster. The cluster's YAML file must be applied through the native provider.</p>
        """
        return pulumi.get(self, "activation_expiry")

    @property
    @pulumi.getter(name="activationId")
    def activation_id(self) -> Optional[str]:
        """
        <p>A unique ID associated with the cluster for registration purposes.</p>
        """
        return pulumi.get(self, "activation_id")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        <p>The cluster's cloud service provider.</p>
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the role to communicate with services from the connected Kubernetes cluster.</p>
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class ContainerDefinitionResponse(dict):
    """
    Definition of ContainerDefinition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialSpecs":
            suggest = "credential_specs"
        elif key == "dependsOn":
            suggest = "depends_on"
        elif key == "disableNetworking":
            suggest = "disable_networking"
        elif key == "dnsSearchDomains":
            suggest = "dns_search_domains"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "dockerLabels":
            suggest = "docker_labels"
        elif key == "dockerSecurityOptions":
            suggest = "docker_security_options"
        elif key == "entryPoint":
            suggest = "entry_point"
        elif key == "environmentFiles":
            suggest = "environment_files"
        elif key == "extraHosts":
            suggest = "extra_hosts"
        elif key == "firelensConfiguration":
            suggest = "firelens_configuration"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "linuxParameters":
            suggest = "linux_parameters"
        elif key == "logConfiguration":
            suggest = "log_configuration"
        elif key == "memoryReservation":
            suggest = "memory_reservation"
        elif key == "mountPoints":
            suggest = "mount_points"
        elif key == "portMappings":
            suggest = "port_mappings"
        elif key == "pseudoTerminal":
            suggest = "pseudo_terminal"
        elif key == "readonlyRootFilesystem":
            suggest = "readonly_root_filesystem"
        elif key == "repositoryCredentials":
            suggest = "repository_credentials"
        elif key == "resourceRequirements":
            suggest = "resource_requirements"
        elif key == "startTimeout":
            suggest = "start_timeout"
        elif key == "stopTimeout":
            suggest = "stop_timeout"
        elif key == "systemControls":
            suggest = "system_controls"
        elif key == "volumesFrom":
            suggest = "volumes_from"
        elif key == "workingDirectory":
            suggest = "working_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: Optional[Sequence[str]] = None,
                 cpu: Optional[int] = None,
                 credential_specs: Optional[Sequence[str]] = None,
                 depends_on: Optional[Sequence['outputs.ContainerDependencyResponse']] = None,
                 disable_networking: Optional[bool] = None,
                 dns_search_domains: Optional[Sequence[str]] = None,
                 dns_servers: Optional[Sequence[str]] = None,
                 docker_labels: Optional[Any] = None,
                 docker_security_options: Optional[Sequence[str]] = None,
                 entry_point: Optional[Sequence[str]] = None,
                 environment: Optional[Sequence['outputs.KeyValuePairResponse']] = None,
                 environment_files: Optional[Sequence['outputs.EnvironmentFileResponse']] = None,
                 essential: Optional[bool] = None,
                 extra_hosts: Optional[Sequence['outputs.HostEntryResponse']] = None,
                 firelens_configuration: Optional['outputs.FirelensConfigurationResponse'] = None,
                 health_check: Optional['outputs.HealthCheckResponse'] = None,
                 hostname: Optional[str] = None,
                 image: Optional[str] = None,
                 interactive: Optional[bool] = None,
                 links: Optional[Sequence[str]] = None,
                 linux_parameters: Optional['outputs.LinuxParametersResponse'] = None,
                 log_configuration: Optional['outputs.LogConfigurationResponse'] = None,
                 memory: Optional[int] = None,
                 memory_reservation: Optional[int] = None,
                 mount_points: Optional[Sequence['outputs.MountPointResponse']] = None,
                 name: Optional[str] = None,
                 port_mappings: Optional[Sequence['outputs.PortMappingResponse']] = None,
                 privileged: Optional[bool] = None,
                 pseudo_terminal: Optional[bool] = None,
                 readonly_root_filesystem: Optional[bool] = None,
                 repository_credentials: Optional['outputs.RepositoryCredentialsResponse'] = None,
                 resource_requirements: Optional[Sequence['outputs.ResourceRequirementResponse']] = None,
                 secrets: Optional[Sequence['outputs.SecretResponse']] = None,
                 start_timeout: Optional[int] = None,
                 stop_timeout: Optional[int] = None,
                 system_controls: Optional[Sequence['outputs.SystemControlResponse']] = None,
                 ulimits: Optional[Sequence['outputs.UlimitResponse']] = None,
                 user: Optional[str] = None,
                 volumes_from: Optional[Sequence['outputs.VolumeFromResponse']] = None,
                 working_directory: Optional[str] = None):
        """
        Definition of ContainerDefinition
        :param Sequence[str] command: The command that's passed to the container. This parameter maps to ``Cmd`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``COMMAND`` parameter to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). For more information, see [https://docs.docker.com/engine/reference/builder/#cmd](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/builder/#cmd). If there are multiple arguments, each argument is a separated string in the array.
        :param int cpu: The number of ``cpu`` units reserved for the container. This parameter maps to ``CpuShares`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--cpu-shares`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). This field is optional for tasks using the Fargate launch type, and the only requirement is that the total amount of CPU reserved for all containers within a task be lower than the task-level ``cpu`` value.  You can determine the number of CPU units that are available per EC2 instance type by multiplying the vCPUs listed for that instance type on the [Amazon EC2 Instances](https://docs.aws.amazon.com/ec2/instance-types/) detail page by 1,024.  Linux containers share unallocated CPU units with other containers on the container instance with the same ratio as their allocated amount. For example, if you run a single-container task on a single-core instance type with 512 CPU units specified for that container, and that's the only task running on the container instance, that container could use the full 1,024 CPU unit share at any given time. However, if you launched another copy of the same task on that container instance, each task is guaranteed a minimum of 512 CPU units when needed. Moreover, each container could float to higher CPU usage if the other container was not using it. If both tasks were 100% active all of the time, they would be limited to 512 CPU units. On Linux container instances, the Docker daemon on the container instance uses the CPU value to calculate the relative CPU share ratios for running containers. For more information, see [CPU share constraint](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#cpu-share-constraint) in the Docker documentation. The minimum valid CPU share value that the Linux kernel allows is 2. However, the CPU parameter isn't required, and you can use CPU values below 2 in your container definitions. For CPU values below 2 (including null), the behavior varies based on your Amazon ECS container agent version:  +   *Agent versions less than or equal to 1.1.0:* Null and zero CPU values are passed to Docker as 0, which Docker then converts to 1,024 CPU shares. CPU values of 1 are passed to Docker as 1, which the Linux kernel converts to two CPU shares.  +   *Agent versions greater than or equal to 1.2.0:* Null, zero, and CPU values of 1 are passed to Docker as 2.   On Windows container instances, the CPU limit is enforced as an absolute limit, or a quota. Windows containers only have access to the specified amount of CPU that's described in the task definition. A null or zero CPU value is passed to Docker as ``0``, which Windows interprets as 1% of one CPU.
        :param Sequence[str] credential_specs: A list of ARNs in SSM or Amazon S3 to a credential spec (``CredSpec``) file that configures the container for Active Directory authentication. We recommend that you use this parameter instead of the ``dockerSecurityOptions``. The maximum number of ARNs is 1. There are two formats for each ARN.  + credentialspecdomainless:MyARN You use credentialspecdomainless:MyARN to provide a CredSpec with an additional section for a secret in . You provide the login credentials to the domain in the secret. Each task that runs on any container instance can join different domains. You can use this format without joining the container instance to a domain. + credentialspec:MyARN You use credentialspec:MyARN to provide a CredSpec for a single domain. You must join the container instance to the domain before you start any tasks that use this task definition.  In both formats, replace ``MyARN`` with the ARN in SSM or Amazon S3. If you provide a ``credentialspecdomainless:MyARN``, the ``credspec`` must provide a ARN in ASMlong for a secret containing the username, password, and the domain to connect to. For better security, the instance isn't joined to the domain for domainless authentication. Other applications on the instance can't use the domainless credentials. You can use this parameter to run tasks on the same instance, even it the tasks need to join different domains. For more information, see [Using gMSAs for Windows Containers](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/windows-gmsa.html) and [Using gMSAs for Linux Containers](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/linux-gmsa.html).
        :param Sequence['ContainerDependencyResponse'] depends_on: The dependencies defined for container startup and shutdown. A container can contain multiple dependencies. When a dependency is defined for container startup, for container shutdown it is reversed. For tasks using the EC2 launch type, the container instances require at least version 1.26.0 of the container agent to turn on container dependencies. However, we recommend using the latest container agent version. For information about checking your agent version and updating to the latest version, see [Updating the Amazon ECS Container Agent](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html) in the *Amazon Elastic Container Service Developer Guide*. If you're using an Amazon ECS-optimized Linux AMI, your instance needs at least version 1.26.0-1 of the ``ecs-init`` package. If your container instances are launched from version ``20190301`` or later, then they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html) in the *Amazon Elastic Container Service Developer Guide*. For tasks using the Fargate launch type, the task or service requires the following platforms:  +  Linux platform version ``1.3.0`` or later.  +  Windows platform version ``1.0.0`` or later.   If the task definition is used in a blue/green deployment that uses [AWS::CodeDeploy::DeploymentGroup BlueGreenDeploymentConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-bluegreendeploymentconfiguration.html), the ``dependsOn`` parameter is not supported. For more information see [Issue #680](https://docs.aws.amazon.com/https://github.com/aws-cloudformation/cloudformation-coverage-roadmap/issues/680) on the on the GitHub website.
        :param bool disable_networking: When this parameter is true, networking is off within the container. This parameter maps to ``NetworkDisabled`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/).  This parameter is not supported for Windows containers.
        :param Sequence[str] dns_search_domains: A list of DNS search domains that are presented to the container. This parameter maps to ``DnsSearch`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--dns-search`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers.
        :param Sequence[str] dns_servers: A list of DNS servers that are presented to the container. This parameter maps to ``Dns`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--dns`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers.
        :param Any docker_labels: A key/value map of labels to add to the container. This parameter maps to ``Labels`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--label`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). This parameter requires version 1.18 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``
        :param Sequence[str] docker_security_options: A list of strings to provide custom configuration for multiple security systems. For more information about valid values, see [Docker Run Security Configuration](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). This field isn't valid for containers in tasks using the Fargate launch type. For Linux tasks on EC2, this parameter can be used to reference custom labels for SELinux and AppArmor multi-level security systems. For any tasks on EC2, this parameter can be used to reference a credential spec file that configures a container for Active Directory authentication. For more information, see [Using gMSAs for Windows Containers](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/windows-gmsa.html) and [Using gMSAs for Linux Containers](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/linux-gmsa.html) in the *Amazon Elastic Container Service Developer Guide*. This parameter maps to ``SecurityOpt`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--security-opt`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  The Amazon ECS container agent running on a container instance must register with the ``ECS_SELINUX_CAPABLE=true`` or ``ECS_APPARMOR_CAPABLE=true`` environment variables before containers placed on that instance can use these security options. For more information, see [Amazon ECS Container Agent Configuration](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the *Amazon Elastic Container Service Developer Guide*.  For more information about valid values, see [Docker Run Security Configuration](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  Valid values: 'no-new-privileges' | 'apparmor:PROFILE' | 'label:value' | 'credentialspec:CredentialSpecFilePath'
        :param Sequence[str] entry_point: Early versions of the Amazon ECS container agent don't properly handle ``entryPoint`` parameters. If you have problems using ``entryPoint``, update your container agent or enter your commands and arguments as ``command`` array items instead.  The entry point that's passed to the container. This parameter maps to ``Entrypoint`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--entrypoint`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). For more information, see [https://docs.docker.com/engine/reference/builder/#entrypoint](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/builder/#entrypoint).
        :param Sequence['KeyValuePairResponse'] environment: The environment variables to pass to a container. This parameter maps to ``Env`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--env`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  We don't recommend that you use plaintext environment variables for sensitive information, such as credential data.
        :param Sequence['EnvironmentFileResponse'] environment_files: A list of files containing the environment variables to pass to a container. This parameter maps to the ``--env-file`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). You can specify up to ten environment files. The file must have a ``.env`` file extension. Each line in an environment file contains an environment variable in ``VARIABLE=VALUE`` format. Lines beginning with ``#`` are treated as comments and are ignored. For more information about the environment variable file syntax, see [Declare default environment variables in file](https://docs.aws.amazon.com/https://docs.docker.com/compose/env-file/). If there are environment variables specified using the ``environment`` parameter in a container definition, they take precedence over the variables contained within an environment file. If multiple environment files are specified that contain the same variable, they're processed from the top down. We recommend that you use unique variable names. For more information, see [Specifying Environment Variables](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/taskdef-envfiles.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param bool essential: If the ``essential`` parameter of a container is marked as ``true``, and that container fails or stops for any reason, all other containers that are part of the task are stopped. If the ``essential`` parameter of a container is marked as ``false``, its failure doesn't affect the rest of the containers in a task. If this parameter is omitted, a container is assumed to be essential. All tasks must have at least one essential container. If you have an application that's composed of multiple containers, group containers that are used for a common purpose into components, and separate the different components into multiple task definitions. For more information, see [Application Architecture](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/application_architecture.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param Sequence['HostEntryResponse'] extra_hosts: A list of hostnames and IP address mappings to append to the ``/etc/hosts`` file on the container. This parameter maps to ``ExtraHosts`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--add-host`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter isn't supported for Windows containers or tasks that use the ``awsvpc`` network mode.
        :param 'FirelensConfigurationResponse' firelens_configuration: The FireLens configuration for the container. This is used to specify and configure a log router for container logs. For more information, see [Custom Log Routing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_firelens.html) in the *Amazon Elastic Container Service Developer Guide*. The FireLens configuration for the container. This is used to specify and configure a log router for container logs. For more information, see [Custom log routing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_firelens.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param 'HealthCheckResponse' health_check: The container health check command and associated configuration parameters for the container. This parameter maps to ``HealthCheck`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``HEALTHCHECK`` parameter of [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). The ``HealthCheck`` property specifies an object representing a container health check. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image (such as those specified in a parent image or from the image's Dockerfile). This configuration maps to the ``HEALTHCHECK`` parameter of [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/).  The Amazon ECS container agent only monitors and reports on the health checks specified in the task definition. Amazon ECS does not monitor Docker health checks that are embedded in a container image and not specified in the container definition. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image.  If a task is run manually, and not as part of a service, the task will continue its lifecycle regardless of its health status. For tasks that are part of a service, if the task reports as unhealthy then the task will be stopped and the service scheduler will replace it. The following are notes about container health check support:  +  Container health checks require version 1.17.0 or greater of the Amazon ECS container agent. For more information, see [Updating the Amazon ECS Container Agent](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html).  +  Container health checks are supported for Fargate tasks if you are using platform version 1.1.0 or greater. For more information, see [Platform Versions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).  +  Container health checks are not supported for tasks that are part of a service that is configured to use a Classic Load Balancer.
        :param str hostname: The hostname to use for your container. This parameter maps to ``Hostname`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--hostname`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  The ``hostname`` parameter is not supported if you're using the ``awsvpc`` network mode.
        :param str image: The image used to start a container. This string is passed directly to the Docker daemon. By default, images in the Docker Hub registry are available. Other repositories are specified with either ``repository-url/image:tag`` or ``repository-url/image@digest``. Up to 255 letters (uppercase and lowercase), numbers, hyphens, underscores, colons, periods, forward slashes, and number signs are allowed. This parameter maps to ``Image`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``IMAGE`` parameter of [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  +  When a new task starts, the Amazon ECS container agent pulls the latest version of the specified image and tag for the container to use. However, subsequent updates to a repository image aren't propagated to already running tasks.  +  Images in Amazon ECR repositories can be specified by either using the full ``registry/repository:tag`` or ``registry/repository@digest``. For example, ``012345678910.dkr.ecr.<region-name>.amazonaws.com/<repository-name>:latest`` or ``012345678910.dkr.ecr.<region-name>.amazonaws.com/<repository-name>@sha256:94afd1f2e64d908bc90dbca0035a5b567EXAMPLE``.   +  Images in official repositories on Docker Hub use a single name (for example, ``ubuntu`` or ``mongo``).  +  Images in other repositories on Docker Hub are qualified with an organization name (for example, ``amazon/amazon-ecs-agent``).  +  Images in other online repositories are qualified further by a domain name (for example, ``quay.io/assemblyline/ubuntu``).
        :param bool interactive: When this parameter is ``true``, you can deploy containerized applications that require ``stdin`` or a ``tty`` to be allocated. This parameter maps to ``OpenStdin`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--interactive`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        :param Sequence[str] links: The ``links`` parameter allows containers to communicate with each other without the need for port mappings. This parameter is only supported if the network mode of a task definition is ``bridge``. The ``name:internalName`` construct is analogous to ``name:alias`` in Docker links. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. For more information about linking Docker containers, go to [Legacy container links](https://docs.aws.amazon.com/https://docs.docker.com/network/links/) in the Docker documentation. This parameter maps to ``Links`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--link`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers.   Containers that are collocated on a single container instance may be able to communicate with each other without requiring links or host port mappings. Network isolation is achieved on the container instance using security groups and VPC settings.
        :param 'LinuxParametersResponse' linux_parameters: Linux-specific modifications that are applied to the container, such as Linux kernel capabilities. For more information see [KernelCapabilities](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_KernelCapabilities.html).  This parameter is not supported for Windows containers. The Linux-specific options that are applied to the container, such as Linux [KernelCapabilities](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_KernelCapabilities.html).
        :param 'LogConfigurationResponse' log_configuration: The log configuration specification for the container. This parameter maps to ``LogConfig`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--log-driver`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/). By default, containers use the same logging driver that the Docker daemon uses. However, the container may use a different logging driver than the Docker daemon by specifying a log driver with this parameter in the container definition. To use a different logging driver for a container, the log system must be configured properly on the container instance (or on a different log server for remote logging options). For more information on the options for different supported log drivers, see [Configure logging drivers](https://docs.aws.amazon.com/https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation.  Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon (shown in the [LogConfiguration](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_LogConfiguration.html) data type). Additional log drivers may be available in future releases of the Amazon ECS container agent.  This parameter requires version 1.18 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``   The Amazon ECS container agent running on a container instance must register the logging drivers available on that instance with the ``ECS_AVAILABLE_LOGGING_DRIVERS`` environment variable before containers placed on that instance can use these log configuration options. For more information, see [Amazon ECS Container Agent Configuration](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the *Amazon Elastic Container Service Developer Guide*. The ``LogConfiguration`` property specifies log configuration options to send to a custom log driver for the container.
        :param int memory: The amount (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed. The total amount of memory reserved for all containers within a task must be lower than the task ``memory`` value, if one is specified. This parameter maps to ``Memory`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--memory`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). If using the Fargate launch type, this parameter is optional. If using the EC2 launch type, you must specify either a task-level memory value or a container-level memory value. If you specify both a container-level ``memory`` and ``memoryReservation`` value, ``memory`` must be greater than ``memoryReservation``. If you specify ``memoryReservation``, then that value is subtracted from the available memory resources for the container instance where the container is placed. Otherwise, the value of ``memory`` is used. The Docker 20.10.0 or later daemon reserves a minimum of 6 MiB of memory for a container, so you should not specify fewer than 6 MiB of memory for your containers. The Docker 19.03.13-ce or earlier daemon reserves a minimum of 4 MiB of memory for a container, so you should not specify fewer than 4 MiB of memory for your containers.
        :param int memory_reservation: The soft limit (in MiB) of memory to reserve for the container. When system memory is under heavy contention, Docker attempts to keep the container memory to this soft limit. However, your container can consume more memory when it needs to, up to either the hard limit specified with the ``memory`` parameter (if applicable), or all of the available memory on the container instance, whichever comes first. This parameter maps to ``MemoryReservation`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--memory-reservation`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). If a task-level memory value is not specified, you must specify a non-zero integer for one or both of ``memory`` or ``memoryReservation`` in a container definition. If you specify both, ``memory`` must be greater than ``memoryReservation``. If you specify ``memoryReservation``, then that value is subtracted from the available memory resources for the container instance where the container is placed. Otherwise, the value of ``memory`` is used. For example, if your container normally uses 128 MiB of memory, but occasionally bursts to 256 MiB of memory for short periods of time, you can set a ``memoryReservation`` of 128 MiB, and a ``memory`` hard limit of 300 MiB. This configuration would allow the container to only reserve 128 MiB of memory from the remaining resources on the container instance, but also allow the container to consume more memory resources when needed. The Docker 20.10.0 or later daemon reserves a minimum of 6 MiB of memory for a container. So, don't specify less than 6 MiB of memory for your containers.  The Docker 19.03.13-ce or earlier daemon reserves a minimum of 4 MiB of memory for a container. So, don't specify less than 4 MiB of memory for your containers.
        :param Sequence['MountPointResponse'] mount_points: The mount points for data volumes in your container. This parameter maps to ``Volumes`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--volume`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). Windows containers can mount whole directories on the same drive as ``$env:ProgramData``. Windows containers can't mount directories on a different drive, and mount point can't be across drives.
        :param str name: The name of a container. If you're linking multiple containers together in a task definition, the ``name`` of one container can be entered in the ``links`` of another container to connect the containers. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. This parameter maps to ``name`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--name`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        :param Sequence['PortMappingResponse'] port_mappings: The list of port mappings for the container. Port mappings allow containers to access ports on the host container instance to send or receive traffic. For task definitions that use the ``awsvpc`` network mode, you should only specify the ``containerPort``. The ``hostPort`` can be left blank or it must be the same value as the ``containerPort``. Port mappings on Windows use the ``NetNAT`` gateway address rather than ``localhost``. There is no loopback for port mappings on Windows, so you cannot access a container's mapped port from the host itself.  This parameter maps to ``PortBindings`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--publish`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/). If the network mode of a task definition is set to ``none``, then you can't specify port mappings. If the network mode of a task definition is set to ``host``, then host ports must either be undefined or they must match the container port in the port mapping.  After a task reaches the ``RUNNING`` status, manual and automatic host and container port assignments are visible in the *Network Bindings* section of a container description for a selected task in the Amazon ECS console. The assignments are also visible in the ``networkBindings`` section [DescribeTasks](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeTasks.html) responses.
        :param bool privileged: When this parameter is true, the container is given elevated privileges on the host container instance (similar to the ``root`` user). This parameter maps to ``Privileged`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--privileged`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers or tasks run on FARGATElong.
        :param bool pseudo_terminal: When this parameter is ``true``, a TTY is allocated. This parameter maps to ``Tty`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--tty`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        :param bool readonly_root_filesystem: When this parameter is true, the container is given read-only access to its root file system. This parameter maps to ``ReadonlyRootfs`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--read-only`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers.
        :param 'RepositoryCredentialsResponse' repository_credentials: The private repository authentication credentials to use. The repository credentials for private registry authentication.
        :param Sequence['ResourceRequirementResponse'] resource_requirements: The type and amount of a resource to assign to a container. The only supported resource is a GPU.
        :param Sequence['SecretResponse'] secrets: The secrets to pass to the container. For more information, see [Specifying Sensitive Data](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/specifying-sensitive-data.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param int start_timeout: Time duration (in seconds) to wait before giving up on resolving dependencies for a container. For example, you specify two containers in a task definition with containerA having a dependency on containerB reaching a ``COMPLETE``, ``SUCCESS``, or ``HEALTHY`` status. If a ``startTimeout`` value is specified for containerB and it doesn't reach the desired status within that time then containerA gives up and not start. This results in the task transitioning to a ``STOPPED`` state.  When the ``ECS_CONTAINER_START_TIMEOUT`` container agent configuration variable is used, it's enforced independently from this start timeout value.  For tasks using the Fargate launch type, the task or service requires the following platforms:  +  Linux platform version ``1.3.0`` or later.  +  Windows platform version ``1.0.0`` or later.   For tasks using the EC2 launch type, your container instances require at least version ``1.26.0`` of the container agent to use a container start timeout value. However, we recommend using the latest container agent version. For information about checking your agent version and updating to the latest version, see [Updating the Amazon ECS Container Agent](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html) in the *Amazon Elastic Container Service Developer Guide*. If you're using an Amazon ECS-optimized Linux AMI, your instance needs at least version ``1.26.0-1`` of the ``ecs-init`` package. If your container instances are launched from version ``20190301`` or later, then they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html) in the *Amazon Elastic Container Service Developer Guide*. The valid values are 2-120 seconds.
        :param int stop_timeout: Time duration (in seconds) to wait before the container is forcefully killed if it doesn't exit normally on its own. For tasks using the Fargate launch type, the task or service requires the following platforms:  +  Linux platform version ``1.3.0`` or later.  +  Windows platform version ``1.0.0`` or later.   The max stop timeout value is 120 seconds and if the parameter is not specified, the default value of 30 seconds is used. For tasks that use the EC2 launch type, if the ``stopTimeout`` parameter isn't specified, the value set for the Amazon ECS container agent configuration variable ``ECS_CONTAINER_STOP_TIMEOUT`` is used. If neither the ``stopTimeout`` parameter or the ``ECS_CONTAINER_STOP_TIMEOUT`` agent configuration variable are set, then the default values of 30 seconds for Linux containers and 30 seconds on Windows containers are used. Your container instances require at least version 1.26.0 of the container agent to use a container stop timeout value. However, we recommend using the latest container agent version. For information about checking your agent version and updating to the latest version, see [Updating the Amazon ECS Container Agent](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html) in the *Amazon Elastic Container Service Developer Guide*. If you're using an Amazon ECS-optimized Linux AMI, your instance needs at least version 1.26.0-1 of the ``ecs-init`` package. If your container instances are launched from version ``20190301`` or later, then they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html) in the *Amazon Elastic Container Service Developer Guide*. The valid values are 2-120 seconds.
        :param Sequence['SystemControlResponse'] system_controls: A list of namespaced kernel parameters to set in the container. This parameter maps to ``Sysctls`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--sysctl`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). For example, you can configure ``net.ipv4.tcp_keepalive_time`` setting to maintain longer lived connections.
        :param Sequence['UlimitResponse'] ulimits: A list of ``ulimits`` to set in the container. This parameter maps to ``Ulimits`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--ulimit`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/). Valid naming values are displayed in the [Ulimit](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_Ulimit.html) data type. This parameter requires version 1.18 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``   This parameter is not supported for Windows containers.
        :param str user: The user to use inside the container. This parameter maps to ``User`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--user`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  When running tasks using the ``host`` network mode, don't run containers using the root user (UID 0). We recommend using a non-root user for better security.  You can specify the ``user`` using the following formats. If specifying a UID or GID, you must specify it as a positive integer.  +   ``user``   +   ``user:group``   +   ``uid``   +   ``uid:gid``   +   ``user:gid``   +   ``uid:group``     This parameter is not supported for Windows containers.
        :param Sequence['VolumeFromResponse'] volumes_from: Data volumes to mount from another container. This parameter maps to ``VolumesFrom`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--volumes-from`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        :param str working_directory: The working directory to run commands inside the container in. This parameter maps to ``WorkingDir`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--workdir`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        """
        if command is not None:
            pulumi.set(__self__, "command", command)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if credential_specs is not None:
            pulumi.set(__self__, "credential_specs", credential_specs)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if disable_networking is not None:
            pulumi.set(__self__, "disable_networking", disable_networking)
        if dns_search_domains is not None:
            pulumi.set(__self__, "dns_search_domains", dns_search_domains)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if docker_labels is not None:
            pulumi.set(__self__, "docker_labels", docker_labels)
        if docker_security_options is not None:
            pulumi.set(__self__, "docker_security_options", docker_security_options)
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if environment_files is not None:
            pulumi.set(__self__, "environment_files", environment_files)
        if essential is not None:
            pulumi.set(__self__, "essential", essential)
        if extra_hosts is not None:
            pulumi.set(__self__, "extra_hosts", extra_hosts)
        if firelens_configuration is not None:
            pulumi.set(__self__, "firelens_configuration", firelens_configuration)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if interactive is not None:
            pulumi.set(__self__, "interactive", interactive)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if linux_parameters is not None:
            pulumi.set(__self__, "linux_parameters", linux_parameters)
        if log_configuration is not None:
            pulumi.set(__self__, "log_configuration", log_configuration)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if memory_reservation is not None:
            pulumi.set(__self__, "memory_reservation", memory_reservation)
        if mount_points is not None:
            pulumi.set(__self__, "mount_points", mount_points)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port_mappings is not None:
            pulumi.set(__self__, "port_mappings", port_mappings)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if pseudo_terminal is not None:
            pulumi.set(__self__, "pseudo_terminal", pseudo_terminal)
        if readonly_root_filesystem is not None:
            pulumi.set(__self__, "readonly_root_filesystem", readonly_root_filesystem)
        if repository_credentials is not None:
            pulumi.set(__self__, "repository_credentials", repository_credentials)
        if resource_requirements is not None:
            pulumi.set(__self__, "resource_requirements", resource_requirements)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if start_timeout is not None:
            pulumi.set(__self__, "start_timeout", start_timeout)
        if stop_timeout is not None:
            pulumi.set(__self__, "stop_timeout", stop_timeout)
        if system_controls is not None:
            pulumi.set(__self__, "system_controls", system_controls)
        if ulimits is not None:
            pulumi.set(__self__, "ulimits", ulimits)
        if user is not None:
            pulumi.set(__self__, "user", user)
        if volumes_from is not None:
            pulumi.set(__self__, "volumes_from", volumes_from)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[str]]:
        """
        The command that's passed to the container. This parameter maps to ``Cmd`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``COMMAND`` parameter to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). For more information, see [https://docs.docker.com/engine/reference/builder/#cmd](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/builder/#cmd). If there are multiple arguments, each argument is a separated string in the array.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def cpu(self) -> Optional[int]:
        """
        The number of ``cpu`` units reserved for the container. This parameter maps to ``CpuShares`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--cpu-shares`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). This field is optional for tasks using the Fargate launch type, and the only requirement is that the total amount of CPU reserved for all containers within a task be lower than the task-level ``cpu`` value.  You can determine the number of CPU units that are available per EC2 instance type by multiplying the vCPUs listed for that instance type on the [Amazon EC2 Instances](https://docs.aws.amazon.com/ec2/instance-types/) detail page by 1,024.  Linux containers share unallocated CPU units with other containers on the container instance with the same ratio as their allocated amount. For example, if you run a single-container task on a single-core instance type with 512 CPU units specified for that container, and that's the only task running on the container instance, that container could use the full 1,024 CPU unit share at any given time. However, if you launched another copy of the same task on that container instance, each task is guaranteed a minimum of 512 CPU units when needed. Moreover, each container could float to higher CPU usage if the other container was not using it. If both tasks were 100% active all of the time, they would be limited to 512 CPU units. On Linux container instances, the Docker daemon on the container instance uses the CPU value to calculate the relative CPU share ratios for running containers. For more information, see [CPU share constraint](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#cpu-share-constraint) in the Docker documentation. The minimum valid CPU share value that the Linux kernel allows is 2. However, the CPU parameter isn't required, and you can use CPU values below 2 in your container definitions. For CPU values below 2 (including null), the behavior varies based on your Amazon ECS container agent version:  +   *Agent versions less than or equal to 1.1.0:* Null and zero CPU values are passed to Docker as 0, which Docker then converts to 1,024 CPU shares. CPU values of 1 are passed to Docker as 1, which the Linux kernel converts to two CPU shares.  +   *Agent versions greater than or equal to 1.2.0:* Null, zero, and CPU values of 1 are passed to Docker as 2.   On Windows container instances, the CPU limit is enforced as an absolute limit, or a quota. Windows containers only have access to the specified amount of CPU that's described in the task definition. A null or zero CPU value is passed to Docker as ``0``, which Windows interprets as 1% of one CPU.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="credentialSpecs")
    def credential_specs(self) -> Optional[Sequence[str]]:
        """
        A list of ARNs in SSM or Amazon S3 to a credential spec (``CredSpec``) file that configures the container for Active Directory authentication. We recommend that you use this parameter instead of the ``dockerSecurityOptions``. The maximum number of ARNs is 1. There are two formats for each ARN.  + credentialspecdomainless:MyARN You use credentialspecdomainless:MyARN to provide a CredSpec with an additional section for a secret in . You provide the login credentials to the domain in the secret. Each task that runs on any container instance can join different domains. You can use this format without joining the container instance to a domain. + credentialspec:MyARN You use credentialspec:MyARN to provide a CredSpec for a single domain. You must join the container instance to the domain before you start any tasks that use this task definition.  In both formats, replace ``MyARN`` with the ARN in SSM or Amazon S3. If you provide a ``credentialspecdomainless:MyARN``, the ``credspec`` must provide a ARN in ASMlong for a secret containing the username, password, and the domain to connect to. For better security, the instance isn't joined to the domain for domainless authentication. Other applications on the instance can't use the domainless credentials. You can use this parameter to run tasks on the same instance, even it the tasks need to join different domains. For more information, see [Using gMSAs for Windows Containers](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/windows-gmsa.html) and [Using gMSAs for Linux Containers](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/linux-gmsa.html).
        """
        return pulumi.get(self, "credential_specs")

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[Sequence['outputs.ContainerDependencyResponse']]:
        """
        The dependencies defined for container startup and shutdown. A container can contain multiple dependencies. When a dependency is defined for container startup, for container shutdown it is reversed. For tasks using the EC2 launch type, the container instances require at least version 1.26.0 of the container agent to turn on container dependencies. However, we recommend using the latest container agent version. For information about checking your agent version and updating to the latest version, see [Updating the Amazon ECS Container Agent](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html) in the *Amazon Elastic Container Service Developer Guide*. If you're using an Amazon ECS-optimized Linux AMI, your instance needs at least version 1.26.0-1 of the ``ecs-init`` package. If your container instances are launched from version ``20190301`` or later, then they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html) in the *Amazon Elastic Container Service Developer Guide*. For tasks using the Fargate launch type, the task or service requires the following platforms:  +  Linux platform version ``1.3.0`` or later.  +  Windows platform version ``1.0.0`` or later.   If the task definition is used in a blue/green deployment that uses [AWS::CodeDeploy::DeploymentGroup BlueGreenDeploymentConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-codedeploy-deploymentgroup-bluegreendeploymentconfiguration.html), the ``dependsOn`` parameter is not supported. For more information see [Issue #680](https://docs.aws.amazon.com/https://github.com/aws-cloudformation/cloudformation-coverage-roadmap/issues/680) on the on the GitHub website.
        """
        return pulumi.get(self, "depends_on")

    @property
    @pulumi.getter(name="disableNetworking")
    def disable_networking(self) -> Optional[bool]:
        """
        When this parameter is true, networking is off within the container. This parameter maps to ``NetworkDisabled`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/).  This parameter is not supported for Windows containers.
        """
        return pulumi.get(self, "disable_networking")

    @property
    @pulumi.getter(name="dnsSearchDomains")
    def dns_search_domains(self) -> Optional[Sequence[str]]:
        """
        A list of DNS search domains that are presented to the container. This parameter maps to ``DnsSearch`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--dns-search`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers.
        """
        return pulumi.get(self, "dns_search_domains")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        A list of DNS servers that are presented to the container. This parameter maps to ``Dns`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--dns`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="dockerLabels")
    def docker_labels(self) -> Optional[Any]:
        """
        A key/value map of labels to add to the container. This parameter maps to ``Labels`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--label`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). This parameter requires version 1.18 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``
        """
        return pulumi.get(self, "docker_labels")

    @property
    @pulumi.getter(name="dockerSecurityOptions")
    def docker_security_options(self) -> Optional[Sequence[str]]:
        """
        A list of strings to provide custom configuration for multiple security systems. For more information about valid values, see [Docker Run Security Configuration](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). This field isn't valid for containers in tasks using the Fargate launch type. For Linux tasks on EC2, this parameter can be used to reference custom labels for SELinux and AppArmor multi-level security systems. For any tasks on EC2, this parameter can be used to reference a credential spec file that configures a container for Active Directory authentication. For more information, see [Using gMSAs for Windows Containers](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/windows-gmsa.html) and [Using gMSAs for Linux Containers](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/linux-gmsa.html) in the *Amazon Elastic Container Service Developer Guide*. This parameter maps to ``SecurityOpt`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--security-opt`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  The Amazon ECS container agent running on a container instance must register with the ``ECS_SELINUX_CAPABLE=true`` or ``ECS_APPARMOR_CAPABLE=true`` environment variables before containers placed on that instance can use these security options. For more information, see [Amazon ECS Container Agent Configuration](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the *Amazon Elastic Container Service Developer Guide*.  For more information about valid values, see [Docker Run Security Configuration](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  Valid values: 'no-new-privileges' | 'apparmor:PROFILE' | 'label:value' | 'credentialspec:CredentialSpecFilePath'
        """
        return pulumi.get(self, "docker_security_options")

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[Sequence[str]]:
        """
        Early versions of the Amazon ECS container agent don't properly handle ``entryPoint`` parameters. If you have problems using ``entryPoint``, update your container agent or enter your commands and arguments as ``command`` array items instead.  The entry point that's passed to the container. This parameter maps to ``Entrypoint`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--entrypoint`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). For more information, see [https://docs.docker.com/engine/reference/builder/#entrypoint](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/builder/#entrypoint).
        """
        return pulumi.get(self, "entry_point")

    @property
    @pulumi.getter
    def environment(self) -> Optional[Sequence['outputs.KeyValuePairResponse']]:
        """
        The environment variables to pass to a container. This parameter maps to ``Env`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--env`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  We don't recommend that you use plaintext environment variables for sensitive information, such as credential data.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="environmentFiles")
    def environment_files(self) -> Optional[Sequence['outputs.EnvironmentFileResponse']]:
        """
        A list of files containing the environment variables to pass to a container. This parameter maps to the ``--env-file`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). You can specify up to ten environment files. The file must have a ``.env`` file extension. Each line in an environment file contains an environment variable in ``VARIABLE=VALUE`` format. Lines beginning with ``#`` are treated as comments and are ignored. For more information about the environment variable file syntax, see [Declare default environment variables in file](https://docs.aws.amazon.com/https://docs.docker.com/compose/env-file/). If there are environment variables specified using the ``environment`` parameter in a container definition, they take precedence over the variables contained within an environment file. If multiple environment files are specified that contain the same variable, they're processed from the top down. We recommend that you use unique variable names. For more information, see [Specifying Environment Variables](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/taskdef-envfiles.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "environment_files")

    @property
    @pulumi.getter
    def essential(self) -> Optional[bool]:
        """
        If the ``essential`` parameter of a container is marked as ``true``, and that container fails or stops for any reason, all other containers that are part of the task are stopped. If the ``essential`` parameter of a container is marked as ``false``, its failure doesn't affect the rest of the containers in a task. If this parameter is omitted, a container is assumed to be essential. All tasks must have at least one essential container. If you have an application that's composed of multiple containers, group containers that are used for a common purpose into components, and separate the different components into multiple task definitions. For more information, see [Application Architecture](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/application_architecture.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "essential")

    @property
    @pulumi.getter(name="extraHosts")
    def extra_hosts(self) -> Optional[Sequence['outputs.HostEntryResponse']]:
        """
        A list of hostnames and IP address mappings to append to the ``/etc/hosts`` file on the container. This parameter maps to ``ExtraHosts`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--add-host`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter isn't supported for Windows containers or tasks that use the ``awsvpc`` network mode.
        """
        return pulumi.get(self, "extra_hosts")

    @property
    @pulumi.getter(name="firelensConfiguration")
    def firelens_configuration(self) -> Optional['outputs.FirelensConfigurationResponse']:
        """
        The FireLens configuration for the container. This is used to specify and configure a log router for container logs. For more information, see [Custom Log Routing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_firelens.html) in the *Amazon Elastic Container Service Developer Guide*. The FireLens configuration for the container. This is used to specify and configure a log router for container logs. For more information, see [Custom log routing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_firelens.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "firelens_configuration")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.HealthCheckResponse']:
        """
        The container health check command and associated configuration parameters for the container. This parameter maps to ``HealthCheck`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``HEALTHCHECK`` parameter of [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). The ``HealthCheck`` property specifies an object representing a container health check. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image (such as those specified in a parent image or from the image's Dockerfile). This configuration maps to the ``HEALTHCHECK`` parameter of [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/).  The Amazon ECS container agent only monitors and reports on the health checks specified in the task definition. Amazon ECS does not monitor Docker health checks that are embedded in a container image and not specified in the container definition. Health check parameters that are specified in a container definition override any Docker health checks that exist in the container image.  If a task is run manually, and not as part of a service, the task will continue its lifecycle regardless of its health status. For tasks that are part of a service, if the task reports as unhealthy then the task will be stopped and the service scheduler will replace it. The following are notes about container health check support:  +  Container health checks require version 1.17.0 or greater of the Amazon ECS container agent. For more information, see [Updating the Amazon ECS Container Agent](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html).  +  Container health checks are supported for Fargate tasks if you are using platform version 1.1.0 or greater. For more information, see [Platform Versions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).  +  Container health checks are not supported for tasks that are part of a service that is configured to use a Classic Load Balancer.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The hostname to use for your container. This parameter maps to ``Hostname`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--hostname`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  The ``hostname`` parameter is not supported if you're using the ``awsvpc`` network mode.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The image used to start a container. This string is passed directly to the Docker daemon. By default, images in the Docker Hub registry are available. Other repositories are specified with either ``repository-url/image:tag`` or ``repository-url/image@digest``. Up to 255 letters (uppercase and lowercase), numbers, hyphens, underscores, colons, periods, forward slashes, and number signs are allowed. This parameter maps to ``Image`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``IMAGE`` parameter of [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  +  When a new task starts, the Amazon ECS container agent pulls the latest version of the specified image and tag for the container to use. However, subsequent updates to a repository image aren't propagated to already running tasks.  +  Images in Amazon ECR repositories can be specified by either using the full ``registry/repository:tag`` or ``registry/repository@digest``. For example, ``012345678910.dkr.ecr.<region-name>.amazonaws.com/<repository-name>:latest`` or ``012345678910.dkr.ecr.<region-name>.amazonaws.com/<repository-name>@sha256:94afd1f2e64d908bc90dbca0035a5b567EXAMPLE``.   +  Images in official repositories on Docker Hub use a single name (for example, ``ubuntu`` or ``mongo``).  +  Images in other repositories on Docker Hub are qualified with an organization name (for example, ``amazon/amazon-ecs-agent``).  +  Images in other online repositories are qualified further by a domain name (for example, ``quay.io/assemblyline/ubuntu``).
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def interactive(self) -> Optional[bool]:
        """
        When this parameter is ``true``, you can deploy containerized applications that require ``stdin`` or a ``tty`` to be allocated. This parameter maps to ``OpenStdin`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--interactive`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        """
        return pulumi.get(self, "interactive")

    @property
    @pulumi.getter
    def links(self) -> Optional[Sequence[str]]:
        """
        The ``links`` parameter allows containers to communicate with each other without the need for port mappings. This parameter is only supported if the network mode of a task definition is ``bridge``. The ``name:internalName`` construct is analogous to ``name:alias`` in Docker links. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. For more information about linking Docker containers, go to [Legacy container links](https://docs.aws.amazon.com/https://docs.docker.com/network/links/) in the Docker documentation. This parameter maps to ``Links`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--link`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers.   Containers that are collocated on a single container instance may be able to communicate with each other without requiring links or host port mappings. Network isolation is achieved on the container instance using security groups and VPC settings.
        """
        return pulumi.get(self, "links")

    @property
    @pulumi.getter(name="linuxParameters")
    def linux_parameters(self) -> Optional['outputs.LinuxParametersResponse']:
        """
        Linux-specific modifications that are applied to the container, such as Linux kernel capabilities. For more information see [KernelCapabilities](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_KernelCapabilities.html).  This parameter is not supported for Windows containers. The Linux-specific options that are applied to the container, such as Linux [KernelCapabilities](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_KernelCapabilities.html).
        """
        return pulumi.get(self, "linux_parameters")

    @property
    @pulumi.getter(name="logConfiguration")
    def log_configuration(self) -> Optional['outputs.LogConfigurationResponse']:
        """
        The log configuration specification for the container. This parameter maps to ``LogConfig`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--log-driver`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/). By default, containers use the same logging driver that the Docker daemon uses. However, the container may use a different logging driver than the Docker daemon by specifying a log driver with this parameter in the container definition. To use a different logging driver for a container, the log system must be configured properly on the container instance (or on a different log server for remote logging options). For more information on the options for different supported log drivers, see [Configure logging drivers](https://docs.aws.amazon.com/https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation.  Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon (shown in the [LogConfiguration](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_LogConfiguration.html) data type). Additional log drivers may be available in future releases of the Amazon ECS container agent.  This parameter requires version 1.18 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``   The Amazon ECS container agent running on a container instance must register the logging drivers available on that instance with the ``ECS_AVAILABLE_LOGGING_DRIVERS`` environment variable before containers placed on that instance can use these log configuration options. For more information, see [Amazon ECS Container Agent Configuration](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the *Amazon Elastic Container Service Developer Guide*. The ``LogConfiguration`` property specifies log configuration options to send to a custom log driver for the container.
        """
        return pulumi.get(self, "log_configuration")

    @property
    @pulumi.getter
    def memory(self) -> Optional[int]:
        """
        The amount (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed. The total amount of memory reserved for all containers within a task must be lower than the task ``memory`` value, if one is specified. This parameter maps to ``Memory`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--memory`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). If using the Fargate launch type, this parameter is optional. If using the EC2 launch type, you must specify either a task-level memory value or a container-level memory value. If you specify both a container-level ``memory`` and ``memoryReservation`` value, ``memory`` must be greater than ``memoryReservation``. If you specify ``memoryReservation``, then that value is subtracted from the available memory resources for the container instance where the container is placed. Otherwise, the value of ``memory`` is used. The Docker 20.10.0 or later daemon reserves a minimum of 6 MiB of memory for a container, so you should not specify fewer than 6 MiB of memory for your containers. The Docker 19.03.13-ce or earlier daemon reserves a minimum of 4 MiB of memory for a container, so you should not specify fewer than 4 MiB of memory for your containers.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter(name="memoryReservation")
    def memory_reservation(self) -> Optional[int]:
        """
        The soft limit (in MiB) of memory to reserve for the container. When system memory is under heavy contention, Docker attempts to keep the container memory to this soft limit. However, your container can consume more memory when it needs to, up to either the hard limit specified with the ``memory`` parameter (if applicable), or all of the available memory on the container instance, whichever comes first. This parameter maps to ``MemoryReservation`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--memory-reservation`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). If a task-level memory value is not specified, you must specify a non-zero integer for one or both of ``memory`` or ``memoryReservation`` in a container definition. If you specify both, ``memory`` must be greater than ``memoryReservation``. If you specify ``memoryReservation``, then that value is subtracted from the available memory resources for the container instance where the container is placed. Otherwise, the value of ``memory`` is used. For example, if your container normally uses 128 MiB of memory, but occasionally bursts to 256 MiB of memory for short periods of time, you can set a ``memoryReservation`` of 128 MiB, and a ``memory`` hard limit of 300 MiB. This configuration would allow the container to only reserve 128 MiB of memory from the remaining resources on the container instance, but also allow the container to consume more memory resources when needed. The Docker 20.10.0 or later daemon reserves a minimum of 6 MiB of memory for a container. So, don't specify less than 6 MiB of memory for your containers.  The Docker 19.03.13-ce or earlier daemon reserves a minimum of 4 MiB of memory for a container. So, don't specify less than 4 MiB of memory for your containers.
        """
        return pulumi.get(self, "memory_reservation")

    @property
    @pulumi.getter(name="mountPoints")
    def mount_points(self) -> Optional[Sequence['outputs.MountPointResponse']]:
        """
        The mount points for data volumes in your container. This parameter maps to ``Volumes`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--volume`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). Windows containers can mount whole directories on the same drive as ``$env:ProgramData``. Windows containers can't mount directories on a different drive, and mount point can't be across drives.
        """
        return pulumi.get(self, "mount_points")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of a container. If you're linking multiple containers together in a task definition, the ``name`` of one container can be entered in the ``links`` of another container to connect the containers. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. This parameter maps to ``name`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--name`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="portMappings")
    def port_mappings(self) -> Optional[Sequence['outputs.PortMappingResponse']]:
        """
        The list of port mappings for the container. Port mappings allow containers to access ports on the host container instance to send or receive traffic. For task definitions that use the ``awsvpc`` network mode, you should only specify the ``containerPort``. The ``hostPort`` can be left blank or it must be the same value as the ``containerPort``. Port mappings on Windows use the ``NetNAT`` gateway address rather than ``localhost``. There is no loopback for port mappings on Windows, so you cannot access a container's mapped port from the host itself.  This parameter maps to ``PortBindings`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--publish`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/). If the network mode of a task definition is set to ``none``, then you can't specify port mappings. If the network mode of a task definition is set to ``host``, then host ports must either be undefined or they must match the container port in the port mapping.  After a task reaches the ``RUNNING`` status, manual and automatic host and container port assignments are visible in the *Network Bindings* section of a container description for a selected task in the Amazon ECS console. The assignments are also visible in the ``networkBindings`` section [DescribeTasks](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeTasks.html) responses.
        """
        return pulumi.get(self, "port_mappings")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        """
        When this parameter is true, the container is given elevated privileges on the host container instance (similar to the ``root`` user). This parameter maps to ``Privileged`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--privileged`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers or tasks run on FARGATElong.
        """
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="pseudoTerminal")
    def pseudo_terminal(self) -> Optional[bool]:
        """
        When this parameter is ``true``, a TTY is allocated. This parameter maps to ``Tty`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--tty`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        """
        return pulumi.get(self, "pseudo_terminal")

    @property
    @pulumi.getter(name="readonlyRootFilesystem")
    def readonly_root_filesystem(self) -> Optional[bool]:
        """
        When this parameter is true, the container is given read-only access to its root file system. This parameter maps to ``ReadonlyRootfs`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--read-only`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  This parameter is not supported for Windows containers.
        """
        return pulumi.get(self, "readonly_root_filesystem")

    @property
    @pulumi.getter(name="repositoryCredentials")
    def repository_credentials(self) -> Optional['outputs.RepositoryCredentialsResponse']:
        """
        The private repository authentication credentials to use. The repository credentials for private registry authentication.
        """
        return pulumi.get(self, "repository_credentials")

    @property
    @pulumi.getter(name="resourceRequirements")
    def resource_requirements(self) -> Optional[Sequence['outputs.ResourceRequirementResponse']]:
        """
        The type and amount of a resource to assign to a container. The only supported resource is a GPU.
        """
        return pulumi.get(self, "resource_requirements")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.SecretResponse']]:
        """
        The secrets to pass to the container. For more information, see [Specifying Sensitive Data](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/specifying-sensitive-data.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="startTimeout")
    def start_timeout(self) -> Optional[int]:
        """
        Time duration (in seconds) to wait before giving up on resolving dependencies for a container. For example, you specify two containers in a task definition with containerA having a dependency on containerB reaching a ``COMPLETE``, ``SUCCESS``, or ``HEALTHY`` status. If a ``startTimeout`` value is specified for containerB and it doesn't reach the desired status within that time then containerA gives up and not start. This results in the task transitioning to a ``STOPPED`` state.  When the ``ECS_CONTAINER_START_TIMEOUT`` container agent configuration variable is used, it's enforced independently from this start timeout value.  For tasks using the Fargate launch type, the task or service requires the following platforms:  +  Linux platform version ``1.3.0`` or later.  +  Windows platform version ``1.0.0`` or later.   For tasks using the EC2 launch type, your container instances require at least version ``1.26.0`` of the container agent to use a container start timeout value. However, we recommend using the latest container agent version. For information about checking your agent version and updating to the latest version, see [Updating the Amazon ECS Container Agent](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html) in the *Amazon Elastic Container Service Developer Guide*. If you're using an Amazon ECS-optimized Linux AMI, your instance needs at least version ``1.26.0-1`` of the ``ecs-init`` package. If your container instances are launched from version ``20190301`` or later, then they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html) in the *Amazon Elastic Container Service Developer Guide*. The valid values are 2-120 seconds.
        """
        return pulumi.get(self, "start_timeout")

    @property
    @pulumi.getter(name="stopTimeout")
    def stop_timeout(self) -> Optional[int]:
        """
        Time duration (in seconds) to wait before the container is forcefully killed if it doesn't exit normally on its own. For tasks using the Fargate launch type, the task or service requires the following platforms:  +  Linux platform version ``1.3.0`` or later.  +  Windows platform version ``1.0.0`` or later.   The max stop timeout value is 120 seconds and if the parameter is not specified, the default value of 30 seconds is used. For tasks that use the EC2 launch type, if the ``stopTimeout`` parameter isn't specified, the value set for the Amazon ECS container agent configuration variable ``ECS_CONTAINER_STOP_TIMEOUT`` is used. If neither the ``stopTimeout`` parameter or the ``ECS_CONTAINER_STOP_TIMEOUT`` agent configuration variable are set, then the default values of 30 seconds for Linux containers and 30 seconds on Windows containers are used. Your container instances require at least version 1.26.0 of the container agent to use a container stop timeout value. However, we recommend using the latest container agent version. For information about checking your agent version and updating to the latest version, see [Updating the Amazon ECS Container Agent](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-update.html) in the *Amazon Elastic Container Service Developer Guide*. If you're using an Amazon ECS-optimized Linux AMI, your instance needs at least version 1.26.0-1 of the ``ecs-init`` package. If your container instances are launched from version ``20190301`` or later, then they contain the required versions of the container agent and ``ecs-init``. For more information, see [Amazon ECS-optimized Linux AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html) in the *Amazon Elastic Container Service Developer Guide*. The valid values are 2-120 seconds.
        """
        return pulumi.get(self, "stop_timeout")

    @property
    @pulumi.getter(name="systemControls")
    def system_controls(self) -> Optional[Sequence['outputs.SystemControlResponse']]:
        """
        A list of namespaced kernel parameters to set in the container. This parameter maps to ``Sysctls`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--sysctl`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). For example, you can configure ``net.ipv4.tcp_keepalive_time`` setting to maintain longer lived connections.
        """
        return pulumi.get(self, "system_controls")

    @property
    @pulumi.getter
    def ulimits(self) -> Optional[Sequence['outputs.UlimitResponse']]:
        """
        A list of ``ulimits`` to set in the container. This parameter maps to ``Ulimits`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--ulimit`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/). Valid naming values are displayed in the [Ulimit](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_Ulimit.html) data type. This parameter requires version 1.18 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``   This parameter is not supported for Windows containers.
        """
        return pulumi.get(self, "ulimits")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        The user to use inside the container. This parameter maps to ``User`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--user`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  When running tasks using the ``host`` network mode, don't run containers using the root user (UID 0). We recommend using a non-root user for better security.  You can specify the ``user`` using the following formats. If specifying a UID or GID, you must specify it as a positive integer.  +   ``user``   +   ``user:group``   +   ``uid``   +   ``uid:gid``   +   ``user:gid``   +   ``uid:group``     This parameter is not supported for Windows containers.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="volumesFrom")
    def volumes_from(self) -> Optional[Sequence['outputs.VolumeFromResponse']]:
        """
        Data volumes to mount from another container. This parameter maps to ``VolumesFrom`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--volumes-from`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        """
        return pulumi.get(self, "volumes_from")

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[str]:
        """
        The working directory to run commands inside the container in. This parameter maps to ``WorkingDir`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--workdir`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).
        """
        return pulumi.get(self, "working_directory")


@pulumi.output_type
class ContainerDependencyResponse(dict):
    """
    Definition of ContainerDependency
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerDependencyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerDependencyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerDependencyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 container_name: Optional[str] = None):
        """
        Definition of ContainerDependency
        :param str condition: The dependency condition of the container. The following are the available conditions and their behavior:  +   ``START`` - This condition emulates the behavior of links and volumes today. It validates that a dependent container is started before permitting other containers to start.  +   ``COMPLETE`` - This condition validates that a dependent container runs to completion (exits) before permitting other containers to start. This can be useful for nonessential containers that run a script and then exit. This condition can't be set on an essential container.  +   ``SUCCESS`` - This condition is the same as ``COMPLETE``, but it also requires that the container exits with a ``zero`` status. This condition can't be set on an essential container.  +   ``HEALTHY`` - This condition validates that the dependent container passes its Docker health check before permitting other containers to start. This requires that the dependent container has health checks configured. This condition is confirmed only at task startup.
        :param str container_name: The name of a container.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        The dependency condition of the container. The following are the available conditions and their behavior:  +   ``START`` - This condition emulates the behavior of links and volumes today. It validates that a dependent container is started before permitting other containers to start.  +   ``COMPLETE`` - This condition validates that a dependent container runs to completion (exits) before permitting other containers to start. This can be useful for nonessential containers that run a script and then exit. This condition can't be set on an essential container.  +   ``SUCCESS`` - This condition is the same as ``COMPLETE``, but it also requires that the container exits with a ``zero`` status. This condition can't be set on an essential container.  +   ``HEALTHY`` - This condition validates that the dependent container passes its Docker health check before permitting other containers to start. This requires that the dependent container has health checks configured. This condition is confirmed only at task startup.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        The name of a container.
        """
        return pulumi.get(self, "container_name")


@pulumi.output_type
class ContinuousBackupsStatusEnumValueResponse(dict):
    """
    Definition of ContinuousBackupsStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ContinuousBackupsStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ContributorInsightsSpecificationResponse(dict):
    """
    Definition of ContributorInsightsSpecification
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Definition of ContributorInsightsSpecification
        :param bool enabled: Indicates whether CloudWatch Contributor Insights are to be enabled (true) or disabled (false).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether CloudWatch Contributor Insights are to be enabled (true) or disabled (false).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ControlPlanePlacementResponseResponse(dict):
    """
    Definition of ControlPlanePlacementResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlPlanePlacementResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlPlanePlacementResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlPlanePlacementResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[str] = None):
        """
        Definition of ControlPlanePlacementResponse
        :param str group_name: <p>The name of the placement group for the Kubernetes control plane instances.</p>
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        <p>The name of the placement group for the Kubernetes control plane instances.</p>
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class CookiesResponse(dict):
    """
    Definition of Cookies
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whitelistedNames":
            suggest = "whitelisted_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CookiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CookiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CookiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward: Optional[str] = None,
                 whitelisted_names: Optional[Sequence[str]] = None):
        """
        Definition of Cookies
        :param str forward: This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send cookies to the origin but not include them in the cache key, use origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. Specifies which cookies to forward to the origin for this cache behavior: all, none, or the list of cookies specified in the ``WhitelistedNames`` complex type. Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an Amazon S3 origin, specify none for the ``Forward`` element.
        :param Sequence[str] whitelisted_names: This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*.
        """
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if whitelisted_names is not None:
            pulumi.set(__self__, "whitelisted_names", whitelisted_names)

    @property
    @pulumi.getter
    def forward(self) -> Optional[str]:
        """
        This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send cookies to the origin but not include them in the cache key, use origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. Specifies which cookies to forward to the origin for this cache behavior: all, none, or the list of cookies specified in the ``WhitelistedNames`` complex type. Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an Amazon S3 origin, specify none for the ``Forward`` element.
        """
        return pulumi.get(self, "forward")

    @property
    @pulumi.getter(name="whitelistedNames")
    def whitelisted_names(self) -> Optional[Sequence[str]]:
        """
        This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "whitelisted_names")


@pulumi.output_type
class CoordinatesResponse(dict):
    """
    Definition of Coordinates
    """
    def __init__(__self__, *,
                 latitude: Optional[str] = None,
                 longitude: Optional[str] = None):
        """
        Definition of Coordinates
        :param str latitude: <p> Specifies a coordinate of the northsouth position of a geographic point on the surface of the Earth (-90 - 90). </p>
        :param str longitude: <p> Specifies a coordinate of the eastwest position of a geographic point on the surface of the Earth (-180 - 180). </p>
        """
        if latitude is not None:
            pulumi.set(__self__, "latitude", latitude)
        if longitude is not None:
            pulumi.set(__self__, "longitude", longitude)

    @property
    @pulumi.getter
    def latitude(self) -> Optional[str]:
        """
        <p> Specifies a coordinate of the northsouth position of a geographic point on the surface of the Earth (-90 - 90). </p>
        """
        return pulumi.get(self, "latitude")

    @property
    @pulumi.getter
    def longitude(self) -> Optional[str]:
        """
        <p> Specifies a coordinate of the eastwest position of a geographic point on the surface of the Earth (-180 - 180). </p>
        """
        return pulumi.get(self, "longitude")


@pulumi.output_type
class CorsConfigurationResponse(dict):
    """
    Definition of CorsConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsRules":
            suggest = "cors_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CorsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CorsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CorsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_rules: Optional[Sequence['outputs.CorsRuleResponse']] = None):
        """
        Definition of CorsConfiguration
        :param Sequence['CorsRuleResponse'] cors_rules: A set of origins and methods (cross-origin access that you want to allow). You can add up to 100 rules to the configuration.
        """
        if cors_rules is not None:
            pulumi.set(__self__, "cors_rules", cors_rules)

    @property
    @pulumi.getter(name="corsRules")
    def cors_rules(self) -> Optional[Sequence['outputs.CorsRuleResponse']]:
        """
        A set of origins and methods (cross-origin access that you want to allow). You can add up to 100 rules to the configuration.
        """
        return pulumi.get(self, "cors_rules")


@pulumi.output_type
class CorsRuleResponse(dict):
    """
    Definition of CorsRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "exposedHeaders":
            suggest = "exposed_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CorsRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CorsRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CorsRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_headers: Optional[Sequence[str]] = None,
                 allowed_methods: Optional[Sequence[str]] = None,
                 allowed_origins: Optional[Sequence[str]] = None,
                 exposed_headers: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 max_age: Optional[int] = None):
        """
        Definition of CorsRule
        :param Sequence[str] allowed_headers: Headers that are specified in the ``Access-Control-Request-Headers`` header. These headers are allowed in a preflight OPTIONS request. In response to any preflight OPTIONS request, Amazon S3 returns any requested headers that are allowed.
        :param Sequence[str] allowed_methods: An HTTP method that you allow the origin to run.  *Allowed values*: ``GET`` | ``PUT`` | ``HEAD`` | ``POST`` | ``DELETE``
        :param Sequence[str] allowed_origins: One or more origins you want customers to be able to access the bucket from.
        :param Sequence[str] exposed_headers: One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript ``XMLHttpRequest`` object).
        :param str id: A unique identifier for this rule. The value must be no more than 255 characters.
        :param int max_age: The time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[str]]:
        """
        Headers that are specified in the ``Access-Control-Request-Headers`` header. These headers are allowed in a preflight OPTIONS request. In response to any preflight OPTIONS request, Amazon S3 returns any requested headers that are allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[str]]:
        """
        An HTTP method that you allow the origin to run.  *Allowed values*: ``GET`` | ``PUT`` | ``HEAD`` | ``POST`` | ``DELETE``
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        One or more origins you want customers to be able to access the bucket from.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[Sequence[str]]:
        """
        One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript ``XMLHttpRequest`` object).
        """
        return pulumi.get(self, "exposed_headers")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A unique identifier for this rule. The value must be no more than 255 characters.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        The time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class CpuOptionsResponse(dict):
    """
    Definition of CpuOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpuOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpuOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpuOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional['outputs.AmdSevSnpSpecificationEnumValueResponse'] = None,
                 core_count: Optional[int] = None,
                 threads_per_core: Optional[int] = None):
        """
        Definition of CpuOptions
        :param 'AmdSevSnpSpecificationEnumValueResponse' amd_sev_snp: <p>Indicates whether the instance is enabled for AMD SEV-SNP. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html'>AMD SEV-SNP</a>.</p>
        :param int core_count: <p>The number of CPU cores for the instance.</p>
        :param int threads_per_core: <p>The number of threads per CPU core.</p>
        """
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional['outputs.AmdSevSnpSpecificationEnumValueResponse']:
        """
        <p>Indicates whether the instance is enabled for AMD SEV-SNP. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html'>AMD SEV-SNP</a>.</p>
        """
        return pulumi.get(self, "amd_sev_snp")

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        """
        <p>The number of CPU cores for the instance.</p>
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[int]:
        """
        <p>The number of threads per CPU core.</p>
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class CredentialProviderTypeEnumValueResponse(dict):
    """
    Definition of CredentialProviderTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of CredentialProviderTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CriteriaBlockForJobResponse(dict):
    """
    Definition of CriteriaBlockForJob
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "and":
            suggest = "and_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CriteriaBlockForJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CriteriaBlockForJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CriteriaBlockForJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_: Optional[Sequence['outputs.CriteriaForJobResponse']] = None):
        """
        Definition of CriteriaBlockForJob
        :param Sequence['CriteriaForJobResponse'] and_: <p>An array of conditions, one for each condition that determines which buckets to include or exclude from the job. If you specify more than one condition, Amazon Macie uses AND logic to join the conditions.</p>
        """
        if and_ is not None:
            pulumi.set(__self__, "and_", and_)

    @property
    @pulumi.getter(name="and")
    def and_(self) -> Optional[Sequence['outputs.CriteriaForJobResponse']]:
        """
        <p>An array of conditions, one for each condition that determines which buckets to include or exclude from the job. If you specify more than one condition, Amazon Macie uses AND logic to join the conditions.</p>
        """
        return pulumi.get(self, "and_")


@pulumi.output_type
class CriteriaForJobResponse(dict):
    """
    Definition of CriteriaForJob
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleCriterion":
            suggest = "simple_criterion"
        elif key == "tagCriterion":
            suggest = "tag_criterion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CriteriaForJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CriteriaForJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CriteriaForJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_criterion: Optional['outputs.SimpleCriterionForJobResponse'] = None,
                 tag_criterion: Optional['outputs.TagCriterionForJobResponse'] = None):
        """
        Definition of CriteriaForJob
        :param 'SimpleCriterionForJobResponse' simple_criterion: <p>A property-based condition that defines a property, operator, and one or more values for including or excluding buckets from the job.</p>
        :param 'TagCriterionForJobResponse' tag_criterion: <p>A tag-based condition that defines an operator and tag keys, tag values, or tag key and value pairs for including or excluding buckets from the job.</p>
        """
        if simple_criterion is not None:
            pulumi.set(__self__, "simple_criterion", simple_criterion)
        if tag_criterion is not None:
            pulumi.set(__self__, "tag_criterion", tag_criterion)

    @property
    @pulumi.getter(name="simpleCriterion")
    def simple_criterion(self) -> Optional['outputs.SimpleCriterionForJobResponse']:
        """
        <p>A property-based condition that defines a property, operator, and one or more values for including or excluding buckets from the job.</p>
        """
        return pulumi.get(self, "simple_criterion")

    @property
    @pulumi.getter(name="tagCriterion")
    def tag_criterion(self) -> Optional['outputs.TagCriterionForJobResponse']:
        """
        <p>A tag-based condition that defines an operator and tag keys, tag values, or tag key and value pairs for including or excluding buckets from the job.</p>
        """
        return pulumi.get(self, "tag_criterion")


@pulumi.output_type
class CriteriaResponse(dict):
    """
    Definition of Criteria
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3WordsList":
            suggest = "s3_words_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CriteriaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CriteriaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CriteriaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regex: Optional[str] = None,
                 s3_words_list: Optional['outputs.S3WordsListResponse'] = None):
        """
        Definition of Criteria
        :param str regex: The S3 object key for the AllowList.
        :param 'S3WordsListResponse' s3_words_list: The S3 location for the AllowList.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if s3_words_list is not None:
            pulumi.set(__self__, "s3_words_list", s3_words_list)

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The S3 object key for the AllowList.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter(name="s3WordsList")
    def s3_words_list(self) -> Optional['outputs.S3WordsListResponse']:
        """
        The S3 location for the AllowList.
        """
        return pulumi.get(self, "s3_words_list")


@pulumi.output_type
class CsvResponse(dict):
    """
    Definition of Csv
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerList":
            suggest = "header_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CsvResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CsvResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CsvResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[str] = None,
                 header_list: Optional[Sequence[str]] = None):
        """
        Definition of Csv
        :param str delimiter: The delimiter used for separating items in the CSV file being imported.
        :param Sequence[str] header_list: List of the headers used to specify a common header for all source CSV files being imported. If this field is specified then the first line of each CSV file is treated as data instead of the header. If this field is not specified the the first line of each CSV file is treated as the header.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if header_list is not None:
            pulumi.set(__self__, "header_list", header_list)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The delimiter used for separating items in the CSV file being imported.
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="headerList")
    def header_list(self) -> Optional[Sequence[str]]:
        """
        List of the headers used to specify a common header for all source CSV files being imported. If this field is specified then the first line of each CSV file is treated as data instead of the header. If this field is not specified the the first line of each CSV file is treated as the header.
        """
        return pulumi.get(self, "header_list")


@pulumi.output_type
class CustomActionResponse(dict):
    """
    Definition of CustomAction
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionDefinition":
            suggest = "action_definition"
        elif key == "actionName":
            suggest = "action_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_definition: Optional['outputs.ActionDefinitionResponse'] = None,
                 action_name: Optional[str] = None):
        """
        Definition of CustomAction
        :param 'ActionDefinitionResponse' action_definition: Property actionDefinition
        :param str action_name: Property actionName
        """
        if action_definition is not None:
            pulumi.set(__self__, "action_definition", action_definition)
        if action_name is not None:
            pulumi.set(__self__, "action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> Optional['outputs.ActionDefinitionResponse']:
        """
        Property actionDefinition
        """
        return pulumi.get(self, "action_definition")

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> Optional[str]:
        """
        Property actionName
        """
        return pulumi.get(self, "action_name")


@pulumi.output_type
class CustomErrorResponseResponse(dict):
    """
    Definition of CustomErrorResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCachingMinTTL":
            suggest = "error_caching_min_ttl"
        elif key == "errorCode":
            suggest = "error_code"
        elif key == "responseCode":
            suggest = "response_code"
        elif key == "responsePagePath":
            suggest = "response_page_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomErrorResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomErrorResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomErrorResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_caching_min_ttl: Optional[int] = None,
                 error_code: Optional[int] = None,
                 response_code: Optional[int] = None,
                 response_page_path: Optional[str] = None):
        """
        Definition of CustomErrorResponse
        :param int error_caching_min_ttl: The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status code specified in ``ErrorCode``. When this time period has elapsed, CloudFront queries your origin to see whether the problem that caused the error has been resolved and the requested object is now available. For more information, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the *Amazon CloudFront Developer Guide*.
        :param int error_code: The HTTP status code for which you want to specify a custom error page and/or a caching duration.
        :param int response_code: The HTTP status code that you want CloudFront to return to the viewer along with the custom error page. There are a variety of reasons that you might want CloudFront to return a status code different from the status code that your origin returned to CloudFront, for example:  +  Some Internet devices (some firewalls and corporate proxies, for example) intercept HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you substitute ``200``, the response typically won't be intercepted.  +  If you don't care about distinguishing among different client errors or server errors, you can specify ``400`` or ``500`` as the ``ResponseCode`` for all 4xx or 5xx errors.  +  You might want to return a ``200`` status code (OK) and static website so your customers don't know that your website is down.   If you specify a value for ``ResponseCode``, you must also specify a value for ``ResponsePagePath``.
        :param str response_page_path: The path to the custom error page that you want CloudFront to return to a viewer when your origin returns the HTTP status code specified by ``ErrorCode``, for example, ``/4xx-errors/403-forbidden.html``. If you want to store your objects and your custom error pages in different locations, your distribution must include a cache behavior for which the following is true:  +  The value of ``PathPattern`` matches the path to your custom error messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3 bucket in a directory named ``/4xx-errors``. Your distribution must include a cache behavior for which the path pattern routes requests for your custom error pages to that location, for example, ``/4xx-errors/*``.  +  The value of ``TargetOriginId`` specifies the value of the ``ID`` element for the origin that contains your custom error pages.   If you specify a value for ``ResponsePagePath``, you must also specify a value for ``ResponseCode``. We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the files that you want to return to viewers because the origin server is unavailable.
        """
        if error_caching_min_ttl is None:
            error_caching_min_ttl = 300
        if error_caching_min_ttl is not None:
            pulumi.set(__self__, "error_caching_min_ttl", error_caching_min_ttl)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if response_page_path is not None:
            pulumi.set(__self__, "response_page_path", response_page_path)

    @property
    @pulumi.getter(name="errorCachingMinTTL")
    def error_caching_min_ttl(self) -> Optional[int]:
        """
        The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status code specified in ``ErrorCode``. When this time period has elapsed, CloudFront queries your origin to see whether the problem that caused the error has been resolved and the requested object is now available. For more information, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "error_caching_min_ttl")

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[int]:
        """
        The HTTP status code for which you want to specify a custom error page and/or a caching duration.
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[int]:
        """
        The HTTP status code that you want CloudFront to return to the viewer along with the custom error page. There are a variety of reasons that you might want CloudFront to return a status code different from the status code that your origin returned to CloudFront, for example:  +  Some Internet devices (some firewalls and corporate proxies, for example) intercept HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you substitute ``200``, the response typically won't be intercepted.  +  If you don't care about distinguishing among different client errors or server errors, you can specify ``400`` or ``500`` as the ``ResponseCode`` for all 4xx or 5xx errors.  +  You might want to return a ``200`` status code (OK) and static website so your customers don't know that your website is down.   If you specify a value for ``ResponseCode``, you must also specify a value for ``ResponsePagePath``.
        """
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="responsePagePath")
    def response_page_path(self) -> Optional[str]:
        """
        The path to the custom error page that you want CloudFront to return to a viewer when your origin returns the HTTP status code specified by ``ErrorCode``, for example, ``/4xx-errors/403-forbidden.html``. If you want to store your objects and your custom error pages in different locations, your distribution must include a cache behavior for which the following is true:  +  The value of ``PathPattern`` matches the path to your custom error messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3 bucket in a directory named ``/4xx-errors``. Your distribution must include a cache behavior for which the path pattern routes requests for your custom error pages to that location, for example, ``/4xx-errors/*``.  +  The value of ``TargetOriginId`` specifies the value of the ``ID`` element for the origin that contains your custom error pages.   If you specify a value for ``ResponsePagePath``, you must also specify a value for ``ResponseCode``. We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the files that you want to return to viewers because the origin server is unavailable.
        """
        return pulumi.get(self, "response_page_path")


@pulumi.output_type
class CustomOriginConfigResponse(dict):
    """
    Definition of CustomOriginConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "originKeepaliveTimeout":
            suggest = "origin_keepalive_timeout"
        elif key == "originProtocolPolicy":
            suggest = "origin_protocol_policy"
        elif key == "originReadTimeout":
            suggest = "origin_read_timeout"
        elif key == "originSSLProtocols":
            suggest = "origin_ssl_protocols"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomOriginConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomOriginConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomOriginConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None,
                 origin_keepalive_timeout: Optional[int] = None,
                 origin_protocol_policy: Optional[str] = None,
                 origin_read_timeout: Optional[int] = None,
                 origin_ssl_protocols: Optional[Sequence[str]] = None):
        """
        Definition of CustomOriginConfig
        :param int http_port: The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin listens on.
        :param int https_port: The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the origin listens on.
        :param int origin_keepalive_timeout: Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 5 seconds. For more information, see [Origin Keep-alive Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout) in the *Amazon CloudFront Developer Guide*.
        :param str origin_protocol_policy: Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values are:  +   ``http-only``  CloudFront always uses HTTP to connect to the origin.  +   ``match-viewer``  CloudFront connects to the origin using the same protocol that the viewer used to connect to CloudFront.  +   ``https-only``  CloudFront always uses HTTPS to connect to the origin.
        :param int origin_read_timeout: Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also known as the *origin response timeout*. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 30 seconds. For more information, see [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout) in the *Amazon CloudFront Developer Guide*.
        :param Sequence[str] origin_ssl_protocols: Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. Valid values include ``SSLv3``, ``TLSv1``, ``TLSv1.1``, and ``TLSv1.2``. For more information, see [Minimum Origin SSL Protocol](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols) in the *Amazon CloudFront Developer Guide*.
        """
        if http_port is None:
            http_port = 80
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is None:
            https_port = 443
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if origin_keepalive_timeout is None:
            origin_keepalive_timeout = 5
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_protocol_policy is not None:
            pulumi.set(__self__, "origin_protocol_policy", origin_protocol_policy)
        if origin_read_timeout is None:
            origin_read_timeout = 30
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)
        if origin_ssl_protocols is not None:
            pulumi.set(__self__, "origin_ssl_protocols", origin_ssl_protocols)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin listens on.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the origin listens on.
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[int]:
        """
        Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 5 seconds. For more information, see [Origin Keep-alive Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_keepalive_timeout")

    @property
    @pulumi.getter(name="originProtocolPolicy")
    def origin_protocol_policy(self) -> Optional[str]:
        """
        Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values are:  +   ``http-only``  CloudFront always uses HTTP to connect to the origin.  +   ``match-viewer``  CloudFront connects to the origin using the same protocol that the viewer used to connect to CloudFront.  +   ``https-only``  CloudFront always uses HTTPS to connect to the origin.
        """
        return pulumi.get(self, "origin_protocol_policy")

    @property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[int]:
        """
        Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also known as the *origin response timeout*. The minimum timeout is 1 second, the maximum is 60 seconds, and the default (if you don't specify otherwise) is 30 seconds. For more information, see [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_read_timeout")

    @property
    @pulumi.getter(name="originSSLProtocols")
    def origin_ssl_protocols(self) -> Optional[Sequence[str]]:
        """
        Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS. Valid values include ``SSLv3``, ``TLSv1``, ``TLSv1.1``, and ``TLSv1.2``. For more information, see [Minimum Origin SSL Protocol](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_ssl_protocols")


@pulumi.output_type
class DBClusterRoleResponse(dict):
    """
    Definition of DBClusterRole
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureName":
            suggest = "feature_name"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DBClusterRoleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DBClusterRoleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DBClusterRoleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_name: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        Definition of DBClusterRole
        :param str feature_name: The name of the feature associated with the AWS Identity and Access Management (IAM) role. For the list of supported feature names, see DBEngineVersion in the Amazon RDS API Reference.
        :param str role_arn: The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
        """
        if feature_name is not None:
            pulumi.set(__self__, "feature_name", feature_name)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="featureName")
    def feature_name(self) -> Optional[str]:
        """
        The name of the feature associated with the AWS Identity and Access Management (IAM) role. For the list of supported feature names, see DBEngineVersion in the Amazon RDS API Reference.
        """
        return pulumi.get(self, "feature_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class DBInstanceRoleResponse(dict):
    """
    Definition of DBInstanceRole
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureName":
            suggest = "feature_name"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DBInstanceRoleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DBInstanceRoleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DBInstanceRoleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_name: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        Definition of DBInstanceRole
        :param str feature_name: The name of the feature associated with the AWS Identity and Access Management (IAM) role. IAM roles that are associated with a DB instance grant permission for the DB instance to access other AWS services on your behalf. For the list of supported feature names, see the ``SupportedFeatureNames`` description in [DBEngineVersion](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DBEngineVersion.html) in the *Amazon RDS API Reference*.
        :param str role_arn: The Amazon Resource Name (ARN) of the IAM role that is associated with the DB instance.
        """
        if feature_name is not None:
            pulumi.set(__self__, "feature_name", feature_name)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="featureName")
    def feature_name(self) -> Optional[str]:
        """
        The name of the feature associated with the AWS Identity and Access Management (IAM) role. IAM roles that are associated with a DB instance grant permission for the DB instance to access other AWS services on your behalf. For the list of supported feature names, see the ``SupportedFeatureNames`` description in [DBEngineVersion](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DBEngineVersion.html) in the *Amazon RDS API Reference*.
        """
        return pulumi.get(self, "feature_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the IAM role that is associated with the DB instance.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class DBSnapshotAttributeResponse(dict):
    """
    Definition of DBSnapshotAttribute
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValues":
            suggest = "attribute_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DBSnapshotAttributeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DBSnapshotAttributeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DBSnapshotAttributeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_values: Optional[Sequence[str]] = None):
        """
        Definition of DBSnapshotAttribute
        :param str attribute_name: <p>The name of the manual DB snapshot attribute.</p> <p>The attribute named <code>restore</code> refers to the list of Amazon Web Services accounts that have permission to copy or restore the manual DB cluster snapshot. For more information, see the <code>ModifyDBSnapshotAttribute</code> API action.</p>
        :param Sequence[str] attribute_values: <p>The value or values for the manual DB snapshot attribute.</p> <p>If the <code>AttributeName</code> field is set to <code>restore</code>, then this element returns a list of IDs of the Amazon Web Services accounts that are authorized to copy or restore the manual DB snapshot. If a value of <code>all</code> is in the list, then the manual DB snapshot is public and available for any Amazon Web Services account to copy or restore.</p>
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_values is not None:
            pulumi.set(__self__, "attribute_values", attribute_values)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        """
        <p>The name of the manual DB snapshot attribute.</p> <p>The attribute named <code>restore</code> refers to the list of Amazon Web Services accounts that have permission to copy or restore the manual DB cluster snapshot. For more information, see the <code>ModifyDBSnapshotAttribute</code> API action.</p>
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValues")
    def attribute_values(self) -> Optional[Sequence[str]]:
        """
        <p>The value or values for the manual DB snapshot attribute.</p> <p>If the <code>AttributeName</code> field is set to <code>restore</code>, then this element returns a list of IDs of the Amazon Web Services accounts that are authorized to copy or restore the manual DB snapshot. If a value of <code>all</code> is in the list, then the manual DB snapshot is public and available for any Amazon Web Services account to copy or restore.</p>
        """
        return pulumi.get(self, "attribute_values")


@pulumi.output_type
class DataExportResponse(dict):
    """
    Definition of DataExport
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputSchemaVersion":
            suggest = "output_schema_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataExportResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataExportResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataExportResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional['outputs.DestinationResponse'] = None,
                 output_schema_version: Optional[str] = None):
        """
        Definition of DataExport
        :param 'DestinationResponse' destination: The place to store the data for an analysis. Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket.
        :param str output_schema_version: The version of the output schema to use when exporting data. Must be ``V_1``.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if output_schema_version is not None:
            pulumi.set(__self__, "output_schema_version", output_schema_version)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.DestinationResponse']:
        """
        The place to store the data for an analysis. Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="outputSchemaVersion")
    def output_schema_version(self) -> Optional[str]:
        """
        The version of the output schema to use when exporting data. Must be ``V_1``.
        """
        return pulumi.get(self, "output_schema_version")


@pulumi.output_type
class DataResourceResponse(dict):
    """
    Definition of DataResource
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        Definition of DataResource
        :param str type: The resource type in which you want to log data events. You can specify AWS::S3::Object or AWS::Lambda::Function resources.
        :param Sequence[str] values: An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified objects.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The resource type in which you want to log data events. You can specify AWS::S3::Object or AWS::Lambda::Function resources.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified objects.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DataSourceLevelMetricsBehaviorEnumValueResponse(dict):
    """
    Definition of DataSourceLevelMetricsBehaviorEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of DataSourceLevelMetricsBehaviorEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DatabaseMigrationServiceReplicationInstancePropertiesResponse(dict):
    """
    Definition of DatabaseMigrationServiceReplicationInstance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseMigrationServiceReplicationInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseMigrationServiceReplicationInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseMigrationServiceReplicationInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsDatabaseMigrationServiceReplicationInstancePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of DatabaseMigrationServiceReplicationInstance
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsDatabaseMigrationServiceReplicationInstancePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsDatabaseMigrationServiceReplicationInstancePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class DaxClusterEndpointResponse(dict):
    """
    Definition of Endpoint
    """
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 port: Optional[int] = None,
                 url: Optional[str] = None):
        """
        Definition of Endpoint
        :param str address: <p>The DNS hostname of the endpoint.</p>
        :param int port: <p>The port number that applications should use to connect to the endpoint.</p>
        :param str url: <p>The URL that applications should use to connect to the endpoint. The default ports are 8111 for the 'dax' protocol and 9111 for the 'daxs' protocol.</p>
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        <p>The DNS hostname of the endpoint.</p>
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        <p>The port number that applications should use to connect to the endpoint.</p>
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        <p>The URL that applications should use to connect to the endpoint. The default ports are 8111 for the 'dax' protocol and 9111 for the 'daxs' protocol.</p>
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class DaxClusterPropertiesResponse(dict):
    """
    Definition of DaxCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaxClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaxClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaxClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsDaxClusterPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of DaxCluster
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsDaxClusterPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsDaxClusterPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class DeadLetterConfigResponse(dict):
    """
    Definition of DeadLetterConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetArn":
            suggest = "target_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeadLetterConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeadLetterConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeadLetterConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_arn: Optional[str] = None):
        """
        Definition of DeadLetterConfig
        :param str target_arn: The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        """
        if target_arn is not None:
            pulumi.set(__self__, "target_arn", target_arn)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
        """
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class DefaultActionEnumValueResponse(dict):
    """
    Definition of DefaultActionEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of DefaultActionEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DefaultCacheBehaviorResponse(dict):
    """
    Definition of DefaultCacheBehavior
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "cachePolicyId":
            suggest = "cache_policy_id"
        elif key == "cachedMethods":
            suggest = "cached_methods"
        elif key == "defaultTTL":
            suggest = "default_ttl"
        elif key == "fieldLevelEncryptionId":
            suggest = "field_level_encryption_id"
        elif key == "forwardedValues":
            suggest = "forwarded_values"
        elif key == "functionAssociations":
            suggest = "function_associations"
        elif key == "lambdaFunctionAssociations":
            suggest = "lambda_function_associations"
        elif key == "maxTTL":
            suggest = "max_ttl"
        elif key == "minTTL":
            suggest = "min_ttl"
        elif key == "originRequestPolicyId":
            suggest = "origin_request_policy_id"
        elif key == "realtimeLogConfigArn":
            suggest = "realtime_log_config_arn"
        elif key == "responseHeadersPolicyId":
            suggest = "response_headers_policy_id"
        elif key == "smoothStreaming":
            suggest = "smooth_streaming"
        elif key == "targetOriginId":
            suggest = "target_origin_id"
        elif key == "trustedKeyGroups":
            suggest = "trusted_key_groups"
        elif key == "trustedSigners":
            suggest = "trusted_signers"
        elif key == "viewerProtocolPolicy":
            suggest = "viewer_protocol_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultCacheBehaviorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultCacheBehaviorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultCacheBehaviorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Optional[Sequence[str]] = None,
                 cache_policy_id: Optional[str] = None,
                 cached_methods: Optional[Sequence[str]] = None,
                 compress: Optional[bool] = None,
                 default_ttl: Optional[int] = None,
                 field_level_encryption_id: Optional[str] = None,
                 forwarded_values: Optional['outputs.ForwardedValuesResponse'] = None,
                 function_associations: Optional[Sequence['outputs.FunctionAssociationResponse']] = None,
                 lambda_function_associations: Optional[Sequence['outputs.LambdaFunctionAssociationResponse']] = None,
                 max_ttl: Optional[int] = None,
                 min_ttl: Optional[int] = None,
                 origin_request_policy_id: Optional[str] = None,
                 realtime_log_config_arn: Optional[str] = None,
                 response_headers_policy_id: Optional[str] = None,
                 smooth_streaming: Optional[bool] = None,
                 target_origin_id: Optional[str] = None,
                 trusted_key_groups: Optional[Sequence[str]] = None,
                 trusted_signers: Optional[Sequence[str]] = None,
                 viewer_protocol_policy: Optional[str] = None):
        """
        Definition of DefaultCacheBehavior
        :param Sequence[str] allowed_methods: A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:  +  CloudFront forwards only ``GET`` and ``HEAD`` requests.  +  CloudFront forwards only ``GET``, ``HEAD``, and ``OPTIONS`` requests.  +  CloudFront forwards ``GET, HEAD, OPTIONS, PUT, PATCH, POST``, and ``DELETE`` requests.   If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        :param str cache_policy_id: The unique identifier of the cache policy that is attached to the default cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. A ``DefaultCacheBehavior`` must include either a ``CachePolicyId`` or ``ForwardedValues``. We recommend that you use a ``CachePolicyId``.
        :param Sequence[str] cached_methods: A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:  +  CloudFront caches responses to ``GET`` and ``HEAD`` requests.  +  CloudFront caches responses to ``GET``, ``HEAD``, and ``OPTIONS`` requests.   If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
        :param bool compress: Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify ``true``; if not, specify ``false``. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the *Amazon CloudFront Developer Guide*.
        :param int default_ttl: This field is deprecated. We recommend that you use the ``DefaultTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as ``Cache-Control max-age``, ``Cache-Control s-maxage``, and ``Expires`` to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        :param str field_level_encryption_id: The value of ``ID`` for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for the default cache behavior.
        :param 'ForwardedValuesResponse' forwarded_values: This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the *Amazon CloudFront Developer Guide*. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the *Amazon CloudFront Developer Guide*. A ``DefaultCacheBehavior`` must include either a ``CachePolicyId`` or ``ForwardedValues``. We recommend that you use a ``CachePolicyId``. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers. This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        :param Sequence['FunctionAssociationResponse'] function_associations: A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the ``LIVE`` stage to associate them with a cache behavior.
        :param Sequence['LambdaFunctionAssociationResponse'] lambda_function_associations: A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        :param int max_ttl: This field is deprecated. We recommend that you use the ``MaxTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as ``Cache-Control max-age``, ``Cache-Control s-maxage``, and ``Expires`` to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        :param int min_ttl: This field is deprecated. We recommend that you use the ``MinTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*. You must specify ``0`` for ``MinTTL`` if you configure CloudFront to forward all headers to your origin (under ``Headers``, if you specify ``1`` for ``Quantity`` and ``*`` for ``Name``).
        :param str origin_request_policy_id: The unique identifier of the origin request policy that is attached to the default cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the *Amazon CloudFront Developer Guide*.
        :param str realtime_log_config_arn: The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the *Amazon CloudFront Developer Guide*.
        :param str response_headers_policy_id: The identifier for a response headers policy.
        :param bool smooth_streaming: Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify ``true``; if not, specify ``false``. If you specify ``true`` for ``SmoothStreaming``, you can still distribute other content using this cache behavior if the content matches the value of ``PathPattern``.
        :param str target_origin_id: The value of ``ID`` for the origin that you want CloudFront to route requests to when they use the default cache behavior.
        :param Sequence[str] trusted_key_groups: A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        :param Sequence[str] trusted_signers: We recommend using ``TrustedKeyGroups`` instead of ``TrustedSigners``.  A list of AWS-account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in a trusted signer's AWS-account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        :param str viewer_protocol_policy: The protocol that viewers can use to access the files in the origin specified by ``TargetOriginId`` when a request matches the path pattern in ``PathPattern``. You can specify the following options:  +   ``allow-all``: Viewers can use HTTP or HTTPS.  +   ``redirect-to-https``: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.  +   ``https-only``: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).   For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the *Amazon CloudFront Developer Guide*.  The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        """
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if cached_methods is not None:
            pulumi.set(__self__, "cached_methods", cached_methods)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if default_ttl is None:
            default_ttl = 86400
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if forwarded_values is not None:
            pulumi.set(__self__, "forwarded_values", forwarded_values)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if max_ttl is None:
            max_ttl = 31536000
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if min_ttl is not None:
            pulumi.set(__self__, "min_ttl", min_ttl)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if smooth_streaming is not None:
            pulumi.set(__self__, "smooth_streaming", smooth_streaming)
        if target_origin_id is not None:
            pulumi.set(__self__, "target_origin_id", target_origin_id)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)
        if trusted_signers is not None:
            pulumi.set(__self__, "trusted_signers", trusted_signers)
        if viewer_protocol_policy is not None:
            pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[str]]:
        """
        A complex type that controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin. There are three choices:  +  CloudFront forwards only ``GET`` and ``HEAD`` requests.  +  CloudFront forwards only ``GET``, ``HEAD``, and ``OPTIONS`` requests.  +  CloudFront forwards ``GET, HEAD, OPTIONS, PUT, PATCH, POST``, and ``DELETE`` requests.   If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or to your custom origin so users can't perform operations that you don't want them to. For example, you might not want users to have permissions to delete objects from your origin.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[str]:
        """
        The unique identifier of the cache policy that is attached to the default cache behavior. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. A ``DefaultCacheBehavior`` must include either a ``CachePolicyId`` or ``ForwardedValues``. We recommend that you use a ``CachePolicyId``.
        """
        return pulumi.get(self, "cache_policy_id")

    @property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> Optional[Sequence[str]]:
        """
        A complex type that controls whether CloudFront caches the response to requests using the specified HTTP methods. There are two choices:  +  CloudFront caches responses to ``GET`` and ``HEAD`` requests.  +  CloudFront caches responses to ``GET``, ``HEAD``, and ``OPTIONS`` requests.   If you pick the second choice for your Amazon S3 Origin, you may need to forward Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the responses to be cached correctly.
        """
        return pulumi.get(self, "cached_methods")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        Whether you want CloudFront to automatically compress certain files for this cache behavior. If so, specify ``true``; if not, specify ``false``. For more information, see [Serving Compressed Files](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="defaultTTL")
    def default_ttl(self) -> Optional[int]:
        """
        This field is deprecated. We recommend that you use the ``DefaultTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The default amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin does not add HTTP headers such as ``Cache-Control max-age``, ``Cache-Control s-maxage``, and ``Expires`` to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[str]:
        """
        The value of ``ID`` for the field-level encryption configuration that you want CloudFront to use for encrypting specific fields of data for the default cache behavior.
        """
        return pulumi.get(self, "field_level_encryption_id")

    @property
    @pulumi.getter(name="forwardedValues")
    def forwarded_values(self) -> Optional['outputs.ForwardedValuesResponse']:
        """
        This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. For more information, see [Working with policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html) in the *Amazon CloudFront Developer Guide*. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the *Amazon CloudFront Developer Guide*. A ``DefaultCacheBehavior`` must include either a ``CachePolicyId`` or ``ForwardedValues``. We recommend that you use a ``CachePolicyId``. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers. This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include values in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send values to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.
        """
        return pulumi.get(self, "forwarded_values")

    @property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[Sequence['outputs.FunctionAssociationResponse']]:
        """
        A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must be published to the ``LIVE`` stage to associate them with a cache behavior.
        """
        return pulumi.get(self, "function_associations")

    @property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[Sequence['outputs.LambdaFunctionAssociationResponse']]:
        """
        A complex type that contains zero or more Lambda@Edge function associations for a cache behavior.
        """
        return pulumi.get(self, "lambda_function_associations")

    @property
    @pulumi.getter(name="maxTTL")
    def max_ttl(self) -> Optional[int]:
        """
        This field is deprecated. We recommend that you use the ``MaxTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. The value that you specify applies only when your origin adds HTTP headers such as ``Cache-Control max-age``, ``Cache-Control s-maxage``, and ``Expires`` to objects. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "max_ttl")

    @property
    @pulumi.getter(name="minTTL")
    def min_ttl(self) -> Optional[int]:
        """
        This field is deprecated. We recommend that you use the ``MinTTL`` field in a cache policy instead of this field. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) or [Using the managed cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html) in the *Amazon CloudFront Developer Guide*. The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront forwards another request to your origin to determine whether the object has been updated. For more information, see [Managing How Long Content Stays in an Edge Cache (Expiration)](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*. You must specify ``0`` for ``MinTTL`` if you configure CloudFront to forward all headers to your origin (under ``Headers``, if you specify ``1`` for ``Quantity`` and ``*`` for ``Name``).
        """
        return pulumi.get(self, "min_ttl")

    @property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[str]:
        """
        The unique identifier of the origin request policy that is attached to the default cache behavior. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) or [Using the managed origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_request_policy_id")

    @property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this cache behavior. For more information, see [Real-time logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "realtime_log_config_arn")

    @property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[str]:
        """
        The identifier for a response headers policy.
        """
        return pulumi.get(self, "response_headers_policy_id")

    @property
    @pulumi.getter(name="smoothStreaming")
    def smooth_streaming(self) -> Optional[bool]:
        """
        Indicates whether you want to distribute media files in the Microsoft Smooth Streaming format using the origin that is associated with this cache behavior. If so, specify ``true``; if not, specify ``false``. If you specify ``true`` for ``SmoothStreaming``, you can still distribute other content using this cache behavior if the content matches the value of ``PathPattern``.
        """
        return pulumi.get(self, "smooth_streaming")

    @property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> Optional[str]:
        """
        The value of ``ID`` for the origin that you want CloudFront to route requests to when they use the default cache behavior.
        """
        return pulumi.get(self, "target_origin_id")

    @property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[Sequence[str]]:
        """
        A list of key groups that CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with a private key whose corresponding public key is in the key group. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "trusted_key_groups")

    @property
    @pulumi.getter(name="trustedSigners")
    def trusted_signers(self) -> Optional[Sequence[str]]:
        """
        We recommend using ``TrustedKeyGroups`` instead of ``TrustedSigners``.  A list of AWS-account IDs whose public keys CloudFront can use to validate signed URLs or signed cookies. When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies for all requests that match the cache behavior. The URLs or cookies must be signed with the private key of a CloudFront key pair in a trusted signer's AWS-account. The signed URL or cookie contains information about which public key CloudFront should use to verify the signature. For more information, see [Serving private content](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "trusted_signers")

    @property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> Optional[str]:
        """
        The protocol that viewers can use to access the files in the origin specified by ``TargetOriginId`` when a request matches the path pattern in ``PathPattern``. You can specify the following options:  +   ``allow-all``: Viewers can use HTTP or HTTPS.  +   ``redirect-to-https``: If a viewer submits an HTTP request, CloudFront returns an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The viewer then resubmits the request using the new URL.  +   ``https-only``: If a viewer sends an HTTP request, CloudFront returns an HTTP status code of 403 (Forbidden).   For more information about requiring the HTTPS protocol, see [Requiring HTTPS Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html) in the *Amazon CloudFront Developer Guide*.  The only way to guarantee that viewers retrieve an object that was fetched from the origin using HTTPS is never to use any other protocol to fetch the object. If you have recently changed from HTTP to HTTPS, we recommend that you clear your objects' cache because cached objects are protocol agnostic. That means that an edge location will return an object from the cache regardless of whether the current request protocol matches the protocol used previously. For more information, see [Managing Cache Expiration](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "viewer_protocol_policy")


@pulumi.output_type
class DefaultRetentionResponse(dict):
    """
    Definition of DefaultRetention
    """
    def __init__(__self__, *,
                 days: Optional[int] = None,
                 mode: Optional[str] = None,
                 years: Optional[int] = None):
        """
        Definition of DefaultRetention
        :param int days: The number of days that you want to specify for the default retention period. If Object Lock is turned on, you must specify ``Mode`` and specify either ``Days`` or ``Years``.
        :param str mode: The default Object Lock retention mode you want to apply to new objects placed in the specified bucket. If Object Lock is turned on, you must specify ``Mode`` and specify either ``Days`` or ``Years``.
        :param int years: The number of years that you want to specify for the default retention period. If Object Lock is turned on, you must specify ``Mode`` and specify either ``Days`` or ``Years``.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if years is not None:
            pulumi.set(__self__, "years", years)

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        The number of days that you want to specify for the default retention period. If Object Lock is turned on, you must specify ``Mode`` and specify either ``Days`` or ``Years``.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The default Object Lock retention mode you want to apply to new objects placed in the specified bucket. If Object Lock is turned on, you must specify ``Mode`` and specify either ``Days`` or ``Years``.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def years(self) -> Optional[int]:
        """
        The number of years that you want to specify for the default retention period. If Object Lock is turned on, you must specify ``Mode`` and specify either ``Days`` or ``Years``.
        """
        return pulumi.get(self, "years")


@pulumi.output_type
class DeleteMarkerReplicationResponse(dict):
    """
    Definition of DeleteMarkerReplication
    """
    def __init__(__self__, *,
                 status: Optional[str] = None):
        """
        Definition of DeleteMarkerReplication
        :param str status: Indicates whether to replicate delete markers. Disabled by default.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates whether to replicate delete markers. Disabled by default.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DeploymentAlarmsResponse(dict):
    """
    Definition of DeploymentAlarms
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmNames":
            suggest = "alarm_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentAlarmsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentAlarmsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentAlarmsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_names: Optional[Sequence[str]] = None,
                 enable: Optional[bool] = None,
                 rollback: Optional[bool] = None):
        """
        Definition of DeploymentAlarms
        :param Sequence[str] alarm_names: One or more CloudWatch alarm names. Use a ',' to separate the alarms.
        :param bool enable: Determines whether to use the CloudWatch alarm option in the service deployment process.
        :param bool rollback: Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
        """
        if alarm_names is not None:
            pulumi.set(__self__, "alarm_names", alarm_names)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if rollback is not None:
            pulumi.set(__self__, "rollback", rollback)

    @property
    @pulumi.getter(name="alarmNames")
    def alarm_names(self) -> Optional[Sequence[str]]:
        """
        One or more CloudWatch alarm names. Use a ',' to separate the alarms.
        """
        return pulumi.get(self, "alarm_names")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Determines whether to use the CloudWatch alarm option in the service deployment process.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def rollback(self) -> Optional[bool]:
        """
        Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
        """
        return pulumi.get(self, "rollback")


@pulumi.output_type
class DeploymentCircuitBreakerResponse(dict):
    """
    Definition of DeploymentCircuitBreaker
    """
    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 rollback: Optional[bool] = None):
        """
        Definition of DeploymentCircuitBreaker
        :param bool enable: Determines whether to use the deployment circuit breaker logic for the service.
        :param bool rollback: Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is on, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if rollback is not None:
            pulumi.set(__self__, "rollback", rollback)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Determines whether to use the deployment circuit breaker logic for the service.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def rollback(self) -> Optional[bool]:
        """
        Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is on, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
        """
        return pulumi.get(self, "rollback")


@pulumi.output_type
class DeploymentConfigurationResponse(dict):
    """
    Definition of DeploymentConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentCircuitBreaker":
            suggest = "deployment_circuit_breaker"
        elif key == "maximumPercent":
            suggest = "maximum_percent"
        elif key == "minimumHealthyPercent":
            suggest = "minimum_healthy_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarms: Optional['outputs.DeploymentAlarmsResponse'] = None,
                 deployment_circuit_breaker: Optional['outputs.DeploymentCircuitBreakerResponse'] = None,
                 maximum_percent: Optional[int] = None,
                 minimum_healthy_percent: Optional[int] = None):
        """
        Definition of DeploymentConfiguration
        :param 'DeploymentAlarmsResponse' alarms: Information about the CloudWatch alarms. One of the methods which provide a way for you to quickly identify when a deployment has failed, and then to optionally roll back the failure to the last working deployment. When the alarms are generated, Amazon ECS sets the service deployment to failed. Set the rollback parameter to have Amazon ECS to roll back your service to the last completed deployment after a failure. You can only use the ``DeploymentAlarms`` method to detect failures when the ``DeploymentController`` is set to ``ECS`` (rolling update). For more information, see [Rolling update](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param 'DeploymentCircuitBreakerResponse' deployment_circuit_breaker: The deployment circuit breaker can only be used for services using the rolling update (``ECS``) deployment type.  The *deployment circuit breaker* determines whether a service deployment will fail if the service can't reach a steady state. If you use the deployment circuit breaker, a service deployment will transition to a failed state and stop launching new tasks. If you use the rollback option, when a service deployment fails, the service is rolled back to the last deployment that completed successfully. For more information, see [Rolling update](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the *Amazon Elastic Container Service Developer Guide* The deployment circuit breaker can only be used for services using the rolling update (``ECS``) deployment type.  The *deployment circuit breaker* determines whether a service deployment will fail if the service can't reach a steady state. If it is turned on, a service deployment will transition to a failed state and stop launching new tasks. You can also configure Amazon ECS to roll back your service to the last completed deployment after a failure. For more information, see [Rolling update](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the *Amazon Elastic Container Service Developer Guide*. For more information about API failure reasons, see [API failure reasons](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/api_failures_messages.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param int maximum_percent: If a service is using the rolling update (``ECS``) deployment type, the ``maximumPercent`` parameter represents an upper limit on the number of your service's tasks that are allowed in the ``RUNNING`` or ``PENDING`` state during a deployment, as a percentage of the ``desiredCount`` (rounded down to the nearest integer). This parameter enables you to define the deployment batch size. For example, if your service is using the ``REPLICA`` service scheduler and has a ``desiredCount`` of four tasks and a ``maximumPercent`` value of 200%, the scheduler may start four new tasks before stopping the four older tasks (provided that the cluster resources required to do this are available). The default ``maximumPercent`` value for a service using the ``REPLICA`` service scheduler is 200%. If a service is using either the blue/green (``CODE_DEPLOY``) or ``EXTERNAL`` deployment types and tasks that use the EC2 launch type, the *maximum percent* value is set to the default value and is used to define the upper limit on the number of the tasks in the service that remain in the ``RUNNING`` state while the container instances are in the ``DRAINING`` state. If the tasks in the service use the Fargate launch type, the maximum percent value is not used, although it is returned when describing your service.
        :param int minimum_healthy_percent: If a service is using the rolling update (``ECS``) deployment type, the ``minimumHealthyPercent`` represents a lower limit on the number of your service's tasks that must remain in the ``RUNNING`` state during a deployment, as a percentage of the ``desiredCount`` (rounded up to the nearest integer). This parameter enables you to deploy without using additional cluster capacity. For example, if your service has a ``desiredCount`` of four tasks and a ``minimumHealthyPercent`` of 50%, the service scheduler may stop two existing tasks to free up cluster capacity before starting two new tasks.  For services that *do not* use a load balancer, the following should be noted:  +  A service is considered healthy if all essential containers within the tasks in the service pass their health checks.  +  If a task has no essential containers with a health check defined, the service scheduler will wait for 40 seconds after a task reaches a ``RUNNING`` state before the task is counted towards the minimum healthy percent total.  +  If a task has one or more essential containers with a health check defined, the service scheduler will wait for the task to reach a healthy status before counting it towards the minimum healthy percent total. A task is considered healthy when all essential containers within the task have passed their health checks. The amount of time the service scheduler can wait for is determined by the container health check settings.    For services that *do* use a load balancer, the following should be noted:  +  If a task has no essential containers with a health check defined, the service scheduler will wait for the load balancer target group health check to return a healthy status before counting the task towards the minimum healthy percent total.  +  If a task has an essential container with a health check defined, the service scheduler will wait for both the task to reach a healthy status and the load balancer target group health check to return a healthy status before counting the task towards the minimum healthy percent total.   If a service is using either the blue/green (``CODE_DEPLOY``) or ``EXTERNAL`` deployment types and is running tasks that use the EC2 launch type, the *minimum healthy percent* value is set to the default value and is used to define the lower limit on the number of the tasks in the service that remain in the ``RUNNING`` state while the container instances are in the ``DRAINING`` state. If a service is using either the blue/green (``CODE_DEPLOY``) or ``EXTERNAL`` deployment types and is running tasks that use the Fargate launch type, the minimum healthy percent value is not used, although it is returned when describing your service.
        """
        if alarms is not None:
            pulumi.set(__self__, "alarms", alarms)
        if deployment_circuit_breaker is not None:
            pulumi.set(__self__, "deployment_circuit_breaker", deployment_circuit_breaker)
        if maximum_percent is not None:
            pulumi.set(__self__, "maximum_percent", maximum_percent)
        if minimum_healthy_percent is not None:
            pulumi.set(__self__, "minimum_healthy_percent", minimum_healthy_percent)

    @property
    @pulumi.getter
    def alarms(self) -> Optional['outputs.DeploymentAlarmsResponse']:
        """
        Information about the CloudWatch alarms. One of the methods which provide a way for you to quickly identify when a deployment has failed, and then to optionally roll back the failure to the last working deployment. When the alarms are generated, Amazon ECS sets the service deployment to failed. Set the rollback parameter to have Amazon ECS to roll back your service to the last completed deployment after a failure. You can only use the ``DeploymentAlarms`` method to detect failures when the ``DeploymentController`` is set to ``ECS`` (rolling update). For more information, see [Rolling update](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "alarms")

    @property
    @pulumi.getter(name="deploymentCircuitBreaker")
    def deployment_circuit_breaker(self) -> Optional['outputs.DeploymentCircuitBreakerResponse']:
        """
        The deployment circuit breaker can only be used for services using the rolling update (``ECS``) deployment type.  The *deployment circuit breaker* determines whether a service deployment will fail if the service can't reach a steady state. If you use the deployment circuit breaker, a service deployment will transition to a failed state and stop launching new tasks. If you use the rollback option, when a service deployment fails, the service is rolled back to the last deployment that completed successfully. For more information, see [Rolling update](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the *Amazon Elastic Container Service Developer Guide* The deployment circuit breaker can only be used for services using the rolling update (``ECS``) deployment type.  The *deployment circuit breaker* determines whether a service deployment will fail if the service can't reach a steady state. If it is turned on, a service deployment will transition to a failed state and stop launching new tasks. You can also configure Amazon ECS to roll back your service to the last completed deployment after a failure. For more information, see [Rolling update](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html) in the *Amazon Elastic Container Service Developer Guide*. For more information about API failure reasons, see [API failure reasons](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/api_failures_messages.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "deployment_circuit_breaker")

    @property
    @pulumi.getter(name="maximumPercent")
    def maximum_percent(self) -> Optional[int]:
        """
        If a service is using the rolling update (``ECS``) deployment type, the ``maximumPercent`` parameter represents an upper limit on the number of your service's tasks that are allowed in the ``RUNNING`` or ``PENDING`` state during a deployment, as a percentage of the ``desiredCount`` (rounded down to the nearest integer). This parameter enables you to define the deployment batch size. For example, if your service is using the ``REPLICA`` service scheduler and has a ``desiredCount`` of four tasks and a ``maximumPercent`` value of 200%, the scheduler may start four new tasks before stopping the four older tasks (provided that the cluster resources required to do this are available). The default ``maximumPercent`` value for a service using the ``REPLICA`` service scheduler is 200%. If a service is using either the blue/green (``CODE_DEPLOY``) or ``EXTERNAL`` deployment types and tasks that use the EC2 launch type, the *maximum percent* value is set to the default value and is used to define the upper limit on the number of the tasks in the service that remain in the ``RUNNING`` state while the container instances are in the ``DRAINING`` state. If the tasks in the service use the Fargate launch type, the maximum percent value is not used, although it is returned when describing your service.
        """
        return pulumi.get(self, "maximum_percent")

    @property
    @pulumi.getter(name="minimumHealthyPercent")
    def minimum_healthy_percent(self) -> Optional[int]:
        """
        If a service is using the rolling update (``ECS``) deployment type, the ``minimumHealthyPercent`` represents a lower limit on the number of your service's tasks that must remain in the ``RUNNING`` state during a deployment, as a percentage of the ``desiredCount`` (rounded up to the nearest integer). This parameter enables you to deploy without using additional cluster capacity. For example, if your service has a ``desiredCount`` of four tasks and a ``minimumHealthyPercent`` of 50%, the service scheduler may stop two existing tasks to free up cluster capacity before starting two new tasks.  For services that *do not* use a load balancer, the following should be noted:  +  A service is considered healthy if all essential containers within the tasks in the service pass their health checks.  +  If a task has no essential containers with a health check defined, the service scheduler will wait for 40 seconds after a task reaches a ``RUNNING`` state before the task is counted towards the minimum healthy percent total.  +  If a task has one or more essential containers with a health check defined, the service scheduler will wait for the task to reach a healthy status before counting it towards the minimum healthy percent total. A task is considered healthy when all essential containers within the task have passed their health checks. The amount of time the service scheduler can wait for is determined by the container health check settings.    For services that *do* use a load balancer, the following should be noted:  +  If a task has no essential containers with a health check defined, the service scheduler will wait for the load balancer target group health check to return a healthy status before counting the task towards the minimum healthy percent total.  +  If a task has an essential container with a health check defined, the service scheduler will wait for both the task to reach a healthy status and the load balancer target group health check to return a healthy status before counting the task towards the minimum healthy percent total.   If a service is using either the blue/green (``CODE_DEPLOY``) or ``EXTERNAL`` deployment types and is running tasks that use the EC2 launch type, the *minimum healthy percent* value is set to the default value and is used to define the lower limit on the number of the tasks in the service that remain in the ``RUNNING`` state while the container instances are in the ``DRAINING`` state. If a service is using either the blue/green (``CODE_DEPLOY``) or ``EXTERNAL`` deployment types and is running tasks that use the Fargate launch type, the minimum healthy percent value is not used, although it is returned when describing your service.
        """
        return pulumi.get(self, "minimum_healthy_percent")


@pulumi.output_type
class DeploymentControllerResponse(dict):
    """
    Definition of DeploymentController
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Definition of DeploymentController
        :param str type: The deployment controller type to use. There are three deployment controller types available:  + ECS The rolling update (ECS) deployment type involves replacing the current running version of the container with the latest version. The number of containers Amazon ECS adds or removes from the service during a rolling update is controlled by adjusting the minimum and maximum number of healthy tasks allowed during a service deployment, as specified in the DeploymentConfiguration. + CODE_DEPLOY The blue/green (CODE_DEPLOY) deployment type uses the blue/green deployment model powered by , which allows you to verify a new deployment of a service before sending production traffic to it. + EXTERNAL The external (EXTERNAL) deployment type enables you to use any third-party deployment controller for full control over the deployment process for an Amazon ECS service.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The deployment controller type to use. There are three deployment controller types available:  + ECS The rolling update (ECS) deployment type involves replacing the current running version of the container with the latest version. The number of containers Amazon ECS adds or removes from the service during a rolling update is controlled by adjusting the minimum and maximum number of healthy tasks allowed during a service deployment, as specified in the DeploymentConfiguration. + CODE_DEPLOY The blue/green (CODE_DEPLOY) deployment type uses the blue/green deployment model powered by , which allows you to verify a new deployment of a service before sending production traffic to it. + EXTERNAL The external (EXTERNAL) deployment type enables you to use any third-party deployment controller for full control over the deployment process for an Amazon ECS service.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DeploymentStatusEnumValueResponse(dict):
    """
    Definition of DeploymentStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of DeploymentStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DeploymentTargetsResponse(dict):
    """
    Definition of DeploymentTargets
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountFilterType":
            suggest = "account_filter_type"
        elif key == "accountsUrl":
            suggest = "accounts_url"
        elif key == "organizationalUnitIds":
            suggest = "organizational_unit_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentTargetsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentTargetsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentTargetsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_filter_type: Optional[str] = None,
                 accounts: Optional[Sequence[str]] = None,
                 accounts_url: Optional[str] = None,
                 organizational_unit_ids: Optional[Sequence[str]] = None):
        """
        Definition of DeploymentTargets
        :param str account_filter_type: The filter type you want to apply on organizational units and accounts.
        :param Sequence[str] accounts: AWS accounts that you want to create stack instances in the specified Region(s) for.
        :param str accounts_url: Returns the value of the AccountsUrl property.
        :param Sequence[str] organizational_unit_ids: The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
        """
        if account_filter_type is not None:
            pulumi.set(__self__, "account_filter_type", account_filter_type)
        if accounts is not None:
            pulumi.set(__self__, "accounts", accounts)
        if accounts_url is not None:
            pulumi.set(__self__, "accounts_url", accounts_url)
        if organizational_unit_ids is not None:
            pulumi.set(__self__, "organizational_unit_ids", organizational_unit_ids)

    @property
    @pulumi.getter(name="accountFilterType")
    def account_filter_type(self) -> Optional[str]:
        """
        The filter type you want to apply on organizational units and accounts.
        """
        return pulumi.get(self, "account_filter_type")

    @property
    @pulumi.getter
    def accounts(self) -> Optional[Sequence[str]]:
        """
        AWS accounts that you want to create stack instances in the specified Region(s) for.
        """
        return pulumi.get(self, "accounts")

    @property
    @pulumi.getter(name="accountsUrl")
    def accounts_url(self) -> Optional[str]:
        """
        Returns the value of the AccountsUrl property.
        """
        return pulumi.get(self, "accounts_url")

    @property
    @pulumi.getter(name="organizationalUnitIds")
    def organizational_unit_ids(self) -> Optional[Sequence[str]]:
        """
        The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
        """
        return pulumi.get(self, "organizational_unit_ids")


@pulumi.output_type
class DestinationOptionsModelPropertiesResponse(dict):
    """
    Definition of DestinationOptionsModelProperties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileFormat":
            suggest = "file_format"
        elif key == "hiveCompatiblePartitions":
            suggest = "hive_compatible_partitions"
        elif key == "perHourPartition":
            suggest = "per_hour_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationOptionsModelPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationOptionsModelPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationOptionsModelPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_format: Optional[str] = None,
                 hive_compatible_partitions: Optional[bool] = None,
                 per_hour_partition: Optional[bool] = None):
        """
        Definition of DestinationOptionsModelProperties
        :param str file_format: Property fileFormat
        :param bool hive_compatible_partitions: Property hiveCompatiblePartitions
        :param bool per_hour_partition: Property perHourPartition
        """
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if hive_compatible_partitions is not None:
            pulumi.set(__self__, "hive_compatible_partitions", hive_compatible_partitions)
        if per_hour_partition is not None:
            pulumi.set(__self__, "per_hour_partition", per_hour_partition)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[str]:
        """
        Property fileFormat
        """
        return pulumi.get(self, "file_format")

    @property
    @pulumi.getter(name="hiveCompatiblePartitions")
    def hive_compatible_partitions(self) -> Optional[bool]:
        """
        Property hiveCompatiblePartitions
        """
        return pulumi.get(self, "hive_compatible_partitions")

    @property
    @pulumi.getter(name="perHourPartition")
    def per_hour_partition(self) -> Optional[bool]:
        """
        Property perHourPartition
        """
        return pulumi.get(self, "per_hour_partition")


@pulumi.output_type
class DestinationResponse(dict):
    """
    Definition of Destination
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketAccountId":
            suggest = "bucket_account_id"
        elif key == "bucketArn":
            suggest = "bucket_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_account_id: Optional[str] = None,
                 bucket_arn: Optional[str] = None,
                 format: Optional[str] = None,
                 prefix: Optional[str] = None):
        """
        Definition of Destination
        :param str bucket_account_id: The account ID that owns the destination S3 bucket. If no account ID is provided, the owner is not validated before exporting data.   Although this value is optional, we strongly recommend that you set it to help prevent problems if the destination bucket ownership changes.
        :param str bucket_arn: The Amazon Resource Name (ARN) of the bucket to which data is exported.
        :param str format: Specifies the file format used when exporting data to Amazon S3.  *Allowed values*: ``CSV`` | ``ORC`` | ``Parquet``
        :param str prefix: The prefix to use when exporting data. The prefix is prepended to all results.
        """
        if bucket_account_id is not None:
            pulumi.set(__self__, "bucket_account_id", bucket_account_id)
        if bucket_arn is not None:
            pulumi.set(__self__, "bucket_arn", bucket_arn)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="bucketAccountId")
    def bucket_account_id(self) -> Optional[str]:
        """
        The account ID that owns the destination S3 bucket. If no account ID is provided, the owner is not validated before exporting data.   Although this value is optional, we strongly recommend that you set it to help prevent problems if the destination bucket ownership changes.
        """
        return pulumi.get(self, "bucket_account_id")

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the bucket to which data is exported.
        """
        return pulumi.get(self, "bucket_arn")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        Specifies the file format used when exporting data to Amazon S3.  *Allowed values*: ``CSV`` | ``ORC`` | ``Parquet``
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The prefix to use when exporting data. The prefix is prepended to all results.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DeviceResponse(dict):
    """
    Definition of Device
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerPath":
            suggest = "container_path"
        elif key == "hostPath":
            suggest = "host_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_path: Optional[str] = None,
                 host_path: Optional[str] = None,
                 permissions: Optional[Sequence[str]] = None):
        """
        Definition of Device
        :param str container_path: The path inside the container at which to expose the host device.
        :param str host_path: The path for the device on the host container instance.
        :param Sequence[str] permissions: The explicit permissions to provide to the container for the device. By default, the container has permissions for ``read``, ``write``, and ``mknod`` for the device.
        """
        if container_path is not None:
            pulumi.set(__self__, "container_path", container_path)
        if host_path is not None:
            pulumi.set(__self__, "host_path", host_path)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter(name="containerPath")
    def container_path(self) -> Optional[str]:
        """
        The path inside the container at which to expose the host device.
        """
        return pulumi.get(self, "container_path")

    @property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> Optional[str]:
        """
        The path for the device on the host container instance.
        """
        return pulumi.get(self, "host_path")

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[str]]:
        """
        The explicit permissions to provide to the container for the device. By default, the container has permissions for ``read``, ``write``, and ``mknod`` for the device.
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class DeviceTypeEnumValueResponse(dict):
    """
    Definition of DeviceTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of DeviceTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DimensionResponse(dict):
    """
    Definition of Dimension
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of Dimension
        :param str key: The name for the CW metric dimension that the metric filter creates. Dimension names must contain only ASCII characters, must include at least one non-whitespace character, and cannot start with a colon (:).
        :param str name: The name of the dimension, from 1255 characters in length. This dimension name must have been included when the metric was published.
        :param str value: Property value
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The name for the CW metric dimension that the metric filter creates. Dimension names must contain only ASCII characters, must include at least one non-whitespace character, and cannot start with a colon (:).
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the dimension, from 1255 characters in length. This dimension name must have been included when the metric was published.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DiskResponse(dict):
    """
    Definition of Disk
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachedTo":
            suggest = "attached_to"
        elif key == "attachmentState":
            suggest = "attachment_state"
        elif key == "diskName":
            suggest = "disk_name"
        elif key == "isSystemDisk":
            suggest = "is_system_disk"
        elif key == "sizeInGb":
            suggest = "size_in_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attached_to: Optional[str] = None,
                 attachment_state: Optional[str] = None,
                 disk_name: Optional[str] = None,
                 iops: Optional[int] = None,
                 is_system_disk: Optional[bool] = None,
                 path: Optional[str] = None,
                 size_in_gb: Optional[str] = None):
        """
        Definition of Disk
        :param str attached_to: Instance attached to the disk.
        :param str attachment_state: Attachment state of the disk.
        :param str disk_name: The names to use for your new Lightsail disk.
        :param int iops: IOPS of disk.
        :param bool is_system_disk: Is the Attached disk is the system disk of the Instance.
        :param str path: Path of the disk attached to the instance.
        :param str size_in_gb: Size of the disk attached to the Instance.
        """
        if attached_to is not None:
            pulumi.set(__self__, "attached_to", attached_to)
        if attachment_state is not None:
            pulumi.set(__self__, "attachment_state", attachment_state)
        if disk_name is not None:
            pulumi.set(__self__, "disk_name", disk_name)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if is_system_disk is not None:
            pulumi.set(__self__, "is_system_disk", is_system_disk)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if size_in_gb is not None:
            pulumi.set(__self__, "size_in_gb", size_in_gb)

    @property
    @pulumi.getter(name="attachedTo")
    def attached_to(self) -> Optional[str]:
        """
        Instance attached to the disk.
        """
        return pulumi.get(self, "attached_to")

    @property
    @pulumi.getter(name="attachmentState")
    def attachment_state(self) -> Optional[str]:
        """
        Attachment state of the disk.
        """
        return pulumi.get(self, "attachment_state")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> Optional[str]:
        """
        The names to use for your new Lightsail disk.
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        IOPS of disk.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="isSystemDisk")
    def is_system_disk(self) -> Optional[bool]:
        """
        Is the Attached disk is the system disk of the Instance.
        """
        return pulumi.get(self, "is_system_disk")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the disk attached to the instance.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> Optional[str]:
        """
        Size of the disk attached to the Instance.
        """
        return pulumi.get(self, "size_in_gb")


@pulumi.output_type
class DistributionConfigResponse(dict):
    """
    Definition of DistributionConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheBehaviors":
            suggest = "cache_behaviors"
        elif key == "cnamEs":
            suggest = "cnam_es"
        elif key == "continuousDeploymentPolicyId":
            suggest = "continuous_deployment_policy_id"
        elif key == "customErrorResponses":
            suggest = "custom_error_responses"
        elif key == "customOrigin":
            suggest = "custom_origin"
        elif key == "defaultCacheBehavior":
            suggest = "default_cache_behavior"
        elif key == "defaultRootObject":
            suggest = "default_root_object"
        elif key == "httpVersion":
            suggest = "http_version"
        elif key == "ipV6Enabled":
            suggest = "ip_v6_enabled"
        elif key == "originGroups":
            suggest = "origin_groups"
        elif key == "priceClass":
            suggest = "price_class"
        elif key == "s3Origin":
            suggest = "s3_origin"
        elif key == "viewerCertificate":
            suggest = "viewer_certificate"
        elif key == "webACLId":
            suggest = "web_acl_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aliases: Optional[Sequence[str]] = None,
                 cache_behaviors: Optional[Sequence['outputs.CacheBehaviorResponse']] = None,
                 cnam_es: Optional[Sequence[str]] = None,
                 comment: Optional[str] = None,
                 continuous_deployment_policy_id: Optional[str] = None,
                 custom_error_responses: Optional[Sequence['outputs.CustomErrorResponseResponse']] = None,
                 custom_origin: Optional['outputs.LegacyCustomOriginResponse'] = None,
                 default_cache_behavior: Optional['outputs.DefaultCacheBehaviorResponse'] = None,
                 default_root_object: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 http_version: Optional[str] = None,
                 ip_v6_enabled: Optional[bool] = None,
                 logging: Optional['outputs.LoggingResponse'] = None,
                 origin_groups: Optional['outputs.OriginGroupsResponse'] = None,
                 origins: Optional[Sequence['outputs.OriginResponse']] = None,
                 price_class: Optional[str] = None,
                 restrictions: Optional['outputs.RestrictionsResponse'] = None,
                 s3_origin: Optional['outputs.LegacyS3OriginResponse'] = None,
                 staging: Optional[bool] = None,
                 viewer_certificate: Optional['outputs.ViewerCertificateResponse'] = None,
                 web_acl_id: Optional[str] = None):
        """
        Definition of DistributionConfig
        :param Sequence[str] aliases: A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        :param Sequence['CacheBehaviorResponse'] cache_behaviors: A complex type that contains zero or more ``CacheBehavior`` elements.
        :param Sequence[str] cnam_es: Property cnamEs
        :param str comment: A comment to describe the distribution. The comment cannot be longer than 128 characters.
        :param str continuous_deployment_policy_id: The identifier of a continuous deployment policy. For more information, see ``CreateContinuousDeploymentPolicy``.
        :param Sequence['CustomErrorResponseResponse'] custom_error_responses: A complex type that controls the following:  +  Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.  +  How long CloudFront caches HTTP status codes in the 4xx and 5xx range.   For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the *Amazon CloudFront Developer Guide*.
        :param 'LegacyCustomOriginResponse' custom_origin: Property customOrigin
        :param 'DefaultCacheBehaviorResponse' default_cache_behavior: A complex type that describes the default cache behavior if you don't specify a ``CacheBehavior`` element or if files don't match any of the values of ``PathPattern`` in ``CacheBehavior`` elements. You must create exactly one default cache behavior. A complex type that describes the default cache behavior if you don't specify a ``CacheBehavior`` element or if request URLs don't match any of the values of ``PathPattern`` in ``CacheBehavior`` elements. You must create exactly one default cache behavior.
        :param str default_root_object: The object that you want CloudFront to request from your origin (for example, ``index.html``) when a viewer requests the root URL for your distribution (``https://www.example.com``) instead of an object in your distribution (``https://www.example.com/product-description.html``). Specifying a default root object avoids exposing the contents of your distribution. Specify only the object name, for example, ``index.html``. Don't add a ``/`` before the object name. If you don't want to specify a default root object when you create a distribution, include an empty ``DefaultRootObject`` element. To delete the default root object from an existing distribution, update the distribution configuration and include an empty ``DefaultRootObject`` element. To replace the default root object, update the distribution configuration and specify the new object. For more information about the default root object, see [Creating a Default Root Object](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html) in the *Amazon CloudFront Developer Guide*.
        :param bool enabled: From this field, you can enable or disable the selected distribution.
        :param str http_version: (Optional) Specify the maximum HTTP version(s) that you want viewers to use to communicate with CF. The default value for new distributions is ``http1.1``. For viewers and CF to use HTTP/2, viewers must support TLSv1.2 or later, and must support Server Name Indication (SNI). For viewers and CF to use HTTP/3, viewers must support TLSv1.3 and Server Name Indication (SNI). CF supports HTTP/3 connection migration to allow the viewer to switch networks without losing connection. For more information about connection migration, see [Connection Migration](https://docs.aws.amazon.com/https://www.rfc-editor.org/rfc/rfc9000.html#name-connection-migration) at RFC 9000. For more information about supported TLSv1.3 ciphers, see [Supported protocols and ciphers between viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html).
        :param bool ip_v6_enabled: If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your distribution, specify ``true``. If you specify ``false``, CloudFront responds to IPv6 DNS requests with the DNS response code ``NOERROR`` and with no IP addresses. This allows viewers to submit a second request, for an IPv4 address for your distribution. In general, you should enable IPv6 if you have users on IPv6 networks who want to access your content. However, if you're using signed URLs or signed cookies to restrict access to your content, and if you're using a custom policy that includes the ``IpAddress`` parameter to restrict the IP addresses that can access your content, don't enable IPv6. If you want to restrict access to some content by IP address and not restrict access to other content (or restrict access but not by IP address), you can create two distributions. For more information, see [Creating a Signed URL Using a Custom Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html) in the *Amazon CloudFront Developer Guide*. If you're using an R53AWSIntlong alias resource record set to route traffic to your CloudFront distribution, you need to create a second alias resource record set when both of the following are true:  +  You enable IPv6 for the distribution  +  You're using alternate domain names in the URLs for your objects   For more information, see [Routing Traffic to an Amazon CloudFront Web Distribution by Using Your Domain Name](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html) in the *Developer Guide*. If you created a CNAME resource record set, either with R53AWSIntlong or with another DNS service, you don't need to make any changes. A CNAME record will route traffic to your distribution regardless of the IP address format of the viewer request.
        :param 'LoggingResponse' logging: A complex type that controls whether access logs are written for the distribution. For more information about logging, see [Access Logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html) in the *Amazon CloudFront Developer Guide*. A complex type that controls whether access logs are written for the distribution.
        :param 'OriginGroupsResponse' origin_groups: A complex type that contains information about origin groups for this distribution. A complex data type for the origin groups specified for a distribution.
        :param Sequence['OriginResponse'] origins: A complex type that contains information about origins for this distribution.
        :param str price_class: The price class that corresponds with the maximum price that you want to pay for CloudFront service. If you specify ``PriceClass_All``, CloudFront responds to requests for your objects from all CloudFront edge locations. If you specify a price class other than ``PriceClass_All``, CloudFront serves your objects from the CloudFront edge location that has the lowest latency among the edge locations in your price class. Viewers who are in or near regions that are excluded from your specified price class may encounter slower performance. For more information about price classes, see [Choosing the Price Class for a CloudFront Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html) in the *Amazon CloudFront Developer Guide*. For information about CloudFront pricing, including how price classes (such as Price Class 100) map to CloudFront regions, see [Amazon CloudFront Pricing](https://docs.aws.amazon.com/cloudfront/pricing/).
        :param 'RestrictionsResponse' restrictions: A complex type that identifies ways in which you want to restrict distribution of your content. A complex type that identifies ways in which you want to restrict distribution of your content.
        :param 'LegacyS3OriginResponse' s3_origin: Property s3Origin
        :param bool staging: A Boolean that indicates whether this is a staging distribution. When this value is ``true``, this is a staging distribution. When this value is ``false``, this is not a staging distribution.
        :param 'ViewerCertificateResponse' viewer_certificate: A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers. A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers. If the distribution doesn't use ``Aliases`` (also known as alternate domain names or CNAMEs)that is, if the distribution uses the CloudFront domain name such as ``d111111abcdef8.cloudfront.net``set ``CloudFrontDefaultCertificate`` to ``true`` and leave all other fields empty. If the distribution uses ``Aliases`` (alternate domain names or CNAMEs), use the fields in this type to specify the following settings:  +  Which viewers the distribution accepts HTTPS connections from: only viewers that support [server name indication (SNI)](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Server_Name_Indication) (recommended), or all viewers including those that don't support SNI.  +  To accept HTTPS connections from only viewers that support SNI, set ``SSLSupportMethod`` to ``sni-only``. This is recommended. Most browsers and clients support SNI. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.)  +  To accept HTTPS connections from all viewers, including those that don't support SNI, set ``SSLSupportMethod`` to ``vip``. This is not recommended, and results in additional monthly charges from CloudFront. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.)    +  The minimum SSL/TLS protocol version that the distribution can use to communicate with viewers. To specify a minimum version, choose a value for ``MinimumProtocolVersion``. For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) in the *Amazon CloudFront Developer Guide*.  +  The location of the SSL/TLS certificate, [(ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html) (recommended) or [(IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html). You specify the location by setting a value in one of the following fields (not both):  +   ``ACMCertificateArn`` (In CloudFormation, this field name is ``AcmCertificateArn``. Note the different capitalization.)  +   ``IAMCertificateId`` (In CloudFormation, this field name is ``IamCertificateId``. Note the different capitalization.)     All distributions support HTTPS connections from viewers. To require viewers to use HTTPS only, or to redirect them from HTTP to HTTPS, use ``ViewerProtocolPolicy`` in the ``CacheBehavior`` or ``DefaultCacheBehavior``. To specify how CloudFront should use SSL/TLS to communicate with your custom origin, use ``CustomOriginConfig``. For more information, see [Using HTTPS with CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html) and [Using Alternate Domain Names and HTTPS](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html) in the *Amazon CloudFront Developer Guide*.
        :param str web_acl_id: A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example ``arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a``. To specify a web ACL created using WAF Classic, use the ACL ID, for example ``473e64fd-f30b-4765-81a0-62ad96dd167a``.  WAF is a web application firewall that lets you monitor the HTTP and HTTPS requests that are forwarded to CloudFront, and lets you control access to your content. Based on conditions that you specify, such as the IP addresses that requests originate from or the values of query strings, CloudFront responds to requests either with the requested content or with an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page when a request is blocked. For more information about WAF, see the [Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html).
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if cache_behaviors is not None:
            pulumi.set(__self__, "cache_behaviors", cache_behaviors)
        if cnam_es is not None:
            pulumi.set(__self__, "cnam_es", cnam_es)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if continuous_deployment_policy_id is not None:
            pulumi.set(__self__, "continuous_deployment_policy_id", continuous_deployment_policy_id)
        if custom_error_responses is not None:
            pulumi.set(__self__, "custom_error_responses", custom_error_responses)
        if custom_origin is not None:
            pulumi.set(__self__, "custom_origin", custom_origin)
        if default_cache_behavior is not None:
            pulumi.set(__self__, "default_cache_behavior", default_cache_behavior)
        if default_root_object is not None:
            pulumi.set(__self__, "default_root_object", default_root_object)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if http_version is None:
            http_version = 'http1.1'
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if ip_v6_enabled is not None:
            pulumi.set(__self__, "ip_v6_enabled", ip_v6_enabled)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if origin_groups is not None:
            pulumi.set(__self__, "origin_groups", origin_groups)
        if origins is not None:
            pulumi.set(__self__, "origins", origins)
        if price_class is None:
            price_class = 'PriceClass_All'
        if price_class is not None:
            pulumi.set(__self__, "price_class", price_class)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)
        if s3_origin is not None:
            pulumi.set(__self__, "s3_origin", s3_origin)
        if staging is not None:
            pulumi.set(__self__, "staging", staging)
        if viewer_certificate is not None:
            pulumi.set(__self__, "viewer_certificate", viewer_certificate)
        if web_acl_id is not None:
            pulumi.set(__self__, "web_acl_id", web_acl_id)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence[str]]:
        """
        A complex type that contains information about CNAMEs (alternate domain names), if any, for this distribution.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter(name="cacheBehaviors")
    def cache_behaviors(self) -> Optional[Sequence['outputs.CacheBehaviorResponse']]:
        """
        A complex type that contains zero or more ``CacheBehavior`` elements.
        """
        return pulumi.get(self, "cache_behaviors")

    @property
    @pulumi.getter(name="cnamEs")
    def cnam_es(self) -> Optional[Sequence[str]]:
        """
        Property cnamEs
        """
        return pulumi.get(self, "cnam_es")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        A comment to describe the distribution. The comment cannot be longer than 128 characters.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="continuousDeploymentPolicyId")
    def continuous_deployment_policy_id(self) -> Optional[str]:
        """
        The identifier of a continuous deployment policy. For more information, see ``CreateContinuousDeploymentPolicy``.
        """
        return pulumi.get(self, "continuous_deployment_policy_id")

    @property
    @pulumi.getter(name="customErrorResponses")
    def custom_error_responses(self) -> Optional[Sequence['outputs.CustomErrorResponseResponse']]:
        """
        A complex type that controls the following:  +  Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error messages before returning the response to the viewer.  +  How long CloudFront caches HTTP status codes in the 4xx and 5xx range.   For more information about custom error pages, see [Customizing Error Responses](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "custom_error_responses")

    @property
    @pulumi.getter(name="customOrigin")
    def custom_origin(self) -> Optional['outputs.LegacyCustomOriginResponse']:
        """
        Property customOrigin
        """
        return pulumi.get(self, "custom_origin")

    @property
    @pulumi.getter(name="defaultCacheBehavior")
    def default_cache_behavior(self) -> Optional['outputs.DefaultCacheBehaviorResponse']:
        """
        A complex type that describes the default cache behavior if you don't specify a ``CacheBehavior`` element or if files don't match any of the values of ``PathPattern`` in ``CacheBehavior`` elements. You must create exactly one default cache behavior. A complex type that describes the default cache behavior if you don't specify a ``CacheBehavior`` element or if request URLs don't match any of the values of ``PathPattern`` in ``CacheBehavior`` elements. You must create exactly one default cache behavior.
        """
        return pulumi.get(self, "default_cache_behavior")

    @property
    @pulumi.getter(name="defaultRootObject")
    def default_root_object(self) -> Optional[str]:
        """
        The object that you want CloudFront to request from your origin (for example, ``index.html``) when a viewer requests the root URL for your distribution (``https://www.example.com``) instead of an object in your distribution (``https://www.example.com/product-description.html``). Specifying a default root object avoids exposing the contents of your distribution. Specify only the object name, for example, ``index.html``. Don't add a ``/`` before the object name. If you don't want to specify a default root object when you create a distribution, include an empty ``DefaultRootObject`` element. To delete the default root object from an existing distribution, update the distribution configuration and include an empty ``DefaultRootObject`` element. To replace the default root object, update the distribution configuration and specify the new object. For more information about the default root object, see [Creating a Default Root Object](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "default_root_object")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        From this field, you can enable or disable the selected distribution.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[str]:
        """
        (Optional) Specify the maximum HTTP version(s) that you want viewers to use to communicate with CF. The default value for new distributions is ``http1.1``. For viewers and CF to use HTTP/2, viewers must support TLSv1.2 or later, and must support Server Name Indication (SNI). For viewers and CF to use HTTP/3, viewers must support TLSv1.3 and Server Name Indication (SNI). CF supports HTTP/3 connection migration to allow the viewer to switch networks without losing connection. For more information about connection migration, see [Connection Migration](https://docs.aws.amazon.com/https://www.rfc-editor.org/rfc/rfc9000.html#name-connection-migration) at RFC 9000. For more information about supported TLSv1.3 ciphers, see [Supported protocols and ciphers between viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html).
        """
        return pulumi.get(self, "http_version")

    @property
    @pulumi.getter(name="ipV6Enabled")
    def ip_v6_enabled(self) -> Optional[bool]:
        """
        If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your distribution, specify ``true``. If you specify ``false``, CloudFront responds to IPv6 DNS requests with the DNS response code ``NOERROR`` and with no IP addresses. This allows viewers to submit a second request, for an IPv4 address for your distribution. In general, you should enable IPv6 if you have users on IPv6 networks who want to access your content. However, if you're using signed URLs or signed cookies to restrict access to your content, and if you're using a custom policy that includes the ``IpAddress`` parameter to restrict the IP addresses that can access your content, don't enable IPv6. If you want to restrict access to some content by IP address and not restrict access to other content (or restrict access but not by IP address), you can create two distributions. For more information, see [Creating a Signed URL Using a Custom Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html) in the *Amazon CloudFront Developer Guide*. If you're using an R53AWSIntlong alias resource record set to route traffic to your CloudFront distribution, you need to create a second alias resource record set when both of the following are true:  +  You enable IPv6 for the distribution  +  You're using alternate domain names in the URLs for your objects   For more information, see [Routing Traffic to an Amazon CloudFront Web Distribution by Using Your Domain Name](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html) in the *Developer Guide*. If you created a CNAME resource record set, either with R53AWSIntlong or with another DNS service, you don't need to make any changes. A CNAME record will route traffic to your distribution regardless of the IP address format of the viewer request.
        """
        return pulumi.get(self, "ip_v6_enabled")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.LoggingResponse']:
        """
        A complex type that controls whether access logs are written for the distribution. For more information about logging, see [Access Logs](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html) in the *Amazon CloudFront Developer Guide*. A complex type that controls whether access logs are written for the distribution.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="originGroups")
    def origin_groups(self) -> Optional['outputs.OriginGroupsResponse']:
        """
        A complex type that contains information about origin groups for this distribution. A complex data type for the origin groups specified for a distribution.
        """
        return pulumi.get(self, "origin_groups")

    @property
    @pulumi.getter
    def origins(self) -> Optional[Sequence['outputs.OriginResponse']]:
        """
        A complex type that contains information about origins for this distribution.
        """
        return pulumi.get(self, "origins")

    @property
    @pulumi.getter(name="priceClass")
    def price_class(self) -> Optional[str]:
        """
        The price class that corresponds with the maximum price that you want to pay for CloudFront service. If you specify ``PriceClass_All``, CloudFront responds to requests for your objects from all CloudFront edge locations. If you specify a price class other than ``PriceClass_All``, CloudFront serves your objects from the CloudFront edge location that has the lowest latency among the edge locations in your price class. Viewers who are in or near regions that are excluded from your specified price class may encounter slower performance. For more information about price classes, see [Choosing the Price Class for a CloudFront Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html) in the *Amazon CloudFront Developer Guide*. For information about CloudFront pricing, including how price classes (such as Price Class 100) map to CloudFront regions, see [Amazon CloudFront Pricing](https://docs.aws.amazon.com/cloudfront/pricing/).
        """
        return pulumi.get(self, "price_class")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional['outputs.RestrictionsResponse']:
        """
        A complex type that identifies ways in which you want to restrict distribution of your content. A complex type that identifies ways in which you want to restrict distribution of your content.
        """
        return pulumi.get(self, "restrictions")

    @property
    @pulumi.getter(name="s3Origin")
    def s3_origin(self) -> Optional['outputs.LegacyS3OriginResponse']:
        """
        Property s3Origin
        """
        return pulumi.get(self, "s3_origin")

    @property
    @pulumi.getter
    def staging(self) -> Optional[bool]:
        """
        A Boolean that indicates whether this is a staging distribution. When this value is ``true``, this is a staging distribution. When this value is ``false``, this is not a staging distribution.
        """
        return pulumi.get(self, "staging")

    @property
    @pulumi.getter(name="viewerCertificate")
    def viewer_certificate(self) -> Optional['outputs.ViewerCertificateResponse']:
        """
        A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers. A complex type that determines the distribution's SSL/TLS configuration for communicating with viewers. If the distribution doesn't use ``Aliases`` (also known as alternate domain names or CNAMEs)that is, if the distribution uses the CloudFront domain name such as ``d111111abcdef8.cloudfront.net``set ``CloudFrontDefaultCertificate`` to ``true`` and leave all other fields empty. If the distribution uses ``Aliases`` (alternate domain names or CNAMEs), use the fields in this type to specify the following settings:  +  Which viewers the distribution accepts HTTPS connections from: only viewers that support [server name indication (SNI)](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Server_Name_Indication) (recommended), or all viewers including those that don't support SNI.  +  To accept HTTPS connections from only viewers that support SNI, set ``SSLSupportMethod`` to ``sni-only``. This is recommended. Most browsers and clients support SNI. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.)  +  To accept HTTPS connections from all viewers, including those that don't support SNI, set ``SSLSupportMethod`` to ``vip``. This is not recommended, and results in additional monthly charges from CloudFront. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.)    +  The minimum SSL/TLS protocol version that the distribution can use to communicate with viewers. To specify a minimum version, choose a value for ``MinimumProtocolVersion``. For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) in the *Amazon CloudFront Developer Guide*.  +  The location of the SSL/TLS certificate, [(ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html) (recommended) or [(IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html). You specify the location by setting a value in one of the following fields (not both):  +   ``ACMCertificateArn`` (In CloudFormation, this field name is ``AcmCertificateArn``. Note the different capitalization.)  +   ``IAMCertificateId`` (In CloudFormation, this field name is ``IamCertificateId``. Note the different capitalization.)     All distributions support HTTPS connections from viewers. To require viewers to use HTTPS only, or to redirect them from HTTP to HTTPS, use ``ViewerProtocolPolicy`` in the ``CacheBehavior`` or ``DefaultCacheBehavior``. To specify how CloudFront should use SSL/TLS to communicate with your custom origin, use ``CustomOriginConfig``. For more information, see [Using HTTPS with CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html) and [Using Alternate Domain Names and HTTPS](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "viewer_certificate")

    @property
    @pulumi.getter(name="webACLId")
    def web_acl_id(self) -> Optional[str]:
        """
        A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of WAF, use the ACL ARN, for example ``arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a``. To specify a web ACL created using WAF Classic, use the ACL ID, for example ``473e64fd-f30b-4765-81a0-62ad96dd167a``.  WAF is a web application firewall that lets you monitor the HTTP and HTTPS requests that are forwarded to CloudFront, and lets you control access to your content. Based on conditions that you specify, such as the IP addresses that requests originate from or the values of query strings, CloudFront responds to requests either with the requested content or with an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page when a request is blocked. For more information about WAF, see the [Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html).
        """
        return pulumi.get(self, "web_acl_id")


@pulumi.output_type
class DockerVolumeConfigurationResponse(dict):
    """
    Definition of DockerVolumeConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driverOpts":
            suggest = "driver_opts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerVolumeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerVolumeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerVolumeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoprovision: Optional[bool] = None,
                 driver: Optional[str] = None,
                 driver_opts: Optional[Any] = None,
                 labels: Optional[Any] = None,
                 scope: Optional[str] = None):
        """
        Definition of DockerVolumeConfiguration
        :param bool autoprovision: If this value is ``true``, the Docker volume is created if it doesn't already exist.  This field is only used if the ``scope`` is ``shared``.
        :param str driver: The Docker volume driver to use. The driver value must match the driver name provided by Docker because it is used for task placement. If the driver was installed using the Docker plugin CLI, use ``docker plugin ls`` to retrieve the driver name from your container instance. If the driver was installed using another method, use Docker plugin discovery to retrieve the driver name. For more information, see [Docker plugin discovery](https://docs.aws.amazon.com/https://docs.docker.com/engine/extend/plugin_api/#plugin-discovery). This parameter maps to ``Driver`` in the [Create a volume](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/VolumeCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``xxdriver`` option to [docker volume create](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/volume_create/).
        :param Any driver_opts: A map of Docker driver-specific options passed through. This parameter maps to ``DriverOpts`` in the [Create a volume](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/VolumeCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``xxopt`` option to [docker volume create](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/volume_create/).
        :param Any labels: Custom metadata to add to your Docker volume. This parameter maps to ``Labels`` in the [Create a volume](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/VolumeCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``xxlabel`` option to [docker volume create](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/volume_create/).
        :param str scope: The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a ``task`` are automatically provisioned when the task starts and destroyed when the task stops. Docker volumes that are scoped as ``shared`` persist after the task stops.
        """
        if autoprovision is not None:
            pulumi.set(__self__, "autoprovision", autoprovision)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if driver_opts is not None:
            pulumi.set(__self__, "driver_opts", driver_opts)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def autoprovision(self) -> Optional[bool]:
        """
        If this value is ``true``, the Docker volume is created if it doesn't already exist.  This field is only used if the ``scope`` is ``shared``.
        """
        return pulumi.get(self, "autoprovision")

    @property
    @pulumi.getter
    def driver(self) -> Optional[str]:
        """
        The Docker volume driver to use. The driver value must match the driver name provided by Docker because it is used for task placement. If the driver was installed using the Docker plugin CLI, use ``docker plugin ls`` to retrieve the driver name from your container instance. If the driver was installed using another method, use Docker plugin discovery to retrieve the driver name. For more information, see [Docker plugin discovery](https://docs.aws.amazon.com/https://docs.docker.com/engine/extend/plugin_api/#plugin-discovery). This parameter maps to ``Driver`` in the [Create a volume](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/VolumeCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``xxdriver`` option to [docker volume create](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/volume_create/).
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="driverOpts")
    def driver_opts(self) -> Optional[Any]:
        """
        A map of Docker driver-specific options passed through. This parameter maps to ``DriverOpts`` in the [Create a volume](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/VolumeCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``xxopt`` option to [docker volume create](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/volume_create/).
        """
        return pulumi.get(self, "driver_opts")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Any]:
        """
        Custom metadata to add to your Docker volume. This parameter maps to ``Labels`` in the [Create a volume](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/VolumeCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``xxlabel`` option to [docker volume create](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/volume_create/).
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a ``task`` are automatically provisioned when the task starts and destroyed when the task stops. Docker volumes that are scoped as ``shared`` persist after the task stops.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class DomainEndpointOptionsResponse(dict):
    """
    Definition of DomainEndpointOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customEndpoint":
            suggest = "custom_endpoint"
        elif key == "customEndpointCertificateArn":
            suggest = "custom_endpoint_certificate_arn"
        elif key == "customEndpointEnabled":
            suggest = "custom_endpoint_enabled"
        elif key == "enforceHTTPS":
            suggest = "enforce_https"
        elif key == "tlsSecurityPolicy":
            suggest = "tls_security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainEndpointOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainEndpointOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainEndpointOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_endpoint: Optional[str] = None,
                 custom_endpoint_certificate_arn: Optional[str] = None,
                 custom_endpoint_enabled: Optional[bool] = None,
                 enforce_https: Optional[bool] = None,
                 tls_security_policy: Optional['outputs.TLSSecurityPolicyEnumValueResponse'] = None):
        """
        Definition of DomainEndpointOptions
        :param str custom_endpoint: <p>The fully qualified URL for the custom endpoint.</p>
        :param str custom_endpoint_certificate_arn: <p>The ARN for your security certificate, managed in Amazon Web Services Certificate Manager (ACM).</p>
        :param bool custom_endpoint_enabled: <p>Whether to enable a custom endpoint for the domain.</p>
        :param bool enforce_https: <p>True to require that all traffic to the domain arrive over HTTPS.</p>
        :param 'TLSSecurityPolicyEnumValueResponse' tls_security_policy: <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain. The policy can be one of the following values:</p> <ul> <li> <p> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy that supports TLS version 1.0 to TLS version 1.2</p> </li> <li> <p> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy that supports only TLS version 1.2</p> </li> <li> <p> <b>Policy-Min-TLS-1-2-PFS-2023-10:</b> TLS security policy that supports TLS version 1.2 to TLS version 1.3 with perfect forward secrecy cipher suites</p> </li> </ul>
        """
        if custom_endpoint is not None:
            pulumi.set(__self__, "custom_endpoint", custom_endpoint)
        if custom_endpoint_certificate_arn is not None:
            pulumi.set(__self__, "custom_endpoint_certificate_arn", custom_endpoint_certificate_arn)
        if custom_endpoint_enabled is not None:
            pulumi.set(__self__, "custom_endpoint_enabled", custom_endpoint_enabled)
        if enforce_https is not None:
            pulumi.set(__self__, "enforce_https", enforce_https)
        if tls_security_policy is not None:
            pulumi.set(__self__, "tls_security_policy", tls_security_policy)

    @property
    @pulumi.getter(name="customEndpoint")
    def custom_endpoint(self) -> Optional[str]:
        """
        <p>The fully qualified URL for the custom endpoint.</p>
        """
        return pulumi.get(self, "custom_endpoint")

    @property
    @pulumi.getter(name="customEndpointCertificateArn")
    def custom_endpoint_certificate_arn(self) -> Optional[str]:
        """
        <p>The ARN for your security certificate, managed in Amazon Web Services Certificate Manager (ACM).</p>
        """
        return pulumi.get(self, "custom_endpoint_certificate_arn")

    @property
    @pulumi.getter(name="customEndpointEnabled")
    def custom_endpoint_enabled(self) -> Optional[bool]:
        """
        <p>Whether to enable a custom endpoint for the domain.</p>
        """
        return pulumi.get(self, "custom_endpoint_enabled")

    @property
    @pulumi.getter(name="enforceHTTPS")
    def enforce_https(self) -> Optional[bool]:
        """
        <p>True to require that all traffic to the domain arrive over HTTPS.</p>
        """
        return pulumi.get(self, "enforce_https")

    @property
    @pulumi.getter(name="tlsSecurityPolicy")
    def tls_security_policy(self) -> Optional['outputs.TLSSecurityPolicyEnumValueResponse']:
        """
        <p>Specify the TLS security policy to apply to the HTTPS endpoint of the domain. The policy can be one of the following values:</p> <ul> <li> <p> <b>Policy-Min-TLS-1-0-2019-07:</b> TLS security policy that supports TLS version 1.0 to TLS version 1.2</p> </li> <li> <p> <b>Policy-Min-TLS-1-2-2019-07:</b> TLS security policy that supports only TLS version 1.2</p> </li> <li> <p> <b>Policy-Min-TLS-1-2-PFS-2023-10:</b> TLS security policy that supports TLS version 1.2 to TLS version 1.3 with perfect forward secrecy cipher suites</p> </li> </ul>
        """
        return pulumi.get(self, "tls_security_policy")


@pulumi.output_type
class DomainProcessingStatusTypeEnumValueResponse(dict):
    """
    Definition of DomainProcessingStatusTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of DomainProcessingStatusTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainTypeEnumValueResponse(dict):
    """
    Definition of DomainTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of DomainTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DynamoDBContinuousBackupsDescriptionPropertiesResponse(dict):
    """
    Definition of DynamoDBContinuousBackupsDescription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamoDBContinuousBackupsDescriptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamoDBContinuousBackupsDescriptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamoDBContinuousBackupsDescriptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsDynamoDBContinuousBackupsDescriptionPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of DynamoDBContinuousBackupsDescription
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsDynamoDBContinuousBackupsDescriptionPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsDynamoDBContinuousBackupsDescriptionPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class DynamoDBTablePropertiesResponse(dict):
    """
    Definition of DynamoDBTable
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamoDBTablePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamoDBTablePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamoDBTablePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsDynamoDBTablePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of DynamoDBTable
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsDynamoDBTablePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsDynamoDBTablePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EBSOptionsResponse(dict):
    """
    Definition of EBSOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsEnabled":
            suggest = "ebs_enabled"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EBSOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EBSOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EBSOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ebs_enabled: Optional[bool] = None,
                 iops: Optional[int] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional['outputs.VolumeTypeEnumValueResponse'] = None):
        """
        Definition of EBSOptions
        :param bool ebs_enabled: <p>Indicates whether EBS volumes are attached to data nodes in an OpenSearch Service domain.</p>
        :param int iops: <p>Specifies the baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> and provisioned IOPS EBS volume types.</p>
        :param int throughput: <p>Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> volume type.</p>
        :param int volume_size: <p>Specifies the size (in GiB) of EBS volumes attached to data nodes.</p>
        :param 'VolumeTypeEnumValueResponse' volume_type: <p>Specifies the type of EBS volumes attached to data nodes.</p>
        """
        if ebs_enabled is not None:
            pulumi.set(__self__, "ebs_enabled", ebs_enabled)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="ebsEnabled")
    def ebs_enabled(self) -> Optional[bool]:
        """
        <p>Indicates whether EBS volumes are attached to data nodes in an OpenSearch Service domain.</p>
        """
        return pulumi.get(self, "ebs_enabled")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        <p>Specifies the baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> and provisioned IOPS EBS volume types.</p>
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        <p>Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the <code>gp3</code> volume type.</p>
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        <p>Specifies the size (in GiB) of EBS volumes attached to data nodes.</p>
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional['outputs.VolumeTypeEnumValueResponse']:
        """
        <p>Specifies the type of EBS volumes attached to data nodes.</p>
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class EBSTagSpecificationResponse(dict):
    """
    Definition of EBSTagSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagateTags":
            suggest = "propagate_tags"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EBSTagSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EBSTagSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EBSTagSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 propagate_tags: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TagResponse']] = None):
        """
        Definition of EBSTagSpecification
        :param str propagate_tags: Determines whether to propagate the tags from the task definition to the Amazon EBS volume. Tags can only propagate to a ``SERVICE`` specified in ``ServiceVolumeConfiguration``. If no value is specified, the tags aren't propagated.
        :param str resource_type: The type of volume resource.
        :param Sequence['TagResponse'] tags: The tags applied to this Amazon EBS volume. ``AmazonECSCreated`` and ``AmazonECSManaged`` are reserved tags that can't be used.
        """
        if propagate_tags is not None:
            pulumi.set(__self__, "propagate_tags", propagate_tags)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="propagateTags")
    def propagate_tags(self) -> Optional[str]:
        """
        Determines whether to propagate the tags from the task definition to the Amazon EBS volume. Tags can only propagate to a ``SERVICE`` specified in ``ServiceVolumeConfiguration``. If no value is specified, the tags aren't propagated.
        """
        return pulumi.get(self, "propagate_tags")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of volume resource.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TagResponse']]:
        """
        The tags applied to this Amazon EBS volume. ``AmazonECSCreated`` and ``AmazonECSManaged`` are reserved tags that can't be used.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class EFSVolumeConfigurationResponse(dict):
    """
    Definition of EFSVolumeConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationConfig":
            suggest = "authorization_config"
        elif key == "filesystemId":
            suggest = "filesystem_id"
        elif key == "rootDirectory":
            suggest = "root_directory"
        elif key == "transitEncryption":
            suggest = "transit_encryption"
        elif key == "transitEncryptionPort":
            suggest = "transit_encryption_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EFSVolumeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EFSVolumeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EFSVolumeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_config: Optional['outputs.AuthorizationConfigResponse'] = None,
                 filesystem_id: Optional[str] = None,
                 root_directory: Optional[str] = None,
                 transit_encryption: Optional[str] = None,
                 transit_encryption_port: Optional[int] = None):
        """
        Definition of EFSVolumeConfiguration
        :param 'AuthorizationConfigResponse' authorization_config: The authorization configuration details for the Amazon EFS file system. The authorization configuration details for the Amazon EFS file system.
        :param str filesystem_id: The Amazon EFS file system ID to use.
        :param str root_directory: The directory within the Amazon EFS file system to mount as the root directory inside the host. If this parameter is omitted, the root of the Amazon EFS volume will be used. Specifying ``/`` will have the same effect as omitting this parameter.  If an EFS access point is specified in the ``authorizationConfig``, the root directory parameter must either be omitted or set to ``/`` which will enforce the path set on the EFS access point.
        :param str transit_encryption: Determines whether to use encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be turned on if Amazon EFS IAM authorization is used. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Encrypting data in transit](https://docs.aws.amazon.com/efs/latest/ug/encryption-in-transit.html) in the *Amazon Elastic File System User Guide*.
        :param int transit_encryption_port: The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server. If you do not specify a transit encryption port, it will use the port selection strategy that the Amazon EFS mount helper uses. For more information, see [EFS mount helper](https://docs.aws.amazon.com/efs/latest/ug/efs-mount-helper.html) in the *Amazon Elastic File System User Guide*.
        """
        if authorization_config is not None:
            pulumi.set(__self__, "authorization_config", authorization_config)
        if filesystem_id is not None:
            pulumi.set(__self__, "filesystem_id", filesystem_id)
        if root_directory is not None:
            pulumi.set(__self__, "root_directory", root_directory)
        if transit_encryption is not None:
            pulumi.set(__self__, "transit_encryption", transit_encryption)
        if transit_encryption_port is not None:
            pulumi.set(__self__, "transit_encryption_port", transit_encryption_port)

    @property
    @pulumi.getter(name="authorizationConfig")
    def authorization_config(self) -> Optional['outputs.AuthorizationConfigResponse']:
        """
        The authorization configuration details for the Amazon EFS file system. The authorization configuration details for the Amazon EFS file system.
        """
        return pulumi.get(self, "authorization_config")

    @property
    @pulumi.getter(name="filesystemId")
    def filesystem_id(self) -> Optional[str]:
        """
        The Amazon EFS file system ID to use.
        """
        return pulumi.get(self, "filesystem_id")

    @property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> Optional[str]:
        """
        The directory within the Amazon EFS file system to mount as the root directory inside the host. If this parameter is omitted, the root of the Amazon EFS volume will be used. Specifying ``/`` will have the same effect as omitting this parameter.  If an EFS access point is specified in the ``authorizationConfig``, the root directory parameter must either be omitted or set to ``/`` which will enforce the path set on the EFS access point.
        """
        return pulumi.get(self, "root_directory")

    @property
    @pulumi.getter(name="transitEncryption")
    def transit_encryption(self) -> Optional[str]:
        """
        Determines whether to use encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be turned on if Amazon EFS IAM authorization is used. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Encrypting data in transit](https://docs.aws.amazon.com/efs/latest/ug/encryption-in-transit.html) in the *Amazon Elastic File System User Guide*.
        """
        return pulumi.get(self, "transit_encryption")

    @property
    @pulumi.getter(name="transitEncryptionPort")
    def transit_encryption_port(self) -> Optional[int]:
        """
        The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server. If you do not specify a transit encryption port, it will use the port selection strategy that the Amazon EFS mount helper uses. For more information, see [EFS mount helper](https://docs.aws.amazon.com/efs/latest/ug/efs-mount-helper.html) in the *Amazon Elastic File System User Guide*.
        """
        return pulumi.get(self, "transit_encryption_port")


@pulumi.output_type
class EbsBlockDeviceResponse(dict):
    """
    Definition of EbsBlockDevice
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "outpostArn":
            suggest = "outpost_arn"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EbsBlockDeviceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EbsBlockDeviceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EbsBlockDeviceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 outpost_arn: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional['outputs.VolumeTypeEnumValueResponse'] = None):
        """
        Definition of EbsBlockDevice
        :param bool delete_on_termination: <p>Indicates whether the EBS volume is deleted on instance termination. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination'>Preserving Amazon EBS volumes on instance termination</a> in the <i>Amazon EC2 User Guide</i>.</p>
        :param bool encrypted: <p>Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to <code>true</code> depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see <a href='https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption.html#encryption-parameters'>Amazon EBS encryption</a> in the <i>Amazon EBS User Guide</i>.</p> <p>In no case can you remove encryption from an encrypted volume.</p> <p>Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see <a href='https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption-requirements.html#ebs-encryption_supported_instances'>Supported instance types</a>.</p> <p>This parameter is not returned by <a>DescribeImageAttribute</a>.</p> <p>For <a>CreateImage</a> and <a>RegisterImage</a>, whether you can include this parameter, and the allowed values differ depending on the type of block device mapping you are creating.</p> <ul> <li> <p>If you are creating a block device mapping for a <b>new (empty) volume</b>, you can include this parameter, and specify either <code>true</code> for an encrypted volume, or <code>false</code> for an unencrypted volume. If you omit this parameter, it defaults to <code>false</code> (unencrypted).</p> </li> <li> <p>If you are creating a block device mapping from an <b>existing encrypted or unencrypted snapshot</b>, you must omit this parameter. If you include this parameter, the request will fail, regardless of the value that you specify.</p> </li> <li> <p>If you are creating a block device mapping from an <b>existing unencrypted volume</b>, you can include this parameter, but you must specify <code>false</code>. If you specify <code>true</code>, the request will fail. In this case, we recommend that you omit the parameter.</p> </li> <li> <p>If you are creating a block device mapping from an <b>existing encrypted volume</b>, you can include this parameter, and specify either <code>true</code> or <code>false</code>. However, if you specify <code>false</code>, the parameter is ignored and the block device mapping is always encrypted. In this case, we recommend that you omit the parameter.</p> </li> </ul>
        :param int iops: <p>The number of I/O operations per second (IOPS). For <code>gp3</code>, <code>io1</code>, and <code>io2</code> volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.</p> <p>The following are the supported values for each volume type:</p> <ul> <li> <p> <code>gp3</code>: 3,000 - 16,000 IOPS</p> </li> <li> <p> <code>io1</code>: 100 - 64,000 IOPS</p> </li> <li> <p> <code>io2</code>: 100 - 256,000 IOPS</p> </li> </ul> <p>For <code>io2</code> volumes, you can achieve up to 256,000 IOPS on <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances'>instances built on the Nitro System</a>. On other instances, you can achieve performance up to 32,000 IOPS.</p> <p>This parameter is required for <code>io1</code> and <code>io2</code> volumes. The default for <code>gp3</code> volumes is 3,000 IOPS.</p>
        :param str kms_key_id: <p>Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.</p> <p>This parameter is only supported on <code>BlockDeviceMapping</code> objects called by <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html'>RunInstances</a>, <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html'>RequestSpotFleet</a>, and <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html'>RequestSpotInstances</a>.</p>
        :param str outpost_arn: <p>The ARN of the Outpost on which the snapshot is stored.</p> <p>This parameter is not supported when using <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateImage.html'>CreateImage</a>.</p>
        :param str snapshot_id: <p>The ID of the snapshot.</p>
        :param int throughput: <p>The throughput that the volume supports, in MiB/s.</p> <p>This parameter is valid only for <code>gp3</code> volumes.</p> <p>Valid Range: Minimum value of 125. Maximum value of 1000.</p>
        :param int volume_size: <p>The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.</p> <p>The following are the supported sizes for each volume type:</p> <ul> <li> <p> <code>gp2</code> and <code>gp3</code>: 1 - 16,384 GiB</p> </li> <li> <p> <code>io1</code>: 4 - 16,384 GiB</p> </li> <li> <p> <code>io2</code>: 4 - 65,536 GiB</p> </li> <li> <p> <code>st1</code> and <code>sc1</code>: 125 - 16,384 GiB</p> </li> <li> <p> <code>standard</code>: 1 - 1024 GiB</p> </li> </ul>
        :param 'VolumeTypeEnumValueResponse' volume_type: <p>The volume type. For more information, see <a href='https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html'>Amazon EBS volume types</a> in the <i>Amazon EBS User Guide</i>.</p>
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if outpost_arn is not None:
            pulumi.set(__self__, "outpost_arn", outpost_arn)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        <p>Indicates whether the EBS volume is deleted on instance termination. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination'>Preserving Amazon EBS volumes on instance termination</a> in the <i>Amazon EC2 User Guide</i>.</p>
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        <p>Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to <code>true</code> depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see <a href='https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption.html#encryption-parameters'>Amazon EBS encryption</a> in the <i>Amazon EBS User Guide</i>.</p> <p>In no case can you remove encryption from an encrypted volume.</p> <p>Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see <a href='https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption-requirements.html#ebs-encryption_supported_instances'>Supported instance types</a>.</p> <p>This parameter is not returned by <a>DescribeImageAttribute</a>.</p> <p>For <a>CreateImage</a> and <a>RegisterImage</a>, whether you can include this parameter, and the allowed values differ depending on the type of block device mapping you are creating.</p> <ul> <li> <p>If you are creating a block device mapping for a <b>new (empty) volume</b>, you can include this parameter, and specify either <code>true</code> for an encrypted volume, or <code>false</code> for an unencrypted volume. If you omit this parameter, it defaults to <code>false</code> (unencrypted).</p> </li> <li> <p>If you are creating a block device mapping from an <b>existing encrypted or unencrypted snapshot</b>, you must omit this parameter. If you include this parameter, the request will fail, regardless of the value that you specify.</p> </li> <li> <p>If you are creating a block device mapping from an <b>existing unencrypted volume</b>, you can include this parameter, but you must specify <code>false</code>. If you specify <code>true</code>, the request will fail. In this case, we recommend that you omit the parameter.</p> </li> <li> <p>If you are creating a block device mapping from an <b>existing encrypted volume</b>, you can include this parameter, and specify either <code>true</code> or <code>false</code>. However, if you specify <code>false</code>, the parameter is ignored and the block device mapping is always encrypted. In this case, we recommend that you omit the parameter.</p> </li> </ul>
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        <p>The number of I/O operations per second (IOPS). For <code>gp3</code>, <code>io1</code>, and <code>io2</code> volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.</p> <p>The following are the supported values for each volume type:</p> <ul> <li> <p> <code>gp3</code>: 3,000 - 16,000 IOPS</p> </li> <li> <p> <code>io1</code>: 100 - 64,000 IOPS</p> </li> <li> <p> <code>io2</code>: 100 - 256,000 IOPS</p> </li> </ul> <p>For <code>io2</code> volumes, you can achieve up to 256,000 IOPS on <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances'>instances built on the Nitro System</a>. On other instances, you can achieve performance up to 32,000 IOPS.</p> <p>This parameter is required for <code>io1</code> and <code>io2</code> volumes. The default for <code>gp3</code> volumes is 3,000 IOPS.</p>
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        <p>Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.</p> <p>This parameter is only supported on <code>BlockDeviceMapping</code> objects called by <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html'>RunInstances</a>, <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html'>RequestSpotFleet</a>, and <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html'>RequestSpotInstances</a>.</p>
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="outpostArn")
    def outpost_arn(self) -> Optional[str]:
        """
        <p>The ARN of the Outpost on which the snapshot is stored.</p> <p>This parameter is not supported when using <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateImage.html'>CreateImage</a>.</p>
        """
        return pulumi.get(self, "outpost_arn")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        <p>The ID of the snapshot.</p>
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        <p>The throughput that the volume supports, in MiB/s.</p> <p>This parameter is valid only for <code>gp3</code> volumes.</p> <p>Valid Range: Minimum value of 125. Maximum value of 1000.</p>
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        <p>The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.</p> <p>The following are the supported sizes for each volume type:</p> <ul> <li> <p> <code>gp2</code> and <code>gp3</code>: 1 - 16,384 GiB</p> </li> <li> <p> <code>io1</code>: 4 - 16,384 GiB</p> </li> <li> <p> <code>io2</code>: 4 - 65,536 GiB</p> </li> <li> <p> <code>st1</code> and <code>sc1</code>: 125 - 16,384 GiB</p> </li> <li> <p> <code>standard</code>: 1 - 1024 GiB</p> </li> </ul>
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional['outputs.VolumeTypeEnumValueResponse']:
        """
        <p>The volume type. For more information, see <a href='https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html'>Amazon EBS volume types</a> in the <i>Amazon EBS User Guide</i>.</p>
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class EbsInstanceBlockDeviceResponse(dict):
    """
    Definition of EbsInstanceBlockDevice
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedResource":
            suggest = "associated_resource"
        elif key == "attachTime":
            suggest = "attach_time"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeOwnerId":
            suggest = "volume_owner_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EbsInstanceBlockDeviceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EbsInstanceBlockDeviceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EbsInstanceBlockDeviceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_resource: Optional[str] = None,
                 attach_time: Optional[str] = None,
                 delete_on_termination: Optional[bool] = None,
                 status: Optional['outputs.AttachmentStatusEnumValueResponse'] = None,
                 volume_id: Optional[str] = None,
                 volume_owner_id: Optional[str] = None):
        """
        Definition of EbsInstanceBlockDevice
        :param str associated_resource: <p>The ARN of the Amazon ECS or Fargate task to which the volume is attached.</p>
        :param str attach_time: <p>The time stamp when the attachment initiated.</p>
        :param bool delete_on_termination: <p>Indicates whether the volume is deleted on instance termination.</p>
        :param 'AttachmentStatusEnumValueResponse' status: <p>The attachment state.</p>
        :param str volume_id: <p>The ID of the EBS volume.</p>
        :param str volume_owner_id: <p>The ID of the Amazon Web Services account that owns the volume.</p> <p>This parameter is returned only for volumes that are attached to Fargate tasks.</p>
        """
        if associated_resource is not None:
            pulumi.set(__self__, "associated_resource", associated_resource)
        if attach_time is not None:
            pulumi.set(__self__, "attach_time", attach_time)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_owner_id is not None:
            pulumi.set(__self__, "volume_owner_id", volume_owner_id)

    @property
    @pulumi.getter(name="associatedResource")
    def associated_resource(self) -> Optional[str]:
        """
        <p>The ARN of the Amazon ECS or Fargate task to which the volume is attached.</p>
        """
        return pulumi.get(self, "associated_resource")

    @property
    @pulumi.getter(name="attachTime")
    def attach_time(self) -> Optional[str]:
        """
        <p>The time stamp when the attachment initiated.</p>
        """
        return pulumi.get(self, "attach_time")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        <p>Indicates whether the volume is deleted on instance termination.</p>
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.AttachmentStatusEnumValueResponse']:
        """
        <p>The attachment state.</p>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        <p>The ID of the EBS volume.</p>
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeOwnerId")
    def volume_owner_id(self) -> Optional[str]:
        """
        <p>The ID of the Amazon Web Services account that owns the volume.</p> <p>This parameter is returned only for volumes that are attached to Fargate tasks.</p>
        """
        return pulumi.get(self, "volume_owner_id")


@pulumi.output_type
class Ec2AccountAttributePropertiesResponse(dict):
    """
    Definition of Ec2AccountAttribute
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2AccountAttributePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2AccountAttributePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2AccountAttributePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2AccountAttributePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2AccountAttribute
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2AccountAttributePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2AccountAttributePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2AddressPropertiesResponse(dict):
    """
    Definition of Ec2Address
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2AddressPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2AddressPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2AddressPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2AddressPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2Address
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2AddressPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2AddressPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2FlowLogPropertiesResponse(dict):
    """
    Definition of Ec2FlowLog
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FlowLogPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FlowLogPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FlowLogPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2FlowLogPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2FlowLog
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2FlowLogPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2FlowLogPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2ImagePropertiesResponse(dict):
    """
    Definition of Ec2Image
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2ImagePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2ImagePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2ImagePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2ImagePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2Image
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2ImagePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2ImagePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2InstanceAttributesResponse(dict):
    """
    Definition of Ec2InstanceAttributes
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalMasterSecurityGroups":
            suggest = "additional_master_security_groups"
        elif key == "additionalSlaveSecurityGroups":
            suggest = "additional_slave_security_groups"
        elif key == "ec2AvailabilityZone":
            suggest = "ec2_availability_zone"
        elif key == "ec2KeyName":
            suggest = "ec2_key_name"
        elif key == "ec2SubnetId":
            suggest = "ec2_subnet_id"
        elif key == "emrManagedMasterSecurityGroup":
            suggest = "emr_managed_master_security_group"
        elif key == "emrManagedSlaveSecurityGroup":
            suggest = "emr_managed_slave_security_group"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "requestedEc2AvailabilityZones":
            suggest = "requested_ec2_availability_zones"
        elif key == "requestedEc2SubnetIds":
            suggest = "requested_ec2_subnet_ids"
        elif key == "serviceAccessSecurityGroup":
            suggest = "service_access_security_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2InstanceAttributesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2InstanceAttributesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2InstanceAttributesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_master_security_groups: Optional[Sequence[str]] = None,
                 additional_slave_security_groups: Optional[Sequence[str]] = None,
                 ec2_availability_zone: Optional[str] = None,
                 ec2_key_name: Optional[str] = None,
                 ec2_subnet_id: Optional[str] = None,
                 emr_managed_master_security_group: Optional[str] = None,
                 emr_managed_slave_security_group: Optional[str] = None,
                 iam_instance_profile: Optional[str] = None,
                 requested_ec2_availability_zones: Optional[Sequence[str]] = None,
                 requested_ec2_subnet_ids: Optional[Sequence[str]] = None,
                 service_access_security_group: Optional[str] = None):
        """
        Definition of Ec2InstanceAttributes
        :param Sequence[str] additional_master_security_groups: <p>A list of additional Amazon EC2 security group IDs for the master node.</p>
        :param Sequence[str] additional_slave_security_groups: <p>A list of additional Amazon EC2 security group IDs for the core and task nodes.</p>
        :param str ec2_availability_zone: <p>The Availability Zone in which the cluster will run. </p>
        :param str ec2_key_name: <p>The name of the Amazon EC2 key pair to use when connecting with SSH into the master node as a user named 'hadoop'.</p>
        :param str ec2_subnet_id: <p>Set this parameter to the identifier of the Amazon VPC subnet where you want the cluster to launch. If you do not specify this value, and your account supports EC2-Classic, the cluster launches in EC2-Classic.</p>
        :param str emr_managed_master_security_group: <p>The identifier of the Amazon EC2 security group for the master node.</p>
        :param str emr_managed_slave_security_group: <p>The identifier of the Amazon EC2 security group for the core and task nodes.</p>
        :param str iam_instance_profile: <p>The IAM role that was specified when the cluster was launched. The Amazon EC2 instances of the cluster assume this role.</p>
        :param Sequence[str] requested_ec2_availability_zones: <p>Applies to clusters configured with the instance fleets option. Specifies one or more Availability Zones in which to launch Amazon EC2 cluster instances when the EC2-Classic network configuration is supported. Amazon EMR chooses the Availability Zone with the best fit from among the list of <code>RequestedEc2AvailabilityZones</code>, and then launches all cluster instances within that Availability Zone. If you do not specify this value, Amazon EMR chooses the Availability Zone for you. <code>RequestedEc2SubnetIDs</code> and <code>RequestedEc2AvailabilityZones</code> cannot be specified together.</p>
        :param Sequence[str] requested_ec2_subnet_ids: <p>Applies to clusters configured with the instance fleets option. Specifies the unique identifier of one or more Amazon EC2 subnets in which to launch Amazon EC2 cluster instances. Subnets must exist within the same VPC. Amazon EMR chooses the Amazon EC2 subnet with the best fit from among the list of <code>RequestedEc2SubnetIds</code>, and then launches all cluster instances within that Subnet. If this value is not specified, and the account and Region support EC2-Classic networks, the cluster launches instances in the EC2-Classic network and uses <code>RequestedEc2AvailabilityZones</code> instead of this setting. If EC2-Classic is not supported, and no Subnet is specified, Amazon EMR chooses the subnet for you. <code>RequestedEc2SubnetIDs</code> and <code>RequestedEc2AvailabilityZones</code> cannot be specified together.</p>
        :param str service_access_security_group: <p>The identifier of the Amazon EC2 security group for the Amazon EMR service to access clusters in VPC private subnets.</p>
        """
        if additional_master_security_groups is not None:
            pulumi.set(__self__, "additional_master_security_groups", additional_master_security_groups)
        if additional_slave_security_groups is not None:
            pulumi.set(__self__, "additional_slave_security_groups", additional_slave_security_groups)
        if ec2_availability_zone is not None:
            pulumi.set(__self__, "ec2_availability_zone", ec2_availability_zone)
        if ec2_key_name is not None:
            pulumi.set(__self__, "ec2_key_name", ec2_key_name)
        if ec2_subnet_id is not None:
            pulumi.set(__self__, "ec2_subnet_id", ec2_subnet_id)
        if emr_managed_master_security_group is not None:
            pulumi.set(__self__, "emr_managed_master_security_group", emr_managed_master_security_group)
        if emr_managed_slave_security_group is not None:
            pulumi.set(__self__, "emr_managed_slave_security_group", emr_managed_slave_security_group)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if requested_ec2_availability_zones is not None:
            pulumi.set(__self__, "requested_ec2_availability_zones", requested_ec2_availability_zones)
        if requested_ec2_subnet_ids is not None:
            pulumi.set(__self__, "requested_ec2_subnet_ids", requested_ec2_subnet_ids)
        if service_access_security_group is not None:
            pulumi.set(__self__, "service_access_security_group", service_access_security_group)

    @property
    @pulumi.getter(name="additionalMasterSecurityGroups")
    def additional_master_security_groups(self) -> Optional[Sequence[str]]:
        """
        <p>A list of additional Amazon EC2 security group IDs for the master node.</p>
        """
        return pulumi.get(self, "additional_master_security_groups")

    @property
    @pulumi.getter(name="additionalSlaveSecurityGroups")
    def additional_slave_security_groups(self) -> Optional[Sequence[str]]:
        """
        <p>A list of additional Amazon EC2 security group IDs for the core and task nodes.</p>
        """
        return pulumi.get(self, "additional_slave_security_groups")

    @property
    @pulumi.getter(name="ec2AvailabilityZone")
    def ec2_availability_zone(self) -> Optional[str]:
        """
        <p>The Availability Zone in which the cluster will run. </p>
        """
        return pulumi.get(self, "ec2_availability_zone")

    @property
    @pulumi.getter(name="ec2KeyName")
    def ec2_key_name(self) -> Optional[str]:
        """
        <p>The name of the Amazon EC2 key pair to use when connecting with SSH into the master node as a user named 'hadoop'.</p>
        """
        return pulumi.get(self, "ec2_key_name")

    @property
    @pulumi.getter(name="ec2SubnetId")
    def ec2_subnet_id(self) -> Optional[str]:
        """
        <p>Set this parameter to the identifier of the Amazon VPC subnet where you want the cluster to launch. If you do not specify this value, and your account supports EC2-Classic, the cluster launches in EC2-Classic.</p>
        """
        return pulumi.get(self, "ec2_subnet_id")

    @property
    @pulumi.getter(name="emrManagedMasterSecurityGroup")
    def emr_managed_master_security_group(self) -> Optional[str]:
        """
        <p>The identifier of the Amazon EC2 security group for the master node.</p>
        """
        return pulumi.get(self, "emr_managed_master_security_group")

    @property
    @pulumi.getter(name="emrManagedSlaveSecurityGroup")
    def emr_managed_slave_security_group(self) -> Optional[str]:
        """
        <p>The identifier of the Amazon EC2 security group for the core and task nodes.</p>
        """
        return pulumi.get(self, "emr_managed_slave_security_group")

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[str]:
        """
        <p>The IAM role that was specified when the cluster was launched. The Amazon EC2 instances of the cluster assume this role.</p>
        """
        return pulumi.get(self, "iam_instance_profile")

    @property
    @pulumi.getter(name="requestedEc2AvailabilityZones")
    def requested_ec2_availability_zones(self) -> Optional[Sequence[str]]:
        """
        <p>Applies to clusters configured with the instance fleets option. Specifies one or more Availability Zones in which to launch Amazon EC2 cluster instances when the EC2-Classic network configuration is supported. Amazon EMR chooses the Availability Zone with the best fit from among the list of <code>RequestedEc2AvailabilityZones</code>, and then launches all cluster instances within that Availability Zone. If you do not specify this value, Amazon EMR chooses the Availability Zone for you. <code>RequestedEc2SubnetIDs</code> and <code>RequestedEc2AvailabilityZones</code> cannot be specified together.</p>
        """
        return pulumi.get(self, "requested_ec2_availability_zones")

    @property
    @pulumi.getter(name="requestedEc2SubnetIds")
    def requested_ec2_subnet_ids(self) -> Optional[Sequence[str]]:
        """
        <p>Applies to clusters configured with the instance fleets option. Specifies the unique identifier of one or more Amazon EC2 subnets in which to launch Amazon EC2 cluster instances. Subnets must exist within the same VPC. Amazon EMR chooses the Amazon EC2 subnet with the best fit from among the list of <code>RequestedEc2SubnetIds</code>, and then launches all cluster instances within that Subnet. If this value is not specified, and the account and Region support EC2-Classic networks, the cluster launches instances in the EC2-Classic network and uses <code>RequestedEc2AvailabilityZones</code> instead of this setting. If EC2-Classic is not supported, and no Subnet is specified, Amazon EMR chooses the subnet for you. <code>RequestedEc2SubnetIDs</code> and <code>RequestedEc2AvailabilityZones</code> cannot be specified together.</p>
        """
        return pulumi.get(self, "requested_ec2_subnet_ids")

    @property
    @pulumi.getter(name="serviceAccessSecurityGroup")
    def service_access_security_group(self) -> Optional[str]:
        """
        <p>The identifier of the Amazon EC2 security group for the Amazon EMR service to access clusters in VPC private subnets.</p>
        """
        return pulumi.get(self, "service_access_security_group")


@pulumi.output_type
class Ec2InstancePropertiesResponse(dict):
    """
    Definition of Ec2Instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2InstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2InstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2InstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2InstancePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2Instance
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2InstancePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2InstancePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2InstanceStatusPropertiesResponse(dict):
    """
    Definition of Ec2InstanceStatus
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2InstanceStatusPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2InstanceStatusPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2InstanceStatusPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2InstanceStatusPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2InstanceStatus
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2InstanceStatusPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2InstanceStatusPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2IpamPropertiesResponse(dict):
    """
    Definition of Ec2Ipam
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2IpamPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2IpamPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2IpamPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2IpamPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2Ipam
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2IpamPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2IpamPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2KeyPairPropertiesResponse(dict):
    """
    Definition of Ec2KeyPair
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2KeyPairPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2KeyPairPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2KeyPairPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2KeyPairPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2KeyPair
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2KeyPairPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2KeyPairPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2NetworkAclPropertiesResponse(dict):
    """
    Definition of Ec2NetworkAcl
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2NetworkAclPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2NetworkAclPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2NetworkAclPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2NetworkAclPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2NetworkAcl
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2NetworkAclPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2NetworkAclPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2NetworkInterfacePropertiesResponse(dict):
    """
    Definition of Ec2NetworkInterface
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2NetworkInterfacePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2NetworkInterfacePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2NetworkInterfacePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2NetworkInterfacePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2NetworkInterface
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2NetworkInterfacePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2NetworkInterfacePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2RouteTablePropertiesResponse(dict):
    """
    Definition of Ec2RouteTable
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2RouteTablePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2RouteTablePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2RouteTablePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2RouteTablePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2RouteTable
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2RouteTablePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2RouteTablePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2SecurityGroupPropertiesResponse(dict):
    """
    Definition of Ec2SecurityGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2SecurityGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2SecurityGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2SecurityGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2SecurityGroupPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2SecurityGroup
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2SecurityGroupPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2SecurityGroupPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2SnapshotPropertiesResponse(dict):
    """
    Definition of Ec2Snapshot
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2SnapshotPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2SnapshotPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2SnapshotPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2SnapshotPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2Snapshot
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2SnapshotPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2SnapshotPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2SubnetPropertiesResponse(dict):
    """
    Definition of Ec2Subnet
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2SubnetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2SubnetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2SubnetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2SubnetPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2Subnet
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2SubnetPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2SubnetPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2VPCEndpointPropertiesResponse(dict):
    """
    Definition of Ec2VPCEndpoint
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2VPCEndpointPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2VPCEndpointPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2VPCEndpointPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2VPCEndpointPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2VPCEndpoint
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2VPCEndpointPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2VPCEndpointPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2VPCPeeringConnectionPropertiesResponse(dict):
    """
    Definition of Ec2VPCPeeringConnection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2VPCPeeringConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2VPCPeeringConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2VPCPeeringConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2VPCPeeringConnectionPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2VPCPeeringConnection
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2VPCPeeringConnectionPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2VPCPeeringConnectionPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2VolumePropertiesResponse(dict):
    """
    Definition of Ec2Volume
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2VolumePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2VolumePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2VolumePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2VolumePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2Volume
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2VolumePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2VolumePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Ec2VpcPropertiesResponse(dict):
    """
    Definition of Ec2Vpc
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2VpcPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2VpcPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2VpcPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEc2VpcPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Ec2Vpc
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEc2VpcPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEc2VpcPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EcrImageDetailPropertiesResponse(dict):
    """
    Definition of EcrImageDetail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcrImageDetailPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcrImageDetailPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcrImageDetailPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEcrImageDetailPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EcrImageDetail
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEcrImageDetailPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEcrImageDetailPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EcrRepositoryPropertiesResponse(dict):
    """
    Definition of EcrRepository
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcrRepositoryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcrRepositoryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcrRepositoryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEcrRepositoryPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EcrRepository
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEcrRepositoryPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEcrRepositoryPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EcsClusterPropertiesResponse(dict):
    """
    Definition of EcsCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEcsClusterPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EcsCluster
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEcsClusterPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEcsClusterPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EcsServicePropertiesResponse(dict):
    """
    Definition of EcsService
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsServicePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsServicePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsServicePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEcsServicePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EcsService
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEcsServicePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEcsServicePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EcsTaskDefinitionPropertiesResponse(dict):
    """
    Definition of EcsTaskDefinition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsTaskDefinitionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsTaskDefinitionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsTaskDefinitionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEcsTaskDefinitionPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EcsTaskDefinition
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEcsTaskDefinitionPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEcsTaskDefinitionPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EfsFileSystemPropertiesResponse(dict):
    """
    Definition of EfsFileSystem
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EfsFileSystemPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EfsFileSystemPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EfsFileSystemPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEfsFileSystemPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EfsFileSystem
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEfsFileSystemPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEfsFileSystemPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EfsMountTargetPropertiesResponse(dict):
    """
    Definition of EfsMountTarget
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EfsMountTargetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EfsMountTargetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EfsMountTargetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEfsMountTargetPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EfsMountTarget
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEfsMountTargetPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEfsMountTargetPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EksClusterPropertiesResponse(dict):
    """
    Definition of EksCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EksClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EksClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EksClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEksClusterPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EksCluster
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEksClusterPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEksClusterPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EksNodegroupPropertiesResponse(dict):
    """
    Definition of EksNodegroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EksNodegroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EksNodegroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EksNodegroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEksNodegroupPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EksNodegroup
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEksNodegroupPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEksNodegroupPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ElasticBeanstalkApplicationPropertiesResponse(dict):
    """
    Definition of ElasticBeanstalkApplication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticBeanstalkApplicationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticBeanstalkApplicationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticBeanstalkApplicationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsElasticBeanstalkApplicationPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ElasticBeanstalkApplication
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsElasticBeanstalkApplicationPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsElasticBeanstalkApplicationPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ElasticBeanstalkConfigurationTemplatePropertiesResponse(dict):
    """
    Definition of ElasticBeanstalkConfigurationTemplate
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticBeanstalkConfigurationTemplatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticBeanstalkConfigurationTemplatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticBeanstalkConfigurationTemplatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsElasticBeanstalkConfigurationTemplatePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ElasticBeanstalkConfigurationTemplate
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsElasticBeanstalkConfigurationTemplatePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsElasticBeanstalkConfigurationTemplatePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ElasticBeanstalkEnvironmentPropertiesResponse(dict):
    """
    Definition of ElasticBeanstalkEnvironment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticBeanstalkEnvironmentPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticBeanstalkEnvironmentPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticBeanstalkEnvironmentPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsElasticBeanstalkEnvironmentPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ElasticBeanstalkEnvironment
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsElasticBeanstalkEnvironmentPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsElasticBeanstalkEnvironmentPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ElasticFileSystemTagResponse(dict):
    """
    Definition of ElasticFileSystemTag
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of ElasticFileSystemTag
        :param str key: The tag key (String). The key can't start with ``aws:``.
        :param str value: The value of the tag key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The tag key (String). The key can't start with ``aws:``.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ElasticGpuAssociationResponse(dict):
    """
    Definition of ElasticGpuAssociation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticGpuAssociationId":
            suggest = "elastic_gpu_association_id"
        elif key == "elasticGpuAssociationState":
            suggest = "elastic_gpu_association_state"
        elif key == "elasticGpuAssociationTime":
            suggest = "elastic_gpu_association_time"
        elif key == "elasticGpuId":
            suggest = "elastic_gpu_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticGpuAssociationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticGpuAssociationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticGpuAssociationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elastic_gpu_association_id: Optional[str] = None,
                 elastic_gpu_association_state: Optional[str] = None,
                 elastic_gpu_association_time: Optional[str] = None,
                 elastic_gpu_id: Optional[str] = None):
        """
        Definition of ElasticGpuAssociation
        :param str elastic_gpu_association_id: <p>The ID of the association.</p>
        :param str elastic_gpu_association_state: <p>The state of the association between the instance and the Elastic Graphics accelerator.</p>
        :param str elastic_gpu_association_time: <p>The time the Elastic Graphics accelerator was associated with the instance.</p>
        :param str elastic_gpu_id: <p>The ID of the Elastic Graphics accelerator.</p>
        """
        if elastic_gpu_association_id is not None:
            pulumi.set(__self__, "elastic_gpu_association_id", elastic_gpu_association_id)
        if elastic_gpu_association_state is not None:
            pulumi.set(__self__, "elastic_gpu_association_state", elastic_gpu_association_state)
        if elastic_gpu_association_time is not None:
            pulumi.set(__self__, "elastic_gpu_association_time", elastic_gpu_association_time)
        if elastic_gpu_id is not None:
            pulumi.set(__self__, "elastic_gpu_id", elastic_gpu_id)

    @property
    @pulumi.getter(name="elasticGpuAssociationId")
    def elastic_gpu_association_id(self) -> Optional[str]:
        """
        <p>The ID of the association.</p>
        """
        return pulumi.get(self, "elastic_gpu_association_id")

    @property
    @pulumi.getter(name="elasticGpuAssociationState")
    def elastic_gpu_association_state(self) -> Optional[str]:
        """
        <p>The state of the association between the instance and the Elastic Graphics accelerator.</p>
        """
        return pulumi.get(self, "elastic_gpu_association_state")

    @property
    @pulumi.getter(name="elasticGpuAssociationTime")
    def elastic_gpu_association_time(self) -> Optional[str]:
        """
        <p>The time the Elastic Graphics accelerator was associated with the instance.</p>
        """
        return pulumi.get(self, "elastic_gpu_association_time")

    @property
    @pulumi.getter(name="elasticGpuId")
    def elastic_gpu_id(self) -> Optional[str]:
        """
        <p>The ID of the Elastic Graphics accelerator.</p>
        """
        return pulumi.get(self, "elastic_gpu_id")


@pulumi.output_type
class ElasticInferenceAcceleratorAssociationResponse(dict):
    """
    Definition of ElasticInferenceAcceleratorAssociation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticInferenceAcceleratorArn":
            suggest = "elastic_inference_accelerator_arn"
        elif key == "elasticInferenceAcceleratorAssociationId":
            suggest = "elastic_inference_accelerator_association_id"
        elif key == "elasticInferenceAcceleratorAssociationState":
            suggest = "elastic_inference_accelerator_association_state"
        elif key == "elasticInferenceAcceleratorAssociationTime":
            suggest = "elastic_inference_accelerator_association_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticInferenceAcceleratorAssociationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticInferenceAcceleratorAssociationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticInferenceAcceleratorAssociationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elastic_inference_accelerator_arn: Optional[str] = None,
                 elastic_inference_accelerator_association_id: Optional[str] = None,
                 elastic_inference_accelerator_association_state: Optional[str] = None,
                 elastic_inference_accelerator_association_time: Optional[str] = None):
        """
        Definition of ElasticInferenceAcceleratorAssociation
        :param str elastic_inference_accelerator_arn: <p> The Amazon Resource Name (ARN) of the elastic inference accelerator. </p>
        :param str elastic_inference_accelerator_association_id: <p> The ID of the association. </p>
        :param str elastic_inference_accelerator_association_state: <p> The state of the elastic inference accelerator. </p>
        :param str elastic_inference_accelerator_association_time: <p> The time at which the elastic inference accelerator is associated with an instance. </p>
        """
        if elastic_inference_accelerator_arn is not None:
            pulumi.set(__self__, "elastic_inference_accelerator_arn", elastic_inference_accelerator_arn)
        if elastic_inference_accelerator_association_id is not None:
            pulumi.set(__self__, "elastic_inference_accelerator_association_id", elastic_inference_accelerator_association_id)
        if elastic_inference_accelerator_association_state is not None:
            pulumi.set(__self__, "elastic_inference_accelerator_association_state", elastic_inference_accelerator_association_state)
        if elastic_inference_accelerator_association_time is not None:
            pulumi.set(__self__, "elastic_inference_accelerator_association_time", elastic_inference_accelerator_association_time)

    @property
    @pulumi.getter(name="elasticInferenceAcceleratorArn")
    def elastic_inference_accelerator_arn(self) -> Optional[str]:
        """
        <p> The Amazon Resource Name (ARN) of the elastic inference accelerator. </p>
        """
        return pulumi.get(self, "elastic_inference_accelerator_arn")

    @property
    @pulumi.getter(name="elasticInferenceAcceleratorAssociationId")
    def elastic_inference_accelerator_association_id(self) -> Optional[str]:
        """
        <p> The ID of the association. </p>
        """
        return pulumi.get(self, "elastic_inference_accelerator_association_id")

    @property
    @pulumi.getter(name="elasticInferenceAcceleratorAssociationState")
    def elastic_inference_accelerator_association_state(self) -> Optional[str]:
        """
        <p> The state of the elastic inference accelerator. </p>
        """
        return pulumi.get(self, "elastic_inference_accelerator_association_state")

    @property
    @pulumi.getter(name="elasticInferenceAcceleratorAssociationTime")
    def elastic_inference_accelerator_association_time(self) -> Optional[str]:
        """
        <p> The time at which the elastic inference accelerator is associated with an instance. </p>
        """
        return pulumi.get(self, "elastic_inference_accelerator_association_time")


@pulumi.output_type
class ElasticLoadBalancingV2ListenerPropertiesResponse(dict):
    """
    Definition of ElasticLoadBalancingV2Listener
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticLoadBalancingV2ListenerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticLoadBalancingV2ListenerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticLoadBalancingV2ListenerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsElasticLoadBalancingV2ListenerPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ElasticLoadBalancingV2Listener
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsElasticLoadBalancingV2ListenerPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsElasticLoadBalancingV2ListenerPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ElasticLoadBalancingV2LoadBalancerPropertiesResponse(dict):
    """
    Definition of ElasticLoadBalancingV2LoadBalancer
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticLoadBalancingV2LoadBalancerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticLoadBalancingV2LoadBalancerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticLoadBalancingV2LoadBalancerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsElasticLoadBalancingV2LoadBalancerPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ElasticLoadBalancingV2LoadBalancer
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsElasticLoadBalancingV2LoadBalancerPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsElasticLoadBalancingV2LoadBalancerPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ElasticLoadBalancingV2TargetGroupPropertiesResponse(dict):
    """
    Definition of ElasticLoadBalancingV2TargetGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticLoadBalancingV2TargetGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticLoadBalancingV2TargetGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticLoadBalancingV2TargetGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsElasticLoadBalancingV2TargetGroupPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ElasticLoadBalancingV2TargetGroup
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsElasticLoadBalancingV2TargetGroupPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsElasticLoadBalancingV2TargetGroupPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse(dict):
    """
    Definition of ElasticLoadBalancingv2TargetHealthDescription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of ElasticLoadBalancingv2TargetHealthDescription
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsElasticLoadBalancingv2TargetHealthDescriptionPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EmrClusterPropertiesResponse(dict):
    """
    Definition of EmrCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmrClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmrClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmrClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEmrClusterPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EmrCluster
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEmrClusterPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEmrClusterPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EmrClusterStatusResponse(dict):
    """
    Definition of ClusterStatus
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDetails":
            suggest = "error_details"
        elif key == "stateChangeReason":
            suggest = "state_change_reason"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmrClusterStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmrClusterStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmrClusterStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_details: Optional[Sequence['outputs.ErrorDetailResponse']] = None,
                 state: Optional['outputs.ClusterStateEnumValueResponse'] = None,
                 state_change_reason: Optional['outputs.ClusterStateChangeReasonResponse'] = None,
                 timeline: Optional['outputs.ClusterTimelineResponse'] = None):
        """
        Definition of ClusterStatus
        :param Sequence['ErrorDetailResponse'] error_details: <p>A list of tuples that provides information about the errors that caused a cluster to terminate. This structure can contain up to 10 different <code>ErrorDetail</code> tuples.</p>
        :param 'ClusterStateEnumValueResponse' state: <p>The current state of the cluster.</p>
        :param 'ClusterStateChangeReasonResponse' state_change_reason: <p>The reason for the cluster status change.</p>
        :param 'ClusterTimelineResponse' timeline: <p>A timeline that represents the status of a cluster over the lifetime of the cluster.</p>
        """
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_change_reason is not None:
            pulumi.set(__self__, "state_change_reason", state_change_reason)
        if timeline is not None:
            pulumi.set(__self__, "timeline", timeline)

    @property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional[Sequence['outputs.ErrorDetailResponse']]:
        """
        <p>A list of tuples that provides information about the errors that caused a cluster to terminate. This structure can contain up to 10 different <code>ErrorDetail</code> tuples.</p>
        """
        return pulumi.get(self, "error_details")

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.ClusterStateEnumValueResponse']:
        """
        <p>The current state of the cluster.</p>
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateChangeReason")
    def state_change_reason(self) -> Optional['outputs.ClusterStateChangeReasonResponse']:
        """
        <p>The reason for the cluster status change.</p>
        """
        return pulumi.get(self, "state_change_reason")

    @property
    @pulumi.getter
    def timeline(self) -> Optional['outputs.ClusterTimelineResponse']:
        """
        <p>A timeline that represents the status of a cluster over the lifetime of the cluster.</p>
        """
        return pulumi.get(self, "timeline")


@pulumi.output_type
class EmrClusterSummaryPropertiesResponse(dict):
    """
    Definition of EmrClusterSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EmrClusterSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EmrClusterSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EmrClusterSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsEmrClusterSummaryPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of EmrClusterSummary
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsEmrClusterSummaryPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsEmrClusterSummaryPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class EnclaveOptionsResponse(dict):
    """
    Definition of EnclaveOptions
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Definition of EnclaveOptions
        :param bool enabled: <p>If this parameter is set to <code>true</code>, the instance is enabled for Amazon Web Services Nitro Enclaves; otherwise, it is not enabled for Amazon Web Services Nitro Enclaves.</p>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>If this parameter is set to <code>true</code>, the instance is enabled for Amazon Web Services Nitro Enclaves; otherwise, it is not enabled for Amazon Web Services Nitro Enclaves.</p>
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class EncryptionAtRestOptionsResponse(dict):
    """
    Definition of EncryptionAtRestOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 kms_key_id: Optional[str] = None):
        """
        Definition of EncryptionAtRestOptions
        :param bool enabled: <p>True to enable encryption at rest.</p>
        :param str kms_key_id: <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>True to enable encryption at rest.</p>
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        <p>The KMS key ID. Takes the form <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.</p>
        """
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class EncryptionConfigResponse(dict):
    """
    Definition of EncryptionConfig
    """
    def __init__(__self__, *,
                 provider: Optional['outputs.ProviderResponse'] = None,
                 resources: Optional[Sequence[str]] = None):
        """
        Definition of EncryptionConfig
        :param 'ProviderResponse' provider: <p>Key Management Service (KMS) key. Either the ARN or the alias can be used.</p>
        :param Sequence[str] resources: <p>Specifies the resources to be encrypted. The only supported value is <code>secrets</code>.</p>
        """
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def provider(self) -> Optional['outputs.ProviderResponse']:
        """
        <p>Key Management Service (KMS) key. Either the ARN or the alias can be used.</p>
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[str]]:
        """
        <p>Specifies the resources to be encrypted. The only supported value is <code>secrets</code>.</p>
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class EncryptionConfigurationResponse(dict):
    """
    Definition of EncryptionConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"
        elif key == "replicaKmsKeyID":
            suggest = "replica_kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_type: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 replica_kms_key_id: Optional[str] = None):
        """
        Definition of EncryptionConfiguration
        :param str encryption_type: The encryption type to use. If you use the ``KMS`` encryption type, the contents of the repository will be encrypted using server-side encryption with KMSlong key stored in KMS. When you use KMS to encrypt your data, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you already created. For more information, see [Protecting data using server-side encryption with an key stored in (SSE-KMS)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html) in the *Amazon Simple Storage Service Console Developer Guide*. If you use the ``AES256`` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES-256 encryption algorithm. For more information, see [Protecting data using server-side encryption with Amazon S3-managed encryption keys (SSE-S3)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html) in the *Ama The encryption type to use.
        :param str kms_key: If you use the ``KMS`` encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used. If you use the KMS encryption type, specify the CMK to use for encryption. The alias, key ID, or full ARN of the CMK can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed CMK for Amazon ECR will be used.
        :param str replica_kms_key_id: Specifies the ID (Key ARN or Alias ARN) of the customer managed AWS KMS key stored in AWS Key Management Service (KMS) for the destination bucket. Amazon S3 uses this key to encrypt replica objects. Amazon S3 only supports symmetric encryption KMS keys. For more information, see [Asymmetric keys in KMS](https://docs.aws.amazon.com//kms/latest/developerguide/symmetric-asymmetric.html) in the *Key Management Service Developer Guide*.
        """
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if replica_kms_key_id is not None:
            pulumi.set(__self__, "replica_kms_key_id", replica_kms_key_id)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        """
        The encryption type to use. If you use the ``KMS`` encryption type, the contents of the repository will be encrypted using server-side encryption with KMSlong key stored in KMS. When you use KMS to encrypt your data, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you already created. For more information, see [Protecting data using server-side encryption with an key stored in (SSE-KMS)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html) in the *Amazon Simple Storage Service Console Developer Guide*. If you use the ``AES256`` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES-256 encryption algorithm. For more information, see [Protecting data using server-side encryption with Amazon S3-managed encryption keys (SSE-S3)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html) in the *Ama The encryption type to use.
        """
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        """
        If you use the ``KMS`` encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used. If you use the KMS encryption type, specify the CMK to use for encryption. The alias, key ID, or full ARN of the CMK can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed CMK for Amazon ECR will be used.
        """
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter(name="replicaKmsKeyID")
    def replica_kms_key_id(self) -> Optional[str]:
        """
        Specifies the ID (Key ARN or Alias ARN) of the customer managed AWS KMS key stored in AWS Key Management Service (KMS) for the destination bucket. Amazon S3 uses this key to encrypt replica objects. Amazon S3 only supports symmetric encryption KMS keys. For more information, see [Asymmetric keys in KMS](https://docs.aws.amazon.com//kms/latest/developerguide/symmetric-asymmetric.html) in the *Key Management Service Developer Guide*.
        """
        return pulumi.get(self, "replica_kms_key_id")


@pulumi.output_type
class EndpointConfigurationResponse(dict):
    """
    Definition of EndpointConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcEndpointIds":
            suggest = "vpc_endpoint_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EndpointConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EndpointConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EndpointConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 types: Optional[Sequence[str]] = None,
                 vpc_endpoint_ids: Optional[Sequence[str]] = None):
        """
        Definition of EndpointConfiguration
        :param Sequence[str] types: A list of endpoint types of an API (RestApi) or its custom domain name (DomainName). For an edge-optimized API and its custom domain name, the endpoint type is ``'EDGE'``. For a regional API and its custom domain name, the endpoint type is ``REGIONAL``. For a private API, the endpoint type is ``PRIVATE``.
        :param Sequence[str] vpc_endpoint_ids: A list of VpcEndpointIds of an API (RestApi) against which to create Route53 ALIASes. It is only supported for ``PRIVATE`` endpoint type.
        """
        if types is not None:
            pulumi.set(__self__, "types", types)
        if vpc_endpoint_ids is not None:
            pulumi.set(__self__, "vpc_endpoint_ids", vpc_endpoint_ids)

    @property
    @pulumi.getter
    def types(self) -> Optional[Sequence[str]]:
        """
        A list of endpoint types of an API (RestApi) or its custom domain name (DomainName). For an edge-optimized API and its custom domain name, the endpoint type is ``'EDGE'``. For a regional API and its custom domain name, the endpoint type is ``REGIONAL``. For a private API, the endpoint type is ``PRIVATE``.
        """
        return pulumi.get(self, "types")

    @property
    @pulumi.getter(name="vpcEndpointIds")
    def vpc_endpoint_ids(self) -> Optional[Sequence[str]]:
        """
        A list of VpcEndpointIds of an API (RestApi) against which to create Route53 ALIASes. It is only supported for ``PRIVATE`` endpoint type.
        """
        return pulumi.get(self, "vpc_endpoint_ids")


@pulumi.output_type
class EnhancedMetricsConfigResponse(dict):
    """
    Definition of EnhancedMetricsConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSourceLevelMetricsBehavior":
            suggest = "data_source_level_metrics_behavior"
        elif key == "operationLevelMetricsConfig":
            suggest = "operation_level_metrics_config"
        elif key == "resolverLevelMetricsBehavior":
            suggest = "resolver_level_metrics_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnhancedMetricsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnhancedMetricsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnhancedMetricsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source_level_metrics_behavior: Optional['outputs.DataSourceLevelMetricsBehaviorEnumValueResponse'] = None,
                 operation_level_metrics_config: Optional['outputs.OperationLevelMetricsConfigEnumValueResponse'] = None,
                 resolver_level_metrics_behavior: Optional['outputs.ResolverLevelMetricsBehaviorEnumValueResponse'] = None):
        """
        Definition of EnhancedMetricsConfig
        :param 'DataSourceLevelMetricsBehaviorEnumValueResponse' data_source_level_metrics_behavior: <p>Controls how data source metrics will be emitted to CloudWatch. Data source metrics include:</p> <ul> <li> <p>Requests: The number of invocations that occured during a request.</p> </li> <li> <p>Latency: The time to complete a data source invocation.</p> </li> <li> <p>Errors: The number of errors that occurred during a data source invocation.</p> </li> </ul> <p>These metrics can be emitted to CloudWatch per data source or for all data sources in the request. Metrics will be recorded by API ID and data source name. <code>dataSourceLevelMetricsBehavior</code> accepts one of these values at a time:</p> <ul> <li> <p> <code>FULL_REQUEST_DATA_SOURCE_METRICS</code>: Records and emits metric data for all data sources in the request.</p> </li> <li> <p> <code>PER_DATA_SOURCE_METRICS</code>: Records and emits metric data for data sources that have the <code>metricsConfig</code> value set to <code>ENABLED</code>.</p> </li> </ul>
        :param 'OperationLevelMetricsConfigEnumValueResponse' operation_level_metrics_config: <p> Controls how operation metrics will be emitted to CloudWatch. Operation metrics include:</p> <ul> <li> <p>Requests: The number of times a specified GraphQL operation was called.</p> </li> <li> <p>GraphQL errors: The number of GraphQL errors that occurred during a specified GraphQL operation.</p> </li> </ul> <p>Metrics will be recorded by API ID and operation name. You can set the value to <code>ENABLED</code> or <code>DISABLED</code>.</p>
        :param 'ResolverLevelMetricsBehaviorEnumValueResponse' resolver_level_metrics_behavior: <p>Controls how resolver metrics will be emitted to CloudWatch. Resolver metrics include:</p> <ul> <li> <p>GraphQL errors: The number of GraphQL errors that occurred.</p> </li> <li> <p>Requests: The number of invocations that occurred during a request. </p> </li> <li> <p>Latency: The time to complete a resolver invocation.</p> </li> <li> <p>Cache hits: The number of cache hits during a request.</p> </li> <li> <p>Cache misses: The number of cache misses during a request.</p> </li> </ul> <p>These metrics can be emitted to CloudWatch per resolver or for all resolvers in the request. Metrics will be recorded by API ID and resolver name. <code>resolverLevelMetricsBehavior</code> accepts one of these values at a time:</p> <ul> <li> <p> <code>FULL_REQUEST_RESOLVER_METRICS</code>: Records and emits metric data for all resolvers in the request.</p> </li> <li> <p> <code>PER_RESOLVER_METRICS</code>: Records and emits metric data for resolvers that have the <code>metricsConfig</code> value set to <code>ENABLED</code>.</p> </li> </ul>
        """
        if data_source_level_metrics_behavior is not None:
            pulumi.set(__self__, "data_source_level_metrics_behavior", data_source_level_metrics_behavior)
        if operation_level_metrics_config is not None:
            pulumi.set(__self__, "operation_level_metrics_config", operation_level_metrics_config)
        if resolver_level_metrics_behavior is not None:
            pulumi.set(__self__, "resolver_level_metrics_behavior", resolver_level_metrics_behavior)

    @property
    @pulumi.getter(name="dataSourceLevelMetricsBehavior")
    def data_source_level_metrics_behavior(self) -> Optional['outputs.DataSourceLevelMetricsBehaviorEnumValueResponse']:
        """
        <p>Controls how data source metrics will be emitted to CloudWatch. Data source metrics include:</p> <ul> <li> <p>Requests: The number of invocations that occured during a request.</p> </li> <li> <p>Latency: The time to complete a data source invocation.</p> </li> <li> <p>Errors: The number of errors that occurred during a data source invocation.</p> </li> </ul> <p>These metrics can be emitted to CloudWatch per data source or for all data sources in the request. Metrics will be recorded by API ID and data source name. <code>dataSourceLevelMetricsBehavior</code> accepts one of these values at a time:</p> <ul> <li> <p> <code>FULL_REQUEST_DATA_SOURCE_METRICS</code>: Records and emits metric data for all data sources in the request.</p> </li> <li> <p> <code>PER_DATA_SOURCE_METRICS</code>: Records and emits metric data for data sources that have the <code>metricsConfig</code> value set to <code>ENABLED</code>.</p> </li> </ul>
        """
        return pulumi.get(self, "data_source_level_metrics_behavior")

    @property
    @pulumi.getter(name="operationLevelMetricsConfig")
    def operation_level_metrics_config(self) -> Optional['outputs.OperationLevelMetricsConfigEnumValueResponse']:
        """
        <p> Controls how operation metrics will be emitted to CloudWatch. Operation metrics include:</p> <ul> <li> <p>Requests: The number of times a specified GraphQL operation was called.</p> </li> <li> <p>GraphQL errors: The number of GraphQL errors that occurred during a specified GraphQL operation.</p> </li> </ul> <p>Metrics will be recorded by API ID and operation name. You can set the value to <code>ENABLED</code> or <code>DISABLED</code>.</p>
        """
        return pulumi.get(self, "operation_level_metrics_config")

    @property
    @pulumi.getter(name="resolverLevelMetricsBehavior")
    def resolver_level_metrics_behavior(self) -> Optional['outputs.ResolverLevelMetricsBehaviorEnumValueResponse']:
        """
        <p>Controls how resolver metrics will be emitted to CloudWatch. Resolver metrics include:</p> <ul> <li> <p>GraphQL errors: The number of GraphQL errors that occurred.</p> </li> <li> <p>Requests: The number of invocations that occurred during a request. </p> </li> <li> <p>Latency: The time to complete a resolver invocation.</p> </li> <li> <p>Cache hits: The number of cache hits during a request.</p> </li> <li> <p>Cache misses: The number of cache misses during a request.</p> </li> </ul> <p>These metrics can be emitted to CloudWatch per resolver or for all resolvers in the request. Metrics will be recorded by API ID and resolver name. <code>resolverLevelMetricsBehavior</code> accepts one of these values at a time:</p> <ul> <li> <p> <code>FULL_REQUEST_RESOLVER_METRICS</code>: Records and emits metric data for all resolvers in the request.</p> </li> <li> <p> <code>PER_RESOLVER_METRICS</code>: Records and emits metric data for resolvers that have the <code>metricsConfig</code> value set to <code>ENABLED</code>.</p> </li> </ul>
        """
        return pulumi.get(self, "resolver_level_metrics_behavior")


@pulumi.output_type
class EnvironmentFileResponse(dict):
    """
    Definition of EnvironmentFile
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of EnvironmentFile
        :param str type: The file type to use. Environment files are objects in Amazon S3. The only supported value is ``s3``.
        :param str value: The Amazon Resource Name (ARN) of the Amazon S3 object containing the environment variable file.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The file type to use. Environment files are objects in Amazon S3. The only supported value is ``s3``.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon S3 object containing the environment variable file.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentResponse(dict):
    """
    Definition of Environment
    """
    def __init__(__self__, *,
                 variables: Optional[Mapping[str, str]] = None):
        """
        Definition of Environment
        :param Mapping[str, str] variables: Environment variable key-value pairs. For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, str]]:
        """
        Environment variable key-value pairs. For more information, see [Using Lambda environment variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html).
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EnvironmentTypeEnumValueResponse(dict):
    """
    Definition of EnvironmentTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of EnvironmentTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentVariableResponse(dict):
    """
    Definition of EnvironmentVariable
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional['outputs.EnvironmentVariableTypeEnumValueResponse'] = None,
                 value: Optional[str] = None):
        """
        Definition of EnvironmentVariable
        :param str name: <p>The name or key of the environment variable.</p>
        :param 'EnvironmentVariableTypeEnumValueResponse' type: <p>The type of environment variable. Valid values include:</p> <ul> <li> <p> <code>PARAMETER_STORE</code>: An environment variable stored in Systems Manager Parameter Store. For environment variables of this type, specify the name of the parameter as the <code>value</code> of the EnvironmentVariable. The parameter value will be substituted for the name at runtime. You can also define Parameter Store environment variables in the buildspec. To learn how to do so, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.parameter-store'>env/parameter-store</a> in the <i>CodeBuild User Guide</i>.</p> </li> <li> <p> <code>PLAINTEXT</code>: An environment variable in plain text format. This is the default value.</p> </li> <li> <p> <code>SECRETS_MANAGER</code>: An environment variable stored in Secrets Manager. For environment variables of this type, specify the name of the secret as the <code>value</code> of the EnvironmentVariable. The secret value will be substituted for the name at runtime. You can also define Secrets Manager environment variables in the buildspec. To learn how to do so, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.secrets-manager'>env/secrets-manager</a> in the <i>CodeBuild User Guide</i>.</p> </li> </ul>
        :param str value: <p>The value of the environment variable.</p> <important> <p>We strongly discourage the use of <code>PLAINTEXT</code> environment variables to store sensitive values, especially Amazon Web Services secret key IDs. <code>PLAINTEXT</code> environment variables can be displayed in plain text using the CodeBuild console and the CLI. For sensitive values, we recommend you use an environment variable of type <code>PARAMETER_STORE</code> or <code>SECRETS_MANAGER</code>. </p> </important>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name or key of the environment variable.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.EnvironmentVariableTypeEnumValueResponse']:
        """
        <p>The type of environment variable. Valid values include:</p> <ul> <li> <p> <code>PARAMETER_STORE</code>: An environment variable stored in Systems Manager Parameter Store. For environment variables of this type, specify the name of the parameter as the <code>value</code> of the EnvironmentVariable. The parameter value will be substituted for the name at runtime. You can also define Parameter Store environment variables in the buildspec. To learn how to do so, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.parameter-store'>env/parameter-store</a> in the <i>CodeBuild User Guide</i>.</p> </li> <li> <p> <code>PLAINTEXT</code>: An environment variable in plain text format. This is the default value.</p> </li> <li> <p> <code>SECRETS_MANAGER</code>: An environment variable stored in Secrets Manager. For environment variables of this type, specify the name of the secret as the <code>value</code> of the EnvironmentVariable. The secret value will be substituted for the name at runtime. You can also define Secrets Manager environment variables in the buildspec. To learn how to do so, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec.env.secrets-manager'>env/secrets-manager</a> in the <i>CodeBuild User Guide</i>.</p> </li> </ul>
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        <p>The value of the environment variable.</p> <important> <p>We strongly discourage the use of <code>PLAINTEXT</code> environment variables to store sensitive values, especially Amazon Web Services secret key IDs. <code>PLAINTEXT</code> environment variables can be displayed in plain text using the CodeBuild console and the CLI. For sensitive values, we recommend you use an environment variable of type <code>PARAMETER_STORE</code> or <code>SECRETS_MANAGER</code>. </p> </important>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentVariableTypeEnumValueResponse(dict):
    """
    Definition of EnvironmentVariableTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of EnvironmentVariableTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EphemeralStorageResponse(dict):
    """
    Definition of EphemeralStorage
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeInGiB":
            suggest = "size_in_gi_b"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EphemeralStorageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EphemeralStorageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EphemeralStorageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: Optional[int] = None,
                 size_in_gi_b: Optional[int] = None):
        """
        Definition of EphemeralStorage
        :param int size: The size of the function's ``/tmp`` directory.
        :param int size_in_gi_b: The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is ``20`` GiB and the maximum supported value is ``200`` GiB.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_in_gi_b is not None:
            pulumi.set(__self__, "size_in_gi_b", size_in_gi_b)

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the function's ``/tmp`` directory.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeInGiB")
    def size_in_gi_b(self) -> Optional[int]:
        """
        The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is ``20`` GiB and the maximum supported value is ``200`` GiB.
        """
        return pulumi.get(self, "size_in_gi_b")


@pulumi.output_type
class ErrorDetailResponse(dict):
    """
    Definition of ErrorDetail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorData":
            suggest = "error_data"
        elif key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ErrorDetailResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: Optional[str] = None,
                 error_data: Optional[Sequence[Any]] = None,
                 error_message: Optional[str] = None):
        """
        Definition of ErrorDetail
        :param str error_code: <p>The name or code associated with the error.</p>
        :param Sequence[Any] error_data: <p>A list of key value pairs that provides contextual information about why an error occured.</p>
        :param str error_message: <p>A message that describes the error.</p>
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_data is not None:
            pulumi.set(__self__, "error_data", error_data)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[str]:
        """
        <p>The name or code associated with the error.</p>
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorData")
    def error_data(self) -> Optional[Sequence[Any]]:
        """
        <p>A list of key value pairs that provides contextual information about why an error occured.</p>
        """
        return pulumi.get(self, "error_data")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        <p>A message that describes the error.</p>
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class EstablishedMultiRegionAccessPointPolicyResponse(dict):
    """
    Definition of EstablishedMultiRegionAccessPointPolicy
    """
    def __init__(__self__, *,
                 policy: Optional[str] = None):
        """
        Definition of EstablishedMultiRegionAccessPointPolicy
        :param str policy: <p>The details of the last established policy.</p>
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        <p>The details of the last established policy.</p>
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class EventBridgeConfigurationResponse(dict):
    """
    Definition of EventBridgeConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventBridgeEnabled":
            suggest = "event_bridge_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventBridgeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventBridgeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventBridgeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_bridge_enabled: Optional[bool] = None):
        """
        Definition of EventBridgeConfiguration
        :param bool event_bridge_enabled: Enables delivery of events to Amazon EventBridge.
        """
        if event_bridge_enabled is None:
            event_bridge_enabled = True
        if event_bridge_enabled is not None:
            pulumi.set(__self__, "event_bridge_enabled", event_bridge_enabled)

    @property
    @pulumi.getter(name="eventBridgeEnabled")
    def event_bridge_enabled(self) -> Optional[bool]:
        """
        Enables delivery of events to Amazon EventBridge.
        """
        return pulumi.get(self, "event_bridge_enabled")


@pulumi.output_type
class EventCodeEnumValueResponse(dict):
    """
    Definition of EventCodeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of EventCodeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventSelectorResponse(dict):
    """
    Definition of EventSelector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataResources":
            suggest = "data_resources"
        elif key == "excludeManagementEventSources":
            suggest = "exclude_management_event_sources"
        elif key == "includeManagementEvents":
            suggest = "include_management_events"
        elif key == "readWriteType":
            suggest = "read_write_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventSelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventSelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventSelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_resources: Optional[Sequence['outputs.DataResourceResponse']] = None,
                 exclude_management_event_sources: Optional[Sequence[str]] = None,
                 include_management_events: Optional[bool] = None,
                 read_write_type: Optional[str] = None):
        """
        Definition of EventSelector
        :param Sequence['DataResourceResponse'] data_resources: Property dataResources
        :param Sequence[str] exclude_management_event_sources: An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out AWS Key Management Service events by containing 'kms.amazonaws.com'. By default, ExcludeManagementEventSources is empty, and AWS KMS events are included in events that are logged to your trail.
        :param bool include_management_events: Specify if you want your event selector to include management events for your trail.
        :param str read_write_type: Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation.
        """
        if data_resources is not None:
            pulumi.set(__self__, "data_resources", data_resources)
        if exclude_management_event_sources is not None:
            pulumi.set(__self__, "exclude_management_event_sources", exclude_management_event_sources)
        if include_management_events is not None:
            pulumi.set(__self__, "include_management_events", include_management_events)
        if read_write_type is not None:
            pulumi.set(__self__, "read_write_type", read_write_type)

    @property
    @pulumi.getter(name="dataResources")
    def data_resources(self) -> Optional[Sequence['outputs.DataResourceResponse']]:
        """
        Property dataResources
        """
        return pulumi.get(self, "data_resources")

    @property
    @pulumi.getter(name="excludeManagementEventSources")
    def exclude_management_event_sources(self) -> Optional[Sequence[str]]:
        """
        An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out AWS Key Management Service events by containing 'kms.amazonaws.com'. By default, ExcludeManagementEventSources is empty, and AWS KMS events are included in events that are logged to your trail.
        """
        return pulumi.get(self, "exclude_management_event_sources")

    @property
    @pulumi.getter(name="includeManagementEvents")
    def include_management_events(self) -> Optional[bool]:
        """
        Specify if you want your event selector to include management events for your trail.
        """
        return pulumi.get(self, "include_management_events")

    @property
    @pulumi.getter(name="readWriteType")
    def read_write_type(self) -> Optional[str]:
        """
        Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation.
        """
        return pulumi.get(self, "read_write_type")


@pulumi.output_type
class ExclusionByResourceTypesResponse(dict):
    """
    Definition of ExclusionByResourceTypes
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceTypes":
            suggest = "resource_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExclusionByResourceTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExclusionByResourceTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExclusionByResourceTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_types: Optional[Sequence[str]] = None):
        """
        Definition of ExclusionByResourceTypes
        :param Sequence[str] resource_types: <p>A comma-separated list of resource types to exclude from recording by the configuration recorder.</p>
        """
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence[str]]:
        """
        <p>A comma-separated list of resource types to exclude from recording by the configuration recorder.</p>
        """
        return pulumi.get(self, "resource_types")


@pulumi.output_type
class ExecuteCommandConfigurationResponse(dict):
    """
    Definition of ExecuteCommandConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "logConfiguration":
            suggest = "log_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExecuteCommandConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExecuteCommandConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExecuteCommandConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_id: Optional[str] = None,
                 log_configuration: Optional['outputs.ExecuteCommandLogConfigurationResponse'] = None,
                 logging: Optional[str] = None):
        """
        Definition of ExecuteCommandConfiguration
        :param str kms_key_id: Specify an KMSlong key ID to encrypt the data between the local client and the container.
        :param 'ExecuteCommandLogConfigurationResponse' log_configuration: The log configuration for the results of the execute command actions. The logs can be sent to CloudWatch Logs or an Amazon S3 bucket. When ``logging=OVERRIDE`` is specified, a ``logConfiguration`` must be provided. The log configuration for the results of the execute command actions. The logs can be sent to CloudWatch Logs or an Amazon S3 bucket.
        :param str logging: The log setting to use for redirecting logs for your execute command results. The following log settings are available.  +   ``NONE``: The execute command session is not logged.  +   ``DEFAULT``: The ``awslogs`` configuration in the task definition is used. If no logging parameter is specified, it defaults to this value. If no ``awslogs`` log driver is configured in the task definition, the output won't be logged.  +   ``OVERRIDE``: Specify the logging details as a part of ``logConfiguration``. If the ``OVERRIDE`` logging option is specified, the ``logConfiguration`` is required.
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if log_configuration is not None:
            pulumi.set(__self__, "log_configuration", log_configuration)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        Specify an KMSlong key ID to encrypt the data between the local client and the container.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="logConfiguration")
    def log_configuration(self) -> Optional['outputs.ExecuteCommandLogConfigurationResponse']:
        """
        The log configuration for the results of the execute command actions. The logs can be sent to CloudWatch Logs or an Amazon S3 bucket. When ``logging=OVERRIDE`` is specified, a ``logConfiguration`` must be provided. The log configuration for the results of the execute command actions. The logs can be sent to CloudWatch Logs or an Amazon S3 bucket.
        """
        return pulumi.get(self, "log_configuration")

    @property
    @pulumi.getter
    def logging(self) -> Optional[str]:
        """
        The log setting to use for redirecting logs for your execute command results. The following log settings are available.  +   ``NONE``: The execute command session is not logged.  +   ``DEFAULT``: The ``awslogs`` configuration in the task definition is used. If no logging parameter is specified, it defaults to this value. If no ``awslogs`` log driver is configured in the task definition, the output won't be logged.  +   ``OVERRIDE``: Specify the logging details as a part of ``logConfiguration``. If the ``OVERRIDE`` logging option is specified, the ``logConfiguration`` is required.
        """
        return pulumi.get(self, "logging")


@pulumi.output_type
class ExecuteCommandLogConfigurationResponse(dict):
    """
    Definition of ExecuteCommandLogConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchEncryptionEnabled":
            suggest = "cloud_watch_encryption_enabled"
        elif key == "cloudWatchLogGroupName":
            suggest = "cloud_watch_log_group_name"
        elif key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3EncryptionEnabled":
            suggest = "s3_encryption_enabled"
        elif key == "s3KeyPrefix":
            suggest = "s3_key_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExecuteCommandLogConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExecuteCommandLogConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExecuteCommandLogConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_encryption_enabled: Optional[bool] = None,
                 cloud_watch_log_group_name: Optional[str] = None,
                 s3_bucket_name: Optional[str] = None,
                 s3_encryption_enabled: Optional[bool] = None,
                 s3_key_prefix: Optional[str] = None):
        """
        Definition of ExecuteCommandLogConfiguration
        :param bool cloud_watch_encryption_enabled: Determines whether to use encryption on the CloudWatch logs. If not specified, encryption will be off.
        :param str cloud_watch_log_group_name: The name of the CloudWatch log group to send logs to.  The CloudWatch log group must already be created.
        :param str s3_bucket_name: The name of the S3 bucket to send logs to.  The S3 bucket must already be created.
        :param bool s3_encryption_enabled: Determines whether to use encryption on the S3 logs. If not specified, encryption is not used.
        :param str s3_key_prefix: An optional folder in the S3 bucket to place logs in.
        """
        if cloud_watch_encryption_enabled is not None:
            pulumi.set(__self__, "cloud_watch_encryption_enabled", cloud_watch_encryption_enabled)
        if cloud_watch_log_group_name is not None:
            pulumi.set(__self__, "cloud_watch_log_group_name", cloud_watch_log_group_name)
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_encryption_enabled is not None:
            pulumi.set(__self__, "s3_encryption_enabled", s3_encryption_enabled)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)

    @property
    @pulumi.getter(name="cloudWatchEncryptionEnabled")
    def cloud_watch_encryption_enabled(self) -> Optional[bool]:
        """
        Determines whether to use encryption on the CloudWatch logs. If not specified, encryption will be off.
        """
        return pulumi.get(self, "cloud_watch_encryption_enabled")

    @property
    @pulumi.getter(name="cloudWatchLogGroupName")
    def cloud_watch_log_group_name(self) -> Optional[str]:
        """
        The name of the CloudWatch log group to send logs to.  The CloudWatch log group must already be created.
        """
        return pulumi.get(self, "cloud_watch_log_group_name")

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[str]:
        """
        The name of the S3 bucket to send logs to.  The S3 bucket must already be created.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3EncryptionEnabled")
    def s3_encryption_enabled(self) -> Optional[bool]:
        """
        Determines whether to use encryption on the S3 logs. If not specified, encryption is not used.
        """
        return pulumi.get(self, "s3_encryption_enabled")

    @property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[str]:
        """
        An optional folder in the S3 bucket to place logs in.
        """
        return pulumi.get(self, "s3_key_prefix")


@pulumi.output_type
class ExportSourceTypeEnumValueResponse(dict):
    """
    Definition of ExportSourceTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ExportSourceTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FSxAuthorizationConfigResponse(dict):
    """
    Definition of FSxAuthorizationConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsParameter":
            suggest = "credentials_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FSxAuthorizationConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FSxAuthorizationConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FSxAuthorizationConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_parameter: Optional[str] = None,
                 domain: Optional[str] = None):
        """
        Definition of FSxAuthorizationConfig
        :param str credentials_parameter: Property credentialsParameter
        :param str domain: Property domain
        """
        if credentials_parameter is not None:
            pulumi.set(__self__, "credentials_parameter", credentials_parameter)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter(name="credentialsParameter")
    def credentials_parameter(self) -> Optional[str]:
        """
        Property credentialsParameter
        """
        return pulumi.get(self, "credentials_parameter")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Property domain
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class FSxWindowsFileServerVolumeConfigurationResponse(dict):
    """
    Definition of FSxWindowsFileServerVolumeConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationConfig":
            suggest = "authorization_config"
        elif key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "rootDirectory":
            suggest = "root_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FSxWindowsFileServerVolumeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FSxWindowsFileServerVolumeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FSxWindowsFileServerVolumeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_config: Optional['outputs.FSxAuthorizationConfigResponse'] = None,
                 file_system_id: Optional[str] = None,
                 root_directory: Optional[str] = None):
        """
        Definition of FSxWindowsFileServerVolumeConfiguration
        :param 'FSxAuthorizationConfigResponse' authorization_config: The authorization configuration details for the Amazon FSx for Windows File Server file system.
        :param str file_system_id: The Amazon FSx for Windows File Server file system ID to use.
        :param str root_directory: The directory within the Amazon FSx for Windows File Server file system to mount as the root directory inside the host.
        """
        if authorization_config is not None:
            pulumi.set(__self__, "authorization_config", authorization_config)
        if file_system_id is not None:
            pulumi.set(__self__, "file_system_id", file_system_id)
        if root_directory is not None:
            pulumi.set(__self__, "root_directory", root_directory)

    @property
    @pulumi.getter(name="authorizationConfig")
    def authorization_config(self) -> Optional['outputs.FSxAuthorizationConfigResponse']:
        """
        The authorization configuration details for the Amazon FSx for Windows File Server file system.
        """
        return pulumi.get(self, "authorization_config")

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> Optional[str]:
        """
        The Amazon FSx for Windows File Server file system ID to use.
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> Optional[str]:
        """
        The directory within the Amazon FSx for Windows File Server file system to mount as the root directory inside the host.
        """
        return pulumi.get(self, "root_directory")


@pulumi.output_type
class FieldLogLevelEnumValueResponse(dict):
    """
    Definition of FieldLogLevelEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of FieldLogLevelEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FieldToMatchResponse(dict):
    """
    Definition of FieldToMatch
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FieldToMatchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FieldToMatchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FieldToMatchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[Any] = None,
                 query_string: Optional[Any] = None,
                 single_header: Optional['outputs.SingleHeaderModelPropertiesResponse'] = None,
                 uri_path: Optional[Any] = None):
        """
        Definition of FieldToMatch
        :param Any method: Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        :param Any query_string: Inspect the query string. This is the part of a URL that appears after a ? character, if any.
        :param 'SingleHeaderModelPropertiesResponse' single_header: Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        :param Any uri_path: Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        """
        Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[Any]:
        """
        Inspect the query string. This is the part of a URL that appears after a ? character, if any.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.SingleHeaderModelPropertiesResponse']:
        """
        Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
        """
        return pulumi.get(self, "single_header")

    @property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[Any]:
        """
        Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class FileSystemConfigResponse(dict):
    """
    Definition of FileSystemConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localMountPath":
            suggest = "local_mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 local_mount_path: Optional[str] = None):
        """
        Definition of FileSystemConfig
        :param str arn: The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        :param str local_mount_path: The path where the function can access the file system, starting with ``/mnt/``.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if local_mount_path is not None:
            pulumi.set(__self__, "local_mount_path", local_mount_path)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> Optional[str]:
        """
        The path where the function can access the file system, starting with ``/mnt/``.
        """
        return pulumi.get(self, "local_mount_path")


@pulumi.output_type
class FileSystemProtectionResponse(dict):
    """
    Definition of FileSystemProtection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationOverwriteProtection":
            suggest = "replication_overwrite_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemProtectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemProtectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemProtectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replication_overwrite_protection: Optional[str] = None):
        """
        Definition of FileSystemProtection
        :param str replication_overwrite_protection: The status of the file system's replication overwrite protection.  +   ``ENABLED``  The file system cannot be used as the destination file system in a replication configuration. The file system is writeable. Replication overwrite protection is ``ENABLED`` by default.   +   ``DISABLED``  The file system can be used as the destination file system in a replication configuration. The file system is read-only and can only be modified by EFS replication.  +   ``REPLICATING``  The file system is being used as the destination file system in a replication configuration. The file system is read-only and is only modified only by EFS replication.   If the replication configuration is deleted, the file system's replication overwrite protection is re-enabled, the file system becomes writeable.
        """
        if replication_overwrite_protection is not None:
            pulumi.set(__self__, "replication_overwrite_protection", replication_overwrite_protection)

    @property
    @pulumi.getter(name="replicationOverwriteProtection")
    def replication_overwrite_protection(self) -> Optional[str]:
        """
        The status of the file system's replication overwrite protection.  +   ``ENABLED``  The file system cannot be used as the destination file system in a replication configuration. The file system is writeable. Replication overwrite protection is ``ENABLED`` by default.   +   ``DISABLED``  The file system can be used as the destination file system in a replication configuration. The file system is read-only and can only be modified by EFS replication.  +   ``REPLICATING``  The file system is being used as the destination file system in a replication configuration. The file system is read-only and is only modified only by EFS replication.   If the replication configuration is deleted, the file system's replication overwrite protection is re-enabled, the file system becomes writeable.
        """
        return pulumi.get(self, "replication_overwrite_protection")


@pulumi.output_type
class FileSystemTypeEnumValueResponse(dict):
    """
    Definition of FileSystemTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of FileSystemTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FilterGroupResponse(dict):
    """
    Definition of FilterGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webhookFilter":
            suggest = "webhook_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FilterGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FilterGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FilterGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 webhook_filter: Optional['outputs.WebhookFilterResponse'] = None):
        """
        Definition of FilterGroup
        :param 'WebhookFilterResponse' webhook_filter: Property webhookFilter
        """
        if webhook_filter is not None:
            pulumi.set(__self__, "webhook_filter", webhook_filter)

    @property
    @pulumi.getter(name="webhookFilter")
    def webhook_filter(self) -> Optional['outputs.WebhookFilterResponse']:
        """
        Property webhookFilter
        """
        return pulumi.get(self, "webhook_filter")


@pulumi.output_type
class FilterResponse(dict):
    """
    Definition of Filter
    """
    def __init__(__self__, *,
                 behavior: Optional[str] = None,
                 conditions: Optional[Sequence['outputs.ConditionResponse']] = None,
                 contains: Optional[Sequence[str]] = None,
                 eq: Optional[Sequence[str]] = None,
                 exists: Optional[bool] = None,
                 neq: Optional[Sequence[str]] = None,
                 property: Optional[str] = None,
                 requirement: Optional[str] = None):
        """
        Definition of Filter
        :param str behavior: How to handle logs that satisfy the filter's conditions and requirement.
        :param Sequence['ConditionResponse'] conditions: Match conditions for the filter.
        :param Sequence[str] contains: Property contains
        :param Sequence[str] eq: Property eq
        :param bool exists: Property exists
        :param Sequence[str] neq: Property neq
        :param str property: Property property
        :param str requirement: Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if eq is not None:
            pulumi.set(__self__, "eq", eq)
        if exists is not None:
            pulumi.set(__self__, "exists", exists)
        if neq is not None:
            pulumi.set(__self__, "neq", neq)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if requirement is not None:
            pulumi.set(__self__, "requirement", requirement)

    @property
    @pulumi.getter
    def behavior(self) -> Optional[str]:
        """
        How to handle logs that satisfy the filter's conditions and requirement.
        """
        return pulumi.get(self, "behavior")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ConditionResponse']]:
        """
        Match conditions for the filter.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def contains(self) -> Optional[Sequence[str]]:
        """
        Property contains
        """
        return pulumi.get(self, "contains")

    @property
    @pulumi.getter
    def eq(self) -> Optional[Sequence[str]]:
        """
        Property eq
        """
        return pulumi.get(self, "eq")

    @property
    @pulumi.getter
    def exists(self) -> Optional[bool]:
        """
        Property exists
        """
        return pulumi.get(self, "exists")

    @property
    @pulumi.getter
    def neq(self) -> Optional[Sequence[str]]:
        """
        Property neq
        """
        return pulumi.get(self, "neq")

    @property
    @pulumi.getter
    def requirement(self) -> Optional[str]:
        """
        Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
        """
        return pulumi.get(self, "requirement")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        Property property
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class FilterRuleResponse(dict):
    """
    Definition of FilterRule
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of FilterRule
        :param str name: The object key name prefix or suffix identifying one or more objects to which the filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see [Configuring Event Notifications](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide*.
        :param str value: The value that the filter searches for in object key names.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The object key name prefix or suffix identifying one or more objects to which the filtering rule applies. The maximum length is 1,024 characters. Overlapping prefixes and suffixes are not supported. For more information, see [Configuring Event Notifications](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that the filter searches for in object key names.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FirelensConfigurationResponse(dict):
    """
    Definition of FirelensConfiguration
    """
    def __init__(__self__, *,
                 options: Optional[Any] = None,
                 type: Optional[str] = None):
        """
        Definition of FirelensConfiguration
        :param Any options: The options to use when configuring the log router. This field is optional and can be used to add additional metadata, such as the task, task definition, cluster, and container instance details to the log event.  If specified, valid option keys are:  +   ``enable-ecs-log-metadata``, which can be ``true`` or ``false``   +   ``config-file-type``, which can be ``s3`` or ``file``   +   ``config-file-value``, which is either an S3 ARN or a file path
        :param str type: The log router to use. The valid values are ``fluentd`` or ``fluentbit``.
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def options(self) -> Optional[Any]:
        """
        The options to use when configuring the log router. This field is optional and can be used to add additional metadata, such as the task, task definition, cluster, and container instance details to the log event.  If specified, valid option keys are:  +   ``enable-ecs-log-metadata``, which can be ``true`` or ``false``   +   ``config-file-type``, which can be ``s3`` or ``file``   +   ``config-file-value``, which is either an S3 ARN or a file path
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The log router to use. The valid values are ``fluentd`` or ``fluentbit``.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FirewallPolicyResponse(dict):
    """
    Definition of FirewallPolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyVariables":
            suggest = "policy_variables"
        elif key == "statefulDefaultActions":
            suggest = "stateful_default_actions"
        elif key == "statefulEngineOptions":
            suggest = "stateful_engine_options"
        elif key == "statefulRuleGroupReferences":
            suggest = "stateful_rule_group_references"
        elif key == "statelessCustomActions":
            suggest = "stateless_custom_actions"
        elif key == "statelessDefaultActions":
            suggest = "stateless_default_actions"
        elif key == "statelessFragmentDefaultActions":
            suggest = "stateless_fragment_default_actions"
        elif key == "statelessRuleGroupReferences":
            suggest = "stateless_rule_group_references"
        elif key == "tlsInspectionConfigurationArn":
            suggest = "tls_inspection_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_variables: Optional['outputs.RuleVariablesModelResponse'] = None,
                 stateful_default_actions: Optional[Sequence[str]] = None,
                 stateful_engine_options: Optional['outputs.StatefulEngineOptionsResponse'] = None,
                 stateful_rule_group_references: Optional[Sequence['outputs.StatefulRuleGroupReferenceResponse']] = None,
                 stateless_custom_actions: Optional[Sequence['outputs.CustomActionResponse']] = None,
                 stateless_default_actions: Optional[Sequence[str]] = None,
                 stateless_fragment_default_actions: Optional[Sequence[str]] = None,
                 stateless_rule_group_references: Optional[Sequence['outputs.StatelessRuleGroupReferenceResponse']] = None,
                 tls_inspection_configuration_arn: Optional[str] = None):
        """
        Definition of FirewallPolicy
        :param 'RuleVariablesModelResponse' policy_variables: Property policyVariables
        :param Sequence[str] stateful_default_actions: Property statefulDefaultActions
        :param 'StatefulEngineOptionsResponse' stateful_engine_options: Property statefulEngineOptions
        :param Sequence['StatefulRuleGroupReferenceResponse'] stateful_rule_group_references: Property statefulRuleGroupReferences
        :param Sequence['CustomActionResponse'] stateless_custom_actions: Property statelessCustomActions
        :param Sequence[str] stateless_default_actions: Property statelessDefaultActions
        :param Sequence[str] stateless_fragment_default_actions: Property statelessFragmentDefaultActions
        :param Sequence['StatelessRuleGroupReferenceResponse'] stateless_rule_group_references: Property statelessRuleGroupReferences
        :param str tls_inspection_configuration_arn: A resource ARN.
        """
        if policy_variables is not None:
            pulumi.set(__self__, "policy_variables", policy_variables)
        if stateful_default_actions is not None:
            pulumi.set(__self__, "stateful_default_actions", stateful_default_actions)
        if stateful_engine_options is not None:
            pulumi.set(__self__, "stateful_engine_options", stateful_engine_options)
        if stateful_rule_group_references is not None:
            pulumi.set(__self__, "stateful_rule_group_references", stateful_rule_group_references)
        if stateless_custom_actions is not None:
            pulumi.set(__self__, "stateless_custom_actions", stateless_custom_actions)
        if stateless_default_actions is not None:
            pulumi.set(__self__, "stateless_default_actions", stateless_default_actions)
        if stateless_fragment_default_actions is not None:
            pulumi.set(__self__, "stateless_fragment_default_actions", stateless_fragment_default_actions)
        if stateless_rule_group_references is not None:
            pulumi.set(__self__, "stateless_rule_group_references", stateless_rule_group_references)
        if tls_inspection_configuration_arn is not None:
            pulumi.set(__self__, "tls_inspection_configuration_arn", tls_inspection_configuration_arn)

    @property
    @pulumi.getter(name="policyVariables")
    def policy_variables(self) -> Optional['outputs.RuleVariablesModelResponse']:
        """
        Property policyVariables
        """
        return pulumi.get(self, "policy_variables")

    @property
    @pulumi.getter(name="statefulDefaultActions")
    def stateful_default_actions(self) -> Optional[Sequence[str]]:
        """
        Property statefulDefaultActions
        """
        return pulumi.get(self, "stateful_default_actions")

    @property
    @pulumi.getter(name="statefulEngineOptions")
    def stateful_engine_options(self) -> Optional['outputs.StatefulEngineOptionsResponse']:
        """
        Property statefulEngineOptions
        """
        return pulumi.get(self, "stateful_engine_options")

    @property
    @pulumi.getter(name="statefulRuleGroupReferences")
    def stateful_rule_group_references(self) -> Optional[Sequence['outputs.StatefulRuleGroupReferenceResponse']]:
        """
        Property statefulRuleGroupReferences
        """
        return pulumi.get(self, "stateful_rule_group_references")

    @property
    @pulumi.getter(name="statelessCustomActions")
    def stateless_custom_actions(self) -> Optional[Sequence['outputs.CustomActionResponse']]:
        """
        Property statelessCustomActions
        """
        return pulumi.get(self, "stateless_custom_actions")

    @property
    @pulumi.getter(name="statelessDefaultActions")
    def stateless_default_actions(self) -> Optional[Sequence[str]]:
        """
        Property statelessDefaultActions
        """
        return pulumi.get(self, "stateless_default_actions")

    @property
    @pulumi.getter(name="statelessFragmentDefaultActions")
    def stateless_fragment_default_actions(self) -> Optional[Sequence[str]]:
        """
        Property statelessFragmentDefaultActions
        """
        return pulumi.get(self, "stateless_fragment_default_actions")

    @property
    @pulumi.getter(name="statelessRuleGroupReferences")
    def stateless_rule_group_references(self) -> Optional[Sequence['outputs.StatelessRuleGroupReferenceResponse']]:
        """
        Property statelessRuleGroupReferences
        """
        return pulumi.get(self, "stateless_rule_group_references")

    @property
    @pulumi.getter(name="tlsInspectionConfigurationArn")
    def tls_inspection_configuration_arn(self) -> Optional[str]:
        """
        A resource ARN.
        """
        return pulumi.get(self, "tls_inspection_configuration_arn")


@pulumi.output_type
class FixedResponseConfigResponse(dict):
    """
    Definition of FixedResponseConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FixedResponseConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FixedResponseConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FixedResponseConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional[str] = None,
                 message_body: Optional[str] = None,
                 status_code: Optional[str] = None):
        """
        Definition of FixedResponseConfig
        :param str content_type: The content type. Valid Values: text/plain | text/css | text/html | application/javascript | application/json
        :param str message_body: The message.
        :param str status_code: The HTTP response code (2XX, 4XX, or 5XX).
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        The content type. Valid Values: text/plain | text/css | text/html | application/javascript | application/json
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[str]:
        """
        The message.
        """
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[str]:
        """
        The HTTP response code (2XX, 4XX, or 5XX).
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class ForwardConfigResponse(dict):
    """
    Definition of ForwardConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupStickinessConfig":
            suggest = "target_group_stickiness_config"
        elif key == "targetGroups":
            suggest = "target_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForwardConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForwardConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForwardConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_group_stickiness_config: Optional['outputs.TargetGroupStickinessConfigResponse'] = None,
                 target_groups: Optional[Sequence['outputs.TargetGroupTupleResponse']] = None):
        """
        Definition of ForwardConfig
        :param 'TargetGroupStickinessConfigResponse' target_group_stickiness_config: Information about the target group stickiness for a rule. Information about the target group stickiness for a rule.
        :param Sequence['TargetGroupTupleResponse'] target_groups: Information about how traffic will be distributed between multiple target groups in a forward rule.
        """
        if target_group_stickiness_config is not None:
            pulumi.set(__self__, "target_group_stickiness_config", target_group_stickiness_config)
        if target_groups is not None:
            pulumi.set(__self__, "target_groups", target_groups)

    @property
    @pulumi.getter(name="targetGroupStickinessConfig")
    def target_group_stickiness_config(self) -> Optional['outputs.TargetGroupStickinessConfigResponse']:
        """
        Information about the target group stickiness for a rule. Information about the target group stickiness for a rule.
        """
        return pulumi.get(self, "target_group_stickiness_config")

    @property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> Optional[Sequence['outputs.TargetGroupTupleResponse']]:
        """
        Information about how traffic will be distributed between multiple target groups in a forward rule.
        """
        return pulumi.get(self, "target_groups")


@pulumi.output_type
class ForwardedValuesResponse(dict):
    """
    Definition of ForwardedValues
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "queryStringCacheKeys":
            suggest = "query_string_cache_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForwardedValuesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForwardedValuesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForwardedValuesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookies: Optional['outputs.CookiesResponse'] = None,
                 headers: Optional[Sequence[str]] = None,
                 query_string: Optional[bool] = None,
                 query_string_cache_keys: Optional[Sequence[str]] = None):
        """
        Definition of ForwardedValues
        :param 'CookiesResponse' cookies: This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [How CloudFront Forwards, Caches, and Logs Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the *Amazon CloudFront Developer Guide*. This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [How CloudFront Forwards, Caches, and Logs Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the *Amazon CloudFront Developer Guide*.
        :param Sequence[str] headers: This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include headers in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send headers to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies the ``Headers``, if any, that you want CloudFront to forward to the origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches separate versions of a specified object that is based on the header values in viewer requests. For more information, see [Caching Content Based on Request Headers](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html) in the *Amazon CloudFront Developer Guide*.
        :param bool query_string: This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior and cache based on the query string parameters. CloudFront behavior depends on the value of ``QueryString`` and on the values that you specify for ``QueryStringCacheKeys``, if any: If you specify true for ``QueryString`` and you don't specify any values for ``QueryStringCacheKeys``, CloudFront forwards all query string parameters to the origin and caches based on all query string parameters. Depending on how many query string parameters and values you have, this can adversely affect performance because CloudFront must forward more requests to the origin. If you specify true for ``QueryString`` and you specify one or more values for ``QueryStringCacheKeys``, CloudFront forwards all query string parameters to the origin, but it only caches based on the query string parameters that you specify. If you specify false for ``QueryString``, CloudFront doesn't forward any query string parameters to the origin, and doesn't cache based on query string parameters. For more information, see [Configuring CloudFront to Cache Based on Query String Parameters](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html) in the *Amazon CloudFront Developer Guide*.
        :param Sequence[str] query_string_cache_keys: This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for this cache behavior.
        """
        if cookies is not None:
            pulumi.set(__self__, "cookies", cookies)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if query_string_cache_keys is not None:
            pulumi.set(__self__, "query_string_cache_keys", query_string_cache_keys)

    @property
    @pulumi.getter
    def cookies(self) -> Optional['outputs.CookiesResponse']:
        """
        This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [How CloudFront Forwards, Caches, and Logs Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the *Amazon CloudFront Developer Guide*. This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include cookies in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send cookies to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies whether you want CloudFront to forward cookies to the origin and, if so, which ones. For more information about forwarding cookies to the origin, see [How CloudFront Forwards, Caches, and Logs Cookies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        """
        This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include headers in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send headers to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that specifies the ``Headers``, if any, that you want CloudFront to forward to the origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches separate versions of a specified object that is based on the header values in viewer requests. For more information, see [Caching Content Based on Request Headers](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[bool]:
        """
        This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior and cache based on the query string parameters. CloudFront behavior depends on the value of ``QueryString`` and on the values that you specify for ``QueryStringCacheKeys``, if any: If you specify true for ``QueryString`` and you don't specify any values for ``QueryStringCacheKeys``, CloudFront forwards all query string parameters to the origin and caches based on all query string parameters. Depending on how many query string parameters and values you have, this can adversely affect performance because CloudFront must forward more requests to the origin. If you specify true for ``QueryString`` and you specify one or more values for ``QueryStringCacheKeys``, CloudFront forwards all query string parameters to the origin, but it only caches based on the query string parameters that you specify. If you specify false for ``QueryString``, CloudFront doesn't forward any query string parameters to the origin, and doesn't cache based on query string parameters. For more information, see [Configuring CloudFront to Cache Based on Query String Parameters](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="queryStringCacheKeys")
    def query_string_cache_keys(self) -> Optional[Sequence[str]]:
        """
        This field is deprecated. We recommend that you use a cache policy or an origin request policy instead of this field. If you want to include query strings in the cache key, use a cache policy. For more information, see [Creating cache policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy) in the *Amazon CloudFront Developer Guide*. If you want to send query strings to the origin but not include them in the cache key, use an origin request policy. For more information, see [Creating origin request policies](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy) in the *Amazon CloudFront Developer Guide*. A complex type that contains information about the query string parameters that you want CloudFront to use for caching for this cache behavior.
        """
        return pulumi.get(self, "query_string_cache_keys")


@pulumi.output_type
class FunctionAssociationResponse(dict):
    """
    Definition of FunctionAssociation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "functionARN":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAssociationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAssociationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAssociationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: Optional[str] = None,
                 function_arn: Optional[str] = None):
        """
        Definition of FunctionAssociation
        :param str event_type: The event type of the function, either ``viewer-request`` or ``viewer-response``. You cannot use origin-facing event types (``origin-request`` and ``origin-response``) with a CloudFront function.
        :param str function_arn: The Amazon Resource Name (ARN) of the function.
        """
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if function_arn is not None:
            pulumi.set(__self__, "function_arn", function_arn)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[str]:
        """
        The event type of the function, either ``viewer-request`` or ``viewer-response``. You cannot use origin-facing event types (``origin-request`` and ``origin-response``) with a CloudFront function.
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter(name="functionARN")
    def function_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the function.
        """
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class GenerateSecretStringResponse(dict):
    """
    Definition of GenerateSecretString
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeCharacters":
            suggest = "exclude_characters"
        elif key == "excludeLowercase":
            suggest = "exclude_lowercase"
        elif key == "excludeNumbers":
            suggest = "exclude_numbers"
        elif key == "excludePunctuation":
            suggest = "exclude_punctuation"
        elif key == "excludeUppercase":
            suggest = "exclude_uppercase"
        elif key == "generateStringKey":
            suggest = "generate_string_key"
        elif key == "includeSpace":
            suggest = "include_space"
        elif key == "passwordLength":
            suggest = "password_length"
        elif key == "requireEachIncludedType":
            suggest = "require_each_included_type"
        elif key == "secretStringTemplate":
            suggest = "secret_string_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenerateSecretStringResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenerateSecretStringResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenerateSecretStringResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_characters: Optional[str] = None,
                 exclude_lowercase: Optional[bool] = None,
                 exclude_numbers: Optional[bool] = None,
                 exclude_punctuation: Optional[bool] = None,
                 exclude_uppercase: Optional[bool] = None,
                 generate_string_key: Optional[str] = None,
                 include_space: Optional[bool] = None,
                 password_length: Optional[int] = None,
                 require_each_included_type: Optional[bool] = None,
                 secret_string_template: Optional[str] = None):
        """
        Definition of GenerateSecretString
        :param str exclude_characters: A string of the characters that you don't want in the password.
        :param bool exclude_lowercase: Specifies whether to exclude lowercase letters from the password. If you don't include this switch, the password can contain lowercase letters.
        :param bool exclude_numbers: Specifies whether to exclude numbers from the password. If you don't include this switch, the password can contain numbers.
        :param bool exclude_punctuation: Specifies whether to exclude the following punctuation characters from the password: ``! ' # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ ` { | } ~``. If you don't include this switch, the password can contain punctuation.
        :param bool exclude_uppercase: Specifies whether to exclude uppercase letters from the password. If you don't include this switch, the password can contain uppercase letters.
        :param str generate_string_key: The JSON key name for the key/value pair, where the value is the generated password. This pair is added to the JSON structure specified by the ``SecretStringTemplate`` parameter. If you specify this parameter, then you must also specify ``SecretStringTemplate``.
        :param bool include_space: Specifies whether to include the space character. If you include this switch, the password can contain space characters.
        :param int password_length: The length of the password. If you don't include this parameter, the default length is 32 characters.
        :param bool require_each_included_type: Specifies whether to include at least one upper and lowercase letter, one number, and one punctuation. If you don't include this switch, the password contains at least one of every character type.
        :param str secret_string_template: A template that the generated string must match. When you make a change to this property, a new secret version is created.
        """
        if exclude_characters is not None:
            pulumi.set(__self__, "exclude_characters", exclude_characters)
        if exclude_lowercase is not None:
            pulumi.set(__self__, "exclude_lowercase", exclude_lowercase)
        if exclude_numbers is not None:
            pulumi.set(__self__, "exclude_numbers", exclude_numbers)
        if exclude_punctuation is not None:
            pulumi.set(__self__, "exclude_punctuation", exclude_punctuation)
        if exclude_uppercase is not None:
            pulumi.set(__self__, "exclude_uppercase", exclude_uppercase)
        if generate_string_key is not None:
            pulumi.set(__self__, "generate_string_key", generate_string_key)
        if include_space is not None:
            pulumi.set(__self__, "include_space", include_space)
        if password_length is not None:
            pulumi.set(__self__, "password_length", password_length)
        if require_each_included_type is not None:
            pulumi.set(__self__, "require_each_included_type", require_each_included_type)
        if secret_string_template is not None:
            pulumi.set(__self__, "secret_string_template", secret_string_template)

    @property
    @pulumi.getter(name="excludeCharacters")
    def exclude_characters(self) -> Optional[str]:
        """
        A string of the characters that you don't want in the password.
        """
        return pulumi.get(self, "exclude_characters")

    @property
    @pulumi.getter(name="excludeLowercase")
    def exclude_lowercase(self) -> Optional[bool]:
        """
        Specifies whether to exclude lowercase letters from the password. If you don't include this switch, the password can contain lowercase letters.
        """
        return pulumi.get(self, "exclude_lowercase")

    @property
    @pulumi.getter(name="excludeNumbers")
    def exclude_numbers(self) -> Optional[bool]:
        """
        Specifies whether to exclude numbers from the password. If you don't include this switch, the password can contain numbers.
        """
        return pulumi.get(self, "exclude_numbers")

    @property
    @pulumi.getter(name="excludePunctuation")
    def exclude_punctuation(self) -> Optional[bool]:
        """
        Specifies whether to exclude the following punctuation characters from the password: ``! ' # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ ` { | } ~``. If you don't include this switch, the password can contain punctuation.
        """
        return pulumi.get(self, "exclude_punctuation")

    @property
    @pulumi.getter(name="excludeUppercase")
    def exclude_uppercase(self) -> Optional[bool]:
        """
        Specifies whether to exclude uppercase letters from the password. If you don't include this switch, the password can contain uppercase letters.
        """
        return pulumi.get(self, "exclude_uppercase")

    @property
    @pulumi.getter(name="generateStringKey")
    def generate_string_key(self) -> Optional[str]:
        """
        The JSON key name for the key/value pair, where the value is the generated password. This pair is added to the JSON structure specified by the ``SecretStringTemplate`` parameter. If you specify this parameter, then you must also specify ``SecretStringTemplate``.
        """
        return pulumi.get(self, "generate_string_key")

    @property
    @pulumi.getter(name="includeSpace")
    def include_space(self) -> Optional[bool]:
        """
        Specifies whether to include the space character. If you include this switch, the password can contain space characters.
        """
        return pulumi.get(self, "include_space")

    @property
    @pulumi.getter(name="passwordLength")
    def password_length(self) -> Optional[int]:
        """
        The length of the password. If you don't include this parameter, the default length is 32 characters.
        """
        return pulumi.get(self, "password_length")

    @property
    @pulumi.getter(name="requireEachIncludedType")
    def require_each_included_type(self) -> Optional[bool]:
        """
        Specifies whether to include at least one upper and lowercase letter, one number, and one punctuation. If you don't include this switch, the password contains at least one of every character type.
        """
        return pulumi.get(self, "require_each_included_type")

    @property
    @pulumi.getter(name="secretStringTemplate")
    def secret_string_template(self) -> Optional[str]:
        """
        A template that the generated string must match. When you make a change to this property, a new secret version is created.
        """
        return pulumi.get(self, "secret_string_template")


@pulumi.output_type
class GeoLocationResponse(dict):
    """
    Definition of GeoLocation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continentCode":
            suggest = "continent_code"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "subdivisionCode":
            suggest = "subdivision_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GeoLocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GeoLocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GeoLocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continent_code: Optional[str] = None,
                 country_code: Optional[str] = None,
                 subdivision_code: Optional[str] = None):
        """
        Definition of GeoLocation
        :param str continent_code: <p>The two-letter code for the continent.</p> <p>Amazon Route 53 supports the following continent codes:</p> <ul> <li> <p> <b>AF</b>: Africa</p> </li> <li> <p> <b>AN</b>: Antarctica</p> </li> <li> <p> <b>AS</b>: Asia</p> </li> <li> <p> <b>EU</b>: Europe</p> </li> <li> <p> <b>OC</b>: Oceania</p> </li> <li> <p> <b>NA</b>: North America</p> </li> <li> <p> <b>SA</b>: South America</p> </li> </ul> <p>Constraint: Specifying <code>ContinentCode</code> with either <code>CountryCode</code> or <code>SubdivisionCode</code> returns an <code>InvalidInput</code> error.</p>
        :param str country_code: <p>For geolocation resource record sets, the two-letter code for a country.</p> <p>Amazon Route 53 uses the two-letter country codes that are specified in <a href='https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2'>ISO standard 3166-1 alpha-2</a>.</p> <p>Route 53 also supports the country code <b>UA</b> for Ukraine.</p>
        :param str subdivision_code: <p>For geolocation resource record sets, the two-letter code for a state of the United States. Route 53 doesn't support any other values for <code>SubdivisionCode</code>. For a list of state abbreviations, see <a href='https://pe.usps.com/text/pub28/28apb.htm'>Appendix B: TwoLetter State and Possession Abbreviations</a> on the United States Postal Service website. </p> <p>If you specify <code>subdivisioncode</code>, you must also specify <code>US</code> for <code>CountryCode</code>. </p>
        """
        if continent_code is not None:
            pulumi.set(__self__, "continent_code", continent_code)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if subdivision_code is not None:
            pulumi.set(__self__, "subdivision_code", subdivision_code)

    @property
    @pulumi.getter(name="continentCode")
    def continent_code(self) -> Optional[str]:
        """
        <p>The two-letter code for the continent.</p> <p>Amazon Route 53 supports the following continent codes:</p> <ul> <li> <p> <b>AF</b>: Africa</p> </li> <li> <p> <b>AN</b>: Antarctica</p> </li> <li> <p> <b>AS</b>: Asia</p> </li> <li> <p> <b>EU</b>: Europe</p> </li> <li> <p> <b>OC</b>: Oceania</p> </li> <li> <p> <b>NA</b>: North America</p> </li> <li> <p> <b>SA</b>: South America</p> </li> </ul> <p>Constraint: Specifying <code>ContinentCode</code> with either <code>CountryCode</code> or <code>SubdivisionCode</code> returns an <code>InvalidInput</code> error.</p>
        """
        return pulumi.get(self, "continent_code")

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[str]:
        """
        <p>For geolocation resource record sets, the two-letter code for a country.</p> <p>Amazon Route 53 uses the two-letter country codes that are specified in <a href='https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2'>ISO standard 3166-1 alpha-2</a>.</p> <p>Route 53 also supports the country code <b>UA</b> for Ukraine.</p>
        """
        return pulumi.get(self, "country_code")

    @property
    @pulumi.getter(name="subdivisionCode")
    def subdivision_code(self) -> Optional[str]:
        """
        <p>For geolocation resource record sets, the two-letter code for a state of the United States. Route 53 doesn't support any other values for <code>SubdivisionCode</code>. For a list of state abbreviations, see <a href='https://pe.usps.com/text/pub28/28apb.htm'>Appendix B: TwoLetter State and Possession Abbreviations</a> on the United States Postal Service website. </p> <p>If you specify <code>subdivisioncode</code>, you must also specify <code>US</code> for <code>CountryCode</code>. </p>
        """
        return pulumi.get(self, "subdivision_code")


@pulumi.output_type
class GeoProximityLocationResponse(dict):
    """
    Definition of GeoProximityLocation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsRegion":
            suggest = "aws_region"
        elif key == "localZoneGroup":
            suggest = "local_zone_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GeoProximityLocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GeoProximityLocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GeoProximityLocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_region: Optional[str] = None,
                 bias: Optional[int] = None,
                 coordinates: Optional['outputs.CoordinatesResponse'] = None,
                 local_zone_group: Optional[str] = None):
        """
        Definition of GeoProximityLocation
        :param str aws_region: <p> The Amazon Web Services Region the resource you are directing DNS traffic to, is in. </p>
        :param int bias: <p> The bias increases or decreases the size of the geographic region from which Route53 routes traffic to a resource. </p> <p>To use <code>Bias</code> to change the size of the geographic region, specify the applicable value for the bias:</p> <ul> <li> <p>To expand the size of the geographic region from which Route53 routes traffic to a resource, specify a positive integer from 1 to 99 for the bias. Route53 shrinks the size of adjacent regions. </p> </li> <li> <p>To shrink the size of the geographic region from which Route53 routes traffic to a resource, specify a negative bias of -1 to -99. Route53 expands the size of adjacent regions. </p> </li> </ul>
        :param 'CoordinatesResponse' coordinates: <p> Contains the longitude and latitude for a geographic region. </p>
        :param str local_zone_group: <p> Specifies an Amazon Web Services Local Zone Group. </p> <p>A local Zone Group is usually the Local Zone code without the ending character. For example, if the Local Zone is <code>us-east-1-bue-1a</code> the Local Zone Group is <code>us-east-1-bue-1</code>.</p> <p>You can identify the Local Zones Group for a specific Local Zone by using the <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-availability-zones.html'>describe-availability-zones</a> CLI command:</p> <p>This command returns: <code>'GroupName': 'us-west-2-den-1'</code>, specifying that the Local Zone <code>us-west-2-den-1a</code> belongs to the Local Zone Group <code>us-west-2-den-1</code>.</p>
        """
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if coordinates is not None:
            pulumi.set(__self__, "coordinates", coordinates)
        if local_zone_group is not None:
            pulumi.set(__self__, "local_zone_group", local_zone_group)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        <p> The Amazon Web Services Region the resource you are directing DNS traffic to, is in. </p>
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter
    def bias(self) -> Optional[int]:
        """
        <p> The bias increases or decreases the size of the geographic region from which Route53 routes traffic to a resource. </p> <p>To use <code>Bias</code> to change the size of the geographic region, specify the applicable value for the bias:</p> <ul> <li> <p>To expand the size of the geographic region from which Route53 routes traffic to a resource, specify a positive integer from 1 to 99 for the bias. Route53 shrinks the size of adjacent regions. </p> </li> <li> <p>To shrink the size of the geographic region from which Route53 routes traffic to a resource, specify a negative bias of -1 to -99. Route53 expands the size of adjacent regions. </p> </li> </ul>
        """
        return pulumi.get(self, "bias")

    @property
    @pulumi.getter
    def coordinates(self) -> Optional['outputs.CoordinatesResponse']:
        """
        <p> Contains the longitude and latitude for a geographic region. </p>
        """
        return pulumi.get(self, "coordinates")

    @property
    @pulumi.getter(name="localZoneGroup")
    def local_zone_group(self) -> Optional[str]:
        """
        <p> Specifies an Amazon Web Services Local Zone Group. </p> <p>A local Zone Group is usually the Local Zone code without the ending character. For example, if the Local Zone is <code>us-east-1-bue-1a</code> the Local Zone Group is <code>us-east-1-bue-1</code>.</p> <p>You can identify the Local Zones Group for a specific Local Zone by using the <a href='https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-availability-zones.html'>describe-availability-zones</a> CLI command:</p> <p>This command returns: <code>'GroupName': 'us-west-2-den-1'</code>, specifying that the Local Zone <code>us-west-2-den-1a</code> belongs to the Local Zone Group <code>us-west-2-den-1</code>.</p>
        """
        return pulumi.get(self, "local_zone_group")


@pulumi.output_type
class GeoRestrictionResponse(dict):
    """
    Definition of GeoRestriction
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionType":
            suggest = "restriction_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GeoRestrictionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GeoRestrictionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GeoRestrictionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locations: Optional[Sequence[str]] = None,
                 restriction_type: Optional[str] = None):
        """
        Definition of GeoRestriction
        :param Sequence[str] locations: A complex type that contains a ``Location`` element for each country in which you want CloudFront either to distribute your content or not distribute your content.
        :param str restriction_type: The method that you want to use to restrict distribution of your content by country.
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if restriction_type is not None:
            pulumi.set(__self__, "restriction_type", restriction_type)

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        """
        A complex type that contains a ``Location`` element for each country in which you want CloudFront either to distribute your content or not distribute your content.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="restrictionType")
    def restriction_type(self) -> Optional[str]:
        """
        The method that you want to use to restrict distribution of your content by country.
        """
        return pulumi.get(self, "restriction_type")


@pulumi.output_type
class GitSubmodulesConfigResponse(dict):
    """
    Definition of GitSubmodulesConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fetchSubmodules":
            suggest = "fetch_submodules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitSubmodulesConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitSubmodulesConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitSubmodulesConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fetch_submodules: Optional[bool] = None):
        """
        Definition of GitSubmodulesConfig
        :param bool fetch_submodules: <p> Set to true to fetch Git submodules for your CodeBuild build project. </p>
        """
        if fetch_submodules is not None:
            pulumi.set(__self__, "fetch_submodules", fetch_submodules)

    @property
    @pulumi.getter(name="fetchSubmodules")
    def fetch_submodules(self) -> Optional[bool]:
        """
        <p> Set to true to fetch Git submodules for your CodeBuild build project. </p>
        """
        return pulumi.get(self, "fetch_submodules")


@pulumi.output_type
class GlobalSecondaryIndexResponse(dict):
    """
    Definition of GlobalSecondaryIndex
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contributorInsightsSpecification":
            suggest = "contributor_insights_specification"
        elif key == "indexName":
            suggest = "index_name"
        elif key == "keySchema":
            suggest = "key_schema"
        elif key == "provisionedThroughput":
            suggest = "provisioned_throughput"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalSecondaryIndexResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalSecondaryIndexResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalSecondaryIndexResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contributor_insights_specification: Optional['outputs.ContributorInsightsSpecificationResponse'] = None,
                 index_name: Optional[str] = None,
                 key_schema: Optional[Sequence['outputs.KeySchemaResponse']] = None,
                 projection: Optional['outputs.ProjectionResponse'] = None,
                 provisioned_throughput: Optional['outputs.ProvisionedThroughputResponse'] = None):
        """
        Definition of GlobalSecondaryIndex
        :param 'ContributorInsightsSpecificationResponse' contributor_insights_specification: The settings used to enable or disable CloudWatch Contributor Insights for the specified global secondary index. The settings used to enable or disable CloudWatch Contributor Insights.
        :param str index_name: The name of the global secondary index. The name must be unique among all other indexes on this table.
        :param Sequence['KeySchemaResponse'] key_schema: The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:  +   ``HASH`` - partition key  +   ``RANGE`` - sort key    The partition key of an item is also known as its *hash attribute*. The term 'hash attribute' derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values. The sort key of an item is also known as its *range attribute*. The term 'range attribute' derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        :param 'ProjectionResponse' projection: Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        :param 'ProvisionedThroughputResponse' provisioned_throughput: Represents the provisioned throughput settings for the specified global secondary index. For current minimum and maximum provisioned throughput values, see [Service, Account, and Table Quotas](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the *Amazon DynamoDB Developer Guide*. Throughput for the specified table, which consists of values for ``ReadCapacityUnits`` and ``WriteCapacityUnits``. For more information about the contents of a provisioned throughput structure, see [Table ProvisionedThroughput](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ProvisionedThroughput.html).
        """
        if contributor_insights_specification is not None:
            pulumi.set(__self__, "contributor_insights_specification", contributor_insights_specification)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if key_schema is not None:
            pulumi.set(__self__, "key_schema", key_schema)
        if projection is not None:
            pulumi.set(__self__, "projection", projection)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)

    @property
    @pulumi.getter(name="contributorInsightsSpecification")
    def contributor_insights_specification(self) -> Optional['outputs.ContributorInsightsSpecificationResponse']:
        """
        The settings used to enable or disable CloudWatch Contributor Insights for the specified global secondary index. The settings used to enable or disable CloudWatch Contributor Insights.
        """
        return pulumi.get(self, "contributor_insights_specification")

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[str]:
        """
        The name of the global secondary index. The name must be unique among all other indexes on this table.
        """
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> Optional[Sequence['outputs.KeySchemaResponse']]:
        """
        The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:  +   ``HASH`` - partition key  +   ``RANGE`` - sort key    The partition key of an item is also known as its *hash attribute*. The term 'hash attribute' derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values. The sort key of an item is also known as its *range attribute*. The term 'range attribute' derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_schema")

    @property
    @pulumi.getter
    def projection(self) -> Optional['outputs.ProjectionResponse']:
        """
        Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        return pulumi.get(self, "projection")

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional['outputs.ProvisionedThroughputResponse']:
        """
        Represents the provisioned throughput settings for the specified global secondary index. For current minimum and maximum provisioned throughput values, see [Service, Account, and Table Quotas](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the *Amazon DynamoDB Developer Guide*. Throughput for the specified table, which consists of values for ``ReadCapacityUnits`` and ``WriteCapacityUnits``. For more information about the contents of a provisioned throughput structure, see [Table ProvisionedThroughput](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ProvisionedThroughput.html).
        """
        return pulumi.get(self, "provisioned_throughput")


@pulumi.output_type
class GraphQLApiIntrospectionConfigEnumValueResponse(dict):
    """
    Definition of GraphQLApiIntrospectionConfigEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of GraphQLApiIntrospectionConfigEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GraphQLApiTypeEnumValueResponse(dict):
    """
    Definition of GraphQLApiTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of GraphQLApiTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GraphQLApiVisibilityEnumValueResponse(dict):
    """
    Definition of GraphQLApiVisibilityEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of GraphQLApiVisibilityEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GroupIdentifierResponse(dict):
    """
    Definition of GroupIdentifier
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupIdentifierResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupIdentifierResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupIdentifierResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 group_name: Optional[str] = None):
        """
        Definition of GroupIdentifier
        :param str group_id: <p>The ID of the security group.</p>
        :param str group_name: <p>The name of the security group.</p>
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        <p>The ID of the security group.</p>
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        <p>The name of the security group.</p>
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class GuardDutyDetectorPropertiesResponse(dict):
    """
    Definition of GuardDutyDetector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardDutyDetectorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardDutyDetectorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardDutyDetectorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsGuardDutyDetectorPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of GuardDutyDetector
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsGuardDutyDetectorPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsGuardDutyDetectorPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class HardwareResponse(dict):
    """
    Definition of Hardware
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCount":
            suggest = "cpu_count"
        elif key == "ramSizeInGb":
            suggest = "ram_size_in_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HardwareResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HardwareResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HardwareResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_count: Optional[int] = None,
                 disks: Optional[Sequence['outputs.DiskResponse']] = None,
                 ram_size_in_gb: Optional[int] = None):
        """
        Definition of Hardware
        :param int cpu_count: CPU count of the Instance.
        :param Sequence['DiskResponse'] disks: Disks attached to the Instance.
        :param int ram_size_in_gb: RAM Size of the Instance.
        """
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if ram_size_in_gb is not None:
            pulumi.set(__self__, "ram_size_in_gb", ram_size_in_gb)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[int]:
        """
        CPU count of the Instance.
        """
        return pulumi.get(self, "cpu_count")

    @property
    @pulumi.getter
    def disks(self) -> Optional[Sequence['outputs.DiskResponse']]:
        """
        Disks attached to the Instance.
        """
        return pulumi.get(self, "disks")

    @property
    @pulumi.getter(name="ramSizeInGb")
    def ram_size_in_gb(self) -> Optional[int]:
        """
        RAM Size of the Instance.
        """
        return pulumi.get(self, "ram_size_in_gb")


@pulumi.output_type
class HeaderResponse(dict):
    """
    Definition of Header
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPort":
            suggest = "destination_port"
        elif key == "sourcePort":
            suggest = "source_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeaderResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeaderResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeaderResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[str] = None,
                 destination_port: Optional[str] = None,
                 direction: Optional[str] = None,
                 protocol: Optional[str] = None,
                 source: Optional[str] = None,
                 source_port: Optional[str] = None):
        """
        Definition of Header
        :param str destination: Property destination
        :param str destination_port: Property destinationPort
        :param str direction: Property direction
        :param str protocol: Property protocol
        :param str source: Property source
        :param str source_port: Property sourcePort
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        """
        Property destination
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[str]:
        """
        Property destinationPort
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Property direction
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Property protocol
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Property source
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[str]:
        """
        Property sourcePort
        """
        return pulumi.get(self, "source_port")


@pulumi.output_type
class HealthCheckResponse(dict):
    """
    Definition of HealthCheck
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startPeriod":
            suggest = "start_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: Optional[Sequence[str]] = None,
                 interval: Optional[int] = None,
                 retries: Optional[int] = None,
                 start_period: Optional[int] = None,
                 timeout: Optional[int] = None):
        """
        Definition of HealthCheck
        :param Sequence[str] command: A string array representing the command that the container runs to determine if it is healthy. The string array must start with ``CMD`` to run the command arguments directly, or ``CMD-SHELL`` to run the command with the container's default shell.   When you use the AWS Management Console JSON panel, the CLIlong, or the APIs, enclose the list of commands in double quotes and brackets.  ``[ 'CMD-SHELL', 'curl -f http://localhost/ || exit 1' ]``  You don't include the double quotes and brackets when you use the AWS Management Console.  ``CMD-SHELL, curl -f http://localhost/ || exit 1``  An exit code of 0 indicates success, and non-zero exit code indicates failure. For more information, see ``HealthCheck`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/).
        :param int interval: The time period in seconds between each health check execution. You may specify between 5 and 300 seconds. The default value is 30 seconds.
        :param int retries: The number of times to retry a failed health check before the container is considered unhealthy. You may specify between 1 and 10 retries. The default value is 3.
        :param int start_period: The optional grace period to provide containers time to bootstrap before failed health checks count towards the maximum number of retries. You can specify between 0 and 300 seconds. By default, the ``startPeriod`` is off.  If a health check succeeds within the ``startPeriod``, then the container is considered healthy and any subsequent failures count toward the maximum number of retries.
        :param int timeout: The time period in seconds to wait for a health check to succeed before it is considered a failure. You may specify between 2 and 60 seconds. The default value is 5.
        """
        if command is not None:
            pulumi.set(__self__, "command", command)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if start_period is not None:
            pulumi.set(__self__, "start_period", start_period)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[str]]:
        """
        A string array representing the command that the container runs to determine if it is healthy. The string array must start with ``CMD`` to run the command arguments directly, or ``CMD-SHELL`` to run the command with the container's default shell.   When you use the AWS Management Console JSON panel, the CLIlong, or the APIs, enclose the list of commands in double quotes and brackets.  ``[ 'CMD-SHELL', 'curl -f http://localhost/ || exit 1' ]``  You don't include the double quotes and brackets when you use the AWS Management Console.  ``CMD-SHELL, curl -f http://localhost/ || exit 1``  An exit code of 0 indicates success, and non-zero exit code indicates failure. For more information, see ``HealthCheck`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/).
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The time period in seconds between each health check execution. You may specify between 5 and 300 seconds. The default value is 30 seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        The number of times to retry a failed health check before the container is considered unhealthy. You may specify between 1 and 10 retries. The default value is 3.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter(name="startPeriod")
    def start_period(self) -> Optional[int]:
        """
        The optional grace period to provide containers time to bootstrap before failed health checks count towards the maximum number of retries. You can specify between 0 and 300 seconds. By default, the ``startPeriod`` is off.  If a health check succeeds within the ``startPeriod``, then the container is considered healthy and any subsequent failures count toward the maximum number of retries.
        """
        return pulumi.get(self, "start_period")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The time period in seconds to wait for a health check to succeed before it is considered a failure. You may specify between 2 and 60 seconds. The default value is 5.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class HibernationOptionsResponse(dict):
    """
    Definition of HibernationOptions
    """
    def __init__(__self__, *,
                 configured: Optional[bool] = None):
        """
        Definition of HibernationOptions
        :param bool configured: <p>If <code>true</code>, your instance is enabled for hibernation; otherwise, it is not enabled for hibernation.</p>
        """
        if configured is not None:
            pulumi.set(__self__, "configured", configured)

    @property
    @pulumi.getter
    def configured(self) -> Optional[bool]:
        """
        <p>If <code>true</code>, your instance is enabled for hibernation; otherwise, it is not enabled for hibernation.</p>
        """
        return pulumi.get(self, "configured")


@pulumi.output_type
class HostEntryResponse(dict):
    """
    Definition of HostEntry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostEntryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostEntryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostEntryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 ip_address: Optional[str] = None):
        """
        Definition of HostEntry
        :param str hostname: The hostname to use in the ``/etc/hosts`` entry.
        :param str ip_address: The IP address to use in the ``/etc/hosts`` entry.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        The hostname to use in the ``/etc/hosts`` entry.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP address to use in the ``/etc/hosts`` entry.
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class HostVolumePropertiesResponse(dict):
    """
    Definition of HostVolumeProperties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePath":
            suggest = "source_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostVolumePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostVolumePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostVolumePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_path: Optional[str] = None):
        """
        Definition of HostVolumeProperties
        :param str source_path: When the ``host`` parameter is used, specify a ``sourcePath`` to declare the path on the host container instance that's presented to the container. If this parameter is empty, then the Docker daemon has assigned a host path for you. If the ``host`` parameter contains a ``sourcePath`` file location, then the data volume persists at the specified location on the host container instance until you delete it manually. If the ``sourcePath`` value doesn't exist on the host container instance, the Docker daemon creates it. If the location does exist, the contents of the source path folder are exported. If you're using the Fargate launch type, the ``sourcePath`` parameter is not supported.
        """
        if source_path is not None:
            pulumi.set(__self__, "source_path", source_path)

    @property
    @pulumi.getter(name="sourcePath")
    def source_path(self) -> Optional[str]:
        """
        When the ``host`` parameter is used, specify a ``sourcePath`` to declare the path on the host container instance that's presented to the container. If this parameter is empty, then the Docker daemon has assigned a host path for you. If the ``host`` parameter contains a ``sourcePath`` file location, then the data volume persists at the specified location on the host container instance until you delete it manually. If the ``sourcePath`` value doesn't exist on the host container instance, the Docker daemon creates it. If the location does exist, the contents of the source path folder are exported. If you're using the Fargate launch type, the ``sourcePath`` parameter is not supported.
        """
        return pulumi.get(self, "source_path")


@pulumi.output_type
class HostedZoneConfigResponse(dict):
    """
    Definition of HostedZoneConfig
    """
    def __init__(__self__, *,
                 comment: Optional[str] = None):
        """
        Definition of HostedZoneConfig
        :param str comment: Any comments that you want to include about the hosted zone.
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Any comments that you want to include about the hosted zone.
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class HostedZoneTagResponse(dict):
    """
    Definition of HostedZoneTag
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of HostedZoneTag
        :param str key: The value of ``Key`` depends on the operation that you want to perform:  +   *Add a tag to a health check or hosted zone*: ``Key`` is the name that you want to give the new tag.  +   *Edit a tag*: ``Key`` is the name of the tag that you want to change the ``Value`` for.  +   *Delete a key*: ``Key`` is the name of the tag you want to remove.  +   *Give a name to a health check*: Edit the default ``Name`` tag. In the Amazon Route 53 console, the list of your health checks includes a *Name* column that lets you see the name that you've given to each health check.
        :param str value: The value of ``Value`` depends on the operation that you want to perform:  +   *Add a tag to a health check or hosted zone*: ``Value`` is the value that you want to give the new tag.  +   *Edit a tag*: ``Value`` is the new value that you want to assign the tag.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The value of ``Key`` depends on the operation that you want to perform:  +   *Add a tag to a health check or hosted zone*: ``Key`` is the name that you want to give the new tag.  +   *Edit a tag*: ``Key`` is the name of the tag that you want to change the ``Value`` for.  +   *Delete a key*: ``Key`` is the name of the tag you want to remove.  +   *Give a name to a health check*: Edit the default ``Name`` tag. In the Amazon Route 53 console, the list of your health checks includes a *Name* column that lets you see the name that you've given to each health check.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of ``Value`` depends on the operation that you want to perform:  +   *Add a tag to a health check or hosted zone*: ``Value`` is the value that you want to give the new tag.  +   *Edit a tag*: ``Value`` is the new value that you want to assign the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostnameTypeEnumValueResponse(dict):
    """
    Definition of HostnameTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of HostnameTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HttpTokensStateEnumValueResponse(dict):
    """
    Definition of HttpTokensStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of HttpTokensStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HypervisorTypeEnumValueResponse(dict):
    """
    Definition of HypervisorTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of HypervisorTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IPAddressTypeEnumValueResponse(dict):
    """
    Definition of IPAddressTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of IPAddressTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IPSetReferenceResponse(dict):
    """
    Definition of IPSetReference
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceArn":
            suggest = "reference_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IPSetReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IPSetReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IPSetReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_arn: Optional[str] = None):
        """
        Definition of IPSetReference
        :param str reference_arn: A resource ARN.
        """
        if reference_arn is not None:
            pulumi.set(__self__, "reference_arn", reference_arn)

    @property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> Optional[str]:
        """
        A resource ARN.
        """
        return pulumi.get(self, "reference_arn")


@pulumi.output_type
class IPSetResponse(dict):
    """
    Definition of IPSet
    """
    def __init__(__self__, *,
                 definition: Optional[Sequence[str]] = None):
        """
        Definition of IPSet
        :param Sequence[str] definition: Property definition
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[Sequence[str]]:
        """
        Property definition
        """
        return pulumi.get(self, "definition")


@pulumi.output_type
class IamAccessKeyLastUsedPropertiesResponse(dict):
    """
    Definition of IamAccessKeyLastUsed
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamAccessKeyLastUsedPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamAccessKeyLastUsedPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamAccessKeyLastUsedPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamAccessKeyLastUsedPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamAccessKeyLastUsed
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamAccessKeyLastUsedPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamAccessKeyLastUsedPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IamAccessKeyMetadataPropertiesResponse(dict):
    """
    Definition of IamAccessKeyMetadata
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamAccessKeyMetadataPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamAccessKeyMetadataPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamAccessKeyMetadataPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamAccessKeyMetadataPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamAccessKeyMetadata
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamAccessKeyMetadataPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamAccessKeyMetadataPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IamGroupPropertiesResponse(dict):
    """
    Definition of IamGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamGroupPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamGroup
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamGroupPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamGroupPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IamInstanceProfilePropertiesResponse(dict):
    """
    Definition of IamInstanceProfile
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamInstanceProfilePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamInstanceProfilePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamInstanceProfilePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamInstanceProfilePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamInstanceProfile
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamInstanceProfilePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamInstanceProfilePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IamInstanceProfileResponse(dict):
    """
    Definition of IamInstanceProfile
    """
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None):
        """
        Definition of IamInstanceProfile
        :param str arn: <p>The Amazon Resource Name (ARN) of the instance profile.</p>
        :param str id: <p>The ID of the instance profile.</p>
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the instance profile.</p>
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        <p>The ID of the instance profile.</p>
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class IamMFADevicePropertiesResponse(dict):
    """
    Definition of IamMFADevice
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamMFADevicePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamMFADevicePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamMFADevicePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamMFADevicePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamMFADevice
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamMFADevicePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamMFADevicePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IamPasswordPolicyPropertiesResponse(dict):
    """
    Definition of IamPasswordPolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamPasswordPolicyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamPasswordPolicyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamPasswordPolicyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamPasswordPolicyPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamPasswordPolicy
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamPasswordPolicyPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamPasswordPolicyPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IamPolicyVersionPropertiesResponse(dict):
    """
    Definition of IamPolicyVersion
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamPolicyVersionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamPolicyVersionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamPolicyVersionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamPolicyVersionPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamPolicyVersion
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamPolicyVersionPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamPolicyVersionPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IamRolePropertiesResponse(dict):
    """
    Definition of IamRole
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamRolePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamRolePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamRolePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamRolePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamRole
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamRolePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamRolePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IamServerCertificatePropertiesResponse(dict):
    """
    Definition of IamServerCertificate
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamServerCertificatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamServerCertificatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamServerCertificatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamServerCertificatePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamServerCertificate
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamServerCertificatePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamServerCertificatePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IamVirtualMFADevicePropertiesResponse(dict):
    """
    Definition of IamVirtualMFADevice
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamVirtualMFADevicePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamVirtualMFADevicePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamVirtualMFADevicePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsIamVirtualMFADevicePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of IamVirtualMFADevice
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsIamVirtualMFADevicePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsIamVirtualMFADevicePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Definition of Identity
    """
    def __init__(__self__, *,
                 oidc: Optional['outputs.OIDCResponse'] = None):
        """
        Definition of Identity
        :param 'OIDCResponse' oidc: <p>An object representing the <a href='https://openid.net/connect/'>OpenID Connect</a> identity provider information.</p>
        """
        if oidc is not None:
            pulumi.set(__self__, "oidc", oidc)

    @property
    @pulumi.getter
    def oidc(self) -> Optional['outputs.OIDCResponse']:
        """
        <p>An object representing the <a href='https://openid.net/connect/'>OpenID Connect</a> identity provider information.</p>
        """
        return pulumi.get(self, "oidc")


@pulumi.output_type
class ImageConfigResponse(dict):
    """
    Definition of ImageConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoint":
            suggest = "entry_point"
        elif key == "workingDirectory":
            suggest = "working_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command: Optional[Sequence[str]] = None,
                 entry_point: Optional[Sequence[str]] = None,
                 working_directory: Optional[str] = None):
        """
        Definition of ImageConfig
        :param Sequence[str] command: Specifies parameters that you want to pass in with ENTRYPOINT. You can specify a maximum of 1,500 parameters in the list.
        :param Sequence[str] entry_point: Specifies the entry point to their application, which is typically the location of the runtime executable. You can specify a maximum of 1,500 string entries in the list.
        :param str working_directory: Specifies the working directory. The length of the directory string cannot exceed 1,000 characters.
        """
        if command is not None:
            pulumi.set(__self__, "command", command)
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[str]]:
        """
        Specifies parameters that you want to pass in with ENTRYPOINT. You can specify a maximum of 1,500 parameters in the list.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[Sequence[str]]:
        """
        Specifies the entry point to their application, which is typically the location of the runtime executable. You can specify a maximum of 1,500 string entries in the list.
        """
        return pulumi.get(self, "entry_point")

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[str]:
        """
        Specifies the working directory. The length of the directory string cannot exceed 1,000 characters.
        """
        return pulumi.get(self, "working_directory")


@pulumi.output_type
class ImagePullCredentialsTypeEnumValueResponse(dict):
    """
    Definition of ImagePullCredentialsTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ImagePullCredentialsTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ImageScanFindingsSummaryResponse(dict):
    """
    Definition of ImageScanFindingsSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "findingSeverityCounts":
            suggest = "finding_severity_counts"
        elif key == "imageScanCompletedAt":
            suggest = "image_scan_completed_at"
        elif key == "vulnerabilitySourceUpdatedAt":
            suggest = "vulnerability_source_updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageScanFindingsSummaryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageScanFindingsSummaryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageScanFindingsSummaryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 finding_severity_counts: Optional[Mapping[str, int]] = None,
                 image_scan_completed_at: Optional[str] = None,
                 vulnerability_source_updated_at: Optional[str] = None):
        """
        Definition of ImageScanFindingsSummary
        :param Mapping[str, int] finding_severity_counts: <p>The image vulnerability counts, sorted by severity.</p>
        :param str image_scan_completed_at: <p>The time of the last completed image scan.</p>
        :param str vulnerability_source_updated_at: <p>The time when the vulnerability data was last scanned.</p>
        """
        if finding_severity_counts is not None:
            pulumi.set(__self__, "finding_severity_counts", finding_severity_counts)
        if image_scan_completed_at is not None:
            pulumi.set(__self__, "image_scan_completed_at", image_scan_completed_at)
        if vulnerability_source_updated_at is not None:
            pulumi.set(__self__, "vulnerability_source_updated_at", vulnerability_source_updated_at)

    @property
    @pulumi.getter(name="findingSeverityCounts")
    def finding_severity_counts(self) -> Optional[Mapping[str, int]]:
        """
        <p>The image vulnerability counts, sorted by severity.</p>
        """
        return pulumi.get(self, "finding_severity_counts")

    @property
    @pulumi.getter(name="imageScanCompletedAt")
    def image_scan_completed_at(self) -> Optional[str]:
        """
        <p>The time of the last completed image scan.</p>
        """
        return pulumi.get(self, "image_scan_completed_at")

    @property
    @pulumi.getter(name="vulnerabilitySourceUpdatedAt")
    def vulnerability_source_updated_at(self) -> Optional[str]:
        """
        <p>The time when the vulnerability data was last scanned.</p>
        """
        return pulumi.get(self, "vulnerability_source_updated_at")


@pulumi.output_type
class ImageScanStatusResponse(dict):
    """
    Definition of ImageScanStatus
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 status: Optional['outputs.ScanStatusEnumValueResponse'] = None):
        """
        Definition of ImageScanStatus
        :param str description: <p>The description of the image scan status.</p>
        :param 'ScanStatusEnumValueResponse' status: <p>The current state of an image scan.</p>
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>The description of the image scan status.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.ScanStatusEnumValueResponse']:
        """
        <p>The current state of an image scan.</p>
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ImageScanningConfigurationResponse(dict):
    """
    Definition of ImageScanningConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scanOnPush":
            suggest = "scan_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImageScanningConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImageScanningConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImageScanningConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scan_on_push: Optional[bool] = None):
        """
        Definition of ImageScanningConfiguration
        :param bool scan_on_push: The setting that determines whether images are scanned after being pushed to a repository. If set to ``true``, images will be scanned after being pushed. If this parameter is not specified, it will default to ``false`` and images will not be scanned unless a scan is manually started. The setting that determines whether images are scanned after being pushed to a repository.
        """
        if scan_on_push is not None:
            pulumi.set(__self__, "scan_on_push", scan_on_push)

    @property
    @pulumi.getter(name="scanOnPush")
    def scan_on_push(self) -> Optional[bool]:
        """
        The setting that determines whether images are scanned after being pushed to a repository. If set to ``true``, images will be scanned after being pushed. If this parameter is not specified, it will default to ``false`` and images will not be scanned unless a scan is manually started. The setting that determines whether images are scanned after being pushed to a repository.
        """
        return pulumi.get(self, "scan_on_push")


@pulumi.output_type
class ImageStateEnumValueResponse(dict):
    """
    Definition of ImageStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ImageStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ImageTypeValuesEnumValueResponse(dict):
    """
    Definition of ImageTypeValuesEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ImageTypeValuesEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ImdsSupportValuesEnumValueResponse(dict):
    """
    Definition of ImdsSupportValuesEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ImdsSupportValuesEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ImportSourceSpecificationResponse(dict):
    """
    Definition of ImportSourceSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputCompressionType":
            suggest = "input_compression_type"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "inputFormatOptions":
            suggest = "input_format_options"
        elif key == "s3BucketSource":
            suggest = "s3_bucket_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImportSourceSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImportSourceSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImportSourceSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_compression_type: Optional[str] = None,
                 input_format: Optional[str] = None,
                 input_format_options: Optional['outputs.InputFormatOptionsResponse'] = None,
                 s3_bucket_source: Optional['outputs.S3BucketSourceResponse'] = None):
        """
        Definition of ImportSourceSpecification
        :param str input_compression_type: Type of compression to be used on the input coming from the imported table.
        :param str input_format: The format of the source data. Valid values for ``ImportFormat`` are ``CSV``, ``DYNAMODB_JSON`` or ``ION``.
        :param 'InputFormatOptionsResponse' input_format_options: Additional properties that specify how the input is formatted, The format options for the data that was imported into the target table. There is one value, CsvOption.
        :param 'S3BucketSourceResponse' s3_bucket_source: The S3 bucket that provides the source for the import. The S3 bucket that is being imported from.
        """
        if input_compression_type is not None:
            pulumi.set(__self__, "input_compression_type", input_compression_type)
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if input_format_options is not None:
            pulumi.set(__self__, "input_format_options", input_format_options)
        if s3_bucket_source is not None:
            pulumi.set(__self__, "s3_bucket_source", s3_bucket_source)

    @property
    @pulumi.getter(name="inputCompressionType")
    def input_compression_type(self) -> Optional[str]:
        """
        Type of compression to be used on the input coming from the imported table.
        """
        return pulumi.get(self, "input_compression_type")

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[str]:
        """
        The format of the source data. Valid values for ``ImportFormat`` are ``CSV``, ``DYNAMODB_JSON`` or ``ION``.
        """
        return pulumi.get(self, "input_format")

    @property
    @pulumi.getter(name="inputFormatOptions")
    def input_format_options(self) -> Optional['outputs.InputFormatOptionsResponse']:
        """
        Additional properties that specify how the input is formatted, The format options for the data that was imported into the target table. There is one value, CsvOption.
        """
        return pulumi.get(self, "input_format_options")

    @property
    @pulumi.getter(name="s3BucketSource")
    def s3_bucket_source(self) -> Optional['outputs.S3BucketSourceResponse']:
        """
        The S3 bucket that provides the source for the import. The S3 bucket that is being imported from.
        """
        return pulumi.get(self, "s3_bucket_source")


@pulumi.output_type
class InferenceAcceleratorResponse(dict):
    """
    Definition of InferenceAccelerator
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deviceType":
            suggest = "device_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InferenceAcceleratorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InferenceAcceleratorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InferenceAcceleratorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 device_type: Optional[str] = None):
        """
        Definition of InferenceAccelerator
        :param str device_name: The Elastic Inference accelerator device name. The ``deviceName`` must also be referenced in a container definition as a [ResourceRequirement](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ResourceRequirement.html).
        :param str device_type: The Elastic Inference accelerator type to use.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        The Elastic Inference accelerator device name. The ``deviceName`` must also be referenced in a container definition as a [ResourceRequirement](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ResourceRequirement.html).
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[str]:
        """
        The Elastic Inference accelerator type to use.
        """
        return pulumi.get(self, "device_type")


@pulumi.output_type
class InitiatedByEnumValueResponse(dict):
    """
    Definition of InitiatedByEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InitiatedByEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InputFormatOptionsResponse(dict):
    """
    Definition of InputFormatOptions
    """
    def __init__(__self__, *,
                 csv: Optional['outputs.CsvResponse'] = None):
        """
        Definition of InputFormatOptions
        :param 'CsvResponse' csv: The options for imported source files in CSV format. The values are Delimiter and HeaderList. The options for imported source files in CSV format. The values are Delimiter and HeaderList.
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)

    @property
    @pulumi.getter
    def csv(self) -> Optional['outputs.CsvResponse']:
        """
        The options for imported source files in CSV format. The values are Delimiter and HeaderList. The options for imported source files in CSV format. The values are Delimiter and HeaderList.
        """
        return pulumi.get(self, "csv")


@pulumi.output_type
class InsightSelectorResponse(dict):
    """
    Definition of InsightSelector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insightType":
            suggest = "insight_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InsightSelectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InsightSelectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InsightSelectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insight_type: Optional[str] = None):
        """
        Definition of InsightSelector
        :param str insight_type: The type of insight to log on a trail.
        """
        if insight_type is not None:
            pulumi.set(__self__, "insight_type", insight_type)

    @property
    @pulumi.getter(name="insightType")
    def insight_type(self) -> Optional[str]:
        """
        The type of insight to log on a trail.
        """
        return pulumi.get(self, "insight_type")


@pulumi.output_type
class InstanceAggregatedAssociationOverviewResponse(dict):
    """
    Definition of InstanceAggregatedAssociationOverview
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detailedStatus":
            suggest = "detailed_status"
        elif key == "instanceAssociationStatusAggregatedCount":
            suggest = "instance_association_status_aggregated_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceAggregatedAssociationOverviewResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceAggregatedAssociationOverviewResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceAggregatedAssociationOverviewResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detailed_status: Optional[str] = None,
                 instance_association_status_aggregated_count: Optional[Mapping[str, int]] = None):
        """
        Definition of InstanceAggregatedAssociationOverview
        :param str detailed_status: <p>Detailed status information about the aggregated associations.</p>
        :param Mapping[str, int] instance_association_status_aggregated_count: <p>The number of associations for the managed nodes.</p>
        """
        if detailed_status is not None:
            pulumi.set(__self__, "detailed_status", detailed_status)
        if instance_association_status_aggregated_count is not None:
            pulumi.set(__self__, "instance_association_status_aggregated_count", instance_association_status_aggregated_count)

    @property
    @pulumi.getter(name="detailedStatus")
    def detailed_status(self) -> Optional[str]:
        """
        <p>Detailed status information about the aggregated associations.</p>
        """
        return pulumi.get(self, "detailed_status")

    @property
    @pulumi.getter(name="instanceAssociationStatusAggregatedCount")
    def instance_association_status_aggregated_count(self) -> Optional[Mapping[str, int]]:
        """
        <p>The number of associations for the managed nodes.</p>
        """
        return pulumi.get(self, "instance_association_status_aggregated_count")


@pulumi.output_type
class InstanceAttachmentEnaSrdSpecificationResponse(dict):
    """
    Definition of InstanceAttachmentEnaSrdSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdEnabled":
            suggest = "ena_srd_enabled"
        elif key == "enaSrdUdpSpecification":
            suggest = "ena_srd_udp_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceAttachmentEnaSrdSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceAttachmentEnaSrdSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceAttachmentEnaSrdSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_enabled: Optional[bool] = None,
                 ena_srd_udp_specification: Optional['outputs.InstanceAttachmentEnaSrdUdpSpecificationResponse'] = None):
        """
        Definition of InstanceAttachmentEnaSrdSpecification
        :param bool ena_srd_enabled: <p>Indicates whether ENA Express is enabled for the network interface.</p>
        :param 'InstanceAttachmentEnaSrdUdpSpecificationResponse' ena_srd_udp_specification: <p>Configures ENA Express for UDP network traffic.</p>
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[bool]:
        """
        <p>Indicates whether ENA Express is enabled for the network interface.</p>
        """
        return pulumi.get(self, "ena_srd_enabled")

    @property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional['outputs.InstanceAttachmentEnaSrdUdpSpecificationResponse']:
        """
        <p>Configures ENA Express for UDP network traffic.</p>
        """
        return pulumi.get(self, "ena_srd_udp_specification")


@pulumi.output_type
class InstanceAttachmentEnaSrdUdpSpecificationResponse(dict):
    """
    Definition of InstanceAttachmentEnaSrdUdpSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdUdpEnabled":
            suggest = "ena_srd_udp_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceAttachmentEnaSrdUdpSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceAttachmentEnaSrdUdpSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceAttachmentEnaSrdUdpSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[bool] = None):
        """
        Definition of InstanceAttachmentEnaSrdUdpSpecification
        :param bool ena_srd_udp_enabled: <p>Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.</p>
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[bool]:
        """
        <p>Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.</p>
        """
        return pulumi.get(self, "ena_srd_udp_enabled")


@pulumi.output_type
class InstanceAutoRecoveryStateEnumValueResponse(dict):
    """
    Definition of InstanceAutoRecoveryStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceAutoRecoveryStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceBlockDeviceMappingResponse(dict):
    """
    Definition of InstanceBlockDeviceMapping
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBlockDeviceMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBlockDeviceMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBlockDeviceMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 ebs: Optional['outputs.EbsInstanceBlockDeviceResponse'] = None):
        """
        Definition of InstanceBlockDeviceMapping
        :param str device_name: <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        :param 'EbsInstanceBlockDeviceResponse' ebs: <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.EbsInstanceBlockDeviceResponse']:
        """
        <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
        """
        return pulumi.get(self, "ebs")


@pulumi.output_type
class InstanceBootModeValuesEnumValueResponse(dict):
    """
    Definition of InstanceBootModeValuesEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceBootModeValuesEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceCollectionTypeEnumValueResponse(dict):
    """
    Definition of InstanceCollectionTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceCollectionTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceIpv4PrefixResponse(dict):
    """
    Definition of InstanceIpv4Prefix
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Prefix":
            suggest = "ipv4_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceIpv4PrefixResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceIpv4PrefixResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceIpv4PrefixResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_prefix: Optional[str] = None):
        """
        Definition of InstanceIpv4Prefix
        :param str ipv4_prefix: <p>One or more IPv4 prefixes assigned to the network interface.</p>
        """
        if ipv4_prefix is not None:
            pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> Optional[str]:
        """
        <p>One or more IPv4 prefixes assigned to the network interface.</p>
        """
        return pulumi.get(self, "ipv4_prefix")


@pulumi.output_type
class InstanceIpv6AddressResponse(dict):
    """
    Definition of InstanceIpv6Address
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "isPrimaryIpv6":
            suggest = "is_primary_ipv6"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceIpv6AddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceIpv6AddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceIpv6AddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: Optional[str] = None,
                 is_primary_ipv6: Optional[bool] = None):
        """
        Definition of InstanceIpv6Address
        :param str ipv6_address: Property ipv6Address
        :param bool is_primary_ipv6: <p>Determines if an IPv6 address associated with a network interface is the primary IPv6 address. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html'>RunInstances</a>.</p>
        """
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if is_primary_ipv6 is not None:
            pulumi.set(__self__, "is_primary_ipv6", is_primary_ipv6)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        """
        Property ipv6Address
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="isPrimaryIpv6")
    def is_primary_ipv6(self) -> Optional[bool]:
        """
        <p>Determines if an IPv6 address associated with a network interface is the primary IPv6 address. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html'>RunInstances</a>.</p>
        """
        return pulumi.get(self, "is_primary_ipv6")


@pulumi.output_type
class InstanceIpv6PrefixResponse(dict):
    """
    Definition of InstanceIpv6Prefix
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Prefix":
            suggest = "ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceIpv6PrefixResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceIpv6PrefixResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceIpv6PrefixResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_prefix: Optional[str] = None):
        """
        Definition of InstanceIpv6Prefix
        :param str ipv6_prefix: <p>One or more IPv6 prefixes assigned to the network interface.</p>
        """
        if ipv6_prefix is not None:
            pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> Optional[str]:
        """
        <p>One or more IPv6 prefixes assigned to the network interface.</p>
        """
        return pulumi.get(self, "ipv6_prefix")


@pulumi.output_type
class InstanceLifecycleTypeEnumValueResponse(dict):
    """
    Definition of InstanceLifecycleTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceLifecycleTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceMaintenanceOptionsResponse(dict):
    """
    Definition of InstanceMaintenanceOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMaintenanceOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMaintenanceOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMaintenanceOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional['outputs.InstanceAutoRecoveryStateEnumValueResponse'] = None):
        """
        Definition of InstanceMaintenanceOptions
        :param 'InstanceAutoRecoveryStateEnumValueResponse' auto_recovery: <p>Provides information on the current automatic recovery behavior of your instance.</p>
        """
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional['outputs.InstanceAutoRecoveryStateEnumValueResponse']:
        """
        <p>Provides information on the current automatic recovery behavior of your instance.</p>
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class InstanceMaintenancePolicyResponse(dict):
    """
    Definition of InstanceMaintenancePolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxHealthyPercentage":
            suggest = "max_healthy_percentage"
        elif key == "minHealthyPercentage":
            suggest = "min_healthy_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMaintenancePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMaintenancePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMaintenancePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_healthy_percentage: Optional[int] = None,
                 min_healthy_percentage: Optional[int] = None):
        """
        Definition of InstanceMaintenancePolicy
        :param int max_healthy_percentage: Specifies the upper threshold as a percentage of the desired capacity of the Auto Scaling group. It represents the maximum percentage of the group that can be in service and healthy, or pending, to support your workload when replacing instances. Value range is 100 to 200. To clear a previously set value, specify a value of ``-1``. Both ``MinHealthyPercentage`` and ``MaxHealthyPercentage`` must be specified, and the difference between them cannot be greater than 100. A large range increases the number of instances that can be replaced at the same time.
        :param int min_healthy_percentage: Specifies the lower threshold as a percentage of the desired capacity of the Auto Scaling group. It represents the minimum percentage of the group to keep in service, healthy, and ready to use to support your workload when replacing instances. Value range is 0 to 100. To clear a previously set value, specify a value of ``-1``.
        """
        if max_healthy_percentage is not None:
            pulumi.set(__self__, "max_healthy_percentage", max_healthy_percentage)
        if min_healthy_percentage is not None:
            pulumi.set(__self__, "min_healthy_percentage", min_healthy_percentage)

    @property
    @pulumi.getter(name="maxHealthyPercentage")
    def max_healthy_percentage(self) -> Optional[int]:
        """
        Specifies the upper threshold as a percentage of the desired capacity of the Auto Scaling group. It represents the maximum percentage of the group that can be in service and healthy, or pending, to support your workload when replacing instances. Value range is 100 to 200. To clear a previously set value, specify a value of ``-1``. Both ``MinHealthyPercentage`` and ``MaxHealthyPercentage`` must be specified, and the difference between them cannot be greater than 100. A large range increases the number of instances that can be replaced at the same time.
        """
        return pulumi.get(self, "max_healthy_percentage")

    @property
    @pulumi.getter(name="minHealthyPercentage")
    def min_healthy_percentage(self) -> Optional[int]:
        """
        Specifies the lower threshold as a percentage of the desired capacity of the Auto Scaling group. It represents the minimum percentage of the group to keep in service, healthy, and ready to use to support your workload when replacing instances. Value range is 0 to 100. To clear a previously set value, specify a value of ``-1``.
        """
        return pulumi.get(self, "min_healthy_percentage")


@pulumi.output_type
class InstanceMetadataEndpointStateEnumValueResponse(dict):
    """
    Definition of InstanceMetadataEndpointStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceMetadataEndpointStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceMetadataOptionsResponseResponse(dict):
    """
    Definition of InstanceMetadataOptionsResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMetadataOptionsResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMetadataOptionsResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMetadataOptionsResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional['outputs.InstanceMetadataEndpointStateEnumValueResponse'] = None,
                 http_protocol_ipv6: Optional['outputs.InstanceMetadataProtocolStateEnumValueResponse'] = None,
                 http_put_response_hop_limit: Optional[int] = None,
                 http_tokens: Optional['outputs.HttpTokensStateEnumValueResponse'] = None,
                 instance_metadata_tags: Optional['outputs.InstanceMetadataTagsStateEnumValueResponse'] = None,
                 state: Optional['outputs.InstanceMetadataOptionsStateEnumValueResponse'] = None):
        """
        Definition of InstanceMetadataOptionsResponse
        :param 'InstanceMetadataEndpointStateEnumValueResponse' http_endpoint: <p>Indicates whether the HTTP metadata endpoint on your instances is enabled or disabled.</p> <p>If the value is <code>disabled</code>, you cannot access your instance metadata.</p>
        :param 'InstanceMetadataProtocolStateEnumValueResponse' http_protocol_ipv6: <p>Indicates whether the IPv6 endpoint for the instance metadata service is enabled or disabled.</p> <p>Default: <code>disabled</code> </p>
        :param int http_put_response_hop_limit: <p>The maximum number of hops that the metadata token can travel.</p> <p>Possible values: Integers from <code>1</code> to <code>64</code> </p>
        :param 'HttpTokensStateEnumValueResponse' http_tokens: <p>Indicates whether IMDSv2 is required.</p> <ul> <li> <p> <code>optional</code> - IMDSv2 is optional, which means that you can use either IMDSv2 or IMDSv1.</p> </li> <li> <p> <code>required</code> - IMDSv2 is required, which means that IMDSv1 is disabled, and you must use IMDSv2.</p> </li> </ul>
        :param 'InstanceMetadataTagsStateEnumValueResponse' instance_metadata_tags: <p>Indicates whether access to instance tags from the instance metadata is enabled or disabled. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS'>Work with instance tags using the instance metadata</a>.</p>
        :param 'InstanceMetadataOptionsStateEnumValueResponse' state: <p>The state of the metadata option changes.</p> <p> <code>pending</code> - The metadata options are being updated and the instance is not ready to process metadata traffic with the new selection.</p> <p> <code>applied</code> - The metadata options have been successfully applied on the instance.</p>
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional['outputs.InstanceMetadataEndpointStateEnumValueResponse']:
        """
        <p>Indicates whether the HTTP metadata endpoint on your instances is enabled or disabled.</p> <p>If the value is <code>disabled</code>, you cannot access your instance metadata.</p>
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional['outputs.InstanceMetadataProtocolStateEnumValueResponse']:
        """
        <p>Indicates whether the IPv6 endpoint for the instance metadata service is enabled or disabled.</p> <p>Default: <code>disabled</code> </p>
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        <p>The maximum number of hops that the metadata token can travel.</p> <p>Possible values: Integers from <code>1</code> to <code>64</code> </p>
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional['outputs.HttpTokensStateEnumValueResponse']:
        """
        <p>Indicates whether IMDSv2 is required.</p> <ul> <li> <p> <code>optional</code> - IMDSv2 is optional, which means that you can use either IMDSv2 or IMDSv1.</p> </li> <li> <p> <code>required</code> - IMDSv2 is required, which means that IMDSv1 is disabled, and you must use IMDSv2.</p> </li> </ul>
        """
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional['outputs.InstanceMetadataTagsStateEnumValueResponse']:
        """
        <p>Indicates whether access to instance tags from the instance metadata is enabled or disabled. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS'>Work with instance tags using the instance metadata</a>.</p>
        """
        return pulumi.get(self, "instance_metadata_tags")

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.InstanceMetadataOptionsStateEnumValueResponse']:
        """
        <p>The state of the metadata option changes.</p> <p> <code>pending</code> - The metadata options are being updated and the instance is not ready to process metadata traffic with the new selection.</p> <p> <code>applied</code> - The metadata options have been successfully applied on the instance.</p>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class InstanceMetadataOptionsStateEnumValueResponse(dict):
    """
    Definition of InstanceMetadataOptionsStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceMetadataOptionsStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceMetadataProtocolStateEnumValueResponse(dict):
    """
    Definition of InstanceMetadataProtocolStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceMetadataProtocolStateEnumValue
        :param str value: Property value
        """
        if value is None:
            value = 'disabled'
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceMetadataTagsStateEnumValueResponse(dict):
    """
    Definition of InstanceMetadataTagsStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceMetadataTagsStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceNetworkInterfaceAssociationResponse(dict):
    """
    Definition of InstanceNetworkInterfaceAssociation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "carrierIp":
            suggest = "carrier_ip"
        elif key == "customerOwnedIp":
            suggest = "customer_owned_ip"
        elif key == "ipOwnerId":
            suggest = "ip_owner_id"
        elif key == "publicDnsName":
            suggest = "public_dns_name"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterfaceAssociationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterfaceAssociationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterfaceAssociationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 carrier_ip: Optional[str] = None,
                 customer_owned_ip: Optional[str] = None,
                 ip_owner_id: Optional[str] = None,
                 public_dns_name: Optional[str] = None,
                 public_ip: Optional[str] = None):
        """
        Definition of InstanceNetworkInterfaceAssociation
        :param str carrier_ip: <p>The carrier IP address associated with the network interface.</p>
        :param str customer_owned_ip: <p>The customer-owned IP address associated with the network interface.</p>
        :param str ip_owner_id: <p>The ID of the owner of the Elastic IP address.</p>
        :param str public_dns_name: <p>The public DNS name.</p>
        :param str public_ip: <p>The public IP address or Elastic IP address bound to the network interface.</p>
        """
        if carrier_ip is not None:
            pulumi.set(__self__, "carrier_ip", carrier_ip)
        if customer_owned_ip is not None:
            pulumi.set(__self__, "customer_owned_ip", customer_owned_ip)
        if ip_owner_id is not None:
            pulumi.set(__self__, "ip_owner_id", ip_owner_id)
        if public_dns_name is not None:
            pulumi.set(__self__, "public_dns_name", public_dns_name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)

    @property
    @pulumi.getter(name="carrierIp")
    def carrier_ip(self) -> Optional[str]:
        """
        <p>The carrier IP address associated with the network interface.</p>
        """
        return pulumi.get(self, "carrier_ip")

    @property
    @pulumi.getter(name="customerOwnedIp")
    def customer_owned_ip(self) -> Optional[str]:
        """
        <p>The customer-owned IP address associated with the network interface.</p>
        """
        return pulumi.get(self, "customer_owned_ip")

    @property
    @pulumi.getter(name="ipOwnerId")
    def ip_owner_id(self) -> Optional[str]:
        """
        <p>The ID of the owner of the Elastic IP address.</p>
        """
        return pulumi.get(self, "ip_owner_id")

    @property
    @pulumi.getter(name="publicDnsName")
    def public_dns_name(self) -> Optional[str]:
        """
        <p>The public DNS name.</p>
        """
        return pulumi.get(self, "public_dns_name")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[str]:
        """
        <p>The public IP address or Elastic IP address bound to the network interface.</p>
        """
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class InstanceNetworkInterfaceAttachmentResponse(dict):
    """
    Definition of InstanceNetworkInterfaceAttachment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachTime":
            suggest = "attach_time"
        elif key == "attachmentId":
            suggest = "attachment_id"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "enaSrdSpecification":
            suggest = "ena_srd_specification"
        elif key == "networkCardIndex":
            suggest = "network_card_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterfaceAttachmentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterfaceAttachmentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterfaceAttachmentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach_time: Optional[str] = None,
                 attachment_id: Optional[str] = None,
                 delete_on_termination: Optional[bool] = None,
                 device_index: Optional[int] = None,
                 ena_srd_specification: Optional['outputs.InstanceAttachmentEnaSrdSpecificationResponse'] = None,
                 network_card_index: Optional[int] = None,
                 status: Optional['outputs.AttachmentStatusEnumValueResponse'] = None):
        """
        Definition of InstanceNetworkInterfaceAttachment
        :param str attach_time: <p>The time stamp when the attachment initiated.</p>
        :param str attachment_id: <p>The ID of the network interface attachment.</p>
        :param bool delete_on_termination: <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
        :param int device_index: <p>The index of the device on the instance for the network interface attachment.</p>
        :param 'InstanceAttachmentEnaSrdSpecificationResponse' ena_srd_specification: <p>Contains the ENA Express settings for the network interface that's attached to the instance.</p>
        :param int network_card_index: <p>The index of the network card.</p>
        :param 'AttachmentStatusEnumValueResponse' status: <p>The attachment state.</p>
        """
        if attach_time is not None:
            pulumi.set(__self__, "attach_time", attach_time)
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if ena_srd_specification is not None:
            pulumi.set(__self__, "ena_srd_specification", ena_srd_specification)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="attachTime")
    def attach_time(self) -> Optional[str]:
        """
        <p>The time stamp when the attachment initiated.</p>
        """
        return pulumi.get(self, "attach_time")

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[str]:
        """
        <p>The ID of the network interface attachment.</p>
        """
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[int]:
        """
        <p>The index of the device on the instance for the network interface attachment.</p>
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="enaSrdSpecification")
    def ena_srd_specification(self) -> Optional['outputs.InstanceAttachmentEnaSrdSpecificationResponse']:
        """
        <p>Contains the ENA Express settings for the network interface that's attached to the instance.</p>
        """
        return pulumi.get(self, "ena_srd_specification")

    @property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[int]:
        """
        <p>The index of the network card.</p>
        """
        return pulumi.get(self, "network_card_index")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.AttachmentStatusEnumValueResponse']:
        """
        <p>The attachment state.</p>
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class InstanceNetworkInterfaceResponse(dict):
    """
    Definition of InstanceNetworkInterface
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionTrackingConfiguration":
            suggest = "connection_tracking_configuration"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "ipv4Prefixes":
            suggest = "ipv4_prefixes"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "ipv6Prefixes":
            suggest = "ipv6_prefixes"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "ownerId":
            suggest = "owner_id"
        elif key == "privateDnsName":
            suggest = "private_dns_name"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "sourceDestCheck":
            suggest = "source_dest_check"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterfaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterfaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterfaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 association: Optional['outputs.InstanceNetworkInterfaceAssociationResponse'] = None,
                 attachment: Optional['outputs.InstanceNetworkInterfaceAttachmentResponse'] = None,
                 connection_tracking_configuration: Optional['outputs.ConnectionTrackingSpecificationResponseResponse'] = None,
                 description: Optional[str] = None,
                 groups: Optional[Sequence['outputs.GroupIdentifierResponse']] = None,
                 interface_type: Optional[str] = None,
                 ipv4_prefixes: Optional[Sequence['outputs.InstanceIpv4PrefixResponse']] = None,
                 ipv6_addresses: Optional[Sequence['outputs.InstanceIpv6AddressResponse']] = None,
                 ipv6_prefixes: Optional[Sequence['outputs.InstanceIpv6PrefixResponse']] = None,
                 mac_address: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 owner_id: Optional[str] = None,
                 private_dns_name: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.InstancePrivateIpAddressResponse']] = None,
                 source_dest_check: Optional[bool] = None,
                 status: Optional['outputs.NetworkInterfaceStatusEnumValueResponse'] = None,
                 subnet_id: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of InstanceNetworkInterface
        :param 'InstanceNetworkInterfaceAssociationResponse' association: <p>The association information for an Elastic IPv4 associated with the network interface.</p>
        :param 'InstanceNetworkInterfaceAttachmentResponse' attachment: <p>The network interface attachment.</p>
        :param 'ConnectionTrackingSpecificationResponseResponse' connection_tracking_configuration: <p>A security group connection tracking configuration that enables you to set the timeout for connection tracking on an Elastic network interface. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts'>Connection tracking timeouts</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        :param str description: <p>The description.</p>
        :param Sequence['GroupIdentifierResponse'] groups: <p>The security groups.</p>
        :param str interface_type: <p>The type of network interface.</p> <p>Valid values: <code>interface</code> | <code>efa</code> | <code>trunk</code> </p>
        :param Sequence['InstanceIpv4PrefixResponse'] ipv4_prefixes: <p>The IPv4 delegated prefixes that are assigned to the network interface.</p>
        :param Sequence['InstanceIpv6AddressResponse'] ipv6_addresses: <p>The IPv6 addresses associated with the network interface.</p>
        :param Sequence['InstanceIpv6PrefixResponse'] ipv6_prefixes: <p>The IPv6 delegated prefixes that are assigned to the network interface.</p>
        :param str mac_address: <p>The MAC address.</p>
        :param str network_interface_id: <p>The ID of the network interface.</p>
        :param str owner_id: <p>The ID of the Amazon Web Services account that created the network interface.</p>
        :param str private_dns_name: <p>The private DNS name.</p>
        :param str private_ip_address: <p>The IPv4 address of the network interface within the subnet.</p>
        :param Sequence['InstancePrivateIpAddressResponse'] private_ip_addresses: <p>The private IPv4 addresses associated with the network interface.</p>
        :param bool source_dest_check: <p>Indicates whether source/destination checking is enabled.</p>
        :param 'NetworkInterfaceStatusEnumValueResponse' status: <p>The status of the network interface.</p>
        :param str subnet_id: <p>The ID of the subnet.</p>
        :param str vpc_id: <p>The ID of the VPC.</p>
        """
        if association is not None:
            pulumi.set(__self__, "association", association)
        if attachment is not None:
            pulumi.set(__self__, "attachment", attachment)
        if connection_tracking_configuration is not None:
            pulumi.set(__self__, "connection_tracking_configuration", connection_tracking_configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if ipv4_prefixes is not None:
            pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if ipv6_prefixes is not None:
            pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if private_dns_name is not None:
            pulumi.set(__self__, "private_dns_name", private_dns_name)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def association(self) -> Optional['outputs.InstanceNetworkInterfaceAssociationResponse']:
        """
        <p>The association information for an Elastic IPv4 associated with the network interface.</p>
        """
        return pulumi.get(self, "association")

    @property
    @pulumi.getter
    def attachment(self) -> Optional['outputs.InstanceNetworkInterfaceAttachmentResponse']:
        """
        <p>The network interface attachment.</p>
        """
        return pulumi.get(self, "attachment")

    @property
    @pulumi.getter(name="connectionTrackingConfiguration")
    def connection_tracking_configuration(self) -> Optional['outputs.ConnectionTrackingSpecificationResponseResponse']:
        """
        <p>A security group connection tracking configuration that enables you to set the timeout for connection tracking on an Elastic network interface. For more information, see <a href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts'>Connection tracking timeouts</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
        """
        return pulumi.get(self, "connection_tracking_configuration")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>The description.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GroupIdentifierResponse']]:
        """
        <p>The security groups.</p>
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[str]:
        """
        <p>The type of network interface.</p> <p>Valid values: <code>interface</code> | <code>efa</code> | <code>trunk</code> </p>
        """
        return pulumi.get(self, "interface_type")

    @property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Optional[Sequence['outputs.InstanceIpv4PrefixResponse']]:
        """
        <p>The IPv4 delegated prefixes that are assigned to the network interface.</p>
        """
        return pulumi.get(self, "ipv4_prefixes")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.InstanceIpv6AddressResponse']]:
        """
        <p>The IPv6 addresses associated with the network interface.</p>
        """
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Optional[Sequence['outputs.InstanceIpv6PrefixResponse']]:
        """
        <p>The IPv6 delegated prefixes that are assigned to the network interface.</p>
        """
        return pulumi.get(self, "ipv6_prefixes")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        <p>The MAC address.</p>
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        <p>The ID of the network interface.</p>
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[str]:
        """
        <p>The ID of the Amazon Web Services account that created the network interface.</p>
        """
        return pulumi.get(self, "owner_id")

    @property
    @pulumi.getter(name="privateDnsName")
    def private_dns_name(self) -> Optional[str]:
        """
        <p>The private DNS name.</p>
        """
        return pulumi.get(self, "private_dns_name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        <p>The IPv4 address of the network interface within the subnet.</p>
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.InstancePrivateIpAddressResponse']]:
        """
        <p>The private IPv4 addresses associated with the network interface.</p>
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[bool]:
        """
        <p>Indicates whether source/destination checking is enabled.</p>
        """
        return pulumi.get(self, "source_dest_check")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.NetworkInterfaceStatusEnumValueResponse']:
        """
        <p>The status of the network interface.</p>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        <p>The ID of the subnet.</p>
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        <p>The ID of the VPC.</p>
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class InstancePrivateIpAddressResponse(dict):
    """
    Definition of InstancePrivateIpAddress
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateDnsName":
            suggest = "private_dns_name"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateIpAddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateIpAddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateIpAddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 association: Optional['outputs.InstanceNetworkInterfaceAssociationResponse'] = None,
                 primary: Optional[bool] = None,
                 private_dns_name: Optional[str] = None,
                 private_ip_address: Optional[str] = None):
        """
        Definition of InstancePrivateIpAddress
        :param 'InstanceNetworkInterfaceAssociationResponse' association: <p>The association information for an Elastic IP address for the network interface.</p>
        :param bool primary: <p>Indicates whether this IPv4 address is the primary private IP address of the network interface.</p>
        :param str private_dns_name: <p>The private IPv4 DNS name.</p>
        :param str private_ip_address: <p>The private IPv4 address of the network interface.</p>
        """
        if association is not None:
            pulumi.set(__self__, "association", association)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_dns_name is not None:
            pulumi.set(__self__, "private_dns_name", private_dns_name)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def association(self) -> Optional['outputs.InstanceNetworkInterfaceAssociationResponse']:
        """
        <p>The association information for an Elastic IP address for the network interface.</p>
        """
        return pulumi.get(self, "association")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        <p>Indicates whether this IPv4 address is the primary private IP address of the network interface.</p>
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateDnsName")
    def private_dns_name(self) -> Optional[str]:
        """
        <p>The private IPv4 DNS name.</p>
        """
        return pulumi.get(self, "private_dns_name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        <p>The private IPv4 address of the network interface.</p>
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class InstanceRequirementsResponse(dict):
    """
    Definition of InstanceRequirements
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGB":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceRequirementsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceRequirementsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceRequirementsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.AcceleratorCountRequestResponse'] = None,
                 accelerator_manufacturers: Optional[Sequence[str]] = None,
                 accelerator_names: Optional[Sequence[str]] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.AcceleratorTotalMemoryMiBRequestResponse'] = None,
                 accelerator_types: Optional[Sequence[str]] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional[str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.BaselineEbsBandwidthMbpsRequestResponse'] = None,
                 burstable_performance: Optional[str] = None,
                 cpu_manufacturers: Optional[Sequence[str]] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence[str]] = None,
                 local_storage: Optional[str] = None,
                 local_storage_types: Optional[Sequence[str]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[int] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.MemoryGiBPerVCpuRequestResponse'] = None,
                 memory_mi_b: Optional['outputs.MemoryMiBRequestResponse'] = None,
                 network_bandwidth_gbps: Optional['outputs.NetworkBandwidthGbpsRequestResponse'] = None,
                 network_interface_count: Optional['outputs.NetworkInterfaceCountRequestResponse'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.TotalLocalStorageGBRequestResponse'] = None,
                 v_cpu_count: Optional['outputs.VCpuCountRequestResponse'] = None):
        """
        Definition of InstanceRequirements
        :param 'AcceleratorCountRequestResponse' accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) for an instance type. To exclude accelerator-enabled instance types, set ``Max`` to ``0``. Default: No minimum or maximum limits ``AcceleratorCountRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum number of accelerators for an instance type.
        :param Sequence[str] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.  +  For instance types with NVIDIA devices, specify ``nvidia``.  +  For instance types with AMD devices, specify ``amd``.  +  For instance types with AWS devices, specify ``amazon-web-services``.  +  For instance types with Xilinx devices, specify ``xilinx``.   Default: Any manufacturer
        :param Sequence[str] accelerator_names: Lists the accelerators that must be on an instance type.  +  For instance types with NVIDIA A100 GPUs, specify ``a100``.  +  For instance types with NVIDIA V100 GPUs, specify ``v100``.  +  For instance types with NVIDIA K80 GPUs, specify ``k80``.  +  For instance types with NVIDIA T4 GPUs, specify ``t4``.  +  For instance types with NVIDIA M60 GPUs, specify ``m60``.  +  For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520``.  +  For instance types with Xilinx VU9P FPGAs, specify ``vu9p``.   Default: Any accelerator
        :param 'AcceleratorTotalMemoryMiBRequestResponse' accelerator_total_memory_mi_b: The minimum and maximum total memory size for the accelerators on an instance type, in MiB. Default: No minimum or maximum limits ``AcceleratorTotalMemoryMiBRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum total memory size for the accelerators for an instance type, in MiB.
        :param Sequence[str] accelerator_types: Lists the accelerator types that must be on an instance type.  +  For instance types with GPU accelerators, specify ``gpu``.  +  For instance types with FPGA accelerators, specify ``fpga``.  +  For instance types with inference accelerators, specify ``inference``.   Default: Any accelerator type
        :param Sequence[str] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (``*``), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``. For example, if you specify ``c5*``, Amazon EC2 Auto Scaling will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 Auto Scaling will allow all the M5a instance types, but not the M5n instance types.  If you specify ``AllowedInstanceTypes``, you can't specify ``ExcludedInstanceTypes``.  Default: All instance types
        :param str bare_metal: Indicates whether bare metal instance types are included, excluded, or required. Default: ``excluded``
        :param 'BaselineEbsBandwidthMbpsRequestResponse' baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth performance for an instance type, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide for Linux Instances*. Default: No minimum or maximum limits ``BaselineEbsBandwidthMbpsRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum baseline bandwidth performance for an instance type, in Mbps.
        :param str burstable_performance: Indicates whether burstable performance instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide for Linux Instances*. Default: ``excluded``
        :param Sequence[str] cpu_manufacturers: Lists which specific CPU manufacturers to include.  +  For instance types with Intel CPUs, specify ``intel``.  +  For instance types with AMD CPUs, specify ``amd``.  +  For instance types with AWS CPUs, specify ``amazon-web-services``.    Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.   Default: Any manufacturer
        :param Sequence[str] excluded_instance_types: The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (``*``), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.  For example, if you specify ``c5*``, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 Auto Scaling will exclude all the M5a instance types, but not the M5n instance types.  If you specify ``ExcludedInstanceTypes``, you can't specify ``AllowedInstanceTypes``.  Default: No excluded instance types
        :param Sequence[str] instance_generations: Indicates whether current or previous generation instance types are included.  +  For current generation instance types, specify ``current``. The current generation includes EC2 instance types currently recommended for use. This typically includes the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide for Linux Instances*.  +  For previous generation instance types, specify ``previous``.   Default: Any current or previous generation
        :param str local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, see [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide for Linux Instances*. Default: ``included``
        :param Sequence[str] local_storage_types: Indicates the type of local storage that is required.  +  For instance types with hard disk drive (HDD) storage, specify ``hdd``.  +  For instance types with solid state drive (SSD) storage, specify ``ssd``.   Default: Any local storage type
        :param int max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To indicate no price protection threshold, specify a high value, such as ``999999``.  If you set ``DesiredCapacityType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per-vCPU or per-memory price instead of the per instance price.   Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, then ``SpotMaxPricePercentageOverLowestPrice`` is used and the value for that parameter defaults to ``100``.
        :param 'MemoryGiBPerVCpuRequestResponse' memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU for an instance type, in GiB. Default: No minimum or maximum limits ``MemoryGiBPerVCpuRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum amount of memory per vCPU for an instance type, in GiB.
        :param 'MemoryMiBRequestResponse' memory_mi_b: The minimum and maximum instance memory size for an instance type, in MiB. ``MemoryMiBRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum instance memory size for an instance type, in MiB.
        :param 'NetworkBandwidthGbpsRequestResponse' network_bandwidth_gbps: The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default: No minimum or maximum limits ``NetworkBandwidthGbpsRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum network bandwidth for an instance type, in Gbps.  Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide for Linux Instances*.
        :param 'NetworkInterfaceCountRequestResponse' network_interface_count: The minimum and maximum number of network interfaces for an instance type. Default: No minimum or maximum limits ``NetworkInterfaceCountRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum number of network interfaces for an instance type.
        :param int on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold.  The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as ``999999``.  If you set ``DesiredCapacityType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per instance price.  Default: ``20``
        :param bool require_hibernate_support: Indicates whether instance types must provide On-Demand Instance hibernation support. Default: ``false``
        :param int spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as ``999999``.  If you set ``DesiredCapacityType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per-vCPU or per-memory price instead of the per instance price.   Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified.  Default: ``100``
        :param 'TotalLocalStorageGBRequestResponse' total_local_storage_gb: The minimum and maximum total local storage size for an instance type, in GB. Default: No minimum or maximum limits ``TotalLocalStorageGBRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum total local storage size for an instance type, in GB.
        :param 'VCpuCountRequestResponse' v_cpu_count: The minimum and maximum number of vCPUs for an instance type. ``VCpuCountRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum number of vCPUs for an instance type.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.AcceleratorCountRequestResponse']:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) for an instance type. To exclude accelerator-enabled instance types, set ``Max`` to ``0``. Default: No minimum or maximum limits ``AcceleratorCountRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum number of accelerators for an instance type.
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[str]]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.  +  For instance types with NVIDIA devices, specify ``nvidia``.  +  For instance types with AMD devices, specify ``amd``.  +  For instance types with AWS devices, specify ``amazon-web-services``.  +  For instance types with Xilinx devices, specify ``xilinx``.   Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[str]]:
        """
        Lists the accelerators that must be on an instance type.  +  For instance types with NVIDIA A100 GPUs, specify ``a100``.  +  For instance types with NVIDIA V100 GPUs, specify ``v100``.  +  For instance types with NVIDIA K80 GPUs, specify ``k80``.  +  For instance types with NVIDIA T4 GPUs, specify ``t4``.  +  For instance types with NVIDIA M60 GPUs, specify ``m60``.  +  For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520``.  +  For instance types with Xilinx VU9P FPGAs, specify ``vu9p``.   Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.AcceleratorTotalMemoryMiBRequestResponse']:
        """
        The minimum and maximum total memory size for the accelerators on an instance type, in MiB. Default: No minimum or maximum limits ``AcceleratorTotalMemoryMiBRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum total memory size for the accelerators for an instance type, in MiB.
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[str]]:
        """
        Lists the accelerator types that must be on an instance type.  +  For instance types with GPU accelerators, specify ``gpu``.  +  For instance types with FPGA accelerators, specify ``fpga``.  +  For instance types with inference accelerators, specify ``inference``.   Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes. You can use strings with one or more wild cards, represented by an asterisk (``*``), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``. For example, if you specify ``c5*``, Amazon EC2 Auto Scaling will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 Auto Scaling will allow all the M5a instance types, but not the M5n instance types.  If you specify ``AllowedInstanceTypes``, you can't specify ``ExcludedInstanceTypes``.  Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[str]:
        """
        Indicates whether bare metal instance types are included, excluded, or required. Default: ``excluded``
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.BaselineEbsBandwidthMbpsRequestResponse']:
        """
        The minimum and maximum baseline bandwidth performance for an instance type, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide for Linux Instances*. Default: No minimum or maximum limits ``BaselineEbsBandwidthMbpsRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum baseline bandwidth performance for an instance type, in Mbps.
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[str]:
        """
        Indicates whether burstable performance instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the *Amazon EC2 User Guide for Linux Instances*. Default: ``excluded``
        """
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[str]]:
        """
        Lists which specific CPU manufacturers to include.  +  For instance types with Intel CPUs, specify ``intel``.  +  For instance types with AMD CPUs, specify ``amd``.  +  For instance types with AWS CPUs, specify ``amazon-web-services``.    Don't confuse the CPU hardware manufacturer with the CPU hardware architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.   Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk (``*``), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.  For example, if you specify ``c5*``, you are excluding the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 Auto Scaling will exclude all the M5a instance types, but not the M5n instance types.  If you specify ``ExcludedInstanceTypes``, you can't specify ``AllowedInstanceTypes``.  Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[str]]:
        """
        Indicates whether current or previous generation instance types are included.  +  For current generation instance types, specify ``current``. The current generation includes EC2 instance types currently recommended for use. This typically includes the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide for Linux Instances*.  +  For previous generation instance types, specify ``previous``.   Default: Any current or previous generation
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[str]:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, see [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide for Linux Instances*. Default: ``included``
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[str]]:
        """
        Indicates the type of local storage that is required.  +  For instance types with hard disk drive (HDD) storage, specify ``hdd``.  +  For instance types with solid state drive (SSD) storage, specify ``ssd``.   Default: Any local storage type
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To indicate no price protection threshold, specify a high value, such as ``999999``.  If you set ``DesiredCapacityType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per-vCPU or per-memory price instead of the per instance price.   Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, then ``SpotMaxPricePercentageOverLowestPrice`` is used and the value for that parameter defaults to ``100``.
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.MemoryGiBPerVCpuRequestResponse']:
        """
        The minimum and maximum amount of memory per vCPU for an instance type, in GiB. Default: No minimum or maximum limits ``MemoryGiBPerVCpuRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum amount of memory per vCPU for an instance type, in GiB.
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.MemoryMiBRequestResponse']:
        """
        The minimum and maximum instance memory size for an instance type, in MiB. ``MemoryMiBRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum instance memory size for an instance type, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.NetworkBandwidthGbpsRequestResponse']:
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps). Default: No minimum or maximum limits ``NetworkBandwidthGbpsRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum network bandwidth for an instance type, in Gbps.  Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide for Linux Instances*.
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.NetworkInterfaceCountRequestResponse']:
        """
        The minimum and maximum number of network interfaces for an instance type. Default: No minimum or maximum limits ``NetworkInterfaceCountRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum number of network interfaces for an instance type.
        """
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold.  The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as ``999999``.  If you set ``DesiredCapacityType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per instance price.  Default: ``20``
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        """
        Indicates whether instance types must provide On-Demand Instance hibernation support. Default: ``false``
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon EC2 Auto Scaling selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold. The parameter accepts an integer, which Amazon EC2 Auto Scaling interprets as a percentage. To turn off price protection, specify a high value, such as ``999999``.  If you set ``DesiredCapacityType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per-vCPU or per-memory price instead of the per instance price.   Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified.  Default: ``100``
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGB")
    def total_local_storage_gb(self) -> Optional['outputs.TotalLocalStorageGBRequestResponse']:
        """
        The minimum and maximum total local storage size for an instance type, in GB. Default: No minimum or maximum limits ``TotalLocalStorageGBRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum total local storage size for an instance type, in GB.
        """
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.VCpuCountRequestResponse']:
        """
        The minimum and maximum number of vCPUs for an instance type. ``VCpuCountRequest`` is a property of the ``InstanceRequirements`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property type that describes the minimum and maximum number of vCPUs for an instance type.
        """
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class InstanceRoleTypeEnumValueResponse(dict):
    """
    Definition of InstanceRoleTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceRoleTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceStateNameEnumValueResponse(dict):
    """
    Definition of InstanceStateNameEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceStateNameEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceStateResponse(dict):
    """
    Definition of InstanceState
    """
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 name: Optional['outputs.InstanceStateNameEnumValueResponse'] = None):
        """
        Definition of InstanceState
        :param int code: <p>The state of the instance as a 16-bit unsigned integer. </p> <p>The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values between 256 and 65,535. These numerical values are used for internal purposes and should be ignored.</p> <p>The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values between 0 and 255. </p> <p>The valid values for instance-state-code will all be in the range of the low byte and they are:</p> <ul> <li> <p> <code>0</code> : <code>pending</code> </p> </li> <li> <p> <code>16</code> : <code>running</code> </p> </li> <li> <p> <code>32</code> : <code>shutting-down</code> </p> </li> <li> <p> <code>48</code> : <code>terminated</code> </p> </li> <li> <p> <code>64</code> : <code>stopping</code> </p> </li> <li> <p> <code>80</code> : <code>stopped</code> </p> </li> </ul> <p>You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in decimal.</p>
        :param 'InstanceStateNameEnumValueResponse' name: <p>The current state of the instance.</p>
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        <p>The state of the instance as a 16-bit unsigned integer. </p> <p>The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values between 256 and 65,535. These numerical values are used for internal purposes and should be ignored.</p> <p>The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values between 0 and 255. </p> <p>The valid values for instance-state-code will all be in the range of the low byte and they are:</p> <ul> <li> <p> <code>0</code> : <code>pending</code> </p> </li> <li> <p> <code>16</code> : <code>running</code> </p> </li> <li> <p> <code>32</code> : <code>shutting-down</code> </p> </li> <li> <p> <code>48</code> : <code>terminated</code> </p> </li> <li> <p> <code>64</code> : <code>stopping</code> </p> </li> <li> <p> <code>80</code> : <code>stopped</code> </p> </li> </ul> <p>You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in decimal.</p>
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def name(self) -> Optional['outputs.InstanceStateNameEnumValueResponse']:
        """
        <p>The current state of the instance.</p>
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InstanceStatusDetailsResponse(dict):
    """
    Definition of InstanceStatusDetails
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "impairedSince":
            suggest = "impaired_since"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceStatusDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceStatusDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceStatusDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 impaired_since: Optional[str] = None,
                 name: Optional['outputs.StatusNameEnumValueResponse'] = None,
                 status: Optional['outputs.StatusTypeEnumValueResponse'] = None):
        """
        Definition of InstanceStatusDetails
        :param str impaired_since: <p>The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.</p>
        :param 'StatusNameEnumValueResponse' name: <p>The type of instance status.</p>
        :param 'StatusTypeEnumValueResponse' status: <p>The status.</p>
        """
        if impaired_since is not None:
            pulumi.set(__self__, "impaired_since", impaired_since)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="impairedSince")
    def impaired_since(self) -> Optional[str]:
        """
        <p>The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.</p>
        """
        return pulumi.get(self, "impaired_since")

    @property
    @pulumi.getter
    def name(self) -> Optional['outputs.StatusNameEnumValueResponse']:
        """
        <p>The type of instance status.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.StatusTypeEnumValueResponse']:
        """
        <p>The status.</p>
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class InstanceStatusEventResponse(dict):
    """
    Definition of InstanceStatusEvent
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceEventId":
            suggest = "instance_event_id"
        elif key == "notAfter":
            suggest = "not_after"
        elif key == "notBefore":
            suggest = "not_before"
        elif key == "notBeforeDeadline":
            suggest = "not_before_deadline"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceStatusEventResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceStatusEventResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceStatusEventResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional['outputs.EventCodeEnumValueResponse'] = None,
                 description: Optional[str] = None,
                 instance_event_id: Optional[str] = None,
                 not_after: Optional[str] = None,
                 not_before: Optional[str] = None,
                 not_before_deadline: Optional[str] = None):
        """
        Definition of InstanceStatusEvent
        :param 'EventCodeEnumValueResponse' code: <p>The event code.</p>
        :param str description: <p>A description of the event.</p> <p>After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].</p>
        :param str instance_event_id: <p>The ID of the event.</p>
        :param str not_after: <p>The latest scheduled end time for the event.</p>
        :param str not_before: <p>The earliest scheduled start time for the event.</p>
        :param str not_before_deadline: <p>The deadline for starting the event.</p>
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if instance_event_id is not None:
            pulumi.set(__self__, "instance_event_id", instance_event_id)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)
        if not_before_deadline is not None:
            pulumi.set(__self__, "not_before_deadline", not_before_deadline)

    @property
    @pulumi.getter
    def code(self) -> Optional['outputs.EventCodeEnumValueResponse']:
        """
        <p>The event code.</p>
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description of the event.</p> <p>After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="instanceEventId")
    def instance_event_id(self) -> Optional[str]:
        """
        <p>The ID of the event.</p>
        """
        return pulumi.get(self, "instance_event_id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[str]:
        """
        <p>The latest scheduled end time for the event.</p>
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[str]:
        """
        <p>The earliest scheduled start time for the event.</p>
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter(name="notBeforeDeadline")
    def not_before_deadline(self) -> Optional[str]:
        """
        <p>The deadline for starting the event.</p>
        """
        return pulumi.get(self, "not_before_deadline")


@pulumi.output_type
class InstanceStatusSummaryResponse(dict):
    """
    Definition of InstanceStatusSummary
    """
    def __init__(__self__, *,
                 details: Optional[Sequence['outputs.InstanceStatusDetailsResponse']] = None,
                 status: Optional['outputs.SummaryStatusEnumValueResponse'] = None):
        """
        Definition of InstanceStatusSummary
        :param Sequence['InstanceStatusDetailsResponse'] details: <p>The system instance health or application instance health.</p>
        :param 'SummaryStatusEnumValueResponse' status: <p>The status.</p>
        """
        if details is not None:
            pulumi.set(__self__, "details", details)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.InstanceStatusDetailsResponse']]:
        """
        <p>The system instance health or application instance health.</p>
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.SummaryStatusEnumValueResponse']:
        """
        <p>The status.</p>
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class InstanceTypeEnumValueResponse(dict):
    """
    Definition of InstanceTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of InstanceTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstancesDistributionResponse(dict):
    """
    Definition of InstancesDistribution
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandAllocationStrategy":
            suggest = "on_demand_allocation_strategy"
        elif key == "onDemandBaseCapacity":
            suggest = "on_demand_base_capacity"
        elif key == "onDemandPercentageAboveBaseCapacity":
            suggest = "on_demand_percentage_above_base_capacity"
        elif key == "spotAllocationStrategy":
            suggest = "spot_allocation_strategy"
        elif key == "spotInstancePools":
            suggest = "spot_instance_pools"
        elif key == "spotMaxPrice":
            suggest = "spot_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancesDistributionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancesDistributionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancesDistributionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_allocation_strategy: Optional[str] = None,
                 on_demand_base_capacity: Optional[int] = None,
                 on_demand_percentage_above_base_capacity: Optional[int] = None,
                 spot_allocation_strategy: Optional[str] = None,
                 spot_instance_pools: Optional[int] = None,
                 spot_max_price: Optional[str] = None):
        """
        Definition of InstancesDistribution
        :param str on_demand_allocation_strategy: The allocation strategy to apply to your On-Demand Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify. The following lists the valid values:  + lowest-price Uses price to determine which instance types are the highest priority, launching the lowest priced instance types within an Availability Zone first. This is the default value for Auto Scaling groups that specify InstanceRequirements. + prioritized You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling launches your highest priority instance types first. If all your On-Demand capacity cannot be fulfilled using your highest priority instance type, then Amazon EC2 Auto Scaling launches the remaining capacity using the second priority instance type, and so on. This is the default value for Auto Scaling groups that don't specify InstanceRequirements and cannot be used for groups that do.
        :param int on_demand_base_capacity: The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances. This base portion is launched first as your group scales. This number has the same unit of measurement as the group's desired capacity. If you change the default unit of measurement (number of instances) by specifying weighted capacity values in your launch template overrides list, or by changing the default desired capacity type setting of the group, you must specify this number using the same unit of measurement. Default: 0  An update to this setting means a gradual replacement of instances to adjust the current On-Demand Instance levels. When replacing instances, Amazon EC2 Auto Scaling launches new instances before terminating the previous ones.
        :param int on_demand_percentage_above_base_capacity: Controls the percentages of On-Demand Instances and Spot Instances for your additional capacity beyond ``OnDemandBaseCapacity``. Expressed as a number (for example, 20 specifies 20% On-Demand Instances, 80% Spot Instances). If set to 100, only On-Demand Instances are used. Default: 100  An update to this setting means a gradual replacement of instances to adjust the current On-Demand and Spot Instance levels for your additional capacity higher than the base capacity. When replacing instances, Amazon EC2 Auto Scaling launches new instances before terminating the previous ones.
        :param str spot_allocation_strategy: The allocation strategy to apply to your Spot Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify. The following lists the valid values:  + capacity-optimized Requests Spot Instances using pools that are optimally chosen based on the available Spot capacity. This strategy has the lowest risk of interruption. To give certain instance types a higher chance of launching first, use capacity-optimized-prioritized. + capacity-optimized-prioritized You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling honors the instance type priorities on a best effort basis but optimizes for capacity first. Note that if the On-Demand allocation strategy is set to prioritized, the same priority is applied when fulfilling On-Demand capacity. This is not a valid value for Auto Scaling groups that specify InstanceRequirements. + lowest-price Requests Spot Instances using the lowest priced pools within an Availability Zone, across the number of Spot pools that you specify for the SpotInstancePools property. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. This is the default value, but it might lead to high interruption rates because this strategy only considers instance price and not available capacity. + price-capacity-optimized (recommended) The price and capacity optimized allocation strategy looks at both price and capacity to select the Spot Instance pools that are the least likely to be interrupted and have the lowest possible price.
        :param int spot_instance_pools: The number of Spot Instance pools across which to allocate your Spot Instances. The Spot pools are determined from the different instance types in the overrides. Valid only when the ``SpotAllocationStrategy`` is ``lowest-price``. Value must be in the range of 120. Default: 2
        :param str spot_max_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. If your maximum price is lower than the Spot price for the instance types that you selected, your Spot Instances are not launched. We do not recommend specifying a maximum price because it can lead to increased interruptions. When Spot Instances launch, you pay the current Spot price. To remove a maximum price that you previously set, include the property but specify an empty string ('') for the value.  If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify one.  Valid Range: Minimum value of 0.001
        """
        if on_demand_allocation_strategy is not None:
            pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        if on_demand_base_capacity is not None:
            pulumi.set(__self__, "on_demand_base_capacity", on_demand_base_capacity)
        if on_demand_percentage_above_base_capacity is not None:
            pulumi.set(__self__, "on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        if spot_allocation_strategy is not None:
            pulumi.set(__self__, "spot_allocation_strategy", spot_allocation_strategy)
        if spot_instance_pools is not None:
            pulumi.set(__self__, "spot_instance_pools", spot_instance_pools)
        if spot_max_price is not None:
            pulumi.set(__self__, "spot_max_price", spot_max_price)

    @property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> Optional[str]:
        """
        The allocation strategy to apply to your On-Demand Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify. The following lists the valid values:  + lowest-price Uses price to determine which instance types are the highest priority, launching the lowest priced instance types within an Availability Zone first. This is the default value for Auto Scaling groups that specify InstanceRequirements. + prioritized You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling launches your highest priority instance types first. If all your On-Demand capacity cannot be fulfilled using your highest priority instance type, then Amazon EC2 Auto Scaling launches the remaining capacity using the second priority instance type, and so on. This is the default value for Auto Scaling groups that don't specify InstanceRequirements and cannot be used for groups that do.
        """
        return pulumi.get(self, "on_demand_allocation_strategy")

    @property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> Optional[int]:
        """
        The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances. This base portion is launched first as your group scales. This number has the same unit of measurement as the group's desired capacity. If you change the default unit of measurement (number of instances) by specifying weighted capacity values in your launch template overrides list, or by changing the default desired capacity type setting of the group, you must specify this number using the same unit of measurement. Default: 0  An update to this setting means a gradual replacement of instances to adjust the current On-Demand Instance levels. When replacing instances, Amazon EC2 Auto Scaling launches new instances before terminating the previous ones.
        """
        return pulumi.get(self, "on_demand_base_capacity")

    @property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> Optional[int]:
        """
        Controls the percentages of On-Demand Instances and Spot Instances for your additional capacity beyond ``OnDemandBaseCapacity``. Expressed as a number (for example, 20 specifies 20% On-Demand Instances, 80% Spot Instances). If set to 100, only On-Demand Instances are used. Default: 100  An update to this setting means a gradual replacement of instances to adjust the current On-Demand and Spot Instance levels for your additional capacity higher than the base capacity. When replacing instances, Amazon EC2 Auto Scaling launches new instances before terminating the previous ones.
        """
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> Optional[str]:
        """
        The allocation strategy to apply to your Spot Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify. The following lists the valid values:  + capacity-optimized Requests Spot Instances using pools that are optimally chosen based on the available Spot capacity. This strategy has the lowest risk of interruption. To give certain instance types a higher chance of launching first, use capacity-optimized-prioritized. + capacity-optimized-prioritized You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling honors the instance type priorities on a best effort basis but optimizes for capacity first. Note that if the On-Demand allocation strategy is set to prioritized, the same priority is applied when fulfilling On-Demand capacity. This is not a valid value for Auto Scaling groups that specify InstanceRequirements. + lowest-price Requests Spot Instances using the lowest priced pools within an Availability Zone, across the number of Spot pools that you specify for the SpotInstancePools property. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. This is the default value, but it might lead to high interruption rates because this strategy only considers instance price and not available capacity. + price-capacity-optimized (recommended) The price and capacity optimized allocation strategy looks at both price and capacity to select the Spot Instance pools that are the least likely to be interrupted and have the lowest possible price.
        """
        return pulumi.get(self, "spot_allocation_strategy")

    @property
    @pulumi.getter(name="spotInstancePools")
    def spot_instance_pools(self) -> Optional[int]:
        """
        The number of Spot Instance pools across which to allocate your Spot Instances. The Spot pools are determined from the different instance types in the overrides. Valid only when the ``SpotAllocationStrategy`` is ``lowest-price``. Value must be in the range of 120. Default: 2
        """
        return pulumi.get(self, "spot_instance_pools")

    @property
    @pulumi.getter(name="spotMaxPrice")
    def spot_max_price(self) -> Optional[str]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. If your maximum price is lower than the Spot price for the instance types that you selected, your Spot Instances are not launched. We do not recommend specifying a maximum price because it can lead to increased interruptions. When Spot Instances launch, you pay the current Spot price. To remove a maximum price that you previously set, include the property but specify an empty string ('') for the value.  If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify one.  Valid Range: Minimum value of 0.001
        """
        return pulumi.get(self, "spot_max_price")


@pulumi.output_type
class IntelligentTieringConfigurationResponse(dict):
    """
    Definition of IntelligentTieringConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntelligentTieringConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntelligentTieringConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntelligentTieringConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 prefix: Optional[str] = None,
                 status: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.TagFilterResponse']] = None,
                 tierings: Optional[Sequence['outputs.TieringResponse']] = None):
        """
        Definition of IntelligentTieringConfiguration
        :param str id: The ID used to identify the S3 Intelligent-Tiering configuration.
        :param str prefix: An object key name prefix that identifies the subset of objects to which the rule applies.
        :param str status: Specifies the status of the configuration.
        :param Sequence['TagFilterResponse'] tag_filters: A container for a key-value pair.
        :param Sequence['TieringResponse'] tierings: Specifies a list of S3 Intelligent-Tiering storage class tiers in the configuration. At least one tier must be defined in the list. At most, you can specify two tiers in the list, one for each available AccessTier: ``ARCHIVE_ACCESS`` and ``DEEP_ARCHIVE_ACCESS``.  You only need Intelligent Tiering Configuration enabled on a bucket if you want to automatically move objects stored in the Intelligent-Tiering storage class to Archive Access or Deep Archive Access tiers.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if tierings is not None:
            pulumi.set(__self__, "tierings", tierings)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID used to identify the S3 Intelligent-Tiering configuration.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An object key name prefix that identifies the subset of objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Specifies the status of the configuration.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.TagFilterResponse']]:
        """
        A container for a key-value pair.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter
    def tierings(self) -> Optional[Sequence['outputs.TieringResponse']]:
        """
        Specifies a list of S3 Intelligent-Tiering storage class tiers in the configuration. At least one tier must be defined in the list. At most, you can specify two tiers in the list, one for each available AccessTier: ``ARCHIVE_ACCESS`` and ``DEEP_ARCHIVE_ACCESS``.  You only need Intelligent Tiering Configuration enabled on a bucket if you want to automatically move objects stored in the Intelligent-Tiering storage class to Archive Access or Deep Archive Access tiers.
        """
        return pulumi.get(self, "tierings")


@pulumi.output_type
class InventoryConfigurationResponse(dict):
    """
    Definition of InventoryConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedObjectVersions":
            suggest = "included_object_versions"
        elif key == "optionalFields":
            suggest = "optional_fields"
        elif key == "scheduleFrequency":
            suggest = "schedule_frequency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InventoryConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InventoryConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InventoryConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional['outputs.DestinationResponse'] = None,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 included_object_versions: Optional[str] = None,
                 optional_fields: Optional[Sequence[str]] = None,
                 prefix: Optional[str] = None,
                 schedule_frequency: Optional[str] = None):
        """
        Definition of InventoryConfiguration
        :param 'DestinationResponse' destination: Contains information about where to publish the inventory results. Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket.
        :param bool enabled: Specifies whether the inventory is enabled or disabled. If set to ``True``, an inventory list is generated. If set to ``False``, no inventory list is generated.
        :param str id: The ID used to identify the inventory configuration.
        :param str included_object_versions: Object versions to include in the inventory list. If set to ``All``, the list includes all the object versions, which adds the version-related fields ``VersionId``, ``IsLatest``, and ``DeleteMarker`` to the list. If set to ``Current``, the list does not contain these version-related fields.
        :param Sequence[str] optional_fields: Contains the optional fields that are included in the inventory results.
        :param str prefix: Specifies the inventory filter prefix.
        :param str schedule_frequency: Specifies the schedule for generating inventory results.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if included_object_versions is not None:
            pulumi.set(__self__, "included_object_versions", included_object_versions)
        if optional_fields is not None:
            pulumi.set(__self__, "optional_fields", optional_fields)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if schedule_frequency is not None:
            pulumi.set(__self__, "schedule_frequency", schedule_frequency)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.DestinationResponse']:
        """
        Contains information about where to publish the inventory results. Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether the inventory is enabled or disabled. If set to ``True``, an inventory list is generated. If set to ``False``, no inventory list is generated.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID used to identify the inventory configuration.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includedObjectVersions")
    def included_object_versions(self) -> Optional[str]:
        """
        Object versions to include in the inventory list. If set to ``All``, the list includes all the object versions, which adds the version-related fields ``VersionId``, ``IsLatest``, and ``DeleteMarker`` to the list. If set to ``Current``, the list does not contain these version-related fields.
        """
        return pulumi.get(self, "included_object_versions")

    @property
    @pulumi.getter(name="optionalFields")
    def optional_fields(self) -> Optional[Sequence[str]]:
        """
        Contains the optional fields that are included in the inventory results.
        """
        return pulumi.get(self, "optional_fields")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Specifies the inventory filter prefix.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="scheduleFrequency")
    def schedule_frequency(self) -> Optional[str]:
        """
        Specifies the schedule for generating inventory results.
        """
        return pulumi.get(self, "schedule_frequency")


@pulumi.output_type
class IpFamilyEnumValueResponse(dict):
    """
    Definition of IpFamilyEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of IpFamilyEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpPermissionResponse(dict):
    """
    Definition of IpPermission
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "ipRanges":
            suggest = "ip_ranges"
        elif key == "ipv6Ranges":
            suggest = "ipv6_ranges"
        elif key == "prefixListIds":
            suggest = "prefix_list_ids"
        elif key == "toPort":
            suggest = "to_port"
        elif key == "userIdGroupPairs":
            suggest = "user_id_group_pairs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpPermissionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpPermissionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpPermissionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[int] = None,
                 ip_protocol: Optional[str] = None,
                 ip_ranges: Optional[Sequence['outputs.IpRangeResponse']] = None,
                 ipv6_ranges: Optional[Sequence['outputs.Ipv6RangeResponse']] = None,
                 prefix_list_ids: Optional[Sequence['outputs.PrefixListIdResponse']] = None,
                 to_port: Optional[int] = None,
                 user_id_group_pairs: Optional[Sequence['outputs.UserIdGroupPairResponse']] = None):
        """
        Definition of IpPermission
        :param int from_port: <p>If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).</p>
        :param str ip_protocol: <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number (see <a href='http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml'>Protocol Numbers</a>).</p> <p>Use <code>-1</code> to specify all protocols. When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows traffic on all ports, regardless of any port range you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For <code>icmpv6</code>, the port range is optional; if you omit the port range, traffic for all types and codes is allowed.</p>
        :param Sequence['IpRangeResponse'] ip_ranges: <p>The IPv4 address ranges.</p>
        :param Sequence['Ipv6RangeResponse'] ipv6_ranges: <p>The IPv6 address ranges.</p>
        :param Sequence['PrefixListIdResponse'] prefix_list_ids: <p>The prefix list IDs.</p>
        :param int to_port: <p>If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).</p>
        :param Sequence['UserIdGroupPairResponse'] user_id_group_pairs: <p>The security group and Amazon Web Services account ID pairs.</p>
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)
        if ipv6_ranges is not None:
            pulumi.set(__self__, "ipv6_ranges", ipv6_ranges)
        if prefix_list_ids is not None:
            pulumi.set(__self__, "prefix_list_ids", prefix_list_ids)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)
        if user_id_group_pairs is not None:
            pulumi.set(__self__, "user_id_group_pairs", user_id_group_pairs)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        """
        <p>If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).</p>
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[str]:
        """
        <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number (see <a href='http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml'>Protocol Numbers</a>).</p> <p>Use <code>-1</code> to specify all protocols. When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows traffic on all ports, regardless of any port range you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For <code>icmpv6</code>, the port range is optional; if you omit the port range, traffic for all types and codes is allowed.</p>
        """
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence['outputs.IpRangeResponse']]:
        """
        <p>The IPv4 address ranges.</p>
        """
        return pulumi.get(self, "ip_ranges")

    @property
    @pulumi.getter(name="ipv6Ranges")
    def ipv6_ranges(self) -> Optional[Sequence['outputs.Ipv6RangeResponse']]:
        """
        <p>The IPv6 address ranges.</p>
        """
        return pulumi.get(self, "ipv6_ranges")

    @property
    @pulumi.getter(name="prefixListIds")
    def prefix_list_ids(self) -> Optional[Sequence['outputs.PrefixListIdResponse']]:
        """
        <p>The prefix list IDs.</p>
        """
        return pulumi.get(self, "prefix_list_ids")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        <p>If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).</p>
        """
        return pulumi.get(self, "to_port")

    @property
    @pulumi.getter(name="userIdGroupPairs")
    def user_id_group_pairs(self) -> Optional[Sequence['outputs.UserIdGroupPairResponse']]:
        """
        <p>The security group and Amazon Web Services account ID pairs.</p>
        """
        return pulumi.get(self, "user_id_group_pairs")


@pulumi.output_type
class IpRangeResponse(dict):
    """
    Definition of IpRange
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrIp":
            suggest = "cidr_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpRangeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpRangeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpRangeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_ip: Optional[str] = None,
                 description: Optional[str] = None):
        """
        Definition of IpRange
        :param str cidr_ip: <p>The IPv4 address range. You can either specify a CIDR block or a source security group, not both. To specify a single IPv4 address, use the /32 prefix length.</p>
        :param str description: <p>A description for the security group rule that references this IPv4 address range.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
        """
        if cidr_ip is not None:
            pulumi.set(__self__, "cidr_ip", cidr_ip)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="cidrIp")
    def cidr_ip(self) -> Optional[str]:
        """
        <p>The IPv4 address range. You can either specify a CIDR block or a source security group, not both. To specify a single IPv4 address, use the /32 prefix length.</p>
        """
        return pulumi.get(self, "cidr_ip")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description for the security group rule that references this IPv4 address range.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class IpamOperatingRegionResponse(dict):
    """
    Definition of IpamOperatingRegion
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamOperatingRegionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamOperatingRegionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamOperatingRegionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: Optional[str] = None):
        """
        Definition of IpamOperatingRegion
        :param str region_name: <p>The name of the operating Region.</p>
        """
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        <p>The name of the operating Region.</p>
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class IpamStateEnumValueResponse(dict):
    """
    Definition of IpamStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of IpamStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpamTierEnumValueResponse(dict):
    """
    Definition of IpamTierEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of IpamTierEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class Ipv4PrefixSpecificationResponse(dict):
    """
    Definition of Ipv4PrefixSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Prefix":
            suggest = "ipv4_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ipv4PrefixSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ipv4PrefixSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ipv4PrefixSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_prefix: Optional[str] = None):
        """
        Definition of Ipv4PrefixSpecification
        :param str ipv4_prefix: Property ipv4Prefix
        """
        if ipv4_prefix is not None:
            pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> Optional[str]:
        """
        Property ipv4Prefix
        """
        return pulumi.get(self, "ipv4_prefix")


@pulumi.output_type
class Ipv6PrefixSpecificationResponse(dict):
    """
    Definition of Ipv6PrefixSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Prefix":
            suggest = "ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ipv6PrefixSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ipv6PrefixSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ipv6PrefixSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_prefix: Optional[str] = None):
        """
        Definition of Ipv6PrefixSpecification
        :param str ipv6_prefix: Property ipv6Prefix
        """
        if ipv6_prefix is not None:
            pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> Optional[str]:
        """
        Property ipv6Prefix
        """
        return pulumi.get(self, "ipv6_prefix")


@pulumi.output_type
class Ipv6RangeResponse(dict):
    """
    Definition of Ipv6Range
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrIpv6":
            suggest = "cidr_ipv6"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ipv6RangeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ipv6RangeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ipv6RangeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_ipv6: Optional[str] = None,
                 description: Optional[str] = None):
        """
        Definition of Ipv6Range
        :param str cidr_ipv6: <p>The IPv6 address range. You can either specify a CIDR block or a source security group, not both. To specify a single IPv6 address, use the /128 prefix length.</p>
        :param str description: <p>A description for the security group rule that references this IPv6 address range.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
        """
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[str]:
        """
        <p>The IPv6 address range. You can either specify a CIDR block or a source security group, not both. To specify a single IPv6 address, use the /128 prefix length.</p>
        """
        return pulumi.get(self, "cidr_ipv6")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description for the security group rule that references this IPv6 address range.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class JobComparatorEnumValueResponse(dict):
    """
    Definition of JobComparatorEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of JobComparatorEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class JobStatusEnumValueResponse(dict):
    """
    Definition of JobStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of JobStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class JobTypeEnumValueResponse(dict):
    """
    Definition of JobTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of JobTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KerberosAttributesResponse(dict):
    """
    Definition of KerberosAttributes
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adDomainJoinPassword":
            suggest = "ad_domain_join_password"
        elif key == "adDomainJoinUser":
            suggest = "ad_domain_join_user"
        elif key == "crossRealmTrustPrincipalPassword":
            suggest = "cross_realm_trust_principal_password"
        elif key == "kdcAdminPassword":
            suggest = "kdc_admin_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KerberosAttributesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KerberosAttributesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KerberosAttributesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad_domain_join_password: Optional[str] = None,
                 ad_domain_join_user: Optional[str] = None,
                 cross_realm_trust_principal_password: Optional[str] = None,
                 kdc_admin_password: Optional[str] = None,
                 realm: Optional[str] = None):
        """
        Definition of KerberosAttributes
        :param str ad_domain_join_password: <p>The Active Directory password for <code>ADDomainJoinUser</code>.</p>
        :param str ad_domain_join_user: <p>Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain.</p>
        :param str cross_realm_trust_principal_password: <p>Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms.</p>
        :param str kdc_admin_password: <p>The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster.</p>
        :param str realm: <p>The name of the Kerberos realm to which all nodes in a cluster belong. For example, <code>EC2.INTERNAL</code>. </p>
        """
        if ad_domain_join_password is not None:
            pulumi.set(__self__, "ad_domain_join_password", ad_domain_join_password)
        if ad_domain_join_user is not None:
            pulumi.set(__self__, "ad_domain_join_user", ad_domain_join_user)
        if cross_realm_trust_principal_password is not None:
            pulumi.set(__self__, "cross_realm_trust_principal_password", cross_realm_trust_principal_password)
        if kdc_admin_password is not None:
            pulumi.set(__self__, "kdc_admin_password", kdc_admin_password)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)

    @property
    @pulumi.getter(name="adDomainJoinPassword")
    def ad_domain_join_password(self) -> Optional[str]:
        """
        <p>The Active Directory password for <code>ADDomainJoinUser</code>.</p>
        """
        return pulumi.get(self, "ad_domain_join_password")

    @property
    @pulumi.getter(name="adDomainJoinUser")
    def ad_domain_join_user(self) -> Optional[str]:
        """
        <p>Required only when establishing a cross-realm trust with an Active Directory domain. A user with sufficient privileges to join resources to the domain.</p>
        """
        return pulumi.get(self, "ad_domain_join_user")

    @property
    @pulumi.getter(name="crossRealmTrustPrincipalPassword")
    def cross_realm_trust_principal_password(self) -> Optional[str]:
        """
        <p>Required only when establishing a cross-realm trust with a KDC in a different realm. The cross-realm principal password, which must be identical across realms.</p>
        """
        return pulumi.get(self, "cross_realm_trust_principal_password")

    @property
    @pulumi.getter(name="kdcAdminPassword")
    def kdc_admin_password(self) -> Optional[str]:
        """
        <p>The password used within the cluster for the kadmin service on the cluster-dedicated KDC, which maintains Kerberos principals, password policies, and keytabs for the cluster.</p>
        """
        return pulumi.get(self, "kdc_admin_password")

    @property
    @pulumi.getter
    def realm(self) -> Optional[str]:
        """
        <p>The name of the Kerberos realm to which all nodes in a cluster belong. For example, <code>EC2.INTERNAL</code>. </p>
        """
        return pulumi.get(self, "realm")


@pulumi.output_type
class KernelCapabilitiesResponse(dict):
    """
    Definition of KernelCapabilities
    """
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        """
        Definition of KernelCapabilities
        :param Sequence[str] add: The Linux capabilities for the container that have been added to the default configuration provided by Docker. This parameter maps to ``CapAdd`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--cap-add`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  Tasks launched on FARGATElong only support adding the ``SYS_PTRACE`` kernel capability.  Valid values: ``'ALL' | 'AUDIT_CONTROL' | 'AUDIT_WRITE' | 'BLOCK_SUSPEND' | 'CHOWN' | 'DAC_OVERRIDE' | 'DAC_READ_SEARCH' | 'FOWNER' | 'FSETID' | 'IPC_LOCK' | 'IPC_OWNER' | 'KILL' | 'LEASE' | 'LINUX_IMMUTABLE' | 'MAC_ADMIN' | 'MAC_OVERRIDE' | 'MKNOD' | 'NET_ADMIN' | 'NET_BIND_SERVICE' | 'NET_BROADCAST' | 'NET_RAW' | 'SETFCAP' | 'SETGID' | 'SETPCAP' | 'SETUID' | 'SYS_ADMIN' | 'SYS_BOOT' | 'SYS_CHROOT' | 'SYS_MODULE' | 'SYS_NICE' | 'SYS_PACCT' | 'SYS_PTRACE' | 'SYS_RAWIO' | 'SYS_RESOURCE' | 'SYS_TIME' | 'SYS_TTY_CONFIG' | 'SYSLOG' | 'WAKE_ALARM'``
        :param Sequence[str] drop: The Linux capabilities for the container that have been removed from the default configuration provided by Docker. This parameter maps to ``CapDrop`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--cap-drop`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). Valid values: ``'ALL' | 'AUDIT_CONTROL' | 'AUDIT_WRITE' | 'BLOCK_SUSPEND' | 'CHOWN' | 'DAC_OVERRIDE' | 'DAC_READ_SEARCH' | 'FOWNER' | 'FSETID' | 'IPC_LOCK' | 'IPC_OWNER' | 'KILL' | 'LEASE' | 'LINUX_IMMUTABLE' | 'MAC_ADMIN' | 'MAC_OVERRIDE' | 'MKNOD' | 'NET_ADMIN' | 'NET_BIND_SERVICE' | 'NET_BROADCAST' | 'NET_RAW' | 'SETFCAP' | 'SETGID' | 'SETPCAP' | 'SETUID' | 'SYS_ADMIN' | 'SYS_BOOT' | 'SYS_CHROOT' | 'SYS_MODULE' | 'SYS_NICE' | 'SYS_PACCT' | 'SYS_PTRACE' | 'SYS_RAWIO' | 'SYS_RESOURCE' | 'SYS_TIME' | 'SYS_TTY_CONFIG' | 'SYSLOG' | 'WAKE_ALARM'``
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        """
        The Linux capabilities for the container that have been added to the default configuration provided by Docker. This parameter maps to ``CapAdd`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--cap-add`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  Tasks launched on FARGATElong only support adding the ``SYS_PTRACE`` kernel capability.  Valid values: ``'ALL' | 'AUDIT_CONTROL' | 'AUDIT_WRITE' | 'BLOCK_SUSPEND' | 'CHOWN' | 'DAC_OVERRIDE' | 'DAC_READ_SEARCH' | 'FOWNER' | 'FSETID' | 'IPC_LOCK' | 'IPC_OWNER' | 'KILL' | 'LEASE' | 'LINUX_IMMUTABLE' | 'MAC_ADMIN' | 'MAC_OVERRIDE' | 'MKNOD' | 'NET_ADMIN' | 'NET_BIND_SERVICE' | 'NET_BROADCAST' | 'NET_RAW' | 'SETFCAP' | 'SETGID' | 'SETPCAP' | 'SETUID' | 'SYS_ADMIN' | 'SYS_BOOT' | 'SYS_CHROOT' | 'SYS_MODULE' | 'SYS_NICE' | 'SYS_PACCT' | 'SYS_PTRACE' | 'SYS_RAWIO' | 'SYS_RESOURCE' | 'SYS_TIME' | 'SYS_TTY_CONFIG' | 'SYSLOG' | 'WAKE_ALARM'``
        """
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        """
        The Linux capabilities for the container that have been removed from the default configuration provided by Docker. This parameter maps to ``CapDrop`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--cap-drop`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). Valid values: ``'ALL' | 'AUDIT_CONTROL' | 'AUDIT_WRITE' | 'BLOCK_SUSPEND' | 'CHOWN' | 'DAC_OVERRIDE' | 'DAC_READ_SEARCH' | 'FOWNER' | 'FSETID' | 'IPC_LOCK' | 'IPC_OWNER' | 'KILL' | 'LEASE' | 'LINUX_IMMUTABLE' | 'MAC_ADMIN' | 'MAC_OVERRIDE' | 'MKNOD' | 'NET_ADMIN' | 'NET_BIND_SERVICE' | 'NET_BROADCAST' | 'NET_RAW' | 'SETFCAP' | 'SETGID' | 'SETPCAP' | 'SETUID' | 'SYS_ADMIN' | 'SYS_BOOT' | 'SYS_CHROOT' | 'SYS_MODULE' | 'SYS_NICE' | 'SYS_PACCT' | 'SYS_PTRACE' | 'SYS_RAWIO' | 'SYS_RESOURCE' | 'SYS_TIME' | 'SYS_TTY_CONFIG' | 'SYSLOG' | 'WAKE_ALARM'``
        """
        return pulumi.get(self, "drop")


@pulumi.output_type
class KeyAlgorithmEnumValueResponse(dict):
    """
    Definition of KeyAlgorithmEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of KeyAlgorithmEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KeySchemaResponse(dict):
    """
    Definition of KeySchema
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "keyType":
            suggest = "key_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeySchemaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeySchemaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeySchemaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 key_type: Optional[str] = None):
        """
        Definition of KeySchema
        :param str attribute_name: The name of a key attribute.
        :param str key_type: The role that this key attribute will assume:  +   ``HASH`` - partition key  +   ``RANGE`` - sort key    The partition key of an item is also known as its *hash attribute*. The term 'hash attribute' derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values. The sort key of an item is also known as its *range attribute*. The term 'range attribute' derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        """
        The name of a key attribute.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[str]:
        """
        The role that this key attribute will assume:  +   ``HASH`` - partition key  +   ``RANGE`` - sort key    The partition key of an item is also known as its *hash attribute*. The term 'hash attribute' derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values. The sort key of an item is also known as its *range attribute*. The term 'range attribute' derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_type")


@pulumi.output_type
class KeyValuePairResponse(dict):
    """
    Definition of KeyValuePair
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of KeyValuePair
        :param str name: The name of the key-value pair. For environment variables, this is the name of the environment variable.
        :param str value: The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the key-value pair. For environment variables, this is the name of the environment variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the key-value pair. For environment variables, this is the value of the environment variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KinesisStreamSpecificationResponse(dict):
    """
    Definition of KinesisStreamSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approximateCreationDateTimePrecision":
            suggest = "approximate_creation_date_time_precision"
        elif key == "streamArn":
            suggest = "stream_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisStreamSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisStreamSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisStreamSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approximate_creation_date_time_precision: Optional[str] = None,
                 stream_arn: Optional[str] = None):
        """
        Definition of KinesisStreamSpecification
        :param str approximate_creation_date_time_precision: The precision for the time and date that the stream was created.
        :param str stream_arn: The ARN for a specific Kinesis data stream. Length Constraints: Minimum length of 37. Maximum length of 1024.
        """
        if approximate_creation_date_time_precision is not None:
            pulumi.set(__self__, "approximate_creation_date_time_precision", approximate_creation_date_time_precision)
        if stream_arn is not None:
            pulumi.set(__self__, "stream_arn", stream_arn)

    @property
    @pulumi.getter(name="approximateCreationDateTimePrecision")
    def approximate_creation_date_time_precision(self) -> Optional[str]:
        """
        The precision for the time and date that the stream was created.
        """
        return pulumi.get(self, "approximate_creation_date_time_precision")

    @property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> Optional[str]:
        """
        The ARN for a specific Kinesis data stream. Length Constraints: Minimum length of 37. Maximum length of 1024.
        """
        return pulumi.get(self, "stream_arn")


@pulumi.output_type
class KmsAliasPropertiesResponse(dict):
    """
    Definition of KmsAlias
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KmsAliasPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KmsAliasPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KmsAliasPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsKmsAliasPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of KmsAlias
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsKmsAliasPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsKmsAliasPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class KmsKeyPropertiesResponse(dict):
    """
    Definition of KmsKey
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KmsKeyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KmsKeyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KmsKeyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsKmsKeyPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of KmsKey
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsKmsKeyPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsKmsKeyPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class KubernetesNetworkConfigResponseResponse(dict):
    """
    Definition of KubernetesNetworkConfigResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFamily":
            suggest = "ip_family"
        elif key == "serviceIpv4Cidr":
            suggest = "service_ipv4_cidr"
        elif key == "serviceIpv6Cidr":
            suggest = "service_ipv6_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNetworkConfigResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNetworkConfigResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNetworkConfigResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_family: Optional['outputs.IpFamilyEnumValueResponse'] = None,
                 service_ipv4_cidr: Optional[str] = None,
                 service_ipv6_cidr: Optional[str] = None):
        """
        Definition of KubernetesNetworkConfigResponse
        :param 'IpFamilyEnumValueResponse' ip_family: <p>The IP family used to assign Kubernetes <code>Pod</code> and <code>Service</code> objects IP addresses. The IP family is always <code>ipv4</code>, unless you have a <code>1.21</code> or later cluster running version <code>1.10.1</code> or later of the Amazon VPC CNI plugin for Kubernetes and specified <code>ipv6</code> when you created the cluster. </p>
        :param str service_ipv4_cidr: <p>The CIDR block that Kubernetes <code>Pod</code> and <code>Service</code> object IP addresses are assigned from. Kubernetes assigns addresses from an <code>IPv4</code> CIDR block assigned to a subnet that the node is in. If you didn't specify a CIDR block when you created the cluster, then Kubernetes assigns addresses from either the <code>10.100.0.0/16</code> or <code>172.20.0.0/16</code> CIDR blocks. If this was specified, then it was specified when the cluster was created and it can't be changed.</p>
        :param str service_ipv6_cidr: <p>The CIDR block that Kubernetes pod and service IP addresses are assigned from if you created a 1.21 or later cluster with version 1.10.1 or later of the Amazon VPC CNI add-on and specified <code>ipv6</code> for <b>ipFamily</b> when you created the cluster. Kubernetes assigns service addresses from the unique local address range (<code>fc00::/7</code>) because you can't specify a custom IPv6 CIDR block when you create the cluster.</p>
        """
        if ip_family is not None:
            pulumi.set(__self__, "ip_family", ip_family)
        if service_ipv4_cidr is not None:
            pulumi.set(__self__, "service_ipv4_cidr", service_ipv4_cidr)
        if service_ipv6_cidr is not None:
            pulumi.set(__self__, "service_ipv6_cidr", service_ipv6_cidr)

    @property
    @pulumi.getter(name="ipFamily")
    def ip_family(self) -> Optional['outputs.IpFamilyEnumValueResponse']:
        """
        <p>The IP family used to assign Kubernetes <code>Pod</code> and <code>Service</code> objects IP addresses. The IP family is always <code>ipv4</code>, unless you have a <code>1.21</code> or later cluster running version <code>1.10.1</code> or later of the Amazon VPC CNI plugin for Kubernetes and specified <code>ipv6</code> when you created the cluster. </p>
        """
        return pulumi.get(self, "ip_family")

    @property
    @pulumi.getter(name="serviceIpv4Cidr")
    def service_ipv4_cidr(self) -> Optional[str]:
        """
        <p>The CIDR block that Kubernetes <code>Pod</code> and <code>Service</code> object IP addresses are assigned from. Kubernetes assigns addresses from an <code>IPv4</code> CIDR block assigned to a subnet that the node is in. If you didn't specify a CIDR block when you created the cluster, then Kubernetes assigns addresses from either the <code>10.100.0.0/16</code> or <code>172.20.0.0/16</code> CIDR blocks. If this was specified, then it was specified when the cluster was created and it can't be changed.</p>
        """
        return pulumi.get(self, "service_ipv4_cidr")

    @property
    @pulumi.getter(name="serviceIpv6Cidr")
    def service_ipv6_cidr(self) -> Optional[str]:
        """
        <p>The CIDR block that Kubernetes pod and service IP addresses are assigned from if you created a 1.21 or later cluster with version 1.10.1 or later of the Amazon VPC CNI add-on and specified <code>ipv6</code> for <b>ipFamily</b> when you created the cluster. Kubernetes assigns service addresses from the unique local address range (<code>fc00::/7</code>) because you can't specify a custom IPv6 CIDR block when you create the cluster.</p>
        """
        return pulumi.get(self, "service_ipv6_cidr")


@pulumi.output_type
class LabelNameConditionModelPropertiesResponse(dict):
    """
    Definition of LabelNameConditionModelProperties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LabelNameConditionModelPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LabelNameConditionModelPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LabelNameConditionModelPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: Optional[str] = None):
        """
        Definition of LabelNameConditionModelProperties
        :param str label_name: The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.
        """
        if label_name is not None:
            pulumi.set(__self__, "label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> Optional[str]:
        """
        The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.
        """
        return pulumi.get(self, "label_name")


@pulumi.output_type
class LambdaAuthorizerConfigResponse(dict):
    """
    Definition of LambdaAuthorizerConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizerResultTtlInSeconds":
            suggest = "authorizer_result_ttl_in_seconds"
        elif key == "authorizerUri":
            suggest = "authorizer_uri"
        elif key == "identityValidationExpression":
            suggest = "identity_validation_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LambdaAuthorizerConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LambdaAuthorizerConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LambdaAuthorizerConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorizer_result_ttl_in_seconds: Optional[int] = None,
                 authorizer_uri: Optional[str] = None,
                 identity_validation_expression: Optional[str] = None):
        """
        Definition of LambdaAuthorizerConfig
        :param int authorizer_result_ttl_in_seconds: <p>The number of seconds a response should be cached for. The default is 0 seconds, which disables caching. If you don't specify a value for <code>authorizerResultTtlInSeconds</code>, the default value is used. The maximum value is one hour (3600 seconds). The Lambda function can override this by returning a <code>ttlOverride</code> key in its response.</p>
        :param str authorizer_uri: <p>The Amazon Resource Name (ARN) of the Lambda function to be called for authorization. This can be a standard Lambda ARN, a version ARN (<code>.../v3</code>), or an alias ARN. </p> <p> <b>Note</b>: This Lambda function must have the following resource-based policy assigned to it. When configuring Lambda authorizers in the console, this is done for you. To use the Command Line Interface (CLI), run the following:</p> <p> <code>aws lambda add-permission --function-name 'arn:aws:lambda:us-east-2:111122223333:function:my-function' --statement-id 'appsync' --principal appsync.amazonaws.com --action lambda:InvokeFunction</code> </p>
        :param str identity_validation_expression: <p>A regular expression for validation of tokens before the Lambda function is called.</p>
        """
        if authorizer_result_ttl_in_seconds is not None:
            pulumi.set(__self__, "authorizer_result_ttl_in_seconds", authorizer_result_ttl_in_seconds)
        if authorizer_uri is not None:
            pulumi.set(__self__, "authorizer_uri", authorizer_uri)
        if identity_validation_expression is not None:
            pulumi.set(__self__, "identity_validation_expression", identity_validation_expression)

    @property
    @pulumi.getter(name="authorizerResultTtlInSeconds")
    def authorizer_result_ttl_in_seconds(self) -> Optional[int]:
        """
        <p>The number of seconds a response should be cached for. The default is 0 seconds, which disables caching. If you don't specify a value for <code>authorizerResultTtlInSeconds</code>, the default value is used. The maximum value is one hour (3600 seconds). The Lambda function can override this by returning a <code>ttlOverride</code> key in its response.</p>
        """
        return pulumi.get(self, "authorizer_result_ttl_in_seconds")

    @property
    @pulumi.getter(name="authorizerUri")
    def authorizer_uri(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the Lambda function to be called for authorization. This can be a standard Lambda ARN, a version ARN (<code>.../v3</code>), or an alias ARN. </p> <p> <b>Note</b>: This Lambda function must have the following resource-based policy assigned to it. When configuring Lambda authorizers in the console, this is done for you. To use the Command Line Interface (CLI), run the following:</p> <p> <code>aws lambda add-permission --function-name 'arn:aws:lambda:us-east-2:111122223333:function:my-function' --statement-id 'appsync' --principal appsync.amazonaws.com --action lambda:InvokeFunction</code> </p>
        """
        return pulumi.get(self, "authorizer_uri")

    @property
    @pulumi.getter(name="identityValidationExpression")
    def identity_validation_expression(self) -> Optional[str]:
        """
        <p>A regular expression for validation of tokens before the Lambda function is called.</p>
        """
        return pulumi.get(self, "identity_validation_expression")


@pulumi.output_type
class LambdaConfigurationResponse(dict):
    """
    Definition of LambdaConfiguration
    """
    def __init__(__self__, *,
                 event: Optional[str] = None,
                 filter: Optional['outputs.NotificationFilterResponse'] = None,
                 function: Optional[str] = None):
        """
        Definition of LambdaConfiguration
        :param str event: The Amazon S3 bucket event for which to invoke the LAMlong function. For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide*.
        :param 'NotificationFilterResponse' filter: The filtering rules that determine which objects invoke the AWS Lambda function. For example, you can create a filter so that only image files with a ``.jpg`` extension invoke the function when they are added to the Amazon S3 bucket. Specifies object key name filtering rules. For information about key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*.
        :param str function: The Amazon Resource Name (ARN) of the LAMlong function that Amazon S3 invokes when the specified event type occurs.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if function is not None:
            pulumi.set(__self__, "function", function)

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        The Amazon S3 bucket event for which to invoke the LAMlong function. For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.NotificationFilterResponse']:
        """
        The filtering rules that determine which objects invoke the AWS Lambda function. For example, you can create a filter so that only image files with a ``.jpg`` extension invoke the function when they are added to the Amazon S3 bucket. Specifies object key name filtering rules. For information about key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def function(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the LAMlong function that Amazon S3 invokes when the specified event type occurs.
        """
        return pulumi.get(self, "function")


@pulumi.output_type
class LambdaFunctionAssociationResponse(dict):
    """
    Definition of LambdaFunctionAssociation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "includeBody":
            suggest = "include_body"
        elif key == "lambdaFunctionARN":
            suggest = "lambda_function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LambdaFunctionAssociationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LambdaFunctionAssociationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LambdaFunctionAssociationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: Optional[str] = None,
                 include_body: Optional[bool] = None,
                 lambda_function_arn: Optional[str] = None):
        """
        Definition of LambdaFunctionAssociation
        :param str event_type: Specifies the event type that triggers a Lambda@Edge function invocation. You can specify the following values:  +   ``viewer-request``: The function executes when CloudFront receives a request from a viewer and before it checks to see whether the requested object is in the edge cache.  +   ``origin-request``: The function executes only when CloudFront sends a request to your origin. When the requested object is in the edge cache, the function doesn't execute.  +   ``origin-response``: The function executes after CloudFront receives a response from the origin and before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.  +   ``viewer-response``: The function executes before CloudFront returns the requested object to the viewer. The function executes regardless of whether the object was already in the edge cache. If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.
        :param bool include_body: A flag that allows a Lambda@Edge function to have read access to the body content. For more information, see [Accessing the Request Body by Choosing the Include Body Option](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html) in the Amazon CloudFront Developer Guide.
        :param str lambda_function_arn: The ARN of the Lambda@Edge function. You must specify the ARN of a function version; you can't specify an alias or $LATEST.
        """
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)
        if lambda_function_arn is not None:
            pulumi.set(__self__, "lambda_function_arn", lambda_function_arn)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[str]:
        """
        Specifies the event type that triggers a Lambda@Edge function invocation. You can specify the following values:  +   ``viewer-request``: The function executes when CloudFront receives a request from a viewer and before it checks to see whether the requested object is in the edge cache.  +   ``origin-request``: The function executes only when CloudFront sends a request to your origin. When the requested object is in the edge cache, the function doesn't execute.  +   ``origin-response``: The function executes after CloudFront receives a response from the origin and before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.  +   ``viewer-response``: The function executes before CloudFront returns the requested object to the viewer. The function executes regardless of whether the object was already in the edge cache. If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[bool]:
        """
        A flag that allows a Lambda@Edge function to have read access to the body content. For more information, see [Accessing the Request Body by Choosing the Include Body Option](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html) in the Amazon CloudFront Developer Guide.
        """
        return pulumi.get(self, "include_body")

    @property
    @pulumi.getter(name="lambdaFunctionARN")
    def lambda_function_arn(self) -> Optional[str]:
        """
        The ARN of the Lambda@Edge function. You must specify the ARN of a function version; you can't specify an alias or $LATEST.
        """
        return pulumi.get(self, "lambda_function_arn")


@pulumi.output_type
class LambdaFunctionCodeLocationPropertiesResponse(dict):
    """
    Definition of LambdaFunctionCodeLocation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LambdaFunctionCodeLocationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LambdaFunctionCodeLocationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LambdaFunctionCodeLocationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsLambdaFunctionCodeLocationPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of LambdaFunctionCodeLocation
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsLambdaFunctionCodeLocationPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsLambdaFunctionCodeLocationPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class LambdaFunctionPropertiesResponse(dict):
    """
    Definition of LambdaFunction
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LambdaFunctionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LambdaFunctionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LambdaFunctionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsLambdaFunctionPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of LambdaFunction
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsLambdaFunctionPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsLambdaFunctionPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class LastRunErrorStatusCodeEnumValueResponse(dict):
    """
    Definition of LastRunErrorStatusCodeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of LastRunErrorStatusCodeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LastRunErrorStatusResponse(dict):
    """
    Definition of LastRunErrorStatus
    """
    def __init__(__self__, *,
                 code: Optional['outputs.LastRunErrorStatusCodeEnumValueResponse'] = None):
        """
        Definition of LastRunErrorStatus
        :param 'LastRunErrorStatusCodeEnumValueResponse' code: <p>Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run. Possible values are:</p> <ul><li><p>ERROR - One or more errors occurred. Amazon Macie didn't process all the data specified for the job.</p></li> <li><p>NONE - No errors occurred. Macie processed all the data specified for the job.</p></li></ul>
        """
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def code(self) -> Optional['outputs.LastRunErrorStatusCodeEnumValueResponse']:
        """
        <p>Specifies whether any account- or bucket-level access errors occurred when the job ran. For a recurring job, this value indicates the error status of the job's most recent run. Possible values are:</p> <ul><li><p>ERROR - One or more errors occurred. Amazon Macie didn't process all the data specified for the job.</p></li> <li><p>NONE - No errors occurred. Macie processed all the data specified for the job.</p></li></ul>
        """
        return pulumi.get(self, "code")


@pulumi.output_type
class LaunchTemplateOverridesResponse(dict):
    """
    Definition of LaunchTemplateOverrides
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "launchTemplateSpecification":
            suggest = "launch_template_specification"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateOverridesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateOverridesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateOverridesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_requirements: Optional['outputs.InstanceRequirementsResponse'] = None,
                 instance_type: Optional[str] = None,
                 launch_template_specification: Optional['outputs.LaunchTemplateSpecificationResponse'] = None,
                 weighted_capacity: Optional[str] = None):
        """
        Definition of LaunchTemplateOverrides
        :param 'InstanceRequirementsResponse' instance_requirements: The instance requirements. Amazon EC2 Auto Scaling uses your specified requirements to identify instance types. Then, it uses your On-Demand and Spot allocation strategies to launch instances from these instance types. You can specify up to four separate sets of instance requirements per Auto Scaling group. This is useful for provisioning instances from different Amazon Machine Images (AMIs) in the same Auto Scaling group. To do this, create the AMIs and create a new launch template for each AMI. Then, create a compatible set of instance requirements for each launch template.   If you specify ``InstanceRequirements``, you can't specify ``InstanceType``. The attributes for the instance types for a mixed instances policy. Amazon EC2 Auto Scaling uses your specified requirements to identify instance types. Then, it uses your On-Demand and Spot allocation strategies to launch instances from these instance types. When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values. To limit the list of instance types from which Amazon EC2 Auto Scaling can identify matching instance types, you can use one of the following parameters, but not both in the same request:  +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.  +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.    You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.  For an example template, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html). For more information, see [Creating an Auto Scaling group using attribute-based instance type selection](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-asg-instance-type-requirements.html) in the *Amazon EC2 Auto Scaling User Guide*. For help determining which instance types match your attributes before you apply them to your Auto Scaling group, see [Preview instance types with specified attributes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-get-instance-types-from-instance-requirements) in the *Amazon EC2 User Guide for Linux Instances*. ``InstanceRequirements`` is a property of the ``LaunchTemplateOverrides`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplate.html) property type.
        :param str instance_type: The instance type, such as ``m3.xlarge``. You must specify an instance type that is supported in your requested Region and Availability Zones. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon Elastic Compute Cloud User Guide*. You can specify up to 40 instance types per Auto Scaling group.
        :param 'LaunchTemplateSpecificationResponse' launch_template_specification: Provides a launch template for the specified instance type or set of instance requirements. For example, some instance types might require a launch template with a different AMI. If not provided, Amazon EC2 Auto Scaling uses the launch template that's specified in the ``LaunchTemplate`` definition. For more information, see [Specifying a different launch template for an instance type](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups-launch-template-overrides.html) in the *Amazon EC2 Auto Scaling User Guide*.  You can specify up to 20 launch templates per Auto Scaling group. The launch templates specified in the overrides and in the ``LaunchTemplate`` definition count towards this limit. Specifies a launch template to use when provisioning EC2 instances for an Auto Scaling group. You must specify the following:  +  The ID or the name of the launch template, but not both.  +  The version of the launch template.   ``LaunchTemplateSpecification`` is property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. It is also a property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplate.html) and [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property types. For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html) in the *Amazon EC2 Auto Scaling User Guide*. For examples of launch templates, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html) and the [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) section in the ``AWS::EC2::LaunchTemplate`` resource.
        :param str weighted_capacity: If you provide a list of instance types to use, you can specify the number of capacity units provided by each instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic. When a Spot or On-Demand Instance is launched, the capacity units count toward the desired capacity. Amazon EC2 Auto Scaling launches instances until the desired capacity is totally fulfilled, even if this results in an overage. For example, if there are two units remaining to fulfill capacity, and Amazon EC2 Auto Scaling can only launch an instance with a ``WeightedCapacity`` of five units, the instance is launched, and the desired capacity is exceeded by three units. For more information, see [Configure instance weighting for Amazon EC2 Auto Scaling](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups-instance-weighting.html) in the *Amazon EC2 Auto Scaling User Guide*. Value must be in the range of 1-999.  If you specify a value for ``WeightedCapacity`` for one instance type, you must specify a value for ``WeightedCapacity`` for all of them.  Every Auto Scaling group has three size parameters (``DesiredCapacity``, ``MaxSize``, and ``MinSize``). Usually, you set these sizes based on a specific number of instances. However, if you configure a mixed instances policy that defines weights for the instance types, you must specify these sizes with the same units that you use for weighting instances.
        """
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.InstanceRequirementsResponse']:
        """
        The instance requirements. Amazon EC2 Auto Scaling uses your specified requirements to identify instance types. Then, it uses your On-Demand and Spot allocation strategies to launch instances from these instance types. You can specify up to four separate sets of instance requirements per Auto Scaling group. This is useful for provisioning instances from different Amazon Machine Images (AMIs) in the same Auto Scaling group. To do this, create the AMIs and create a new launch template for each AMI. Then, create a compatible set of instance requirements for each launch template.   If you specify ``InstanceRequirements``, you can't specify ``InstanceType``. The attributes for the instance types for a mixed instances policy. Amazon EC2 Auto Scaling uses your specified requirements to identify instance types. Then, it uses your On-Demand and Spot allocation strategies to launch instances from these instance types. When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values. To limit the list of instance types from which Amazon EC2 Auto Scaling can identify matching instance types, you can use one of the following parameters, but not both in the same request:  +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.  +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.    You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.  For an example template, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html). For more information, see [Creating an Auto Scaling group using attribute-based instance type selection](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-asg-instance-type-requirements.html) in the *Amazon EC2 Auto Scaling User Guide*. For help determining which instance types match your attributes before you apply them to your Auto Scaling group, see [Preview instance types with specified attributes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-get-instance-types-from-instance-requirements) in the *Amazon EC2 User Guide for Linux Instances*. ``InstanceRequirements`` is a property of the ``LaunchTemplateOverrides`` property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplate.html) property type.
        """
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The instance type, such as ``m3.xlarge``. You must specify an instance type that is supported in your requested Region and Availability Zones. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon Elastic Compute Cloud User Guide*. You can specify up to 40 instance types per Auto Scaling group.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.LaunchTemplateSpecificationResponse']:
        """
        Provides a launch template for the specified instance type or set of instance requirements. For example, some instance types might require a launch template with a different AMI. If not provided, Amazon EC2 Auto Scaling uses the launch template that's specified in the ``LaunchTemplate`` definition. For more information, see [Specifying a different launch template for an instance type](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups-launch-template-overrides.html) in the *Amazon EC2 Auto Scaling User Guide*.  You can specify up to 20 launch templates per Auto Scaling group. The launch templates specified in the overrides and in the ``LaunchTemplate`` definition count towards this limit. Specifies a launch template to use when provisioning EC2 instances for an Auto Scaling group. You must specify the following:  +  The ID or the name of the launch template, but not both.  +  The version of the launch template.   ``LaunchTemplateSpecification`` is property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. It is also a property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplate.html) and [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property types. For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html) in the *Amazon EC2 Auto Scaling User Guide*. For examples of launch templates, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html) and the [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) section in the ``AWS::EC2::LaunchTemplate`` resource.
        """
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[str]:
        """
        If you provide a list of instance types to use, you can specify the number of capacity units provided by each instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic. When a Spot or On-Demand Instance is launched, the capacity units count toward the desired capacity. Amazon EC2 Auto Scaling launches instances until the desired capacity is totally fulfilled, even if this results in an overage. For example, if there are two units remaining to fulfill capacity, and Amazon EC2 Auto Scaling can only launch an instance with a ``WeightedCapacity`` of five units, the instance is launched, and the desired capacity is exceeded by three units. For more information, see [Configure instance weighting for Amazon EC2 Auto Scaling](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups-instance-weighting.html) in the *Amazon EC2 Auto Scaling User Guide*. Value must be in the range of 1-999.  If you specify a value for ``WeightedCapacity`` for one instance type, you must specify a value for ``WeightedCapacity`` for all of them.  Every Auto Scaling group has three size parameters (``DesiredCapacity``, ``MaxSize``, and ``MinSize``). Usually, you set these sizes based on a specific number of instances. However, if you configure a mixed instances policy that defines weights for the instance types, you must specify these sizes with the same units that you use for weighting instances.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class LaunchTemplateResponse(dict):
    """
    Definition of LaunchTemplate
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.LaunchTemplateSpecificationResponse'] = None,
                 overrides: Optional[Sequence['outputs.LaunchTemplateOverridesResponse']] = None):
        """
        Definition of LaunchTemplate
        :param 'LaunchTemplateSpecificationResponse' launch_template_specification: The launch template. Specifies a launch template to use when provisioning EC2 instances for an Auto Scaling group. You must specify the following:  +  The ID or the name of the launch template, but not both.  +  The version of the launch template.   ``LaunchTemplateSpecification`` is property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. It is also a property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplate.html) and [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property types. For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html) in the *Amazon EC2 Auto Scaling User Guide*. For examples of launch templates, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html) and the [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) section in the ``AWS::EC2::LaunchTemplate`` resource.
        :param Sequence['LaunchTemplateOverridesResponse'] overrides: Any properties that you specify override the same properties in the launch template.
        """
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.LaunchTemplateSpecificationResponse']:
        """
        The launch template. Specifies a launch template to use when provisioning EC2 instances for an Auto Scaling group. You must specify the following:  +  The ID or the name of the launch template, but not both.  +  The version of the launch template.   ``LaunchTemplateSpecification`` is property of the [AWS::AutoScaling::AutoScalingGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autoscaling-autoscalinggroup.html) resource. It is also a property of the [AWS::AutoScaling::AutoScalingGroup LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplate.html) and [AWS::AutoScaling::AutoScalingGroup LaunchTemplateOverrides](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-launchtemplateoverrides.html) property types. For information about creating a launch template, see [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html) and [Create a launch template for an Auto Scaling group](https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html) in the *Amazon EC2 Auto Scaling User Guide*. For examples of launch templates, see [Auto scaling template snippets](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html) and the [Examples](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate--examples) section in the ``AWS::EC2::LaunchTemplate`` resource.
        """
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.LaunchTemplateOverridesResponse']]:
        """
        Any properties that you specify override the same properties in the launch template.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class LaunchTemplateSpecificationResponse(dict):
    """
    Definition of LaunchTemplateSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Definition of LaunchTemplateSpecification
        :param str id: Property id
        :param str launch_template_id: The ID of the launch template. You must specify the ``LaunchTemplateID`` or the ``LaunchTemplateName``, but not both.
        :param str launch_template_name: The name of the launch template. You must specify the ``LaunchTemplateName`` or the ``LaunchTemplateID``, but not both.
        :param str name: Property name
        :param str version: Property version
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Property id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        """
        The ID of the launch template. You must specify the ``LaunchTemplateID`` or the ``LaunchTemplateName``, but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        """
        The name of the launch template. You must specify the ``LaunchTemplateName`` or the ``LaunchTemplateID``, but not both.
        """
        return pulumi.get(self, "launch_template_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Property name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Property version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class LegacyCustomOriginResponse(dict):
    """
    Definition of LegacyCustomOrigin
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "originProtocolPolicy":
            suggest = "origin_protocol_policy"
        elif key == "originSSLProtocols":
            suggest = "origin_ssl_protocols"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LegacyCustomOriginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LegacyCustomOriginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LegacyCustomOriginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[str] = None,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None,
                 origin_protocol_policy: Optional[str] = None,
                 origin_ssl_protocols: Optional[Sequence[str]] = None):
        """
        Definition of LegacyCustomOrigin
        :param str dns_name: Property dnsName
        :param int http_port: Property httpPort
        :param int https_port: Property httpsPort
        :param str origin_protocol_policy: Property originProtocolPolicy
        :param Sequence[str] origin_ssl_protocols: Property originSSLProtocols
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if http_port is None:
            http_port = 80
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is None:
            https_port = 443
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if origin_protocol_policy is not None:
            pulumi.set(__self__, "origin_protocol_policy", origin_protocol_policy)
        if origin_ssl_protocols is not None:
            pulumi.set(__self__, "origin_ssl_protocols", origin_ssl_protocols)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[str]:
        """
        Property dnsName
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        Property httpPort
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        Property httpsPort
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter(name="originProtocolPolicy")
    def origin_protocol_policy(self) -> Optional[str]:
        """
        Property originProtocolPolicy
        """
        return pulumi.get(self, "origin_protocol_policy")

    @property
    @pulumi.getter(name="originSSLProtocols")
    def origin_ssl_protocols(self) -> Optional[Sequence[str]]:
        """
        Property originSSLProtocols
        """
        return pulumi.get(self, "origin_ssl_protocols")


@pulumi.output_type
class LegacyS3OriginResponse(dict):
    """
    Definition of LegacyS3Origin
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "originAccessIdentity":
            suggest = "origin_access_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LegacyS3OriginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LegacyS3OriginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LegacyS3OriginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[str] = None,
                 origin_access_identity: Optional[str] = None):
        """
        Definition of LegacyS3Origin
        :param str dns_name: Property dnsName
        :param str origin_access_identity: Property originAccessIdentity
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if origin_access_identity is not None:
            pulumi.set(__self__, "origin_access_identity", origin_access_identity)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[str]:
        """
        Property dnsName
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="originAccessIdentity")
    def origin_access_identity(self) -> Optional[str]:
        """
        Property originAccessIdentity
        """
        return pulumi.get(self, "origin_access_identity")


@pulumi.output_type
class LicenseConfigurationResponse(dict):
    """
    Definition of LicenseConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LicenseConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LicenseConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LicenseConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: Optional[str] = None):
        """
        Definition of LicenseConfiguration
        :param str license_configuration_arn: <p>The Amazon Resource Name (ARN) of the license configuration.</p>
        """
        if license_configuration_arn is not None:
            pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the license configuration.</p>
        """
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class LifecycleConfigurationResponse(dict):
    """
    Definition of LifecycleConfiguration
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.RuleResponse']] = None):
        """
        Definition of LifecycleConfiguration
        :param Sequence['RuleResponse'] rules: A lifecycle rule for individual objects in an Amazon S3 bucket.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.RuleResponse']]:
        """
        A lifecycle rule for individual objects in an Amazon S3 bucket.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class LifecycleHookSpecificationResponse(dict):
    """
    Definition of LifecycleHookSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultResult":
            suggest = "default_result"
        elif key == "heartbeatTimeout":
            suggest = "heartbeat_timeout"
        elif key == "lifecycleHookName":
            suggest = "lifecycle_hook_name"
        elif key == "lifecycleTransition":
            suggest = "lifecycle_transition"
        elif key == "notificationMetadata":
            suggest = "notification_metadata"
        elif key == "notificationTargetARN":
            suggest = "notification_target_arn"
        elif key == "roleARN":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecycleHookSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecycleHookSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecycleHookSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_result: Optional[str] = None,
                 heartbeat_timeout: Optional[int] = None,
                 lifecycle_hook_name: Optional[str] = None,
                 lifecycle_transition: Optional[str] = None,
                 notification_metadata: Optional[str] = None,
                 notification_target_arn: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        Definition of LifecycleHookSpecification
        :param str default_result: The action the Auto Scaling group takes when the lifecycle hook timeout elapses or if an unexpected failure occurs. The default value is ``ABANDON``. Valid values: ``CONTINUE`` | ``ABANDON``
        :param int heartbeat_timeout: The maximum time, in seconds, that can elapse before the lifecycle hook times out. The range is from ``30`` to ``7200`` seconds. The default value is ``3600`` seconds (1 hour).
        :param str lifecycle_hook_name: The name of the lifecycle hook.
        :param str lifecycle_transition: The lifecycle transition. For Auto Scaling groups, there are two major lifecycle transitions.  +  To create a lifecycle hook for scale-out events, specify ``autoscaling:EC2_INSTANCE_LAUNCHING``.  +  To create a lifecycle hook for scale-in events, specify ``autoscaling:EC2_INSTANCE_TERMINATING``.
        :param str notification_metadata: Additional information that you want to include any time Amazon EC2 Auto Scaling sends a message to the notification target.
        :param str notification_target_arn: The Amazon Resource Name (ARN) of the notification target that Amazon EC2 Auto Scaling sends notifications to when an instance is in a wait state for the lifecycle hook. You can specify an Amazon SNS topic or an Amazon SQS queue.
        :param str role_arn: The ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target. For information about creating this role, see [Configure a notification target for a lifecycle hook](https://docs.aws.amazon.com/autoscaling/ec2/userguide/prepare-for-lifecycle-notifications.html#lifecycle-hook-notification-target) in the *Amazon EC2 Auto Scaling User Guide*. Valid only if the notification target is an Amazon SNS topic or an Amazon SQS queue.
        """
        if default_result is not None:
            pulumi.set(__self__, "default_result", default_result)
        if heartbeat_timeout is not None:
            pulumi.set(__self__, "heartbeat_timeout", heartbeat_timeout)
        if lifecycle_hook_name is not None:
            pulumi.set(__self__, "lifecycle_hook_name", lifecycle_hook_name)
        if lifecycle_transition is not None:
            pulumi.set(__self__, "lifecycle_transition", lifecycle_transition)
        if notification_metadata is not None:
            pulumi.set(__self__, "notification_metadata", notification_metadata)
        if notification_target_arn is not None:
            pulumi.set(__self__, "notification_target_arn", notification_target_arn)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="defaultResult")
    def default_result(self) -> Optional[str]:
        """
        The action the Auto Scaling group takes when the lifecycle hook timeout elapses or if an unexpected failure occurs. The default value is ``ABANDON``. Valid values: ``CONTINUE`` | ``ABANDON``
        """
        return pulumi.get(self, "default_result")

    @property
    @pulumi.getter(name="heartbeatTimeout")
    def heartbeat_timeout(self) -> Optional[int]:
        """
        The maximum time, in seconds, that can elapse before the lifecycle hook times out. The range is from ``30`` to ``7200`` seconds. The default value is ``3600`` seconds (1 hour).
        """
        return pulumi.get(self, "heartbeat_timeout")

    @property
    @pulumi.getter(name="lifecycleHookName")
    def lifecycle_hook_name(self) -> Optional[str]:
        """
        The name of the lifecycle hook.
        """
        return pulumi.get(self, "lifecycle_hook_name")

    @property
    @pulumi.getter(name="lifecycleTransition")
    def lifecycle_transition(self) -> Optional[str]:
        """
        The lifecycle transition. For Auto Scaling groups, there are two major lifecycle transitions.  +  To create a lifecycle hook for scale-out events, specify ``autoscaling:EC2_INSTANCE_LAUNCHING``.  +  To create a lifecycle hook for scale-in events, specify ``autoscaling:EC2_INSTANCE_TERMINATING``.
        """
        return pulumi.get(self, "lifecycle_transition")

    @property
    @pulumi.getter(name="notificationMetadata")
    def notification_metadata(self) -> Optional[str]:
        """
        Additional information that you want to include any time Amazon EC2 Auto Scaling sends a message to the notification target.
        """
        return pulumi.get(self, "notification_metadata")

    @property
    @pulumi.getter(name="notificationTargetARN")
    def notification_target_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the notification target that Amazon EC2 Auto Scaling sends notifications to when an instance is in a wait state for the lifecycle hook. You can specify an Amazon SNS topic or an Amazon SQS queue.
        """
        return pulumi.get(self, "notification_target_arn")

    @property
    @pulumi.getter(name="roleARN")
    def role_arn(self) -> Optional[str]:
        """
        The ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target. For information about creating this role, see [Configure a notification target for a lifecycle hook](https://docs.aws.amazon.com/autoscaling/ec2/userguide/prepare-for-lifecycle-notifications.html#lifecycle-hook-notification-target) in the *Amazon EC2 Auto Scaling User Guide*. Valid only if the notification target is an Amazon SNS topic or an Amazon SQS queue.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class LifecyclePolicyResponse(dict):
    """
    Definition of LifecyclePolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifecyclePolicyText":
            suggest = "lifecycle_policy_text"
        elif key == "registryId":
            suggest = "registry_id"
        elif key == "transitionToArchive":
            suggest = "transition_to_archive"
        elif key == "transitionToIA":
            suggest = "transition_to_ia"
        elif key == "transitionToPrimaryStorageClass":
            suggest = "transition_to_primary_storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecyclePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecyclePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecyclePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lifecycle_policy_text: Optional[str] = None,
                 registry_id: Optional[str] = None,
                 transition_to_archive: Optional[str] = None,
                 transition_to_ia: Optional[str] = None,
                 transition_to_primary_storage_class: Optional[str] = None):
        """
        Definition of LifecyclePolicy
        :param str lifecycle_policy_text: The JSON repository policy text to apply to the repository. The JSON repository policy text to apply to the repository.
        :param str registry_id: The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed. The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        :param str transition_to_archive: The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        :param str transition_to_ia: The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Infrequent Access (IA) storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        :param str transition_to_primary_storage_class: Whether to move files back to primary (Standard) storage after they are accessed in IA or Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        """
        if lifecycle_policy_text is not None:
            pulumi.set(__self__, "lifecycle_policy_text", lifecycle_policy_text)
        if registry_id is not None:
            pulumi.set(__self__, "registry_id", registry_id)
        if transition_to_archive is not None:
            pulumi.set(__self__, "transition_to_archive", transition_to_archive)
        if transition_to_ia is not None:
            pulumi.set(__self__, "transition_to_ia", transition_to_ia)
        if transition_to_primary_storage_class is not None:
            pulumi.set(__self__, "transition_to_primary_storage_class", transition_to_primary_storage_class)

    @property
    @pulumi.getter(name="lifecyclePolicyText")
    def lifecycle_policy_text(self) -> Optional[str]:
        """
        The JSON repository policy text to apply to the repository. The JSON repository policy text to apply to the repository.
        """
        return pulumi.get(self, "lifecycle_policy_text")

    @property
    @pulumi.getter(name="registryId")
    def registry_id(self) -> Optional[str]:
        """
        The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed. The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
        """
        return pulumi.get(self, "registry_id")

    @property
    @pulumi.getter(name="transitionToArchive")
    def transition_to_archive(self) -> Optional[str]:
        """
        The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        """
        return pulumi.get(self, "transition_to_archive")

    @property
    @pulumi.getter(name="transitionToIA")
    def transition_to_ia(self) -> Optional[str]:
        """
        The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Infrequent Access (IA) storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        """
        return pulumi.get(self, "transition_to_ia")

    @property
    @pulumi.getter(name="transitionToPrimaryStorageClass")
    def transition_to_primary_storage_class(self) -> Optional[str]:
        """
        Whether to move files back to primary (Standard) storage after they are accessed in IA or Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        """
        return pulumi.get(self, "transition_to_primary_storage_class")


@pulumi.output_type
class LightsailBucketPropertiesResponse(dict):
    """
    Definition of LightsailBucket
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LightsailBucketPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LightsailBucketPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LightsailBucketPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsLightsailBucketPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of LightsailBucket
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsLightsailBucketPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsLightsailBucketPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class LightsailInstancePropertiesResponse(dict):
    """
    Definition of LightsailInstance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LightsailInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LightsailInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LightsailInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsLightsailInstancePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of LightsailInstance
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsLightsailInstancePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsLightsailInstancePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class LinuxParametersResponse(dict):
    """
    Definition of LinuxParameters
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initProcessEnabled":
            suggest = "init_process_enabled"
        elif key == "maxSwap":
            suggest = "max_swap"
        elif key == "sharedMemorySize":
            suggest = "shared_memory_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capabilities: Optional['outputs.KernelCapabilitiesResponse'] = None,
                 devices: Optional[Sequence['outputs.DeviceResponse']] = None,
                 init_process_enabled: Optional[bool] = None,
                 max_swap: Optional[int] = None,
                 shared_memory_size: Optional[int] = None,
                 swappiness: Optional[int] = None,
                 tmpfs: Optional[Sequence['outputs.TmpfsResponse']] = None):
        """
        Definition of LinuxParameters
        :param 'KernelCapabilitiesResponse' capabilities: The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.  For tasks that use the Fargate launch type, ``capabilities`` is supported for all platform versions but the ``add`` parameter is only supported if using platform version 1.4.0 or later. The Linux capabilities to add or remove from the default Docker configuration for a container defined in the task definition. For more information about the default capabilities and the non-default available capabilities, see [Runtime privilege and Linux capabilities](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities) in the *Docker run reference*. For more detailed information about these Linux capabilities, see the [capabilities(7)](https://docs.aws.amazon.com/http://man7.org/linux/man-pages/man7/capabilities.7.html) Linux manual page.
        :param Sequence['DeviceResponse'] devices: Any host devices to expose to the container. This parameter maps to ``Devices`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--device`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  If you're using tasks that use the Fargate launch type, the ``devices`` parameter isn't supported.
        :param bool init_process_enabled: Run an ``init`` process inside the container that forwards signals and reaps processes. This parameter maps to the ``--init`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). This parameter requires version 1.25 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``
        :param int max_swap: The total amount of swap memory (in MiB) a container can use. This parameter will be translated to the ``--memory-swap`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration) where the value would be the sum of the container memory plus the ``maxSwap`` value. If a ``maxSwap`` value of ``0`` is specified, the container will not use swap. Accepted values are ``0`` or any positive integer. If the ``maxSwap`` parameter is omitted, the container will use the swap configuration for the container instance it is running on. A ``maxSwap`` value must be set for the ``swappiness`` parameter to be used.  If you're using tasks that use the Fargate launch type, the ``maxSwap`` parameter isn't supported. If you're using tasks on Amazon Linux 2023 the ``swappiness`` parameter isn't supported.
        :param int shared_memory_size: The value for the size (in MiB) of the ``/dev/shm`` volume. This parameter maps to the ``--shm-size`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  If you are using tasks that use the Fargate launch type, the ``sharedMemorySize`` parameter is not supported.
        :param int swappiness: This allows you to tune a container's memory swappiness behavior. A ``swappiness`` value of ``0`` will cause swapping to not happen unless absolutely necessary. A ``swappiness`` value of ``100`` will cause pages to be swapped very aggressively. Accepted values are whole numbers between ``0`` and ``100``. If the ``swappiness`` parameter is not specified, a default value of ``60`` is used. If a value is not specified for ``maxSwap`` then this parameter is ignored. This parameter maps to the ``--memory-swappiness`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  If you're using tasks that use the Fargate launch type, the ``swappiness`` parameter isn't supported. If you're using tasks on Amazon Linux 2023 the ``swappiness`` parameter isn't supported.
        :param Sequence['TmpfsResponse'] tmpfs: The container path, mount options, and size (in MiB) of the tmpfs mount. This parameter maps to the ``--tmpfs`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  If you're using tasks that use the Fargate launch type, the ``tmpfs`` parameter isn't supported.
        """
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if init_process_enabled is not None:
            pulumi.set(__self__, "init_process_enabled", init_process_enabled)
        if max_swap is not None:
            pulumi.set(__self__, "max_swap", max_swap)
        if shared_memory_size is not None:
            pulumi.set(__self__, "shared_memory_size", shared_memory_size)
        if swappiness is not None:
            pulumi.set(__self__, "swappiness", swappiness)
        if tmpfs is not None:
            pulumi.set(__self__, "tmpfs", tmpfs)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KernelCapabilitiesResponse']:
        """
        The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.  For tasks that use the Fargate launch type, ``capabilities`` is supported for all platform versions but the ``add`` parameter is only supported if using platform version 1.4.0 or later. The Linux capabilities to add or remove from the default Docker configuration for a container defined in the task definition. For more information about the default capabilities and the non-default available capabilities, see [Runtime privilege and Linux capabilities](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities) in the *Docker run reference*. For more detailed information about these Linux capabilities, see the [capabilities(7)](https://docs.aws.amazon.com/http://man7.org/linux/man-pages/man7/capabilities.7.html) Linux manual page.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def devices(self) -> Optional[Sequence['outputs.DeviceResponse']]:
        """
        Any host devices to expose to the container. This parameter maps to ``Devices`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--device`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  If you're using tasks that use the Fargate launch type, the ``devices`` parameter isn't supported.
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="initProcessEnabled")
    def init_process_enabled(self) -> Optional[bool]:
        """
        Run an ``init`` process inside the container that forwards signals and reaps processes. This parameter maps to the ``--init`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration). This parameter requires version 1.25 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``
        """
        return pulumi.get(self, "init_process_enabled")

    @property
    @pulumi.getter(name="maxSwap")
    def max_swap(self) -> Optional[int]:
        """
        The total amount of swap memory (in MiB) a container can use. This parameter will be translated to the ``--memory-swap`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration) where the value would be the sum of the container memory plus the ``maxSwap`` value. If a ``maxSwap`` value of ``0`` is specified, the container will not use swap. Accepted values are ``0`` or any positive integer. If the ``maxSwap`` parameter is omitted, the container will use the swap configuration for the container instance it is running on. A ``maxSwap`` value must be set for the ``swappiness`` parameter to be used.  If you're using tasks that use the Fargate launch type, the ``maxSwap`` parameter isn't supported. If you're using tasks on Amazon Linux 2023 the ``swappiness`` parameter isn't supported.
        """
        return pulumi.get(self, "max_swap")

    @property
    @pulumi.getter(name="sharedMemorySize")
    def shared_memory_size(self) -> Optional[int]:
        """
        The value for the size (in MiB) of the ``/dev/shm`` volume. This parameter maps to the ``--shm-size`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  If you are using tasks that use the Fargate launch type, the ``sharedMemorySize`` parameter is not supported.
        """
        return pulumi.get(self, "shared_memory_size")

    @property
    @pulumi.getter
    def swappiness(self) -> Optional[int]:
        """
        This allows you to tune a container's memory swappiness behavior. A ``swappiness`` value of ``0`` will cause swapping to not happen unless absolutely necessary. A ``swappiness`` value of ``100`` will cause pages to be swapped very aggressively. Accepted values are whole numbers between ``0`` and ``100``. If the ``swappiness`` parameter is not specified, a default value of ``60`` is used. If a value is not specified for ``maxSwap`` then this parameter is ignored. This parameter maps to the ``--memory-swappiness`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  If you're using tasks that use the Fargate launch type, the ``swappiness`` parameter isn't supported. If you're using tasks on Amazon Linux 2023 the ``swappiness`` parameter isn't supported.
        """
        return pulumi.get(self, "swappiness")

    @property
    @pulumi.getter
    def tmpfs(self) -> Optional[Sequence['outputs.TmpfsResponse']]:
        """
        The container path, mount options, and size (in MiB) of the tmpfs mount. This parameter maps to the ``--tmpfs`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/run/#security-configuration).  If you're using tasks that use the Fargate launch type, the ``tmpfs`` parameter isn't supported.
        """
        return pulumi.get(self, "tmpfs")


@pulumi.output_type
class LoadBalancerAttributeResponse(dict):
    """
    Definition of LoadBalancerAttribute
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of LoadBalancerAttribute
        :param str key: The name of the attribute. The following attributes are supported by all load balancers:  +   ``deletion_protection.enabled`` - Indicates whether deletion protection is enabled. The value is ``true`` or ``false``. The default is ``false``.  +   ``load_balancing.cross_zone.enabled`` - Indicates whether cross-zone load balancing is enabled. The possible values are ``true`` and ``false``. The default for Network Load Balancers and Gateway Load Balancers is ``false``. The default for Application Load Balancers is ``true``, and cannot be changed.   The following attributes are supported by both Application Load Balancers and Network Load Balancers:  +   ``access_logs.s3.enabled`` - Indicates whether access logs are enabled. The value is ``true`` or ``false``. The default is ``false``.  +   ``access_logs.s3.bucket`` - The name of the S3 bucket for the access logs. This attribute is required if access logs are enabled. The bucket must exist in the same region as the load balancer and have a bucket policy that grants Elastic Load Balancing permissions to write to the bucket.  +   ``access_logs.s3.prefix`` - The prefix for the location in the S3 bucket for the access logs.  +   ``ipv6.deny_all_igw_traffic`` - Blocks internet gateway (IGW) access to the load balancer. It is set to ``false`` for internet-facing load balancers and ``true`` for internal load balancers, preventing unintended access to your internal load balancer through an internet gateway.   The following attributes are supported by only Application Load Balancers:  +   ``idle_timeout.timeout_seconds`` - The idle timeout value, in seconds. The valid range is 1-4000 seconds. The default is 60 seconds.  +   ``client_keep_alive.seconds`` - The client keep alive value, in seconds. The valid range is 60-604800 seconds. The default is 3600 seconds.  +   ``connection_logs.s3.enabled`` - Indicates whether connection logs are enabled. The value is ``true`` or ``false``. The default is ``false``.  +   ``connection_logs.s3.bucket`` - The name of the S3 bucket for the connection logs. This attribute is required if connection logs are enabled. The bucket must exist in the same region as the load balancer and have a bucket policy that grants Elastic Load Balancing permissions to write to the bucket.  +   ``connection_logs.s3.prefix`` - The prefix for the location in the S3 bucket for the connection logs.  +   ``routing.http.desync_mitigation_mode`` - Determines how the load balancer handles requests that might pose a security risk to your application. The possible values are ``monitor``, ``defensive``, and ``strictest``. The default is ``defensive``.  +   ``routing.http.drop_invalid_header_fields.enabled`` - Indicates whether HTTP headers with invalid header fields are removed by the load balancer (``true``) or routed to targets (``false``). The default is ``false``.  +   ``routing.http.preserve_host_header.enabled`` - Indicates whether the Application Load Balancer should preserve the ``Host`` header in the HTTP request and send it to the target without any change. The possible values are ``true`` and ``false``. The default is ``false``.  +   ``routing.http.x_amzn_tls_version_and_cipher_suite.enabled`` - Indicates whether the two headers (``x-amzn-tls-version`` and ``x-amzn-tls-cipher-suite``), which contain information about the negotiated TLS version and cipher suite, are added to the client request before sending it to the target. The ``x-amzn-tls-version`` header has information about the TLS protocol version negotiated with the client, and the ``x-amzn-tls-cipher-suite`` header has information about the cipher suite negotiated with the client. Both headers are in OpenSSL format. The possible values for the attribute are ``true`` and ``false``. The default is ``false``.  +   ``routing.http.xff_client_port.enabled`` - Indicates whether the ``X-Forwarded-For`` header should preserve the source port that the client used to connect to the load balancer. The possible values are ``true`` and ``false``. The default is ``false``.  +   ``routing.http.xff_header_processing.mode`` - Enables you to modify, preserve, or remove the ``X-Forwarded-For`` header in the HTTP request before the Application Load Balancer sends the request to the target. The possible values are ``append``, ``preserve``, and ``remove``. The default is ``append``.  +  If the value is ``append``, the Application Load Balancer adds the client IP address (of the last hop) to the ``X-Forwarded-For`` header in the HTTP request before it sends it to targets.  +  If the value is ``preserve`` the Application Load Balancer preserves the ``X-Forwarded-For`` header in the HTTP request, and sends it to targets without any change.  +  If the value is ``remove``, the Application Load Balancer removes the ``X-Forwarded-For`` header in the HTTP request before it sends it to targets.    +   ``routing.http2.enabled`` - Indicates whether HTTP/2 is enabled. The possible values are ``true`` and ``false``. The default is ``true``. Elastic Load Balancing requires that message header names contain only alphanumeric characters and hyphens.  +   ``waf.fail_open.enabled`` - Indicates whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. The possible values are ``true`` and ``false``. The default is ``false``.   The following attributes are supported by only Network Load Balancers:  +   ``dns_record.client_routing_policy`` - Indicates how traffic is distributed among the load balancer Availability Zones. The possible values are ``availability_zone_affinity`` with 100 percent zonal affinity, ``partial_availability_zone_affinity`` with 85 percent zonal affinity, and ``any_availability_zone`` with 0 percent zonal affinity.
        :param str value: The value of the attribute.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The name of the attribute. The following attributes are supported by all load balancers:  +   ``deletion_protection.enabled`` - Indicates whether deletion protection is enabled. The value is ``true`` or ``false``. The default is ``false``.  +   ``load_balancing.cross_zone.enabled`` - Indicates whether cross-zone load balancing is enabled. The possible values are ``true`` and ``false``. The default for Network Load Balancers and Gateway Load Balancers is ``false``. The default for Application Load Balancers is ``true``, and cannot be changed.   The following attributes are supported by both Application Load Balancers and Network Load Balancers:  +   ``access_logs.s3.enabled`` - Indicates whether access logs are enabled. The value is ``true`` or ``false``. The default is ``false``.  +   ``access_logs.s3.bucket`` - The name of the S3 bucket for the access logs. This attribute is required if access logs are enabled. The bucket must exist in the same region as the load balancer and have a bucket policy that grants Elastic Load Balancing permissions to write to the bucket.  +   ``access_logs.s3.prefix`` - The prefix for the location in the S3 bucket for the access logs.  +   ``ipv6.deny_all_igw_traffic`` - Blocks internet gateway (IGW) access to the load balancer. It is set to ``false`` for internet-facing load balancers and ``true`` for internal load balancers, preventing unintended access to your internal load balancer through an internet gateway.   The following attributes are supported by only Application Load Balancers:  +   ``idle_timeout.timeout_seconds`` - The idle timeout value, in seconds. The valid range is 1-4000 seconds. The default is 60 seconds.  +   ``client_keep_alive.seconds`` - The client keep alive value, in seconds. The valid range is 60-604800 seconds. The default is 3600 seconds.  +   ``connection_logs.s3.enabled`` - Indicates whether connection logs are enabled. The value is ``true`` or ``false``. The default is ``false``.  +   ``connection_logs.s3.bucket`` - The name of the S3 bucket for the connection logs. This attribute is required if connection logs are enabled. The bucket must exist in the same region as the load balancer and have a bucket policy that grants Elastic Load Balancing permissions to write to the bucket.  +   ``connection_logs.s3.prefix`` - The prefix for the location in the S3 bucket for the connection logs.  +   ``routing.http.desync_mitigation_mode`` - Determines how the load balancer handles requests that might pose a security risk to your application. The possible values are ``monitor``, ``defensive``, and ``strictest``. The default is ``defensive``.  +   ``routing.http.drop_invalid_header_fields.enabled`` - Indicates whether HTTP headers with invalid header fields are removed by the load balancer (``true``) or routed to targets (``false``). The default is ``false``.  +   ``routing.http.preserve_host_header.enabled`` - Indicates whether the Application Load Balancer should preserve the ``Host`` header in the HTTP request and send it to the target without any change. The possible values are ``true`` and ``false``. The default is ``false``.  +   ``routing.http.x_amzn_tls_version_and_cipher_suite.enabled`` - Indicates whether the two headers (``x-amzn-tls-version`` and ``x-amzn-tls-cipher-suite``), which contain information about the negotiated TLS version and cipher suite, are added to the client request before sending it to the target. The ``x-amzn-tls-version`` header has information about the TLS protocol version negotiated with the client, and the ``x-amzn-tls-cipher-suite`` header has information about the cipher suite negotiated with the client. Both headers are in OpenSSL format. The possible values for the attribute are ``true`` and ``false``. The default is ``false``.  +   ``routing.http.xff_client_port.enabled`` - Indicates whether the ``X-Forwarded-For`` header should preserve the source port that the client used to connect to the load balancer. The possible values are ``true`` and ``false``. The default is ``false``.  +   ``routing.http.xff_header_processing.mode`` - Enables you to modify, preserve, or remove the ``X-Forwarded-For`` header in the HTTP request before the Application Load Balancer sends the request to the target. The possible values are ``append``, ``preserve``, and ``remove``. The default is ``append``.  +  If the value is ``append``, the Application Load Balancer adds the client IP address (of the last hop) to the ``X-Forwarded-For`` header in the HTTP request before it sends it to targets.  +  If the value is ``preserve`` the Application Load Balancer preserves the ``X-Forwarded-For`` header in the HTTP request, and sends it to targets without any change.  +  If the value is ``remove``, the Application Load Balancer removes the ``X-Forwarded-For`` header in the HTTP request before it sends it to targets.    +   ``routing.http2.enabled`` - Indicates whether HTTP/2 is enabled. The possible values are ``true`` and ``false``. The default is ``true``. Elastic Load Balancing requires that message header names contain only alphanumeric characters and hyphens.  +   ``waf.fail_open.enabled`` - Indicates whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. The possible values are ``true`` and ``false``. The default is ``false``.   The following attributes are supported by only Network Load Balancers:  +   ``dns_record.client_routing_policy`` - Indicates how traffic is distributed among the load balancer Availability Zones. The possible values are ``availability_zone_affinity`` with 100 percent zonal affinity, ``partial_availability_zone_affinity`` with 85 percent zonal affinity, and ``any_availability_zone`` with 0 percent zonal affinity.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the attribute.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LoadBalancerResponse(dict):
    """
    Definition of LoadBalancer
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"
        elif key == "containerPort":
            suggest = "container_port"
        elif key == "loadBalancerName":
            suggest = "load_balancer_name"
        elif key == "targetGroupArn":
            suggest = "target_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: Optional[str] = None,
                 container_port: Optional[int] = None,
                 load_balancer_name: Optional[str] = None,
                 target_group_arn: Optional[str] = None):
        """
        Definition of LoadBalancer
        :param str container_name: The name of the container (as it appears in a container definition) to associate with the load balancer. You need to specify the container name when configuring the target group for an Amazon ECS load balancer.
        :param int container_port: The port on the container to associate with the load balancer. This port must correspond to a ``containerPort`` in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they're launched on must allow ingress traffic on the ``hostPort`` of the port mapping.
        :param str load_balancer_name: The name of the load balancer to associate with the Amazon ECS service or task set. If you are using an Application Load Balancer or a Network Load Balancer the load balancer name parameter should be omitted.
        :param str target_group_arn: The full Amazon Resource Name (ARN) of the Elastic Load Balancing target group or groups associated with a service or task set. A target group ARN is only specified when using an Application Load Balancer or Network Load Balancer.  For services using the ``ECS`` deployment controller, you can specify one or multiple target groups. For more information, see [Registering multiple target groups with a service](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/register-multiple-targetgroups.html) in the *Amazon Elastic Container Service Developer Guide*. For services using the ``CODE_DEPLOY`` deployment controller, you're required to define two target groups for the load balancer. For more information, see [Blue/green deployment with CodeDeploy](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-bluegreen.html) in the *Amazon Elastic Container Service Developer Guide*.  If your service's task definition uses the ``awsvpc`` network mode, you must choose ``ip`` as the target type, not ``instance``. Do this when creating your target groups because tasks that use the ``awsvpc`` network mode are associated with an elastic network interface, not an Amazon EC2 instance. This network mode is required for the Fargate launch type.
        """
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if load_balancer_name is not None:
            pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        The name of the container (as it appears in a container definition) to associate with the load balancer. You need to specify the container name when configuring the target group for an Amazon ECS load balancer.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[int]:
        """
        The port on the container to associate with the load balancer. This port must correspond to a ``containerPort`` in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they're launched on must allow ingress traffic on the ``hostPort`` of the port mapping.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> Optional[str]:
        """
        The name of the load balancer to associate with the Amazon ECS service or task set. If you are using an Application Load Balancer or a Network Load Balancer the load balancer name parameter should be omitted.
        """
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[str]:
        """
        The full Amazon Resource Name (ARN) of the Elastic Load Balancing target group or groups associated with a service or task set. A target group ARN is only specified when using an Application Load Balancer or Network Load Balancer.  For services using the ``ECS`` deployment controller, you can specify one or multiple target groups. For more information, see [Registering multiple target groups with a service](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/register-multiple-targetgroups.html) in the *Amazon Elastic Container Service Developer Guide*. For services using the ``CODE_DEPLOY`` deployment controller, you're required to define two target groups for the load balancer. For more information, see [Blue/green deployment with CodeDeploy](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-bluegreen.html) in the *Amazon Elastic Container Service Developer Guide*.  If your service's task definition uses the ``awsvpc`` network mode, you must choose ``ip`` as the target type, not ``instance``. Do this when creating your target groups because tasks that use the ``awsvpc`` network mode are associated with an elastic network interface, not an Amazon EC2 instance. This network mode is required for the Fargate launch type.
        """
        return pulumi.get(self, "target_group_arn")


@pulumi.output_type
class LocalSecondaryIndexResponse(dict):
    """
    Definition of LocalSecondaryIndex
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexName":
            suggest = "index_name"
        elif key == "keySchema":
            suggest = "key_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalSecondaryIndexResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalSecondaryIndexResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalSecondaryIndexResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index_name: Optional[str] = None,
                 key_schema: Optional[Sequence['outputs.KeySchemaResponse']] = None,
                 projection: Optional['outputs.ProjectionResponse'] = None):
        """
        Definition of LocalSecondaryIndex
        :param str index_name: The name of the local secondary index. The name must be unique among all other indexes on this table.
        :param Sequence['KeySchemaResponse'] key_schema: The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:  +   ``HASH`` - partition key  +   ``RANGE`` - sort key    The partition key of an item is also known as its *hash attribute*. The term 'hash attribute' derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values. The sort key of an item is also known as its *range attribute*. The term 'range attribute' derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        :param 'ProjectionResponse' projection: Represents attributes that are copied (projected) from the table into the local secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if key_schema is not None:
            pulumi.set(__self__, "key_schema", key_schema)
        if projection is not None:
            pulumi.set(__self__, "projection", projection)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[str]:
        """
        The name of the local secondary index. The name must be unique among all other indexes on this table.
        """
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> Optional[Sequence['outputs.KeySchemaResponse']]:
        """
        The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:  +   ``HASH`` - partition key  +   ``RANGE`` - sort key    The partition key of an item is also known as its *hash attribute*. The term 'hash attribute' derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values. The sort key of an item is also known as its *range attribute*. The term 'range attribute' derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_schema")

    @property
    @pulumi.getter
    def projection(self) -> Optional['outputs.ProjectionResponse']:
        """
        Represents attributes that are copied (projected) from the table into the local secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        return pulumi.get(self, "projection")


@pulumi.output_type
class LocationResponse(dict):
    """
    Definition of Location
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 region_name: Optional[str] = None):
        """
        Definition of Location
        :param str availability_zone: The Availability Zone in which to create your instance. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
        :param str region_name: The Region Name in which to create your instance.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone in which to create your instance. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        The Region Name in which to create your instance.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class LogConfigResponse(dict):
    """
    Definition of LogConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogsRoleArn":
            suggest = "cloud_watch_logs_role_arn"
        elif key == "excludeVerboseContent":
            suggest = "exclude_verbose_content"
        elif key == "fieldLogLevel":
            suggest = "field_log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs_role_arn: Optional[str] = None,
                 exclude_verbose_content: Optional[bool] = None,
                 field_log_level: Optional['outputs.FieldLogLevelEnumValueResponse'] = None):
        """
        Definition of LogConfig
        :param str cloud_watch_logs_role_arn: <p>The service role that AppSync assumes to publish to CloudWatch logs in your account.</p>
        :param bool exclude_verbose_content: <p>Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging level.</p>
        :param 'FieldLogLevelEnumValueResponse' field_log_level: <p>The field logging level. Values can be NONE, ERROR, or ALL.</p> <ul> <li> <p> <b>NONE</b>: No field-level logs are captured.</p> </li> <li> <p> <b>ERROR</b>: Logs the following information only for the fields that are in error:</p> <ul> <li> <p>The error section in the server response.</p> </li> <li> <p>Field-level errors.</p> </li> <li> <p>The generated request/response functions that got resolved for error fields.</p> </li> </ul> </li> <li> <p> <b>ALL</b>: The following information is logged for all fields in the query:</p> <ul> <li> <p>Field-level tracing information.</p> </li> <li> <p>The generated request/response functions that got resolved for each field.</p> </li> </ul> </li> </ul>
        """
        if cloud_watch_logs_role_arn is not None:
            pulumi.set(__self__, "cloud_watch_logs_role_arn", cloud_watch_logs_role_arn)
        if exclude_verbose_content is not None:
            pulumi.set(__self__, "exclude_verbose_content", exclude_verbose_content)
        if field_log_level is not None:
            pulumi.set(__self__, "field_log_level", field_log_level)

    @property
    @pulumi.getter(name="cloudWatchLogsRoleArn")
    def cloud_watch_logs_role_arn(self) -> Optional[str]:
        """
        <p>The service role that AppSync assumes to publish to CloudWatch logs in your account.</p>
        """
        return pulumi.get(self, "cloud_watch_logs_role_arn")

    @property
    @pulumi.getter(name="excludeVerboseContent")
    def exclude_verbose_content(self) -> Optional[bool]:
        """
        <p>Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging level.</p>
        """
        return pulumi.get(self, "exclude_verbose_content")

    @property
    @pulumi.getter(name="fieldLogLevel")
    def field_log_level(self) -> Optional['outputs.FieldLogLevelEnumValueResponse']:
        """
        <p>The field logging level. Values can be NONE, ERROR, or ALL.</p> <ul> <li> <p> <b>NONE</b>: No field-level logs are captured.</p> </li> <li> <p> <b>ERROR</b>: Logs the following information only for the fields that are in error:</p> <ul> <li> <p>The error section in the server response.</p> </li> <li> <p>Field-level errors.</p> </li> <li> <p>The generated request/response functions that got resolved for error fields.</p> </li> </ul> </li> <li> <p> <b>ALL</b>: The following information is logged for all fields in the query:</p> <ul> <li> <p>Field-level tracing information.</p> </li> <li> <p>The generated request/response functions that got resolved for each field.</p> </li> </ul> </li> </ul>
        """
        return pulumi.get(self, "field_log_level")


@pulumi.output_type
class LogConfigurationResponse(dict):
    """
    Definition of LogConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logDriver":
            suggest = "log_driver"
        elif key == "secretOptions":
            suggest = "secret_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_driver: Optional[str] = None,
                 options: Optional[Any] = None,
                 secret_options: Optional[Sequence['outputs.SecretResponse']] = None):
        """
        Definition of LogConfiguration
        :param str log_driver: The log driver to use for the container. For tasks on FARGATElong, the supported log drivers are ``awslogs``, ``splunk``, and ``awsfirelens``. For tasks hosted on Amazon EC2 instances, the supported log drivers are ``awslogs``, ``fluentd``, ``gelf``, ``json-file``, ``journald``, ``logentries``,``syslog``, ``splunk``, and ``awsfirelens``. For more information about using the ``awslogs`` log driver, see [Using the awslogs log driver](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_awslogs.html) in the *Amazon Elastic Container Service Developer Guide*. For more information about using the ``awsfirelens`` log driver, see [Custom log routing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_firelens.html) in the *Amazon Elastic Container Service Developer Guide*.  If you have a custom driver that isn't listed, you can fork the Amazon ECS container agent project that's [available on GitHub](https://docs.aws.amazon.com/https://github.com/aws/amazon-ecs-agent) and customize it to work with that driver. We encourage you to submit pull requests for changes that you would like to have included. However, we don't currently provide support for running modified copies of this software.
        :param Any options: The configuration options to send to the log driver. This parameter requires version 1.19 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``
        :param Sequence['SecretResponse'] secret_options: The secrets to pass to the log configuration. For more information, see [Specifying sensitive data](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/specifying-sensitive-data.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        if log_driver is not None:
            pulumi.set(__self__, "log_driver", log_driver)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if secret_options is not None:
            pulumi.set(__self__, "secret_options", secret_options)

    @property
    @pulumi.getter(name="logDriver")
    def log_driver(self) -> Optional[str]:
        """
        The log driver to use for the container. For tasks on FARGATElong, the supported log drivers are ``awslogs``, ``splunk``, and ``awsfirelens``. For tasks hosted on Amazon EC2 instances, the supported log drivers are ``awslogs``, ``fluentd``, ``gelf``, ``json-file``, ``journald``, ``logentries``,``syslog``, ``splunk``, and ``awsfirelens``. For more information about using the ``awslogs`` log driver, see [Using the awslogs log driver](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_awslogs.html) in the *Amazon Elastic Container Service Developer Guide*. For more information about using the ``awsfirelens`` log driver, see [Custom log routing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_firelens.html) in the *Amazon Elastic Container Service Developer Guide*.  If you have a custom driver that isn't listed, you can fork the Amazon ECS container agent project that's [available on GitHub](https://docs.aws.amazon.com/https://github.com/aws/amazon-ecs-agent) and customize it to work with that driver. We encourage you to submit pull requests for changes that you would like to have included. However, we don't currently provide support for running modified copies of this software.
        """
        return pulumi.get(self, "log_driver")

    @property
    @pulumi.getter
    def options(self) -> Optional[Any]:
        """
        The configuration options to send to the log driver. This parameter requires version 1.19 of the Docker Remote API or greater on your container instance. To check the Docker Remote API version on your container instance, log in to your container instance and run the following command: ``sudo docker version --format '{{.Server.APIVersion}}'``
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="secretOptions")
    def secret_options(self) -> Optional[Sequence['outputs.SecretResponse']]:
        """
        The secrets to pass to the log configuration. For more information, see [Specifying sensitive data](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/specifying-sensitive-data.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "secret_options")


@pulumi.output_type
class LogPublishingOptionResponse(dict):
    """
    Definition of LogPublishingOption
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogsLogGroupArn":
            suggest = "cloud_watch_logs_log_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogPublishingOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogPublishingOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogPublishingOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs_log_group_arn: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        Definition of LogPublishingOption
        :param str cloud_watch_logs_log_group_arn: <p>The Amazon Resource Name (ARN) of the CloudWatch Logs group to publish logs to.</p>
        :param bool enabled: <p>Whether the log should be published.</p>
        """
        if cloud_watch_logs_log_group_arn is not None:
            pulumi.set(__self__, "cloud_watch_logs_log_group_arn", cloud_watch_logs_log_group_arn)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="cloudWatchLogsLogGroupArn")
    def cloud_watch_logs_log_group_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the CloudWatch Logs group to publish logs to.</p>
        """
        return pulumi.get(self, "cloud_watch_logs_log_group_arn")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>Whether the log should be published.</p>
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LogSetupResponse(dict):
    """
    Definition of LogSetup
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 types: Optional[Sequence[str]] = None):
        """
        Definition of LogSetup
        :param bool enabled: <p>If a log type is enabled, that log type exports its control plane logs to CloudWatch Logs. If a log type isn't enabled, that log type doesn't export its control plane logs. Each individual log type can be enabled or disabled independently.</p>
        :param Sequence[str] types: <p>The available cluster control plane log types.</p>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>If a log type is enabled, that log type exports its control plane logs to CloudWatch Logs. If a log type isn't enabled, that log type doesn't export its control plane logs. Each individual log type can be enabled or disabled independently.</p>
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def types(self) -> Optional[Sequence[str]]:
        """
        <p>The available cluster control plane log types.</p>
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class LoggingConfigResponse(dict):
    """
    Definition of LoggingConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogLevel":
            suggest = "application_log_level"
        elif key == "failureFeedbackRoleArn":
            suggest = "failure_feedback_role_arn"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logGroup":
            suggest = "log_group"
        elif key == "successFeedbackRoleArn":
            suggest = "success_feedback_role_arn"
        elif key == "successFeedbackSampleRate":
            suggest = "success_feedback_sample_rate"
        elif key == "systemLogLevel":
            suggest = "system_log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_log_level: Optional[str] = None,
                 failure_feedback_role_arn: Optional[str] = None,
                 log_format: Optional[str] = None,
                 log_group: Optional[str] = None,
                 protocol: Optional[str] = None,
                 success_feedback_role_arn: Optional[str] = None,
                 success_feedback_sample_rate: Optional[str] = None,
                 system_log_level: Optional[str] = None):
        """
        Definition of LoggingConfig
        :param str application_log_level: Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where ``TRACE`` is the highest level and ``FATAL`` is the lowest.
        :param str failure_feedback_role_arn: Property failureFeedbackRoleArn
        :param str log_format: The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
        :param str log_group: The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named ``/aws/lambda/<function name>``. To use a different log group, enter an existing log group or enter a new log group name.
        :param str protocol: Property protocol
        :param str success_feedback_role_arn: Property successFeedbackRoleArn
        :param str success_feedback_sample_rate: Property successFeedbackSampleRate
        :param str system_log_level: Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where ``DEBUG`` is the highest level and ``WARN`` is the lowest.
        """
        if application_log_level is not None:
            pulumi.set(__self__, "application_log_level", application_log_level)
        if failure_feedback_role_arn is not None:
            pulumi.set(__self__, "failure_feedback_role_arn", failure_feedback_role_arn)
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if success_feedback_role_arn is not None:
            pulumi.set(__self__, "success_feedback_role_arn", success_feedback_role_arn)
        if success_feedback_sample_rate is not None:
            pulumi.set(__self__, "success_feedback_sample_rate", success_feedback_sample_rate)
        if system_log_level is not None:
            pulumi.set(__self__, "system_log_level", system_log_level)

    @property
    @pulumi.getter(name="applicationLogLevel")
    def application_log_level(self) -> Optional[str]:
        """
        Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where ``TRACE`` is the highest level and ``FATAL`` is the lowest.
        """
        return pulumi.get(self, "application_log_level")

    @property
    @pulumi.getter(name="failureFeedbackRoleArn")
    def failure_feedback_role_arn(self) -> Optional[str]:
        """
        Property failureFeedbackRoleArn
        """
        return pulumi.get(self, "failure_feedback_role_arn")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[str]:
        """
        The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
        """
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[str]:
        """
        The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named ``/aws/lambda/<function name>``. To use a different log group, enter an existing log group or enter a new log group name.
        """
        return pulumi.get(self, "log_group")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Property protocol
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="successFeedbackRoleArn")
    def success_feedback_role_arn(self) -> Optional[str]:
        """
        Property successFeedbackRoleArn
        """
        return pulumi.get(self, "success_feedback_role_arn")

    @property
    @pulumi.getter(name="successFeedbackSampleRate")
    def success_feedback_sample_rate(self) -> Optional[str]:
        """
        Property successFeedbackSampleRate
        """
        return pulumi.get(self, "success_feedback_sample_rate")

    @property
    @pulumi.getter(name="systemLogLevel")
    def system_log_level(self) -> Optional[str]:
        """
        Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where ``DEBUG`` is the highest level and ``WARN`` is the lowest.
        """
        return pulumi.get(self, "system_log_level")


@pulumi.output_type
class LoggingConfigurationResponse(dict):
    """
    Definition of LoggingConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationBucketName":
            suggest = "destination_bucket_name"
        elif key == "logFilePrefix":
            suggest = "log_file_prefix"
        elif key == "targetObjectKeyFormat":
            suggest = "target_object_key_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_bucket_name: Optional[str] = None,
                 log_file_prefix: Optional[str] = None,
                 target_object_key_format: Optional['outputs.TargetObjectKeyFormatResponse'] = None):
        """
        Definition of LoggingConfiguration
        :param str destination_bucket_name: The name of the bucket where Amazon S3 should store server access log files. You can store log files in any bucket that you own. By default, logs are stored in the bucket where the ``LoggingConfiguration`` property is defined.
        :param str log_file_prefix: A prefix for all log object keys. If you store log files from multiple Amazon S3 buckets in a single bucket, you can use a prefix to distinguish which log files came from which bucket.
        :param 'TargetObjectKeyFormatResponse' target_object_key_format: Amazon S3 key format for log objects. Only one format, either PartitionedPrefix or SimplePrefix, is allowed. Describes the key format for server access log file in the target bucket. You can choose between SimplePrefix and PartitionedPrefix.
        """
        if destination_bucket_name is not None:
            pulumi.set(__self__, "destination_bucket_name", destination_bucket_name)
        if log_file_prefix is not None:
            pulumi.set(__self__, "log_file_prefix", log_file_prefix)
        if target_object_key_format is not None:
            pulumi.set(__self__, "target_object_key_format", target_object_key_format)

    @property
    @pulumi.getter(name="destinationBucketName")
    def destination_bucket_name(self) -> Optional[str]:
        """
        The name of the bucket where Amazon S3 should store server access log files. You can store log files in any bucket that you own. By default, logs are stored in the bucket where the ``LoggingConfiguration`` property is defined.
        """
        return pulumi.get(self, "destination_bucket_name")

    @property
    @pulumi.getter(name="logFilePrefix")
    def log_file_prefix(self) -> Optional[str]:
        """
        A prefix for all log object keys. If you store log files from multiple Amazon S3 buckets in a single bucket, you can use a prefix to distinguish which log files came from which bucket.
        """
        return pulumi.get(self, "log_file_prefix")

    @property
    @pulumi.getter(name="targetObjectKeyFormat")
    def target_object_key_format(self) -> Optional['outputs.TargetObjectKeyFormatResponse']:
        """
        Amazon S3 key format for log objects. Only one format, either PartitionedPrefix or SimplePrefix, is allowed. Describes the key format for server access log file in the target bucket. You can choose between SimplePrefix and PartitionedPrefix.
        """
        return pulumi.get(self, "target_object_key_format")


@pulumi.output_type
class LoggingFilterModelPropertiesResponse(dict):
    """
    Definition of LoggingFilterModelProperties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBehavior":
            suggest = "default_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingFilterModelPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingFilterModelPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingFilterModelPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_behavior: Optional[str] = None,
                 filters: Optional[Sequence['outputs.FilterResponse']] = None):
        """
        Definition of LoggingFilterModelProperties
        :param str default_behavior: Default handling for logs that don't match any of the specified filtering conditions.
        :param Sequence['FilterResponse'] filters: The filters that you want to apply to the logs.
        """
        if default_behavior is not None:
            pulumi.set(__self__, "default_behavior", default_behavior)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> Optional[str]:
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        """
        return pulumi.get(self, "default_behavior")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.FilterResponse']]:
        """
        The filters that you want to apply to the logs.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class LoggingPropertiesResponse(dict):
    """
    Definition of LoggingProperties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "s3KeyPrefix":
            suggest = "s3_key_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 s3_key_prefix: Optional[str] = None):
        """
        Definition of LoggingProperties
        :param str bucket_name: Property bucketName
        :param str s3_key_prefix: Property s3KeyPrefix
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Property bucketName
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[str]:
        """
        Property s3KeyPrefix
        """
        return pulumi.get(self, "s3_key_prefix")


@pulumi.output_type
class LoggingResponse(dict):
    """
    Definition of Logging
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterLogging":
            suggest = "cluster_logging"
        elif key == "includeCookies":
            suggest = "include_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 cluster_logging: Optional[Sequence['outputs.LogSetupResponse']] = None,
                 include_cookies: Optional[bool] = None,
                 prefix: Optional[str] = None):
        """
        Definition of Logging
        :param str bucket: The Amazon S3 bucket to store the access logs in, for example, ``myawslogbucket.s3.amazonaws.com``.
        :param Sequence['LogSetupResponse'] cluster_logging: <p>The cluster control plane logging configuration for your cluster.</p>
        :param bool include_cookies: Specifies whether you want CloudFront to include cookies in access logs, specify ``true`` for ``IncludeCookies``. If you choose to include cookies in logs, CloudFront logs all cookies regardless of how you configure the cache behaviors for this distribution. If you don't want to include cookies when you create a distribution or if you want to disable include cookies for an existing distribution, specify ``false`` for ``IncludeCookies``.
        :param str prefix: An optional string that you want CloudFront to prefix to the access log ``filenames`` for this distribution, for example, ``myprefix/``. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty ``Prefix`` element in the ``Logging`` element.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if cluster_logging is not None:
            pulumi.set(__self__, "cluster_logging", cluster_logging)
        if include_cookies is not None:
            pulumi.set(__self__, "include_cookies", include_cookies)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The Amazon S3 bucket to store the access logs in, for example, ``myawslogbucket.s3.amazonaws.com``.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clusterLogging")
    def cluster_logging(self) -> Optional[Sequence['outputs.LogSetupResponse']]:
        """
        <p>The cluster control plane logging configuration for your cluster.</p>
        """
        return pulumi.get(self, "cluster_logging")

    @property
    @pulumi.getter(name="includeCookies")
    def include_cookies(self) -> Optional[bool]:
        """
        Specifies whether you want CloudFront to include cookies in access logs, specify ``true`` for ``IncludeCookies``. If you choose to include cookies in logs, CloudFront logs all cookies regardless of how you configure the cache behaviors for this distribution. If you don't want to include cookies when you create a distribution or if you want to disable include cookies for an existing distribution, specify ``false`` for ``IncludeCookies``.
        """
        return pulumi.get(self, "include_cookies")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An optional string that you want CloudFront to prefix to the access log ``filenames`` for this distribution, for example, ``myprefix/``. If you want to enable logging, but you don't want to specify a prefix, you still must include an empty ``Prefix`` element in the ``Logging`` element.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class LogsConfigResponse(dict):
    """
    Definition of LogsConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogs":
            suggest = "cloud_watch_logs"
        elif key == "s3Logs":
            suggest = "s3_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs: Optional['outputs.CloudWatchLogsConfigResponse'] = None,
                 s3_logs: Optional['outputs.S3LogsConfigResponse'] = None):
        """
        Definition of LogsConfig
        :param 'CloudWatchLogsConfigResponse' cloud_watch_logs: <p> Information about CloudWatch Logs for a build project. CloudWatch Logs are enabled by default. </p>
        :param 'S3LogsConfigResponse' s3_logs: <p> Information about logs built to an S3 bucket for a build project. S3 logs are not enabled by default. </p>
        """
        if cloud_watch_logs is not None:
            pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)
        if s3_logs is not None:
            pulumi.set(__self__, "s3_logs", s3_logs)

    @property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> Optional['outputs.CloudWatchLogsConfigResponse']:
        """
        <p> Information about CloudWatch Logs for a build project. CloudWatch Logs are enabled by default. </p>
        """
        return pulumi.get(self, "cloud_watch_logs")

    @property
    @pulumi.getter(name="s3Logs")
    def s3_logs(self) -> Optional['outputs.S3LogsConfigResponse']:
        """
        <p> Information about logs built to an S3 bucket for a build project. S3 logs are not enabled by default. </p>
        """
        return pulumi.get(self, "s3_logs")


@pulumi.output_type
class LogsConfigStatusTypeEnumValueResponse(dict):
    """
    Definition of LogsConfigStatusTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of LogsConfigStatusTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LogsLogGroupPropertiesResponse(dict):
    """
    Definition of LogsLogGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsLogGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsLogGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsLogGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsLogsLogGroupPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of LogsLogGroup
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsLogsLogGroupPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsLogsLogGroupPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class LogsLogStreamPropertiesResponse(dict):
    """
    Definition of LogsLogStream
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsLogStreamPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsLogStreamPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsLogStreamPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsLogsLogStreamPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of LogsLogStream
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsLogsLogStreamPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsLogsLogStreamPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class LogsMetricFilterPropertiesResponse(dict):
    """
    Definition of LogsMetricFilter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsMetricFilterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsMetricFilterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsMetricFilterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsLogsMetricFilterPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of LogsMetricFilter
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsLogsMetricFilterPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsLogsMetricFilterPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class LogsSubscriptionFilterPropertiesResponse(dict):
    """
    Definition of LogsSubscriptionFilter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsSubscriptionFilterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsSubscriptionFilterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsSubscriptionFilterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsLogsSubscriptionFilterPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of LogsSubscriptionFilter
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsLogsSubscriptionFilterPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsLogsSubscriptionFilterPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Macie2JobSummaryPropertiesResponse(dict):
    """
    Definition of Macie2JobSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Macie2JobSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Macie2JobSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Macie2JobSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsMacie2JobSummaryPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Macie2JobSummary
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsMacie2JobSummaryPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsMacie2JobSummaryPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class MacieAllowListPropertiesResponse(dict):
    """
    Definition of MacieAllowList
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MacieAllowListPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MacieAllowListPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MacieAllowListPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsMacieAllowListPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of MacieAllowList
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsMacieAllowListPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsMacieAllowListPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class MasterUserSecretResponse(dict):
    """
    Definition of MasterUserSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "secretArn":
            suggest = "secret_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MasterUserSecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MasterUserSecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MasterUserSecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_id: Optional[str] = None,
                 secret_arn: Optional[str] = None):
        """
        Definition of MasterUserSecret
        :param str kms_key_id: The AWS KMS key identifier that is used to encrypt the secret.
        :param str secret_arn: The Amazon Resource Name (ARN) of the secret.
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The AWS KMS key identifier that is used to encrypt the secret.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the secret.
        """
        return pulumi.get(self, "secret_arn")


@pulumi.output_type
class MatchAttributesResponse(dict):
    """
    Definition of MatchAttributes
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "sourcePorts":
            suggest = "source_ports"
        elif key == "tcpFlags":
            suggest = "tcp_flags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MatchAttributesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MatchAttributesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MatchAttributesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ports: Optional[Sequence['outputs.PortRangeResponse']] = None,
                 destinations: Optional[Sequence['outputs.AddressResponse']] = None,
                 protocols: Optional[Sequence[int]] = None,
                 source_ports: Optional[Sequence['outputs.PortRangeResponse']] = None,
                 sources: Optional[Sequence['outputs.AddressResponse']] = None,
                 tcp_flags: Optional[Sequence['outputs.TCPFlagFieldResponse']] = None):
        """
        Definition of MatchAttributes
        :param Sequence['PortRangeResponse'] destination_ports: Property destinationPorts
        :param Sequence['AddressResponse'] destinations: Property destinations
        :param Sequence[int] protocols: Property protocols
        :param Sequence['PortRangeResponse'] source_ports: Property sourcePorts
        :param Sequence['AddressResponse'] sources: Property sources
        :param Sequence['TCPFlagFieldResponse'] tcp_flags: Property tcpFlags
        """
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if tcp_flags is not None:
            pulumi.set(__self__, "tcp_flags", tcp_flags)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence['outputs.PortRangeResponse']]:
        """
        Property destinationPorts
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence['outputs.AddressResponse']]:
        """
        Property destinations
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[int]]:
        """
        Property protocols
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[Sequence['outputs.PortRangeResponse']]:
        """
        Property sourcePorts
        """
        return pulumi.get(self, "source_ports")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.AddressResponse']]:
        """
        Property sources
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> Optional[Sequence['outputs.TCPFlagFieldResponse']]:
        """
        Property tcpFlags
        """
        return pulumi.get(self, "tcp_flags")


@pulumi.output_type
class MatcherResponse(dict):
    """
    Definition of Matcher
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcCode":
            suggest = "grpc_code"
        elif key == "httpCode":
            suggest = "http_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MatcherResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MatcherResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MatcherResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_code: Optional[str] = None,
                 http_code: Optional[str] = None):
        """
        Definition of Matcher
        :param str grpc_code: You can specify values between 0 and 99. You can specify multiple values, or a range of values. The default value is 12.
        :param str http_code: For Application Load Balancers, you can specify values between 200 and 499, and the default value is 200. You can specify multiple values or a range of values.
        """
        if grpc_code is not None:
            pulumi.set(__self__, "grpc_code", grpc_code)
        if http_code is not None:
            pulumi.set(__self__, "http_code", http_code)

    @property
    @pulumi.getter(name="grpcCode")
    def grpc_code(self) -> Optional[str]:
        """
        You can specify values between 0 and 99. You can specify multiple values, or a range of values. The default value is 12.
        """
        return pulumi.get(self, "grpc_code")

    @property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> Optional[str]:
        """
        For Application Load Balancers, you can specify values between 200 and 499, and the default value is 200. You can specify multiple values or a range of values.
        """
        return pulumi.get(self, "http_code")


@pulumi.output_type
class MaxAgeRuleResponse(dict):
    """
    Definition of MaxAgeRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteSourceFromS3":
            suggest = "delete_source_from_s3"
        elif key == "maxAgeInDays":
            suggest = "max_age_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaxAgeRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaxAgeRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaxAgeRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_source_from_s3: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 max_age_in_days: Optional[int] = None):
        """
        Definition of MaxAgeRule
        :param bool delete_source_from_s3: Set to true to delete a version's source bundle from Amazon S3 when Elastic Beanstalk deletes the application version.
        :param bool enabled: Specify true to apply the rule, or false to disable it.
        :param int max_age_in_days: Specify the number of days to retain an application versions.
        """
        if delete_source_from_s3 is not None:
            pulumi.set(__self__, "delete_source_from_s3", delete_source_from_s3)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_age_in_days is not None:
            pulumi.set(__self__, "max_age_in_days", max_age_in_days)

    @property
    @pulumi.getter(name="deleteSourceFromS3")
    def delete_source_from_s3(self) -> Optional[bool]:
        """
        Set to true to delete a version's source bundle from Amazon S3 when Elastic Beanstalk deletes the application version.
        """
        return pulumi.get(self, "delete_source_from_s3")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specify true to apply the rule, or false to disable it.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxAgeInDays")
    def max_age_in_days(self) -> Optional[int]:
        """
        Specify the number of days to retain an application versions.
        """
        return pulumi.get(self, "max_age_in_days")


@pulumi.output_type
class MaxCountRuleResponse(dict):
    """
    Definition of MaxCountRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteSourceFromS3":
            suggest = "delete_source_from_s3"
        elif key == "maxCount":
            suggest = "max_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaxCountRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaxCountRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaxCountRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_source_from_s3: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 max_count: Optional[int] = None):
        """
        Definition of MaxCountRule
        :param bool delete_source_from_s3: Set to true to delete a version's source bundle from Amazon S3 when Elastic Beanstalk deletes the application version.
        :param bool enabled: Specify true to apply the rule, or false to disable it.
        :param int max_count: Specify the maximum number of application versions to retain.
        """
        if delete_source_from_s3 is not None:
            pulumi.set(__self__, "delete_source_from_s3", delete_source_from_s3)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)

    @property
    @pulumi.getter(name="deleteSourceFromS3")
    def delete_source_from_s3(self) -> Optional[bool]:
        """
        Set to true to delete a version's source bundle from Amazon S3 when Elastic Beanstalk deletes the application version.
        """
        return pulumi.get(self, "delete_source_from_s3")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specify true to apply the rule, or false to disable it.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[int]:
        """
        Specify the maximum number of application versions to retain.
        """
        return pulumi.get(self, "max_count")


@pulumi.output_type
class MaximumExecutionFrequencyEnumValueResponse(dict):
    """
    Definition of MaximumExecutionFrequencyEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of MaximumExecutionFrequencyEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MemoryGiBPerVCpuRequestResponse(dict):
    """
    Definition of MemoryGiBPerVCpuRequest
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Definition of MemoryGiBPerVCpuRequest
        :param int max: The memory maximum in GiB.
        :param int min: The memory minimum in GiB.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The memory maximum in GiB.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The memory minimum in GiB.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class MemoryMiBRequestResponse(dict):
    """
    Definition of MemoryMiBRequest
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Definition of MemoryMiBRequest
        :param int max: The memory maximum in MiB.
        :param int min: The memory minimum in MiB.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The memory maximum in MiB.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The memory minimum in MiB.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class MethodSettingResponse(dict):
    """
    Definition of MethodSetting
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheDataEncrypted":
            suggest = "cache_data_encrypted"
        elif key == "cacheTtlInSeconds":
            suggest = "cache_ttl_in_seconds"
        elif key == "cachingEnabled":
            suggest = "caching_enabled"
        elif key == "dataTraceEnabled":
            suggest = "data_trace_enabled"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "loggingLevel":
            suggest = "logging_level"
        elif key == "metricsEnabled":
            suggest = "metrics_enabled"
        elif key == "resourcePath":
            suggest = "resource_path"
        elif key == "throttlingBurstLimit":
            suggest = "throttling_burst_limit"
        elif key == "throttlingRateLimit":
            suggest = "throttling_rate_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MethodSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MethodSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MethodSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_data_encrypted: Optional[bool] = None,
                 cache_ttl_in_seconds: Optional[int] = None,
                 caching_enabled: Optional[bool] = None,
                 data_trace_enabled: Optional[bool] = None,
                 http_method: Optional[str] = None,
                 logging_level: Optional[str] = None,
                 metrics_enabled: Optional[bool] = None,
                 resource_path: Optional[str] = None,
                 throttling_burst_limit: Optional[int] = None,
                 throttling_rate_limit: Optional[int] = None):
        """
        Definition of MethodSetting
        :param bool cache_data_encrypted: Specifies whether the cached responses are encrypted.
        :param int cache_ttl_in_seconds: Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.
        :param bool caching_enabled: Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.
        :param bool data_trace_enabled: Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this option for production APIs.
        :param str http_method: The HTTP method. To apply settings to multiple resources and methods, specify an asterisk (``*``) for the ``HttpMethod`` and ``/*`` for the ``ResourcePath``. This parameter is required when you specify a ``MethodSetting``.
        :param str logging_level: Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are ``OFF``, ``ERROR``, and ``INFO``. Choose ``ERROR`` to write only error-level entries to CloudWatch Logs, or choose ``INFO`` to include all ``ERROR`` events as well as extra informational events.
        :param bool metrics_enabled: Specifies whether Amazon CloudWatch metrics are enabled for this method.
        :param str resource_path: The resource path for this method. Forward slashes (``/``) are encoded as ``~1`` and the initial slash must include a forward slash. For example, the path value ``/resource/subresource`` must be encoded as ``/~1resource~1subresource``. To specify the root path, use only a slash (``/``). To apply settings to multiple resources and methods, specify an asterisk (``*``) for the ``HttpMethod`` and ``/*`` for the ``ResourcePath``. This parameter is required when you specify a ``MethodSetting``.
        :param int throttling_burst_limit: Specifies the throttling burst limit.
        :param int throttling_rate_limit: Specifies the throttling rate limit.
        """
        if cache_data_encrypted is not None:
            pulumi.set(__self__, "cache_data_encrypted", cache_data_encrypted)
        if cache_ttl_in_seconds is not None:
            pulumi.set(__self__, "cache_ttl_in_seconds", cache_ttl_in_seconds)
        if caching_enabled is not None:
            pulumi.set(__self__, "caching_enabled", caching_enabled)
        if data_trace_enabled is not None:
            pulumi.set(__self__, "data_trace_enabled", data_trace_enabled)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if logging_level is not None:
            pulumi.set(__self__, "logging_level", logging_level)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)
        if resource_path is not None:
            pulumi.set(__self__, "resource_path", resource_path)
        if throttling_burst_limit is not None:
            pulumi.set(__self__, "throttling_burst_limit", throttling_burst_limit)
        if throttling_rate_limit is not None:
            pulumi.set(__self__, "throttling_rate_limit", throttling_rate_limit)

    @property
    @pulumi.getter(name="cacheDataEncrypted")
    def cache_data_encrypted(self) -> Optional[bool]:
        """
        Specifies whether the cached responses are encrypted.
        """
        return pulumi.get(self, "cache_data_encrypted")

    @property
    @pulumi.getter(name="cacheTtlInSeconds")
    def cache_ttl_in_seconds(self) -> Optional[int]:
        """
        Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.
        """
        return pulumi.get(self, "cache_ttl_in_seconds")

    @property
    @pulumi.getter(name="cachingEnabled")
    def caching_enabled(self) -> Optional[bool]:
        """
        Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.
        """
        return pulumi.get(self, "caching_enabled")

    @property
    @pulumi.getter(name="dataTraceEnabled")
    def data_trace_enabled(self) -> Optional[bool]:
        """
        Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this option for production APIs.
        """
        return pulumi.get(self, "data_trace_enabled")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[str]:
        """
        The HTTP method. To apply settings to multiple resources and methods, specify an asterisk (``*``) for the ``HttpMethod`` and ``/*`` for the ``ResourcePath``. This parameter is required when you specify a ``MethodSetting``.
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="loggingLevel")
    def logging_level(self) -> Optional[str]:
        """
        Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are ``OFF``, ``ERROR``, and ``INFO``. Choose ``ERROR`` to write only error-level entries to CloudWatch Logs, or choose ``INFO`` to include all ``ERROR`` events as well as extra informational events.
        """
        return pulumi.get(self, "logging_level")

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[bool]:
        """
        Specifies whether Amazon CloudWatch metrics are enabled for this method.
        """
        return pulumi.get(self, "metrics_enabled")

    @property
    @pulumi.getter(name="resourcePath")
    def resource_path(self) -> Optional[str]:
        """
        The resource path for this method. Forward slashes (``/``) are encoded as ``~1`` and the initial slash must include a forward slash. For example, the path value ``/resource/subresource`` must be encoded as ``/~1resource~1subresource``. To specify the root path, use only a slash (``/``). To apply settings to multiple resources and methods, specify an asterisk (``*``) for the ``HttpMethod`` and ``/*`` for the ``ResourcePath``. This parameter is required when you specify a ``MethodSetting``.
        """
        return pulumi.get(self, "resource_path")

    @property
    @pulumi.getter(name="throttlingBurstLimit")
    def throttling_burst_limit(self) -> Optional[int]:
        """
        Specifies the throttling burst limit.
        """
        return pulumi.get(self, "throttling_burst_limit")

    @property
    @pulumi.getter(name="throttlingRateLimit")
    def throttling_rate_limit(self) -> Optional[int]:
        """
        Specifies the throttling rate limit.
        """
        return pulumi.get(self, "throttling_rate_limit")


@pulumi.output_type
class MetricDataQueryResponse(dict):
    """
    Definition of MetricDataQuery
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricDataQueryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricDataQueryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricDataQueryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 expression: Optional[str] = None,
                 id: Optional[str] = None,
                 label: Optional[str] = None,
                 metric_stat: Optional['outputs.MetricStatResponse'] = None,
                 period: Optional[int] = None,
                 return_data: Optional[bool] = None):
        """
        Definition of MetricDataQuery
        :param str account_id: The ID of the account where the metrics are located, if this is a cross-account alarm.
        :param str expression: The math expression to be performed on the returned data, if this object is performing a math expression. This expression can use the ``Id`` of the other metrics to refer to those metrics, and can also use the ``Id`` of other expressions to use the result of those expressions. For more information about metric math expressions, see [Metric Math Syntax and Functions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax) in the *User Guide*. Within each MetricDataQuery object, you must specify either ``Expression`` or ``MetricStat`` but not both.
        :param str id: A short name used to tie this object to the results in the response. This name must be unique within a single call to ``GetMetricData``. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the mathematical expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
        :param str label: A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents. If the metric or expression is shown in a CW dashboard widget, the label is shown. If ``Label`` is omitted, CW generates a default.
        :param 'MetricStatResponse' metric_stat: The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data. Within one MetricDataQuery object, you must specify either ``Expression`` or ``MetricStat`` but not both. This structure defines the metric to be returned, along with the statistics, period, and units.  ``MetricStat`` is a property of the [MetricDataQuery](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-alarm-metricdataquery.html) property type.
        :param int period: The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a ``PutMetricData`` operation that includes a ``StorageResolution of 1 second``.
        :param bool return_data: This option indicates whether to return the timestamps and raw data values of this metric. When you create an alarm based on a metric math expression, specify ``True`` for this value for only the one math expression that the alarm is based on. You must specify ``False`` for ``ReturnData`` for all the other metrics and expressions used in the alarm. This field is required.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if metric_stat is not None:
            pulumi.set(__self__, "metric_stat", metric_stat)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if return_data is not None:
            pulumi.set(__self__, "return_data", return_data)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The ID of the account where the metrics are located, if this is a cross-account alarm.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The math expression to be performed on the returned data, if this object is performing a math expression. This expression can use the ``Id`` of the other metrics to refer to those metrics, and can also use the ``Id`` of other expressions to use the result of those expressions. For more information about metric math expressions, see [Metric Math Syntax and Functions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax) in the *User Guide*. Within each MetricDataQuery object, you must specify either ``Expression`` or ``MetricStat`` but not both.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A short name used to tie this object to the results in the response. This name must be unique within a single call to ``GetMetricData``. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the mathematical expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents. If the metric or expression is shown in a CW dashboard widget, the label is shown. If ``Label`` is omitted, CW generates a default.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.MetricStatResponse']:
        """
        The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data. Within one MetricDataQuery object, you must specify either ``Expression`` or ``MetricStat`` but not both. This structure defines the metric to be returned, along with the statistics, period, and units.  ``MetricStat`` is a property of the [MetricDataQuery](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-alarm-metricdataquery.html) property type.
        """
        return pulumi.get(self, "metric_stat")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a ``PutMetricData`` operation that includes a ``StorageResolution of 1 second``.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[bool]:
        """
        This option indicates whether to return the timestamps and raw data values of this metric. When you create an alarm based on a metric math expression, specify ``True`` for this value for only the one math expression that the alarm is based on. You must specify ``False`` for ``ReturnData`` for all the other metrics and expressions used in the alarm. This field is required.
        """
        return pulumi.get(self, "return_data")


@pulumi.output_type
class MetricResponse(dict):
    """
    Definition of Metric
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Optional[Sequence['outputs.DimensionResponse']] = None,
                 metric_name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        Definition of Metric
        :param Sequence['DimensionResponse'] dimensions: The metric dimensions that you want to be used for the metric that the alarm will watch.
        :param str metric_name: The name of the metric that you want the alarm to watch. This is a required field.
        :param str namespace: The namespace of the metric that the alarm will watch.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.DimensionResponse']]:
        """
        The metric dimensions that you want to be used for the metric that the alarm will watch.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        The name of the metric that you want the alarm to watch. This is a required field.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace of the metric that the alarm will watch.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class MetricStatResponse(dict):
    """
    Definition of MetricStat
    """
    def __init__(__self__, *,
                 metric: Optional['outputs.MetricResponse'] = None,
                 period: Optional[int] = None,
                 stat: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        Definition of MetricStat
        :param 'MetricResponse' metric: The metric to return, including the metric name, namespace, and dimensions. The ``Metric`` property type represents a specific metric. ``Metric`` is a property of the [MetricStat](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-alarm-metricstat.html) property type.
        :param int period: The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a ``PutMetricData`` call that includes a ``StorageResolution`` of 1 second. If the ``StartTime`` parameter specifies a time stamp that is greater than 3 hours ago, you must specify the period as follows or no data points in that time range is returned:  +  Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute).  +  Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes).  +  Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).
        :param str stat: The statistic to return. It can include any CW statistic or extended statistic. For a list of valid values, see the table in [Statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Statistic) in the *User Guide*.
        :param str unit: The unit to use for the returned data points.  Valid values are: Seconds, Microseconds, Milliseconds, Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes, Bits, Kilobits, Megabits, Gigabits, Terabits, Percent, Count, Bytes/Second, Kilobytes/Second, Megabytes/Second, Gigabytes/Second, Terabytes/Second, Bits/Second, Kilobits/Second, Megabits/Second, Gigabits/Second, Terabits/Second, Count/Second, or None.
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if stat is not None:
            pulumi.set(__self__, "stat", stat)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def metric(self) -> Optional['outputs.MetricResponse']:
        """
        The metric to return, including the metric name, namespace, and dimensions. The ``Metric`` property type represents a specific metric. ``Metric`` is a property of the [MetricStat](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudwatch-alarm-metricstat.html) property type.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The granularity, in seconds, of the returned data points. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a ``PutMetricData`` call that includes a ``StorageResolution`` of 1 second. If the ``StartTime`` parameter specifies a time stamp that is greater than 3 hours ago, you must specify the period as follows or no data points in that time range is returned:  +  Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute).  +  Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes).  +  Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def stat(self) -> Optional[str]:
        """
        The statistic to return. It can include any CW statistic or extended statistic. For a list of valid values, see the table in [Statistics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Statistic) in the *User Guide*.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit to use for the returned data points.  Valid values are: Seconds, Microseconds, Milliseconds, Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes, Bits, Kilobits, Megabits, Gigabits, Terabits, Percent, Count, Bytes/Second, Kilobytes/Second, Megabytes/Second, Gigabytes/Second, Terabytes/Second, Bits/Second, Kilobits/Second, Megabits/Second, Gigabits/Second, Terabits/Second, Count/Second, or None.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class MetricTransformationResponse(dict):
    """
    Definition of MetricTransformation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "metricValue":
            suggest = "metric_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricTransformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricTransformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricTransformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.DimensionResponse']] = None,
                 metric_name: Optional[str] = None,
                 metric_namespace: Optional[str] = None,
                 metric_value: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        Definition of MetricTransformation
        :param int default_value: (Optional) The value to emit when a filter pattern does not match a log event. This value can be null.
        :param Sequence['DimensionResponse'] dimensions: The fields to use as dimensions for the metric. One metric filter can include as many as three dimensions.  Metrics extracted from log events are charged as custom metrics. To prevent unexpected high charges, do not specify high-cardinality fields such as ``IPAddress`` or ``requestID`` as dimensions. Each different value found for a dimension is treated as a separate metric and accrues charges as a separate custom metric.  CloudWatch Logs disables a metric filter if it generates 1000 different name/value pairs for your specified dimensions within a certain amount of time. This helps to prevent accidental high charges. You can also set up a billing alarm to alert you if your charges are higher than expected. For more information, see [Creating a Billing Alarm to Monitor Your Estimated Charges](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html).
        :param str metric_name: The name of the CloudWatch metric.
        :param str metric_namespace: A custom namespace to contain your metric in CloudWatch. Use namespaces to group together metrics that are similar. For more information, see [Namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace).
        :param str metric_value: The value that is published to the CloudWatch metric. For example, if you're counting the occurrences of a particular term like ``Error``, specify 1 for the metric value. If you're counting the number of bytes transferred, reference the value that is in the log event by using $. followed by the name of the field that you specified in the filter pattern, such as ``$.size``.
        :param str unit: The unit to assign to the metric. If you omit this, the unit is set as ``None``.
        """
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if metric_value is not None:
            pulumi.set(__self__, "metric_value", metric_value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[int]:
        """
        (Optional) The value to emit when a filter pattern does not match a log event. This value can be null.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.DimensionResponse']]:
        """
        The fields to use as dimensions for the metric. One metric filter can include as many as three dimensions.  Metrics extracted from log events are charged as custom metrics. To prevent unexpected high charges, do not specify high-cardinality fields such as ``IPAddress`` or ``requestID`` as dimensions. Each different value found for a dimension is treated as a separate metric and accrues charges as a separate custom metric.  CloudWatch Logs disables a metric filter if it generates 1000 different name/value pairs for your specified dimensions within a certain amount of time. This helps to prevent accidental high charges. You can also set up a billing alarm to alert you if your charges are higher than expected. For more information, see [Creating a Billing Alarm to Monitor Your Estimated Charges](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html).
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        The name of the CloudWatch metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[str]:
        """
        A custom namespace to contain your metric in CloudWatch. Use namespaces to group together metrics that are similar. For more information, see [Namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace).
        """
        return pulumi.get(self, "metric_namespace")

    @property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> Optional[str]:
        """
        The value that is published to the CloudWatch metric. For example, if you're counting the occurrences of a particular term like ``Error``, specify 1 for the metric value. If you're counting the number of bytes transferred, reference the value that is in the log event by using $. followed by the name of the field that you specified in the filter pattern, such as ``$.size``.
        """
        return pulumi.get(self, "metric_value")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit to assign to the metric. If you omit this, the unit is set as ``None``.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class MetricsCollectionResponse(dict):
    """
    Definition of MetricsCollection
    """
    def __init__(__self__, *,
                 granularity: Optional[str] = None,
                 metrics: Optional[Sequence[str]] = None):
        """
        Definition of MetricsCollection
        :param str granularity: The frequency at which Amazon EC2 Auto Scaling sends aggregated data to CloudWatch. The only valid value is ``1Minute``.
        :param Sequence[str] metrics: Identifies the metrics to enable. You can specify one or more of the following metrics:  +   ``GroupMinSize``   +   ``GroupMaxSize``   +   ``GroupDesiredCapacity``   +   ``GroupInServiceInstances``   +   ``GroupPendingInstances``   +   ``GroupStandbyInstances``   +   ``GroupTerminatingInstances``   +   ``GroupTotalInstances``   +   ``GroupInServiceCapacity``   +   ``GroupPendingCapacity``   +   ``GroupStandbyCapacity``   +   ``GroupTerminatingCapacity``   +   ``GroupTotalCapacity``   +   ``WarmPoolDesiredCapacity``   +   ``WarmPoolWarmedCapacity``   +   ``WarmPoolPendingCapacity``   +   ``WarmPoolTerminatingCapacity``   +   ``WarmPoolTotalCapacity``   +   ``GroupAndWarmPoolDesiredCapacity``   +   ``GroupAndWarmPoolTotalCapacity``    If you specify ``Granularity`` and don't specify any metrics, all metrics are enabled. For more information, see [Auto Scaling group metrics](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-cloudwatch-monitoring.html#as-group-metrics) in the *Amazon EC2 Auto Scaling User Guide*.
        """
        if granularity is not None:
            pulumi.set(__self__, "granularity", granularity)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @property
    @pulumi.getter
    def granularity(self) -> Optional[str]:
        """
        The frequency at which Amazon EC2 Auto Scaling sends aggregated data to CloudWatch. The only valid value is ``1Minute``.
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence[str]]:
        """
        Identifies the metrics to enable. You can specify one or more of the following metrics:  +   ``GroupMinSize``   +   ``GroupMaxSize``   +   ``GroupDesiredCapacity``   +   ``GroupInServiceInstances``   +   ``GroupPendingInstances``   +   ``GroupStandbyInstances``   +   ``GroupTerminatingInstances``   +   ``GroupTotalInstances``   +   ``GroupInServiceCapacity``   +   ``GroupPendingCapacity``   +   ``GroupStandbyCapacity``   +   ``GroupTerminatingCapacity``   +   ``GroupTotalCapacity``   +   ``WarmPoolDesiredCapacity``   +   ``WarmPoolWarmedCapacity``   +   ``WarmPoolPendingCapacity``   +   ``WarmPoolTerminatingCapacity``   +   ``WarmPoolTotalCapacity``   +   ``GroupAndWarmPoolDesiredCapacity``   +   ``GroupAndWarmPoolTotalCapacity``    If you specify ``Granularity`` and don't specify any metrics, all metrics are enabled. For more information, see [Auto Scaling group metrics](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-cloudwatch-monitoring.html#as-group-metrics) in the *Amazon EC2 Auto Scaling User Guide*.
        """
        return pulumi.get(self, "metrics")


@pulumi.output_type
class MetricsConfigurationResponse(dict):
    """
    Definition of MetricsConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPointArn":
            suggest = "access_point_arn"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_point_arn: Optional[str] = None,
                 id: Optional[str] = None,
                 prefix: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.TagFilterResponse']] = None):
        """
        Definition of MetricsConfiguration
        :param str access_point_arn: The access point that was used while performing operations on the object. The metrics configuration only includes objects that meet the filter's criteria.
        :param str id: The ID used to identify the metrics configuration. This can be any value you choose that helps you identify your metrics configuration.
        :param str prefix: The prefix that an object must have to be included in the metrics results.
        :param Sequence['TagFilterResponse'] tag_filters: Specifies a list of tag filters to use as a metrics configuration filter. The metrics configuration includes only objects that meet the filter's criteria.
        """
        if access_point_arn is not None:
            pulumi.set(__self__, "access_point_arn", access_point_arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter(name="accessPointArn")
    def access_point_arn(self) -> Optional[str]:
        """
        The access point that was used while performing operations on the object. The metrics configuration only includes objects that meet the filter's criteria.
        """
        return pulumi.get(self, "access_point_arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID used to identify the metrics configuration. This can be any value you choose that helps you identify your metrics configuration.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The prefix that an object must have to be included in the metrics results.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.TagFilterResponse']]:
        """
        Specifies a list of tag filters to use as a metrics configuration filter. The metrics configuration includes only objects that meet the filter's criteria.
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class MetricsResponse(dict):
    """
    Definition of Metrics
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventThreshold":
            suggest = "event_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_threshold: Optional['outputs.ReplicationTimeValueResponse'] = None,
                 status: Optional[str] = None):
        """
        Definition of Metrics
        :param 'ReplicationTimeValueResponse' event_threshold: A container specifying the time threshold for emitting the ``s3:Replication:OperationMissedThreshold`` event. A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics ``EventThreshold``.
        :param str status: Specifies whether the replication metrics are enabled.
        """
        if event_threshold is not None:
            pulumi.set(__self__, "event_threshold", event_threshold)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="eventThreshold")
    def event_threshold(self) -> Optional['outputs.ReplicationTimeValueResponse']:
        """
        A container specifying the time threshold for emitting the ``s3:Replication:OperationMissedThreshold`` event. A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics ``EventThreshold``.
        """
        return pulumi.get(self, "event_threshold")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Specifies whether the replication metrics are enabled.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class MitigationInEffectEnumEnumValueResponse(dict):
    """
    Definition of MitigationInEffectEnumEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of MitigationInEffectEnumEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MixedInstancesPolicyResponse(dict):
    """
    Definition of MixedInstancesPolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instancesDistribution":
            suggest = "instances_distribution"
        elif key == "launchTemplate":
            suggest = "launch_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MixedInstancesPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MixedInstancesPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MixedInstancesPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances_distribution: Optional['outputs.InstancesDistributionResponse'] = None,
                 launch_template: Optional['outputs.LaunchTemplateResponse'] = None):
        """
        Definition of MixedInstancesPolicy
        :param 'InstancesDistributionResponse' instances_distribution: The instances distribution. Use this structure to specify the distribution of On-Demand Instances and Spot Instances and the allocation strategies used to fulfill On-Demand and Spot capacities for a mixed instances policy. For more information, see [Auto Scaling groups with multiple instance types and purchase options](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups.html) in the *Amazon EC2 Auto Scaling User Guide*.  ``InstancesDistribution`` is a property of the [AWS::AutoScaling::AutoScalingGroup MixedInstancesPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-mixedinstancespolicy.html) property type.
        :param 'LaunchTemplateResponse' launch_template: One or more launch templates and the instance types (overrides) that are used to launch EC2 instances to fulfill On-Demand and Spot capacities. Use this structure to specify the launch templates and instance types (overrides) for a mixed instances policy.  ``LaunchTemplate`` is a property of the [AWS::AutoScaling::AutoScalingGroup MixedInstancesPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-mixedinstancespolicy.html) property type.
        """
        if instances_distribution is not None:
            pulumi.set(__self__, "instances_distribution", instances_distribution)
        if launch_template is not None:
            pulumi.set(__self__, "launch_template", launch_template)

    @property
    @pulumi.getter(name="instancesDistribution")
    def instances_distribution(self) -> Optional['outputs.InstancesDistributionResponse']:
        """
        The instances distribution. Use this structure to specify the distribution of On-Demand Instances and Spot Instances and the allocation strategies used to fulfill On-Demand and Spot capacities for a mixed instances policy. For more information, see [Auto Scaling groups with multiple instance types and purchase options](https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-mixed-instances-groups.html) in the *Amazon EC2 Auto Scaling User Guide*.  ``InstancesDistribution`` is a property of the [AWS::AutoScaling::AutoScalingGroup MixedInstancesPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-mixedinstancespolicy.html) property type.
        """
        return pulumi.get(self, "instances_distribution")

    @property
    @pulumi.getter(name="launchTemplate")
    def launch_template(self) -> Optional['outputs.LaunchTemplateResponse']:
        """
        One or more launch templates and the instance types (overrides) that are used to launch EC2 instances to fulfill On-Demand and Spot capacities. Use this structure to specify the launch templates and instance types (overrides) for a mixed instances policy.  ``LaunchTemplate`` is a property of the [AWS::AutoScaling::AutoScalingGroup MixedInstancesPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-autoscaling-autoscalinggroup-mixedinstancespolicy.html) property type.
        """
        return pulumi.get(self, "launch_template")


@pulumi.output_type
class ModifyingPropertiesResponse(dict):
    """
    Definition of ModifyingProperties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeValue":
            suggest = "active_value"
        elif key == "pendingValue":
            suggest = "pending_value"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModifyingPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModifyingPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModifyingPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_value: Optional[str] = None,
                 name: Optional[str] = None,
                 pending_value: Optional[str] = None,
                 value_type: Optional['outputs.PropertyValueTypeEnumValueResponse'] = None):
        """
        Definition of ModifyingProperties
        :param str active_value: <p>The current value of the domain property that is being modified.</p>
        :param str name: <p>The name of the property that is currently being modified.</p>
        :param str pending_value: <p>The value that the property that is currently being modified will eventually have.</p>
        :param 'PropertyValueTypeEnumValueResponse' value_type: <p>The type of value that is currently being modified. Properties can have two types:</p> <ul> <li> <p> <code>PLAIN_TEXT</code>: Contain direct values such as '1', 'True', or 'c5.large.search'.</p> </li> <li> <p> <code>STRINGIFIED_JSON</code>: Contain content in JSON format, such as {'Enabled':'True'}'.</p> </li> </ul>
        """
        if active_value is not None:
            pulumi.set(__self__, "active_value", active_value)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pending_value is not None:
            pulumi.set(__self__, "pending_value", pending_value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter(name="activeValue")
    def active_value(self) -> Optional[str]:
        """
        <p>The current value of the domain property that is being modified.</p>
        """
        return pulumi.get(self, "active_value")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the property that is currently being modified.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pendingValue")
    def pending_value(self) -> Optional[str]:
        """
        <p>The value that the property that is currently being modified will eventually have.</p>
        """
        return pulumi.get(self, "pending_value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional['outputs.PropertyValueTypeEnumValueResponse']:
        """
        <p>The type of value that is currently being modified. Properties can have two types:</p> <ul> <li> <p> <code>PLAIN_TEXT</code>: Contain direct values such as '1', 'True', or 'c5.large.search'.</p> </li> <li> <p> <code>STRINGIFIED_JSON</code>: Contain content in JSON format, such as {'Enabled':'True'}'.</p> </li> </ul>
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class MonitoringResponse(dict):
    """
    Definition of Monitoring
    """
    def __init__(__self__, *,
                 state: Optional['outputs.MonitoringStateEnumValueResponse'] = None):
        """
        Definition of Monitoring
        :param 'MonitoringStateEnumValueResponse' state: <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.MonitoringStateEnumValueResponse']:
        """
        <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MonitoringStateEnumValueResponse(dict):
    """
    Definition of MonitoringStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of MonitoringStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MonthlyTransferResponse(dict):
    """
    Definition of MonthlyTransfer
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gbPerMonthAllocated":
            suggest = "gb_per_month_allocated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonthlyTransferResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonthlyTransferResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonthlyTransferResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gb_per_month_allocated: Optional[str] = None):
        """
        Definition of MonthlyTransfer
        :param str gb_per_month_allocated: GbPerMonthAllocated of the Instance.
        """
        if gb_per_month_allocated is not None:
            pulumi.set(__self__, "gb_per_month_allocated", gb_per_month_allocated)

    @property
    @pulumi.getter(name="gbPerMonthAllocated")
    def gb_per_month_allocated(self) -> Optional[str]:
        """
        GbPerMonthAllocated of the Instance.
        """
        return pulumi.get(self, "gb_per_month_allocated")


@pulumi.output_type
class MountPointResponse(dict):
    """
    Definition of MountPoint
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerPath":
            suggest = "container_path"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "sourceVolume":
            suggest = "source_volume"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountPointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountPointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountPointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_path: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 source_volume: Optional[str] = None):
        """
        Definition of MountPoint
        :param str container_path: The path on the container to mount the host volume at.
        :param bool read_only: If this value is ``true``, the container has read-only access to the volume. If this value is ``false``, then the container can write to the volume. The default value is ``false``.
        :param str source_volume: The name of the volume to mount. Must be a volume name referenced in the ``name`` parameter of task definition ``volume``.
        """
        if container_path is not None:
            pulumi.set(__self__, "container_path", container_path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source_volume is not None:
            pulumi.set(__self__, "source_volume", source_volume)

    @property
    @pulumi.getter(name="containerPath")
    def container_path(self) -> Optional[str]:
        """
        The path on the container to mount the host volume at.
        """
        return pulumi.get(self, "container_path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        If this value is ``true``, the container has read-only access to the volume. If this value is ``false``, then the container can write to the volume. The default value is ``false``.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="sourceVolume")
    def source_volume(self) -> Optional[str]:
        """
        The name of the volume to mount. Must be a volume name referenced in the ``name`` parameter of task definition ``volume``.
        """
        return pulumi.get(self, "source_volume")


@pulumi.output_type
class MutualAuthenticationResponse(dict):
    """
    Definition of MutualAuthentication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreClientCertificateExpiry":
            suggest = "ignore_client_certificate_expiry"
        elif key == "trustStoreArn":
            suggest = "trust_store_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MutualAuthenticationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MutualAuthenticationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MutualAuthenticationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ignore_client_certificate_expiry: Optional[bool] = None,
                 mode: Optional[str] = None,
                 trust_store_arn: Optional[str] = None):
        """
        Definition of MutualAuthentication
        :param bool ignore_client_certificate_expiry: Indicates whether expired client certificates are ignored.
        :param str mode: The client certificate handling method. Options are ``off``, ``passthrough`` or ``verify``. The default value is ``off``.
        :param str trust_store_arn: The Amazon Resource Name (ARN) of the trust store.
        """
        if ignore_client_certificate_expiry is not None:
            pulumi.set(__self__, "ignore_client_certificate_expiry", ignore_client_certificate_expiry)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if trust_store_arn is not None:
            pulumi.set(__self__, "trust_store_arn", trust_store_arn)

    @property
    @pulumi.getter(name="ignoreClientCertificateExpiry")
    def ignore_client_certificate_expiry(self) -> Optional[bool]:
        """
        Indicates whether expired client certificates are ignored.
        """
        return pulumi.get(self, "ignore_client_certificate_expiry")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The client certificate handling method. Options are ``off``, ``passthrough`` or ``verify``. The default value is ``off``.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="trustStoreArn")
    def trust_store_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the trust store.
        """
        return pulumi.get(self, "trust_store_arn")


@pulumi.output_type
class NetworkBandwidthGbpsRequestResponse(dict):
    """
    Definition of NetworkBandwidthGbpsRequest
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Definition of NetworkBandwidthGbpsRequest
        :param int max: The maximum amount of network bandwidth, in gigabits per second (Gbps).
        :param int min: The minimum amount of network bandwidth, in gigabits per second (Gbps).
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum amount of network bandwidth, in gigabits per second (Gbps).
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum amount of network bandwidth, in gigabits per second (Gbps).
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class NetworkConfigurationResponse(dict):
    """
    Definition of NetworkConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsvpcConfiguration":
            suggest = "awsvpc_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 awsvpc_configuration: Optional['outputs.AwsVpcConfigurationResponse'] = None):
        """
        Definition of NetworkConfiguration
        :param 'AwsVpcConfigurationResponse' awsvpc_configuration: The VPC subnets and security groups that are associated with a task.  All specified subnets and security groups must be from the same VPC. An object representing the networking details for a task or service. For example ``awsvpcConfiguration={subnets=['subnet-12344321'],securityGroups=['sg-12344321']}``
        """
        if awsvpc_configuration is not None:
            pulumi.set(__self__, "awsvpc_configuration", awsvpc_configuration)

    @property
    @pulumi.getter(name="awsvpcConfiguration")
    def awsvpc_configuration(self) -> Optional['outputs.AwsVpcConfigurationResponse']:
        """
        The VPC subnets and security groups that are associated with a task.  All specified subnets and security groups must be from the same VPC. An object representing the networking details for a task or service. For example ``awsvpcConfiguration={subnets=['subnet-12344321'],securityGroups=['sg-12344321']}``
        """
        return pulumi.get(self, "awsvpc_configuration")


@pulumi.output_type
class NetworkFirewallFirewallPolicyPropertiesResponse(dict):
    """
    Definition of NetworkFirewallFirewallPolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallFirewallPolicyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallFirewallPolicyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallFirewallPolicyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsNetworkFirewallFirewallPolicyPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of NetworkFirewallFirewallPolicy
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsNetworkFirewallFirewallPolicyPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsNetworkFirewallFirewallPolicyPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class NetworkFirewallFirewallPropertiesResponse(dict):
    """
    Definition of NetworkFirewallFirewall
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallFirewallPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallFirewallPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallFirewallPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsNetworkFirewallFirewallPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of NetworkFirewallFirewall
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsNetworkFirewallFirewallPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsNetworkFirewallFirewallPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class NetworkFirewallRuleGroupPropertiesResponse(dict):
    """
    Definition of NetworkFirewallRuleGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkFirewallRuleGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkFirewallRuleGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkFirewallRuleGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsNetworkFirewallRuleGroupPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of NetworkFirewallRuleGroup
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsNetworkFirewallRuleGroupPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsNetworkFirewallRuleGroupPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class NetworkInterfaceCountRequestResponse(dict):
    """
    Definition of NetworkInterfaceCountRequest
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Definition of NetworkInterfaceCountRequest
        :param int max: The maximum number of network interfaces.
        :param int min: The minimum number of network interfaces.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of network interfaces.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of network interfaces.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class NetworkInterfaceStatusEnumValueResponse(dict):
    """
    Definition of NetworkInterfaceStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of NetworkInterfaceStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkingResponse(dict):
    """
    Definition of Networking
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monthlyTransfer":
            suggest = "monthly_transfer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monthly_transfer: Optional['outputs.MonthlyTransferResponse'] = None,
                 ports: Optional[Sequence['outputs.PortResponse']] = None):
        """
        Definition of Networking
        :param 'MonthlyTransferResponse' monthly_transfer: Monthly Transfer of the Instance.
        :param Sequence['PortResponse'] ports: Ports to the Instance.
        """
        if monthly_transfer is not None:
            pulumi.set(__self__, "monthly_transfer", monthly_transfer)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="monthlyTransfer")
    def monthly_transfer(self) -> Optional['outputs.MonthlyTransferResponse']:
        """
        Monthly Transfer of the Instance.
        """
        return pulumi.get(self, "monthly_transfer")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.PortResponse']]:
        """
        Ports to the Instance.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NodeResponse(dict):
    """
    Definition of Node
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "nodeCreateTime":
            suggest = "node_create_time"
        elif key == "nodeId":
            suggest = "node_id"
        elif key == "nodeStatus":
            suggest = "node_status"
        elif key == "parameterGroupStatus":
            suggest = "parameter_group_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 endpoint: Optional['outputs.DaxClusterEndpointResponse'] = None,
                 node_create_time: Optional[str] = None,
                 node_id: Optional[str] = None,
                 node_status: Optional[str] = None,
                 parameter_group_status: Optional[str] = None):
        """
        Definition of Node
        :param str availability_zone: <p>The Availability Zone (AZ) in which the node has been deployed.</p>
        :param 'DaxClusterEndpointResponse' endpoint: <p>The endpoint for the node, consisting of a DNS name and a port number. Client applications can connect directly to a node endpoint, if desired (as an alternative to allowing DAX client software to intelligently route requests and responses to nodes in the DAX cluster.</p>
        :param str node_create_time: <p>The date and time (in UNIX epoch format) when the node was launched.</p>
        :param str node_id: <p>A system-generated identifier for the node.</p>
        :param str node_status: <p>The current status of the node. For example: <code>available</code>.</p>
        :param str parameter_group_status: <p>The status of the parameter group associated with this node. For example, <code>in-sync</code>.</p>
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if node_create_time is not None:
            pulumi.set(__self__, "node_create_time", node_create_time)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if node_status is not None:
            pulumi.set(__self__, "node_status", node_status)
        if parameter_group_status is not None:
            pulumi.set(__self__, "parameter_group_status", parameter_group_status)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        <p>The Availability Zone (AZ) in which the node has been deployed.</p>
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional['outputs.DaxClusterEndpointResponse']:
        """
        <p>The endpoint for the node, consisting of a DNS name and a port number. Client applications can connect directly to a node endpoint, if desired (as an alternative to allowing DAX client software to intelligently route requests and responses to nodes in the DAX cluster.</p>
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="nodeCreateTime")
    def node_create_time(self) -> Optional[str]:
        """
        <p>The date and time (in UNIX epoch format) when the node was launched.</p>
        """
        return pulumi.get(self, "node_create_time")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        """
        <p>A system-generated identifier for the node.</p>
        """
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter(name="nodeStatus")
    def node_status(self) -> Optional[str]:
        """
        <p>The current status of the node. For example: <code>available</code>.</p>
        """
        return pulumi.get(self, "node_status")

    @property
    @pulumi.getter(name="parameterGroupStatus")
    def parameter_group_status(self) -> Optional[str]:
        """
        <p>The status of the parameter group associated with this node. For example, <code>in-sync</code>.</p>
        """
        return pulumi.get(self, "parameter_group_status")


@pulumi.output_type
class NodeToNodeEncryptionOptionsResponse(dict):
    """
    Definition of NodeToNodeEncryptionOptions
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Definition of NodeToNodeEncryptionOptions
        :param bool enabled: <p>True to enable node-to-node encryption.</p>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>True to enable node-to-node encryption.</p>
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NonCompliantSummaryResponse(dict):
    """
    Definition of NonCompliantSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nonCompliantCount":
            suggest = "non_compliant_count"
        elif key == "severitySummary":
            suggest = "severity_summary"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NonCompliantSummaryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NonCompliantSummaryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NonCompliantSummaryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 non_compliant_count: Optional[int] = None,
                 severity_summary: Optional['outputs.SeveritySummaryResponse'] = None):
        """
        Definition of NonCompliantSummary
        :param int non_compliant_count: <p>The total number of compliance items that aren't compliant.</p>
        :param 'SeveritySummaryResponse' severity_summary: <p>A summary of the non-compliance severity by compliance type</p>
        """
        if non_compliant_count is not None:
            pulumi.set(__self__, "non_compliant_count", non_compliant_count)
        if severity_summary is not None:
            pulumi.set(__self__, "severity_summary", severity_summary)

    @property
    @pulumi.getter(name="nonCompliantCount")
    def non_compliant_count(self) -> Optional[int]:
        """
        <p>The total number of compliance items that aren't compliant.</p>
        """
        return pulumi.get(self, "non_compliant_count")

    @property
    @pulumi.getter(name="severitySummary")
    def severity_summary(self) -> Optional['outputs.SeveritySummaryResponse']:
        """
        <p>A summary of the non-compliance severity by compliance type</p>
        """
        return pulumi.get(self, "severity_summary")


@pulumi.output_type
class NoncurrentVersionExpirationResponse(dict):
    """
    Definition of NoncurrentVersionExpiration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newerNoncurrentVersions":
            suggest = "newer_noncurrent_versions"
        elif key == "noncurrentDays":
            suggest = "noncurrent_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NoncurrentVersionExpirationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NoncurrentVersionExpirationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NoncurrentVersionExpirationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 newer_noncurrent_versions: Optional[int] = None,
                 noncurrent_days: Optional[int] = None):
        """
        Definition of NoncurrentVersionExpiration
        :param int newer_noncurrent_versions: Specifies how many noncurrent versions S3 will retain. If there are this many more recent noncurrent versions, S3 will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the *Amazon S3 User Guide*.
        :param int noncurrent_days: Specifies the number of days an object is noncurrent before S3 can perform the associated action. For information about the noncurrent days calculations, see [How Amazon S3 Calculates When an Object Became Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the *Amazon S3 User Guide*.
        """
        if newer_noncurrent_versions is not None:
            pulumi.set(__self__, "newer_noncurrent_versions", newer_noncurrent_versions)
        if noncurrent_days is not None:
            pulumi.set(__self__, "noncurrent_days", noncurrent_days)

    @property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[int]:
        """
        Specifies how many noncurrent versions S3 will retain. If there are this many more recent noncurrent versions, S3 will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> Optional[int]:
        """
        Specifies the number of days an object is noncurrent before S3 can perform the associated action. For information about the noncurrent days calculations, see [How Amazon S3 Calculates When an Object Became Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "noncurrent_days")


@pulumi.output_type
class NoncurrentVersionTransitionResponse(dict):
    """
    Definition of NoncurrentVersionTransition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newerNoncurrentVersions":
            suggest = "newer_noncurrent_versions"
        elif key == "storageClass":
            suggest = "storage_class"
        elif key == "transitionInDays":
            suggest = "transition_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NoncurrentVersionTransitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NoncurrentVersionTransitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NoncurrentVersionTransitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 newer_noncurrent_versions: Optional[int] = None,
                 storage_class: Optional[str] = None,
                 transition_in_days: Optional[int] = None):
        """
        Definition of NoncurrentVersionTransition
        :param int newer_noncurrent_versions: Specifies how many noncurrent versions S3 will retain. If there are this many more recent noncurrent versions, S3 will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the *Amazon S3 User Guide*.
        :param str storage_class: The class of storage used to store the object.
        :param int transition_in_days: Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [How Amazon S3 Calculates How Long an Object Has Been Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the *Amazon S3 User Guide*.
        """
        if newer_noncurrent_versions is not None:
            pulumi.set(__self__, "newer_noncurrent_versions", newer_noncurrent_versions)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)
        if transition_in_days is not None:
            pulumi.set(__self__, "transition_in_days", transition_in_days)

    @property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[int]:
        """
        Specifies how many noncurrent versions S3 will retain. If there are this many more recent noncurrent versions, S3 will take the associated action. For more information about noncurrent versions, see [Lifecycle configuration elements](https://docs.aws.amazon.com/AmazonS3/latest/userguide/intro-lifecycle-rules.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[str]:
        """
        The class of storage used to store the object.
        """
        return pulumi.get(self, "storage_class")

    @property
    @pulumi.getter(name="transitionInDays")
    def transition_in_days(self) -> Optional[int]:
        """
        Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see [How Amazon S3 Calculates How Long an Object Has Been Noncurrent](https://docs.aws.amazon.com/AmazonS3/latest/dev/intro-lifecycle-rules.html#non-current-days-calculations) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "transition_in_days")


@pulumi.output_type
class NotebookInstanceStatusEnumValueResponse(dict):
    """
    Definition of NotebookInstanceStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of NotebookInstanceStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NotificationConfigurationResponse(dict):
    """
    Definition of NotificationConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventBridgeConfiguration":
            suggest = "event_bridge_configuration"
        elif key == "lambdaConfigurations":
            suggest = "lambda_configurations"
        elif key == "notificationTypes":
            suggest = "notification_types"
        elif key == "queueConfigurations":
            suggest = "queue_configurations"
        elif key == "topicARN":
            suggest = "topic_arn"
        elif key == "topicArn":
            suggest = "topic_arn"
        elif key == "topicConfigurations":
            suggest = "topic_configurations"
        elif key == "topicStatus":
            suggest = "topic_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_bridge_configuration: Optional['outputs.EventBridgeConfigurationResponse'] = None,
                 lambda_configurations: Optional[Sequence['outputs.LambdaConfigurationResponse']] = None,
                 notification_types: Optional[Sequence[str]] = None,
                 queue_configurations: Optional[Sequence['outputs.QueueConfigurationResponse']] = None,
                 topic_arn: Optional[str] = None,
                 topic_arn: Optional[str] = None,
                 topic_configurations: Optional[Sequence['outputs.TopicConfigurationResponse']] = None,
                 topic_status: Optional[str] = None):
        """
        Definition of NotificationConfiguration
        :param 'EventBridgeConfigurationResponse' event_bridge_configuration: Enables delivery of events to Amazon EventBridge. Amazon S3 can send events to Amazon EventBridge whenever certain events happen in your bucket, see [Using EventBridge](https://docs.aws.amazon.com/AmazonS3/latest/userguide/EventBridge.html) in the *Amazon S3 User Guide*. Unlike other destinations, delivery of events to EventBridge can be either enabled or disabled for a bucket. If enabled, all events will be sent to EventBridge and you can use EventBridge rules to route events to additional targets. For more information, see [What Is Amazon EventBridge](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-what-is.html) in the *Amazon EventBridge User Guide*
        :param Sequence['LambdaConfigurationResponse'] lambda_configurations: Describes the LAMlong functions to invoke and the events for which to invoke them.
        :param Sequence[str] notification_types: A list of event types that send a notification. Event types can include any of the following types.  *Allowed values*:  +   ``autoscaling:EC2_INSTANCE_LAUNCH``   +   ``autoscaling:EC2_INSTANCE_LAUNCH_ERROR``   +   ``autoscaling:EC2_INSTANCE_TERMINATE``   +   ``autoscaling:EC2_INSTANCE_TERMINATE_ERROR``   +   ``autoscaling:TEST_NOTIFICATION``
        :param Sequence['QueueConfigurationResponse'] queue_configurations: The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
        :param str topic_arn: The Amazon Resource Name (ARN) of the Amazon SNS topic.
        :param str topic_arn: <p>The Amazon Resource Name (ARN) that identifies the topic. </p>
        :param Sequence['TopicConfigurationResponse'] topic_configurations: The topic to which notifications are sent and the events for which notifications are generated.
        :param str topic_status: <p>The current state of the topic. A value of active means that notifications will be sent to the topic. A value of inactive means that notifications will not be sent to the topic.</p>
        """
        if event_bridge_configuration is not None:
            pulumi.set(__self__, "event_bridge_configuration", event_bridge_configuration)
        if lambda_configurations is not None:
            pulumi.set(__self__, "lambda_configurations", lambda_configurations)
        if notification_types is not None:
            pulumi.set(__self__, "notification_types", notification_types)
        if queue_configurations is not None:
            pulumi.set(__self__, "queue_configurations", queue_configurations)
        if topic_arn is not None:
            pulumi.set(__self__, "topic_arn", topic_arn)
        if topic_arn is not None:
            pulumi.set(__self__, "topic_arn", topic_arn)
        if topic_configurations is not None:
            pulumi.set(__self__, "topic_configurations", topic_configurations)
        if topic_status is not None:
            pulumi.set(__self__, "topic_status", topic_status)

    @property
    @pulumi.getter(name="eventBridgeConfiguration")
    def event_bridge_configuration(self) -> Optional['outputs.EventBridgeConfigurationResponse']:
        """
        Enables delivery of events to Amazon EventBridge. Amazon S3 can send events to Amazon EventBridge whenever certain events happen in your bucket, see [Using EventBridge](https://docs.aws.amazon.com/AmazonS3/latest/userguide/EventBridge.html) in the *Amazon S3 User Guide*. Unlike other destinations, delivery of events to EventBridge can be either enabled or disabled for a bucket. If enabled, all events will be sent to EventBridge and you can use EventBridge rules to route events to additional targets. For more information, see [What Is Amazon EventBridge](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-what-is.html) in the *Amazon EventBridge User Guide*
        """
        return pulumi.get(self, "event_bridge_configuration")

    @property
    @pulumi.getter(name="lambdaConfigurations")
    def lambda_configurations(self) -> Optional[Sequence['outputs.LambdaConfigurationResponse']]:
        """
        Describes the LAMlong functions to invoke and the events for which to invoke them.
        """
        return pulumi.get(self, "lambda_configurations")

    @property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Optional[Sequence[str]]:
        """
        A list of event types that send a notification. Event types can include any of the following types.  *Allowed values*:  +   ``autoscaling:EC2_INSTANCE_LAUNCH``   +   ``autoscaling:EC2_INSTANCE_LAUNCH_ERROR``   +   ``autoscaling:EC2_INSTANCE_TERMINATE``   +   ``autoscaling:EC2_INSTANCE_TERMINATE_ERROR``   +   ``autoscaling:TEST_NOTIFICATION``
        """
        return pulumi.get(self, "notification_types")

    @property
    @pulumi.getter(name="queueConfigurations")
    def queue_configurations(self) -> Optional[Sequence['outputs.QueueConfigurationResponse']]:
        """
        The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
        """
        return pulumi.get(self, "queue_configurations")

    @property
    @pulumi.getter(name="topicARN")
    def topic_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon SNS topic.
        """
        return pulumi.get(self, "topic_arn")

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) that identifies the topic. </p>
        """
        return pulumi.get(self, "topic_arn")

    @property
    @pulumi.getter(name="topicConfigurations")
    def topic_configurations(self) -> Optional[Sequence['outputs.TopicConfigurationResponse']]:
        """
        The topic to which notifications are sent and the events for which notifications are generated.
        """
        return pulumi.get(self, "topic_configurations")

    @property
    @pulumi.getter(name="topicStatus")
    def topic_status(self) -> Optional[str]:
        """
        <p>The current state of the topic. A value of active means that notifications will be sent to the topic. A value of inactive means that notifications will not be sent to the topic.</p>
        """
        return pulumi.get(self, "topic_status")


@pulumi.output_type
class NotificationFilterResponse(dict):
    """
    Definition of NotificationFilter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Key":
            suggest = "s3_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_key: Optional['outputs.S3KeyFilterResponse'] = None):
        """
        Definition of NotificationFilter
        :param 'S3KeyFilterResponse' s3_key: A container for object key name prefix and suffix filtering rules. A container for object key name prefix and suffix filtering rules. For more information about object key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*.  The same type of filter rule cannot be used more than once. For example, you cannot specify two prefix rules.
        """
        if s3_key is not None:
            pulumi.set(__self__, "s3_key", s3_key)

    @property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> Optional['outputs.S3KeyFilterResponse']:
        """
        A container for object key name prefix and suffix filtering rules. A container for object key name prefix and suffix filtering rules. For more information about object key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*.  The same type of filter rule cannot be used more than once. For example, you cannot specify two prefix rules.
        """
        return pulumi.get(self, "s3_key")


@pulumi.output_type
class OIDCResponse(dict):
    """
    Definition of OIDC
    """
    def __init__(__self__, *,
                 issuer: Optional[str] = None):
        """
        Definition of OIDC
        :param str issuer: <p>The issuer URL for the OIDC identity provider.</p>
        """
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        <p>The issuer URL for the OIDC identity provider.</p>
        """
        return pulumi.get(self, "issuer")


@pulumi.output_type
class ObjectLockConfigurationResponse(dict):
    """
    Definition of ObjectLockConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectLockEnabled":
            suggest = "object_lock_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectLockConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectLockConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectLockConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_lock_enabled: Optional[str] = None,
                 rule: Optional['outputs.ObjectLockRuleResponse'] = None):
        """
        Definition of ObjectLockConfiguration
        :param str object_lock_enabled: Indicates whether this bucket has an Object Lock configuration enabled. Enable ``ObjectLockEnabled`` when you apply ``ObjectLockConfiguration`` to a bucket.
        :param 'ObjectLockRuleResponse' rule: Specifies the Object Lock rule for the specified object. Enable this rule when you apply ``ObjectLockConfiguration`` to a bucket. If Object Lock is turned on, bucket settings require both ``Mode`` and a period of either ``Days`` or ``Years``. You cannot specify ``Days`` and ``Years`` at the same time. For more information, see [ObjectLockRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-objectlockrule.html) and [DefaultRetention](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html). Specifies the Object Lock rule for the specified object. Enable the this rule when you apply ``ObjectLockConfiguration`` to a bucket.
        """
        if object_lock_enabled is not None:
            pulumi.set(__self__, "object_lock_enabled", object_lock_enabled)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter(name="objectLockEnabled")
    def object_lock_enabled(self) -> Optional[str]:
        """
        Indicates whether this bucket has an Object Lock configuration enabled. Enable ``ObjectLockEnabled`` when you apply ``ObjectLockConfiguration`` to a bucket.
        """
        return pulumi.get(self, "object_lock_enabled")

    @property
    @pulumi.getter
    def rule(self) -> Optional['outputs.ObjectLockRuleResponse']:
        """
        Specifies the Object Lock rule for the specified object. Enable this rule when you apply ``ObjectLockConfiguration`` to a bucket. If Object Lock is turned on, bucket settings require both ``Mode`` and a period of either ``Days`` or ``Years``. You cannot specify ``Days`` and ``Years`` at the same time. For more information, see [ObjectLockRule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-objectlockrule.html) and [DefaultRetention](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html). Specifies the Object Lock rule for the specified object. Enable the this rule when you apply ``ObjectLockConfiguration`` to a bucket.
        """
        return pulumi.get(self, "rule")


@pulumi.output_type
class ObjectLockRuleResponse(dict):
    """
    Definition of ObjectLockRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultRetention":
            suggest = "default_retention"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectLockRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectLockRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectLockRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_retention: Optional['outputs.DefaultRetentionResponse'] = None):
        """
        Definition of ObjectLockRule
        :param 'DefaultRetentionResponse' default_retention: The default Object Lock retention mode and period that you want to apply to new objects placed in the specified bucket. If Object Lock is turned on, bucket settings require both ``Mode`` and a period of either ``Days`` or ``Years``. You cannot specify ``Days`` and ``Years`` at the same time. For more information about allowable values for mode and period, see [DefaultRetention](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html). The container element for specifying the default Object Lock retention settings for new objects placed in the specified bucket.   +  The ``DefaultRetention`` settings require both a mode and a period.  +  The ``DefaultRetention`` period can be either ``Days`` or ``Years`` but you must select one. You cannot specify ``Days`` and ``Years`` at the same time.
        """
        if default_retention is not None:
            pulumi.set(__self__, "default_retention", default_retention)

    @property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> Optional['outputs.DefaultRetentionResponse']:
        """
        The default Object Lock retention mode and period that you want to apply to new objects placed in the specified bucket. If Object Lock is turned on, bucket settings require both ``Mode`` and a period of either ``Days`` or ``Years``. You cannot specify ``Days`` and ``Years`` at the same time. For more information about allowable values for mode and period, see [DefaultRetention](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-defaultretention.html). The container element for specifying the default Object Lock retention settings for new objects placed in the specified bucket.   +  The ``DefaultRetention`` settings require both a mode and a period.  +  The ``DefaultRetention`` period can be either ``Days`` or ``Years`` but you must select one. You cannot specify ``Days`` and ``Years`` at the same time.
        """
        return pulumi.get(self, "default_retention")


@pulumi.output_type
class OffPeakWindowOptionsResponse(dict):
    """
    Definition of OffPeakWindowOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offPeakWindow":
            suggest = "off_peak_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OffPeakWindowOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OffPeakWindowOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OffPeakWindowOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 off_peak_window: Optional['outputs.OffPeakWindowResponse'] = None):
        """
        Definition of OffPeakWindowOptions
        :param bool enabled: <p>Whether to enable an off-peak window.</p> <p>This option is only available when modifying a domain created prior to February 16, 2023, not when creating a new domain. All domains created after this date have the off-peak window enabled by default. You can't disable the off-peak window after it's enabled for a domain.</p>
        :param 'OffPeakWindowResponse' off_peak_window: <p>Off-peak window settings for the domain.</p>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if off_peak_window is not None:
            pulumi.set(__self__, "off_peak_window", off_peak_window)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>Whether to enable an off-peak window.</p> <p>This option is only available when modifying a domain created prior to February 16, 2023, not when creating a new domain. All domains created after this date have the off-peak window enabled by default. You can't disable the off-peak window after it's enabled for a domain.</p>
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="offPeakWindow")
    def off_peak_window(self) -> Optional['outputs.OffPeakWindowResponse']:
        """
        <p>Off-peak window settings for the domain.</p>
        """
        return pulumi.get(self, "off_peak_window")


@pulumi.output_type
class OffPeakWindowResponse(dict):
    """
    Definition of OffPeakWindow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OffPeakWindowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OffPeakWindowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OffPeakWindowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 window_start_time: Optional['outputs.WindowStartTimeResponse'] = None):
        """
        Definition of OffPeakWindow
        :param 'WindowStartTimeResponse' window_start_time: <p>A custom start time for the off-peak window, in Coordinated Universal Time (UTC). The window length will always be 10 hours, so you can't specify an end time. For example, if you specify 11:00 P.M. UTC as a start time, the end time will automatically be set to 9:00 A.M.</p>
        """
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.WindowStartTimeResponse']:
        """
        <p>A custom start time for the off-peak window, in Coordinated Universal Time (UTC). The window length will always be 10 hours, so you can't specify an end time. For example, if you specify 11:00 P.M. UTC as a start time, the end time will automatically be set to 9:00 A.M.</p>
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class OpenIDConnectConfigResponse(dict):
    """
    Definition of OpenIDConnectConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authTTL":
            suggest = "auth_ttl"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "iatTTL":
            suggest = "iat_ttl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIDConnectConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIDConnectConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIDConnectConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_ttl: Optional[float] = None,
                 client_id: Optional[str] = None,
                 iat_ttl: Optional[float] = None,
                 issuer: Optional[str] = None):
        """
        Definition of OpenIDConnectConfig
        :param float auth_ttl: <p>The number of milliseconds that a token is valid after being authenticated.</p>
        :param str client_id: <p>The client identifier of the relying party at the OpenID identity provider. This identifier is typically obtained when the relying party is registered with the OpenID identity provider. You can specify a regular expression so that AppSync can validate against multiple client identifiers at a time.</p>
        :param float iat_ttl: <p>The number of milliseconds that a token is valid after it's issued to a user.</p>
        :param str issuer: <p>The issuer for the OIDC configuration. The issuer returned by discovery must exactly match the value of <code>iss</code> in the ID token.</p>
        """
        if auth_ttl is not None:
            pulumi.set(__self__, "auth_ttl", auth_ttl)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if iat_ttl is not None:
            pulumi.set(__self__, "iat_ttl", iat_ttl)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)

    @property
    @pulumi.getter(name="authTTL")
    def auth_ttl(self) -> Optional[float]:
        """
        <p>The number of milliseconds that a token is valid after being authenticated.</p>
        """
        return pulumi.get(self, "auth_ttl")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        <p>The client identifier of the relying party at the OpenID identity provider. This identifier is typically obtained when the relying party is registered with the OpenID identity provider. You can specify a regular expression so that AppSync can validate against multiple client identifiers at a time.</p>
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="iatTTL")
    def iat_ttl(self) -> Optional[float]:
        """
        <p>The number of milliseconds that a token is valid after it's issued to a user.</p>
        """
        return pulumi.get(self, "iat_ttl")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        <p>The issuer for the OIDC configuration. The issuer returned by discovery must exactly match the value of <code>iss</code> in the ID token.</p>
        """
        return pulumi.get(self, "issuer")


@pulumi.output_type
class OpenSearchDomainStatusPropertiesResponse(dict):
    """
    Definition of OpenSearchDomainStatus
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenSearchDomainStatusPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenSearchDomainStatusPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenSearchDomainStatusPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsOpenSearchDomainStatusPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of OpenSearchDomainStatus
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsOpenSearchDomainStatusPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsOpenSearchDomainStatusPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class OpenSearchPartitionInstanceTypeEnumValueResponse(dict):
    """
    Definition of OpenSearchPartitionInstanceTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of OpenSearchPartitionInstanceTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OpenSearchWarmPartitionInstanceTypeEnumValueResponse(dict):
    """
    Definition of OpenSearchWarmPartitionInstanceTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of OpenSearchWarmPartitionInstanceTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OperationLevelMetricsConfigEnumValueResponse(dict):
    """
    Definition of OperationLevelMetricsConfigEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of OperationLevelMetricsConfigEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OperationPreferencesResponse(dict):
    """
    Definition of OperationPreferences
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureToleranceCount":
            suggest = "failure_tolerance_count"
        elif key == "failureTolerancePercentage":
            suggest = "failure_tolerance_percentage"
        elif key == "maxConcurrentCount":
            suggest = "max_concurrent_count"
        elif key == "maxConcurrentPercentage":
            suggest = "max_concurrent_percentage"
        elif key == "regionConcurrencyType":
            suggest = "region_concurrency_type"
        elif key == "regionOrder":
            suggest = "region_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OperationPreferencesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OperationPreferencesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OperationPreferencesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_tolerance_count: Optional[int] = None,
                 failure_tolerance_percentage: Optional[int] = None,
                 max_concurrent_count: Optional[int] = None,
                 max_concurrent_percentage: Optional[int] = None,
                 region_concurrency_type: Optional[str] = None,
                 region_order: Optional[Sequence[str]] = None):
        """
        Definition of OperationPreferences
        :param int failure_tolerance_count: Property failureToleranceCount
        :param int failure_tolerance_percentage: Property failureTolerancePercentage
        :param int max_concurrent_count: Property maxConcurrentCount
        :param int max_concurrent_percentage: Property maxConcurrentPercentage
        :param str region_concurrency_type: The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time
        :param Sequence[str] region_order: Property regionOrder
        """
        if failure_tolerance_count is not None:
            pulumi.set(__self__, "failure_tolerance_count", failure_tolerance_count)
        if failure_tolerance_percentage is not None:
            pulumi.set(__self__, "failure_tolerance_percentage", failure_tolerance_percentage)
        if max_concurrent_count is not None:
            pulumi.set(__self__, "max_concurrent_count", max_concurrent_count)
        if max_concurrent_percentage is not None:
            pulumi.set(__self__, "max_concurrent_percentage", max_concurrent_percentage)
        if region_concurrency_type is not None:
            pulumi.set(__self__, "region_concurrency_type", region_concurrency_type)
        if region_order is not None:
            pulumi.set(__self__, "region_order", region_order)

    @property
    @pulumi.getter(name="failureToleranceCount")
    def failure_tolerance_count(self) -> Optional[int]:
        """
        Property failureToleranceCount
        """
        return pulumi.get(self, "failure_tolerance_count")

    @property
    @pulumi.getter(name="failureTolerancePercentage")
    def failure_tolerance_percentage(self) -> Optional[int]:
        """
        Property failureTolerancePercentage
        """
        return pulumi.get(self, "failure_tolerance_percentage")

    @property
    @pulumi.getter(name="maxConcurrentCount")
    def max_concurrent_count(self) -> Optional[int]:
        """
        Property maxConcurrentCount
        """
        return pulumi.get(self, "max_concurrent_count")

    @property
    @pulumi.getter(name="maxConcurrentPercentage")
    def max_concurrent_percentage(self) -> Optional[int]:
        """
        Property maxConcurrentPercentage
        """
        return pulumi.get(self, "max_concurrent_percentage")

    @property
    @pulumi.getter(name="regionConcurrencyType")
    def region_concurrency_type(self) -> Optional[str]:
        """
        The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time
        """
        return pulumi.get(self, "region_concurrency_type")

    @property
    @pulumi.getter(name="regionOrder")
    def region_order(self) -> Optional[Sequence[str]]:
        """
        Property regionOrder
        """
        return pulumi.get(self, "region_order")


@pulumi.output_type
class OptionSettingResponse(dict):
    """
    Definition of OptionSetting
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optionName":
            suggest = "option_name"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OptionSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OptionSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OptionSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 option_name: Optional[str] = None,
                 resource_name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of OptionSetting
        :param str namespace: A unique namespace that identifies the option's associated AWS resource.
        :param str option_name: The name of the configuration option.
        :param str resource_name: A unique resource name for the option setting. Use it for a timebased scaling configuration option.
        :param str value: The current value for the configuration option.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if option_name is not None:
            pulumi.set(__self__, "option_name", option_name)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        A unique namespace that identifies the option's associated AWS resource.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="optionName")
    def option_name(self) -> Optional[str]:
        """
        The name of the configuration option.
        """
        return pulumi.get(self, "option_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        A unique resource name for the option setting. Use it for a timebased scaling configuration option.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The current value for the configuration option.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OrganizationsAccountPropertiesResponse(dict):
    """
    Definition of OrganizationsAccount
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationsAccountPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationsAccountPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationsAccountPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsOrganizationsAccountPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of OrganizationsAccount
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsOrganizationsAccountPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsOrganizationsAccountPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class OrganizationsOrganizationPropertiesResponse(dict):
    """
    Definition of OrganizationsOrganization
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationsOrganizationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationsOrganizationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationsOrganizationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsOrganizationsOrganizationPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of OrganizationsOrganization
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsOrganizationsOrganizationPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsOrganizationsOrganizationPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class OriginCustomHeaderResponse(dict):
    """
    Definition of OriginCustomHeader
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginCustomHeaderResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginCustomHeaderResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginCustomHeaderResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[str] = None,
                 header_value: Optional[str] = None):
        """
        Definition of OriginCustomHeader
        :param str header_name: The name of a header that you want CloudFront to send to your origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html) in the *Amazon CloudFront Developer Guide*.
        :param str header_value: The value for the header that you specified in the ``HeaderName`` field.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        The name of a header that you want CloudFront to send to your origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        The value for the header that you specified in the ``HeaderName`` field.
        """
        return pulumi.get(self, "header_value")


@pulumi.output_type
class OriginGroupFailoverCriteriaResponse(dict):
    """
    Definition of OriginGroupFailoverCriteria
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginGroupFailoverCriteriaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginGroupFailoverCriteriaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginGroupFailoverCriteriaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_codes: Optional['outputs.StatusCodesResponse'] = None):
        """
        Definition of OriginGroupFailoverCriteria
        :param 'StatusCodesResponse' status_codes: The status codes that, when returned from the primary origin, will trigger CloudFront to failover to the second origin. A complex data type for the status codes that you specify that, when returned by a primary origin, trigger CloudFront to failover to a second origin.
        """
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional['outputs.StatusCodesResponse']:
        """
        The status codes that, when returned from the primary origin, will trigger CloudFront to failover to the second origin. A complex data type for the status codes that you specify that, when returned by a primary origin, trigger CloudFront to failover to a second origin.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class OriginGroupMemberResponse(dict):
    """
    Definition of OriginGroupMember
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originId":
            suggest = "origin_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginGroupMemberResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginGroupMemberResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginGroupMemberResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_id: Optional[str] = None):
        """
        Definition of OriginGroupMember
        :param str origin_id: The ID for an origin in an origin group.
        """
        if origin_id is not None:
            pulumi.set(__self__, "origin_id", origin_id)

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> Optional[str]:
        """
        The ID for an origin in an origin group.
        """
        return pulumi.get(self, "origin_id")


@pulumi.output_type
class OriginGroupMembersResponse(dict):
    """
    Definition of OriginGroupMembers
    """
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.OriginGroupMemberResponse']] = None,
                 quantity: Optional[int] = None):
        """
        Definition of OriginGroupMembers
        :param Sequence['OriginGroupMemberResponse'] items: Items (origins) in an origin group.
        :param int quantity: The number of origins in an origin group.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.OriginGroupMemberResponse']]:
        """
        Items (origins) in an origin group.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[int]:
        """
        The number of origins in an origin group.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class OriginGroupResponse(dict):
    """
    Definition of OriginGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverCriteria":
            suggest = "failover_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_criteria: Optional['outputs.OriginGroupFailoverCriteriaResponse'] = None,
                 id: Optional[str] = None,
                 members: Optional['outputs.OriginGroupMembersResponse'] = None):
        """
        Definition of OriginGroup
        :param 'OriginGroupFailoverCriteriaResponse' failover_criteria: A complex type that contains information about the failover criteria for an origin group. A complex data type that includes information about the failover criteria for an origin group, including the status codes for which CloudFront will failover from the primary origin to the second origin.
        :param str id: The origin group's ID.
        :param 'OriginGroupMembersResponse' members: A complex type that contains information about the origins in an origin group. A complex data type for the origins included in an origin group.
        """
        if failover_criteria is not None:
            pulumi.set(__self__, "failover_criteria", failover_criteria)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if members is not None:
            pulumi.set(__self__, "members", members)

    @property
    @pulumi.getter(name="failoverCriteria")
    def failover_criteria(self) -> Optional['outputs.OriginGroupFailoverCriteriaResponse']:
        """
        A complex type that contains information about the failover criteria for an origin group. A complex data type that includes information about the failover criteria for an origin group, including the status codes for which CloudFront will failover from the primary origin to the second origin.
        """
        return pulumi.get(self, "failover_criteria")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The origin group's ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def members(self) -> Optional['outputs.OriginGroupMembersResponse']:
        """
        A complex type that contains information about the origins in an origin group. A complex data type for the origins included in an origin group.
        """
        return pulumi.get(self, "members")


@pulumi.output_type
class OriginGroupsResponse(dict):
    """
    Definition of OriginGroups
    """
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.OriginGroupResponse']] = None,
                 quantity: Optional[int] = None):
        """
        Definition of OriginGroups
        :param Sequence['OriginGroupResponse'] items: The items (origin groups) in a distribution.
        :param int quantity: The number of origin groups.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.OriginGroupResponse']]:
        """
        The items (origin groups) in a distribution.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[int]:
        """
        The number of origin groups.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class OriginResponse(dict):
    """
    Definition of Origin
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionAttempts":
            suggest = "connection_attempts"
        elif key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "customOriginConfig":
            suggest = "custom_origin_config"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "originAccessControlId":
            suggest = "origin_access_control_id"
        elif key == "originCustomHeaders":
            suggest = "origin_custom_headers"
        elif key == "originPath":
            suggest = "origin_path"
        elif key == "originShield":
            suggest = "origin_shield"
        elif key == "s3OriginConfig":
            suggest = "s3_origin_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_attempts: Optional[int] = None,
                 connection_timeout: Optional[int] = None,
                 custom_origin_config: Optional['outputs.CustomOriginConfigResponse'] = None,
                 domain_name: Optional[str] = None,
                 id: Optional[str] = None,
                 origin_access_control_id: Optional[str] = None,
                 origin_custom_headers: Optional[Sequence['outputs.OriginCustomHeaderResponse']] = None,
                 origin_path: Optional[str] = None,
                 origin_shield: Optional['outputs.OriginShieldResponse'] = None,
                 s3_origin_config: Optional['outputs.S3OriginConfigResponse'] = None):
        """
        Definition of Origin
        :param int connection_attempts: The number of times that CloudFront attempts to connect to the origin. The minimum number is 1, the maximum is 3, and the default (if you don't specify otherwise) is 3. For a custom origin (including an Amazon S3 bucket that's configured with static website hosting), this value also specifies the number of times that CloudFront attempts to get a response from the origin, in the case of an [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout). For more information, see [Origin Connection Attempts](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts) in the *Amazon CloudFront Developer Guide*.
        :param int connection_timeout: The number of seconds that CloudFront waits when trying to establish a connection to the origin. The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you don't specify otherwise) is 10 seconds. For more information, see [Origin Connection Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout) in the *Amazon CloudFront Developer Guide*.
        :param 'CustomOriginConfigResponse' custom_origin_config: Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket is not configured with static website hosting, use the ``S3OriginConfig`` type instead. A custom origin. A custom origin is any origin that is *not* an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is [configured with static website hosting](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) *is* a custom origin.
        :param str domain_name: The domain name for the origin. For more information, see [Origin Domain Name](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName) in the *Amazon CloudFront Developer Guide*.
        :param str id: A unique identifier for the origin. This value must be unique within the distribution. Use this value to specify the ``TargetOriginId`` in a ``CacheBehavior`` or ``DefaultCacheBehavior``.
        :param str origin_access_control_id: The unique identifier of an origin access control for this origin. For more information, see [Restricting access to an Amazon S3 origin](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the *Amazon CloudFront Developer Guide*.
        :param Sequence['OriginCustomHeaderResponse'] origin_custom_headers: A list of HTTP header names and values that CloudFront adds to the requests that it sends to the origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html) in the *Amazon CloudFront Developer Guide*.
        :param str origin_path: An optional path that CloudFront appends to the origin domain name when CloudFront requests content from the origin. For more information, see [Origin Path](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath) in the *Amazon CloudFront Developer Guide*.
        :param 'OriginShieldResponse' origin_shield: CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the *Amazon CloudFront Developer Guide*. CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the *Amazon CloudFront Developer Guide*.
        :param 'S3OriginConfigResponse' s3_origin_config: Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static website hosting. To specify any other type of origin, including an Amazon S3 bucket that is configured with static website hosting, use the ``CustomOriginConfig`` type instead. A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin or an S3 bucket that is configured as a website endpoint, use the ``CustomOriginConfig`` element instead.
        """
        if connection_attempts is not None:
            pulumi.set(__self__, "connection_attempts", connection_attempts)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if custom_origin_config is not None:
            pulumi.set(__self__, "custom_origin_config", custom_origin_config)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if origin_access_control_id is not None:
            pulumi.set(__self__, "origin_access_control_id", origin_access_control_id)
        if origin_custom_headers is not None:
            pulumi.set(__self__, "origin_custom_headers", origin_custom_headers)
        if origin_path is not None:
            pulumi.set(__self__, "origin_path", origin_path)
        if origin_shield is not None:
            pulumi.set(__self__, "origin_shield", origin_shield)
        if s3_origin_config is not None:
            pulumi.set(__self__, "s3_origin_config", s3_origin_config)

    @property
    @pulumi.getter(name="connectionAttempts")
    def connection_attempts(self) -> Optional[int]:
        """
        The number of times that CloudFront attempts to connect to the origin. The minimum number is 1, the maximum is 3, and the default (if you don't specify otherwise) is 3. For a custom origin (including an Amazon S3 bucket that's configured with static website hosting), this value also specifies the number of times that CloudFront attempts to get a response from the origin, in the case of an [Origin Response Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout). For more information, see [Origin Connection Attempts](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "connection_attempts")

    @property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[int]:
        """
        The number of seconds that CloudFront waits when trying to establish a connection to the origin. The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you don't specify otherwise) is 10 seconds. For more information, see [Origin Connection Timeout](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "connection_timeout")

    @property
    @pulumi.getter(name="customOriginConfig")
    def custom_origin_config(self) -> Optional['outputs.CustomOriginConfigResponse']:
        """
        Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket is not configured with static website hosting, use the ``S3OriginConfig`` type instead. A custom origin. A custom origin is any origin that is *not* an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is [configured with static website hosting](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) *is* a custom origin.
        """
        return pulumi.get(self, "custom_origin_config")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        """
        The domain name for the origin. For more information, see [Origin Domain Name](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A unique identifier for the origin. This value must be unique within the distribution. Use this value to specify the ``TargetOriginId`` in a ``CacheBehavior`` or ``DefaultCacheBehavior``.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="originAccessControlId")
    def origin_access_control_id(self) -> Optional[str]:
        """
        The unique identifier of an origin access control for this origin. For more information, see [Restricting access to an Amazon S3 origin](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_access_control_id")

    @property
    @pulumi.getter(name="originCustomHeaders")
    def origin_custom_headers(self) -> Optional[Sequence['outputs.OriginCustomHeaderResponse']]:
        """
        A list of HTTP header names and values that CloudFront adds to the requests that it sends to the origin. For more information, see [Adding Custom Headers to Origin Requests](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_custom_headers")

    @property
    @pulumi.getter(name="originPath")
    def origin_path(self) -> Optional[str]:
        """
        An optional path that CloudFront appends to the origin domain name when CloudFront requests content from the origin. For more information, see [Origin Path](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_path")

    @property
    @pulumi.getter(name="originShield")
    def origin_shield(self) -> Optional['outputs.OriginShieldResponse']:
        """
        CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the *Amazon CloudFront Developer Guide*. CloudFront Origin Shield. Using Origin Shield can help reduce the load on your origin. For more information, see [Using Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_shield")

    @property
    @pulumi.getter(name="s3OriginConfig")
    def s3_origin_config(self) -> Optional['outputs.S3OriginConfigResponse']:
        """
        Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static website hosting. To specify any other type of origin, including an Amazon S3 bucket that is configured with static website hosting, use the ``CustomOriginConfig`` type instead. A complex type that contains information about the Amazon S3 origin. If the origin is a custom origin or an S3 bucket that is configured as a website endpoint, use the ``CustomOriginConfig`` element instead.
        """
        return pulumi.get(self, "s3_origin_config")


@pulumi.output_type
class OriginShieldResponse(dict):
    """
    Definition of OriginShield
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originShieldRegion":
            suggest = "origin_shield_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginShieldResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginShieldResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginShieldResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 origin_shield_region: Optional[str] = None):
        """
        Definition of OriginShield
        :param bool enabled: A flag that specifies whether Origin Shield is enabled. When it's enabled, CloudFront routes all requests through Origin Shield, which can help protect your origin. When it's disabled, CloudFront might send requests directly to your origin from multiple edge locations or regional edge caches.
        :param str origin_shield_region: The AWS-Region for Origin Shield. Specify the AWS-Region that has the lowest latency to your origin. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as ``us-east-2``. When you enable CloudFront Origin Shield, you must specify the AWS-Region for Origin Shield. For the list of AWS-Regions that you can specify, and for help choosing the best Region for your origin, see [Choosing the for Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region) in the *Amazon CloudFront Developer Guide*.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if origin_shield_region is not None:
            pulumi.set(__self__, "origin_shield_region", origin_shield_region)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        A flag that specifies whether Origin Shield is enabled. When it's enabled, CloudFront routes all requests through Origin Shield, which can help protect your origin. When it's disabled, CloudFront might send requests directly to your origin from multiple edge locations or regional edge caches.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="originShieldRegion")
    def origin_shield_region(self) -> Optional[str]:
        """
        The AWS-Region for Origin Shield. Specify the AWS-Region that has the lowest latency to your origin. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as ``us-east-2``. When you enable CloudFront Origin Shield, you must specify the AWS-Region for Origin Shield. For the list of AWS-Regions that you can specify, and for help choosing the best Region for your origin, see [Choosing the for Origin Shield](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_shield_region")


@pulumi.output_type
class OutpostConfigResponseResponse(dict):
    """
    Definition of OutpostConfigResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneInstanceType":
            suggest = "control_plane_instance_type"
        elif key == "controlPlanePlacement":
            suggest = "control_plane_placement"
        elif key == "outpostArns":
            suggest = "outpost_arns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutpostConfigResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutpostConfigResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutpostConfigResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_instance_type: Optional[str] = None,
                 control_plane_placement: Optional['outputs.ControlPlanePlacementResponseResponse'] = None,
                 outpost_arns: Optional[Sequence[str]] = None):
        """
        Definition of OutpostConfigResponse
        :param str control_plane_instance_type: <p>The Amazon EC2 instance type used for the control plane. The instance type is the same for all control plane instances.</p>
        :param 'ControlPlanePlacementResponseResponse' control_plane_placement: <p>An object representing the placement configuration for all the control plane instances of your local Amazon EKS cluster on an Amazon Web Services Outpost. For more information, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-capacity-considerations.html'>Capacity considerations</a> in the <i>Amazon EKS User Guide</i>.</p>
        :param Sequence[str] outpost_arns: <p>The ARN of the Outpost that you specified for use with your local Amazon EKS cluster on Outposts.</p>
        """
        if control_plane_instance_type is not None:
            pulumi.set(__self__, "control_plane_instance_type", control_plane_instance_type)
        if control_plane_placement is not None:
            pulumi.set(__self__, "control_plane_placement", control_plane_placement)
        if outpost_arns is not None:
            pulumi.set(__self__, "outpost_arns", outpost_arns)

    @property
    @pulumi.getter(name="controlPlaneInstanceType")
    def control_plane_instance_type(self) -> Optional[str]:
        """
        <p>The Amazon EC2 instance type used for the control plane. The instance type is the same for all control plane instances.</p>
        """
        return pulumi.get(self, "control_plane_instance_type")

    @property
    @pulumi.getter(name="controlPlanePlacement")
    def control_plane_placement(self) -> Optional['outputs.ControlPlanePlacementResponseResponse']:
        """
        <p>An object representing the placement configuration for all the control plane instances of your local Amazon EKS cluster on an Amazon Web Services Outpost. For more information, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-capacity-considerations.html'>Capacity considerations</a> in the <i>Amazon EKS User Guide</i>.</p>
        """
        return pulumi.get(self, "control_plane_placement")

    @property
    @pulumi.getter(name="outpostArns")
    def outpost_arns(self) -> Optional[Sequence[str]]:
        """
        <p>The ARN of the Outpost that you specified for use with your local Amazon EKS cluster on Outposts.</p>
        """
        return pulumi.get(self, "outpost_arns")


@pulumi.output_type
class OutputResponse(dict):
    """
    Definition of Output
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportName":
            suggest = "export_name"
        elif key == "outputKey":
            suggest = "output_key"
        elif key == "outputValue":
            suggest = "output_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 export_name: Optional[str] = None,
                 output_key: Optional[str] = None,
                 output_value: Optional[str] = None):
        """
        Definition of Output
        :param str description: Property description
        :param str export_name: Property exportName
        :param str output_key: Property outputKey
        :param str output_value: Property outputValue
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if export_name is not None:
            pulumi.set(__self__, "export_name", export_name)
        if output_key is not None:
            pulumi.set(__self__, "output_key", output_key)
        if output_value is not None:
            pulumi.set(__self__, "output_value", output_value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Property description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="exportName")
    def export_name(self) -> Optional[str]:
        """
        Property exportName
        """
        return pulumi.get(self, "export_name")

    @property
    @pulumi.getter(name="outputKey")
    def output_key(self) -> Optional[str]:
        """
        Property outputKey
        """
        return pulumi.get(self, "output_key")

    @property
    @pulumi.getter(name="outputValue")
    def output_value(self) -> Optional[str]:
        """
        Property outputValue
        """
        return pulumi.get(self, "output_value")


@pulumi.output_type
class OwnershipControlsResponse(dict):
    """
    Definition of OwnershipControls
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.OwnershipControlsRuleResponse']] = None):
        """
        Definition of OwnershipControls
        :param Sequence['OwnershipControlsRuleResponse'] rules: Specifies the container element for Object Ownership rules.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.OwnershipControlsRuleResponse']]:
        """
        Specifies the container element for Object Ownership rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class OwnershipControlsRuleResponse(dict):
    """
    Definition of OwnershipControlsRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectOwnership":
            suggest = "object_ownership"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OwnershipControlsRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OwnershipControlsRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OwnershipControlsRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_ownership: Optional[str] = None):
        """
        Definition of OwnershipControlsRule
        :param str object_ownership: Specifies an object ownership rule.
        """
        if object_ownership is not None:
            pulumi.set(__self__, "object_ownership", object_ownership)

    @property
    @pulumi.getter(name="objectOwnership")
    def object_ownership(self) -> Optional[str]:
        """
        Specifies an object ownership rule.
        """
        return pulumi.get(self, "object_ownership")


@pulumi.output_type
class ParameterGroupStatusResponse(dict):
    """
    Definition of ParameterGroupStatus
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIdsToReboot":
            suggest = "node_ids_to_reboot"
        elif key == "parameterApplyStatus":
            suggest = "parameter_apply_status"
        elif key == "parameterGroupName":
            suggest = "parameter_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ParameterGroupStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ParameterGroupStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ParameterGroupStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_ids_to_reboot: Optional[Sequence[str]] = None,
                 parameter_apply_status: Optional[str] = None,
                 parameter_group_name: Optional[str] = None):
        """
        Definition of ParameterGroupStatus
        :param Sequence[str] node_ids_to_reboot: <p>The node IDs of one or more nodes to be rebooted.</p>
        :param str parameter_apply_status: <p>The status of parameter updates. </p>
        :param str parameter_group_name: <p>The name of the parameter group.</p>
        """
        if node_ids_to_reboot is not None:
            pulumi.set(__self__, "node_ids_to_reboot", node_ids_to_reboot)
        if parameter_apply_status is not None:
            pulumi.set(__self__, "parameter_apply_status", parameter_apply_status)
        if parameter_group_name is not None:
            pulumi.set(__self__, "parameter_group_name", parameter_group_name)

    @property
    @pulumi.getter(name="nodeIdsToReboot")
    def node_ids_to_reboot(self) -> Optional[Sequence[str]]:
        """
        <p>The node IDs of one or more nodes to be rebooted.</p>
        """
        return pulumi.get(self, "node_ids_to_reboot")

    @property
    @pulumi.getter(name="parameterApplyStatus")
    def parameter_apply_status(self) -> Optional[str]:
        """
        <p>The status of parameter updates. </p>
        """
        return pulumi.get(self, "parameter_apply_status")

    @property
    @pulumi.getter(name="parameterGroupName")
    def parameter_group_name(self) -> Optional[str]:
        """
        <p>The name of the parameter group.</p>
        """
        return pulumi.get(self, "parameter_group_name")


@pulumi.output_type
class ParameterResponse(dict):
    """
    Definition of Parameter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parameterKey":
            suggest = "parameter_key"
        elif key == "parameterName":
            suggest = "parameter_name"
        elif key == "parameterValue":
            suggest = "parameter_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ParameterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ParameterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ParameterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parameter_key: Optional[str] = None,
                 parameter_name: Optional[str] = None,
                 parameter_value: Optional[str] = None):
        """
        Definition of Parameter
        :param str parameter_key: The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
        :param str parameter_name: The name of the parameter.
        :param str parameter_value: The value of the parameter. If `ParameterName` is `wlm_json_configuration`, then the maximum size of `ParameterValue` is 8000 characters.
        """
        if parameter_key is not None:
            pulumi.set(__self__, "parameter_key", parameter_key)
        if parameter_name is not None:
            pulumi.set(__self__, "parameter_name", parameter_name)
        if parameter_value is not None:
            pulumi.set(__self__, "parameter_value", parameter_value)

    @property
    @pulumi.getter(name="parameterKey")
    def parameter_key(self) -> Optional[str]:
        """
        The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
        """
        return pulumi.get(self, "parameter_key")

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[str]:
        """
        The name of the parameter.
        """
        return pulumi.get(self, "parameter_name")

    @property
    @pulumi.getter(name="parameterValue")
    def parameter_value(self) -> Optional[str]:
        """
        The value of the parameter. If `ParameterName` is `wlm_json_configuration`, then the maximum size of `ParameterValue` is 8000 characters.
        """
        return pulumi.get(self, "parameter_value")


@pulumi.output_type
class PartitionedPrefixResponse(dict):
    """
    Definition of PartitionedPrefix
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionDateSource":
            suggest = "partition_date_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionedPrefixResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionedPrefixResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionedPrefixResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partition_date_source: Optional[str] = None):
        """
        Definition of PartitionedPrefix
        :param str partition_date_source: Specifies the partition date source for the partitioned prefix. PartitionDateSource can be EventTime or DeliveryTime.
        """
        if partition_date_source is not None:
            pulumi.set(__self__, "partition_date_source", partition_date_source)

    @property
    @pulumi.getter(name="partitionDateSource")
    def partition_date_source(self) -> Optional[str]:
        """
        Specifies the partition date source for the partitioned prefix. PartitionDateSource can be EventTime or DeliveryTime.
        """
        return pulumi.get(self, "partition_date_source")


@pulumi.output_type
class PingStatusEnumValueResponse(dict):
    """
    Definition of PingStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of PingStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PlacementConstraintResponse(dict):
    """
    Definition of PlacementConstraint
    """
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Definition of PlacementConstraint
        :param str expression: A cluster query language expression to apply to the constraint. The expression can have a maximum length of 2000 characters. You can't specify an expression if the constraint type is ``distinctInstance``. For more information, see [Cluster query language](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param str type: The type of constraint. Use ``distinctInstance`` to ensure that each task in a particular group is running on a different container instance. Use ``memberOf`` to restrict the selection to a group of valid candidates.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        A cluster query language expression to apply to the constraint. The expression can have a maximum length of 2000 characters. You can't specify an expression if the constraint type is ``distinctInstance``. For more information, see [Cluster query language](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of constraint. Use ``distinctInstance`` to ensure that each task in a particular group is running on a different container instance. Use ``memberOf`` to restrict the selection to a group of valid candidates.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PlacementGroupConfigResponse(dict):
    """
    Definition of PlacementGroupConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceRole":
            suggest = "instance_role"
        elif key == "placementStrategy":
            suggest = "placement_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlacementGroupConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlacementGroupConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlacementGroupConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_role: Optional['outputs.InstanceRoleTypeEnumValueResponse'] = None,
                 placement_strategy: Optional['outputs.PlacementGroupStrategyEnumValueResponse'] = None):
        """
        Definition of PlacementGroupConfig
        :param 'InstanceRoleTypeEnumValueResponse' instance_role: <p>Role of the instance in the cluster.</p> <p>Starting with Amazon EMR release 5.23.0, the only supported instance role is <code>MASTER</code>.</p>
        :param 'PlacementGroupStrategyEnumValueResponse' placement_strategy: <p>Amazon EC2 Placement Group strategy associated with instance role.</p> <p>Starting with Amazon EMR release 5.23.0, the only supported placement strategy is <code>SPREAD</code> for the <code>MASTER</code> instance role.</p>
        """
        if instance_role is not None:
            pulumi.set(__self__, "instance_role", instance_role)
        if placement_strategy is not None:
            pulumi.set(__self__, "placement_strategy", placement_strategy)

    @property
    @pulumi.getter(name="instanceRole")
    def instance_role(self) -> Optional['outputs.InstanceRoleTypeEnumValueResponse']:
        """
        <p>Role of the instance in the cluster.</p> <p>Starting with Amazon EMR release 5.23.0, the only supported instance role is <code>MASTER</code>.</p>
        """
        return pulumi.get(self, "instance_role")

    @property
    @pulumi.getter(name="placementStrategy")
    def placement_strategy(self) -> Optional['outputs.PlacementGroupStrategyEnumValueResponse']:
        """
        <p>Amazon EC2 Placement Group strategy associated with instance role.</p> <p>Starting with Amazon EMR release 5.23.0, the only supported placement strategy is <code>SPREAD</code> for the <code>MASTER</code> instance role.</p>
        """
        return pulumi.get(self, "placement_strategy")


@pulumi.output_type
class PlacementGroupStrategyEnumValueResponse(dict):
    """
    Definition of PlacementGroupStrategyEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of PlacementGroupStrategyEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PlacementResponse(dict):
    """
    Definition of Placement
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlacementResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlacementResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlacementResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[str] = None,
                 availability_zone: Optional[str] = None,
                 group_id: Optional[str] = None,
                 group_name: Optional[str] = None,
                 host_id: Optional[str] = None,
                 host_resource_group_arn: Optional[str] = None,
                 partition_number: Optional[int] = None,
                 spread_domain: Optional[str] = None,
                 tenancy: Optional['outputs.TenancyEnumValueResponse'] = None):
        """
        Definition of Placement
        :param str affinity: <p>The affinity setting for the instance on the Dedicated Host.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a> or <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html'>ImportInstance</a>.</p>
        :param str availability_zone: <p>The Availability Zone of the instance.</p> <p>If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a>.</p>
        :param str group_id: <p>The ID of the placement group that the instance is in. If you specify <code>GroupId</code>, you can't specify <code>GroupName</code>.</p>
        :param str group_name: <p>The name of the placement group that the instance is in. If you specify <code>GroupName</code>, you can't specify <code>GroupId</code>.</p>
        :param str host_id: <p>The ID of the Dedicated Host on which the instance resides.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a> or <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html'>ImportInstance</a>.</p>
        :param str host_resource_group_arn: <p>The ARN of the host resource group in which to launch the instances.</p> <p>If you specify this parameter, either omit the <b>Tenancy</b> parameter or set it to <code>host</code>.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a>.</p>
        :param int partition_number: <p>The number of the partition that the instance is in. Valid only if the placement group strategy is set to <code>partition</code>.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a>.</p>
        :param str spread_domain: <p>Reserved for future use.</p>
        :param 'TenancyEnumValueResponse' tenancy: <p>The tenancy of the instance. An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a>. The <code>host</code> tenancy is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html'>ImportInstance</a> or for T3 instances that are configured for the <code>unlimited</code> CPU credit option.</p>
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[str]:
        """
        <p>The affinity setting for the instance on the Dedicated Host.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a> or <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html'>ImportInstance</a>.</p>
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        <p>The Availability Zone of the instance.</p> <p>If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a>.</p>
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        <p>The ID of the placement group that the instance is in. If you specify <code>GroupId</code>, you can't specify <code>GroupName</code>.</p>
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        <p>The name of the placement group that the instance is in. If you specify <code>GroupName</code>, you can't specify <code>GroupId</code>.</p>
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[str]:
        """
        <p>The ID of the Dedicated Host on which the instance resides.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a> or <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html'>ImportInstance</a>.</p>
        """
        return pulumi.get(self, "host_id")

    @property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[str]:
        """
        <p>The ARN of the host resource group in which to launch the instances.</p> <p>If you specify this parameter, either omit the <b>Tenancy</b> parameter or set it to <code>host</code>.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a>.</p>
        """
        return pulumi.get(self, "host_resource_group_arn")

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[int]:
        """
        <p>The number of the partition that the instance is in. Valid only if the placement group strategy is set to <code>partition</code>.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a>.</p>
        """
        return pulumi.get(self, "partition_number")

    @property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[str]:
        """
        <p>Reserved for future use.</p>
        """
        return pulumi.get(self, "spread_domain")

    @property
    @pulumi.getter
    def tenancy(self) -> Optional['outputs.TenancyEnumValueResponse']:
        """
        <p>The tenancy of the instance. An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware.</p> <p>This parameter is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet'>CreateFleet</a>. The <code>host</code> tenancy is not supported for <a href='https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html'>ImportInstance</a> or for T3 instances that are configured for the <code>unlimited</code> CPU credit option.</p>
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class PlacementStrategyResponse(dict):
    """
    Definition of PlacementStrategy
    """
    def __init__(__self__, *,
                 field: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Definition of PlacementStrategy
        :param str field: The field to apply the placement strategy against. For the ``spread`` placement strategy, valid values are ``instanceId`` (or ``host``, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as ``attribute:ecs.availability-zone``. For the ``binpack`` placement strategy, valid values are ``CPU`` and ``MEMORY``. For the ``random`` placement strategy, this field is not used.
        :param str type: The type of placement strategy. The ``random`` placement strategy randomly places tasks on available candidates. The ``spread`` placement strategy spreads placement across available candidates evenly based on the ``field`` parameter. The ``binpack`` strategy places tasks on available candidates that have the least available amount of the resource that's specified with the ``field`` parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory but still enough to run the task.
        """
        if field is not None:
            pulumi.set(__self__, "field", field)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        The field to apply the placement strategy against. For the ``spread`` placement strategy, valid values are ``instanceId`` (or ``host``, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as ``attribute:ecs.availability-zone``. For the ``binpack`` placement strategy, valid values are ``CPU`` and ``MEMORY``. For the ``random`` placement strategy, this field is not used.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of placement strategy. The ``random`` placement strategy randomly places tasks on available candidates. The ``spread`` placement strategy spreads placement across available candidates evenly based on the ``field`` parameter. The ``binpack`` strategy places tasks on available candidates that have the least available amount of the resource that's specified with the ``field`` parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory but still enough to run the task.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PlatformTypeEnumValueResponse(dict):
    """
    Definition of PlatformTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of PlatformTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PlatformValuesEnumValueResponse(dict):
    """
    Definition of PlatformValuesEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of PlatformValuesEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PointInTimeRecoveryDescriptionResponse(dict):
    """
    Definition of PointInTimeRecoveryDescription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earliestRestorableDateTime":
            suggest = "earliest_restorable_date_time"
        elif key == "latestRestorableDateTime":
            suggest = "latest_restorable_date_time"
        elif key == "pointInTimeRecoveryStatus":
            suggest = "point_in_time_recovery_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PointInTimeRecoveryDescriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PointInTimeRecoveryDescriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PointInTimeRecoveryDescriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 earliest_restorable_date_time: Optional[str] = None,
                 latest_restorable_date_time: Optional[str] = None,
                 point_in_time_recovery_status: Optional['outputs.PointInTimeRecoveryStatusEnumValueResponse'] = None):
        """
        Definition of PointInTimeRecoveryDescription
        :param str earliest_restorable_date_time: <p>Specifies the earliest point in time you can restore your table to. You can restore your table to any point in time during the last 35 days. </p>
        :param str latest_restorable_date_time: <p> <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time. </p>
        :param 'PointInTimeRecoveryStatusEnumValueResponse' point_in_time_recovery_status: <p>The current state of point in time recovery:</p> <ul> <li> <p> <code>ENABLED</code> - Point in time recovery is enabled.</p> </li> <li> <p> <code>DISABLED</code> - Point in time recovery is disabled.</p> </li> </ul>
        """
        if earliest_restorable_date_time is not None:
            pulumi.set(__self__, "earliest_restorable_date_time", earliest_restorable_date_time)
        if latest_restorable_date_time is not None:
            pulumi.set(__self__, "latest_restorable_date_time", latest_restorable_date_time)
        if point_in_time_recovery_status is not None:
            pulumi.set(__self__, "point_in_time_recovery_status", point_in_time_recovery_status)

    @property
    @pulumi.getter(name="earliestRestorableDateTime")
    def earliest_restorable_date_time(self) -> Optional[str]:
        """
        <p>Specifies the earliest point in time you can restore your table to. You can restore your table to any point in time during the last 35 days. </p>
        """
        return pulumi.get(self, "earliest_restorable_date_time")

    @property
    @pulumi.getter(name="latestRestorableDateTime")
    def latest_restorable_date_time(self) -> Optional[str]:
        """
        <p> <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time. </p>
        """
        return pulumi.get(self, "latest_restorable_date_time")

    @property
    @pulumi.getter(name="pointInTimeRecoveryStatus")
    def point_in_time_recovery_status(self) -> Optional['outputs.PointInTimeRecoveryStatusEnumValueResponse']:
        """
        <p>The current state of point in time recovery:</p> <ul> <li> <p> <code>ENABLED</code> - Point in time recovery is enabled.</p> </li> <li> <p> <code>DISABLED</code> - Point in time recovery is disabled.</p> </li> </ul>
        """
        return pulumi.get(self, "point_in_time_recovery_status")


@pulumi.output_type
class PointInTimeRecoverySpecificationResponse(dict):
    """
    Definition of PointInTimeRecoverySpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pointInTimeRecoveryEnabled":
            suggest = "point_in_time_recovery_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PointInTimeRecoverySpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PointInTimeRecoverySpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PointInTimeRecoverySpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 point_in_time_recovery_enabled: Optional[bool] = None):
        """
        Definition of PointInTimeRecoverySpecification
        :param bool point_in_time_recovery_enabled: Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.
        """
        if point_in_time_recovery_enabled is not None:
            pulumi.set(__self__, "point_in_time_recovery_enabled", point_in_time_recovery_enabled)

    @property
    @pulumi.getter(name="pointInTimeRecoveryEnabled")
    def point_in_time_recovery_enabled(self) -> Optional[bool]:
        """
        Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.
        """
        return pulumi.get(self, "point_in_time_recovery_enabled")


@pulumi.output_type
class PointInTimeRecoveryStatusEnumValueResponse(dict):
    """
    Definition of PointInTimeRecoveryStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of PointInTimeRecoveryStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PolicyResponse(dict):
    """
    Definition of Policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyDocument":
            suggest = "policy_document"
        elif key == "policyName":
            suggest = "policy_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_document: Optional[Any] = None,
                 policy_name: Optional[str] = None):
        """
        Definition of Policy
        :param Any policy_document: The entire contents of the policy that defines permissions. For more information, see [Overview of JSON policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json).
        :param str policy_name: The friendly name (not ARN) identifying the policy.
        """
        if policy_document is not None:
            pulumi.set(__self__, "policy_document", policy_document)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @property
    @pulumi.getter(name="policyDocument")
    def policy_document(self) -> Optional[Any]:
        """
        The entire contents of the policy that defines permissions. For more information, see [Overview of JSON policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#access_policies-json).
        """
        return pulumi.get(self, "policy_document")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[str]:
        """
        The friendly name (not ARN) identifying the policy.
        """
        return pulumi.get(self, "policy_name")


@pulumi.output_type
class PortMappingResponse(dict):
    """
    Definition of PortMapping
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appProtocol":
            suggest = "app_protocol"
        elif key == "containerPort":
            suggest = "container_port"
        elif key == "containerPortRange":
            suggest = "container_port_range"
        elif key == "hostPort":
            suggest = "host_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_protocol: Optional[str] = None,
                 container_port: Optional[int] = None,
                 container_port_range: Optional[str] = None,
                 host_port: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        Definition of PortMapping
        :param str app_protocol: The application protocol that's used for the port mapping. This parameter only applies to Service Connect. We recommend that you set this parameter to be consistent with the protocol that your application uses. If you set this parameter, Amazon ECS adds protocol-specific connection handling to the Service Connect proxy. If you set this parameter, Amazon ECS adds protocol-specific telemetry in the Amazon ECS console and CloudWatch. If you don't set a value for this parameter, then TCP is used. However, Amazon ECS doesn't add protocol-specific telemetry for TCP.  ``appProtocol`` is immutable in a Service Connect service. Updating this field requires a service deletion and redeployment. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param int container_port: The port number on the container that's bound to the user-specified or automatically assigned host port. If you use containers in a task with the ``awsvpc`` or ``host`` network mode, specify the exposed ports using ``containerPort``. If you use containers in a task with the ``bridge`` network mode and you specify a container port and not a host port, your container automatically receives a host port in the ephemeral port range. For more information, see ``hostPort``. Port mappings that are automatically assigned in this way do not count toward the 100 reserved ports limit of a container instance.
        :param str container_port_range: The port number range on the container that's bound to the dynamically mapped host port range.  The following rules apply when you specify a ``containerPortRange``:  +  You must use either the ``bridge`` network mode or the ``awsvpc`` network mode.  +  This parameter is available for both the EC2 and FARGATElong launch types.  +  This parameter is available for both the Linux and Windows operating systems.  +  The container instance must have at least version 1.67.0 of the container agent and at least version 1.67.0-1 of the ``ecs-init`` package   +  You can specify a maximum of 100 port ranges per container.  +  You do not specify a ``hostPortRange``. The value of the ``hostPortRange`` is set as follows:  +  For containers in a task with the ``awsvpc`` network mode, the ``hostPortRange`` is set to the same value as the ``containerPortRange``. This is a static mapping strategy.  +  For containers in a task with the ``bridge`` network mode, the Amazon ECS agent finds open host ports from the default ephemeral range and passes it to docker to bind them to the container ports.    +  The ``containerPortRange`` valid values are between 1 and 65535.  +  A port can only be included in one port mapping per container.  +  You cannot specify overlapping port ranges.  +  The first port in the range must be less than last port in the range.  +  Docker recommends that you turn off the docker-proxy in the Docker daemon config file when you have a large number of ports. For more information, see [Issue #11185](https://docs.aws.amazon.com/https://github.com/moby/moby/issues/11185) on the Github website. For information about how to turn off the docker-proxy in the Docker daemon config file, see [Docker daemon](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/bootstrap_container_instance.html#bootstrap_docker_daemon) in the *Amazon ECS Developer Guide*.   You can call [DescribeTasks](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeTasks.html) to view the ``hostPortRange`` which are the host ports that are bound to the container ports.
        :param int host_port: The port number on the container instance to reserve for your container. If you specify a ``containerPortRange``, leave this field empty and the value of the ``hostPort`` is set as follows:  +  For containers in a task with the ``awsvpc`` network mode, the ``hostPort`` is set to the same value as the ``containerPort``. This is a static mapping strategy.  +  For containers in a task with the ``bridge`` network mode, the Amazon ECS agent finds open ports on the host and automatically binds them to the container ports. This is a dynamic mapping strategy.   If you use containers in a task with the ``awsvpc`` or ``host`` network mode, the ``hostPort`` can either be left blank or set to the same value as the ``containerPort``. If you use containers in a task with the ``bridge`` network mode, you can specify a non-reserved host port for your container port mapping, or you can omit the ``hostPort`` (or set it to ``0``) while specifying a ``containerPort`` and your container automatically receives a port in the ephemeral port range for your container instance operating system and Docker version. The default ephemeral port range for Docker version 1.6.0 and later is listed on the instance under ``/proc/sys/net/ipv4/ip_local_port_range``. If this kernel parameter is unavailable, the default ephemeral port range from 49153 through 65535 (Linux) or 49152 through 65535 (Windows) is used. Do not attempt to specify a host port in the ephemeral port range as these are reserved for automatic assignment. In general, ports below 32768 are outside of the ephemeral port range. The default reserved ports are 22 for SSH, the Docker ports 2375 and 2376, and the Amazon ECS container agent ports 51678-51680. Any host port that was previously specified in a running task is also reserved while the task is running. That is, after a task stops, the host port is released. The current reserved ports are displayed in the ``remainingResources`` of [DescribeContainerInstances](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeContainerInstances.html) output. A container instance can have up to 100 reserved ports at a time. This number includes the default reserved ports. Automatically assigned ports aren't included in the 100 reserved ports quota.
        :param str name: The name that's used for the port mapping. This parameter only applies to Service Connect. This parameter is the name that you use in the ``serviceConnectConfiguration`` of a service. The name can include up to 64 characters. The characters can include lowercase letters, numbers, underscores (_), and hyphens (-). The name can't start with a hyphen. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param str protocol: The protocol used for the port mapping. Valid values are ``tcp`` and ``udp``. The default is ``tcp``. ``protocol`` is immutable in a Service Connect service. Updating this field requires a service deletion and redeployment.
        """
        if app_protocol is not None:
            pulumi.set(__self__, "app_protocol", app_protocol)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if container_port_range is not None:
            pulumi.set(__self__, "container_port_range", container_port_range)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="appProtocol")
    def app_protocol(self) -> Optional[str]:
        """
        The application protocol that's used for the port mapping. This parameter only applies to Service Connect. We recommend that you set this parameter to be consistent with the protocol that your application uses. If you set this parameter, Amazon ECS adds protocol-specific connection handling to the Service Connect proxy. If you set this parameter, Amazon ECS adds protocol-specific telemetry in the Amazon ECS console and CloudWatch. If you don't set a value for this parameter, then TCP is used. However, Amazon ECS doesn't add protocol-specific telemetry for TCP.  ``appProtocol`` is immutable in a Service Connect service. Updating this field requires a service deletion and redeployment. Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "app_protocol")

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[int]:
        """
        The port number on the container that's bound to the user-specified or automatically assigned host port. If you use containers in a task with the ``awsvpc`` or ``host`` network mode, specify the exposed ports using ``containerPort``. If you use containers in a task with the ``bridge`` network mode and you specify a container port and not a host port, your container automatically receives a host port in the ephemeral port range. For more information, see ``hostPort``. Port mappings that are automatically assigned in this way do not count toward the 100 reserved ports limit of a container instance.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="containerPortRange")
    def container_port_range(self) -> Optional[str]:
        """
        The port number range on the container that's bound to the dynamically mapped host port range.  The following rules apply when you specify a ``containerPortRange``:  +  You must use either the ``bridge`` network mode or the ``awsvpc`` network mode.  +  This parameter is available for both the EC2 and FARGATElong launch types.  +  This parameter is available for both the Linux and Windows operating systems.  +  The container instance must have at least version 1.67.0 of the container agent and at least version 1.67.0-1 of the ``ecs-init`` package   +  You can specify a maximum of 100 port ranges per container.  +  You do not specify a ``hostPortRange``. The value of the ``hostPortRange`` is set as follows:  +  For containers in a task with the ``awsvpc`` network mode, the ``hostPortRange`` is set to the same value as the ``containerPortRange``. This is a static mapping strategy.  +  For containers in a task with the ``bridge`` network mode, the Amazon ECS agent finds open host ports from the default ephemeral range and passes it to docker to bind them to the container ports.    +  The ``containerPortRange`` valid values are between 1 and 65535.  +  A port can only be included in one port mapping per container.  +  You cannot specify overlapping port ranges.  +  The first port in the range must be less than last port in the range.  +  Docker recommends that you turn off the docker-proxy in the Docker daemon config file when you have a large number of ports. For more information, see [Issue #11185](https://docs.aws.amazon.com/https://github.com/moby/moby/issues/11185) on the Github website. For information about how to turn off the docker-proxy in the Docker daemon config file, see [Docker daemon](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/bootstrap_container_instance.html#bootstrap_docker_daemon) in the *Amazon ECS Developer Guide*.   You can call [DescribeTasks](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeTasks.html) to view the ``hostPortRange`` which are the host ports that are bound to the container ports.
        """
        return pulumi.get(self, "container_port_range")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        The port number on the container instance to reserve for your container. If you specify a ``containerPortRange``, leave this field empty and the value of the ``hostPort`` is set as follows:  +  For containers in a task with the ``awsvpc`` network mode, the ``hostPort`` is set to the same value as the ``containerPort``. This is a static mapping strategy.  +  For containers in a task with the ``bridge`` network mode, the Amazon ECS agent finds open ports on the host and automatically binds them to the container ports. This is a dynamic mapping strategy.   If you use containers in a task with the ``awsvpc`` or ``host`` network mode, the ``hostPort`` can either be left blank or set to the same value as the ``containerPort``. If you use containers in a task with the ``bridge`` network mode, you can specify a non-reserved host port for your container port mapping, or you can omit the ``hostPort`` (or set it to ``0``) while specifying a ``containerPort`` and your container automatically receives a port in the ephemeral port range for your container instance operating system and Docker version. The default ephemeral port range for Docker version 1.6.0 and later is listed on the instance under ``/proc/sys/net/ipv4/ip_local_port_range``. If this kernel parameter is unavailable, the default ephemeral port range from 49153 through 65535 (Linux) or 49152 through 65535 (Windows) is used. Do not attempt to specify a host port in the ephemeral port range as these are reserved for automatic assignment. In general, ports below 32768 are outside of the ephemeral port range. The default reserved ports are 22 for SSH, the Docker ports 2375 and 2376, and the Amazon ECS container agent ports 51678-51680. Any host port that was previously specified in a running task is also reserved while the task is running. That is, after a task stops, the host port is released. The current reserved ports are displayed in the ``remainingResources`` of [DescribeContainerInstances](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeContainerInstances.html) output. A container instance can have up to 100 reserved ports at a time. This number includes the default reserved ports. Automatically assigned ports aren't included in the 100 reserved ports quota.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name that's used for the port mapping. This parameter only applies to Service Connect. This parameter is the name that you use in the ``serviceConnectConfiguration`` of a service. The name can include up to 64 characters. The characters can include lowercase letters, numbers, underscores (_), and hyphens (-). The name can't start with a hyphen. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol used for the port mapping. Valid values are ``tcp`` and ``udp``. The default is ``tcp``. ``protocol`` is immutable in a Service Connect service. Updating this field requires a service deletion and redeployment.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class PortRangeResponse(dict):
    """
    Definition of PortRange
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortRangeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortRangeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortRangeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[int] = None,
                 to_port: Optional[int] = None):
        """
        Definition of PortRange
        :param int from_port: Property fromPort
        :param int to_port: Property toPort
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        """
        Property fromPort
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        Property toPort
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class PortResponse(dict):
    """
    Definition of Port
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessDirection":
            suggest = "access_direction"
        elif key == "accessFrom":
            suggest = "access_from"
        elif key == "accessType":
            suggest = "access_type"
        elif key == "cidrListAliases":
            suggest = "cidr_list_aliases"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "fromPort":
            suggest = "from_port"
        elif key == "ipv6Cidrs":
            suggest = "ipv6_cidrs"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PortResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PortResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PortResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_direction: Optional[str] = None,
                 access_from: Optional[str] = None,
                 access_type: Optional[str] = None,
                 cidr_list_aliases: Optional[Sequence[str]] = None,
                 cidrs: Optional[Sequence[str]] = None,
                 common_name: Optional[str] = None,
                 from_port: Optional[int] = None,
                 ipv6_cidrs: Optional[Sequence[str]] = None,
                 protocol: Optional[str] = None,
                 to_port: Optional[int] = None):
        """
        Definition of Port
        :param str access_direction: Access Direction for Protocol of the Instance(inbound/outbound).
        :param str access_from: Access From Protocol of the Instance.
        :param str access_type: Access Type Protocol of the Instance.
        :param Sequence[str] cidr_list_aliases: cidr List Aliases
        :param Sequence[str] cidrs: Property cidrs
        :param str common_name: CommonName for Protocol of the Instance.
        :param int from_port: From Port of the Instance.
        :param Sequence[str] ipv6_cidrs: IPv6 Cidrs
        :param str protocol: Port Protocol of the Instance.
        :param int to_port: To Port of the Instance.
        """
        if access_direction is not None:
            pulumi.set(__self__, "access_direction", access_direction)
        if access_from is not None:
            pulumi.set(__self__, "access_from", access_from)
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if cidr_list_aliases is not None:
            pulumi.set(__self__, "cidr_list_aliases", cidr_list_aliases)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if ipv6_cidrs is not None:
            pulumi.set(__self__, "ipv6_cidrs", ipv6_cidrs)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="accessDirection")
    def access_direction(self) -> Optional[str]:
        """
        Access Direction for Protocol of the Instance(inbound/outbound).
        """
        return pulumi.get(self, "access_direction")

    @property
    @pulumi.getter(name="accessFrom")
    def access_from(self) -> Optional[str]:
        """
        Access From Protocol of the Instance.
        """
        return pulumi.get(self, "access_from")

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[str]:
        """
        Access Type Protocol of the Instance.
        """
        return pulumi.get(self, "access_type")

    @property
    @pulumi.getter(name="cidrListAliases")
    def cidr_list_aliases(self) -> Optional[Sequence[str]]:
        """
        cidr List Aliases
        """
        return pulumi.get(self, "cidr_list_aliases")

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[str]]:
        """
        Property cidrs
        """
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[str]:
        """
        CommonName for Protocol of the Instance.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        """
        From Port of the Instance.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="ipv6Cidrs")
    def ipv6_cidrs(self) -> Optional[Sequence[str]]:
        """
        IPv6 Cidrs
        """
        return pulumi.get(self, "ipv6_cidrs")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Port Protocol of the Instance.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        To Port of the Instance.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class PortSetResponse(dict):
    """
    Definition of PortSet
    """
    def __init__(__self__, *,
                 definition: Optional[Sequence[str]] = None):
        """
        Definition of PortSet
        :param Sequence[str] definition: Property definition
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[Sequence[str]]:
        """
        Property definition
        """
        return pulumi.get(self, "definition")


@pulumi.output_type
class PrefixListIdResponse(dict):
    """
    Definition of PrefixListId
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixListId":
            suggest = "prefix_list_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrefixListIdResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrefixListIdResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrefixListIdResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 prefix_list_id: Optional[str] = None):
        """
        Definition of PrefixListId
        :param str description: <p>A description for the security group rule that references this prefix list ID.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>
        :param str prefix_list_id: <p>The ID of the prefix.</p>
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description for the security group rule that references this prefix list ID.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        """
        <p>The ID of the prefix.</p>
        """
        return pulumi.get(self, "prefix_list_id")


@pulumi.output_type
class PrivateDnsNameOptionsOnLaunchModelPropertiesResponse(dict):
    """
    Definition of PrivateDnsNameOptionsOnLaunchModelProperties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsAAAARecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateDnsNameOptionsOnLaunchModelPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateDnsNameOptionsOnLaunchModelPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateDnsNameOptionsOnLaunchModelPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 hostname_type: Optional[str] = None):
        """
        Definition of PrivateDnsNameOptionsOnLaunchModelProperties
        :param bool enable_resource_name_dns_aaaa_record: Property enableResourceNameDnsAAAARecord
        :param bool enable_resource_name_dns_a_record: Property enableResourceNameDnsARecord
        :param str hostname_type: Property hostnameType
        """
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsAAAARecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        """
        Property enableResourceNameDnsAAAARecord
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        """
        Property enableResourceNameDnsARecord
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[str]:
        """
        Property hostnameType
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class PrivateDnsNameOptionsResponseResponse(dict):
    """
    Definition of PrivateDnsNameOptionsResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsAAAARecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateDnsNameOptionsResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateDnsNameOptionsResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateDnsNameOptionsResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 hostname_type: Optional['outputs.HostnameTypeEnumValueResponse'] = None):
        """
        Definition of PrivateDnsNameOptionsResponse
        :param bool enable_resource_name_dns_aaaa_record: <p>Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.</p>
        :param bool enable_resource_name_dns_a_record: <p>Indicates whether to respond to DNS queries for instance hostnames with DNS A records.</p>
        :param 'HostnameTypeEnumValueResponse' hostname_type: <p>The type of hostname to assign to an instance.</p>
        """
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsAAAARecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        """
        <p>Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.</p>
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        """
        <p>Indicates whether to respond to DNS queries for instance hostnames with DNS A records.</p>
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional['outputs.HostnameTypeEnumValueResponse']:
        """
        <p>The type of hostname to assign to an instance.</p>
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class PrivateIpAddressSpecificationResponse(dict):
    """
    Definition of PrivateIpAddressSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateIpAddressSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateIpAddressSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateIpAddressSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: Optional[bool] = None,
                 private_ip_address: Optional[str] = None):
        """
        Definition of PrivateIpAddressSpecification
        :param bool primary: Property primary
        :param str private_ip_address: Property privateIpAddress
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Property primary
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        Property privateIpAddress
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class ProcessorFeatureResponse(dict):
    """
    Definition of ProcessorFeature
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of ProcessorFeature
        :param str name: <p>The name of the processor feature. Valid names are <code>coreCount</code> and <code>threadsPerCore</code>.</p>
        :param str value: <p>The value of a processor feature name.</p>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>The name of the processor feature. Valid names are <code>coreCount</code> and <code>threadsPerCore</code>.</p>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        <p>The value of a processor feature name.</p>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProductCodeResponse(dict):
    """
    Definition of ProductCode
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "productCodeId":
            suggest = "product_code_id"
        elif key == "productCodeType":
            suggest = "product_code_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProductCodeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProductCodeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProductCodeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 product_code_id: Optional[str] = None,
                 product_code_type: Optional['outputs.ProductCodeValuesEnumValueResponse'] = None):
        """
        Definition of ProductCode
        :param str product_code_id: <p>The product code.</p>
        :param 'ProductCodeValuesEnumValueResponse' product_code_type: <p>The type of product code.</p>
        """
        if product_code_id is not None:
            pulumi.set(__self__, "product_code_id", product_code_id)
        if product_code_type is not None:
            pulumi.set(__self__, "product_code_type", product_code_type)

    @property
    @pulumi.getter(name="productCodeId")
    def product_code_id(self) -> Optional[str]:
        """
        <p>The product code.</p>
        """
        return pulumi.get(self, "product_code_id")

    @property
    @pulumi.getter(name="productCodeType")
    def product_code_type(self) -> Optional['outputs.ProductCodeValuesEnumValueResponse']:
        """
        <p>The type of product code.</p>
        """
        return pulumi.get(self, "product_code_type")


@pulumi.output_type
class ProductCodeValuesEnumValueResponse(dict):
    """
    Definition of ProductCodeValuesEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ProductCodeValuesEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProjectArtifactsResponse(dict):
    """
    Definition of ProjectArtifacts
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactIdentifier":
            suggest = "artifact_identifier"
        elif key == "bucketOwnerAccess":
            suggest = "bucket_owner_access"
        elif key == "encryptionDisabled":
            suggest = "encryption_disabled"
        elif key == "namespaceType":
            suggest = "namespace_type"
        elif key == "overrideArtifactName":
            suggest = "override_artifact_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectArtifactsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectArtifactsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectArtifactsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_identifier: Optional[str] = None,
                 bucket_owner_access: Optional['outputs.BucketOwnerAccessEnumValueResponse'] = None,
                 encryption_disabled: Optional[bool] = None,
                 location: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace_type: Optional['outputs.ArtifactNamespaceEnumValueResponse'] = None,
                 override_artifact_name: Optional[bool] = None,
                 packaging: Optional['outputs.ArtifactPackagingEnumValueResponse'] = None,
                 path: Optional[str] = None,
                 type: Optional['outputs.ArtifactsTypeEnumValueResponse'] = None):
        """
        Definition of ProjectArtifacts
        :param str artifact_identifier: <p> An identifier for this artifact definition. </p>
        :param 'BucketOwnerAccessEnumValueResponse' bucket_owner_access: Property bucketOwnerAccess
        :param bool encryption_disabled: <p> Set to true if you do not want your output artifacts encrypted. This option is valid only if your artifacts type is Amazon S3. If this is set with another artifacts type, an invalidInputException is thrown. </p>
        :param str location: <p>Information about the build output artifact location:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output bucket.</p> </li> </ul>
        :param str name: <p>Along with <code>path</code> and <code>namespaceType</code>, the pattern that CodeBuild uses to name and store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output artifact object. If you set the name to be a forward slash ('/'), the artifact is stored in the root of the output bucket.</p> </li> </ul> <p>For example:</p> <ul> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, then the output artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>. </p> </li> <li> <p> If <code>path</code> is empty, <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to '<code>/</code>', the output artifact is stored in the root of the output bucket. </p> </li> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to '<code>/</code>', the output artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;</code>. </p> </li> </ul>
        :param 'ArtifactNamespaceEnumValueResponse' namespace_type: <p>Along with <code>path</code> and <code>name</code>, the pattern that CodeBuild uses to determine the name and location to store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p> <ul> <li> <p> <code>BUILD_ID</code>: Include the build ID in the location of the build output artifact.</p> </li> <li> <p> <code>NONE</code>: Do not include the build ID. This is the default if <code>namespaceType</code> is not specified.</p> </li> </ul> </li> </ul> <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, the output artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>.</p>
        :param bool override_artifact_name: <p> If this flag is set, a name specified in the buildspec file overrides the artifact name. The name specified in a buildspec file is calculated at build time and uses the Shell Command Language. For example, you can append a date and time to your artifact name so that it is always unique. </p>
        :param 'ArtifactPackagingEnumValueResponse' packaging: <p>The type of build output artifact to create:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output artifacts instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p> <ul> <li> <p> <code>NONE</code>: CodeBuild creates in the output bucket a folder that contains the build output. This is the default if <code>packaging</code> is not specified.</p> </li> <li> <p> <code>ZIP</code>: CodeBuild creates in the output bucket a ZIP file that contains the build output.</p> </li> </ul> </li> </ul>
        :param str path: <p>Along with <code>namespaceType</code> and <code>name</code>, the pattern that CodeBuild uses to name and store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the path to the output artifact. If <code>path</code> is not specified, <code>path</code> is not used.</p> </li> </ul> <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, the output artifact is stored in the output bucket at <code>MyArtifacts/MyArtifact.zip</code>.</p>
        :param 'ArtifactsTypeEnumValueResponse' type: <p>The type of build output artifact. Valid values include:</p> <ul> <li> <p> <code>CODEPIPELINE</code>: The build project has build output generated through CodePipeline. </p> <note> <p>The <code>CODEPIPELINE</code> type is not supported for <code>secondaryArtifacts</code>.</p> </note> </li> <li> <p> <code>NO_ARTIFACTS</code>: The build project does not produce any build output.</p> </li> <li> <p> <code>S3</code>: The build project stores build output in Amazon S3.</p> </li> </ul>
        """
        if artifact_identifier is not None:
            pulumi.set(__self__, "artifact_identifier", artifact_identifier)
        if bucket_owner_access is not None:
            pulumi.set(__self__, "bucket_owner_access", bucket_owner_access)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace_type is not None:
            pulumi.set(__self__, "namespace_type", namespace_type)
        if override_artifact_name is not None:
            pulumi.set(__self__, "override_artifact_name", override_artifact_name)
        if packaging is not None:
            pulumi.set(__self__, "packaging", packaging)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="artifactIdentifier")
    def artifact_identifier(self) -> Optional[str]:
        """
        <p> An identifier for this artifact definition. </p>
        """
        return pulumi.get(self, "artifact_identifier")

    @property
    @pulumi.getter(name="bucketOwnerAccess")
    def bucket_owner_access(self) -> Optional['outputs.BucketOwnerAccessEnumValueResponse']:
        """
        Property bucketOwnerAccess
        """
        return pulumi.get(self, "bucket_owner_access")

    @property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[bool]:
        """
        <p> Set to true if you do not want your output artifacts encrypted. This option is valid only if your artifacts type is Amazon S3. If this is set with another artifacts type, an invalidInputException is thrown. </p>
        """
        return pulumi.get(self, "encryption_disabled")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        <p>Information about the build output artifact location:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output bucket.</p> </li> </ul>
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        <p>Along with <code>path</code> and <code>namespaceType</code>, the pattern that CodeBuild uses to name and store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output artifact object. If you set the name to be a forward slash ('/'), the artifact is stored in the root of the output bucket.</p> </li> </ul> <p>For example:</p> <ul> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, then the output artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>. </p> </li> <li> <p> If <code>path</code> is empty, <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to '<code>/</code>', the output artifact is stored in the root of the output bucket. </p> </li> <li> <p> If <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to '<code>/</code>', the output artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;</code>. </p> </li> </ul>
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="namespaceType")
    def namespace_type(self) -> Optional['outputs.ArtifactNamespaceEnumValueResponse']:
        """
        <p>Along with <code>path</code> and <code>name</code>, the pattern that CodeBuild uses to determine the name and location to store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p> <ul> <li> <p> <code>BUILD_ID</code>: Include the build ID in the location of the build output artifact.</p> </li> <li> <p> <code>NONE</code>: Do not include the build ID. This is the default if <code>namespaceType</code> is not specified.</p> </li> </ul> </li> </ul> <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, the output artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>.</p>
        """
        return pulumi.get(self, "namespace_type")

    @property
    @pulumi.getter(name="overrideArtifactName")
    def override_artifact_name(self) -> Optional[bool]:
        """
        <p> If this flag is set, a name specified in the buildspec file overrides the artifact name. The name specified in a buildspec file is calculated at build time and uses the Shell Command Language. For example, you can append a date and time to your artifact name so that it is always unique. </p>
        """
        return pulumi.get(self, "override_artifact_name")

    @property
    @pulumi.getter
    def packaging(self) -> Optional['outputs.ArtifactPackagingEnumValueResponse']:
        """
        <p>The type of build output artifact to create:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output artifacts instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p> <ul> <li> <p> <code>NONE</code>: CodeBuild creates in the output bucket a folder that contains the build output. This is the default if <code>packaging</code> is not specified.</p> </li> <li> <p> <code>ZIP</code>: CodeBuild creates in the output bucket a ZIP file that contains the build output.</p> </li> </ul> </li> </ul>
        """
        return pulumi.get(self, "packaging")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        <p>Along with <code>namespaceType</code> and <code>name</code>, the pattern that CodeBuild uses to name and store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>, this is the path to the output artifact. If <code>path</code> is not specified, <code>path</code> is not used.</p> </li> </ul> <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to <code>MyArtifact.zip</code>, the output artifact is stored in the output bucket at <code>MyArtifacts/MyArtifact.zip</code>.</p>
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.ArtifactsTypeEnumValueResponse']:
        """
        <p>The type of build output artifact. Valid values include:</p> <ul> <li> <p> <code>CODEPIPELINE</code>: The build project has build output generated through CodePipeline. </p> <note> <p>The <code>CODEPIPELINE</code> type is not supported for <code>secondaryArtifacts</code>.</p> </note> </li> <li> <p> <code>NO_ARTIFACTS</code>: The build project does not produce any build output.</p> </li> <li> <p> <code>S3</code>: The build project stores build output in Amazon S3.</p> </li> </ul>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectBadgeResponse(dict):
    """
    Definition of ProjectBadge
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "badgeEnabled":
            suggest = "badge_enabled"
        elif key == "badgeRequestUrl":
            suggest = "badge_request_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectBadgeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectBadgeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectBadgeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 badge_enabled: Optional[bool] = None,
                 badge_request_url: Optional[str] = None):
        """
        Definition of ProjectBadge
        :param bool badge_enabled: <p>Set this to true to generate a publicly accessible URL for your project's build badge.</p>
        :param str badge_request_url: <p>The publicly-accessible URL through which you can access the build badge for your project. </p>
        """
        if badge_enabled is not None:
            pulumi.set(__self__, "badge_enabled", badge_enabled)
        if badge_request_url is not None:
            pulumi.set(__self__, "badge_request_url", badge_request_url)

    @property
    @pulumi.getter(name="badgeEnabled")
    def badge_enabled(self) -> Optional[bool]:
        """
        <p>Set this to true to generate a publicly accessible URL for your project's build badge.</p>
        """
        return pulumi.get(self, "badge_enabled")

    @property
    @pulumi.getter(name="badgeRequestUrl")
    def badge_request_url(self) -> Optional[str]:
        """
        <p>The publicly-accessible URL through which you can access the build badge for your project. </p>
        """
        return pulumi.get(self, "badge_request_url")


@pulumi.output_type
class ProjectBuildBatchConfigResponse(dict):
    """
    Definition of ProjectBuildBatchConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchReportMode":
            suggest = "batch_report_mode"
        elif key == "combineArtifacts":
            suggest = "combine_artifacts"
        elif key == "serviceRole":
            suggest = "service_role"
        elif key == "timeoutInMins":
            suggest = "timeout_in_mins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectBuildBatchConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectBuildBatchConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectBuildBatchConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_report_mode: Optional['outputs.BatchReportModeTypeEnumValueResponse'] = None,
                 combine_artifacts: Optional[bool] = None,
                 restrictions: Optional['outputs.BatchRestrictionsResponse'] = None,
                 service_role: Optional[str] = None,
                 timeout_in_mins: Optional[int] = None):
        """
        Definition of ProjectBuildBatchConfig
        :param 'BatchReportModeTypeEnumValueResponse' batch_report_mode: <p>Specifies how build status reports are sent to the source provider for the batch build. This property is only used when the source provider for your project is Bitbucket, GitHub, or GitHub Enterprise, and your project is configured to report build statuses to the source provider.</p> <dl> <dt>REPORT_AGGREGATED_BATCH</dt> <dd> <p>(Default) Aggregate all of the build statuses into a single status report.</p> </dd> <dt>REPORT_INDIVIDUAL_BUILDS</dt> <dd> <p>Send a separate status report for each individual build.</p> </dd> </dl>
        :param bool combine_artifacts: <p>Specifies if the build artifacts for the batch build should be combined into a single artifact location.</p>
        :param 'BatchRestrictionsResponse' restrictions: <p>A <code>BatchRestrictions</code> object that specifies the restrictions for the batch build.</p>
        :param str service_role: <p>Specifies the service role ARN for the batch build project.</p>
        :param int timeout_in_mins: <p>Specifies the maximum amount of time, in minutes, that the batch build must be completed in.</p>
        """
        if batch_report_mode is not None:
            pulumi.set(__self__, "batch_report_mode", batch_report_mode)
        if combine_artifacts is not None:
            pulumi.set(__self__, "combine_artifacts", combine_artifacts)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)
        if service_role is not None:
            pulumi.set(__self__, "service_role", service_role)
        if timeout_in_mins is not None:
            pulumi.set(__self__, "timeout_in_mins", timeout_in_mins)

    @property
    @pulumi.getter(name="batchReportMode")
    def batch_report_mode(self) -> Optional['outputs.BatchReportModeTypeEnumValueResponse']:
        """
        <p>Specifies how build status reports are sent to the source provider for the batch build. This property is only used when the source provider for your project is Bitbucket, GitHub, or GitHub Enterprise, and your project is configured to report build statuses to the source provider.</p> <dl> <dt>REPORT_AGGREGATED_BATCH</dt> <dd> <p>(Default) Aggregate all of the build statuses into a single status report.</p> </dd> <dt>REPORT_INDIVIDUAL_BUILDS</dt> <dd> <p>Send a separate status report for each individual build.</p> </dd> </dl>
        """
        return pulumi.get(self, "batch_report_mode")

    @property
    @pulumi.getter(name="combineArtifacts")
    def combine_artifacts(self) -> Optional[bool]:
        """
        <p>Specifies if the build artifacts for the batch build should be combined into a single artifact location.</p>
        """
        return pulumi.get(self, "combine_artifacts")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional['outputs.BatchRestrictionsResponse']:
        """
        <p>A <code>BatchRestrictions</code> object that specifies the restrictions for the batch build.</p>
        """
        return pulumi.get(self, "restrictions")

    @property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> Optional[str]:
        """
        <p>Specifies the service role ARN for the batch build project.</p>
        """
        return pulumi.get(self, "service_role")

    @property
    @pulumi.getter(name="timeoutInMins")
    def timeout_in_mins(self) -> Optional[int]:
        """
        <p>Specifies the maximum amount of time, in minutes, that the batch build must be completed in.</p>
        """
        return pulumi.get(self, "timeout_in_mins")


@pulumi.output_type
class ProjectCacheResponse(dict):
    """
    Definition of ProjectCache
    """
    def __init__(__self__, *,
                 location: Optional[str] = None,
                 modes: Optional[Sequence[str]] = None,
                 type: Optional['outputs.CacheTypeEnumValueResponse'] = None):
        """
        Definition of ProjectCache
        :param str location: <p>Information about the cache location: </p> <ul> <li> <p> <code>NO_CACHE</code> or <code>LOCAL</code>: This value is ignored.</p> </li> <li> <p> <code>S3</code>: This is the S3 bucket name/prefix.</p> </li> </ul>
        :param Sequence[str] modes: <p>An array of strings that specify the local cache modes. You can use one or more local cache modes at the same time. This is only used for <code>LOCAL</code> cache types.</p> <p>Possible values are:</p> <dl> <dt>LOCAL_SOURCE_CACHE</dt> <dd> <p>Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds pull only the change between commits. This mode is a good choice for projects with a clean working directory and a source that is a large Git repository. If you choose this option and your project does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. </p> </dd> <dt>LOCAL_DOCKER_LAYER_CACHE</dt> <dd> <p>Caches existing Docker layers. This mode is a good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by pulling large Docker images down from the network. </p> <note> <ul> <li> <p>You can use a Docker layer cache in the Linux environment only. </p> </li> <li> <p>The <code>privileged</code> flag must be set so that your project has the required Docker permissions. </p> </li> <li> <p>You should consider the security implications before you use a Docker layer cache. </p> </li> </ul> </note> </dd> <dt>LOCAL_CUSTOM_CACHE</dt> <dd> <p>Caches directories you specify in the buildspec file. This mode is a good choice if your build scenario is not suited to one of the other three local cache modes. If you use a custom cache: </p> <ul> <li> <p>Only directories can be specified for caching. You cannot specify individual files. </p> </li> <li> <p>Symlinks are used to reference cached directories. </p> </li> <li> <p>Cached directories are linked to your build before it downloads its project sources. Cached items are overridden if a source item has the same name. Directories are specified using cache paths in the buildspec file. </p> </li> </ul> </dd> </dl>
        :param 'CacheTypeEnumValueResponse' type: <p>The type of cache used by the build project. Valid values include:</p> <ul> <li> <p> <code>NO_CACHE</code>: The build project does not use any cache.</p> </li> <li> <p> <code>S3</code>: The build project reads and writes from and to S3.</p> </li> <li> <p> <code>LOCAL</code>: The build project stores a cache locally on a build host that is only available to that build host.</p> </li> </ul>
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if modes is not None:
            pulumi.set(__self__, "modes", modes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        <p>Information about the cache location: </p> <ul> <li> <p> <code>NO_CACHE</code> or <code>LOCAL</code>: This value is ignored.</p> </li> <li> <p> <code>S3</code>: This is the S3 bucket name/prefix.</p> </li> </ul>
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def modes(self) -> Optional[Sequence[str]]:
        """
        <p>An array of strings that specify the local cache modes. You can use one or more local cache modes at the same time. This is only used for <code>LOCAL</code> cache types.</p> <p>Possible values are:</p> <dl> <dt>LOCAL_SOURCE_CACHE</dt> <dd> <p>Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds pull only the change between commits. This mode is a good choice for projects with a clean working directory and a source that is a large Git repository. If you choose this option and your project does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. </p> </dd> <dt>LOCAL_DOCKER_LAYER_CACHE</dt> <dd> <p>Caches existing Docker layers. This mode is a good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by pulling large Docker images down from the network. </p> <note> <ul> <li> <p>You can use a Docker layer cache in the Linux environment only. </p> </li> <li> <p>The <code>privileged</code> flag must be set so that your project has the required Docker permissions. </p> </li> <li> <p>You should consider the security implications before you use a Docker layer cache. </p> </li> </ul> </note> </dd> <dt>LOCAL_CUSTOM_CACHE</dt> <dd> <p>Caches directories you specify in the buildspec file. This mode is a good choice if your build scenario is not suited to one of the other three local cache modes. If you use a custom cache: </p> <ul> <li> <p>Only directories can be specified for caching. You cannot specify individual files. </p> </li> <li> <p>Symlinks are used to reference cached directories. </p> </li> <li> <p>Cached directories are linked to your build before it downloads its project sources. Cached items are overridden if a source item has the same name. Directories are specified using cache paths in the buildspec file. </p> </li> </ul> </dd> </dl>
        """
        return pulumi.get(self, "modes")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.CacheTypeEnumValueResponse']:
        """
        <p>The type of cache used by the build project. Valid values include:</p> <ul> <li> <p> <code>NO_CACHE</code>: The build project does not use any cache.</p> </li> <li> <p> <code>S3</code>: The build project reads and writes from and to S3.</p> </li> <li> <p> <code>LOCAL</code>: The build project stores a cache locally on a build host that is only available to that build host.</p> </li> </ul>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectEnvironmentResponse(dict):
    """
    Definition of ProjectEnvironment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeType":
            suggest = "compute_type"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "imagePullCredentialsType":
            suggest = "image_pull_credentials_type"
        elif key == "privilegedMode":
            suggest = "privileged_mode"
        elif key == "registryCredential":
            suggest = "registry_credential"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectEnvironmentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectEnvironmentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectEnvironmentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 compute_type: Optional['outputs.ComputeTypeEnumValueResponse'] = None,
                 environment_variables: Optional[Sequence['outputs.EnvironmentVariableResponse']] = None,
                 fleet: Optional['outputs.ProjectFleetResponse'] = None,
                 image: Optional[str] = None,
                 image_pull_credentials_type: Optional['outputs.ImagePullCredentialsTypeEnumValueResponse'] = None,
                 privileged_mode: Optional[bool] = None,
                 registry_credential: Optional['outputs.RegistryCredentialResponse'] = None,
                 type: Optional['outputs.EnvironmentTypeEnumValueResponse'] = None):
        """
        Definition of ProjectEnvironment
        :param str certificate: <p>The ARN of the Amazon S3 bucket, path prefix, and object key that contains the PEM-encoded certificate for the build project. For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/create-project-cli.html#cli.environment.certificate'>certificate</a> in the <i>CodeBuild User Guide</i>.</p>
        :param 'ComputeTypeEnumValueResponse' compute_type: <p>Information about the compute resources the build project uses. Available values include:</p> <ul> <li> <p> <code>BUILD_GENERAL1_SMALL</code>: Use up to 3 GB memory and 2 vCPUs for builds.</p> </li> <li> <p> <code>BUILD_GENERAL1_MEDIUM</code>: Use up to 7 GB memory and 4 vCPUs for builds.</p> </li> <li> <p> <code>BUILD_GENERAL1_LARGE</code>: Use up to 16 GB memory and 8 vCPUs for builds, depending on your environment type.</p> </li> <li> <p> <code>BUILD_GENERAL1_XLARGE</code>: Use up to 70 GB memory and 36 vCPUs for builds, depending on your environment type.</p> </li> <li> <p> <code>BUILD_GENERAL1_2XLARGE</code>: Use up to 145 GB memory, 72 vCPUs, and 824 GB of SSD storage for builds. This compute type supports Docker images up to 100 GB uncompressed.</p> </li> <li> <p> <code>BUILD_LAMBDA_1GB</code>: Use up to 1 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> <li> <p> <code>BUILD_LAMBDA_2GB</code>: Use up to 2 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> <li> <p> <code>BUILD_LAMBDA_4GB</code>: Use up to 4 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> <li> <p> <code>BUILD_LAMBDA_8GB</code>: Use up to 8 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> <li> <p> <code>BUILD_LAMBDA_10GB</code>: Use up to 10 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> </ul> <p> If you use <code>BUILD_GENERAL1_SMALL</code>: </p> <ul> <li> <p> For environment type <code>LINUX_CONTAINER</code>, you can use up to 3 GB memory and 2 vCPUs for builds. </p> </li> <li> <p> For environment type <code>LINUX_GPU_CONTAINER</code>, you can use up to 16 GB memory, 4 vCPUs, and 1 NVIDIA A10G Tensor Core GPU for builds.</p> </li> <li> <p> For environment type <code>ARM_CONTAINER</code>, you can use up to 4 GB memory and 2 vCPUs on ARM-based processors for builds.</p> </li> </ul> <p> If you use <code>BUILD_GENERAL1_LARGE</code>: </p> <ul> <li> <p> For environment type <code>LINUX_CONTAINER</code>, you can use up to 15 GB memory and 8 vCPUs for builds. </p> </li> <li> <p> For environment type <code>LINUX_GPU_CONTAINER</code>, you can use up to 255 GB memory, 32 vCPUs, and 4 NVIDIA Tesla V100 GPUs for builds.</p> </li> <li> <p> For environment type <code>ARM_CONTAINER</code>, you can use up to 16 GB memory and 8 vCPUs on ARM-based processors for builds.</p> </li> </ul> <note> <p>If you're using compute fleets during project creation, <code>computeType</code> will be ignored.</p> </note> <p>For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html'>Build Environment Compute Types</a> in the <i>CodeBuild User Guide.</i> </p>
        :param Sequence['EnvironmentVariableResponse'] environment_variables: <p>A set of environment variables to make available to builds for this build project.</p>
        :param 'ProjectFleetResponse' fleet: <p>A ProjectFleet object to use for this build project.</p>
        :param str image: <p>The image tag or image digest that identifies the Docker image to use for this build project. Use the following formats:</p> <ul> <li> <p>For an image tag: <code>&lt;registry&gt;/&lt;repository&gt;:&lt;tag&gt;</code>. For example, in the Docker repository that CodeBuild uses to manage its Docker images, this would be <code>aws/codebuild/standard:4.0</code>. </p> </li> <li> <p>For an image digest: <code>&lt;registry&gt;/&lt;repository&gt;@&lt;digest&gt;</code>. For example, to specify an image with the digest 'sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf,' use <code>&lt;registry&gt;/&lt;repository&gt;@sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf</code>.</p> </li> </ul> <p>For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html'>Docker images provided by CodeBuild</a> in the <i>CodeBuild user guide</i>.</p>
        :param 'ImagePullCredentialsTypeEnumValueResponse' image_pull_credentials_type: <p> The type of credentials CodeBuild uses to pull images in your build. There are two valid values: </p> <ul> <li> <p> <code>CODEBUILD</code> specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust CodeBuild service principal. </p> </li> <li> <p> <code>SERVICE_ROLE</code> specifies that CodeBuild uses your build project's service role. </p> </li> </ul> <p> When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an CodeBuild curated image, you must use CODEBUILD credentials. </p>
        :param bool privileged_mode: <p>Enables running the Docker daemon inside a Docker container. Set to true only if the build project is used to build Docker images. Otherwise, a build that attempts to interact with the Docker daemon fails. The default setting is <code>false</code>.</p> <p>You can initialize the Docker daemon during the install phase of your build by adding one of the following sets of commands to the install phase of your buildspec file:</p> <p>If the operating system's base image is Ubuntu Linux:</p> <p> <code>- nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&amp;</code> </p> <p> <code>- timeout 15 sh -c 'until docker info; do echo .; sleep 1; done'</code> </p> <p>If the operating system's base image is Alpine Linux and the previous command does not work, add the <code>-t</code> argument to <code>timeout</code>:</p> <p> <code>- nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&amp;</code> </p> <p> <code>- timeout -t 15 sh -c 'until docker info; do echo .; sleep 1; done'</code> </p>
        :param 'RegistryCredentialResponse' registry_credential: <p> The credentials for access to a private registry.</p>
        :param 'EnvironmentTypeEnumValueResponse' type: <p>The type of build environment to use for related builds.</p> <ul> <li> <p>The environment type <code>ARM_CONTAINER</code> is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), EU (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and EU (Frankfurt).</p> </li> <li> <p>The environment type <code>LINUX_CONTAINER</code> is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Canada (Central), EU (Ireland), EU (London), EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p> </li> <li> <p>The environment type <code>LINUX_GPU_CONTAINER</code> is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Canada (Central), EU (Ireland), EU (London), EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney) , China (Beijing), and China (Ningxia).</p> </li> </ul> <ul> <li> <p>The environment types <code>ARM_LAMBDA_CONTAINER</code> and <code>LINUX_LAMBDA_CONTAINER</code> are available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Asia Pacific (Mumbai), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), EU (Frankfurt), EU (Ireland), and South America (So Paulo).</p> </li> </ul> <ul> <li> <p>The environment types <code>WINDOWS_CONTAINER</code> and <code>WINDOWS_SERVER_2019_CONTAINER</code> are available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), and EU (Ireland).</p> </li> </ul> <note> <p>If you're using compute fleets during project creation, <code>type</code> will be ignored.</p> </note> <p>For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html'>Build environment compute types</a> in the <i>CodeBuild user guide</i>.</p>
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if compute_type is not None:
            pulumi.set(__self__, "compute_type", compute_type)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if fleet is not None:
            pulumi.set(__self__, "fleet", fleet)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_pull_credentials_type is not None:
            pulumi.set(__self__, "image_pull_credentials_type", image_pull_credentials_type)
        if privileged_mode is not None:
            pulumi.set(__self__, "privileged_mode", privileged_mode)
        if registry_credential is not None:
            pulumi.set(__self__, "registry_credential", registry_credential)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        <p>The ARN of the Amazon S3 bucket, path prefix, and object key that contains the PEM-encoded certificate for the build project. For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/create-project-cli.html#cli.environment.certificate'>certificate</a> in the <i>CodeBuild User Guide</i>.</p>
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="computeType")
    def compute_type(self) -> Optional['outputs.ComputeTypeEnumValueResponse']:
        """
        <p>Information about the compute resources the build project uses. Available values include:</p> <ul> <li> <p> <code>BUILD_GENERAL1_SMALL</code>: Use up to 3 GB memory and 2 vCPUs for builds.</p> </li> <li> <p> <code>BUILD_GENERAL1_MEDIUM</code>: Use up to 7 GB memory and 4 vCPUs for builds.</p> </li> <li> <p> <code>BUILD_GENERAL1_LARGE</code>: Use up to 16 GB memory and 8 vCPUs for builds, depending on your environment type.</p> </li> <li> <p> <code>BUILD_GENERAL1_XLARGE</code>: Use up to 70 GB memory and 36 vCPUs for builds, depending on your environment type.</p> </li> <li> <p> <code>BUILD_GENERAL1_2XLARGE</code>: Use up to 145 GB memory, 72 vCPUs, and 824 GB of SSD storage for builds. This compute type supports Docker images up to 100 GB uncompressed.</p> </li> <li> <p> <code>BUILD_LAMBDA_1GB</code>: Use up to 1 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> <li> <p> <code>BUILD_LAMBDA_2GB</code>: Use up to 2 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> <li> <p> <code>BUILD_LAMBDA_4GB</code>: Use up to 4 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> <li> <p> <code>BUILD_LAMBDA_8GB</code>: Use up to 8 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> <li> <p> <code>BUILD_LAMBDA_10GB</code>: Use up to 10 GB memory for builds. Only available for environment type <code>LINUX_LAMBDA_CONTAINER</code> and <code>ARM_LAMBDA_CONTAINER</code>.</p> </li> </ul> <p> If you use <code>BUILD_GENERAL1_SMALL</code>: </p> <ul> <li> <p> For environment type <code>LINUX_CONTAINER</code>, you can use up to 3 GB memory and 2 vCPUs for builds. </p> </li> <li> <p> For environment type <code>LINUX_GPU_CONTAINER</code>, you can use up to 16 GB memory, 4 vCPUs, and 1 NVIDIA A10G Tensor Core GPU for builds.</p> </li> <li> <p> For environment type <code>ARM_CONTAINER</code>, you can use up to 4 GB memory and 2 vCPUs on ARM-based processors for builds.</p> </li> </ul> <p> If you use <code>BUILD_GENERAL1_LARGE</code>: </p> <ul> <li> <p> For environment type <code>LINUX_CONTAINER</code>, you can use up to 15 GB memory and 8 vCPUs for builds. </p> </li> <li> <p> For environment type <code>LINUX_GPU_CONTAINER</code>, you can use up to 255 GB memory, 32 vCPUs, and 4 NVIDIA Tesla V100 GPUs for builds.</p> </li> <li> <p> For environment type <code>ARM_CONTAINER</code>, you can use up to 16 GB memory and 8 vCPUs on ARM-based processors for builds.</p> </li> </ul> <note> <p>If you're using compute fleets during project creation, <code>computeType</code> will be ignored.</p> </note> <p>For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html'>Build Environment Compute Types</a> in the <i>CodeBuild User Guide.</i> </p>
        """
        return pulumi.get(self, "compute_type")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Sequence['outputs.EnvironmentVariableResponse']]:
        """
        <p>A set of environment variables to make available to builds for this build project.</p>
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter
    def fleet(self) -> Optional['outputs.ProjectFleetResponse']:
        """
        <p>A ProjectFleet object to use for this build project.</p>
        """
        return pulumi.get(self, "fleet")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        <p>The image tag or image digest that identifies the Docker image to use for this build project. Use the following formats:</p> <ul> <li> <p>For an image tag: <code>&lt;registry&gt;/&lt;repository&gt;:&lt;tag&gt;</code>. For example, in the Docker repository that CodeBuild uses to manage its Docker images, this would be <code>aws/codebuild/standard:4.0</code>. </p> </li> <li> <p>For an image digest: <code>&lt;registry&gt;/&lt;repository&gt;@&lt;digest&gt;</code>. For example, to specify an image with the digest 'sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf,' use <code>&lt;registry&gt;/&lt;repository&gt;@sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf</code>.</p> </li> </ul> <p>For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html'>Docker images provided by CodeBuild</a> in the <i>CodeBuild user guide</i>.</p>
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="imagePullCredentialsType")
    def image_pull_credentials_type(self) -> Optional['outputs.ImagePullCredentialsTypeEnumValueResponse']:
        """
        <p> The type of credentials CodeBuild uses to pull images in your build. There are two valid values: </p> <ul> <li> <p> <code>CODEBUILD</code> specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust CodeBuild service principal. </p> </li> <li> <p> <code>SERVICE_ROLE</code> specifies that CodeBuild uses your build project's service role. </p> </li> </ul> <p> When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an CodeBuild curated image, you must use CODEBUILD credentials. </p>
        """
        return pulumi.get(self, "image_pull_credentials_type")

    @property
    @pulumi.getter(name="privilegedMode")
    def privileged_mode(self) -> Optional[bool]:
        """
        <p>Enables running the Docker daemon inside a Docker container. Set to true only if the build project is used to build Docker images. Otherwise, a build that attempts to interact with the Docker daemon fails. The default setting is <code>false</code>.</p> <p>You can initialize the Docker daemon during the install phase of your build by adding one of the following sets of commands to the install phase of your buildspec file:</p> <p>If the operating system's base image is Ubuntu Linux:</p> <p> <code>- nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&amp;</code> </p> <p> <code>- timeout 15 sh -c 'until docker info; do echo .; sleep 1; done'</code> </p> <p>If the operating system's base image is Alpine Linux and the previous command does not work, add the <code>-t</code> argument to <code>timeout</code>:</p> <p> <code>- nohup /usr/local/bin/dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 --storage-driver=overlay&amp;</code> </p> <p> <code>- timeout -t 15 sh -c 'until docker info; do echo .; sleep 1; done'</code> </p>
        """
        return pulumi.get(self, "privileged_mode")

    @property
    @pulumi.getter(name="registryCredential")
    def registry_credential(self) -> Optional['outputs.RegistryCredentialResponse']:
        """
        <p> The credentials for access to a private registry.</p>
        """
        return pulumi.get(self, "registry_credential")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.EnvironmentTypeEnumValueResponse']:
        """
        <p>The type of build environment to use for related builds.</p> <ul> <li> <p>The environment type <code>ARM_CONTAINER</code> is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), EU (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and EU (Frankfurt).</p> </li> <li> <p>The environment type <code>LINUX_CONTAINER</code> is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Canada (Central), EU (Ireland), EU (London), EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia).</p> </li> <li> <p>The environment type <code>LINUX_GPU_CONTAINER</code> is available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Canada (Central), EU (Ireland), EU (London), EU (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney) , China (Beijing), and China (Ningxia).</p> </li> </ul> <ul> <li> <p>The environment types <code>ARM_LAMBDA_CONTAINER</code> and <code>LINUX_LAMBDA_CONTAINER</code> are available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), Asia Pacific (Mumbai), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), EU (Frankfurt), EU (Ireland), and South America (So Paulo).</p> </li> </ul> <ul> <li> <p>The environment types <code>WINDOWS_CONTAINER</code> and <code>WINDOWS_SERVER_2019_CONTAINER</code> are available only in regions US East (N. Virginia), US East (Ohio), US West (Oregon), and EU (Ireland).</p> </li> </ul> <note> <p>If you're using compute fleets during project creation, <code>type</code> will be ignored.</p> </note> <p>For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-compute-types.html'>Build environment compute types</a> in the <i>CodeBuild user guide</i>.</p>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectFileSystemLocationResponse(dict):
    """
    Definition of ProjectFileSystemLocation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountOptions":
            suggest = "mount_options"
        elif key == "mountPoint":
            suggest = "mount_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectFileSystemLocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectFileSystemLocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectFileSystemLocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identifier: Optional[str] = None,
                 location: Optional[str] = None,
                 mount_options: Optional[str] = None,
                 mount_point: Optional[str] = None,
                 type: Optional['outputs.FileSystemTypeEnumValueResponse'] = None):
        """
        Definition of ProjectFileSystemLocation
        :param str identifier: <p>The name used to access a file system created by Amazon EFS. CodeBuild creates an environment variable by appending the <code>identifier</code> in all capital letters to <code>CODEBUILD_</code>. For example, if you specify <code>my_efs</code> for <code>identifier</code>, a new environment variable is create named <code>CODEBUILD_MY_EFS</code>. </p> <p> The <code>identifier</code> is used to mount your file system. </p>
        :param str location: <p>A string that specifies the location of the file system created by Amazon EFS. Its format is <code>efs-dns-name:/directory-path</code>. You can find the DNS name of file system when you view it in the Amazon EFS console. The directory path is a path to a directory in the file system that CodeBuild mounts. For example, if the DNS name of a file system is <code>fs-abcd1234.efs.us-west-2.amazonaws.com</code>, and its mount directory is <code>my-efs-mount-directory</code>, then the <code>location</code> is <code>fs-abcd1234.efs.us-west-2.amazonaws.com:/my-efs-mount-directory</code>. </p> <p>The directory path in the format <code>efs-dns-name:/directory-path</code> is optional. If you do not specify a directory path, the location is only the DNS name and CodeBuild mounts the entire file system. </p>
        :param str mount_options: <p> The mount options for a file system created by Amazon EFS. The default mount options used by CodeBuild are <code>nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2</code>. For more information, see <a href='https://docs.aws.amazon.com/efs/latest/ug/mounting-fs-nfs-mount-settings.html'>Recommended NFS Mount Options</a>. </p>
        :param str mount_point: <p>The location in the container where you mount the file system. </p>
        :param 'FileSystemTypeEnumValueResponse' type: <p> The type of the file system. The one supported type is <code>EFS</code>. </p>
        """
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)
        if mount_point is not None:
            pulumi.set(__self__, "mount_point", mount_point)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        """
        <p>The name used to access a file system created by Amazon EFS. CodeBuild creates an environment variable by appending the <code>identifier</code> in all capital letters to <code>CODEBUILD_</code>. For example, if you specify <code>my_efs</code> for <code>identifier</code>, a new environment variable is create named <code>CODEBUILD_MY_EFS</code>. </p> <p> The <code>identifier</code> is used to mount your file system. </p>
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        <p>A string that specifies the location of the file system created by Amazon EFS. Its format is <code>efs-dns-name:/directory-path</code>. You can find the DNS name of file system when you view it in the Amazon EFS console. The directory path is a path to a directory in the file system that CodeBuild mounts. For example, if the DNS name of a file system is <code>fs-abcd1234.efs.us-west-2.amazonaws.com</code>, and its mount directory is <code>my-efs-mount-directory</code>, then the <code>location</code> is <code>fs-abcd1234.efs.us-west-2.amazonaws.com:/my-efs-mount-directory</code>. </p> <p>The directory path in the format <code>efs-dns-name:/directory-path</code> is optional. If you do not specify a directory path, the location is only the DNS name and CodeBuild mounts the entire file system. </p>
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        """
        <p> The mount options for a file system created by Amazon EFS. The default mount options used by CodeBuild are <code>nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2</code>. For more information, see <a href='https://docs.aws.amazon.com/efs/latest/ug/mounting-fs-nfs-mount-settings.html'>Recommended NFS Mount Options</a>. </p>
        """
        return pulumi.get(self, "mount_options")

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[str]:
        """
        <p>The location in the container where you mount the file system. </p>
        """
        return pulumi.get(self, "mount_point")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.FileSystemTypeEnumValueResponse']:
        """
        <p> The type of the file system. The one supported type is <code>EFS</code>. </p>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectFleetResponse(dict):
    """
    Definition of ProjectFleet
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fleetArn":
            suggest = "fleet_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectFleetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectFleetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectFleetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fleet_arn: Optional[str] = None):
        """
        Definition of ProjectFleet
        :param str fleet_arn: <p>Specifies the compute fleet ARN for the build project.</p>
        """
        if fleet_arn is not None:
            pulumi.set(__self__, "fleet_arn", fleet_arn)

    @property
    @pulumi.getter(name="fleetArn")
    def fleet_arn(self) -> Optional[str]:
        """
        <p>Specifies the compute fleet ARN for the build project.</p>
        """
        return pulumi.get(self, "fleet_arn")


@pulumi.output_type
class ProjectSourceResponse(dict):
    """
    Definition of ProjectSource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildStatusConfig":
            suggest = "build_status_config"
        elif key == "gitCloneDepth":
            suggest = "git_clone_depth"
        elif key == "gitSubmodulesConfig":
            suggest = "git_submodules_config"
        elif key == "insecureSsl":
            suggest = "insecure_ssl"
        elif key == "reportBuildStatus":
            suggest = "report_build_status"
        elif key == "sourceIdentifier":
            suggest = "source_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.SourceAuthResponse'] = None,
                 build_status_config: Optional['outputs.BuildStatusConfigResponse'] = None,
                 buildspec: Optional[str] = None,
                 git_clone_depth: Optional[int] = None,
                 git_submodules_config: Optional['outputs.GitSubmodulesConfigResponse'] = None,
                 insecure_ssl: Optional[bool] = None,
                 location: Optional[str] = None,
                 report_build_status: Optional[bool] = None,
                 source_identifier: Optional[str] = None,
                 type: Optional['outputs.SourceTypeEnumValueResponse'] = None):
        """
        Definition of ProjectSource
        :param 'SourceAuthResponse' auth: <p>Information about the authorization settings for CodeBuild to access the source code to be built.</p> <p>This information is for the CodeBuild console's use only. Your code should not get or set this information directly.</p>
        :param 'BuildStatusConfigResponse' build_status_config: <p>Contains information that defines how the build project reports the build status to the source provider. This option is only used when the source provider is <code>GITHUB</code>, <code>GITHUB_ENTERPRISE</code>, or <code>BITBUCKET</code>.</p>
        :param str buildspec: <p>The buildspec file declaration to use for the builds in this build project.</p> <p> If this value is set, it can be either an inline buildspec definition, the path to an alternate buildspec file relative to the value of the built-in <code>CODEBUILD_SRC_DIR</code> environment variable, or the path to an S3 bucket. The bucket must be in the same Amazon Web Services Region as the build project. Specify the buildspec file using its ARN (for example, <code>arn:aws:s3:::my-codebuild-sample2/buildspec.yml</code>). If this value is not provided or is set to an empty string, the source code must contain a buildspec file in its root directory. For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-name-storage'>Buildspec File Name and Storage Location</a>. </p>
        :param int git_clone_depth: <p>Information about the Git clone depth for the build project.</p>
        :param 'GitSubmodulesConfigResponse' git_submodules_config: <p> Information about the Git submodules configuration for the build project. </p>
        :param bool insecure_ssl: <p>Enable this flag to ignore SSL warnings while connecting to the project source code.</p>
        :param str location: <p>Information about the location of the source code to be built. Valid values include:</p> <ul> <li> <p>For source code settings that are specified in the source action of a pipeline in CodePipeline, <code>location</code> should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.</p> </li> <li> <p>For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the buildspec file (for example, <code>https://git-codecommit.&lt;region-ID&gt;.amazonaws.com/v1/repos/&lt;repo-name&gt;</code>).</p> </li> <li> <p>For source code in an Amazon S3 input bucket, one of the following. </p> <ul> <li> <p>The path to the ZIP file that contains the source code (for example, <code>&lt;bucket-name&gt;/&lt;path&gt;/&lt;object-name&gt;.zip</code>). </p> </li> <li> <p>The path to the folder that contains the source code (for example, <code>&lt;bucket-name&gt;/&lt;path-to-source-code&gt;/&lt;folder&gt;/</code>). </p> </li> </ul> </li> <li> <p>For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your Amazon Web Services account to your GitHub account. Use the CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with GitHub, on the GitHub <b>Authorize application</b> page, for <b>Organization access</b>, choose <b>Request access</b> next to each repository you want to allow CodeBuild to have access to, and then choose <b>Authorize application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build project. You can leave the CodeBuild console.) To instruct CodeBuild to use this connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.</p> </li> <li> <p>For source code in an GitLab or self-managed GitLab repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your Amazon Web Services account to your GitLab account. Use the CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with GitLab, on the Connections <b>Authorize application</b> page, choose <b>Authorize</b>. Then on the CodeConnections <b>Create GitLab connection</b> page, choose <b>Connect to GitLab</b>. (After you have connected to your GitLab account, you do not need to finish creating the build project. You can leave the CodeBuild console.) To instruct CodeBuild to override the default connection and use this connection instead, set the <code>auth</code> object's <code>type</code> value to <code>CODECONNECTIONS</code> in the <code>source</code> object.</p> </li> <li> <p>For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your Amazon Web Services account to your Bitbucket account. Use the CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page, choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to finish creating the build project. You can leave the CodeBuild console.) To instruct CodeBuild to use this connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.</p> </li> </ul> <p> If you specify <code>CODEPIPELINE</code> for the <code>Type</code> property, don't specify this property. For all of the other types, you must specify <code>Location</code>. </p>
        :param bool report_build_status: <p> Set to true to report the status of a build's start and finish to your source provider. This option is valid only when your source provider is GitHub, GitHub Enterprise, GitLab, GitLab Self Managed, or Bitbucket. If this is set and you use a different source provider, an <code>invalidInputException</code> is thrown. </p> <p>To be able to report the build status to the source provider, the user associated with the source provider must have write access to the repo. If the user does not have write access, the build status cannot be updated. For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/access-tokens.html'>Source provider access</a> in the <i>CodeBuild User Guide</i>.</p> <p>The status of a build triggered by a webhook is always reported to your source provider. </p> <p>If your project's builds are triggered by a webhook, you must push a new commit to the repo for a change to this property to take effect.</p>
        :param str source_identifier: <p>An identifier for this project source. The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length. </p>
        :param 'SourceTypeEnumValueResponse' type: <p>The type of repository that contains the source code to be built. Valid values include:</p> <ul> <li> <p> <code>BITBUCKET</code>: The source code is in a Bitbucket repository.</p> </li> <li> <p> <code>CODECOMMIT</code>: The source code is in an CodeCommit repository.</p> </li> <li> <p> <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in CodePipeline.</p> </li> <li> <p> <code>GITHUB</code>: The source code is in a GitHub repository.</p> </li> <li> <p> <code>GITHUB_ENTERPRISE</code>: The source code is in a GitHub Enterprise Server repository.</p> </li> <li> <p> <code>GITLAB</code>: The source code is in a GitLab repository.</p> </li> <li> <p> <code>GITLAB_SELF_MANAGED</code>: The source code is in a self-managed GitLab repository.</p> </li> <li> <p> <code>NO_SOURCE</code>: The project does not have input source code.</p> </li> <li> <p> <code>S3</code>: The source code is in an Amazon S3 bucket.</p> </li> </ul>
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if build_status_config is not None:
            pulumi.set(__self__, "build_status_config", build_status_config)
        if buildspec is not None:
            pulumi.set(__self__, "buildspec", buildspec)
        if git_clone_depth is not None:
            pulumi.set(__self__, "git_clone_depth", git_clone_depth)
        if git_submodules_config is not None:
            pulumi.set(__self__, "git_submodules_config", git_submodules_config)
        if insecure_ssl is not None:
            pulumi.set(__self__, "insecure_ssl", insecure_ssl)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if report_build_status is not None:
            pulumi.set(__self__, "report_build_status", report_build_status)
        if source_identifier is not None:
            pulumi.set(__self__, "source_identifier", source_identifier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.SourceAuthResponse']:
        """
        <p>Information about the authorization settings for CodeBuild to access the source code to be built.</p> <p>This information is for the CodeBuild console's use only. Your code should not get or set this information directly.</p>
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="buildStatusConfig")
    def build_status_config(self) -> Optional['outputs.BuildStatusConfigResponse']:
        """
        <p>Contains information that defines how the build project reports the build status to the source provider. This option is only used when the source provider is <code>GITHUB</code>, <code>GITHUB_ENTERPRISE</code>, or <code>BITBUCKET</code>.</p>
        """
        return pulumi.get(self, "build_status_config")

    @property
    @pulumi.getter
    def buildspec(self) -> Optional[str]:
        """
        <p>The buildspec file declaration to use for the builds in this build project.</p> <p> If this value is set, it can be either an inline buildspec definition, the path to an alternate buildspec file relative to the value of the built-in <code>CODEBUILD_SRC_DIR</code> environment variable, or the path to an S3 bucket. The bucket must be in the same Amazon Web Services Region as the build project. Specify the buildspec file using its ARN (for example, <code>arn:aws:s3:::my-codebuild-sample2/buildspec.yml</code>). If this value is not provided or is set to an empty string, the source code must contain a buildspec file in its root directory. For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html#build-spec-ref-name-storage'>Buildspec File Name and Storage Location</a>. </p>
        """
        return pulumi.get(self, "buildspec")

    @property
    @pulumi.getter(name="gitCloneDepth")
    def git_clone_depth(self) -> Optional[int]:
        """
        <p>Information about the Git clone depth for the build project.</p>
        """
        return pulumi.get(self, "git_clone_depth")

    @property
    @pulumi.getter(name="gitSubmodulesConfig")
    def git_submodules_config(self) -> Optional['outputs.GitSubmodulesConfigResponse']:
        """
        <p> Information about the Git submodules configuration for the build project. </p>
        """
        return pulumi.get(self, "git_submodules_config")

    @property
    @pulumi.getter(name="insecureSsl")
    def insecure_ssl(self) -> Optional[bool]:
        """
        <p>Enable this flag to ignore SSL warnings while connecting to the project source code.</p>
        """
        return pulumi.get(self, "insecure_ssl")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        <p>Information about the location of the source code to be built. Valid values include:</p> <ul> <li> <p>For source code settings that are specified in the source action of a pipeline in CodePipeline, <code>location</code> should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.</p> </li> <li> <p>For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the buildspec file (for example, <code>https://git-codecommit.&lt;region-ID&gt;.amazonaws.com/v1/repos/&lt;repo-name&gt;</code>).</p> </li> <li> <p>For source code in an Amazon S3 input bucket, one of the following. </p> <ul> <li> <p>The path to the ZIP file that contains the source code (for example, <code>&lt;bucket-name&gt;/&lt;path&gt;/&lt;object-name&gt;.zip</code>). </p> </li> <li> <p>The path to the folder that contains the source code (for example, <code>&lt;bucket-name&gt;/&lt;path-to-source-code&gt;/&lt;folder&gt;/</code>). </p> </li> </ul> </li> <li> <p>For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your Amazon Web Services account to your GitHub account. Use the CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with GitHub, on the GitHub <b>Authorize application</b> page, for <b>Organization access</b>, choose <b>Request access</b> next to each repository you want to allow CodeBuild to have access to, and then choose <b>Authorize application</b>. (After you have connected to your GitHub account, you do not need to finish creating the build project. You can leave the CodeBuild console.) To instruct CodeBuild to use this connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.</p> </li> <li> <p>For source code in an GitLab or self-managed GitLab repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your Amazon Web Services account to your GitLab account. Use the CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with GitLab, on the Connections <b>Authorize application</b> page, choose <b>Authorize</b>. Then on the CodeConnections <b>Create GitLab connection</b> page, choose <b>Connect to GitLab</b>. (After you have connected to your GitLab account, you do not need to finish creating the build project. You can leave the CodeBuild console.) To instruct CodeBuild to override the default connection and use this connection instead, set the <code>auth</code> object's <code>type</code> value to <code>CODECONNECTIONS</code> in the <code>source</code> object.</p> </li> <li> <p>For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the buildspec file. You must connect your Amazon Web Services account to your Bitbucket account. Use the CodeBuild console to start creating a build project. When you use the console to connect (or reconnect) with Bitbucket, on the Bitbucket <b>Confirm access to your account</b> page, choose <b>Grant access</b>. (After you have connected to your Bitbucket account, you do not need to finish creating the build project. You can leave the CodeBuild console.) To instruct CodeBuild to use this connection, in the <code>source</code> object, set the <code>auth</code> object's <code>type</code> value to <code>OAUTH</code>.</p> </li> </ul> <p> If you specify <code>CODEPIPELINE</code> for the <code>Type</code> property, don't specify this property. For all of the other types, you must specify <code>Location</code>. </p>
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="reportBuildStatus")
    def report_build_status(self) -> Optional[bool]:
        """
        <p> Set to true to report the status of a build's start and finish to your source provider. This option is valid only when your source provider is GitHub, GitHub Enterprise, GitLab, GitLab Self Managed, or Bitbucket. If this is set and you use a different source provider, an <code>invalidInputException</code> is thrown. </p> <p>To be able to report the build status to the source provider, the user associated with the source provider must have write access to the repo. If the user does not have write access, the build status cannot be updated. For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/access-tokens.html'>Source provider access</a> in the <i>CodeBuild User Guide</i>.</p> <p>The status of a build triggered by a webhook is always reported to your source provider. </p> <p>If your project's builds are triggered by a webhook, you must push a new commit to the repo for a change to this property to take effect.</p>
        """
        return pulumi.get(self, "report_build_status")

    @property
    @pulumi.getter(name="sourceIdentifier")
    def source_identifier(self) -> Optional[str]:
        """
        <p>An identifier for this project source. The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length. </p>
        """
        return pulumi.get(self, "source_identifier")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.SourceTypeEnumValueResponse']:
        """
        <p>The type of repository that contains the source code to be built. Valid values include:</p> <ul> <li> <p> <code>BITBUCKET</code>: The source code is in a Bitbucket repository.</p> </li> <li> <p> <code>CODECOMMIT</code>: The source code is in an CodeCommit repository.</p> </li> <li> <p> <code>CODEPIPELINE</code>: The source code settings are specified in the source action of a pipeline in CodePipeline.</p> </li> <li> <p> <code>GITHUB</code>: The source code is in a GitHub repository.</p> </li> <li> <p> <code>GITHUB_ENTERPRISE</code>: The source code is in a GitHub Enterprise Server repository.</p> </li> <li> <p> <code>GITLAB</code>: The source code is in a GitLab repository.</p> </li> <li> <p> <code>GITLAB_SELF_MANAGED</code>: The source code is in a self-managed GitLab repository.</p> </li> <li> <p> <code>NO_SOURCE</code>: The project does not have input source code.</p> </li> <li> <p> <code>S3</code>: The source code is in an Amazon S3 bucket.</p> </li> </ul>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ProjectSourceVersionResponse(dict):
    """
    Definition of ProjectSourceVersion
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceIdentifier":
            suggest = "source_identifier"
        elif key == "sourceVersion":
            suggest = "source_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSourceVersionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSourceVersionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSourceVersionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_identifier: Optional[str] = None,
                 source_version: Optional[str] = None):
        """
        Definition of ProjectSourceVersion
        :param str source_identifier: <p>An identifier for a source in the build project. The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length. </p>
        :param str source_version: <p>The source version for the corresponding source identifier. If specified, must be one of:</p> <ul> <li> <p>For CodeCommit: the commit ID, branch, or Git tag to use.</p> </li> <li> <p>For GitHub or GitLab: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format <code>pr/pull-request-ID</code> (for example, <code>pr/25</code>). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.</p> </li> <li> <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.</p> </li> <li> <p>For Amazon S3: the version ID of the object that represents the build input ZIP file to use.</p> </li> </ul> <p> For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html'>Source Version Sample with CodeBuild</a> in the <i>CodeBuild User Guide</i>. </p>
        """
        if source_identifier is not None:
            pulumi.set(__self__, "source_identifier", source_identifier)
        if source_version is not None:
            pulumi.set(__self__, "source_version", source_version)

    @property
    @pulumi.getter(name="sourceIdentifier")
    def source_identifier(self) -> Optional[str]:
        """
        <p>An identifier for a source in the build project. The identifier can only contain alphanumeric characters and underscores, and must be less than 128 characters in length. </p>
        """
        return pulumi.get(self, "source_identifier")

    @property
    @pulumi.getter(name="sourceVersion")
    def source_version(self) -> Optional[str]:
        """
        <p>The source version for the corresponding source identifier. If specified, must be one of:</p> <ul> <li> <p>For CodeCommit: the commit ID, branch, or Git tag to use.</p> </li> <li> <p>For GitHub or GitLab: the commit ID, pull request ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a pull request ID is specified, it must use the format <code>pr/pull-request-ID</code> (for example, <code>pr/25</code>). If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.</p> </li> <li> <p>For Bitbucket: the commit ID, branch name, or tag name that corresponds to the version of the source code you want to build. If a branch name is specified, the branch's HEAD commit ID is used. If not specified, the default branch's HEAD commit ID is used.</p> </li> <li> <p>For Amazon S3: the version ID of the object that represents the build input ZIP file to use.</p> </li> </ul> <p> For more information, see <a href='https://docs.aws.amazon.com/codebuild/latest/userguide/sample-source-version.html'>Source Version Sample with CodeBuild</a> in the <i>CodeBuild User Guide</i>. </p>
        """
        return pulumi.get(self, "source_version")


@pulumi.output_type
class ProjectVisibilityTypeEnumValueResponse(dict):
    """
    Definition of ProjectVisibilityTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ProjectVisibilityTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProjectionResponse(dict):
    """
    Definition of Projection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nonKeyAttributes":
            suggest = "non_key_attributes"
        elif key == "projectionType":
            suggest = "projection_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 non_key_attributes: Optional[Sequence[str]] = None,
                 projection_type: Optional[str] = None):
        """
        Definition of Projection
        :param Sequence[str] non_key_attributes: Represents the non-key attribute names which will be projected into the index. For local secondary indexes, the total count of ``NonKeyAttributes`` summed across all of the local secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
        :param str projection_type: The set of attributes that are projected into the index:  +   ``KEYS_ONLY`` - Only the index and primary keys are projected into the index.  +   ``INCLUDE`` - In addition to the attributes described in ``KEYS_ONLY``, the secondary index will include other non-key attributes that you specify.  +   ``ALL`` - All of the table attributes are projected into the index.   When using the DynamoDB console, ``ALL`` is selected by default.
        """
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        if projection_type is not None:
            pulumi.set(__self__, "projection_type", projection_type)

    @property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[Sequence[str]]:
        """
        Represents the non-key attribute names which will be projected into the index. For local secondary indexes, the total count of ``NonKeyAttributes`` summed across all of the local secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
        """
        return pulumi.get(self, "non_key_attributes")

    @property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> Optional[str]:
        """
        The set of attributes that are projected into the index:  +   ``KEYS_ONLY`` - Only the index and primary keys are projected into the index.  +   ``INCLUDE`` - In addition to the attributes described in ``KEYS_ONLY``, the secondary index will include other non-key attributes that you specify.  +   ``ALL`` - All of the table attributes are projected into the index.   When using the DynamoDB console, ``ALL`` is selected by default.
        """
        return pulumi.get(self, "projection_type")


@pulumi.output_type
class PropertyValueTypeEnumValueResponse(dict):
    """
    Definition of PropertyValueTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of PropertyValueTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProposedMultiRegionAccessPointPolicyResponse(dict):
    """
    Definition of ProposedMultiRegionAccessPointPolicy
    """
    def __init__(__self__, *,
                 policy: Optional[str] = None):
        """
        Definition of ProposedMultiRegionAccessPointPolicy
        :param str policy: <p>The details of the proposed policy.</p>
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        <p>The details of the proposed policy.</p>
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class ProviderResponse(dict):
    """
    Definition of Provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyArn":
            suggest = "key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProviderResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProviderResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProviderResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_arn: Optional[str] = None):
        """
        Definition of Provider
        :param str key_arn: <p>Amazon Resource Name (ARN) or alias of the KMS key. The KMS key must be symmetric and created in the same Amazon Web Services Region as the cluster. If the KMS key was created in a different account, the <a href='https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts.html'>IAM principal</a> must have access to the KMS key. For more information, see <a href='https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-modifying-external-accounts.html'>Allowing users in other accounts to use a KMS key</a> in the <i>Key Management Service Developer Guide</i>.</p>
        """
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[str]:
        """
        <p>Amazon Resource Name (ARN) or alias of the KMS key. The KMS key must be symmetric and created in the same Amazon Web Services Region as the cluster. If the KMS key was created in a different account, the <a href='https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts.html'>IAM principal</a> must have access to the KMS key. For more information, see <a href='https://docs.aws.amazon.com/kms/latest/developerguide/key-policy-modifying-external-accounts.html'>Allowing users in other accounts to use a KMS key</a> in the <i>Key Management Service Developer Guide</i>.</p>
        """
        return pulumi.get(self, "key_arn")


@pulumi.output_type
class ProvisionedThroughputResponse(dict):
    """
    Definition of ProvisionedThroughput
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readCapacityUnits":
            suggest = "read_capacity_units"
        elif key == "writeCapacityUnits":
            suggest = "write_capacity_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisionedThroughputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisionedThroughputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisionedThroughputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_capacity_units: Optional[int] = None,
                 write_capacity_units: Optional[int] = None):
        """
        Definition of ProvisionedThroughput
        :param int read_capacity_units: The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*. If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        :param int write_capacity_units: The maximum number of writes consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*. If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        """
        if read_capacity_units is not None:
            pulumi.set(__self__, "read_capacity_units", read_capacity_units)
        if write_capacity_units is not None:
            pulumi.set(__self__, "write_capacity_units", write_capacity_units)

    @property
    @pulumi.getter(name="readCapacityUnits")
    def read_capacity_units(self) -> Optional[int]:
        """
        The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*. If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        """
        return pulumi.get(self, "read_capacity_units")

    @property
    @pulumi.getter(name="writeCapacityUnits")
    def write_capacity_units(self) -> Optional[int]:
        """
        The maximum number of writes consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*. If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        """
        return pulumi.get(self, "write_capacity_units")


@pulumi.output_type
class ProxyConfigurationResponse(dict):
    """
    Definition of ProxyConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"
        elif key == "proxyConfigurationProperties":
            suggest = "proxy_configuration_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: Optional[str] = None,
                 proxy_configuration_properties: Optional[Sequence['outputs.KeyValuePairResponse']] = None,
                 type: Optional[str] = None):
        """
        Definition of ProxyConfiguration
        :param str container_name: The name of the container that will serve as the App Mesh proxy.
        :param Sequence['KeyValuePairResponse'] proxy_configuration_properties: The set of network configuration parameters to provide the Container Network Interface (CNI) plugin, specified as key-value pairs.  +   ``IgnoredUID`` - (Required) The user ID (UID) of the proxy container as defined by the ``user`` parameter in a container definition. This is used to ensure the proxy ignores its own traffic. If ``IgnoredGID`` is specified, this field can be empty.  +   ``IgnoredGID`` - (Required) The group ID (GID) of the proxy container as defined by the ``user`` parameter in a container definition. This is used to ensure the proxy ignores its own traffic. If ``IgnoredUID`` is specified, this field can be empty.  +   ``AppPorts`` - (Required) The list of ports that the application uses. Network traffic to these ports is forwarded to the ``ProxyIngressPort`` and ``ProxyEgressPort``.  +   ``ProxyIngressPort`` - (Required) Specifies the port that incoming traffic to the ``AppPorts`` is directed to.  +   ``ProxyEgressPort`` - (Required) Specifies the port that outgoing traffic from the ``AppPorts`` is directed to.  +   ``EgressIgnoredPorts`` - (Required) The egress traffic going to the specified ports is ignored and not redirected to the ``ProxyEgressPort``. It can be an empty list.  +   ``EgressIgnoredIPs`` - (Required) The egress traffic going to the specified IP addresses is ignored and not redirected to the ``ProxyEgressPort``. It can be an empty list.
        :param str type: The proxy type. The only supported value is ``APPMESH``.
        """
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if proxy_configuration_properties is not None:
            pulumi.set(__self__, "proxy_configuration_properties", proxy_configuration_properties)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        The name of the container that will serve as the App Mesh proxy.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="proxyConfigurationProperties")
    def proxy_configuration_properties(self) -> Optional[Sequence['outputs.KeyValuePairResponse']]:
        """
        The set of network configuration parameters to provide the Container Network Interface (CNI) plugin, specified as key-value pairs.  +   ``IgnoredUID`` - (Required) The user ID (UID) of the proxy container as defined by the ``user`` parameter in a container definition. This is used to ensure the proxy ignores its own traffic. If ``IgnoredGID`` is specified, this field can be empty.  +   ``IgnoredGID`` - (Required) The group ID (GID) of the proxy container as defined by the ``user`` parameter in a container definition. This is used to ensure the proxy ignores its own traffic. If ``IgnoredUID`` is specified, this field can be empty.  +   ``AppPorts`` - (Required) The list of ports that the application uses. Network traffic to these ports is forwarded to the ``ProxyIngressPort`` and ``ProxyEgressPort``.  +   ``ProxyIngressPort`` - (Required) Specifies the port that incoming traffic to the ``AppPorts`` is directed to.  +   ``ProxyEgressPort`` - (Required) Specifies the port that outgoing traffic from the ``AppPorts`` is directed to.  +   ``EgressIgnoredPorts`` - (Required) The egress traffic going to the specified ports is ignored and not redirected to the ``ProxyEgressPort``. It can be an empty list.  +   ``EgressIgnoredIPs`` - (Required) The egress traffic going to the specified IP addresses is ignored and not redirected to the ``ProxyEgressPort``. It can be an empty list.
        """
        return pulumi.get(self, "proxy_configuration_properties")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The proxy type. The only supported value is ``APPMESH``.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PublicAccessBlockConfigurationResponse(dict):
    """
    Definition of PublicAccessBlockConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockPublicAcls":
            suggest = "block_public_acls"
        elif key == "blockPublicPolicy":
            suggest = "block_public_policy"
        elif key == "ignorePublicAcls":
            suggest = "ignore_public_acls"
        elif key == "restrictPublicBuckets":
            suggest = "restrict_public_buckets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PublicAccessBlockConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PublicAccessBlockConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PublicAccessBlockConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_public_acls: Optional[bool] = None,
                 block_public_policy: Optional[bool] = None,
                 ignore_public_acls: Optional[bool] = None,
                 restrict_public_buckets: Optional[bool] = None):
        """
        Definition of PublicAccessBlockConfiguration
        :param bool block_public_acls: Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket. Setting this element to ``TRUE`` causes the following behavior:  +  PUT Bucket ACL and PUT Object ACL calls fail if the specified ACL is public.  +  PUT Object calls fail if the request includes a public ACL.  +  PUT Bucket calls fail if the request includes a public ACL.   Enabling this setting doesn't affect existing policies or ACLs.
        :param bool block_public_policy: Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to ``TRUE`` causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.  Enabling this setting doesn't affect existing bucket policies.
        :param bool ignore_public_acls: Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to ``TRUE`` causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        :param bool restrict_public_buckets: Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to ``TRUE`` restricts access to this bucket to only AWS-service principals and authorized users within this account if the bucket has a public policy. Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        """
        if block_public_acls is not None:
            pulumi.set(__self__, "block_public_acls", block_public_acls)
        if block_public_policy is not None:
            pulumi.set(__self__, "block_public_policy", block_public_policy)
        if ignore_public_acls is not None:
            pulumi.set(__self__, "ignore_public_acls", ignore_public_acls)
        if restrict_public_buckets is not None:
            pulumi.set(__self__, "restrict_public_buckets", restrict_public_buckets)

    @property
    @pulumi.getter(name="blockPublicAcls")
    def block_public_acls(self) -> Optional[bool]:
        """
        Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket. Setting this element to ``TRUE`` causes the following behavior:  +  PUT Bucket ACL and PUT Object ACL calls fail if the specified ACL is public.  +  PUT Object calls fail if the request includes a public ACL.  +  PUT Bucket calls fail if the request includes a public ACL.   Enabling this setting doesn't affect existing policies or ACLs.
        """
        return pulumi.get(self, "block_public_acls")

    @property
    @pulumi.getter(name="blockPublicPolicy")
    def block_public_policy(self) -> Optional[bool]:
        """
        Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to ``TRUE`` causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.  Enabling this setting doesn't affect existing bucket policies.
        """
        return pulumi.get(self, "block_public_policy")

    @property
    @pulumi.getter(name="ignorePublicAcls")
    def ignore_public_acls(self) -> Optional[bool]:
        """
        Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to ``TRUE`` causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        """
        return pulumi.get(self, "ignore_public_acls")

    @property
    @pulumi.getter(name="restrictPublicBuckets")
    def restrict_public_buckets(self) -> Optional[bool]:
        """
        Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to ``TRUE`` restricts access to this bucket to only AWS-service principals and authorized users within this account if the bucket has a public policy. Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        """
        return pulumi.get(self, "restrict_public_buckets")


@pulumi.output_type
class PublishMetricActionResponse(dict):
    """
    Definition of PublishMetricAction
    """
    def __init__(__self__, *,
                 dimensions: Optional[Sequence['outputs.DimensionResponse']] = None):
        """
        Definition of PublishMetricAction
        :param Sequence['DimensionResponse'] dimensions: Property dimensions
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.DimensionResponse']]:
        """
        Property dimensions
        """
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class QueryLoggingConfigResponse(dict):
    """
    Definition of QueryLoggingConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogsLogGroupArn":
            suggest = "cloud_watch_logs_log_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryLoggingConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryLoggingConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryLoggingConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs_log_group_arn: Optional[str] = None):
        """
        Definition of QueryLoggingConfig
        :param str cloud_watch_logs_log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
        """
        if cloud_watch_logs_log_group_arn is not None:
            pulumi.set(__self__, "cloud_watch_logs_log_group_arn", cloud_watch_logs_log_group_arn)

    @property
    @pulumi.getter(name="cloudWatchLogsLogGroupArn")
    def cloud_watch_logs_log_group_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
        """
        return pulumi.get(self, "cloud_watch_logs_log_group_arn")


@pulumi.output_type
class QueueConfigurationResponse(dict):
    """
    Definition of QueueConfiguration
    """
    def __init__(__self__, *,
                 event: Optional[str] = None,
                 filter: Optional['outputs.NotificationFilterResponse'] = None,
                 queue: Optional[str] = None):
        """
        Definition of QueueConfiguration
        :param str event: The Amazon S3 bucket event about which you want to publish messages to Amazon SQS. For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide*.
        :param 'NotificationFilterResponse' filter: The filtering rules that determine which objects trigger notifications. For example, you can create a filter so that Amazon S3 sends notifications only when image files with a ``.jpg`` extension are added to the bucket. For more information, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/user-guide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*. Specifies object key name filtering rules. For information about key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*.
        :param str queue: The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type. FIFO queues are not allowed when enabling an SQS queue as the event notification destination.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if queue is not None:
            pulumi.set(__self__, "queue", queue)

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        The Amazon S3 bucket event about which you want to publish messages to Amazon SQS. For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.NotificationFilterResponse']:
        """
        The filtering rules that determine which objects trigger notifications. For example, you can create a filter so that Amazon S3 sends notifications only when image files with a ``.jpg`` extension are added to the bucket. For more information, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/user-guide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*. Specifies object key name filtering rules. For information about key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def queue(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type. FIFO queues are not allowed when enabling an SQS queue as the event notification destination.
        """
        return pulumi.get(self, "queue")


@pulumi.output_type
class RRTypeEnumValueResponse(dict):
    """
    Definition of RRTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of RRTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RdsDBClusterPropertiesResponse(dict):
    """
    Definition of RdsDBCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsDBClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsDBClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsDBClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRdsDBClusterPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of RdsDBCluster
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRdsDBClusterPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRdsDBClusterPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class RdsDBInstancePropertiesResponse(dict):
    """
    Definition of RdsDBInstance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsDBInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsDBInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsDBInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRdsDBInstancePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of RdsDBInstance
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRdsDBInstancePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRdsDBInstancePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class RdsDBSnapshotAttributesResultPropertiesResponse(dict):
    """
    Definition of RdsDBSnapshotAttributesResult
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsDBSnapshotAttributesResultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsDBSnapshotAttributesResultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsDBSnapshotAttributesResultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRdsDBSnapshotAttributesResultPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of RdsDBSnapshotAttributesResult
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRdsDBSnapshotAttributesResultPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRdsDBSnapshotAttributesResultPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class RdsDBSnapshotPropertiesResponse(dict):
    """
    Definition of RdsDBSnapshot
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsDBSnapshotPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsDBSnapshotPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsDBSnapshotPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRdsDBSnapshotPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of RdsDBSnapshot
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRdsDBSnapshotPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRdsDBSnapshotPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class RdsDbClusterEndpointResponse(dict):
    """
    Definition of Endpoint
    """
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 port: Optional[str] = None):
        """
        Definition of Endpoint
        :param str address: The connection endpoint for the DB cluster.
        :param str port: The port number that will accept connections on this DB cluster.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The connection endpoint for the DB cluster.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        The port number that will accept connections on this DB cluster.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RdsDbInstanceEndpointResponse(dict):
    """
    Definition of Endpoint
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostedZoneId":
            suggest = "hosted_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsDbInstanceEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsDbInstanceEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsDbInstanceEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 hosted_zone_id: Optional[str] = None,
                 port: Optional[str] = None):
        """
        Definition of Endpoint
        :param str address: Specifies the DNS address of the DB instance.
        :param str hosted_zone_id: Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        :param str port: Specifies the port that the database engine is listening on.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if hosted_zone_id is not None:
            pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Specifies the DNS address of the DB instance.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[str]:
        """
        Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        """
        return pulumi.get(self, "hosted_zone_id")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Specifies the port that the database engine is listening on.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RdsEventSubscriptionPropertiesResponse(dict):
    """
    Definition of RdsEventSubscription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsEventSubscriptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsEventSubscriptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsEventSubscriptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRdsEventSubscriptionPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of RdsEventSubscription
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRdsEventSubscriptionPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRdsEventSubscriptionPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class RdsExportTaskPropertiesResponse(dict):
    """
    Definition of RdsExportTask
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsExportTaskPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsExportTaskPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsExportTaskPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRdsExportTaskPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of RdsExportTask
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRdsExportTaskPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRdsExportTaskPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ReadEndpointResponse(dict):
    """
    Definition of ReadEndpoint
    """
    def __init__(__self__, *,
                 address: Optional[str] = None):
        """
        Definition of ReadEndpoint
        :param str address: The reader endpoint for the DB cluster.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The reader endpoint for the DB cluster.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class RecorderStatusEnumValueResponse(dict):
    """
    Definition of RecorderStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of RecorderStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RecordingFrequencyEnumValueResponse(dict):
    """
    Definition of RecordingFrequencyEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of RecordingFrequencyEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RecordingGroupResponse(dict):
    """
    Definition of RecordingGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allSupported":
            suggest = "all_supported"
        elif key == "exclusionByResourceTypes":
            suggest = "exclusion_by_resource_types"
        elif key == "includeGlobalResourceTypes":
            suggest = "include_global_resource_types"
        elif key == "recordingStrategy":
            suggest = "recording_strategy"
        elif key == "resourceTypes":
            suggest = "resource_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 all_supported: Optional[bool] = None,
                 exclusion_by_resource_types: Optional['outputs.ExclusionByResourceTypesResponse'] = None,
                 include_global_resource_types: Optional[bool] = None,
                 recording_strategy: Optional['outputs.RecordingStrategyResponse'] = None,
                 resource_types: Optional[Sequence[str]] = None):
        """
        Definition of RecordingGroup
        :param bool all_supported: <p>Specifies whether Config records configuration changes for all supported resource types, excluding the global IAM resource types.</p> <p>If you set this field to <code>true</code>, when Config adds support for a new resource type, Config starts recording resources of that type automatically.</p> <p>If you set this field to <code>true</code>, you cannot enumerate specific resource types to record in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>, or to exclude in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> <note> <p> <b>Region availability</b> </p> <p>Check <a href='https://docs.aws.amazon.com/config/latest/developerguide/what-is-resource-config-coverage.html'>Resource Coverage by Region Availability</a> to see if a resource type is supported in the Amazon Web Services Region where you set up Config.</p> </note>
        :param 'ExclusionByResourceTypesResponse' exclusion_by_resource_types: <p>An object that specifies how Config excludes resource types from being recorded by the configuration recorder.</p> <note> <p> <b>Required fields</b> </p> <p>To use this option, you must set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>EXCLUSION_BY_RESOURCE_TYPES</code>.</p> </note>
        :param bool include_global_resource_types: <p>This option is a bundle which only applies to the global IAM resource types: IAM users, groups, roles, and customer managed policies. These global IAM resource types can only be recorded by Config in Regions where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:</p> <ul> <li> <p>Asia Pacific (Hyderabad)</p> </li> <li> <p>Asia Pacific (Melbourne)</p> </li> <li> <p>Canada West (Calgary)</p> </li> <li> <p>Europe (Spain)</p> </li> <li> <p>Europe (Zurich)</p> </li> <li> <p>Israel (Tel Aviv)</p> </li> <li> <p>Middle East (UAE)</p> </li> </ul> <important> <p> <b>Aurora global clusters are recorded in all enabled Regions</b> </p> <p>The <code>AWS::RDS::GlobalCluster</code> resource type will be recorded in all supported Config Regions where the configuration recorder is enabled, even if <code>includeGlobalResourceTypes</code> is set<code>false</code>. The <code>includeGlobalResourceTypes</code> option is a bundle which only applies to IAM users, groups, roles, and customer managed policies. </p> <p>If you do not want to record <code>AWS::RDS::GlobalCluster</code> in all enabled Regions, use one of the following recording strategies:</p> <ol> <li> <p> <b>Record all current and future resource types with exclusions</b> (<code>EXCLUSION_BY_RESOURCE_TYPES</code>), or</p> </li> <li> <p> <b>Record specific resource types</b> (<code>INCLUSION_BY_RESOURCE_TYPES</code>).</p> </li> </ol> <p>For more information, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/select-resources.html#select-resources-all'>Selecting Which Resources are Recorded</a> in the <i>Config developer guide</i>.</p> </important> <important> <p> <b>includeGlobalResourceTypes and the exclusion recording strategy</b> </p> <p>The <code>includeGlobalResourceTypes</code> field has no impact on the <code>EXCLUSION_BY_RESOURCE_TYPES</code> recording strategy. This means that the global IAM resource types (IAM users, groups, roles, and customer managed policies) will not be automatically added as exclusions for <code>exclusionByResourceTypes</code> when <code>includeGlobalResourceTypes</code> is set to <code>false</code>.</p> <p>The <code>includeGlobalResourceTypes</code> field should only be used to modify the <code>AllSupported</code> field, as the default for the <code>AllSupported</code> field is to record configuration changes for all supported resource types excluding the global IAM resource types. To include the global IAM resource types when <code>AllSupported</code> is set to <code>true</code>, make sure to set <code>includeGlobalResourceTypes</code> to <code>true</code>.</p> <p>To exclude the global IAM resource types for the <code>EXCLUSION_BY_RESOURCE_TYPES</code> recording strategy, you need to manually add them to the <code>resourceTypes</code> field of <code>exclusionByResourceTypes</code>.</p> </important> <note> <p> <b>Required and optional fields</b> </p> <p>Before you set this field to <code>true</code>, set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>. Optionally, you can set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>ALL_SUPPORTED_RESOURCE_TYPES</code>.</p> </note> <note> <p> <b>Overriding fields</b> </p> <p>If you set this field to <code>false</code> but list global IAM resource types in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>, Config will still record configuration changes for those specified resource types <i>regardless</i> of if you set the <code>includeGlobalResourceTypes</code> field to false.</p> <p>If you do not want to record configuration changes to the global IAM resource types (IAM users, groups, roles, and customer managed policies), make sure to not list them in the <code>resourceTypes</code> field in addition to setting the <code>includeGlobalResourceTypes</code> field to false.</p> </note>
        :param 'RecordingStrategyResponse' recording_strategy: <p>An object that specifies the recording strategy for the configuration recorder.</p> <ul> <li> <p>If you set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>ALL_SUPPORTED_RESOURCE_TYPES</code>, Config records configuration changes for all supported resource types, excluding the global IAM resource types. You also must set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>. When Config adds support for a new resource type, Config automatically starts recording resources of that type.</p> </li> <li> <p>If you set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>INCLUSION_BY_RESOURCE_TYPES</code>, Config records configuration changes for only the resource types you specify in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>.</p> </li> <li> <p>If you set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>EXCLUSION_BY_RESOURCE_TYPES</code>, Config records configuration changes for all supported resource types except the resource types that you specify to exclude from being recorded in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> </li> </ul> <note> <p> <b>Required and optional fields</b> </p> <p>The <code>recordingStrategy</code> field is optional when you set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>.</p> <p>The <code>recordingStrategy</code> field is optional when you list resource types in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>.</p> <p>The <code>recordingStrategy</code> field is required if you list resource types to exclude from recording in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> </note> <note> <p> <b>Overriding fields</b> </p> <p>If you choose <code>EXCLUSION_BY_RESOURCE_TYPES</code> for the recording strategy, the <code>exclusionByResourceTypes</code> field will override other properties in the request.</p> <p>For example, even if you set <code>includeGlobalResourceTypes</code> to false, global IAM resource types will still be automatically recorded in this option unless those resource types are specifically listed as exclusions in the <code>resourceTypes</code> field of <code>exclusionByResourceTypes</code>.</p> </note> <note> <p> <b>Global resources types and the resource exclusion recording strategy</b> </p> <p>By default, if you choose the <code>EXCLUSION_BY_RESOURCE_TYPES</code> recording strategy, when Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types, Config starts recording resources of that type automatically.</p> <p>Unless specifically listed as exclusions, <code>AWS::RDS::GlobalCluster</code> will be recorded automatically in all supported Config Regions were the configuration recorder is enabled.</p> <p>IAM users, groups, roles, and customer managed policies will be recorded in the Region where you set up the configuration recorder if that is a Region where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:</p> <ul> <li> <p>Asia Pacific (Hyderabad)</p> </li> <li> <p>Asia Pacific (Melbourne)</p> </li> <li> <p>Canada West (Calgary)</p> </li> <li> <p>Europe (Spain)</p> </li> <li> <p>Europe (Zurich)</p> </li> <li> <p>Israel (Tel Aviv)</p> </li> <li> <p>Middle East (UAE)</p> </li> </ul> </note>
        :param Sequence[str] resource_types: <p>A comma-separated list that specifies which resource types Config records.</p> <p>For a list of valid <code>resourceTypes</code> values, see the <b>Resource Type Value</b> column in <a href='https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources'>Supported Amazon Web Services resource Types</a> in the <i>Config developer guide</i>.</p> <note> <p> <b>Required and optional fields</b> </p> <p>Optionally, you can set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>INCLUSION_BY_RESOURCE_TYPES</code>.</p> <p>To record all configuration changes, set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>, and either omit this field or don't specify any resource types in this field. If you set the <code>allSupported</code> field to <code>false</code> and specify values for <code>resourceTypes</code>, when Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group.</p> </note> <note> <p> <b>Region availability</b> </p> <p>Before specifying a resource type for Config to track, check <a href='https://docs.aws.amazon.com/config/latest/developerguide/what-is-resource-config-coverage.html'>Resource Coverage by Region Availability</a> to see if the resource type is supported in the Amazon Web Services Region where you set up Config. If a resource type is supported by Config in at least one Region, you can enable the recording of that resource type in all Regions supported by Config, even if the specified resource type is not supported in the Amazon Web Services Region where you set up Config.</p> </note>
        """
        if all_supported is not None:
            pulumi.set(__self__, "all_supported", all_supported)
        if exclusion_by_resource_types is not None:
            pulumi.set(__self__, "exclusion_by_resource_types", exclusion_by_resource_types)
        if include_global_resource_types is not None:
            pulumi.set(__self__, "include_global_resource_types", include_global_resource_types)
        if recording_strategy is not None:
            pulumi.set(__self__, "recording_strategy", recording_strategy)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)

    @property
    @pulumi.getter(name="allSupported")
    def all_supported(self) -> Optional[bool]:
        """
        <p>Specifies whether Config records configuration changes for all supported resource types, excluding the global IAM resource types.</p> <p>If you set this field to <code>true</code>, when Config adds support for a new resource type, Config starts recording resources of that type automatically.</p> <p>If you set this field to <code>true</code>, you cannot enumerate specific resource types to record in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>, or to exclude in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> <note> <p> <b>Region availability</b> </p> <p>Check <a href='https://docs.aws.amazon.com/config/latest/developerguide/what-is-resource-config-coverage.html'>Resource Coverage by Region Availability</a> to see if a resource type is supported in the Amazon Web Services Region where you set up Config.</p> </note>
        """
        return pulumi.get(self, "all_supported")

    @property
    @pulumi.getter(name="exclusionByResourceTypes")
    def exclusion_by_resource_types(self) -> Optional['outputs.ExclusionByResourceTypesResponse']:
        """
        <p>An object that specifies how Config excludes resource types from being recorded by the configuration recorder.</p> <note> <p> <b>Required fields</b> </p> <p>To use this option, you must set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>EXCLUSION_BY_RESOURCE_TYPES</code>.</p> </note>
        """
        return pulumi.get(self, "exclusion_by_resource_types")

    @property
    @pulumi.getter(name="includeGlobalResourceTypes")
    def include_global_resource_types(self) -> Optional[bool]:
        """
        <p>This option is a bundle which only applies to the global IAM resource types: IAM users, groups, roles, and customer managed policies. These global IAM resource types can only be recorded by Config in Regions where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:</p> <ul> <li> <p>Asia Pacific (Hyderabad)</p> </li> <li> <p>Asia Pacific (Melbourne)</p> </li> <li> <p>Canada West (Calgary)</p> </li> <li> <p>Europe (Spain)</p> </li> <li> <p>Europe (Zurich)</p> </li> <li> <p>Israel (Tel Aviv)</p> </li> <li> <p>Middle East (UAE)</p> </li> </ul> <important> <p> <b>Aurora global clusters are recorded in all enabled Regions</b> </p> <p>The <code>AWS::RDS::GlobalCluster</code> resource type will be recorded in all supported Config Regions where the configuration recorder is enabled, even if <code>includeGlobalResourceTypes</code> is set<code>false</code>. The <code>includeGlobalResourceTypes</code> option is a bundle which only applies to IAM users, groups, roles, and customer managed policies. </p> <p>If you do not want to record <code>AWS::RDS::GlobalCluster</code> in all enabled Regions, use one of the following recording strategies:</p> <ol> <li> <p> <b>Record all current and future resource types with exclusions</b> (<code>EXCLUSION_BY_RESOURCE_TYPES</code>), or</p> </li> <li> <p> <b>Record specific resource types</b> (<code>INCLUSION_BY_RESOURCE_TYPES</code>).</p> </li> </ol> <p>For more information, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/select-resources.html#select-resources-all'>Selecting Which Resources are Recorded</a> in the <i>Config developer guide</i>.</p> </important> <important> <p> <b>includeGlobalResourceTypes and the exclusion recording strategy</b> </p> <p>The <code>includeGlobalResourceTypes</code> field has no impact on the <code>EXCLUSION_BY_RESOURCE_TYPES</code> recording strategy. This means that the global IAM resource types (IAM users, groups, roles, and customer managed policies) will not be automatically added as exclusions for <code>exclusionByResourceTypes</code> when <code>includeGlobalResourceTypes</code> is set to <code>false</code>.</p> <p>The <code>includeGlobalResourceTypes</code> field should only be used to modify the <code>AllSupported</code> field, as the default for the <code>AllSupported</code> field is to record configuration changes for all supported resource types excluding the global IAM resource types. To include the global IAM resource types when <code>AllSupported</code> is set to <code>true</code>, make sure to set <code>includeGlobalResourceTypes</code> to <code>true</code>.</p> <p>To exclude the global IAM resource types for the <code>EXCLUSION_BY_RESOURCE_TYPES</code> recording strategy, you need to manually add them to the <code>resourceTypes</code> field of <code>exclusionByResourceTypes</code>.</p> </important> <note> <p> <b>Required and optional fields</b> </p> <p>Before you set this field to <code>true</code>, set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>. Optionally, you can set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>ALL_SUPPORTED_RESOURCE_TYPES</code>.</p> </note> <note> <p> <b>Overriding fields</b> </p> <p>If you set this field to <code>false</code> but list global IAM resource types in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>, Config will still record configuration changes for those specified resource types <i>regardless</i> of if you set the <code>includeGlobalResourceTypes</code> field to false.</p> <p>If you do not want to record configuration changes to the global IAM resource types (IAM users, groups, roles, and customer managed policies), make sure to not list them in the <code>resourceTypes</code> field in addition to setting the <code>includeGlobalResourceTypes</code> field to false.</p> </note>
        """
        return pulumi.get(self, "include_global_resource_types")

    @property
    @pulumi.getter(name="recordingStrategy")
    def recording_strategy(self) -> Optional['outputs.RecordingStrategyResponse']:
        """
        <p>An object that specifies the recording strategy for the configuration recorder.</p> <ul> <li> <p>If you set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>ALL_SUPPORTED_RESOURCE_TYPES</code>, Config records configuration changes for all supported resource types, excluding the global IAM resource types. You also must set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>. When Config adds support for a new resource type, Config automatically starts recording resources of that type.</p> </li> <li> <p>If you set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>INCLUSION_BY_RESOURCE_TYPES</code>, Config records configuration changes for only the resource types you specify in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>.</p> </li> <li> <p>If you set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>EXCLUSION_BY_RESOURCE_TYPES</code>, Config records configuration changes for all supported resource types except the resource types that you specify to exclude from being recorded in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> </li> </ul> <note> <p> <b>Required and optional fields</b> </p> <p>The <code>recordingStrategy</code> field is optional when you set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>.</p> <p>The <code>recordingStrategy</code> field is optional when you list resource types in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>.</p> <p>The <code>recordingStrategy</code> field is required if you list resource types to exclude from recording in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> </note> <note> <p> <b>Overriding fields</b> </p> <p>If you choose <code>EXCLUSION_BY_RESOURCE_TYPES</code> for the recording strategy, the <code>exclusionByResourceTypes</code> field will override other properties in the request.</p> <p>For example, even if you set <code>includeGlobalResourceTypes</code> to false, global IAM resource types will still be automatically recorded in this option unless those resource types are specifically listed as exclusions in the <code>resourceTypes</code> field of <code>exclusionByResourceTypes</code>.</p> </note> <note> <p> <b>Global resources types and the resource exclusion recording strategy</b> </p> <p>By default, if you choose the <code>EXCLUSION_BY_RESOURCE_TYPES</code> recording strategy, when Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types, Config starts recording resources of that type automatically.</p> <p>Unless specifically listed as exclusions, <code>AWS::RDS::GlobalCluster</code> will be recorded automatically in all supported Config Regions were the configuration recorder is enabled.</p> <p>IAM users, groups, roles, and customer managed policies will be recorded in the Region where you set up the configuration recorder if that is a Region where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:</p> <ul> <li> <p>Asia Pacific (Hyderabad)</p> </li> <li> <p>Asia Pacific (Melbourne)</p> </li> <li> <p>Canada West (Calgary)</p> </li> <li> <p>Europe (Spain)</p> </li> <li> <p>Europe (Zurich)</p> </li> <li> <p>Israel (Tel Aviv)</p> </li> <li> <p>Middle East (UAE)</p> </li> </ul> </note>
        """
        return pulumi.get(self, "recording_strategy")

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence[str]]:
        """
        <p>A comma-separated list that specifies which resource types Config records.</p> <p>For a list of valid <code>resourceTypes</code> values, see the <b>Resource Type Value</b> column in <a href='https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources'>Supported Amazon Web Services resource Types</a> in the <i>Config developer guide</i>.</p> <note> <p> <b>Required and optional fields</b> </p> <p>Optionally, you can set the <code>useOnly</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html'>RecordingStrategy</a> to <code>INCLUSION_BY_RESOURCE_TYPES</code>.</p> <p>To record all configuration changes, set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>, and either omit this field or don't specify any resource types in this field. If you set the <code>allSupported</code> field to <code>false</code> and specify values for <code>resourceTypes</code>, when Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group.</p> </note> <note> <p> <b>Region availability</b> </p> <p>Before specifying a resource type for Config to track, check <a href='https://docs.aws.amazon.com/config/latest/developerguide/what-is-resource-config-coverage.html'>Resource Coverage by Region Availability</a> to see if the resource type is supported in the Amazon Web Services Region where you set up Config. If a resource type is supported by Config in at least one Region, you can enable the recording of that resource type in all Regions supported by Config, even if the specified resource type is not supported in the Amazon Web Services Region where you set up Config.</p> </note>
        """
        return pulumi.get(self, "resource_types")


@pulumi.output_type
class RecordingModeOverrideResponse(dict):
    """
    Definition of RecordingModeOverride
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordingFrequency":
            suggest = "recording_frequency"
        elif key == "resourceTypes":
            suggest = "resource_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingModeOverrideResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingModeOverrideResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingModeOverrideResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 recording_frequency: Optional['outputs.RecordingFrequencyEnumValueResponse'] = None,
                 resource_types: Optional[Sequence[str]] = None):
        """
        Definition of RecordingModeOverride
        :param str description: <p>A description that you provide for the override.</p>
        :param 'RecordingFrequencyEnumValueResponse' recording_frequency: <p>The recording frequency that will be applied to all the resource types specified in the override.</p> <ul> <li> <p>Continuous recording allows you to record configuration changes continuously whenever a change occurs.</p> </li> <li> <p>Daily recording allows you to receive a configuration item (CI) representing the most recent state of your resources over the last 24-hour period, only if its different from the previous CI recorded. </p> </li> </ul> <note> <p>Firewall Manager depends on continuous recording to monitor your resources. If you are using Firewall Manager, it is recommended that you set the recording frequency to Continuous.</p> </note>
        :param Sequence[str] resource_types: <p>A comma-separated list that specifies which resource types Config includes in the override.</p> <important> <p>Daily recording is not supported for the following resource types:</p> <ul> <li> <p> <code>AWS::Config::ResourceCompliance</code> </p> </li> <li> <p> <code>AWS::Config::ConformancePackCompliance</code> </p> </li> <li> <p> <code>AWS::Config::ConfigurationRecorder</code> </p> </li> </ul> </important>
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if recording_frequency is not None:
            pulumi.set(__self__, "recording_frequency", recording_frequency)
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description that you provide for the override.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="recordingFrequency")
    def recording_frequency(self) -> Optional['outputs.RecordingFrequencyEnumValueResponse']:
        """
        <p>The recording frequency that will be applied to all the resource types specified in the override.</p> <ul> <li> <p>Continuous recording allows you to record configuration changes continuously whenever a change occurs.</p> </li> <li> <p>Daily recording allows you to receive a configuration item (CI) representing the most recent state of your resources over the last 24-hour period, only if its different from the previous CI recorded. </p> </li> </ul> <note> <p>Firewall Manager depends on continuous recording to monitor your resources. If you are using Firewall Manager, it is recommended that you set the recording frequency to Continuous.</p> </note>
        """
        return pulumi.get(self, "recording_frequency")

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence[str]]:
        """
        <p>A comma-separated list that specifies which resource types Config includes in the override.</p> <important> <p>Daily recording is not supported for the following resource types:</p> <ul> <li> <p> <code>AWS::Config::ResourceCompliance</code> </p> </li> <li> <p> <code>AWS::Config::ConformancePackCompliance</code> </p> </li> <li> <p> <code>AWS::Config::ConfigurationRecorder</code> </p> </li> </ul> </important>
        """
        return pulumi.get(self, "resource_types")


@pulumi.output_type
class RecordingModeResponse(dict):
    """
    Definition of RecordingMode
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordingFrequency":
            suggest = "recording_frequency"
        elif key == "recordingModeOverrides":
            suggest = "recording_mode_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingModeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingModeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingModeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recording_frequency: Optional['outputs.RecordingFrequencyEnumValueResponse'] = None,
                 recording_mode_overrides: Optional[Sequence['outputs.RecordingModeOverrideResponse']] = None):
        """
        Definition of RecordingMode
        :param 'RecordingFrequencyEnumValueResponse' recording_frequency: <p>The default recording frequency that Config uses to record configuration changes.</p> <important> <p>Daily recording is not supported for the following resource types:</p> <ul> <li> <p> <code>AWS::Config::ResourceCompliance</code> </p> </li> <li> <p> <code>AWS::Config::ConformancePackCompliance</code> </p> </li> <li> <p> <code>AWS::Config::ConfigurationRecorder</code> </p> </li> </ul> <p>For the <b>allSupported</b> (<code>ALL_SUPPORTED_RESOURCE_TYPES</code>) recording strategy, these resource types will be set to Continuous recording.</p> </important>
        :param Sequence['RecordingModeOverrideResponse'] recording_mode_overrides: <p>An array of <code>recordingModeOverride</code> objects for you to specify your overrides for the recording mode. The <code>recordingModeOverride</code> object in the <code>recordingModeOverrides</code> array consists of three fields: a <code>description</code>, the new <code>recordingFrequency</code>, and an array of <code>resourceTypes</code> to override.</p>
        """
        if recording_frequency is not None:
            pulumi.set(__self__, "recording_frequency", recording_frequency)
        if recording_mode_overrides is not None:
            pulumi.set(__self__, "recording_mode_overrides", recording_mode_overrides)

    @property
    @pulumi.getter(name="recordingFrequency")
    def recording_frequency(self) -> Optional['outputs.RecordingFrequencyEnumValueResponse']:
        """
        <p>The default recording frequency that Config uses to record configuration changes.</p> <important> <p>Daily recording is not supported for the following resource types:</p> <ul> <li> <p> <code>AWS::Config::ResourceCompliance</code> </p> </li> <li> <p> <code>AWS::Config::ConformancePackCompliance</code> </p> </li> <li> <p> <code>AWS::Config::ConfigurationRecorder</code> </p> </li> </ul> <p>For the <b>allSupported</b> (<code>ALL_SUPPORTED_RESOURCE_TYPES</code>) recording strategy, these resource types will be set to Continuous recording.</p> </important>
        """
        return pulumi.get(self, "recording_frequency")

    @property
    @pulumi.getter(name="recordingModeOverrides")
    def recording_mode_overrides(self) -> Optional[Sequence['outputs.RecordingModeOverrideResponse']]:
        """
        <p>An array of <code>recordingModeOverride</code> objects for you to specify your overrides for the recording mode. The <code>recordingModeOverride</code> object in the <code>recordingModeOverrides</code> array consists of three fields: a <code>description</code>, the new <code>recordingFrequency</code>, and an array of <code>resourceTypes</code> to override.</p>
        """
        return pulumi.get(self, "recording_mode_overrides")


@pulumi.output_type
class RecordingStrategyResponse(dict):
    """
    Definition of RecordingStrategy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useOnly":
            suggest = "use_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingStrategyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingStrategyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingStrategyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 use_only: Optional['outputs.RecordingStrategyTypeEnumValueResponse'] = None):
        """
        Definition of RecordingStrategy
        :param 'RecordingStrategyTypeEnumValueResponse' use_only: <p>The recording strategy for the configuration recorder.</p> <ul> <li> <p>If you set this option to <code>ALL_SUPPORTED_RESOURCE_TYPES</code>, Config records configuration changes for all supported resource types, excluding the global IAM resource types. You also must set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>. When Config adds support for a new resource type, Config automatically starts recording resources of that type. For a list of supported resource types, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources'>Supported Resource Types</a> in the <i>Config developer guide</i>.</p> </li> <li> <p>If you set this option to <code>INCLUSION_BY_RESOURCE_TYPES</code>, Config records configuration changes for only the resource types that you specify in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>.</p> </li> <li> <p>If you set this option to <code>EXCLUSION_BY_RESOURCE_TYPES</code>, Config records configuration changes for all supported resource types, except the resource types that you specify to exclude from being recorded in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> </li> </ul> <note> <p> <b>Required and optional fields</b> </p> <p>The <code>recordingStrategy</code> field is optional when you set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>.</p> <p>The <code>recordingStrategy</code> field is optional when you list resource types in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>.</p> <p>The <code>recordingStrategy</code> field is required if you list resource types to exclude from recording in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> </note> <note> <p> <b>Overriding fields</b> </p> <p>If you choose <code>EXCLUSION_BY_RESOURCE_TYPES</code> for the recording strategy, the <code>exclusionByResourceTypes</code> field will override other properties in the request.</p> <p>For example, even if you set <code>includeGlobalResourceTypes</code> to false, global IAM resource types will still be automatically recorded in this option unless those resource types are specifically listed as exclusions in the <code>resourceTypes</code> field of <code>exclusionByResourceTypes</code>.</p> </note> <note> <p> <b>Global resource types and the exclusion recording strategy</b> </p> <p>By default, if you choose the <code>EXCLUSION_BY_RESOURCE_TYPES</code> recording strategy, when Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types, Config starts recording resources of that type automatically.</p> <p>Unless specifically listed as exclusions, <code>AWS::RDS::GlobalCluster</code> will be recorded automatically in all supported Config Regions were the configuration recorder is enabled.</p> <p>IAM users, groups, roles, and customer managed policies will be recorded in the Region where you set up the configuration recorder if that is a Region where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:</p> <ul> <li> <p>Asia Pacific (Hyderabad)</p> </li> <li> <p>Asia Pacific (Melbourne)</p> </li> <li> <p>Canada West (Calgary)</p> </li> <li> <p>Europe (Spain)</p> </li> <li> <p>Europe (Zurich)</p> </li> <li> <p>Israel (Tel Aviv)</p> </li> <li> <p>Middle East (UAE)</p> </li> </ul> </note>
        """
        if use_only is not None:
            pulumi.set(__self__, "use_only", use_only)

    @property
    @pulumi.getter(name="useOnly")
    def use_only(self) -> Optional['outputs.RecordingStrategyTypeEnumValueResponse']:
        """
        <p>The recording strategy for the configuration recorder.</p> <ul> <li> <p>If you set this option to <code>ALL_SUPPORTED_RESOURCE_TYPES</code>, Config records configuration changes for all supported resource types, excluding the global IAM resource types. You also must set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>. When Config adds support for a new resource type, Config automatically starts recording resources of that type. For a list of supported resource types, see <a href='https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources'>Supported Resource Types</a> in the <i>Config developer guide</i>.</p> </li> <li> <p>If you set this option to <code>INCLUSION_BY_RESOURCE_TYPES</code>, Config records configuration changes for only the resource types that you specify in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>.</p> </li> <li> <p>If you set this option to <code>EXCLUSION_BY_RESOURCE_TYPES</code>, Config records configuration changes for all supported resource types, except the resource types that you specify to exclude from being recorded in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> </li> </ul> <note> <p> <b>Required and optional fields</b> </p> <p>The <code>recordingStrategy</code> field is optional when you set the <code>allSupported</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a> to <code>true</code>.</p> <p>The <code>recordingStrategy</code> field is optional when you list resource types in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html'>RecordingGroup</a>.</p> <p>The <code>recordingStrategy</code> field is required if you list resource types to exclude from recording in the <code>resourceTypes</code> field of <a href='https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html'>ExclusionByResourceTypes</a>.</p> </note> <note> <p> <b>Overriding fields</b> </p> <p>If you choose <code>EXCLUSION_BY_RESOURCE_TYPES</code> for the recording strategy, the <code>exclusionByResourceTypes</code> field will override other properties in the request.</p> <p>For example, even if you set <code>includeGlobalResourceTypes</code> to false, global IAM resource types will still be automatically recorded in this option unless those resource types are specifically listed as exclusions in the <code>resourceTypes</code> field of <code>exclusionByResourceTypes</code>.</p> </note> <note> <p> <b>Global resource types and the exclusion recording strategy</b> </p> <p>By default, if you choose the <code>EXCLUSION_BY_RESOURCE_TYPES</code> recording strategy, when Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types, Config starts recording resources of that type automatically.</p> <p>Unless specifically listed as exclusions, <code>AWS::RDS::GlobalCluster</code> will be recorded automatically in all supported Config Regions were the configuration recorder is enabled.</p> <p>IAM users, groups, roles, and customer managed policies will be recorded in the Region where you set up the configuration recorder if that is a Region where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:</p> <ul> <li> <p>Asia Pacific (Hyderabad)</p> </li> <li> <p>Asia Pacific (Melbourne)</p> </li> <li> <p>Canada West (Calgary)</p> </li> <li> <p>Europe (Spain)</p> </li> <li> <p>Europe (Zurich)</p> </li> <li> <p>Israel (Tel Aviv)</p> </li> <li> <p>Middle East (UAE)</p> </li> </ul> </note>
        """
        return pulumi.get(self, "use_only")


@pulumi.output_type
class RecordingStrategyTypeEnumValueResponse(dict):
    """
    Definition of RecordingStrategyTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of RecordingStrategyTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RedirectAllRequestsToResponse(dict):
    """
    Definition of RedirectAllRequestsTo
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedirectAllRequestsToResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedirectAllRequestsToResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedirectAllRequestsToResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        Definition of RedirectAllRequestsTo
        :param str host_name: Name of the host where requests are redirected.
        :param str protocol: Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        Name of the host where requests are redirected.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class RedirectConfigResponse(dict):
    """
    Definition of RedirectConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedirectConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedirectConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedirectConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 protocol: Optional[str] = None,
                 query: Optional[str] = None,
                 status_code: Optional[str] = None):
        """
        Definition of RedirectConfig
        :param str host: The hostname. This component is not percent-encoded. The hostname can contain #{host}.
        :param str path: The absolute path, starting with the leading '/'. This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}.
        :param str port: The port. You can specify a value from 1 to 65535 or #{port}.
        :param str protocol: The protocol. You can specify HTTP, HTTPS, or #{protocol}. You can redirect HTTP to HTTP, HTTP to HTTPS, and HTTPS to HTTPS. You cannot redirect HTTPS to HTTP.
        :param str query: The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading '?', as it is automatically added. You can specify any of the reserved keywords.
        :param str status_code: The HTTP redirect code. The redirect is either permanent (HTTP 301) or temporary (HTTP 302).
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The hostname. This component is not percent-encoded. The hostname can contain #{host}.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The absolute path, starting with the leading '/'. This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        The port. You can specify a value from 1 to 65535 or #{port}.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol. You can specify HTTP, HTTPS, or #{protocol}. You can redirect HTTP to HTTP, HTTP to HTTPS, and HTTPS to HTTPS. You cannot redirect HTTPS to HTTP.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading '?', as it is automatically added. You can specify any of the reserved keywords.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[str]:
        """
        The HTTP redirect code. The redirect is either permanent (HTTP 301) or temporary (HTTP 302).
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class RedirectRuleResponse(dict):
    """
    Definition of RedirectRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "httpRedirectCode":
            suggest = "http_redirect_code"
        elif key == "replaceKeyPrefixWith":
            suggest = "replace_key_prefix_with"
        elif key == "replaceKeyWith":
            suggest = "replace_key_with"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedirectRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedirectRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedirectRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: Optional[str] = None,
                 http_redirect_code: Optional[str] = None,
                 protocol: Optional[str] = None,
                 replace_key_prefix_with: Optional[str] = None,
                 replace_key_with: Optional[str] = None):
        """
        Definition of RedirectRule
        :param str host_name: The host name to use in the redirect request.
        :param str http_redirect_code: The HTTP redirect code to use on the response. Not required if one of the siblings is present.
        :param str protocol: Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        :param str replace_key_prefix_with: The object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix ``docs/`` (objects in the ``docs/`` folder) to ``documents/``, you can set a condition block with ``KeyPrefixEquals`` set to ``docs/`` and in the Redirect set ``ReplaceKeyPrefixWith`` to ``/documents``. Not required if one of the siblings is present. Can be present only if ``ReplaceKeyWith`` is not provided.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        :param str replace_key_with: The specific object key to use in the redirect request. For example, redirect request to ``error.html``. Not required if one of the siblings is present. Can be present only if ``ReplaceKeyPrefixWith`` is not provided.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        """
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if http_redirect_code is not None:
            pulumi.set(__self__, "http_redirect_code", http_redirect_code)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if replace_key_prefix_with is not None:
            pulumi.set(__self__, "replace_key_prefix_with", replace_key_prefix_with)
        if replace_key_with is not None:
            pulumi.set(__self__, "replace_key_with", replace_key_with)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        The host name to use in the redirect request.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="httpRedirectCode")
    def http_redirect_code(self) -> Optional[str]:
        """
        The HTTP redirect code to use on the response. Not required if one of the siblings is present.
        """
        return pulumi.get(self, "http_redirect_code")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="replaceKeyPrefixWith")
    def replace_key_prefix_with(self) -> Optional[str]:
        """
        The object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix ``docs/`` (objects in the ``docs/`` folder) to ``documents/``, you can set a condition block with ``KeyPrefixEquals`` set to ``docs/`` and in the Redirect set ``ReplaceKeyPrefixWith`` to ``/documents``. Not required if one of the siblings is present. Can be present only if ``ReplaceKeyWith`` is not provided.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        """
        return pulumi.get(self, "replace_key_prefix_with")

    @property
    @pulumi.getter(name="replaceKeyWith")
    def replace_key_with(self) -> Optional[str]:
        """
        The specific object key to use in the redirect request. For example, redirect request to ``error.html``. Not required if one of the siblings is present. Can be present only if ``ReplaceKeyPrefixWith`` is not provided.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        """
        return pulumi.get(self, "replace_key_with")


@pulumi.output_type
class RedshiftClusterEndpointResponse(dict):
    """
    Definition of Endpoint
    """
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 port: Optional[str] = None):
        """
        Definition of Endpoint
        :param str address: Property address
        :param str port: Property port
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Property address
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Property port
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RedshiftClusterParameterGroupPropertiesResponse(dict):
    """
    Definition of RedshiftClusterParameterGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedshiftClusterParameterGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedshiftClusterParameterGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedshiftClusterParameterGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRedshiftClusterParameterGroupPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of RedshiftClusterParameterGroup
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRedshiftClusterParameterGroupPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRedshiftClusterParameterGroupPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class RedshiftClusterPropertiesResponse(dict):
    """
    Definition of RedshiftCluster
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedshiftClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedshiftClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedshiftClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRedshiftClusterPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of RedshiftCluster
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRedshiftClusterPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRedshiftClusterPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ReferenceSetsResponse(dict):
    """
    Definition of ReferenceSets
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSetReferences":
            suggest = "ip_set_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReferenceSetsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReferenceSetsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReferenceSetsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_set_references: Optional[Mapping[str, 'outputs.IPSetReferenceResponse']] = None):
        """
        Definition of ReferenceSets
        :param Mapping[str, 'IPSetReferenceResponse'] ip_set_references: Property ipSetReferences
        """
        if ip_set_references is not None:
            pulumi.set(__self__, "ip_set_references", ip_set_references)

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> Optional[Mapping[str, 'outputs.IPSetReferenceResponse']]:
        """
        Property ipSetReferences
        """
        return pulumi.get(self, "ip_set_references")


@pulumi.output_type
class RegistryCredentialResponse(dict):
    """
    Definition of RegistryCredential
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialProvider":
            suggest = "credential_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryCredentialResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryCredentialResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryCredentialResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential: Optional[str] = None,
                 credential_provider: Optional['outputs.CredentialProviderTypeEnumValueResponse'] = None):
        """
        Definition of RegistryCredential
        :param str credential: <p> The Amazon Resource Name (ARN) or name of credentials created using Secrets Manager. </p> <note> <p> The <code>credential</code> can use the name of the credentials only if they exist in your current Amazon Web Services Region. </p> </note>
        :param 'CredentialProviderTypeEnumValueResponse' credential_provider: <p> The service that created the credentials to access a private Docker registry. The valid value, SECRETS_MANAGER, is for Secrets Manager. </p>
        """
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if credential_provider is not None:
            pulumi.set(__self__, "credential_provider", credential_provider)

    @property
    @pulumi.getter
    def credential(self) -> Optional[str]:
        """
        <p> The Amazon Resource Name (ARN) or name of credentials created using Secrets Manager. </p> <note> <p> The <code>credential</code> can use the name of the credentials only if they exist in your current Amazon Web Services Region. </p> </note>
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter(name="credentialProvider")
    def credential_provider(self) -> Optional['outputs.CredentialProviderTypeEnumValueResponse']:
        """
        <p> The service that created the credentials to access a private Docker registry. The valid value, SECRETS_MANAGER, is for Secrets Manager. </p>
        """
        return pulumi.get(self, "credential_provider")


@pulumi.output_type
class RemoteAccessResponse(dict):
    """
    Definition of RemoteAccess
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ec2SshKey":
            suggest = "ec2_ssh_key"
        elif key == "sourceSecurityGroups":
            suggest = "source_security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteAccessResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteAccessResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteAccessResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ec2_ssh_key: Optional[str] = None,
                 source_security_groups: Optional[Sequence[str]] = None):
        """
        Definition of RemoteAccess
        :param str ec2_ssh_key: Property ec2SshKey
        :param Sequence[str] source_security_groups: Property sourceSecurityGroups
        """
        if ec2_ssh_key is not None:
            pulumi.set(__self__, "ec2_ssh_key", ec2_ssh_key)
        if source_security_groups is not None:
            pulumi.set(__self__, "source_security_groups", source_security_groups)

    @property
    @pulumi.getter(name="ec2SshKey")
    def ec2_ssh_key(self) -> Optional[str]:
        """
        Property ec2SshKey
        """
        return pulumi.get(self, "ec2_ssh_key")

    @property
    @pulumi.getter(name="sourceSecurityGroups")
    def source_security_groups(self) -> Optional[Sequence[str]]:
        """
        Property sourceSecurityGroups
        """
        return pulumi.get(self, "source_security_groups")


@pulumi.output_type
class RenewalEligibilityEnumValueResponse(dict):
    """
    Definition of RenewalEligibilityEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of RenewalEligibilityEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ReplicaModificationsResponse(dict):
    """
    Definition of ReplicaModifications
    """
    def __init__(__self__, *,
                 status: Optional[str] = None):
        """
        Definition of ReplicaModifications
        :param str status: Specifies whether Amazon S3 replicates modifications on replicas.  *Allowed values*: ``Enabled`` | ``Disabled``
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Specifies whether Amazon S3 replicates modifications on replicas.  *Allowed values*: ``Enabled`` | ``Disabled``
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ReplicaRegionResponse(dict):
    """
    Definition of ReplicaRegion
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicaRegionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicaRegionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicaRegionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        Definition of ReplicaRegion
        :param str kms_key_id: The ARN, key ID, or alias of the KMS key to encrypt the secret. If you don't include this field, Secrets Manager uses ``aws/secretsmanager``.
        :param str region: A string that represents a ``Region``, for example 'us-east-1'.
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ARN, key ID, or alias of the KMS key to encrypt the secret. If you don't include this field, Secrets Manager uses ``aws/secretsmanager``.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        A string that represents a ``Region``, for example 'us-east-1'.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ReplicationConfigurationResponse(dict):
    """
    Definition of ReplicationConfiguration
    """
    def __init__(__self__, *,
                 destinations: Optional[Sequence['outputs.ReplicationDestinationResponse']] = None,
                 role: Optional[str] = None,
                 rules: Optional[Sequence['outputs.ReplicationRuleResponse']] = None):
        """
        Definition of ReplicationConfiguration
        :param Sequence['ReplicationDestinationResponse'] destinations: An array of destination objects. Only one destination object is supported.
        :param str role: The Amazon Resource Name (ARN) of the IAMlong (IAM) role that Amazon S3 assumes when replicating objects. For more information, see [How to Set Up Replication](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-how-setup.html) in the *Amazon S3 User Guide*.
        :param Sequence['ReplicationRuleResponse'] rules: A container for one or more replication rules. A replication configuration must have at least one rule and can contain a maximum of 1,000 rules.
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence['outputs.ReplicationDestinationResponse']]:
        """
        An array of destination objects. Only one destination object is supported.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the IAMlong (IAM) role that Amazon S3 assumes when replicating objects. For more information, see [How to Set Up Replication](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-how-setup.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ReplicationRuleResponse']]:
        """
        A container for one or more replication rules. A replication configuration must have at least one rule and can contain a maximum of 1,000 rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ReplicationDestinationResponse(dict):
    """
    Definition of ReplicationDestination
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessControlTranslation":
            suggest = "access_control_translation"
        elif key == "availabilityZoneName":
            suggest = "availability_zone_name"
        elif key == "encryptionConfiguration":
            suggest = "encryption_configuration"
        elif key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "replicationTime":
            suggest = "replication_time"
        elif key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_control_translation: Optional['outputs.AccessControlTranslationResponse'] = None,
                 account: Optional[str] = None,
                 availability_zone_name: Optional[str] = None,
                 bucket: Optional[str] = None,
                 encryption_configuration: Optional['outputs.EncryptionConfigurationResponse'] = None,
                 file_system_id: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 metrics: Optional['outputs.MetricsResponse'] = None,
                 region: Optional[str] = None,
                 replication_time: Optional['outputs.ReplicationTimeResponse'] = None,
                 storage_class: Optional[str] = None):
        """
        Definition of ReplicationDestination
        :param 'AccessControlTranslationResponse' access_control_translation: Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS-account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS-account that owns the source object. Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS-account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS-account that owns the source object.
        :param str account: Destination bucket owner account ID. In a cross-account scenario, if you direct Amazon S3 to change replica ownership to the AWS-account that owns the destination bucket by specifying the ``AccessControlTranslation`` property, this is the account ID of the destination bucket owner. For more information, see [Cross-Region Replication Additional Configuration: Change Replica Owner](https://docs.aws.amazon.com/AmazonS3/latest/dev/crr-change-owner.html) in the *Amazon S3 User Guide*. If you specify the ``AccessControlTranslation`` property, the ``Account`` property is required.
        :param str availability_zone_name: The AWS For One Zone file systems, the replication configuration must specify the Availability Zone in which the destination file system is located.  Use the format ``us-east-1a`` to specify the Availability Zone. For more information about One Zone file systems, see [EFS file system types](https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html) in the *Amazon EFS User Guide*.  One Zone file system type is not available in all Availability Zones in AWS-Regions where Amazon EFS is available.
        :param str bucket: The Amazon Resource Name (ARN) of the bucket where you want Amazon S3 to store the results.
        :param 'EncryptionConfigurationResponse' encryption_configuration: Specifies encryption-related information. Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
        :param str file_system_id: The ID of the destination Amazon EFS file system.
        :param str kms_key_id: The ID of an kms-key-long used to protect the encrypted file system.
        :param 'MetricsResponse' metrics: A container specifying replication metrics-related settings enabling replication metrics and events. A container specifying replication metrics-related settings enabling replication metrics and events.
        :param str region: The AWS-Region in which the destination file system is located.  For One Zone file systems, the replication configuration must specify the AWS-Region in which the destination file system is located.
        :param 'ReplicationTimeResponse' replication_time: A container specifying S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a ``Metrics`` block. A container specifying S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a ``Metrics`` block.
        :param str storage_class: The storage class to use when replicating objects, such as S3 Standard or reduced redundancy. By default, Amazon S3 uses the storage class of the source object to create the object replica.  For valid values, see the ``StorageClass`` element of the [PUT Bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) action in the *Amazon S3 API Reference*.
        """
        if access_control_translation is not None:
            pulumi.set(__self__, "access_control_translation", access_control_translation)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if availability_zone_name is not None:
            pulumi.set(__self__, "availability_zone_name", availability_zone_name)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if encryption_configuration is not None:
            pulumi.set(__self__, "encryption_configuration", encryption_configuration)
        if file_system_id is not None:
            pulumi.set(__self__, "file_system_id", file_system_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if replication_time is not None:
            pulumi.set(__self__, "replication_time", replication_time)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter(name="accessControlTranslation")
    def access_control_translation(self) -> Optional['outputs.AccessControlTranslationResponse']:
        """
        Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS-account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS-account that owns the source object. Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS-account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS-account that owns the source object.
        """
        return pulumi.get(self, "access_control_translation")

    @property
    @pulumi.getter
    def account(self) -> Optional[str]:
        """
        Destination bucket owner account ID. In a cross-account scenario, if you direct Amazon S3 to change replica ownership to the AWS-account that owns the destination bucket by specifying the ``AccessControlTranslation`` property, this is the account ID of the destination bucket owner. For more information, see [Cross-Region Replication Additional Configuration: Change Replica Owner](https://docs.aws.amazon.com/AmazonS3/latest/dev/crr-change-owner.html) in the *Amazon S3 User Guide*. If you specify the ``AccessControlTranslation`` property, the ``Account`` property is required.
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="availabilityZoneName")
    def availability_zone_name(self) -> Optional[str]:
        """
        The AWS For One Zone file systems, the replication configuration must specify the Availability Zone in which the destination file system is located.  Use the format ``us-east-1a`` to specify the Availability Zone. For more information about One Zone file systems, see [EFS file system types](https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html) in the *Amazon EFS User Guide*.  One Zone file system type is not available in all Availability Zones in AWS-Regions where Amazon EFS is available.
        """
        return pulumi.get(self, "availability_zone_name")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the bucket where you want Amazon S3 to store the results.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional['outputs.EncryptionConfigurationResponse']:
        """
        Specifies encryption-related information. Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
        """
        return pulumi.get(self, "encryption_configuration")

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> Optional[str]:
        """
        The ID of the destination Amazon EFS file system.
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ID of an kms-key-long used to protect the encrypted file system.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.MetricsResponse']:
        """
        A container specifying replication metrics-related settings enabling replication metrics and events. A container specifying replication metrics-related settings enabling replication metrics and events.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS-Region in which the destination file system is located.  For One Zone file systems, the replication configuration must specify the AWS-Region in which the destination file system is located.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="replicationTime")
    def replication_time(self) -> Optional['outputs.ReplicationTimeResponse']:
        """
        A container specifying S3 Replication Time Control (S3 RTC), including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a ``Metrics`` block. A container specifying S3 Replication Time Control (S3 RTC) related information, including whether S3 RTC is enabled and the time when all objects and operations on objects must be replicated. Must be specified together with a ``Metrics`` block.
        """
        return pulumi.get(self, "replication_time")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[str]:
        """
        The storage class to use when replicating objects, such as S3 Standard or reduced redundancy. By default, Amazon S3 uses the storage class of the source object to create the object replica.  For valid values, see the ``StorageClass`` element of the [PUT Bucket replication](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTreplication.html) action in the *Amazon S3 API Reference*.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class ReplicationPendingModifiedValuesResponse(dict):
    """
    Definition of ReplicationPendingModifiedValues
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedStorage":
            suggest = "allocated_storage"
        elif key == "engineVersion":
            suggest = "engine_version"
        elif key == "multiAZ":
            suggest = "multi_az"
        elif key == "networkType":
            suggest = "network_type"
        elif key == "replicationInstanceClass":
            suggest = "replication_instance_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationPendingModifiedValuesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationPendingModifiedValuesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationPendingModifiedValuesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_storage: Optional[int] = None,
                 engine_version: Optional[str] = None,
                 multi_az: Optional[bool] = None,
                 network_type: Optional[str] = None,
                 replication_instance_class: Optional[str] = None):
        """
        Definition of ReplicationPendingModifiedValues
        :param int allocated_storage: <p>The amount of storage (in gigabytes) that is allocated for the replication instance.</p>
        :param str engine_version: <p>The engine version number of the replication instance.</p>
        :param bool multi_az: <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to <code>true</code>. </p>
        :param str network_type: <p>The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.</p>
        :param str replication_instance_class: <p>The compute and memory capacity of the replication instance as defined for the specified replication instance class.</p> <p>For more information on the settings and capacities for the available replication instance classes, see <a href='https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth'> Selecting the right DMS replication instance for your migration</a>. </p>
        """
        if allocated_storage is not None:
            pulumi.set(__self__, "allocated_storage", allocated_storage)
        if engine_version is not None:
            pulumi.set(__self__, "engine_version", engine_version)
        if multi_az is not None:
            pulumi.set(__self__, "multi_az", multi_az)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if replication_instance_class is not None:
            pulumi.set(__self__, "replication_instance_class", replication_instance_class)

    @property
    @pulumi.getter(name="allocatedStorage")
    def allocated_storage(self) -> Optional[int]:
        """
        <p>The amount of storage (in gigabytes) that is allocated for the replication instance.</p>
        """
        return pulumi.get(self, "allocated_storage")

    @property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> Optional[str]:
        """
        <p>The engine version number of the replication instance.</p>
        """
        return pulumi.get(self, "engine_version")

    @property
    @pulumi.getter(name="multiAZ")
    def multi_az(self) -> Optional[bool]:
        """
        <p> Specifies whether the replication instance is a Multi-AZ deployment. You can't set the <code>AvailabilityZone</code> parameter if the Multi-AZ parameter is set to <code>true</code>. </p>
        """
        return pulumi.get(self, "multi_az")

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[str]:
        """
        <p>The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.</p>
        """
        return pulumi.get(self, "network_type")

    @property
    @pulumi.getter(name="replicationInstanceClass")
    def replication_instance_class(self) -> Optional[str]:
        """
        <p>The compute and memory capacity of the replication instance as defined for the specified replication instance class.</p> <p>For more information on the settings and capacities for the available replication instance classes, see <a href='https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth'> Selecting the right DMS replication instance for your migration</a>. </p>
        """
        return pulumi.get(self, "replication_instance_class")


@pulumi.output_type
class ReplicationRuleAndOperatorResponse(dict):
    """
    Definition of ReplicationRuleAndOperator
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationRuleAndOperatorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationRuleAndOperatorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationRuleAndOperatorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.TagFilterResponse']] = None):
        """
        Definition of ReplicationRuleAndOperator
        :param str prefix: An object key name prefix that identifies the subset of objects to which the rule applies.
        :param Sequence['TagFilterResponse'] tag_filters: An array of tags containing key and value pairs.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An object key name prefix that identifies the subset of objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.TagFilterResponse']]:
        """
        An array of tags containing key and value pairs.
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class ReplicationRuleFilterResponse(dict):
    """
    Definition of ReplicationRuleFilter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "and":
            suggest = "and_"
        elif key == "tagFilter":
            suggest = "tag_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationRuleFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationRuleFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationRuleFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_: Optional['outputs.ReplicationRuleAndOperatorResponse'] = None,
                 prefix: Optional[str] = None,
                 tag_filter: Optional['outputs.TagFilterResponse'] = None):
        """
        Definition of ReplicationRuleFilter
        :param 'ReplicationRuleAndOperatorResponse' and_: A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:   +  If you specify both a ``Prefix`` and a ``TagFilter``, wrap these filters in an ``And`` tag.  +  If you specify a filter based on multiple tags, wrap the ``TagFilter`` elements in an ``And`` tag. A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter.  For example:  +  If you specify both a ``Prefix`` and a ``TagFilter``, wrap these filters in an ``And`` tag.   +  If you specify a filter based on multiple tags, wrap the ``TagFilter`` elements in an ``And`` tag
        :param str prefix: An object key name prefix that identifies the subset of objects to which the rule applies.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        :param 'TagFilterResponse' tag_filter: A container for specifying a tag key and value.  The rule applies only to objects that have the tag in their tag set. Specifies tags to use to identify a subset of objects for an Amazon S3 bucket.
        """
        if and_ is not None:
            pulumi.set(__self__, "and_", and_)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if tag_filter is not None:
            pulumi.set(__self__, "tag_filter", tag_filter)

    @property
    @pulumi.getter(name="and")
    def and_(self) -> Optional['outputs.ReplicationRuleAndOperatorResponse']:
        """
        A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter. For example:   +  If you specify both a ``Prefix`` and a ``TagFilter``, wrap these filters in an ``And`` tag.  +  If you specify a filter based on multiple tags, wrap the ``TagFilter`` elements in an ``And`` tag. A container for specifying rule filters. The filters determine the subset of objects to which the rule applies. This element is required only if you specify more than one filter.  For example:  +  If you specify both a ``Prefix`` and a ``TagFilter``, wrap these filters in an ``And`` tag.   +  If you specify a filter based on multiple tags, wrap the ``TagFilter`` elements in an ``And`` tag
        """
        return pulumi.get(self, "and_")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An object key name prefix that identifies the subset of objects to which the rule applies.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="tagFilter")
    def tag_filter(self) -> Optional['outputs.TagFilterResponse']:
        """
        A container for specifying a tag key and value.  The rule applies only to objects that have the tag in their tag set. Specifies tags to use to identify a subset of objects for an Amazon S3 bucket.
        """
        return pulumi.get(self, "tag_filter")


@pulumi.output_type
class ReplicationRuleResponse(dict):
    """
    Definition of ReplicationRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteMarkerReplication":
            suggest = "delete_marker_replication"
        elif key == "sourceSelectionCriteria":
            suggest = "source_selection_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_marker_replication: Optional['outputs.DeleteMarkerReplicationResponse'] = None,
                 destination: Optional['outputs.ReplicationDestinationResponse'] = None,
                 filter: Optional['outputs.ReplicationRuleFilterResponse'] = None,
                 id: Optional[str] = None,
                 prefix: Optional[str] = None,
                 priority: Optional[int] = None,
                 source_selection_criteria: Optional['outputs.SourceSelectionCriteriaResponse'] = None,
                 status: Optional[str] = None):
        """
        Definition of ReplicationRule
        :param 'DeleteMarkerReplicationResponse' delete_marker_replication: Specifies whether Amazon S3 replicates delete markers. If you specify a ``Filter`` in your replication configuration, you must also include a ``DeleteMarkerReplication`` element. If your ``Filter`` includes a ``Tag`` element, the ``DeleteMarkerReplication`` ``Status`` must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config).  For more information about delete marker replication, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html).   If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see [Backward Compatibility](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations). Specifies whether Amazon S3 replicates delete markers. If you specify a ``Filter`` in your replication configuration, you must also include a ``DeleteMarkerReplication`` element. If your ``Filter`` includes a ``Tag`` element, the ``DeleteMarkerReplication`` ``Status`` must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config).  For more information about delete marker replication, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html).   If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see [Backward Compatibility](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations).
        :param 'ReplicationDestinationResponse' destination: A container for information about the replication destination and its configurations including enabling the S3 Replication Time Control (S3 RTC). A container for information about the replication destination and its configurations including enabling the S3 Replication Time Control (S3 RTC).
        :param 'ReplicationRuleFilterResponse' filter: A filter that identifies the subset of objects to which the replication rule applies. A ``Filter`` must specify exactly one ``Prefix``, ``TagFilter``, or an ``And`` child element. The use of the filter field indicates that this is a V2 replication configuration. This field isn't supported in a V1 replication configuration.  V1 replication configuration only supports filtering by key prefix. To filter using a V1 replication configuration, add the ``Prefix`` directly as a child element of the ``Rule`` element. A filter that identifies the subset of objects to which the replication rule applies. A ``Filter`` must specify exactly one ``Prefix``, ``TagFilter``, or an ``And`` child element.
        :param str id: A unique identifier for the rule. The maximum value is 255 characters. If you don't specify a value, AWS CloudFormation generates a random ID. When using a V2 replication configuration this property is capitalized as 'ID'.
        :param str prefix: An object key name prefix that identifies the object or objects to which the rule applies. The maximum prefix length is 1,024 characters. To include all objects in a bucket, specify an empty string. To filter using a V1 replication configuration, add the ``Prefix`` directly as a child element of the ``Rule`` element.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        :param int priority: The priority indicates which rule has precedence whenever two or more replication rules conflict. Amazon S3 will attempt to replicate objects according to all replication rules. However, if there are two or more rules with the same destination bucket, then objects will be replicated according to the rule with the highest priority. The higher the number, the higher the priority.  For more information, see [Replication](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication.html) in the *Amazon S3 User Guide*.
        :param 'SourceSelectionCriteriaResponse' source_selection_criteria: A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects. A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects.
        :param str status: Specifies whether the rule is enabled.
        """
        if delete_marker_replication is not None:
            pulumi.set(__self__, "delete_marker_replication", delete_marker_replication)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if source_selection_criteria is not None:
            pulumi.set(__self__, "source_selection_criteria", source_selection_criteria)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="deleteMarkerReplication")
    def delete_marker_replication(self) -> Optional['outputs.DeleteMarkerReplicationResponse']:
        """
        Specifies whether Amazon S3 replicates delete markers. If you specify a ``Filter`` in your replication configuration, you must also include a ``DeleteMarkerReplication`` element. If your ``Filter`` includes a ``Tag`` element, the ``DeleteMarkerReplication`` ``Status`` must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config).  For more information about delete marker replication, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html).   If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see [Backward Compatibility](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations). Specifies whether Amazon S3 replicates delete markers. If you specify a ``Filter`` in your replication configuration, you must also include a ``DeleteMarkerReplication`` element. If your ``Filter`` includes a ``Tag`` element, the ``DeleteMarkerReplication`` ``Status`` must be set to Disabled, because Amazon S3 does not support replicating delete markers for tag-based rules. For an example configuration, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-config-min-rule-config).  For more information about delete marker replication, see [Basic Rule Configuration](https://docs.aws.amazon.com/AmazonS3/latest/dev/delete-marker-replication.html).   If you are using an earlier version of the replication configuration, Amazon S3 handles replication of delete markers differently. For more information, see [Backward Compatibility](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication-add-config.html#replication-backward-compat-considerations).
        """
        return pulumi.get(self, "delete_marker_replication")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ReplicationDestinationResponse']:
        """
        A container for information about the replication destination and its configurations including enabling the S3 Replication Time Control (S3 RTC). A container for information about the replication destination and its configurations including enabling the S3 Replication Time Control (S3 RTC).
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.ReplicationRuleFilterResponse']:
        """
        A filter that identifies the subset of objects to which the replication rule applies. A ``Filter`` must specify exactly one ``Prefix``, ``TagFilter``, or an ``And`` child element. The use of the filter field indicates that this is a V2 replication configuration. This field isn't supported in a V1 replication configuration.  V1 replication configuration only supports filtering by key prefix. To filter using a V1 replication configuration, add the ``Prefix`` directly as a child element of the ``Rule`` element. A filter that identifies the subset of objects to which the replication rule applies. A ``Filter`` must specify exactly one ``Prefix``, ``TagFilter``, or an ``And`` child element.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A unique identifier for the rule. The maximum value is 255 characters. If you don't specify a value, AWS CloudFormation generates a random ID. When using a V2 replication configuration this property is capitalized as 'ID'.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An object key name prefix that identifies the object or objects to which the rule applies. The maximum prefix length is 1,024 characters. To include all objects in a bucket, specify an empty string. To filter using a V1 replication configuration, add the ``Prefix`` directly as a child element of the ``Rule`` element.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority indicates which rule has precedence whenever two or more replication rules conflict. Amazon S3 will attempt to replicate objects according to all replication rules. However, if there are two or more rules with the same destination bucket, then objects will be replicated according to the rule with the highest priority. The higher the number, the higher the priority.  For more information, see [Replication](https://docs.aws.amazon.com/AmazonS3/latest/dev/replication.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="sourceSelectionCriteria")
    def source_selection_criteria(self) -> Optional['outputs.SourceSelectionCriteriaResponse']:
        """
        A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects. A container that describes additional filters for identifying the source objects that you want to replicate. You can choose to enable or disable the replication of these objects.
        """
        return pulumi.get(self, "source_selection_criteria")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Specifies whether the rule is enabled.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ReplicationSubnetGroupResponse(dict):
    """
    Definition of ReplicationSubnetGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationSubnetGroupDescription":
            suggest = "replication_subnet_group_description"
        elif key == "replicationSubnetGroupIdentifier":
            suggest = "replication_subnet_group_identifier"
        elif key == "subnetGroupStatus":
            suggest = "subnet_group_status"
        elif key == "supportedNetworkTypes":
            suggest = "supported_network_types"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationSubnetGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationSubnetGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationSubnetGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replication_subnet_group_description: Optional[str] = None,
                 replication_subnet_group_identifier: Optional[str] = None,
                 subnet_group_status: Optional[str] = None,
                 subnets: Optional[Sequence['outputs.SubnetResponse']] = None,
                 supported_network_types: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of ReplicationSubnetGroup
        :param str replication_subnet_group_description: <p>A description for the replication subnet group.</p>
        :param str replication_subnet_group_identifier: <p>The identifier of the replication instance subnet group.</p>
        :param str subnet_group_status: <p>The status of the subnet group.</p>
        :param Sequence['SubnetResponse'] subnets: <p>The subnets that are in the subnet group.</p>
        :param Sequence[str] supported_network_types: <p>The IP addressing protocol supported by the subnet group. This is used by a replication instance with values such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.</p>
        :param str vpc_id: <p>The ID of the VPC.</p>
        """
        if replication_subnet_group_description is not None:
            pulumi.set(__self__, "replication_subnet_group_description", replication_subnet_group_description)
        if replication_subnet_group_identifier is not None:
            pulumi.set(__self__, "replication_subnet_group_identifier", replication_subnet_group_identifier)
        if subnet_group_status is not None:
            pulumi.set(__self__, "subnet_group_status", subnet_group_status)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if supported_network_types is not None:
            pulumi.set(__self__, "supported_network_types", supported_network_types)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="replicationSubnetGroupDescription")
    def replication_subnet_group_description(self) -> Optional[str]:
        """
        <p>A description for the replication subnet group.</p>
        """
        return pulumi.get(self, "replication_subnet_group_description")

    @property
    @pulumi.getter(name="replicationSubnetGroupIdentifier")
    def replication_subnet_group_identifier(self) -> Optional[str]:
        """
        <p>The identifier of the replication instance subnet group.</p>
        """
        return pulumi.get(self, "replication_subnet_group_identifier")

    @property
    @pulumi.getter(name="subnetGroupStatus")
    def subnet_group_status(self) -> Optional[str]:
        """
        <p>The status of the subnet group.</p>
        """
        return pulumi.get(self, "subnet_group_status")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.SubnetResponse']]:
        """
        <p>The subnets that are in the subnet group.</p>
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="supportedNetworkTypes")
    def supported_network_types(self) -> Optional[Sequence[str]]:
        """
        <p>The IP addressing protocol supported by the subnet group. This is used by a replication instance with values such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.</p>
        """
        return pulumi.get(self, "supported_network_types")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        <p>The ID of the VPC.</p>
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class ReplicationTimeResponse(dict):
    """
    Definition of ReplicationTime
    """
    def __init__(__self__, *,
                 status: Optional[str] = None,
                 time: Optional['outputs.ReplicationTimeValueResponse'] = None):
        """
        Definition of ReplicationTime
        :param str status: Specifies whether the replication time is enabled.
        :param 'ReplicationTimeValueResponse' time: A container specifying the time by which replication should be complete for all objects and operations on objects. A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics ``EventThreshold``.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Specifies whether the replication time is enabled.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.ReplicationTimeValueResponse']:
        """
        A container specifying the time by which replication should be complete for all objects and operations on objects. A container specifying the time value for S3 Replication Time Control (S3 RTC) and replication metrics ``EventThreshold``.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class ReplicationTimeValueResponse(dict):
    """
    Definition of ReplicationTimeValue
    """
    def __init__(__self__, *,
                 minutes: Optional[int] = None):
        """
        Definition of ReplicationTimeValue
        :param int minutes: Contains an integer specifying time in minutes.   Valid value: 15
        """
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[int]:
        """
        Contains an integer specifying time in minutes.   Valid value: 15
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class RepoUpgradeOnBootEnumValueResponse(dict):
    """
    Definition of RepoUpgradeOnBootEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of RepoUpgradeOnBootEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RepositoryCredentialsResponse(dict):
    """
    Definition of RepositoryCredentials
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsParameter":
            suggest = "credentials_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RepositoryCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RepositoryCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RepositoryCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_parameter: Optional[str] = None):
        """
        Definition of RepositoryCredentials
        :param str credentials_parameter: The Amazon Resource Name (ARN) of the secret containing the private repository credentials.  When you use the Amazon ECS API, CLI, or AWS SDK, if the secret exists in the same Region as the task that you're launching then you can use either the full ARN or the name of the secret. When you use the AWS Management Console, you must specify the full ARN of the secret.
        """
        if credentials_parameter is not None:
            pulumi.set(__self__, "credentials_parameter", credentials_parameter)

    @property
    @pulumi.getter(name="credentialsParameter")
    def credentials_parameter(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the secret containing the private repository credentials.  When you use the Amazon ECS API, CLI, or AWS SDK, if the secret exists in the same Region as the task that you're launching then you can use either the full ARN or the name of the secret. When you use the AWS Management Console, you must specify the full ARN of the secret.
        """
        return pulumi.get(self, "credentials_parameter")


@pulumi.output_type
class ResolverLevelMetricsBehaviorEnumValueResponse(dict):
    """
    Definition of ResolverLevelMetricsBehaviorEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ResolverLevelMetricsBehaviorEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ResourcePolicyResponse(dict):
    """
    Definition of ResourcePolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyDocument":
            suggest = "policy_document"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_document: Optional[Any] = None):
        """
        Definition of ResourcePolicy
        :param Any policy_document: A resource-based policy document that contains permissions to add to the specified DDB table, index, or both. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html).
        """
        if policy_document is not None:
            pulumi.set(__self__, "policy_document", policy_document)

    @property
    @pulumi.getter(name="policyDocument")
    def policy_document(self) -> Optional[Any]:
        """
        A resource-based policy document that contains permissions to add to the specified DDB table, index, or both. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html).
        """
        return pulumi.get(self, "policy_document")


@pulumi.output_type
class ResourceRecordResponse(dict):
    """
    Definition of ResourceRecord
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ResourceRecord
        :param str value: <p>The current or new DNS record value, not to exceed 4,000 characters. In the case of a <code>DELETE</code> action, if the current value does not match the actual value, an error is returned. For descriptions about how to format <code>Value</code> for different record types, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/ResourceRecordTypes.html'>Supported DNS Resource Record Types</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>You can specify more than one value for all record types except <code>CNAME</code> and <code>SOA</code>. </p> <note> <p>If you're creating an alias resource record set, omit <code>Value</code>.</p> </note>
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        <p>The current or new DNS record value, not to exceed 4,000 characters. In the case of a <code>DELETE</code> action, if the current value does not match the actual value, an error is returned. For descriptions about how to format <code>Value</code> for different record types, see <a href='https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/ResourceRecordTypes.html'>Supported DNS Resource Record Types</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>You can specify more than one value for all record types except <code>CNAME</code> and <code>SOA</code>. </p> <note> <p>If you're creating an alias resource record set, omit <code>Value</code>.</p> </note>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ResourceRecordSetFailoverEnumValueResponse(dict):
    """
    Definition of ResourceRecordSetFailoverEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ResourceRecordSetFailoverEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ResourceRecordSetRegionEnumValueResponse(dict):
    """
    Definition of ResourceRecordSetRegionEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ResourceRecordSetRegionEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ResourceRequirementResponse(dict):
    """
    Definition of ResourceRequirement
    """
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of ResourceRequirement
        :param str type: The type of resource to assign to a container. The supported values are ``GPU`` or ``InferenceAccelerator``.
        :param str value: The value for the specified resource type. If the ``GPU`` type is used, the value is the number of physical ``GPUs`` the Amazon ECS container agent reserves for the container. The number of GPUs that's reserved for all containers in a task can't exceed the number of available GPUs on the container instance that the task is launched on. If the ``InferenceAccelerator`` type is used, the ``value`` matches the ``deviceName`` for an [InferenceAccelerator](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_InferenceAccelerator.html) specified in a task definition.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of resource to assign to a container. The supported values are ``GPU`` or ``InferenceAccelerator``.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value for the specified resource type. If the ``GPU`` type is used, the value is the number of physical ``GPUs`` the Amazon ECS container agent reserves for the container. The number of GPUs that's reserved for all containers in a task can't exceed the number of available GPUs on the container instance that the task is launched on. If the ``InferenceAccelerator`` type is used, the ``value`` matches the ``deviceName`` for an [InferenceAccelerator](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_InferenceAccelerator.html) specified in a task definition.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ResourceSpecResponse(dict):
    """
    Definition of ResourceSpec
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "sageMakerImageArn":
            suggest = "sage_maker_image_arn"
        elif key == "sageMakerImageVersionArn":
            suggest = "sage_maker_image_version_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: Optional[str] = None,
                 sage_maker_image_arn: Optional[str] = None,
                 sage_maker_image_version_arn: Optional[str] = None):
        """
        Definition of ResourceSpec
        :param str instance_type: The instance type that the image version runs on.
        :param str sage_maker_image_arn: The ARN of the SageMaker image that the image version belongs to.
        :param str sage_maker_image_version_arn: The ARN of the image version created on the instance.
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if sage_maker_image_arn is not None:
            pulumi.set(__self__, "sage_maker_image_arn", sage_maker_image_arn)
        if sage_maker_image_version_arn is not None:
            pulumi.set(__self__, "sage_maker_image_version_arn", sage_maker_image_version_arn)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The instance type that the image version runs on.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="sageMakerImageArn")
    def sage_maker_image_arn(self) -> Optional[str]:
        """
        The ARN of the SageMaker image that the image version belongs to.
        """
        return pulumi.get(self, "sage_maker_image_arn")

    @property
    @pulumi.getter(name="sageMakerImageVersionArn")
    def sage_maker_image_version_arn(self) -> Optional[str]:
        """
        The ARN of the image version created on the instance.
        """
        return pulumi.get(self, "sage_maker_image_version_arn")


@pulumi.output_type
class ResourceTypeEnumValueResponse(dict):
    """
    Definition of ResourceTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ResourceTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RestrictionsResponse(dict):
    """
    Definition of Restrictions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoRestriction":
            suggest = "geo_restriction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RestrictionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RestrictionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RestrictionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_restriction: Optional['outputs.GeoRestrictionResponse'] = None):
        """
        Definition of Restrictions
        :param 'GeoRestrictionResponse' geo_restriction: A complex type that controls the countries in which your content is distributed. CF determines the location of your users using ``MaxMind`` GeoIP databases. To disable geo restriction, remove the [Restrictions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudfront-distribution-distributionconfig.html#cfn-cloudfront-distribution-distributionconfig-restrictions) property from your stack template. A complex type that controls the countries in which your content is distributed. CF determines the location of your users using ``MaxMind`` GeoIP databases. To disable geo restriction, remove the [Restrictions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudfront-distribution-distributionconfig.html#cfn-cloudfront-distribution-distributionconfig-restrictions) property from your stack template.
        """
        if geo_restriction is not None:
            pulumi.set(__self__, "geo_restriction", geo_restriction)

    @property
    @pulumi.getter(name="geoRestriction")
    def geo_restriction(self) -> Optional['outputs.GeoRestrictionResponse']:
        """
        A complex type that controls the countries in which your content is distributed. CF determines the location of your users using ``MaxMind`` GeoIP databases. To disable geo restriction, remove the [Restrictions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudfront-distribution-distributionconfig.html#cfn-cloudfront-distribution-distributionconfig-restrictions) property from your stack template. A complex type that controls the countries in which your content is distributed. CF determines the location of your users using ``MaxMind`` GeoIP databases. To disable geo restriction, remove the [Restrictions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cloudfront-distribution-distributionconfig.html#cfn-cloudfront-distribution-distributionconfig-restrictions) property from your stack template.
        """
        return pulumi.get(self, "geo_restriction")


@pulumi.output_type
class Route53DomainsDomainSummaryPropertiesResponse(dict):
    """
    Definition of Route53DomainsDomainSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Route53DomainsDomainSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Route53DomainsDomainSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Route53DomainsDomainSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRoute53DomainsDomainSummaryPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Route53DomainsDomainSummary
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRoute53DomainsDomainSummaryPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRoute53DomainsDomainSummaryPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Route53HostedZonePropertiesResponse(dict):
    """
    Definition of Route53HostedZone
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Route53HostedZonePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Route53HostedZonePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Route53HostedZonePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRoute53HostedZonePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Route53HostedZone
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRoute53HostedZonePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRoute53HostedZonePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Route53ResourceRecordSetPropertiesResponse(dict):
    """
    Definition of Route53ResourceRecordSet
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Route53ResourceRecordSetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Route53ResourceRecordSetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Route53ResourceRecordSetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsRoute53ResourceRecordSetPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Route53ResourceRecordSet
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsRoute53ResourceRecordSetPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsRoute53ResourceRecordSetPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class RoutingRuleConditionResponse(dict):
    """
    Definition of RoutingRuleCondition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpErrorCodeReturnedEquals":
            suggest = "http_error_code_returned_equals"
        elif key == "keyPrefixEquals":
            suggest = "key_prefix_equals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutingRuleConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutingRuleConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutingRuleConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_error_code_returned_equals: Optional[str] = None,
                 key_prefix_equals: Optional[str] = None):
        """
        Definition of RoutingRuleCondition
        :param str http_error_code_returned_equals: The HTTP error code when the redirect is applied. In the event of an error, if the error code equals this value, then the specified redirect is applied. Required when parent element ``Condition`` is specified and sibling ``KeyPrefixEquals`` is not specified. If both are specified, then both must be true for the redirect to be applied.
        :param str key_prefix_equals: The object key name prefix when the redirect is applied. For example, to redirect requests for ``ExamplePage.html``, the key prefix will be ``ExamplePage.html``. To redirect request for all pages with the prefix ``docs/``, the key prefix will be ``/docs``, which identifies all objects in the docs/ folder. Required when the parent element ``Condition`` is specified and sibling ``HttpErrorCodeReturnedEquals`` is not specified. If both conditions are specified, both must be true for the redirect to be applied.
        """
        if http_error_code_returned_equals is not None:
            pulumi.set(__self__, "http_error_code_returned_equals", http_error_code_returned_equals)
        if key_prefix_equals is not None:
            pulumi.set(__self__, "key_prefix_equals", key_prefix_equals)

    @property
    @pulumi.getter(name="httpErrorCodeReturnedEquals")
    def http_error_code_returned_equals(self) -> Optional[str]:
        """
        The HTTP error code when the redirect is applied. In the event of an error, if the error code equals this value, then the specified redirect is applied. Required when parent element ``Condition`` is specified and sibling ``KeyPrefixEquals`` is not specified. If both are specified, then both must be true for the redirect to be applied.
        """
        return pulumi.get(self, "http_error_code_returned_equals")

    @property
    @pulumi.getter(name="keyPrefixEquals")
    def key_prefix_equals(self) -> Optional[str]:
        """
        The object key name prefix when the redirect is applied. For example, to redirect requests for ``ExamplePage.html``, the key prefix will be ``ExamplePage.html``. To redirect request for all pages with the prefix ``docs/``, the key prefix will be ``/docs``, which identifies all objects in the docs/ folder. Required when the parent element ``Condition`` is specified and sibling ``HttpErrorCodeReturnedEquals`` is not specified. If both conditions are specified, both must be true for the redirect to be applied.
        """
        return pulumi.get(self, "key_prefix_equals")


@pulumi.output_type
class RoutingRuleResponse(dict):
    """
    Definition of RoutingRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectRule":
            suggest = "redirect_rule"
        elif key == "routingRuleCondition":
            suggest = "routing_rule_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutingRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutingRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutingRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_rule: Optional['outputs.RedirectRuleResponse'] = None,
                 routing_rule_condition: Optional['outputs.RoutingRuleConditionResponse'] = None):
        """
        Definition of RoutingRule
        :param 'RedirectRuleResponse' redirect_rule: Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return. Specifies how requests are redirected. In the event of an error, you can specify a different error code to return.
        :param 'RoutingRuleConditionResponse' routing_rule_condition: A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the ``/docs`` folder, redirect to the ``/documents`` folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error. A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the ``/docs`` folder, redirect to the ``/documents`` folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
        """
        if redirect_rule is not None:
            pulumi.set(__self__, "redirect_rule", redirect_rule)
        if routing_rule_condition is not None:
            pulumi.set(__self__, "routing_rule_condition", routing_rule_condition)

    @property
    @pulumi.getter(name="redirectRule")
    def redirect_rule(self) -> Optional['outputs.RedirectRuleResponse']:
        """
        Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return. Specifies how requests are redirected. In the event of an error, you can specify a different error code to return.
        """
        return pulumi.get(self, "redirect_rule")

    @property
    @pulumi.getter(name="routingRuleCondition")
    def routing_rule_condition(self) -> Optional['outputs.RoutingRuleConditionResponse']:
        """
        A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the ``/docs`` folder, redirect to the ``/documents`` folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error. A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the ``/docs`` folder, redirect to the ``/documents`` folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
        """
        return pulumi.get(self, "routing_rule_condition")


@pulumi.output_type
class RuleDefinitionResponse(dict):
    """
    Definition of RuleDefinition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchAttributes":
            suggest = "match_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence[str]] = None,
                 match_attributes: Optional['outputs.MatchAttributesResponse'] = None):
        """
        Definition of RuleDefinition
        :param Sequence[str] actions: Property actions
        :param 'MatchAttributesResponse' match_attributes: Property matchAttributes
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if match_attributes is not None:
            pulumi.set(__self__, "match_attributes", match_attributes)

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Property actions
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="matchAttributes")
    def match_attributes(self) -> Optional['outputs.MatchAttributesResponse']:
        """
        Property matchAttributes
        """
        return pulumi.get(self, "match_attributes")


@pulumi.output_type
class RuleGroupResponse(dict):
    """
    Definition of RuleGroup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceSets":
            suggest = "reference_sets"
        elif key == "ruleVariables":
            suggest = "rule_variables"
        elif key == "rulesSource":
            suggest = "rules_source"
        elif key == "statefulRuleOptions":
            suggest = "stateful_rule_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_sets: Optional['outputs.ReferenceSetsResponse'] = None,
                 rule_variables: Optional['outputs.RuleVariablesResponse'] = None,
                 rules_source: Optional['outputs.RulesSourceResponse'] = None,
                 stateful_rule_options: Optional['outputs.StatefulRuleOptionsResponse'] = None):
        """
        Definition of RuleGroup
        :param 'ReferenceSetsResponse' reference_sets: Property referenceSets
        :param 'RuleVariablesResponse' rule_variables: Property ruleVariables
        :param 'RulesSourceResponse' rules_source: Property rulesSource
        :param 'StatefulRuleOptionsResponse' stateful_rule_options: Property statefulRuleOptions
        """
        if reference_sets is not None:
            pulumi.set(__self__, "reference_sets", reference_sets)
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)
        if rules_source is not None:
            pulumi.set(__self__, "rules_source", rules_source)
        if stateful_rule_options is not None:
            pulumi.set(__self__, "stateful_rule_options", stateful_rule_options)

    @property
    @pulumi.getter(name="referenceSets")
    def reference_sets(self) -> Optional['outputs.ReferenceSetsResponse']:
        """
        Property referenceSets
        """
        return pulumi.get(self, "reference_sets")

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional['outputs.RuleVariablesResponse']:
        """
        Property ruleVariables
        """
        return pulumi.get(self, "rule_variables")

    @property
    @pulumi.getter(name="rulesSource")
    def rules_source(self) -> Optional['outputs.RulesSourceResponse']:
        """
        Property rulesSource
        """
        return pulumi.get(self, "rules_source")

    @property
    @pulumi.getter(name="statefulRuleOptions")
    def stateful_rule_options(self) -> Optional['outputs.StatefulRuleOptionsResponse']:
        """
        Property statefulRuleOptions
        """
        return pulumi.get(self, "stateful_rule_options")


@pulumi.output_type
class RuleOptionResponse(dict):
    """
    Definition of RuleOption
    """
    def __init__(__self__, *,
                 keyword: Optional[str] = None,
                 settings: Optional[Sequence[str]] = None):
        """
        Definition of RuleOption
        :param str keyword: Property keyword
        :param Sequence[str] settings: Property settings
        """
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def keyword(self) -> Optional[str]:
        """
        Property keyword
        """
        return pulumi.get(self, "keyword")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Sequence[str]]:
        """
        Property settings
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class RuleResponse(dict):
    """
    Definition of Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abortIncompleteMultipartUpload":
            suggest = "abort_incomplete_multipart_upload"
        elif key == "expirationDate":
            suggest = "expiration_date"
        elif key == "expirationInDays":
            suggest = "expiration_in_days"
        elif key == "expiredObjectDeleteMarker":
            suggest = "expired_object_delete_marker"
        elif key == "noncurrentVersionExpiration":
            suggest = "noncurrent_version_expiration"
        elif key == "noncurrentVersionExpirationInDays":
            suggest = "noncurrent_version_expiration_in_days"
        elif key == "noncurrentVersionTransition":
            suggest = "noncurrent_version_transition"
        elif key == "noncurrentVersionTransitions":
            suggest = "noncurrent_version_transitions"
        elif key == "objectSizeGreaterThan":
            suggest = "object_size_greater_than"
        elif key == "objectSizeLessThan":
            suggest = "object_size_less_than"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 abort_incomplete_multipart_upload: Optional['outputs.AbortIncompleteMultipartUploadResponse'] = None,
                 expiration_date: Optional[str] = None,
                 expiration_in_days: Optional[int] = None,
                 expired_object_delete_marker: Optional[bool] = None,
                 id: Optional[str] = None,
                 noncurrent_version_expiration: Optional['outputs.NoncurrentVersionExpirationResponse'] = None,
                 noncurrent_version_expiration_in_days: Optional[int] = None,
                 noncurrent_version_transition: Optional['outputs.NoncurrentVersionTransitionResponse'] = None,
                 noncurrent_version_transitions: Optional[Sequence['outputs.NoncurrentVersionTransitionResponse']] = None,
                 object_size_greater_than: Optional[str] = None,
                 object_size_less_than: Optional[str] = None,
                 prefix: Optional[str] = None,
                 status: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.TagFilterResponse']] = None,
                 transition: Optional['outputs.TransitionResponse'] = None,
                 transitions: Optional[Sequence['outputs.TransitionResponse']] = None):
        """
        Definition of Rule
        :param 'AbortIncompleteMultipartUploadResponse' abort_incomplete_multipart_upload: Specifies a lifecycle rule that stops incomplete multipart uploads to an Amazon S3 bucket. Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. For more information, see [Stopping Incomplete Multipart Uploads Using a Bucket Lifecycle Policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the *Amazon S3 User Guide*.
        :param str expiration_date: Indicates when objects are deleted from Amazon S3 and Amazon S3 Glacier. The date value must be in ISO 8601 format. The time is always midnight UTC. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time. The date value in ISO 8601 format. The timezone is always UTC. (YYYY-MM-DDThh:mm:ssZ)
        :param int expiration_in_days: Indicates the number of days after creation when objects are deleted from Amazon S3 and Amazon S3 Glacier. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time.
        :param bool expired_object_delete_marker: Indicates whether Amazon S3 will remove a delete marker without any noncurrent versions. If set to true, the delete marker will be removed if there are no noncurrent versions. This cannot be specified with ``ExpirationInDays``, ``ExpirationDate``, or ``TagFilters``.
        :param str id: Unique identifier for the rule. The value can't be longer than 255 characters.
        :param 'NoncurrentVersionExpirationResponse' noncurrent_version_expiration: Specifies when noncurrent object versions expire. Upon expiration, S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that S3 delete noncurrent object versions at a specific period in the object's lifetime. Specifies when noncurrent object versions expire. Upon expiration, S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that S3 delete noncurrent object versions at a specific period in the object's lifetime. For more information about setting a lifecycle rule configuration, see [AWS::S3::Bucket Rule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-lifecycleconfig-rule.html).
        :param int noncurrent_version_expiration_in_days: (Deprecated.) For buckets with versioning enabled (or suspended), specifies the time, in days, between when a new version of the object is uploaded to the bucket and when old versions of the object expire. When object versions expire, Amazon S3 permanently deletes them. If you specify a transition and expiration time, the expiration time must be later than the transition time.
        :param 'NoncurrentVersionTransitionResponse' noncurrent_version_transition: (Deprecated.) For buckets with versioning enabled (or suspended), specifies when non-current objects transition to a specified storage class. If you specify a transition and expiration time, the expiration time must be later than the transition time. If you specify this property, don't specify the ``NoncurrentVersionTransitions`` property. Container for the transition rule that describes when noncurrent objects transition to the ``STANDARD_IA``, ``ONEZONE_IA``, ``INTELLIGENT_TIERING``, ``GLACIER_IR``, ``GLACIER``, or ``DEEP_ARCHIVE`` storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the ``STANDARD_IA``, ``ONEZONE_IA``, ``INTELLIGENT_TIERING``, ``GLACIER_IR``, ``GLACIER``, or ``DEEP_ARCHIVE`` storage class at a specific period in the object's lifetime. If you specify this property, don't specify the ``NoncurrentVersionTransitions`` property.
        :param Sequence['NoncurrentVersionTransitionResponse'] noncurrent_version_transitions: For buckets with versioning enabled (or suspended), one or more transition rules that specify when non-current objects transition to a specified storage class. If you specify a transition and expiration time, the expiration time must be later than the transition time. If you specify this property, don't specify the ``NoncurrentVersionTransition`` property.
        :param str object_size_greater_than: Specifies the minimum object size in bytes for this rule to apply to. Objects must be larger than this value in bytes. For more information about size based rules, see [Lifecycle configuration using size-based rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-configuration-examples.html#lc-size-rules) in the *Amazon S3 User Guide*.
        :param str object_size_less_than: Specifies the maximum object size in bytes for this rule to apply to. Objects must be smaller than this value in bytes. For more information about sized based rules, see [Lifecycle configuration using size-based rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-configuration-examples.html#lc-size-rules) in the *Amazon S3 User Guide*.
        :param str prefix: Object key prefix that identifies one or more objects to which this rule applies.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        :param str status: If ``Enabled``, the rule is currently being applied. If ``Disabled``, the rule is not currently being applied.
        :param Sequence['TagFilterResponse'] tag_filters: Tags to use to identify a subset of objects to which the lifecycle rule applies.
        :param 'TransitionResponse' transition: (Deprecated.) Specifies when an object transitions to a specified storage class. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time. If you specify this property, don't specify the ``Transitions`` property. Specifies when an object transitions to a specified storage class. For more information about Amazon S3 lifecycle configuration rules, see [Transitioning Objects Using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html) in the *Amazon S3 User Guide*.
        :param Sequence['TransitionResponse'] transitions: One or more transition rules that specify when an object transitions to a specified storage class. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time. If you specify this property, don't specify the ``Transition`` property.
        """
        if abort_incomplete_multipart_upload is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload", abort_incomplete_multipart_upload)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if expiration_in_days is not None:
            pulumi.set(__self__, "expiration_in_days", expiration_in_days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if noncurrent_version_expiration_in_days is not None:
            pulumi.set(__self__, "noncurrent_version_expiration_in_days", noncurrent_version_expiration_in_days)
        if noncurrent_version_transition is not None:
            pulumi.set(__self__, "noncurrent_version_transition", noncurrent_version_transition)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if object_size_greater_than is not None:
            pulumi.set(__self__, "object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            pulumi.set(__self__, "object_size_less_than", object_size_less_than)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if transition is not None:
            pulumi.set(__self__, "transition", transition)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUpload")
    def abort_incomplete_multipart_upload(self) -> Optional['outputs.AbortIncompleteMultipartUploadResponse']:
        """
        Specifies a lifecycle rule that stops incomplete multipart uploads to an Amazon S3 bucket. Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload. For more information, see [Stopping Incomplete Multipart Uploads Using a Bucket Lifecycle Policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html#mpu-abort-incomplete-mpu-lifecycle-config) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[str]:
        """
        Indicates when objects are deleted from Amazon S3 and Amazon S3 Glacier. The date value must be in ISO 8601 format. The time is always midnight UTC. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time. The date value in ISO 8601 format. The timezone is always UTC. (YYYY-MM-DDThh:mm:ssZ)
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="expirationInDays")
    def expiration_in_days(self) -> Optional[int]:
        """
        Indicates the number of days after creation when objects are deleted from Amazon S3 and Amazon S3 Glacier. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time.
        """
        return pulumi.get(self, "expiration_in_days")

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[bool]:
        """
        Indicates whether Amazon S3 will remove a delete marker without any noncurrent versions. If set to true, the delete marker will be removed if there are no noncurrent versions. This cannot be specified with ``ExpirationInDays``, ``ExpirationDate``, or ``TagFilters``.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier for the rule. The value can't be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional['outputs.NoncurrentVersionExpirationResponse']:
        """
        Specifies when noncurrent object versions expire. Upon expiration, S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that S3 delete noncurrent object versions at a specific period in the object's lifetime. Specifies when noncurrent object versions expire. Upon expiration, S3 permanently deletes the noncurrent object versions. You set this lifecycle configuration action on a bucket that has versioning enabled (or suspended) to request that S3 delete noncurrent object versions at a specific period in the object's lifetime. For more information about setting a lifecycle rule configuration, see [AWS::S3::Bucket Rule](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-lifecycleconfig-rule.html).
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @property
    @pulumi.getter(name="noncurrentVersionExpirationInDays")
    def noncurrent_version_expiration_in_days(self) -> Optional[int]:
        """
        (Deprecated.) For buckets with versioning enabled (or suspended), specifies the time, in days, between when a new version of the object is uploaded to the bucket and when old versions of the object expire. When object versions expire, Amazon S3 permanently deletes them. If you specify a transition and expiration time, the expiration time must be later than the transition time.
        """
        return pulumi.get(self, "noncurrent_version_expiration_in_days")

    @property
    @pulumi.getter(name="noncurrentVersionTransition")
    def noncurrent_version_transition(self) -> Optional['outputs.NoncurrentVersionTransitionResponse']:
        """
        (Deprecated.) For buckets with versioning enabled (or suspended), specifies when non-current objects transition to a specified storage class. If you specify a transition and expiration time, the expiration time must be later than the transition time. If you specify this property, don't specify the ``NoncurrentVersionTransitions`` property. Container for the transition rule that describes when noncurrent objects transition to the ``STANDARD_IA``, ``ONEZONE_IA``, ``INTELLIGENT_TIERING``, ``GLACIER_IR``, ``GLACIER``, or ``DEEP_ARCHIVE`` storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the ``STANDARD_IA``, ``ONEZONE_IA``, ``INTELLIGENT_TIERING``, ``GLACIER_IR``, ``GLACIER``, or ``DEEP_ARCHIVE`` storage class at a specific period in the object's lifetime. If you specify this property, don't specify the ``NoncurrentVersionTransitions`` property.
        """
        return pulumi.get(self, "noncurrent_version_transition")

    @property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[Sequence['outputs.NoncurrentVersionTransitionResponse']]:
        """
        For buckets with versioning enabled (or suspended), one or more transition rules that specify when non-current objects transition to a specified storage class. If you specify a transition and expiration time, the expiration time must be later than the transition time. If you specify this property, don't specify the ``NoncurrentVersionTransition`` property.
        """
        return pulumi.get(self, "noncurrent_version_transitions")

    @property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[str]:
        """
        Specifies the minimum object size in bytes for this rule to apply to. Objects must be larger than this value in bytes. For more information about size based rules, see [Lifecycle configuration using size-based rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-configuration-examples.html#lc-size-rules) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "object_size_greater_than")

    @property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[str]:
        """
        Specifies the maximum object size in bytes for this rule to apply to. Objects must be smaller than this value in bytes. For more information about sized based rules, see [Lifecycle configuration using size-based rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/lifecycle-configuration-examples.html#lc-size-rules) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "object_size_less_than")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Object key prefix that identifies one or more objects to which this rule applies.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see [XML related object key constraints](https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html#object-key-xml-related-constraints).
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        If ``Enabled``, the rule is currently being applied. If ``Disabled``, the rule is not currently being applied.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.TagFilterResponse']]:
        """
        Tags to use to identify a subset of objects to which the lifecycle rule applies.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter
    def transition(self) -> Optional['outputs.TransitionResponse']:
        """
        (Deprecated.) Specifies when an object transitions to a specified storage class. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time. If you specify this property, don't specify the ``Transitions`` property. Specifies when an object transitions to a specified storage class. For more information about Amazon S3 lifecycle configuration rules, see [Transitioning Objects Using Amazon S3 Lifecycle](https://docs.aws.amazon.com/AmazonS3/latest/dev/lifecycle-transition-general-considerations.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "transition")

    @property
    @pulumi.getter
    def transitions(self) -> Optional[Sequence['outputs.TransitionResponse']]:
        """
        One or more transition rules that specify when an object transitions to a specified storage class. If you specify an expiration and transition time, you must use the same time unit for both properties (either in days or by date). The expiration time must also be later than the transition time. If you specify this property, don't specify the ``Transition`` property.
        """
        return pulumi.get(self, "transitions")


@pulumi.output_type
class RuleVariablesModelResponse(dict):
    """
    Definition of RuleVariables
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleVariables":
            suggest = "rule_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleVariablesModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleVariablesModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleVariablesModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_variables: Optional[Mapping[str, 'outputs.IPSetResponse']] = None):
        """
        Definition of RuleVariables
        :param Mapping[str, 'IPSetResponse'] rule_variables: Property ruleVariables
        """
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[Mapping[str, 'outputs.IPSetResponse']]:
        """
        Property ruleVariables
        """
        return pulumi.get(self, "rule_variables")


@pulumi.output_type
class RuleVariablesResponse(dict):
    """
    Definition of RuleVariables
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipSets":
            suggest = "ip_sets"
        elif key == "portSets":
            suggest = "port_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleVariablesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleVariablesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleVariablesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_sets: Optional[Mapping[str, 'outputs.IPSetResponse']] = None,
                 port_sets: Optional[Mapping[str, 'outputs.PortSetResponse']] = None):
        """
        Definition of RuleVariables
        :param Mapping[str, 'IPSetResponse'] ip_sets: Property ipSets
        :param Mapping[str, 'PortSetResponse'] port_sets: Property portSets
        """
        if ip_sets is not None:
            pulumi.set(__self__, "ip_sets", ip_sets)
        if port_sets is not None:
            pulumi.set(__self__, "port_sets", port_sets)

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[Mapping[str, 'outputs.IPSetResponse']]:
        """
        Property ipSets
        """
        return pulumi.get(self, "ip_sets")

    @property
    @pulumi.getter(name="portSets")
    def port_sets(self) -> Optional[Mapping[str, 'outputs.PortSetResponse']]:
        """
        Property portSets
        """
        return pulumi.get(self, "port_sets")


@pulumi.output_type
class RulesSourceListResponse(dict):
    """
    Definition of RulesSourceList
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generatedRulesType":
            suggest = "generated_rules_type"
        elif key == "targetTypes":
            suggest = "target_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesSourceListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesSourceListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesSourceListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generated_rules_type: Optional[str] = None,
                 target_types: Optional[Sequence[str]] = None,
                 targets: Optional[Sequence[str]] = None):
        """
        Definition of RulesSourceList
        :param str generated_rules_type: Property generatedRulesType
        :param Sequence[str] target_types: Property targetTypes
        :param Sequence[str] targets: Property targets
        """
        if generated_rules_type is not None:
            pulumi.set(__self__, "generated_rules_type", generated_rules_type)
        if target_types is not None:
            pulumi.set(__self__, "target_types", target_types)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter(name="generatedRulesType")
    def generated_rules_type(self) -> Optional[str]:
        """
        Property generatedRulesType
        """
        return pulumi.get(self, "generated_rules_type")

    @property
    @pulumi.getter(name="targetTypes")
    def target_types(self) -> Optional[Sequence[str]]:
        """
        Property targetTypes
        """
        return pulumi.get(self, "target_types")

    @property
    @pulumi.getter
    def targets(self) -> Optional[Sequence[str]]:
        """
        Property targets
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class RulesSourceResponse(dict):
    """
    Definition of RulesSource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rulesSourceList":
            suggest = "rules_source_list"
        elif key == "rulesString":
            suggest = "rules_string"
        elif key == "statefulRules":
            suggest = "stateful_rules"
        elif key == "statelessRulesAndCustomActions":
            suggest = "stateless_rules_and_custom_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rules_source_list: Optional['outputs.RulesSourceListResponse'] = None,
                 rules_string: Optional[str] = None,
                 stateful_rules: Optional[Sequence['outputs.StatefulRuleResponse']] = None,
                 stateless_rules_and_custom_actions: Optional['outputs.StatelessRulesAndCustomActionsResponse'] = None):
        """
        Definition of RulesSource
        :param 'RulesSourceListResponse' rules_source_list: Property rulesSourceList
        :param str rules_string: Property rulesString
        :param Sequence['StatefulRuleResponse'] stateful_rules: Property statefulRules
        :param 'StatelessRulesAndCustomActionsResponse' stateless_rules_and_custom_actions: Property statelessRulesAndCustomActions
        """
        if rules_source_list is not None:
            pulumi.set(__self__, "rules_source_list", rules_source_list)
        if rules_string is not None:
            pulumi.set(__self__, "rules_string", rules_string)
        if stateful_rules is not None:
            pulumi.set(__self__, "stateful_rules", stateful_rules)
        if stateless_rules_and_custom_actions is not None:
            pulumi.set(__self__, "stateless_rules_and_custom_actions", stateless_rules_and_custom_actions)

    @property
    @pulumi.getter(name="rulesSourceList")
    def rules_source_list(self) -> Optional['outputs.RulesSourceListResponse']:
        """
        Property rulesSourceList
        """
        return pulumi.get(self, "rules_source_list")

    @property
    @pulumi.getter(name="rulesString")
    def rules_string(self) -> Optional[str]:
        """
        Property rulesString
        """
        return pulumi.get(self, "rules_string")

    @property
    @pulumi.getter(name="statefulRules")
    def stateful_rules(self) -> Optional[Sequence['outputs.StatefulRuleResponse']]:
        """
        Property statefulRules
        """
        return pulumi.get(self, "stateful_rules")

    @property
    @pulumi.getter(name="statelessRulesAndCustomActions")
    def stateless_rules_and_custom_actions(self) -> Optional['outputs.StatelessRulesAndCustomActionsResponse']:
        """
        Property statelessRulesAndCustomActions
        """
        return pulumi.get(self, "stateless_rules_and_custom_actions")


@pulumi.output_type
class RuntimeManagementConfigResponse(dict):
    """
    Definition of RuntimeManagementConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeVersionArn":
            suggest = "runtime_version_arn"
        elif key == "updateRuntimeOn":
            suggest = "update_runtime_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeManagementConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeManagementConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeManagementConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 runtime_version_arn: Optional[str] = None,
                 update_runtime_on: Optional[str] = None):
        """
        Definition of RuntimeManagementConfig
        :param str runtime_version_arn: The ARN of the runtime version you want the function to use.  This is only required if you're using the *Manual* runtime update mode.
        :param str update_runtime_on: Specify the runtime update mode.  +   *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.  +   *FunctionUpdate* - LAM updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.  +   *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).    *Valid Values*: ``Auto`` | ``FunctionUpdate`` | ``Manual``
        """
        if runtime_version_arn is not None:
            pulumi.set(__self__, "runtime_version_arn", runtime_version_arn)
        if update_runtime_on is not None:
            pulumi.set(__self__, "update_runtime_on", update_runtime_on)

    @property
    @pulumi.getter(name="runtimeVersionArn")
    def runtime_version_arn(self) -> Optional[str]:
        """
        The ARN of the runtime version you want the function to use.  This is only required if you're using the *Manual* runtime update mode.
        """
        return pulumi.get(self, "runtime_version_arn")

    @property
    @pulumi.getter(name="updateRuntimeOn")
    def update_runtime_on(self) -> Optional[str]:
        """
        Specify the runtime update mode.  +   *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.  +   *FunctionUpdate* - LAM updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.  +   *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).    *Valid Values*: ``Auto`` | ``FunctionUpdate`` | ``Manual``
        """
        return pulumi.get(self, "update_runtime_on")


@pulumi.output_type
class RuntimePlatformResponse(dict):
    """
    Definition of RuntimePlatform
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuArchitecture":
            suggest = "cpu_architecture"
        elif key == "operatingSystemFamily":
            suggest = "operating_system_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimePlatformResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimePlatformResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimePlatformResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_architecture: Optional[str] = None,
                 operating_system_family: Optional[str] = None):
        """
        Definition of RuntimePlatform
        :param str cpu_architecture: The CPU architecture. You can run your Linux tasks on an ARM-based platform by setting the value to ``ARM64``. This option is available for tasks that run on Linux Amazon EC2 instance or Linux containers on Fargate.
        :param str operating_system_family: The operating system.
        """
        if cpu_architecture is not None:
            pulumi.set(__self__, "cpu_architecture", cpu_architecture)
        if operating_system_family is not None:
            pulumi.set(__self__, "operating_system_family", operating_system_family)

    @property
    @pulumi.getter(name="cpuArchitecture")
    def cpu_architecture(self) -> Optional[str]:
        """
        The CPU architecture. You can run your Linux tasks on an ARM-based platform by setting the value to ``ARM64``. This option is available for tasks that run on Linux Amazon EC2 instance or Linux containers on Fargate.
        """
        return pulumi.get(self, "cpu_architecture")

    @property
    @pulumi.getter(name="operatingSystemFamily")
    def operating_system_family(self) -> Optional[str]:
        """
        The operating system.
        """
        return pulumi.get(self, "operating_system_family")


@pulumi.output_type
class S3AccessPointPropertiesResponse(dict):
    """
    Definition of S3AccessPoint
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AccessPointPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AccessPointPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AccessPointPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsS3AccessPointPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of S3AccessPoint
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsS3AccessPointPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsS3AccessPointPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class S3BucketCriteriaForJobResponse(dict):
    """
    Definition of S3BucketCriteriaForJob
    """
    def __init__(__self__, *,
                 excludes: Optional['outputs.CriteriaBlockForJobResponse'] = None,
                 includes: Optional['outputs.CriteriaBlockForJobResponse'] = None):
        """
        Definition of S3BucketCriteriaForJob
        :param 'CriteriaBlockForJobResponse' excludes: <p>The property- and tag-based conditions that determine which buckets to exclude from the job.</p>
        :param 'CriteriaBlockForJobResponse' includes: <p>The property- and tag-based conditions that determine which buckets to include in the job.</p>
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional['outputs.CriteriaBlockForJobResponse']:
        """
        <p>The property- and tag-based conditions that determine which buckets to exclude from the job.</p>
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional['outputs.CriteriaBlockForJobResponse']:
        """
        <p>The property- and tag-based conditions that determine which buckets to include in the job.</p>
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class S3BucketDefinitionForJobResponse(dict):
    """
    Definition of S3BucketDefinitionForJob
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3BucketDefinitionForJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3BucketDefinitionForJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3BucketDefinitionForJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: Optional[str] = None,
                 buckets: Optional[Sequence[str]] = None):
        """
        Definition of S3BucketDefinitionForJob
        :param str account_id: <p>The unique identifier for the Amazon Web Services account that owns the buckets.</p>
        :param Sequence[str] buckets: <p>An array that lists the names of the buckets.</p>
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if buckets is not None:
            pulumi.set(__self__, "buckets", buckets)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        <p>The unique identifier for the Amazon Web Services account that owns the buckets.</p>
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def buckets(self) -> Optional[Sequence[str]]:
        """
        <p>An array that lists the names of the buckets.</p>
        """
        return pulumi.get(self, "buckets")


@pulumi.output_type
class S3BucketPolicyPropertiesResponse(dict):
    """
    Definition of S3BucketPolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3BucketPolicyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3BucketPolicyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3BucketPolicyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsS3BucketPolicyPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of S3BucketPolicy
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsS3BucketPolicyPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsS3BucketPolicyPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class S3BucketPropertiesResponse(dict):
    """
    Definition of S3Bucket
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3BucketPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3BucketPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3BucketPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsS3BucketPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of S3Bucket
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsS3BucketPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsS3BucketPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class S3BucketSourceResponse(dict):
    """
    Definition of S3BucketSource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Bucket":
            suggest = "s3_bucket"
        elif key == "s3BucketOwner":
            suggest = "s3_bucket_owner"
        elif key == "s3KeyPrefix":
            suggest = "s3_key_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3BucketSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3BucketSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3BucketSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_bucket: Optional[str] = None,
                 s3_bucket_owner: Optional[str] = None,
                 s3_key_prefix: Optional[str] = None):
        """
        Definition of S3BucketSource
        :param str s3_bucket: The S3 bucket that is being imported from.
        :param str s3_bucket_owner: The account number of the S3 bucket that is being imported from. If the bucket is owned by the requester this is optional.
        :param str s3_key_prefix: The key prefix shared by all S3 Objects that are being imported.
        """
        if s3_bucket is not None:
            pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_bucket_owner is not None:
            pulumi.set(__self__, "s3_bucket_owner", s3_bucket_owner)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> Optional[str]:
        """
        The S3 bucket that is being imported from.
        """
        return pulumi.get(self, "s3_bucket")

    @property
    @pulumi.getter(name="s3BucketOwner")
    def s3_bucket_owner(self) -> Optional[str]:
        """
        The account number of the S3 bucket that is being imported from. If the bucket is owned by the requester this is optional.
        """
        return pulumi.get(self, "s3_bucket_owner")

    @property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[str]:
        """
        The key prefix shared by all S3 Objects that are being imported.
        """
        return pulumi.get(self, "s3_key_prefix")


@pulumi.output_type
class S3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse(dict):
    """
    Definition of S3ControlMultiRegionAccessPointPolicyDocument
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsS3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of S3ControlMultiRegionAccessPointPolicyDocument
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsS3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsS3ControlMultiRegionAccessPointPolicyDocumentPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class S3KeyFilterResponse(dict):
    """
    Definition of S3KeyFilter
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.FilterRuleResponse']] = None):
        """
        Definition of S3KeyFilter
        :param Sequence['FilterRuleResponse'] rules: A list of containers for the key-value pair that defines the criteria for the filter rule.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.FilterRuleResponse']]:
        """
        A list of containers for the key-value pair that defines the criteria for the filter rule.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class S3LocationResponse(dict):
    """
    Definition of S3Location
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eTag":
            suggest = "e_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3LocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3LocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3LocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: Optional[str] = None,
                 e_tag: Optional[str] = None,
                 key: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Definition of S3Location
        :param str bucket: The name of the S3 bucket where the OpenAPI file is stored.
        :param str e_tag: The Amazon S3 ETag (a file checksum) of the OpenAPI file. If you don't specify a value, API Gateway skips ETag validation of your OpenAPI file.
        :param str key: The file name of the OpenAPI file (Amazon S3 object name).
        :param str version: For versioning-enabled buckets, a specific version of the OpenAPI file.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if e_tag is not None:
            pulumi.set(__self__, "e_tag", e_tag)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        The name of the S3 bucket where the OpenAPI file is stored.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="eTag")
    def e_tag(self) -> Optional[str]:
        """
        The Amazon S3 ETag (a file checksum) of the OpenAPI file. If you don't specify a value, API Gateway skips ETag validation of your OpenAPI file.
        """
        return pulumi.get(self, "e_tag")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The file name of the OpenAPI file (Amazon S3 object name).
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        For versioning-enabled buckets, a specific version of the OpenAPI file.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class S3LogsConfigResponse(dict):
    """
    Definition of S3LogsConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketOwnerAccess":
            suggest = "bucket_owner_access"
        elif key == "encryptionDisabled":
            suggest = "encryption_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3LogsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3LogsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3LogsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_owner_access: Optional['outputs.BucketOwnerAccessEnumValueResponse'] = None,
                 encryption_disabled: Optional[bool] = None,
                 location: Optional[str] = None,
                 status: Optional['outputs.LogsConfigStatusTypeEnumValueResponse'] = None):
        """
        Definition of S3LogsConfig
        :param 'BucketOwnerAccessEnumValueResponse' bucket_owner_access: Property bucketOwnerAccess
        :param bool encryption_disabled: <p> Set to true if you do not want your S3 build log output encrypted. By default S3 build logs are encrypted. </p>
        :param str location: <p> The ARN of an S3 bucket and the path prefix for S3 logs. If your Amazon S3 bucket name is <code>my-bucket</code>, and your path prefix is <code>build-log</code>, then acceptable formats are <code>my-bucket/build-log</code> or <code>arn:aws:s3:::my-bucket/build-log</code>. </p>
        :param 'LogsConfigStatusTypeEnumValueResponse' status: <p>The current status of the S3 build logs. Valid values are:</p> <ul> <li> <p> <code>ENABLED</code>: S3 build logs are enabled for this build project.</p> </li> <li> <p> <code>DISABLED</code>: S3 build logs are not enabled for this build project.</p> </li> </ul>
        """
        if bucket_owner_access is not None:
            pulumi.set(__self__, "bucket_owner_access", bucket_owner_access)
        if encryption_disabled is not None:
            pulumi.set(__self__, "encryption_disabled", encryption_disabled)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="bucketOwnerAccess")
    def bucket_owner_access(self) -> Optional['outputs.BucketOwnerAccessEnumValueResponse']:
        """
        Property bucketOwnerAccess
        """
        return pulumi.get(self, "bucket_owner_access")

    @property
    @pulumi.getter(name="encryptionDisabled")
    def encryption_disabled(self) -> Optional[bool]:
        """
        <p> Set to true if you do not want your S3 build log output encrypted. By default S3 build logs are encrypted. </p>
        """
        return pulumi.get(self, "encryption_disabled")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        <p> The ARN of an S3 bucket and the path prefix for S3 logs. If your Amazon S3 bucket name is <code>my-bucket</code>, and your path prefix is <code>build-log</code>, then acceptable formats are <code>my-bucket/build-log</code> or <code>arn:aws:s3:::my-bucket/build-log</code>. </p>
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.LogsConfigStatusTypeEnumValueResponse']:
        """
        <p>The current status of the S3 build logs. Valid values are:</p> <ul> <li> <p> <code>ENABLED</code>: S3 build logs are enabled for this build project.</p> </li> <li> <p> <code>DISABLED</code>: S3 build logs are not enabled for this build project.</p> </li> </ul>
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class S3OriginConfigResponse(dict):
    """
    Definition of S3OriginConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originAccessIdentity":
            suggest = "origin_access_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3OriginConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3OriginConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3OriginConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_access_identity: Optional[str] = None):
        """
        Definition of S3OriginConfig
        :param str origin_access_identity: The CloudFront origin access identity to associate with the origin. Use an origin access identity to configure the origin so that viewers can *only* access objects in an Amazon S3 bucket through CloudFront. The format of the value is: origin-access-identity/cloudfront/*ID-of-origin-access-identity*  where ``ID-of-origin-access-identity`` is the value that CloudFront returned in the ``ID`` element when you created the origin access identity. If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty ``OriginAccessIdentity`` element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty ``OriginAccessIdentity`` element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information about the origin access identity, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        """
        if origin_access_identity is not None:
            pulumi.set(__self__, "origin_access_identity", origin_access_identity)

    @property
    @pulumi.getter(name="originAccessIdentity")
    def origin_access_identity(self) -> Optional[str]:
        """
        The CloudFront origin access identity to associate with the origin. Use an origin access identity to configure the origin so that viewers can *only* access objects in an Amazon S3 bucket through CloudFront. The format of the value is: origin-access-identity/cloudfront/*ID-of-origin-access-identity*  where ``ID-of-origin-access-identity`` is the value that CloudFront returned in the ``ID`` element when you created the origin access identity. If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3 URL, specify an empty ``OriginAccessIdentity`` element. To delete the origin access identity from an existing distribution, update the distribution configuration and include an empty ``OriginAccessIdentity`` element. To replace the origin access identity, update the distribution configuration and specify the new origin access identity. For more information about the origin access identity, see [Serving Private Content through CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html) in the *Amazon CloudFront Developer Guide*.
        """
        return pulumi.get(self, "origin_access_identity")


@pulumi.output_type
class S3WordsListResponse(dict):
    """
    Definition of S3WordsList
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "objectKey":
            suggest = "object_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3WordsListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3WordsListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3WordsListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 object_key: Optional[str] = None):
        """
        Definition of S3WordsList
        :param str bucket_name: Property bucketName
        :param str object_key: Property objectKey
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if object_key is not None:
            pulumi.set(__self__, "object_key", object_key)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Property bucketName
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="objectKey")
    def object_key(self) -> Optional[str]:
        """
        Property objectKey
        """
        return pulumi.get(self, "object_key")


@pulumi.output_type
class SAMLIdpResponse(dict):
    """
    Definition of SAMLIdp
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityId":
            suggest = "entity_id"
        elif key == "metadataContent":
            suggest = "metadata_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SAMLIdpResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SAMLIdpResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SAMLIdpResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id: Optional[str] = None,
                 metadata_content: Optional[str] = None):
        """
        Definition of SAMLIdp
        :param str entity_id: <p>The unique entity ID of the application in the SAML identity provider.</p>
        :param str metadata_content: <p>The metadata of the SAML application, in XML format.</p>
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if metadata_content is not None:
            pulumi.set(__self__, "metadata_content", metadata_content)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        """
        <p>The unique entity ID of the application in the SAML identity provider.</p>
        """
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter(name="metadataContent")
    def metadata_content(self) -> Optional[str]:
        """
        <p>The metadata of the SAML application, in XML format.</p>
        """
        return pulumi.get(self, "metadata_content")


@pulumi.output_type
class SAMLOptionsOutputResponse(dict):
    """
    Definition of SAMLOptionsOutput
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rolesKey":
            suggest = "roles_key"
        elif key == "sessionTimeoutMinutes":
            suggest = "session_timeout_minutes"
        elif key == "subjectKey":
            suggest = "subject_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SAMLOptionsOutputResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SAMLOptionsOutputResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SAMLOptionsOutputResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 idp: Optional['outputs.SAMLIdpResponse'] = None,
                 roles_key: Optional[str] = None,
                 session_timeout_minutes: Optional[int] = None,
                 subject_key: Optional[str] = None):
        """
        Definition of SAMLOptionsOutput
        :param bool enabled: <p>True if SAML is enabled.</p>
        :param 'SAMLIdpResponse' idp: <p>Describes the SAML identity provider's information.</p>
        :param str roles_key: <p>The key used for matching the SAML roles attribute.</p>
        :param int session_timeout_minutes: <p>The duration, in minutes, after which a user session becomes inactive.</p>
        :param str subject_key: <p>The key used for matching the SAML subject attribute.</p>
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idp is not None:
            pulumi.set(__self__, "idp", idp)
        if roles_key is not None:
            pulumi.set(__self__, "roles_key", roles_key)
        if session_timeout_minutes is not None:
            pulumi.set(__self__, "session_timeout_minutes", session_timeout_minutes)
        if subject_key is not None:
            pulumi.set(__self__, "subject_key", subject_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        <p>True if SAML is enabled.</p>
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def idp(self) -> Optional['outputs.SAMLIdpResponse']:
        """
        <p>Describes the SAML identity provider's information.</p>
        """
        return pulumi.get(self, "idp")

    @property
    @pulumi.getter(name="rolesKey")
    def roles_key(self) -> Optional[str]:
        """
        <p>The key used for matching the SAML roles attribute.</p>
        """
        return pulumi.get(self, "roles_key")

    @property
    @pulumi.getter(name="sessionTimeoutMinutes")
    def session_timeout_minutes(self) -> Optional[int]:
        """
        <p>The duration, in minutes, after which a user session becomes inactive.</p>
        """
        return pulumi.get(self, "session_timeout_minutes")

    @property
    @pulumi.getter(name="subjectKey")
    def subject_key(self) -> Optional[str]:
        """
        <p>The key used for matching the SAML subject attribute.</p>
        """
        return pulumi.get(self, "subject_key")


@pulumi.output_type
class SSEDescriptionResponse(dict):
    """
    Definition of SSEDescription
    """
    def __init__(__self__, *,
                 status: Optional['outputs.SSEStatusEnumValueResponse'] = None):
        """
        Definition of SSEDescription
        :param 'SSEStatusEnumValueResponse' status: <p>The current state of server-side encryption:</p> <ul> <li> <p> <code>ENABLING</code> - Server-side encryption is being enabled.</p> </li> <li> <p> <code>ENABLED</code> - Server-side encryption is enabled.</p> </li> <li> <p> <code>DISABLING</code> - Server-side encryption is being disabled.</p> </li> <li> <p> <code>DISABLED</code> - Server-side encryption is disabled.</p> </li> </ul>
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.SSEStatusEnumValueResponse']:
        """
        <p>The current state of server-side encryption:</p> <ul> <li> <p> <code>ENABLING</code> - Server-side encryption is being enabled.</p> </li> <li> <p> <code>ENABLED</code> - Server-side encryption is enabled.</p> </li> <li> <p> <code>DISABLING</code> - Server-side encryption is being disabled.</p> </li> <li> <p> <code>DISABLED</code> - Server-side encryption is disabled.</p> </li> </ul>
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SSESpecificationResponse(dict):
    """
    Definition of SSESpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsMasterKeyId":
            suggest = "kms_master_key_id"
        elif key == "sseEnabled":
            suggest = "sse_enabled"
        elif key == "sseType":
            suggest = "sse_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SSESpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SSESpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SSESpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_master_key_id: Optional[str] = None,
                 sse_enabled: Optional[bool] = None,
                 sse_type: Optional[str] = None):
        """
        Definition of SSESpecification
        :param str kms_master_key_id: The KMS key that should be used for the KMS encryption. To specify a key, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note that you should only provide this parameter if the key is different from the default DynamoDB key ``alias/aws/dynamodb``.
        :param bool sse_enabled: Indicates whether server-side encryption is done using an AWS managed key or an AWS owned key. If enabled (true), server-side encryption type is set to ``KMS`` and an AWS managed key is used (KMS charges apply). If disabled (false) or not specified, server-side encryption is set to AWS owned key.
        :param str sse_type: Server-side encryption type. The only supported value is:  +   ``KMS`` - Server-side encryption that uses KMSlong. The key is stored in your account and is managed by KMS (KMS charges apply).
        """
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)
        if sse_enabled is not None:
            pulumi.set(__self__, "sse_enabled", sse_enabled)
        if sse_type is not None:
            pulumi.set(__self__, "sse_type", sse_type)

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[str]:
        """
        The KMS key that should be used for the KMS encryption. To specify a key, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note that you should only provide this parameter if the key is different from the default DynamoDB key ``alias/aws/dynamodb``.
        """
        return pulumi.get(self, "kms_master_key_id")

    @property
    @pulumi.getter(name="sseEnabled")
    def sse_enabled(self) -> Optional[bool]:
        """
        Indicates whether server-side encryption is done using an AWS managed key or an AWS owned key. If enabled (true), server-side encryption type is set to ``KMS`` and an AWS managed key is used (KMS charges apply). If disabled (false) or not specified, server-side encryption is set to AWS owned key.
        """
        return pulumi.get(self, "sse_enabled")

    @property
    @pulumi.getter(name="sseType")
    def sse_type(self) -> Optional[str]:
        """
        Server-side encryption type. The only supported value is:  +   ``KMS`` - Server-side encryption that uses KMSlong. The key is stored in your account and is managed by KMS (KMS charges apply).
        """
        return pulumi.get(self, "sse_type")


@pulumi.output_type
class SSEStatusEnumValueResponse(dict):
    """
    Definition of SSEStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of SSEStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SSETypeEnumValueResponse(dict):
    """
    Definition of SSETypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of SSETypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SageMakerAppPropertiesResponse(dict):
    """
    Definition of SageMakerApp
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SageMakerAppPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SageMakerAppPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SageMakerAppPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSageMakerAppPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SageMakerApp
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSageMakerAppPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSageMakerAppPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class SageMakerNotebookInstanceSummaryPropertiesResponse(dict):
    """
    Definition of SageMakerNotebookInstanceSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SageMakerNotebookInstanceSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SageMakerNotebookInstanceSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SageMakerNotebookInstanceSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSageMakerNotebookInstanceSummaryPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SageMakerNotebookInstanceSummary
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSageMakerNotebookInstanceSummaryPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSageMakerNotebookInstanceSummaryPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class ScaleDownBehaviorEnumValueResponse(dict):
    """
    Definition of ScaleDownBehaviorEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ScaleDownBehaviorEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ScalingConfigResponse(dict):
    """
    Definition of ScalingConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desiredSize":
            suggest = "desired_size"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 desired_size: Optional[int] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None):
        """
        Definition of ScalingConfig
        :param int desired_size: Property desiredSize
        :param int max_size: Property maxSize
        :param int min_size: Property minSize
        """
        if desired_size is not None:
            pulumi.set(__self__, "desired_size", desired_size)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)

    @property
    @pulumi.getter(name="desiredSize")
    def desired_size(self) -> Optional[int]:
        """
        Property desiredSize
        """
        return pulumi.get(self, "desired_size")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        """
        Property maxSize
        """
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        """
        Property minSize
        """
        return pulumi.get(self, "min_size")


@pulumi.output_type
class ScalingConfigurationResponse(dict):
    """
    Definition of ScalingConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPause":
            suggest = "auto_pause"
        elif key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minCapacity":
            suggest = "min_capacity"
        elif key == "secondsBeforeTimeout":
            suggest = "seconds_before_timeout"
        elif key == "secondsUntilAutoPause":
            suggest = "seconds_until_auto_pause"
        elif key == "timeoutAction":
            suggest = "timeout_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_pause: Optional[bool] = None,
                 max_capacity: Optional[int] = None,
                 min_capacity: Optional[int] = None,
                 seconds_before_timeout: Optional[int] = None,
                 seconds_until_auto_pause: Optional[int] = None,
                 timeout_action: Optional[str] = None):
        """
        Definition of ScalingConfiguration
        :param bool auto_pause: A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in serverless DB engine mode. A DB cluster can be paused only when it's idle (it has no connections).
        :param int max_capacity: The maximum capacity for an Aurora DB cluster in serverless DB engine mode.For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.The maximum capacity must be greater than or equal to the minimum capacity.
        :param int min_capacity: The minimum capacity for an Aurora DB cluster in serverless DB engine mode.For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.The minimum capacity must be less than or equal to the maximum capacity.
        :param int seconds_before_timeout: The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action.The default is 300.
        :param int seconds_until_auto_pause: The time, in seconds, before an Aurora DB cluster in serverless mode is paused.
        :param str timeout_action: The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange.ForceApplyCapacityChange sets the capacity to the specified value as soon as possible.RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the timeout period.For more information, see Autoscaling for Aurora Serverless v1 in the Amazon Aurora User Guide.
        """
        if auto_pause is not None:
            pulumi.set(__self__, "auto_pause", auto_pause)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)
        if seconds_before_timeout is not None:
            pulumi.set(__self__, "seconds_before_timeout", seconds_before_timeout)
        if seconds_until_auto_pause is not None:
            pulumi.set(__self__, "seconds_until_auto_pause", seconds_until_auto_pause)
        if timeout_action is not None:
            pulumi.set(__self__, "timeout_action", timeout_action)

    @property
    @pulumi.getter(name="autoPause")
    def auto_pause(self) -> Optional[bool]:
        """
        A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in serverless DB engine mode. A DB cluster can be paused only when it's idle (it has no connections).
        """
        return pulumi.get(self, "auto_pause")

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[int]:
        """
        The maximum capacity for an Aurora DB cluster in serverless DB engine mode.For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.The maximum capacity must be greater than or equal to the minimum capacity.
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[int]:
        """
        The minimum capacity for an Aurora DB cluster in serverless DB engine mode.For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.The minimum capacity must be less than or equal to the maximum capacity.
        """
        return pulumi.get(self, "min_capacity")

    @property
    @pulumi.getter(name="secondsBeforeTimeout")
    def seconds_before_timeout(self) -> Optional[int]:
        """
        The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action.The default is 300.
        """
        return pulumi.get(self, "seconds_before_timeout")

    @property
    @pulumi.getter(name="secondsUntilAutoPause")
    def seconds_until_auto_pause(self) -> Optional[int]:
        """
        The time, in seconds, before an Aurora DB cluster in serverless mode is paused.
        """
        return pulumi.get(self, "seconds_until_auto_pause")

    @property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> Optional[str]:
        """
        The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange.ForceApplyCapacityChange sets the capacity to the specified value as soon as possible.RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the timeout period.For more information, see Autoscaling for Aurora Serverless v1 in the Amazon Aurora User Guide.
        """
        return pulumi.get(self, "timeout_action")


@pulumi.output_type
class ScanStatusEnumValueResponse(dict):
    """
    Definition of ScanStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ScanStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecretResponse(dict):
    """
    Definition of Secret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueFrom":
            suggest = "value_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value_from: Optional[str] = None):
        """
        Definition of Secret
        :param str name: The name of the secret.
        :param str value_from: The secret to expose to the container. The supported values are either the full ARN of the ASMlong secret or the full ARN of the parameter in the SSM Parameter Store. For information about the require IAMlong permissions, see [Required IAM permissions for Amazon ECS secrets](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/specifying-sensitive-data-secrets.html#secrets-iam) (for Secrets Manager) or [Required IAM permissions for Amazon ECS secrets](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/specifying-sensitive-data-parameters.html) (for Systems Manager Parameter store) in the *Amazon Elastic Container Service Developer Guide*.  If the SSM Parameter Store parameter exists in the same Region as the task you're launching, then you can use either the full ARN or name of the parameter. If the parameter exists in a different Region, then the full ARN must be specified.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the secret.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional[str]:
        """
        The secret to expose to the container. The supported values are either the full ARN of the ASMlong secret or the full ARN of the parameter in the SSM Parameter Store. For information about the require IAMlong permissions, see [Required IAM permissions for Amazon ECS secrets](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/specifying-sensitive-data-secrets.html#secrets-iam) (for Secrets Manager) or [Required IAM permissions for Amazon ECS secrets](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/specifying-sensitive-data-parameters.html) (for Systems Manager Parameter store) in the *Amazon Elastic Container Service Developer Guide*.  If the SSM Parameter Store parameter exists in the same Region as the task you're launching, then you can use either the full ARN or name of the parameter. If the parameter exists in a different Region, then the full ARN must be specified.
        """
        return pulumi.get(self, "value_from")


@pulumi.output_type
class SecretsManagerResourcePolicyPropertiesResponse(dict):
    """
    Definition of SecretsManagerResourcePolicy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretsManagerResourcePolicyPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretsManagerResourcePolicyPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretsManagerResourcePolicyPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSecretsManagerResourcePolicyPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SecretsManagerResourcePolicy
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSecretsManagerResourcePolicyPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSecretsManagerResourcePolicyPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class SecretsManagerSecretPropertiesResponse(dict):
    """
    Definition of SecretsManagerSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretsManagerSecretPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretsManagerSecretPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretsManagerSecretPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSecretsManagerSecretPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SecretsManagerSecret
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSecretsManagerSecretPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSecretsManagerSecretPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class SecurityGroupMembershipResponse(dict):
    """
    Definition of SecurityGroupMembership
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIdentifier":
            suggest = "security_group_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupMembershipResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupMembershipResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupMembershipResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_identifier: Optional[str] = None,
                 status: Optional[str] = None):
        """
        Definition of SecurityGroupMembership
        :param str security_group_identifier: <p>The unique ID for this security group.</p>
        :param str status: <p>The status of this security group.</p>
        """
        if security_group_identifier is not None:
            pulumi.set(__self__, "security_group_identifier", security_group_identifier)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="securityGroupIdentifier")
    def security_group_identifier(self) -> Optional[str]:
        """
        <p>The unique ID for this security group.</p>
        """
        return pulumi.get(self, "security_group_identifier")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        <p>The status of this security group.</p>
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ServerSideEncryptionByDefaultResponse(dict):
    """
    Definition of ServerSideEncryptionByDefault
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsMasterKeyID":
            suggest = "kms_master_key_id"
        elif key == "sseAlgorithm":
            suggest = "sse_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSideEncryptionByDefaultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSideEncryptionByDefaultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSideEncryptionByDefaultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_master_key_id: Optional[str] = None,
                 sse_algorithm: Optional[str] = None):
        """
        Definition of ServerSideEncryptionByDefault
        :param str kms_master_key_id: AWS Key Management Service (KMS) customer AWS KMS key ID to use for the default encryption. This parameter is allowed if and only if ``SSEAlgorithm`` is set to ``aws:kms`` or ``aws:kms:dsse``. You can specify the key ID, key alias, or the Amazon Resource Name (ARN) of the KMS key.  +  Key ID: ``1234abcd-12ab-34cd-56ef-1234567890ab``   +  Key ARN: ``arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab``   +  Key Alias: ``alias/alias-name``    If you use a key ID, you can run into a LogDestination undeliverable error when creating a VPC flow log.  If you are using encryption with cross-account or AWS service operations you must use a fully qualified KMS key ARN. For more information, see [Using encryption for cross-account operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html#bucket-encryption-update-bucket-policy).  Amazon S3 only supports symmetric encryption KMS keys. For more information, see [Asymmetric keys in KMS](https://docs.aws.amazon.com//kms/latest/developerguide/symmetric-asymmetric.html) in the *Key Management Service Developer Guide*.
        :param str sse_algorithm: Server-side encryption algorithm to use for the default encryption.
        """
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)
        if sse_algorithm is not None:
            pulumi.set(__self__, "sse_algorithm", sse_algorithm)

    @property
    @pulumi.getter(name="kmsMasterKeyID")
    def kms_master_key_id(self) -> Optional[str]:
        """
        AWS Key Management Service (KMS) customer AWS KMS key ID to use for the default encryption. This parameter is allowed if and only if ``SSEAlgorithm`` is set to ``aws:kms`` or ``aws:kms:dsse``. You can specify the key ID, key alias, or the Amazon Resource Name (ARN) of the KMS key.  +  Key ID: ``1234abcd-12ab-34cd-56ef-1234567890ab``   +  Key ARN: ``arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab``   +  Key Alias: ``alias/alias-name``    If you use a key ID, you can run into a LogDestination undeliverable error when creating a VPC flow log.  If you are using encryption with cross-account or AWS service operations you must use a fully qualified KMS key ARN. For more information, see [Using encryption for cross-account operations](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html#bucket-encryption-update-bucket-policy).  Amazon S3 only supports symmetric encryption KMS keys. For more information, see [Asymmetric keys in KMS](https://docs.aws.amazon.com//kms/latest/developerguide/symmetric-asymmetric.html) in the *Key Management Service Developer Guide*.
        """
        return pulumi.get(self, "kms_master_key_id")

    @property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> Optional[str]:
        """
        Server-side encryption algorithm to use for the default encryption.
        """
        return pulumi.get(self, "sse_algorithm")


@pulumi.output_type
class ServerSideEncryptionRuleResponse(dict):
    """
    Definition of ServerSideEncryptionRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketKeyEnabled":
            suggest = "bucket_key_enabled"
        elif key == "serverSideEncryptionByDefault":
            suggest = "server_side_encryption_by_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerSideEncryptionRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerSideEncryptionRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerSideEncryptionRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_key_enabled: Optional[bool] = None,
                 server_side_encryption_by_default: Optional['outputs.ServerSideEncryptionByDefaultResponse'] = None):
        """
        Definition of ServerSideEncryptionRule
        :param bool bucket_key_enabled: Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the ``BucketKeyEnabled`` element to ``true`` causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled. For more information, see [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) in the *Amazon S3 User Guide*.
        :param 'ServerSideEncryptionByDefaultResponse' server_side_encryption_by_default: Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied. Describes the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied. If you don't specify a customer managed key at configuration, Amazon S3 automatically creates an AWS KMS key in your AWS account the first time that you add an object encrypted with SSE-KMS to a bucket. By default, Amazon S3 uses this KMS key for SSE-KMS. For more information, see [PUT Bucket encryption](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html) in the *Amazon S3 API Reference*.
        """
        if bucket_key_enabled is not None:
            pulumi.set(__self__, "bucket_key_enabled", bucket_key_enabled)
        if server_side_encryption_by_default is not None:
            pulumi.set(__self__, "server_side_encryption_by_default", server_side_encryption_by_default)

    @property
    @pulumi.getter(name="bucketKeyEnabled")
    def bucket_key_enabled(self) -> Optional[bool]:
        """
        Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the ``BucketKeyEnabled`` element to ``true`` causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled. For more information, see [Amazon S3 Bucket Keys](https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-key.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "bucket_key_enabled")

    @property
    @pulumi.getter(name="serverSideEncryptionByDefault")
    def server_side_encryption_by_default(self) -> Optional['outputs.ServerSideEncryptionByDefaultResponse']:
        """
        Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied. Describes the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied. If you don't specify a customer managed key at configuration, Amazon S3 automatically creates an AWS KMS key in your AWS account the first time that you add an object encrypted with SSE-KMS to a bucket. By default, Amazon S3 uses this KMS key for SSE-KMS. For more information, see [PUT Bucket encryption](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTencryption.html) in the *Amazon S3 API Reference*.
        """
        return pulumi.get(self, "server_side_encryption_by_default")


@pulumi.output_type
class ServerTypeEnumValueResponse(dict):
    """
    Definition of ServerTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of ServerTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServerlessV2ScalingConfigurationResponse(dict):
    """
    Definition of ServerlessV2ScalingConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minCapacity":
            suggest = "min_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerlessV2ScalingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerlessV2ScalingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerlessV2ScalingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: Optional[float] = None,
                 min_capacity: Optional[float] = None):
        """
        Definition of ServerlessV2ScalingConfiguration
        :param float max_capacity: The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 128.
        :param float min_capacity: The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0.5.
        """
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[float]:
        """
        The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 128.
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[float]:
        """
        The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0.5.
        """
        return pulumi.get(self, "min_capacity")


@pulumi.output_type
class ServiceConnectClientAliasResponse(dict):
    """
    Definition of ServiceConnectClientAlias
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceConnectClientAliasResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceConnectClientAliasResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceConnectClientAliasResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: Optional[str] = None,
                 port: Optional[int] = None):
        """
        Definition of ServiceConnectClientAlias
        :param str dns_name: The ``dnsName`` is the name that you use in the applications of client tasks to connect to this service. The name must be a valid DNS name but doesn't need to be fully-qualified. The name can include up to 127 characters. The name can include lowercase letters, numbers, underscores (_), hyphens (-), and periods (.). The name can't start with a hyphen. If this parameter isn't specified, the default value of ``discoveryName.namespace`` is used. If the ``discoveryName`` isn't specified, the port mapping name from the task definition is used in ``portName.namespace``. To avoid changing your applications in client Amazon ECS services, set this to the same name that the client application uses by default. For example, a few common names are ``database``, ``db``, or the lowercase name of a database, such as ``mysql`` or ``redis``. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param int port: The listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace. To avoid changing your applications in client Amazon ECS services, set this to the same port that the client application uses by default. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[str]:
        """
        The ``dnsName`` is the name that you use in the applications of client tasks to connect to this service. The name must be a valid DNS name but doesn't need to be fully-qualified. The name can include up to 127 characters. The name can include lowercase letters, numbers, underscores (_), hyphens (-), and periods (.). The name can't start with a hyphen. If this parameter isn't specified, the default value of ``discoveryName.namespace`` is used. If the ``discoveryName`` isn't specified, the port mapping name from the task definition is used in ``portName.namespace``. To avoid changing your applications in client Amazon ECS services, set this to the same name that the client application uses by default. For example, a few common names are ``database``, ``db``, or the lowercase name of a database, such as ``mysql`` or ``redis``. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace. To avoid changing your applications in client Amazon ECS services, set this to the same port that the client application uses by default. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ServiceConnectConfigurationResponse(dict):
    """
    Definition of ServiceConnectConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logConfiguration":
            suggest = "log_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceConnectConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceConnectConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceConnectConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 log_configuration: Optional['outputs.LogConfigurationResponse'] = None,
                 namespace: Optional[str] = None,
                 services: Optional[Sequence['outputs.ServiceConnectServiceResponse']] = None):
        """
        Definition of ServiceConnectConfiguration
        :param bool enabled: Specifies whether to use Service Connect with this service.
        :param 'LogConfigurationResponse' log_configuration: The log configuration for the container. This parameter maps to ``LogConfig`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--log-driver`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/run/). By default, containers use the same logging driver that the Docker daemon uses. However, the container might use a different logging driver than the Docker daemon by specifying a log driver configuration in the container definition. For more information about the options for different supported log drivers, see [Configure logging drivers](https://docs.aws.amazon.com/https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation. Understand the following when specifying a log configuration for your containers.  +  Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon. Additional log drivers may be available in future releases of the Amazon ECS container agent. For tasks on FARGATElong, the supported log drivers are ``awslogs``, ``splunk``, and ``awsfirelens``. For tasks hosted on Amazon EC2 instances, the supported log drivers are ``awslogs``, ``fluentd``, ``gelf``, ``json-file``, ``journald``, ``logentries``,``syslog``, ``splunk``, and ``awsfirelens``.  +  This parameter requires version 1.18 of the Docker Remote API or greater on your container instance.  +  For tasks that are hosted on Amazon EC2 instances, the Amazon ECS container agent must register the available logging drivers with the ``ECS_AVAILABLE_LOGGING_DRIVERS`` environment variable before containers placed on that instance can use these log configuration options. For more information, see [Amazon ECS container agent configuration](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the *Amazon Elastic Container Service Developer Guide*.  +  For tasks that are on FARGATElong, because you don't have access to the underlying infrastructure your tasks are hosted on, any additional software needed must be installed outside of the task. For example, the Fluentd output aggregators or a remote host running Logstash to send Gelf logs to. The log configuration for the container. This parameter maps to ``LogConfig`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--log-driver`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/run/). By default, containers use the same logging driver that the Docker daemon uses. However, the container might use a different logging driver than the Docker daemon by specifying a log driver configuration in the container definition. For more information about the options for different supported log drivers, see [Configure logging drivers](https://docs.aws.amazon.com/https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation. Understand the following when specifying a log configuration for your containers.  +  Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon. Additional log drivers may be available in future releases of the Amazon ECS container agent. For tasks on FARGATElong, the supported log drivers are ``awslogs``, ``splunk``, and ``awsfirelens``. For tasks hosted on Amazon EC2 instances, the supported log drivers are ``awslogs``, ``fluentd``, ``gelf``, ``json-file``, ``journald``, ``logentries``,``syslog``, ``splunk``, and ``awsfirelens``.  +  This parameter requires version 1.18 of the Docker Remote API or greater on your container instance.  +  For tasks that are hosted on Amazon EC2 instances, the Amazon ECS container agent must register the available logging drivers with the ``ECS_AVAILABLE_LOGGING_DRIVERS`` environment variable before containers placed on that instance can use these log configuration options. For more information, see [Amazon ECS container agent configuration](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the *Amazon Elastic Container Service Developer Guide*.  +  For tasks that are on FARGATElong, because you don't have access to the underlying infrastructure your tasks are hosted on, any additional software needed must be installed outside of the task. For example, the Fluentd output aggregators or a remote host running Logstash to send Gelf logs to.
        :param str namespace: The namespace name or full Amazon Resource Name (ARN) of the CMAPlong namespace for use with Service Connect. The namespace must be in the same AWS Region as the Amazon ECS service and cluster. The type of namespace doesn't affect Service Connect. For more information about CMAPlong, see [Working with Services](https://docs.aws.amazon.com/cloud-map/latest/dg/working-with-services.html) in the *Developer Guide*.
        :param Sequence['ServiceConnectServiceResponse'] services: The list of Service Connect service objects. These are names and aliases (also known as endpoints) that are used by other Amazon ECS services to connect to this service.  This field is not required for a 'client' Amazon ECS service that's a member of a namespace only to connect to other services within the namespace. An example of this would be a frontend application that accepts incoming requests from either a load balancer that's attached to the service or by other means. An object selects a port from the task definition, assigns a name for the CMAPlong service, and a list of aliases (endpoints) and ports for client applications to refer to this service.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_configuration is not None:
            pulumi.set(__self__, "log_configuration", log_configuration)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether to use Service Connect with this service.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logConfiguration")
    def log_configuration(self) -> Optional['outputs.LogConfigurationResponse']:
        """
        The log configuration for the container. This parameter maps to ``LogConfig`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--log-driver`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/run/). By default, containers use the same logging driver that the Docker daemon uses. However, the container might use a different logging driver than the Docker daemon by specifying a log driver configuration in the container definition. For more information about the options for different supported log drivers, see [Configure logging drivers](https://docs.aws.amazon.com/https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation. Understand the following when specifying a log configuration for your containers.  +  Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon. Additional log drivers may be available in future releases of the Amazon ECS container agent. For tasks on FARGATElong, the supported log drivers are ``awslogs``, ``splunk``, and ``awsfirelens``. For tasks hosted on Amazon EC2 instances, the supported log drivers are ``awslogs``, ``fluentd``, ``gelf``, ``json-file``, ``journald``, ``logentries``,``syslog``, ``splunk``, and ``awsfirelens``.  +  This parameter requires version 1.18 of the Docker Remote API or greater on your container instance.  +  For tasks that are hosted on Amazon EC2 instances, the Amazon ECS container agent must register the available logging drivers with the ``ECS_AVAILABLE_LOGGING_DRIVERS`` environment variable before containers placed on that instance can use these log configuration options. For more information, see [Amazon ECS container agent configuration](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the *Amazon Elastic Container Service Developer Guide*.  +  For tasks that are on FARGATElong, because you don't have access to the underlying infrastructure your tasks are hosted on, any additional software needed must be installed outside of the task. For example, the Fluentd output aggregators or a remote host running Logstash to send Gelf logs to. The log configuration for the container. This parameter maps to ``LogConfig`` in the [Create a container](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/#operation/ContainerCreate) section of the [Docker Remote API](https://docs.aws.amazon.com/https://docs.docker.com/engine/api/v1.35/) and the ``--log-driver`` option to [docker run](https://docs.aws.amazon.com/https://docs.docker.com/engine/reference/commandline/run/). By default, containers use the same logging driver that the Docker daemon uses. However, the container might use a different logging driver than the Docker daemon by specifying a log driver configuration in the container definition. For more information about the options for different supported log drivers, see [Configure logging drivers](https://docs.aws.amazon.com/https://docs.docker.com/engine/admin/logging/overview/) in the Docker documentation. Understand the following when specifying a log configuration for your containers.  +  Amazon ECS currently supports a subset of the logging drivers available to the Docker daemon. Additional log drivers may be available in future releases of the Amazon ECS container agent. For tasks on FARGATElong, the supported log drivers are ``awslogs``, ``splunk``, and ``awsfirelens``. For tasks hosted on Amazon EC2 instances, the supported log drivers are ``awslogs``, ``fluentd``, ``gelf``, ``json-file``, ``journald``, ``logentries``,``syslog``, ``splunk``, and ``awsfirelens``.  +  This parameter requires version 1.18 of the Docker Remote API or greater on your container instance.  +  For tasks that are hosted on Amazon EC2 instances, the Amazon ECS container agent must register the available logging drivers with the ``ECS_AVAILABLE_LOGGING_DRIVERS`` environment variable before containers placed on that instance can use these log configuration options. For more information, see [Amazon ECS container agent configuration](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html) in the *Amazon Elastic Container Service Developer Guide*.  +  For tasks that are on FARGATElong, because you don't have access to the underlying infrastructure your tasks are hosted on, any additional software needed must be installed outside of the task. For example, the Fluentd output aggregators or a remote host running Logstash to send Gelf logs to.
        """
        return pulumi.get(self, "log_configuration")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace name or full Amazon Resource Name (ARN) of the CMAPlong namespace for use with Service Connect. The namespace must be in the same AWS Region as the Amazon ECS service and cluster. The type of namespace doesn't affect Service Connect. For more information about CMAPlong, see [Working with Services](https://docs.aws.amazon.com/cloud-map/latest/dg/working-with-services.html) in the *Developer Guide*.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.ServiceConnectServiceResponse']]:
        """
        The list of Service Connect service objects. These are names and aliases (also known as endpoints) that are used by other Amazon ECS services to connect to this service.  This field is not required for a 'client' Amazon ECS service that's a member of a namespace only to connect to other services within the namespace. An example of this would be a frontend application that accepts incoming requests from either a load balancer that's attached to the service or by other means. An object selects a port from the task definition, assigns a name for the CMAPlong service, and a list of aliases (endpoints) and ports for client applications to refer to this service.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class ServiceConnectDefaultsResponse(dict):
    """
    Definition of ServiceConnectDefaults
    """
    def __init__(__self__, *,
                 namespace: Optional[str] = None):
        """
        Definition of ServiceConnectDefaults
        :param str namespace: The namespace name or full Amazon Resource Name (ARN) of the CMAPlong namespace that's used when you create a service and don't specify a Service Connect configuration. The namespace name can include up to 1024 characters. The name is case-sensitive. The name can't include hyphens (-), tilde (~), greater than (>), less than (<), or slash (/). If you enter an existing namespace name or ARN, then that namespace will be used. Any namespace type is supported. The namespace must be in this account and this AWS Region. If you enter a new name, a CMAPlong namespace will be created. Amazon ECS creates a CMAP namespace with the 'API calls' method of instance discovery only. This instance discovery method is the 'HTTP' namespace type in the CLIlong. Other types of instance discovery aren't used by Service Connect. If you update the cluster with an empty string ``''`` for the namespace name, the cluster configuration for Service Connect is removed. Note that the namespace will remain in CMAP and must be deleted separately. For more information about CMAPlong, see [Working with Services](https://docs.aws.amazon.com/cloud-map/latest/dg/working-with-services.html) in the *Developer Guide*.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace name or full Amazon Resource Name (ARN) of the CMAPlong namespace that's used when you create a service and don't specify a Service Connect configuration. The namespace name can include up to 1024 characters. The name is case-sensitive. The name can't include hyphens (-), tilde (~), greater than (>), less than (<), or slash (/). If you enter an existing namespace name or ARN, then that namespace will be used. Any namespace type is supported. The namespace must be in this account and this AWS Region. If you enter a new name, a CMAPlong namespace will be created. Amazon ECS creates a CMAP namespace with the 'API calls' method of instance discovery only. This instance discovery method is the 'HTTP' namespace type in the CLIlong. Other types of instance discovery aren't used by Service Connect. If you update the cluster with an empty string ``''`` for the namespace name, the cluster configuration for Service Connect is removed. Note that the namespace will remain in CMAP and must be deleted separately. For more information about CMAPlong, see [Working with Services](https://docs.aws.amazon.com/cloud-map/latest/dg/working-with-services.html) in the *Developer Guide*.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ServiceConnectServiceResponse(dict):
    """
    Definition of ServiceConnectService
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientAliases":
            suggest = "client_aliases"
        elif key == "discoveryName":
            suggest = "discovery_name"
        elif key == "ingressPortOverride":
            suggest = "ingress_port_override"
        elif key == "portName":
            suggest = "port_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceConnectServiceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceConnectServiceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceConnectServiceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_aliases: Optional[Sequence['outputs.ServiceConnectClientAliasResponse']] = None,
                 discovery_name: Optional[str] = None,
                 ingress_port_override: Optional[int] = None,
                 port_name: Optional[str] = None,
                 timeout: Optional['outputs.TimeoutConfigurationResponse'] = None,
                 tls: Optional['outputs.ServiceConnectTlsConfigurationResponse'] = None):
        """
        Definition of ServiceConnectService
        :param Sequence['ServiceConnectClientAliasResponse'] client_aliases: The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. Each alias ('endpoint') is a fully-qualified name and port number that other Amazon ECS tasks ('clients') can use to connect to this service. Each name and port mapping must be unique within the namespace. For each ``ServiceConnectService``, you must provide at least one ``clientAlias`` with one ``port``.
        :param str discovery_name: The ``discoveryName`` is the name of the new CMAP service that Amazon ECS creates for this Amazon ECS service. This must be unique within the CMAP namespace. The name can contain up to 64 characters. The name can include lowercase letters, numbers, underscores (_), and hyphens (-). The name can't start with a hyphen. If the ``discoveryName`` isn't specified, the port mapping name from the task definition is used in ``portName.namespace``.
        :param int ingress_port_override: The port number for the Service Connect proxy to listen on. Use the value of this field to bypass the proxy for traffic on the port number specified in the named ``portMapping`` in the task definition of this application, and then use it in your VPC security groups to allow traffic into the proxy for this Amazon ECS service. In ``awsvpc`` mode and Fargate, the default value is the container port number. The container port number is in the ``portMapping`` in the task definition. In bridge mode, the default value is the ephemeral port of the Service Connect proxy.
        :param str port_name: The ``portName`` must match the name of one of the ``portMappings`` from all the containers in the task definition of this Amazon ECS service.
        :param 'TimeoutConfigurationResponse' timeout: A reference to an object that represents the configured timeouts for Service Connect. An object that represents the timeout configurations for Service Connect.  If ``idleTimeout`` is set to a time that is less than ``perRequestTimeout``, the connection will close when the ``idleTimeout`` is reached and not the ``perRequestTimeout``.
        :param 'ServiceConnectTlsConfigurationResponse' tls: A reference to an object that represents a Transport Layer Security (TLS) configuration. An object that represents the configuration for Service Connect TLS.
        """
        if client_aliases is not None:
            pulumi.set(__self__, "client_aliases", client_aliases)
        if discovery_name is not None:
            pulumi.set(__self__, "discovery_name", discovery_name)
        if ingress_port_override is not None:
            pulumi.set(__self__, "ingress_port_override", ingress_port_override)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="clientAliases")
    def client_aliases(self) -> Optional[Sequence['outputs.ServiceConnectClientAliasResponse']]:
        """
        The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. Each alias ('endpoint') is a fully-qualified name and port number that other Amazon ECS tasks ('clients') can use to connect to this service. Each name and port mapping must be unique within the namespace. For each ``ServiceConnectService``, you must provide at least one ``clientAlias`` with one ``port``.
        """
        return pulumi.get(self, "client_aliases")

    @property
    @pulumi.getter(name="discoveryName")
    def discovery_name(self) -> Optional[str]:
        """
        The ``discoveryName`` is the name of the new CMAP service that Amazon ECS creates for this Amazon ECS service. This must be unique within the CMAP namespace. The name can contain up to 64 characters. The name can include lowercase letters, numbers, underscores (_), and hyphens (-). The name can't start with a hyphen. If the ``discoveryName`` isn't specified, the port mapping name from the task definition is used in ``portName.namespace``.
        """
        return pulumi.get(self, "discovery_name")

    @property
    @pulumi.getter(name="ingressPortOverride")
    def ingress_port_override(self) -> Optional[int]:
        """
        The port number for the Service Connect proxy to listen on. Use the value of this field to bypass the proxy for traffic on the port number specified in the named ``portMapping`` in the task definition of this application, and then use it in your VPC security groups to allow traffic into the proxy for this Amazon ECS service. In ``awsvpc`` mode and Fargate, the default value is the container port number. The container port number is in the ``portMapping`` in the task definition. In bridge mode, the default value is the ephemeral port of the Service Connect proxy.
        """
        return pulumi.get(self, "ingress_port_override")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        The ``portName`` must match the name of one of the ``portMappings`` from all the containers in the task definition of this Amazon ECS service.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter
    def timeout(self) -> Optional['outputs.TimeoutConfigurationResponse']:
        """
        A reference to an object that represents the configured timeouts for Service Connect. An object that represents the timeout configurations for Service Connect.  If ``idleTimeout`` is set to a time that is less than ``perRequestTimeout``, the connection will close when the ``idleTimeout`` is reached and not the ``perRequestTimeout``.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.ServiceConnectTlsConfigurationResponse']:
        """
        A reference to an object that represents a Transport Layer Security (TLS) configuration. An object that represents the configuration for Service Connect TLS.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class ServiceConnectTlsCertificateAuthorityResponse(dict):
    """
    Definition of ServiceConnectTlsCertificateAuthority
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsPcaAuthorityArn":
            suggest = "aws_pca_authority_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceConnectTlsCertificateAuthorityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceConnectTlsCertificateAuthorityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceConnectTlsCertificateAuthorityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_pca_authority_arn: Optional[str] = None):
        """
        Definition of ServiceConnectTlsCertificateAuthority
        :param str aws_pca_authority_arn: The ARN of the AWS Private Certificate Authority certificate.
        """
        if aws_pca_authority_arn is not None:
            pulumi.set(__self__, "aws_pca_authority_arn", aws_pca_authority_arn)

    @property
    @pulumi.getter(name="awsPcaAuthorityArn")
    def aws_pca_authority_arn(self) -> Optional[str]:
        """
        The ARN of the AWS Private Certificate Authority certificate.
        """
        return pulumi.get(self, "aws_pca_authority_arn")


@pulumi.output_type
class ServiceConnectTlsConfigurationResponse(dict):
    """
    Definition of ServiceConnectTlsConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuerCertificateAuthority":
            suggest = "issuer_certificate_authority"
        elif key == "kmsKey":
            suggest = "kms_key"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceConnectTlsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceConnectTlsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceConnectTlsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issuer_certificate_authority: Optional['outputs.ServiceConnectTlsCertificateAuthorityResponse'] = None,
                 kms_key: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        Definition of ServiceConnectTlsConfiguration
        :param 'ServiceConnectTlsCertificateAuthorityResponse' issuer_certificate_authority: The signer certificate authority. An object that represents the AWS Private Certificate Authority certificate.
        :param str kms_key: The AWS Key Management Service key.
        :param str role_arn: The Amazon Resource Name (ARN) of the IAM role that's associated with the Service Connect TLS.
        """
        if issuer_certificate_authority is not None:
            pulumi.set(__self__, "issuer_certificate_authority", issuer_certificate_authority)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="issuerCertificateAuthority")
    def issuer_certificate_authority(self) -> Optional['outputs.ServiceConnectTlsCertificateAuthorityResponse']:
        """
        The signer certificate authority. An object that represents the AWS Private Certificate Authority certificate.
        """
        return pulumi.get(self, "issuer_certificate_authority")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        """
        The AWS Key Management Service key.
        """
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the IAM role that's associated with the Service Connect TLS.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class ServiceManagedEBSVolumeConfigurationResponse(dict):
    """
    Definition of ServiceManagedEBSVolumeConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesystemType":
            suggest = "filesystem_type"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "sizeInGiB":
            suggest = "size_in_gi_b"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceManagedEBSVolumeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceManagedEBSVolumeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceManagedEBSVolumeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted: Optional[bool] = None,
                 filesystem_type: Optional[str] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 size_in_gi_b: Optional[int] = None,
                 snapshot_id: Optional[str] = None,
                 tag_specifications: Optional[Sequence['outputs.EBSTagSpecificationResponse']] = None,
                 throughput: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        Definition of ServiceManagedEBSVolumeConfiguration
        :param bool encrypted: Indicates whether the volume should be encrypted. If no value is specified, encryption is turned on by default. This parameter maps 1:1 with the ``Encrypted`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.
        :param str filesystem_type: The Linux filesystem type for the volume. For volumes created from a snapshot, you must specify the same filesystem type that the volume was using when the snapshot was created. If there is a filesystem type mismatch, the task will fail to start. The available filesystem types are ``ext3``, ``ext4``, and ``xfs``. If no value is specified, the ``xfs`` filesystem type is used by default.
        :param int iops: The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type.  +   ``gp3``: 3,000 - 16,000 IOPS  +   ``io1``: 100 - 64,000 IOPS  +   ``io2``: 100 - 256,000 IOPS   This parameter is required for ``io1`` and ``io2`` volume types. The default for ``gp3`` volumes is ``3,000 IOPS``. This parameter is not supported for ``st1``, ``sc1``, or ``standard`` volume types. This parameter maps 1:1 with the ``Iops`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.
        :param str kms_key_id: The Amazon Resource Name (ARN) identifier of the AWS Key Management Service key to use for Amazon EBS encryption. When encryption is turned on and no AWS Key Management Service key is specified, the default AWS managed key for Amazon EBS volumes is used. This parameter maps 1:1 with the ``KmsKeyId`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.   AWS authenticates the AWS Key Management Service key asynchronously. Therefore, if you specify an ID, alias, or ARN that is invalid, the action can appear to complete, but eventually fails.
        :param str role_arn: The ARN of the IAM role to associate with this volume. This is the Amazon ECS infrastructure IAM role that is used to manage your AWS infrastructure. We recommend using the Amazon ECS-managed ``AmazonECSInfrastructureRolePolicyForVolumes`` IAM policy with this role. For more information, see [Amazon ECS infrastructure IAM role](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/infrastructure_IAM_role.html) in the *Amazon ECS Developer Guide*.
        :param int size_in_gi_b: The size of the volume in GiB. You must specify either a volume size or a snapshot ID. If you specify a snapshot ID, the snapshot size is used for the volume size by default. You can optionally specify a volume size greater than or equal to the snapshot size. This parameter maps 1:1 with the ``Size`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*. The following are the supported volume size values for each volume type.  +   ``gp2`` and ``gp3``: 1-16,384  +   ``io1`` and ``io2``: 4-16,384  +   ``st1`` and ``sc1``: 125-16,384  +   ``standard``: 1-1,024
        :param str snapshot_id: The snapshot that Amazon ECS uses to create the volume. You must specify either a snapshot ID or a volume size. This parameter maps 1:1 with the ``SnapshotId`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.
        :param Sequence['EBSTagSpecificationResponse'] tag_specifications: The tags to apply to the volume. Amazon ECS applies service-managed tags by default. This parameter maps 1:1 with the ``TagSpecifications.N`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.
        :param int throughput: The throughput to provision for a volume, in MiB/s, with a maximum of 1,000 MiB/s. This parameter maps 1:1 with the ``Throughput`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.  This parameter is only supported for the ``gp3`` volume type.
        :param str volume_type: The volume type. This parameter maps 1:1 with the ``VolumeType`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html) in the *Amazon EC2 User Guide*. The following are the supported volume types.  +  General Purpose SSD: ``gp2``|``gp3``   +  Provisioned IOPS SSD: ``io1``|``io2``   +  Throughput Optimized HDD: ``st1``   +  Cold HDD: ``sc1``   +  Magnetic: ``standard``   The magnetic volume type is not supported on Fargate.
        """
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if filesystem_type is not None:
            pulumi.set(__self__, "filesystem_type", filesystem_type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if size_in_gi_b is not None:
            pulumi.set(__self__, "size_in_gi_b", size_in_gi_b)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Indicates whether the volume should be encrypted. If no value is specified, encryption is turned on by default. This parameter maps 1:1 with the ``Encrypted`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="filesystemType")
    def filesystem_type(self) -> Optional[str]:
        """
        The Linux filesystem type for the volume. For volumes created from a snapshot, you must specify the same filesystem type that the volume was using when the snapshot was created. If there is a filesystem type mismatch, the task will fail to start. The available filesystem types are ``ext3``, ``ext4``, and ``xfs``. If no value is specified, the ``xfs`` filesystem type is used by default.
        """
        return pulumi.get(self, "filesystem_type")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type.  +   ``gp3``: 3,000 - 16,000 IOPS  +   ``io1``: 100 - 64,000 IOPS  +   ``io2``: 100 - 256,000 IOPS   This parameter is required for ``io1`` and ``io2`` volume types. The default for ``gp3`` volumes is ``3,000 IOPS``. This parameter is not supported for ``st1``, ``sc1``, or ``standard`` volume types. This parameter maps 1:1 with the ``Iops`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) identifier of the AWS Key Management Service key to use for Amazon EBS encryption. When encryption is turned on and no AWS Key Management Service key is specified, the default AWS managed key for Amazon EBS volumes is used. This parameter maps 1:1 with the ``KmsKeyId`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.   AWS authenticates the AWS Key Management Service key asynchronously. Therefore, if you specify an ID, alias, or ARN that is invalid, the action can appear to complete, but eventually fails.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The ARN of the IAM role to associate with this volume. This is the Amazon ECS infrastructure IAM role that is used to manage your AWS infrastructure. We recommend using the Amazon ECS-managed ``AmazonECSInfrastructureRolePolicyForVolumes`` IAM policy with this role. For more information, see [Amazon ECS infrastructure IAM role](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/infrastructure_IAM_role.html) in the *Amazon ECS Developer Guide*.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="sizeInGiB")
    def size_in_gi_b(self) -> Optional[int]:
        """
        The size of the volume in GiB. You must specify either a volume size or a snapshot ID. If you specify a snapshot ID, the snapshot size is used for the volume size by default. You can optionally specify a volume size greater than or equal to the snapshot size. This parameter maps 1:1 with the ``Size`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*. The following are the supported volume size values for each volume type.  +   ``gp2`` and ``gp3``: 1-16,384  +   ``io1`` and ``io2``: 4-16,384  +   ``st1`` and ``sc1``: 125-16,384  +   ``standard``: 1-1,024
        """
        return pulumi.get(self, "size_in_gi_b")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The snapshot that Amazon ECS uses to create the volume. You must specify either a snapshot ID or a volume size. This parameter maps 1:1 with the ``SnapshotId`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.EBSTagSpecificationResponse']]:
        """
        The tags to apply to the volume. Amazon ECS applies service-managed tags by default. This parameter maps 1:1 with the ``TagSpecifications.N`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.
        """
        return pulumi.get(self, "tag_specifications")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        The throughput to provision for a volume, in MiB/s, with a maximum of 1,000 MiB/s. This parameter maps 1:1 with the ``Throughput`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*.  This parameter is only supported for the ``gp3`` volume type.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The volume type. This parameter maps 1:1 with the ``VolumeType`` parameter of the [CreateVolume API](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html) in the *Amazon EC2 API Reference*. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html) in the *Amazon EC2 User Guide*. The following are the supported volume types.  +  General Purpose SSD: ``gp2``|``gp3``   +  Provisioned IOPS SSD: ``io1``|``io2``   +  Throughput Optimized HDD: ``st1``   +  Cold HDD: ``sc1``   +  Magnetic: ``standard``   The magnetic volume type is not supported on Fargate.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ServiceRegistryResponse(dict):
    """
    Definition of ServiceRegistry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"
        elif key == "containerPort":
            suggest = "container_port"
        elif key == "registryArn":
            suggest = "registry_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceRegistryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceRegistryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceRegistryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: Optional[str] = None,
                 container_port: Optional[int] = None,
                 port: Optional[int] = None,
                 registry_arn: Optional[str] = None):
        """
        Definition of ServiceRegistry
        :param str container_name: The container name value to be used for your service discovery service. It's already specified in the task definition. If the task definition that your service task specifies uses the ``bridge`` or ``host`` network mode, you must specify a ``containerName`` and ``containerPort`` combination from the task definition. If the task definition that your service task specifies uses the ``awsvpc`` network mode and a type SRV DNS record is used, you must specify either a ``containerName`` and ``containerPort`` combination or a ``port`` value. However, you can't specify both.
        :param int container_port: The port value to be used for your service discovery service. It's already specified in the task definition. If the task definition your service task specifies uses the ``bridge`` or ``host`` network mode, you must specify a ``containerName`` and ``containerPort`` combination from the task definition. If the task definition your service task specifies uses the ``awsvpc`` network mode and a type SRV DNS record is used, you must specify either a ``containerName`` and ``containerPort`` combination or a ``port`` value. However, you can't specify both.
        :param int port: The port value used if your service discovery service specified an SRV record. This field might be used if both the ``awsvpc`` network mode and SRV records are used.
        :param str registry_arn: The Amazon Resource Name (ARN) of the service registry. The currently supported service registry is CMAP. For more information, see [CreateService](https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html).
        """
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if registry_arn is not None:
            pulumi.set(__self__, "registry_arn", registry_arn)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        The container name value to be used for your service discovery service. It's already specified in the task definition. If the task definition that your service task specifies uses the ``bridge`` or ``host`` network mode, you must specify a ``containerName`` and ``containerPort`` combination from the task definition. If the task definition that your service task specifies uses the ``awsvpc`` network mode and a type SRV DNS record is used, you must specify either a ``containerName`` and ``containerPort`` combination or a ``port`` value. However, you can't specify both.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[int]:
        """
        The port value to be used for your service discovery service. It's already specified in the task definition. If the task definition your service task specifies uses the ``bridge`` or ``host`` network mode, you must specify a ``containerName`` and ``containerPort`` combination from the task definition. If the task definition your service task specifies uses the ``awsvpc`` network mode and a type SRV DNS record is used, you must specify either a ``containerName`` and ``containerPort`` combination or a ``port`` value. However, you can't specify both.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port value used if your service discovery service specified an SRV record. This field might be used if both the ``awsvpc`` network mode and SRV records are used.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="registryArn")
    def registry_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the service registry. The currently supported service registry is CMAP. For more information, see [CreateService](https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html).
        """
        return pulumi.get(self, "registry_arn")


@pulumi.output_type
class ServiceSoftwareOptionsResponse(dict):
    """
    Definition of ServiceSoftwareOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automatedUpdateDate":
            suggest = "automated_update_date"
        elif key == "currentVersion":
            suggest = "current_version"
        elif key == "newVersion":
            suggest = "new_version"
        elif key == "optionalDeployment":
            suggest = "optional_deployment"
        elif key == "updateAvailable":
            suggest = "update_available"
        elif key == "updateStatus":
            suggest = "update_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceSoftwareOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceSoftwareOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceSoftwareOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated_update_date: Optional[str] = None,
                 cancellable: Optional[bool] = None,
                 current_version: Optional[str] = None,
                 description: Optional[str] = None,
                 new_version: Optional[str] = None,
                 optional_deployment: Optional[bool] = None,
                 update_available: Optional[bool] = None,
                 update_status: Optional['outputs.DeploymentStatusEnumValueResponse'] = None):
        """
        Definition of ServiceSoftwareOptions
        :param str automated_update_date: <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.</p>
        :param bool cancellable: <p> True if you're able to cancel your service software version update. False if you can't cancel your service software update.</p>
        :param str current_version: <p>The current service software version present on the domain.</p>
        :param str description: <p>A description of the service software update status.</p>
        :param str new_version: <p>The new service software version, if one is available.</p>
        :param bool optional_deployment: <p>True if a service software is never automatically updated. False if a service software is automatically updated after the automated update date.</p>
        :param bool update_available: <p>True if you're able to update your service software version. False if you can't update your service software version.</p>
        :param 'DeploymentStatusEnumValueResponse' update_status: <p>The status of your service software update.</p>
        """
        if automated_update_date is not None:
            pulumi.set(__self__, "automated_update_date", automated_update_date)
        if cancellable is not None:
            pulumi.set(__self__, "cancellable", cancellable)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if new_version is not None:
            pulumi.set(__self__, "new_version", new_version)
        if optional_deployment is not None:
            pulumi.set(__self__, "optional_deployment", optional_deployment)
        if update_available is not None:
            pulumi.set(__self__, "update_available", update_available)
        if update_status is not None:
            pulumi.set(__self__, "update_status", update_status)

    @property
    @pulumi.getter(name="automatedUpdateDate")
    def automated_update_date(self) -> Optional[str]:
        """
        <p>The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.</p>
        """
        return pulumi.get(self, "automated_update_date")

    @property
    @pulumi.getter
    def cancellable(self) -> Optional[bool]:
        """
        <p> True if you're able to cancel your service software version update. False if you can't cancel your service software update.</p>
        """
        return pulumi.get(self, "cancellable")

    @property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[str]:
        """
        <p>The current service software version present on the domain.</p>
        """
        return pulumi.get(self, "current_version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description of the service software update status.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="newVersion")
    def new_version(self) -> Optional[str]:
        """
        <p>The new service software version, if one is available.</p>
        """
        return pulumi.get(self, "new_version")

    @property
    @pulumi.getter(name="optionalDeployment")
    def optional_deployment(self) -> Optional[bool]:
        """
        <p>True if a service software is never automatically updated. False if a service software is automatically updated after the automated update date.</p>
        """
        return pulumi.get(self, "optional_deployment")

    @property
    @pulumi.getter(name="updateAvailable")
    def update_available(self) -> Optional[bool]:
        """
        <p>True if you're able to update your service software version. False if you can't update your service software version.</p>
        """
        return pulumi.get(self, "update_available")

    @property
    @pulumi.getter(name="updateStatus")
    def update_status(self) -> Optional['outputs.DeploymentStatusEnumValueResponse']:
        """
        <p>The status of your service software update.</p>
        """
        return pulumi.get(self, "update_status")


@pulumi.output_type
class ServiceVolumeConfigurationResponse(dict):
    """
    Definition of ServiceVolumeConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedEBSVolume":
            suggest = "managed_ebs_volume"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceVolumeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceVolumeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceVolumeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_ebs_volume: Optional['outputs.ServiceManagedEBSVolumeConfigurationResponse'] = None,
                 name: Optional[str] = None):
        """
        Definition of ServiceVolumeConfiguration
        :param 'ServiceManagedEBSVolumeConfigurationResponse' managed_ebs_volume: The configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. These settings are used to create each Amazon EBS volume, with one volume created for each task in the service. The Amazon EBS volumes are visible in your account in the Amazon EC2 console once they are created. The configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. These settings are used to create each Amazon EBS volume, with one volume created for each task in the service. Many of these parameters map 1:1 with the Amazon EBS ``CreateVolume`` API request parameters.
        :param str name: The name of the volume. This value must match the volume name from the ``Volume`` object in the task definition.
        """
        if managed_ebs_volume is not None:
            pulumi.set(__self__, "managed_ebs_volume", managed_ebs_volume)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="managedEBSVolume")
    def managed_ebs_volume(self) -> Optional['outputs.ServiceManagedEBSVolumeConfigurationResponse']:
        """
        The configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. These settings are used to create each Amazon EBS volume, with one volume created for each task in the service. The Amazon EBS volumes are visible in your account in the Amazon EC2 console once they are created. The configuration for the Amazon EBS volume that Amazon ECS creates and manages on your behalf. These settings are used to create each Amazon EBS volume, with one volume created for each task in the service. Many of these parameters map 1:1 with the Amazon EBS ``CreateVolume`` API request parameters.
        """
        return pulumi.get(self, "managed_ebs_volume")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the volume. This value must match the volume name from the ``Volume`` object in the task definition.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SeveritySummaryResponse(dict):
    """
    Definition of SeveritySummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "criticalCount":
            suggest = "critical_count"
        elif key == "highCount":
            suggest = "high_count"
        elif key == "informationalCount":
            suggest = "informational_count"
        elif key == "lowCount":
            suggest = "low_count"
        elif key == "mediumCount":
            suggest = "medium_count"
        elif key == "unspecifiedCount":
            suggest = "unspecified_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SeveritySummaryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SeveritySummaryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SeveritySummaryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 critical_count: Optional[int] = None,
                 high_count: Optional[int] = None,
                 informational_count: Optional[int] = None,
                 low_count: Optional[int] = None,
                 medium_count: Optional[int] = None,
                 unspecified_count: Optional[int] = None):
        """
        Definition of SeveritySummary
        :param int critical_count: <p>The total number of resources or compliance items that have a severity level of <code>Critical</code>. Critical severity is determined by the organization that published the compliance items.</p>
        :param int high_count: <p>The total number of resources or compliance items that have a severity level of high. High severity is determined by the organization that published the compliance items.</p>
        :param int informational_count: <p>The total number of resources or compliance items that have a severity level of informational. Informational severity is determined by the organization that published the compliance items.</p>
        :param int low_count: <p>The total number of resources or compliance items that have a severity level of low. Low severity is determined by the organization that published the compliance items.</p>
        :param int medium_count: <p>The total number of resources or compliance items that have a severity level of medium. Medium severity is determined by the organization that published the compliance items.</p>
        :param int unspecified_count: <p>The total number of resources or compliance items that have a severity level of unspecified. Unspecified severity is determined by the organization that published the compliance items.</p>
        """
        if critical_count is not None:
            pulumi.set(__self__, "critical_count", critical_count)
        if high_count is not None:
            pulumi.set(__self__, "high_count", high_count)
        if informational_count is not None:
            pulumi.set(__self__, "informational_count", informational_count)
        if low_count is not None:
            pulumi.set(__self__, "low_count", low_count)
        if medium_count is not None:
            pulumi.set(__self__, "medium_count", medium_count)
        if unspecified_count is not None:
            pulumi.set(__self__, "unspecified_count", unspecified_count)

    @property
    @pulumi.getter(name="criticalCount")
    def critical_count(self) -> Optional[int]:
        """
        <p>The total number of resources or compliance items that have a severity level of <code>Critical</code>. Critical severity is determined by the organization that published the compliance items.</p>
        """
        return pulumi.get(self, "critical_count")

    @property
    @pulumi.getter(name="highCount")
    def high_count(self) -> Optional[int]:
        """
        <p>The total number of resources or compliance items that have a severity level of high. High severity is determined by the organization that published the compliance items.</p>
        """
        return pulumi.get(self, "high_count")

    @property
    @pulumi.getter(name="informationalCount")
    def informational_count(self) -> Optional[int]:
        """
        <p>The total number of resources or compliance items that have a severity level of informational. Informational severity is determined by the organization that published the compliance items.</p>
        """
        return pulumi.get(self, "informational_count")

    @property
    @pulumi.getter(name="lowCount")
    def low_count(self) -> Optional[int]:
        """
        <p>The total number of resources or compliance items that have a severity level of low. Low severity is determined by the organization that published the compliance items.</p>
        """
        return pulumi.get(self, "low_count")

    @property
    @pulumi.getter(name="mediumCount")
    def medium_count(self) -> Optional[int]:
        """
        <p>The total number of resources or compliance items that have a severity level of medium. Medium severity is determined by the organization that published the compliance items.</p>
        """
        return pulumi.get(self, "medium_count")

    @property
    @pulumi.getter(name="unspecifiedCount")
    def unspecified_count(self) -> Optional[int]:
        """
        <p>The total number of resources or compliance items that have a severity level of unspecified. Unspecified severity is determined by the organization that published the compliance items.</p>
        """
        return pulumi.get(self, "unspecified_count")


@pulumi.output_type
class SimpleCriterionForJobResponse(dict):
    """
    Definition of SimpleCriterionForJob
    """
    def __init__(__self__, *,
                 comparator: Optional['outputs.JobComparatorEnumValueResponse'] = None,
                 key: Optional['outputs.SimpleCriterionKeyForJobEnumValueResponse'] = None,
                 values: Optional[Sequence[str]] = None):
        """
        Definition of SimpleCriterionForJob
        :param 'JobComparatorEnumValueResponse' comparator: <p>The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).</p>
        :param 'SimpleCriterionKeyForJobEnumValueResponse' key: <p>The property to use in the condition.</p>
        :param Sequence[str] values: <p>An array that lists one or more values to use in the condition. If you specify multiple values, Amazon Macie uses OR logic to join the values. Valid values for each supported property (key) are:</p> <ul><li><p>ACCOUNT_ID - A string that represents the unique identifier for the Amazon Web Services account that owns the bucket.</p></li> <li><p>S3_BUCKET_EFFECTIVE_PERMISSION - A string that represents an enumerated value that Macie defines for the <a href='https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketpublicaccess-effectivepermission'>BucketPublicAccess.effectivePermission</a> property of a bucket.</p></li> <li><p>S3_BUCKET_NAME - A string that represents the name of a bucket.</p></li> <li><p>S3_BUCKET_SHARED_ACCESS - A string that represents an enumerated value that Macie defines for the <a href='https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketmetadata-sharedaccess'>BucketMetadata.sharedAccess</a> property of a bucket.</p></li></ul> <p>Values are case sensitive. Also, Macie doesn't support use of partial values or wildcard characters in these values.</p>
        """
        if comparator is not None:
            pulumi.set(__self__, "comparator", comparator)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def comparator(self) -> Optional['outputs.JobComparatorEnumValueResponse']:
        """
        <p>The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).</p>
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def key(self) -> Optional['outputs.SimpleCriterionKeyForJobEnumValueResponse']:
        """
        <p>The property to use in the condition.</p>
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        <p>An array that lists one or more values to use in the condition. If you specify multiple values, Amazon Macie uses OR logic to join the values. Valid values for each supported property (key) are:</p> <ul><li><p>ACCOUNT_ID - A string that represents the unique identifier for the Amazon Web Services account that owns the bucket.</p></li> <li><p>S3_BUCKET_EFFECTIVE_PERMISSION - A string that represents an enumerated value that Macie defines for the <a href='https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketpublicaccess-effectivepermission'>BucketPublicAccess.effectivePermission</a> property of a bucket.</p></li> <li><p>S3_BUCKET_NAME - A string that represents the name of a bucket.</p></li> <li><p>S3_BUCKET_SHARED_ACCESS - A string that represents an enumerated value that Macie defines for the <a href='https://docs.aws.amazon.com/macie/latest/APIReference/datasources-s3.html#datasources-s3-prop-bucketmetadata-sharedaccess'>BucketMetadata.sharedAccess</a> property of a bucket.</p></li></ul> <p>Values are case sensitive. Also, Macie doesn't support use of partial values or wildcard characters in these values.</p>
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SimpleCriterionKeyForJobEnumValueResponse(dict):
    """
    Definition of SimpleCriterionKeyForJobEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of SimpleCriterionKeyForJobEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SingleHeaderModelPropertiesResponse(dict):
    """
    Definition of SingleHeaderModelProperties
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        Definition of SingleHeaderModelProperties
        :param str name: The name of the query header to inspect.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the query header to inspect.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SnapStartResponse(dict):
    """
    Definition of SnapStart
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyOn":
            suggest = "apply_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnapStartResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnapStartResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnapStartResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_on: Optional[str] = None):
        """
        Definition of SnapStart
        :param str apply_on: Set ``ApplyOn`` to ``PublishedVersions`` to create a snapshot of the initialized execution environment when you publish a function version.
        """
        if apply_on is not None:
            pulumi.set(__self__, "apply_on", apply_on)

    @property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> Optional[str]:
        """
        Set ``ApplyOn`` to ``PublishedVersions`` to create a snapshot of the initialized execution environment when you publish a function version.
        """
        return pulumi.get(self, "apply_on")


@pulumi.output_type
class SnapStartResponseResponse(dict):
    """
    Definition of SnapStartResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyOn":
            suggest = "apply_on"
        elif key == "optimizationStatus":
            suggest = "optimization_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnapStartResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnapStartResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnapStartResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_on: Optional[str] = None,
                 optimization_status: Optional[str] = None):
        """
        Definition of SnapStartResponse
        :param str apply_on: When set to ``PublishedVersions``, Lambda creates a snapshot of the execution environment when you publish a function version.
        :param str optimization_status: When you provide a [qualified Amazon Resource Name (ARN)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using), this response element indicates whether SnapStart is activated for the specified function version.
        """
        if apply_on is not None:
            pulumi.set(__self__, "apply_on", apply_on)
        if optimization_status is not None:
            pulumi.set(__self__, "optimization_status", optimization_status)

    @property
    @pulumi.getter(name="applyOn")
    def apply_on(self) -> Optional[str]:
        """
        When set to ``PublishedVersions``, Lambda creates a snapshot of the execution environment when you publish a function version.
        """
        return pulumi.get(self, "apply_on")

    @property
    @pulumi.getter(name="optimizationStatus")
    def optimization_status(self) -> Optional[str]:
        """
        When you provide a [qualified Amazon Resource Name (ARN)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using), this response element indicates whether SnapStart is activated for the specified function version.
        """
        return pulumi.get(self, "optimization_status")


@pulumi.output_type
class SnapshotOptionsResponse(dict):
    """
    Definition of SnapshotOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automatedSnapshotStartHour":
            suggest = "automated_snapshot_start_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnapshotOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnapshotOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnapshotOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated_snapshot_start_hour: Optional[int] = None):
        """
        Definition of SnapshotOptions
        :param int automated_snapshot_start_hour: <p>The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.</p>
        """
        if automated_snapshot_start_hour is not None:
            pulumi.set(__self__, "automated_snapshot_start_hour", automated_snapshot_start_hour)

    @property
    @pulumi.getter(name="automatedSnapshotStartHour")
    def automated_snapshot_start_hour(self) -> Optional[int]:
        """
        <p>The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is <code>0</code> hours.</p>
        """
        return pulumi.get(self, "automated_snapshot_start_hour")


@pulumi.output_type
class SnapshotStateEnumValueResponse(dict):
    """
    Definition of SnapshotStateEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of SnapshotStateEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SnsSubscriptionPropertiesResponse(dict):
    """
    Definition of SnsSubscription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnsSubscriptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnsSubscriptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnsSubscriptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSnsSubscriptionPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SnsSubscription
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSnsSubscriptionPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSnsSubscriptionPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class SnsTopicPropertiesResponse(dict):
    """
    Definition of SnsTopic
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnsTopicPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnsTopicPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnsTopicPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSnsTopicPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SnsTopic
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSnsTopicPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSnsTopicPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class SoftwareUpdateOptionsResponse(dict):
    """
    Definition of SoftwareUpdateOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSoftwareUpdateEnabled":
            suggest = "auto_software_update_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SoftwareUpdateOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SoftwareUpdateOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SoftwareUpdateOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_software_update_enabled: Optional[bool] = None):
        """
        Definition of SoftwareUpdateOptions
        :param bool auto_software_update_enabled: <p>Whether automatic service software updates are enabled for the domain.</p>
        """
        if auto_software_update_enabled is not None:
            pulumi.set(__self__, "auto_software_update_enabled", auto_software_update_enabled)

    @property
    @pulumi.getter(name="autoSoftwareUpdateEnabled")
    def auto_software_update_enabled(self) -> Optional[bool]:
        """
        <p>Whether automatic service software updates are enabled for the domain.</p>
        """
        return pulumi.get(self, "auto_software_update_enabled")


@pulumi.output_type
class SourceAuthResponse(dict):
    """
    Definition of SourceAuth
    """
    def __init__(__self__, *,
                 resource: Optional[str] = None,
                 type: Optional['outputs.SourceAuthTypeEnumValueResponse'] = None):
        """
        Definition of SourceAuth
        :param str resource: <p>The resource value that applies to the specified authorization type.</p>
        :param 'SourceAuthTypeEnumValueResponse' type: <p>The authorization type to use. Valid options are OAUTH or CODECONNECTIONS.</p>
        """
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        <p>The resource value that applies to the specified authorization type.</p>
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.SourceAuthTypeEnumValueResponse']:
        """
        <p>The authorization type to use. Valid options are OAUTH or CODECONNECTIONS.</p>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SourceAuthTypeEnumValueResponse(dict):
    """
    Definition of SourceAuthTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of SourceAuthTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceConfigurationResponse(dict):
    """
    Definition of SourceConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"
        elif key == "templateName":
            suggest = "template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: Optional[str] = None,
                 template_name: Optional[str] = None):
        """
        Definition of SourceConfiguration
        :param str application_name: The name of the application associated with the configuration.
        :param str template_name: The name of the configuration template.
        """
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[str]:
        """
        The name of the application associated with the configuration.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[str]:
        """
        The name of the configuration template.
        """
        return pulumi.get(self, "template_name")


@pulumi.output_type
class SourceSelectionCriteriaResponse(dict):
    """
    Definition of SourceSelectionCriteria
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaModifications":
            suggest = "replica_modifications"
        elif key == "sseKmsEncryptedObjects":
            suggest = "sse_kms_encrypted_objects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSelectionCriteriaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSelectionCriteriaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSelectionCriteriaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replica_modifications: Optional['outputs.ReplicaModificationsResponse'] = None,
                 sse_kms_encrypted_objects: Optional['outputs.SseKmsEncryptedObjectsResponse'] = None):
        """
        Definition of SourceSelectionCriteria
        :param 'ReplicaModificationsResponse' replica_modifications: A filter that you can specify for selection for modifications on replicas. A filter that you can specify for selection for modifications on replicas.
        :param 'SseKmsEncryptedObjectsResponse' sse_kms_encrypted_objects: A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. A container for filter information for the selection of S3 objects encrypted with AWS KMS.
        """
        if replica_modifications is not None:
            pulumi.set(__self__, "replica_modifications", replica_modifications)
        if sse_kms_encrypted_objects is not None:
            pulumi.set(__self__, "sse_kms_encrypted_objects", sse_kms_encrypted_objects)

    @property
    @pulumi.getter(name="replicaModifications")
    def replica_modifications(self) -> Optional['outputs.ReplicaModificationsResponse']:
        """
        A filter that you can specify for selection for modifications on replicas. A filter that you can specify for selection for modifications on replicas.
        """
        return pulumi.get(self, "replica_modifications")

    @property
    @pulumi.getter(name="sseKmsEncryptedObjects")
    def sse_kms_encrypted_objects(self) -> Optional['outputs.SseKmsEncryptedObjectsResponse']:
        """
        A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS. A container for filter information for the selection of S3 objects encrypted with AWS KMS.
        """
        return pulumi.get(self, "sse_kms_encrypted_objects")


@pulumi.output_type
class SourceTypeEnumValueResponse(dict):
    """
    Definition of SourceTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of SourceTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqsQueuePropertiesResponse(dict):
    """
    Definition of SqsQueue
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqsQueuePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqsQueuePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqsQueuePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSqsQueuePropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SqsQueue
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSqsQueuePropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSqsQueuePropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class SseKmsEncryptedObjectsResponse(dict):
    """
    Definition of SseKmsEncryptedObjects
    """
    def __init__(__self__, *,
                 status: Optional[str] = None):
        """
        Definition of SseKmsEncryptedObjects
        :param str status: Specifies whether Amazon S3 replicates objects created with server-side encryption using an AWS KMS key stored in AWS Key Management Service.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Specifies whether Amazon S3 replicates objects created with server-side encryption using an AWS KMS key stored in AWS Key Management Service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SsmInstanceInformationPropertiesResponse(dict):
    """
    Definition of SsmInstanceInformation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsmInstanceInformationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsmInstanceInformationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsmInstanceInformationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSsmInstanceInformationPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SsmInstanceInformation
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSsmInstanceInformationPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSsmInstanceInformationPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class SsmParameterPropertiesResponse(dict):
    """
    Definition of SsmParameter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsmParameterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsmParameterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsmParameterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSsmParameterPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SsmParameter
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSsmParameterPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSsmParameterPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class SsmResourceComplianceSummaryItemPropertiesResponse(dict):
    """
    Definition of SsmResourceComplianceSummaryItem
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SsmResourceComplianceSummaryItemPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SsmResourceComplianceSummaryItemPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SsmResourceComplianceSummaryItemPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsSsmResourceComplianceSummaryItemPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of SsmResourceComplianceSummaryItem
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsSsmResourceComplianceSummaryItemPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsSsmResourceComplianceSummaryItemPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class StackInstancesResponse(dict):
    """
    Definition of StackInstances
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentTargets":
            suggest = "deployment_targets"
        elif key == "parameterOverrides":
            suggest = "parameter_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StackInstancesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StackInstancesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StackInstancesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_targets: Optional['outputs.DeploymentTargetsResponse'] = None,
                 parameter_overrides: Optional[Sequence['outputs.ParameterResponse']] = None,
                 regions: Optional[Sequence[str]] = None):
        """
        Definition of StackInstances
        :param 'DeploymentTargetsResponse' deployment_targets: The AWS OrganizationalUnitIds or Accounts for which to create stack instances in the specified Regions.
        :param Sequence['ParameterResponse'] parameter_overrides: A list of stack set parameters whose values you want to override in the selected stack instances.
        :param Sequence[str] regions: The names of one or more Regions where you want to create stack instances using the specified AWS account(s).
        """
        if deployment_targets is not None:
            pulumi.set(__self__, "deployment_targets", deployment_targets)
        if parameter_overrides is not None:
            pulumi.set(__self__, "parameter_overrides", parameter_overrides)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)

    @property
    @pulumi.getter(name="deploymentTargets")
    def deployment_targets(self) -> Optional['outputs.DeploymentTargetsResponse']:
        """
        The AWS OrganizationalUnitIds or Accounts for which to create stack instances in the specified Regions.
        """
        return pulumi.get(self, "deployment_targets")

    @property
    @pulumi.getter(name="parameterOverrides")
    def parameter_overrides(self) -> Optional[Sequence['outputs.ParameterResponse']]:
        """
        A list of stack set parameters whose values you want to override in the selected stack instances.
        """
        return pulumi.get(self, "parameter_overrides")

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        """
        The names of one or more Regions where you want to create stack instances using the specified AWS account(s).
        """
        return pulumi.get(self, "regions")


@pulumi.output_type
class StateReasonResponse(dict):
    """
    Definition of StateReason
    """
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 message: Optional[str] = None):
        """
        Definition of StateReason
        :param str code: <p>The reason code for the state change.</p>
        :param str message: <p>The message for the state change.</p> <ul> <li> <p> <code>Server.InsufficientInstanceCapacity</code>: There was insufficient capacity available to satisfy the launch request.</p> </li> <li> <p> <code>Server.InternalError</code>: An internal error caused the instance to terminate during launch.</p> </li> <li> <p> <code>Server.ScheduledStop</code>: The instance was stopped due to a scheduled retirement.</p> </li> <li> <p> <code>Server.SpotInstanceShutdown</code>: The instance was stopped because the number of Spot requests with a maximum price equal to or higher than the Spot price exceeded available capacity or because of an increase in the Spot price.</p> </li> <li> <p> <code>Server.SpotInstanceTermination</code>: The instance was terminated because the number of Spot requests with a maximum price equal to or higher than the Spot price exceeded available capacity or because of an increase in the Spot price.</p> </li> <li> <p> <code>Client.InstanceInitiatedShutdown</code>: The instance was shut down from the operating system of the instance.</p> </li> <li> <p> <code>Client.InstanceTerminated</code>: The instance was terminated or rebooted during AMI creation.</p> </li> <li> <p> <code>Client.InternalError</code>: A client error caused the instance to terminate during launch.</p> </li> <li> <p> <code>Client.InvalidSnapshot.NotFound</code>: The specified snapshot was not found.</p> </li> <li> <p> <code>Client.UserInitiatedHibernate</code>: Hibernation was initiated on the instance.</p> </li> <li> <p> <code>Client.UserInitiatedShutdown</code>: The instance was shut down using the Amazon EC2 API.</p> </li> <li> <p> <code>Client.VolumeLimitExceeded</code>: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your account limits.</p> </li> </ul>
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        <p>The reason code for the state change.</p>
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        <p>The message for the state change.</p> <ul> <li> <p> <code>Server.InsufficientInstanceCapacity</code>: There was insufficient capacity available to satisfy the launch request.</p> </li> <li> <p> <code>Server.InternalError</code>: An internal error caused the instance to terminate during launch.</p> </li> <li> <p> <code>Server.ScheduledStop</code>: The instance was stopped due to a scheduled retirement.</p> </li> <li> <p> <code>Server.SpotInstanceShutdown</code>: The instance was stopped because the number of Spot requests with a maximum price equal to or higher than the Spot price exceeded available capacity or because of an increase in the Spot price.</p> </li> <li> <p> <code>Server.SpotInstanceTermination</code>: The instance was terminated because the number of Spot requests with a maximum price equal to or higher than the Spot price exceeded available capacity or because of an increase in the Spot price.</p> </li> <li> <p> <code>Client.InstanceInitiatedShutdown</code>: The instance was shut down from the operating system of the instance.</p> </li> <li> <p> <code>Client.InstanceTerminated</code>: The instance was terminated or rebooted during AMI creation.</p> </li> <li> <p> <code>Client.InternalError</code>: A client error caused the instance to terminate during launch.</p> </li> <li> <p> <code>Client.InvalidSnapshot.NotFound</code>: The specified snapshot was not found.</p> </li> <li> <p> <code>Client.UserInitiatedHibernate</code>: Hibernation was initiated on the instance.</p> </li> <li> <p> <code>Client.UserInitiatedShutdown</code>: The instance was shut down using the Amazon EC2 API.</p> </li> <li> <p> <code>Client.VolumeLimitExceeded</code>: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your account limits.</p> </li> </ul>
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class StateResponse(dict):
    """
    Definition of State
    """
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 name: Optional[str] = None):
        """
        Definition of State
        :param int code: Status code of the Instance.
        :param str name: Status code of the Instance.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        Status code of the Instance.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Status code of the Instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class StatefulEngineOptionsResponse(dict):
    """
    Definition of StatefulEngineOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleOrder":
            suggest = "rule_order"
        elif key == "streamExceptionPolicy":
            suggest = "stream_exception_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulEngineOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulEngineOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulEngineOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_order: Optional[str] = None,
                 stream_exception_policy: Optional[str] = None):
        """
        Definition of StatefulEngineOptions
        :param str rule_order: Property ruleOrder
        :param str stream_exception_policy: Property streamExceptionPolicy
        """
        if rule_order is not None:
            pulumi.set(__self__, "rule_order", rule_order)
        if stream_exception_policy is not None:
            pulumi.set(__self__, "stream_exception_policy", stream_exception_policy)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[str]:
        """
        Property ruleOrder
        """
        return pulumi.get(self, "rule_order")

    @property
    @pulumi.getter(name="streamExceptionPolicy")
    def stream_exception_policy(self) -> Optional[str]:
        """
        Property streamExceptionPolicy
        """
        return pulumi.get(self, "stream_exception_policy")


@pulumi.output_type
class StatefulRuleGroupOverrideResponse(dict):
    """
    Definition of StatefulRuleGroupOverride
    """
    def __init__(__self__, *,
                 action: Optional[str] = None):
        """
        Definition of StatefulRuleGroupOverride
        :param str action: Property action
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Property action
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class StatefulRuleGroupReferenceResponse(dict):
    """
    Definition of StatefulRuleGroupReference
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulRuleGroupReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulRuleGroupReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulRuleGroupReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 override: Optional['outputs.StatefulRuleGroupOverrideResponse'] = None,
                 priority: Optional[int] = None,
                 resource_arn: Optional[str] = None):
        """
        Definition of StatefulRuleGroupReference
        :param 'StatefulRuleGroupOverrideResponse' override: Property override
        :param int priority: Property priority
        :param str resource_arn: A resource ARN.
        """
        if override is not None:
            pulumi.set(__self__, "override", override)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)

    @property
    @pulumi.getter
    def override(self) -> Optional['outputs.StatefulRuleGroupOverrideResponse']:
        """
        Property override
        """
        return pulumi.get(self, "override")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Property priority
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[str]:
        """
        A resource ARN.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class StatefulRuleOptionsResponse(dict):
    """
    Definition of StatefulRuleOptions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleOrder":
            suggest = "rule_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulRuleOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulRuleOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulRuleOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_order: Optional[str] = None):
        """
        Definition of StatefulRuleOptions
        :param str rule_order: Property ruleOrder
        """
        if rule_order is not None:
            pulumi.set(__self__, "rule_order", rule_order)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[str]:
        """
        Property ruleOrder
        """
        return pulumi.get(self, "rule_order")


@pulumi.output_type
class StatefulRuleResponse(dict):
    """
    Definition of StatefulRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleOptions":
            suggest = "rule_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 header: Optional['outputs.HeaderResponse'] = None,
                 rule_options: Optional[Sequence['outputs.RuleOptionResponse']] = None):
        """
        Definition of StatefulRule
        :param str action: Property action
        :param 'HeaderResponse' header: Property header
        :param Sequence['RuleOptionResponse'] rule_options: Property ruleOptions
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if rule_options is not None:
            pulumi.set(__self__, "rule_options", rule_options)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Property action
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def header(self) -> Optional['outputs.HeaderResponse']:
        """
        Property header
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="ruleOptions")
    def rule_options(self) -> Optional[Sequence['outputs.RuleOptionResponse']]:
        """
        Property ruleOptions
        """
        return pulumi.get(self, "rule_options")


@pulumi.output_type
class StatelessRuleGroupReferenceResponse(dict):
    """
    Definition of StatelessRuleGroupReference
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceArn":
            suggest = "resource_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatelessRuleGroupReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatelessRuleGroupReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatelessRuleGroupReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: Optional[int] = None,
                 resource_arn: Optional[str] = None):
        """
        Definition of StatelessRuleGroupReference
        :param int priority: Property priority
        :param str resource_arn: A resource ARN.
        """
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Property priority
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[str]:
        """
        A resource ARN.
        """
        return pulumi.get(self, "resource_arn")


@pulumi.output_type
class StatelessRuleResponse(dict):
    """
    Definition of StatelessRule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleDefinition":
            suggest = "rule_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatelessRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatelessRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatelessRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: Optional[int] = None,
                 rule_definition: Optional['outputs.RuleDefinitionResponse'] = None):
        """
        Definition of StatelessRule
        :param int priority: Property priority
        :param 'RuleDefinitionResponse' rule_definition: Property ruleDefinition
        """
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rule_definition is not None:
            pulumi.set(__self__, "rule_definition", rule_definition)

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Property priority
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="ruleDefinition")
    def rule_definition(self) -> Optional['outputs.RuleDefinitionResponse']:
        """
        Property ruleDefinition
        """
        return pulumi.get(self, "rule_definition")


@pulumi.output_type
class StatelessRulesAndCustomActionsResponse(dict):
    """
    Definition of StatelessRulesAndCustomActions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customActions":
            suggest = "custom_actions"
        elif key == "statelessRules":
            suggest = "stateless_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatelessRulesAndCustomActionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatelessRulesAndCustomActionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatelessRulesAndCustomActionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_actions: Optional[Sequence['outputs.CustomActionResponse']] = None,
                 stateless_rules: Optional[Sequence['outputs.StatelessRuleResponse']] = None):
        """
        Definition of StatelessRulesAndCustomActions
        :param Sequence['CustomActionResponse'] custom_actions: Property customActions
        :param Sequence['StatelessRuleResponse'] stateless_rules: Property statelessRules
        """
        if custom_actions is not None:
            pulumi.set(__self__, "custom_actions", custom_actions)
        if stateless_rules is not None:
            pulumi.set(__self__, "stateless_rules", stateless_rules)

    @property
    @pulumi.getter(name="customActions")
    def custom_actions(self) -> Optional[Sequence['outputs.CustomActionResponse']]:
        """
        Property customActions
        """
        return pulumi.get(self, "custom_actions")

    @property
    @pulumi.getter(name="statelessRules")
    def stateless_rules(self) -> Optional[Sequence['outputs.StatelessRuleResponse']]:
        """
        Property statelessRules
        """
        return pulumi.get(self, "stateless_rules")


@pulumi.output_type
class StatusCodesResponse(dict):
    """
    Definition of StatusCodes
    """
    def __init__(__self__, *,
                 items: Optional[Sequence[int]] = None,
                 quantity: Optional[int] = None):
        """
        Definition of StatusCodes
        :param Sequence[int] items: The items (status codes) for an origin group.
        :param int quantity: The number of status codes.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence[int]]:
        """
        The items (status codes) for an origin group.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[int]:
        """
        The number of status codes.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class StatusNameEnumValueResponse(dict):
    """
    Definition of StatusNameEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of StatusNameEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class StatusTypeEnumValueResponse(dict):
    """
    Definition of statusTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of statusTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class StorageClassAnalysisResponse(dict):
    """
    Definition of StorageClassAnalysis
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataExport":
            suggest = "data_export"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageClassAnalysisResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageClassAnalysisResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageClassAnalysisResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_export: Optional['outputs.DataExportResponse'] = None):
        """
        Definition of StorageClassAnalysis
        :param 'DataExportResponse' data_export: Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported. Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported.
        """
        if data_export is not None:
            pulumi.set(__self__, "data_export", data_export)

    @property
    @pulumi.getter(name="dataExport")
    def data_export(self) -> Optional['outputs.DataExportResponse']:
        """
        Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported. Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported.
        """
        return pulumi.get(self, "data_export")


@pulumi.output_type
class StorageTierEnumValueResponse(dict):
    """
    Definition of StorageTierEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of StorageTierEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class StreamSpecificationResponse(dict):
    """
    Definition of StreamSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourcePolicy":
            suggest = "resource_policy"
        elif key == "streamViewType":
            suggest = "stream_view_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_policy: Optional['outputs.ResourcePolicyResponse'] = None,
                 stream_view_type: Optional[str] = None):
        """
        Definition of StreamSpecification
        :param 'ResourcePolicyResponse' resource_policy: Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a table's streams. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a table, its indexes, and stream. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). While defining resource-based policies in your CFNshort templates, the following considerations apply:  +  The maximum size supported for a resource-based policy document in JSON format is 20 KB. DDB counts whitespaces when calculating the size of a policy against this limit.   +  Resource-based policies don't support [drift detection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html#). If you update a policy outside of the CFNshort stack template, you'll need to update the CFNshort stack with the changes.  +  Resource-based policies don't support out-of-band changes. If you add, update, or delete a policy outside of the CFNshort template, the change won't be overwritten if there are no changes to the policy within the template. For example, say that your template contains a resource-based policy, which you later update outside of the template. If you don't make any changes to the policy in the template, the updated policy in DDB wont be synced with the policy in the template. Conversely, say that your template doesnt contain a resource-based policy, but you add a policy outside of the template. This policy wont be removed from DDB as long as you dont add it to the template. When you add a policy to the template and update the stack, the existing policy in DDB will be updated to match the one defined in the template.   For a full list of all considerations, see [Resource-based policy considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
        :param str stream_view_type: When an item in the table is modified, ``StreamViewType`` determines what information is written to the stream for this table. Valid values for ``StreamViewType`` are:  +   ``KEYS_ONLY`` - Only the key attributes of the modified item are written to the stream.  +   ``NEW_IMAGE`` - The entire item, as it appears after it was modified, is written to the stream.  +   ``OLD_IMAGE`` - The entire item, as it appeared before it was modified, is written to the stream.  +   ``NEW_AND_OLD_IMAGES`` - Both the new and the old item images of the item are written to the stream.
        """
        if resource_policy is not None:
            pulumi.set(__self__, "resource_policy", resource_policy)
        if stream_view_type is not None:
            pulumi.set(__self__, "stream_view_type", stream_view_type)

    @property
    @pulumi.getter(name="resourcePolicy")
    def resource_policy(self) -> Optional['outputs.ResourcePolicyResponse']:
        """
        Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a table's streams. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a table, its indexes, and stream. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). While defining resource-based policies in your CFNshort templates, the following considerations apply:  +  The maximum size supported for a resource-based policy document in JSON format is 20 KB. DDB counts whitespaces when calculating the size of a policy against this limit.   +  Resource-based policies don't support [drift detection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html#). If you update a policy outside of the CFNshort stack template, you'll need to update the CFNshort stack with the changes.  +  Resource-based policies don't support out-of-band changes. If you add, update, or delete a policy outside of the CFNshort template, the change won't be overwritten if there are no changes to the policy within the template. For example, say that your template contains a resource-based policy, which you later update outside of the template. If you don't make any changes to the policy in the template, the updated policy in DDB wont be synced with the policy in the template. Conversely, say that your template doesnt contain a resource-based policy, but you add a policy outside of the template. This policy wont be removed from DDB as long as you dont add it to the template. When you add a policy to the template and update the stack, the existing policy in DDB will be updated to match the one defined in the template.   For a full list of all considerations, see [Resource-based policy considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
        """
        return pulumi.get(self, "resource_policy")

    @property
    @pulumi.getter(name="streamViewType")
    def stream_view_type(self) -> Optional[str]:
        """
        When an item in the table is modified, ``StreamViewType`` determines what information is written to the stream for this table. Valid values for ``StreamViewType`` are:  +   ``KEYS_ONLY`` - Only the key attributes of the modified item are written to the stream.  +   ``NEW_IMAGE`` - The entire item, as it appears after it was modified, is written to the stream.  +   ``OLD_IMAGE`` - The entire item, as it appeared before it was modified, is written to the stream.  +   ``NEW_AND_OLD_IMAGES`` - Both the new and the old item images of the item are written to the stream.
        """
        return pulumi.get(self, "stream_view_type")


@pulumi.output_type
class SubnetMappingResponse(dict):
    """
    Definition of SubnetMapping
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"
        elif key == "iPv6Address":
            suggest = "i_pv6_address"
        elif key == "ipAddressType":
            suggest = "ip_address_type"
        elif key == "privateIPv4Address":
            suggest = "private_i_pv4_address"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_id: Optional[str] = None,
                 i_pv6_address: Optional[str] = None,
                 ip_address_type: Optional[str] = None,
                 private_i_pv4_address: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        Definition of SubnetMapping
        :param str allocation_id: [Network Load Balancers] The allocation ID of the Elastic IP address for an internet-facing load balancer.
        :param str i_pv6_address: [Network Load Balancers] The IPv6 address.
        :param str ip_address_type: A IPAddressType
        :param str private_i_pv4_address: [Network Load Balancers] The private IPv4 address for an internal load balancer.
        :param str subnet_id: A SubnetId.
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if i_pv6_address is not None:
            pulumi.set(__self__, "i_pv6_address", i_pv6_address)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)
        if private_i_pv4_address is not None:
            pulumi.set(__self__, "private_i_pv4_address", private_i_pv4_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[str]:
        """
        [Network Load Balancers] The allocation ID of the Elastic IP address for an internet-facing load balancer.
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter(name="iPv6Address")
    def i_pv6_address(self) -> Optional[str]:
        """
        [Network Load Balancers] The IPv6 address.
        """
        return pulumi.get(self, "i_pv6_address")

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[str]:
        """
        A IPAddressType
        """
        return pulumi.get(self, "ip_address_type")

    @property
    @pulumi.getter(name="privateIPv4Address")
    def private_i_pv4_address(self) -> Optional[str]:
        """
        [Network Load Balancers] The private IPv4 address for an internal load balancer.
        """
        return pulumi.get(self, "private_i_pv4_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        A SubnetId.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class SubnetResponse(dict):
    """
    Definition of Subnet
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetAvailabilityZone":
            suggest = "subnet_availability_zone"
        elif key == "subnetIdentifier":
            suggest = "subnet_identifier"
        elif key == "subnetStatus":
            suggest = "subnet_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_availability_zone: Optional['outputs.AvailabilityZoneResponse'] = None,
                 subnet_identifier: Optional[str] = None,
                 subnet_status: Optional[str] = None):
        """
        Definition of Subnet
        :param 'AvailabilityZoneResponse' subnet_availability_zone: <p>The Availability Zone of the subnet.</p>
        :param str subnet_identifier: <p>The subnet identifier.</p>
        :param str subnet_status: <p>The status of the subnet.</p>
        """
        if subnet_availability_zone is not None:
            pulumi.set(__self__, "subnet_availability_zone", subnet_availability_zone)
        if subnet_identifier is not None:
            pulumi.set(__self__, "subnet_identifier", subnet_identifier)
        if subnet_status is not None:
            pulumi.set(__self__, "subnet_status", subnet_status)

    @property
    @pulumi.getter(name="subnetAvailabilityZone")
    def subnet_availability_zone(self) -> Optional['outputs.AvailabilityZoneResponse']:
        """
        <p>The Availability Zone of the subnet.</p>
        """
        return pulumi.get(self, "subnet_availability_zone")

    @property
    @pulumi.getter(name="subnetIdentifier")
    def subnet_identifier(self) -> Optional[str]:
        """
        <p>The subnet identifier.</p>
        """
        return pulumi.get(self, "subnet_identifier")

    @property
    @pulumi.getter(name="subnetStatus")
    def subnet_status(self) -> Optional[str]:
        """
        <p>The status of the subnet.</p>
        """
        return pulumi.get(self, "subnet_status")


@pulumi.output_type
class SubscriptionResponse(dict):
    """
    Definition of Subscription
    """
    def __init__(__self__, *,
                 endpoint: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        Definition of Subscription
        :param str endpoint: The endpoint that receives notifications from the SNS topic. The endpoint value depends on the protocol that you specify. For more information, see the ``Endpoint`` parameter of the ``Subscribe`` action in the *API Reference*.
        :param str protocol: The subscription's protocol. For more information, see the ``Protocol`` parameter of the ``Subscribe`` action in the *API Reference*.
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The endpoint that receives notifications from the SNS topic. The endpoint value depends on the protocol that you specify. For more information, see the ``Endpoint`` parameter of the ``Subscribe`` action in the *API Reference*.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The subscription's protocol. For more information, see the ``Protocol`` parameter of the ``Subscribe`` action in the *API Reference*.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class SummaryStatusEnumValueResponse(dict):
    """
    Definition of SummaryStatusEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of SummaryStatusEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SystemControlResponse(dict):
    """
    Definition of SystemControl
    """
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of SystemControl
        :param str namespace: The namespaced kernel parameter to set a ``value`` for.
        :param str value: The namespaced kernel parameter to set a ``value`` for. Valid IPC namespace values: ``'kernel.msgmax' | 'kernel.msgmnb' | 'kernel.msgmni' | 'kernel.sem' | 'kernel.shmall' | 'kernel.shmmax' | 'kernel.shmmni' | 'kernel.shm_rmid_forced'``, and ``Sysctls`` that start with ``'fs.mqueue.*'``  Valid network namespace values: ``Sysctls`` that start with ``'net.*'``  All of these values are supported by Fargate.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespaced kernel parameter to set a ``value`` for.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The namespaced kernel parameter to set a ``value`` for. Valid IPC namespace values: ``'kernel.msgmax' | 'kernel.msgmnb' | 'kernel.msgmni' | 'kernel.sem' | 'kernel.shmall' | 'kernel.shmmax' | 'kernel.shmmni' | 'kernel.shm_rmid_forced'``, and ``Sysctls`` that start with ``'fs.mqueue.*'``  Valid network namespace values: ``Sysctls`` that start with ``'net.*'``  All of these values are supported by Fargate.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TCPFlagFieldResponse(dict):
    """
    Definition of TCPFlagField
    """
    def __init__(__self__, *,
                 flags: Optional[Sequence[str]] = None,
                 masks: Optional[Sequence[str]] = None):
        """
        Definition of TCPFlagField
        :param Sequence[str] flags: Property flags
        :param Sequence[str] masks: Property masks
        """
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if masks is not None:
            pulumi.set(__self__, "masks", masks)

    @property
    @pulumi.getter
    def flags(self) -> Optional[Sequence[str]]:
        """
        Property flags
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def masks(self) -> Optional[Sequence[str]]:
        """
        Property masks
        """
        return pulumi.get(self, "masks")


@pulumi.output_type
class TLSSecurityPolicyEnumValueResponse(dict):
    """
    Definition of TLSSecurityPolicyEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of TLSSecurityPolicyEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TagCriterionForJobResponse(dict):
    """
    Definition of TagCriterionForJob
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagValues":
            suggest = "tag_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TagCriterionForJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TagCriterionForJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TagCriterionForJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: Optional['outputs.JobComparatorEnumValueResponse'] = None,
                 tag_values: Optional[Sequence['outputs.TagCriterionPairForJobResponse']] = None):
        """
        Definition of TagCriterionForJob
        :param 'JobComparatorEnumValueResponse' comparator: <p>The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).</p>
        :param Sequence['TagCriterionPairForJobResponse'] tag_values: <p>The tag keys, tag values, or tag key and value pairs to use in the condition.</p>
        """
        if comparator is not None:
            pulumi.set(__self__, "comparator", comparator)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)

    @property
    @pulumi.getter
    def comparator(self) -> Optional['outputs.JobComparatorEnumValueResponse']:
        """
        <p>The operator to use in the condition. Valid values are EQ (equals) and NE (not equals).</p>
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[Sequence['outputs.TagCriterionPairForJobResponse']]:
        """
        <p>The tag keys, tag values, or tag key and value pairs to use in the condition.</p>
        """
        return pulumi.get(self, "tag_values")


@pulumi.output_type
class TagCriterionPairForJobResponse(dict):
    """
    Definition of TagCriterionPairForJob
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of TagCriterionPairForJob
        :param str key: <p>The value for the tag key to use in the condition.</p>
        :param str value: <p>The tag value to use in the condition.</p>
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        <p>The value for the tag key to use in the condition.</p>
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        <p>The tag value to use in the condition.</p>
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TagFilterResponse(dict):
    """
    Definition of TagFilter
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of TagFilter
        :param str key: The tag key.
        :param str value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TagItemResponse(dict):
    """
    Definition of TagItem
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of TagItem
        :param str key: Property key
        :param str value: Property value
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Property key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TagPropertyResponse(dict):
    """
    Definition of TagProperty
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagateAtLaunch":
            suggest = "propagate_at_launch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TagPropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TagPropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TagPropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 propagate_at_launch: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        Definition of TagProperty
        :param str key: The tag key.
        :param bool propagate_at_launch: Set to ``true`` if you want CloudFormation to copy the tag to EC2 instances that are launched as part of the Auto Scaling group. Set to ``false`` if you want the tag attached only to the Auto Scaling group and not copied to any instances launched as part of the Auto Scaling group.
        :param str value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if propagate_at_launch is not None:
            pulumi.set(__self__, "propagate_at_launch", propagate_at_launch)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="propagateAtLaunch")
    def propagate_at_launch(self) -> Optional[bool]:
        """
        Set to ``true`` if you want CloudFormation to copy the tag to EC2 instances that are launched as part of the Auto Scaling group. Set to ``false`` if you want the tag attached only to the Auto Scaling group and not copied to any instances launched as part of the Auto Scaling group.
        """
        return pulumi.get(self, "propagate_at_launch")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TagResponse(dict):
    """
    Definition of Tag
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of Tag
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TaintResponse(dict):
    """
    Definition of Taint
    """
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of Taint
        :param str effect: Property effect
        :param str key: Property key
        :param str value: Property value
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Property effect
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Property key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TargetDescriptionResponse(dict):
    """
    Definition of TargetDescription
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetDescriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetDescriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetDescriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 id: Optional[str] = None,
                 port: Optional[int] = None):
        """
        Definition of TargetDescription
        :param str availability_zone: <p>An Availability Zone or <code>all</code>. This determines whether the target receives traffic from the load balancer nodes in the specified Availability Zone or from all enabled Availability Zones for the load balancer.</p> <p>For Application Load Balancer target groups, the specified Availability Zone value is only applicable when cross-zone load balancing is off. Otherwise the parameter is ignored and treated as <code>all</code>.</p> <p>This parameter is not supported if the target type of the target group is <code>instance</code> or <code>alb</code>.</p> <p>If the target type is <code>ip</code> and the IP address is in a subnet of the VPC for the target group, the Availability Zone is automatically detected and this parameter is optional. If the IP address is outside the VPC, this parameter is required.</p> <p>For Application Load Balancer target groups with cross-zone load balancing off, if the target type is <code>ip</code> and the IP address is outside of the VPC for the target group, this should be an Availability Zone inside the VPC for the target group.</p> <p>If the target type is <code>lambda</code>, this parameter is optional and the only supported value is <code>all</code>.</p>
        :param str id: <p>The ID of the target. If the target type of the target group is <code>instance</code>, specify an instance ID. If the target type is <code>ip</code>, specify an IP address. If the target type is <code>lambda</code>, specify the ARN of the Lambda function. If the target type is <code>alb</code>, specify the ARN of the Application Load Balancer target. </p>
        :param int port: <p>The port on which the target is listening. If the target group protocol is GENEVE, the supported port is 6081. If the target type is <code>alb</code>, the targeted Application Load Balancer must have at least one listener whose port matches the target group port. This parameter is not used if the target is a Lambda function.</p>
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        <p>An Availability Zone or <code>all</code>. This determines whether the target receives traffic from the load balancer nodes in the specified Availability Zone or from all enabled Availability Zones for the load balancer.</p> <p>For Application Load Balancer target groups, the specified Availability Zone value is only applicable when cross-zone load balancing is off. Otherwise the parameter is ignored and treated as <code>all</code>.</p> <p>This parameter is not supported if the target type of the target group is <code>instance</code> or <code>alb</code>.</p> <p>If the target type is <code>ip</code> and the IP address is in a subnet of the VPC for the target group, the Availability Zone is automatically detected and this parameter is optional. If the IP address is outside the VPC, this parameter is required.</p> <p>For Application Load Balancer target groups with cross-zone load balancing off, if the target type is <code>ip</code> and the IP address is outside of the VPC for the target group, this should be an Availability Zone inside the VPC for the target group.</p> <p>If the target type is <code>lambda</code>, this parameter is optional and the only supported value is <code>all</code>.</p>
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        <p>The ID of the target. If the target type of the target group is <code>instance</code>, specify an instance ID. If the target type is <code>ip</code>, specify an IP address. If the target type is <code>lambda</code>, specify the ARN of the Lambda function. If the target type is <code>alb</code>, specify the ARN of the Application Load Balancer target. </p>
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        <p>The port on which the target is listening. If the target group protocol is GENEVE, the supported port is 6081. If the target type is <code>alb</code>, the targeted Application Load Balancer must have at least one listener whose port matches the target group port. This parameter is not used if the target is a Lambda function.</p>
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class TargetGroupAttributeResponse(dict):
    """
    Definition of TargetGroupAttribute
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Definition of TargetGroupAttribute
        :param str key: The value of the attribute.
        :param str value: The name of the attribute.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The value of the attribute.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TargetGroupStickinessConfigResponse(dict):
    """
    Definition of TargetGroupStickinessConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationSeconds":
            suggest = "duration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupStickinessConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupStickinessConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupStickinessConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_seconds: Optional[int] = None,
                 enabled: Optional[bool] = None):
        """
        Definition of TargetGroupStickinessConfig
        :param int duration_seconds: The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
        :param bool enabled: Indicates whether target group stickiness is enabled.
        """
        if duration_seconds is not None:
            pulumi.set(__self__, "duration_seconds", duration_seconds)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> Optional[int]:
        """
        The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
        """
        return pulumi.get(self, "duration_seconds")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether target group stickiness is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class TargetGroupTupleResponse(dict):
    """
    Definition of TargetGroupTuple
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupArn":
            suggest = "target_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetGroupTupleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetGroupTupleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetGroupTupleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_group_arn: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        Definition of TargetGroupTuple
        :param str target_group_arn: The Amazon Resource Name (ARN) of the target group.
        :param int weight: The weight. The range is 0 to 999.
        """
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the target group.
        """
        return pulumi.get(self, "target_group_arn")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The weight. The range is 0 to 999.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class TargetHealthReasonEnumEnumValueResponse(dict):
    """
    Definition of TargetHealthReasonEnumEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of TargetHealthReasonEnumEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TargetHealthResponse(dict):
    """
    Definition of TargetHealth
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 reason: Optional['outputs.TargetHealthReasonEnumEnumValueResponse'] = None,
                 state: Optional['outputs.TargetHealthStateEnumEnumValueResponse'] = None):
        """
        Definition of TargetHealth
        :param str description: <p>A description of the target health that provides additional details. If the state is <code>healthy</code>, a description is not provided.</p>
        :param 'TargetHealthReasonEnumEnumValueResponse' reason: <p>The reason code.</p> <p>If the target state is <code>healthy</code>, a reason code is not provided.</p> <p>If the target state is <code>initial</code>, the reason code can be one of the following values:</p> <ul> <li> <p> <code>Elb.RegistrationInProgress</code> - The target is in the process of being registered with the load balancer.</p> </li> <li> <p> <code>Elb.InitialHealthChecking</code> - The load balancer is still sending the target the minimum number of health checks required to determine its health status.</p> </li> </ul> <p>If the target state is <code>unhealthy</code>, the reason code can be one of the following values:</p> <ul> <li> <p> <code>Target.ResponseCodeMismatch</code> - The health checks did not return an expected HTTP code. Applies only to Application Load Balancers and Gateway Load Balancers.</p> </li> <li> <p> <code>Target.Timeout</code> - The health check requests timed out. Applies only to Application Load Balancers and Gateway Load Balancers.</p> </li> <li> <p> <code>Target.FailedHealthChecks</code> - The load balancer received an error while establishing a connection to the target or the target response was malformed.</p> </li> <li> <p> <code>Elb.InternalError</code> - The health checks failed due to an internal error. Applies only to Application Load Balancers.</p> </li> </ul> <p>If the target state is <code>unused</code>, the reason code can be one of the following values:</p> <ul> <li> <p> <code>Target.NotRegistered</code> - The target is not registered with the target group.</p> </li> <li> <p> <code>Target.NotInUse</code> - The target group is not used by any load balancer or the target is in an Availability Zone that is not enabled for its load balancer.</p> </li> <li> <p> <code>Target.InvalidState</code> - The target is in the stopped or terminated state.</p> </li> <li> <p> <code>Target.IpUnusable</code> - The target IP address is reserved for use by a load balancer.</p> </li> </ul> <p>If the target state is <code>draining</code>, the reason code can be the following value:</p> <ul> <li> <p> <code>Target.DeregistrationInProgress</code> - The target is in the process of being deregistered and the deregistration delay period has not expired.</p> </li> </ul> <p>If the target state is <code>unavailable</code>, the reason code can be the following value:</p> <ul> <li> <p> <code>Target.HealthCheckDisabled</code> - Health checks are disabled for the target group. Applies only to Application Load Balancers.</p> </li> <li> <p> <code>Elb.InternalError</code> - Target health is unavailable due to an internal error. Applies only to Network Load Balancers.</p> </li> </ul>
        :param 'TargetHealthStateEnumEnumValueResponse' state: <p>The state of the target.</p>
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description of the target health that provides additional details. If the state is <code>healthy</code>, a description is not provided.</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def reason(self) -> Optional['outputs.TargetHealthReasonEnumEnumValueResponse']:
        """
        <p>The reason code.</p> <p>If the target state is <code>healthy</code>, a reason code is not provided.</p> <p>If the target state is <code>initial</code>, the reason code can be one of the following values:</p> <ul> <li> <p> <code>Elb.RegistrationInProgress</code> - The target is in the process of being registered with the load balancer.</p> </li> <li> <p> <code>Elb.InitialHealthChecking</code> - The load balancer is still sending the target the minimum number of health checks required to determine its health status.</p> </li> </ul> <p>If the target state is <code>unhealthy</code>, the reason code can be one of the following values:</p> <ul> <li> <p> <code>Target.ResponseCodeMismatch</code> - The health checks did not return an expected HTTP code. Applies only to Application Load Balancers and Gateway Load Balancers.</p> </li> <li> <p> <code>Target.Timeout</code> - The health check requests timed out. Applies only to Application Load Balancers and Gateway Load Balancers.</p> </li> <li> <p> <code>Target.FailedHealthChecks</code> - The load balancer received an error while establishing a connection to the target or the target response was malformed.</p> </li> <li> <p> <code>Elb.InternalError</code> - The health checks failed due to an internal error. Applies only to Application Load Balancers.</p> </li> </ul> <p>If the target state is <code>unused</code>, the reason code can be one of the following values:</p> <ul> <li> <p> <code>Target.NotRegistered</code> - The target is not registered with the target group.</p> </li> <li> <p> <code>Target.NotInUse</code> - The target group is not used by any load balancer or the target is in an Availability Zone that is not enabled for its load balancer.</p> </li> <li> <p> <code>Target.InvalidState</code> - The target is in the stopped or terminated state.</p> </li> <li> <p> <code>Target.IpUnusable</code> - The target IP address is reserved for use by a load balancer.</p> </li> </ul> <p>If the target state is <code>draining</code>, the reason code can be the following value:</p> <ul> <li> <p> <code>Target.DeregistrationInProgress</code> - The target is in the process of being deregistered and the deregistration delay period has not expired.</p> </li> </ul> <p>If the target state is <code>unavailable</code>, the reason code can be the following value:</p> <ul> <li> <p> <code>Target.HealthCheckDisabled</code> - Health checks are disabled for the target group. Applies only to Application Load Balancers.</p> </li> <li> <p> <code>Elb.InternalError</code> - Target health is unavailable due to an internal error. Applies only to Network Load Balancers.</p> </li> </ul>
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional['outputs.TargetHealthStateEnumEnumValueResponse']:
        """
        <p>The state of the target.</p>
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class TargetHealthStateEnumEnumValueResponse(dict):
    """
    Definition of TargetHealthStateEnumEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of TargetHealthStateEnumEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TargetObjectKeyFormatResponse(dict):
    """
    Definition of TargetObjectKeyFormat
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionedPrefix":
            suggest = "partitioned_prefix"
        elif key == "simplePrefix":
            suggest = "simple_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetObjectKeyFormatResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetObjectKeyFormatResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetObjectKeyFormatResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partitioned_prefix: Optional['outputs.PartitionedPrefixResponse'] = None,
                 simple_prefix: Optional[Any] = None):
        """
        Definition of TargetObjectKeyFormat
        :param 'PartitionedPrefixResponse' partitioned_prefix: Amazon S3 keys for log objects are partitioned in the following format:  ``[DestinationPrefix][SourceAccountId]/[SourceRegion]/[SourceBucket]/[YYYY]/[MM]/[DD]/[YYYY]-[MM]-[DD]-[hh]-[mm]-[ss]-[UniqueString]``  PartitionedPrefix defaults to EventTime delivery when server access logs are delivered.
        :param Any simple_prefix: This format defaults the prefix to the given log file prefix for delivering server access log file.
        """
        if partitioned_prefix is not None:
            pulumi.set(__self__, "partitioned_prefix", partitioned_prefix)
        if simple_prefix is not None:
            pulumi.set(__self__, "simple_prefix", simple_prefix)

    @property
    @pulumi.getter(name="partitionedPrefix")
    def partitioned_prefix(self) -> Optional['outputs.PartitionedPrefixResponse']:
        """
        Amazon S3 keys for log objects are partitioned in the following format:  ``[DestinationPrefix][SourceAccountId]/[SourceRegion]/[SourceBucket]/[YYYY]/[MM]/[DD]/[YYYY]-[MM]-[DD]-[hh]-[mm]-[ss]-[UniqueString]``  PartitionedPrefix defaults to EventTime delivery when server access logs are delivered.
        """
        return pulumi.get(self, "partitioned_prefix")

    @property
    @pulumi.getter(name="simplePrefix")
    def simple_prefix(self) -> Optional[Any]:
        """
        This format defaults the prefix to the given log file prefix for delivering server access log file.
        """
        return pulumi.get(self, "simple_prefix")


@pulumi.output_type
class TaskDefinitionPlacementConstraintResponse(dict):
    """
    Definition of TaskDefinitionPlacementConstraint
    """
    def __init__(__self__, *,
                 expression: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Definition of TaskDefinitionPlacementConstraint
        :param str expression: A cluster query language expression to apply to the constraint. For more information, see [Cluster query language](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param str type: The type of constraint. The ``MemberOf`` constraint restricts selection to be from a group of valid candidates.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        A cluster query language expression to apply to the constraint. For more information, see [Cluster query language](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of constraint. The ``MemberOf`` constraint restricts selection to be from a group of valid candidates.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TenancyEnumValueResponse(dict):
    """
    Definition of TenancyEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of TenancyEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TierResponse(dict):
    """
    Definition of Tier
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Definition of Tier
        :param str name: The name of this environment tier.
        :param str type: The type of this environment tier.
        :param str version: The version of this environment tier. When you don't set a value to it, Elastic Beanstalk uses the latest compatible worker tier version.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of this environment tier.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of this environment tier.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version of this environment tier. When you don't set a value to it, Elastic Beanstalk uses the latest compatible worker tier version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class TieringResponse(dict):
    """
    Definition of Tiering
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessTier":
            suggest = "access_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TieringResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TieringResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TieringResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_tier: Optional[str] = None,
                 days: Optional[int] = None):
        """
        Definition of Tiering
        :param str access_tier: S3 Intelligent-Tiering access tier. See [Storage class for automatically optimizing frequently and infrequently accessed objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access) for a list of access tiers in the S3 Intelligent-Tiering storage class.
        :param int days: The number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier. The minimum number of days specified for Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least 180 days. The maximum can be up to 2 years (730 days).
        """
        if access_tier is not None:
            pulumi.set(__self__, "access_tier", access_tier)
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter(name="accessTier")
    def access_tier(self) -> Optional[str]:
        """
        S3 Intelligent-Tiering access tier. See [Storage class for automatically optimizing frequently and infrequently accessed objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access) for a list of access tiers in the S3 Intelligent-Tiering storage class.
        """
        return pulumi.get(self, "access_tier")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        The number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier. The minimum number of days specified for Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least 180 days. The maximum can be up to 2 years (730 days).
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class TimeToLiveSpecificationResponse(dict):
    """
    Definition of TimeToLiveSpecification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeToLiveSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeToLiveSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeToLiveSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        Definition of TimeToLiveSpecification
        :param str attribute_name: The name of the TTL attribute used to store the expiration time for items in the table.   +  The ``AttributeName`` property is required when enabling the TTL, or when TTL is already enabled.  +  To update this property, you must first disable TTL and then enable TTL with the new attribute name.
        :param bool enabled: Indicates whether TTL is to be enabled (true) or disabled (false) on the table.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        """
        The name of the TTL attribute used to store the expiration time for items in the table.   +  The ``AttributeName`` property is required when enabling the TTL, or when TTL is already enabled.  +  To update this property, you must first disable TTL and then enable TTL with the new attribute name.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether TTL is to be enabled (true) or disabled (false) on the table.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class TimeoutConfigurationResponse(dict):
    """
    Definition of TimeoutConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleTimeoutSeconds":
            suggest = "idle_timeout_seconds"
        elif key == "perRequestTimeoutSeconds":
            suggest = "per_request_timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeoutConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeoutConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeoutConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle_timeout_seconds: Optional[int] = None,
                 per_request_timeout_seconds: Optional[int] = None):
        """
        Definition of TimeoutConfiguration
        :param int idle_timeout_seconds: The amount of time in seconds a connection will stay active while idle. A value of ``0`` can be set to disable ``idleTimeout``. The ``idleTimeout`` default for ``HTTP``/``HTTP2``/``GRPC`` is 5 minutes. The ``idleTimeout`` default for ``TCP`` is 1 hour.
        :param int per_request_timeout_seconds: The amount of time waiting for the upstream to respond with a complete response per request. A value of ``0`` can be set to disable ``perRequestTimeout``. ``perRequestTimeout`` can only be set if Service Connect ``appProtocol`` isn't ``TCP``. Only ``idleTimeout`` is allowed for ``TCP`` ``appProtocol``.
        """
        if idle_timeout_seconds is not None:
            pulumi.set(__self__, "idle_timeout_seconds", idle_timeout_seconds)
        if per_request_timeout_seconds is not None:
            pulumi.set(__self__, "per_request_timeout_seconds", per_request_timeout_seconds)

    @property
    @pulumi.getter(name="idleTimeoutSeconds")
    def idle_timeout_seconds(self) -> Optional[int]:
        """
        The amount of time in seconds a connection will stay active while idle. A value of ``0`` can be set to disable ``idleTimeout``. The ``idleTimeout`` default for ``HTTP``/``HTTP2``/``GRPC`` is 5 minutes. The ``idleTimeout`` default for ``TCP`` is 1 hour.
        """
        return pulumi.get(self, "idle_timeout_seconds")

    @property
    @pulumi.getter(name="perRequestTimeoutSeconds")
    def per_request_timeout_seconds(self) -> Optional[int]:
        """
        The amount of time waiting for the upstream to respond with a complete response per request. A value of ``0`` can be set to disable ``perRequestTimeout``. ``perRequestTimeout`` can only be set if Service Connect ``appProtocol`` isn't ``TCP``. Only ``idleTimeout`` is allowed for ``TCP`` ``appProtocol``.
        """
        return pulumi.get(self, "per_request_timeout_seconds")


@pulumi.output_type
class TmpfsResponse(dict):
    """
    Definition of Tmpfs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerPath":
            suggest = "container_path"
        elif key == "mountOptions":
            suggest = "mount_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TmpfsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TmpfsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TmpfsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_path: Optional[str] = None,
                 mount_options: Optional[Sequence[str]] = None,
                 size: Optional[int] = None):
        """
        Definition of Tmpfs
        :param str container_path: The absolute file path where the tmpfs volume is to be mounted.
        :param Sequence[str] mount_options: The list of tmpfs volume mount options.
        :param int size: The maximum size (in MiB) of the tmpfs volume.
        """
        if container_path is not None:
            pulumi.set(__self__, "container_path", container_path)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="containerPath")
    def container_path(self) -> Optional[str]:
        """
        The absolute file path where the tmpfs volume is to be mounted.
        """
        return pulumi.get(self, "container_path")

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[Sequence[str]]:
        """
        The list of tmpfs volume mount options.
        """
        return pulumi.get(self, "mount_options")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The maximum size (in MiB) of the tmpfs volume.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class TopicConfigurationResponse(dict):
    """
    Definition of TopicConfiguration
    """
    def __init__(__self__, *,
                 event: Optional[str] = None,
                 filter: Optional['outputs.NotificationFilterResponse'] = None,
                 topic: Optional[str] = None):
        """
        Definition of TopicConfiguration
        :param str event: The Amazon S3 bucket event about which to send notifications. For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide*.
        :param 'NotificationFilterResponse' filter: The filtering rules that determine for which objects to send notifications. For example, you can create a filter so that Amazon S3 sends notifications only when image files with a ``.jpg`` extension are added to the bucket. Specifies object key name filtering rules. For information about key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*.
        :param str topic: The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        The Amazon S3 bucket event about which to send notifications. For more information, see [Supported Event Types](https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.NotificationFilterResponse']:
        """
        The filtering rules that determine for which objects to send notifications. For example, you can create a filter so that Amazon S3 sends notifications only when image files with a ``.jpg`` extension are added to the bucket. Specifies object key name filtering rules. For information about key name filtering, see [Configuring event notifications using object key name filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/notification-how-to-filtering.html) in the *Amazon S3 User Guide*.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class TotalLocalStorageGBRequestResponse(dict):
    """
    Definition of TotalLocalStorageGBRequest
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Definition of TotalLocalStorageGBRequest
        :param int max: The storage maximum in GB.
        :param int min: The storage minimum in GB.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The storage maximum in GB.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The storage minimum in GB.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class TpmSupportValuesEnumValueResponse(dict):
    """
    Definition of TpmSupportValuesEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of TpmSupportValuesEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TracingConfigResponse(dict):
    """
    Definition of TracingConfig
    """
    def __init__(__self__, *,
                 mode: Optional[str] = None):
        """
        Definition of TracingConfig
        :param str mode: The tracing mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The tracing mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class TransitionResponse(dict):
    """
    Definition of Transition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"
        elif key == "transitionDate":
            suggest = "transition_date"
        elif key == "transitionInDays":
            suggest = "transition_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_class: Optional[str] = None,
                 transition_date: Optional[str] = None,
                 transition_in_days: Optional[int] = None):
        """
        Definition of Transition
        :param str storage_class: The storage class to which you want the object to transition.
        :param str transition_date: Indicates when objects are transitioned to the specified storage class. The date value must be in ISO 8601 format. The time is always midnight UTC. The date value in ISO 8601 format. The timezone is always UTC. (YYYY-MM-DDThh:mm:ssZ)
        :param int transition_in_days: Indicates the number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer.
        """
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)
        if transition_date is not None:
            pulumi.set(__self__, "transition_date", transition_date)
        if transition_in_days is not None:
            pulumi.set(__self__, "transition_in_days", transition_in_days)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[str]:
        """
        The storage class to which you want the object to transition.
        """
        return pulumi.get(self, "storage_class")

    @property
    @pulumi.getter(name="transitionDate")
    def transition_date(self) -> Optional[str]:
        """
        Indicates when objects are transitioned to the specified storage class. The date value must be in ISO 8601 format. The time is always midnight UTC. The date value in ISO 8601 format. The timezone is always UTC. (YYYY-MM-DDThh:mm:ssZ)
        """
        return pulumi.get(self, "transition_date")

    @property
    @pulumi.getter(name="transitionInDays")
    def transition_in_days(self) -> Optional[int]:
        """
        Indicates the number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer.
        """
        return pulumi.get(self, "transition_in_days")


@pulumi.output_type
class UlimitResponse(dict):
    """
    Definition of Ulimit
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hardLimit":
            suggest = "hard_limit"
        elif key == "softLimit":
            suggest = "soft_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UlimitResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UlimitResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UlimitResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hard_limit: Optional[int] = None,
                 name: Optional[str] = None,
                 soft_limit: Optional[int] = None):
        """
        Definition of Ulimit
        :param int hard_limit: The hard limit for the ``ulimit`` type.
        :param str name: The ``type`` of the ``ulimit``.
        :param int soft_limit: The soft limit for the ``ulimit`` type.
        """
        if hard_limit is not None:
            pulumi.set(__self__, "hard_limit", hard_limit)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if soft_limit is not None:
            pulumi.set(__self__, "soft_limit", soft_limit)

    @property
    @pulumi.getter(name="hardLimit")
    def hard_limit(self) -> Optional[int]:
        """
        The hard limit for the ``ulimit`` type.
        """
        return pulumi.get(self, "hard_limit")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The ``type`` of the ``ulimit``.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="softLimit")
    def soft_limit(self) -> Optional[int]:
        """
        The soft limit for the ``ulimit`` type.
        """
        return pulumi.get(self, "soft_limit")


@pulumi.output_type
class UnusedAccessConfigurationResponse(dict):
    """
    Definition of UnusedAccessConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unusedAccessAge":
            suggest = "unused_access_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnusedAccessConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnusedAccessConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnusedAccessConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 unused_access_age: Optional[int] = None):
        """
        Definition of UnusedAccessConfiguration
        :param int unused_access_age: The specified access age in days for which to generate findings for unused access. For example, if you specify 90 days, the analyzer will generate findings for IAM entities within the accounts of the selected organization for any access that hasn't been used in 90 or more days since the analyzer's last scan. You can choose a value between 1 and 180 days.
        """
        if unused_access_age is not None:
            pulumi.set(__self__, "unused_access_age", unused_access_age)

    @property
    @pulumi.getter(name="unusedAccessAge")
    def unused_access_age(self) -> Optional[int]:
        """
        The specified access age in days for which to generate findings for unused access. For example, if you specify 90 days, the analyzer will generate findings for IAM entities within the accounts of the selected organization for any access that hasn't been used in 90 or more days since the analyzer's last scan. You can choose a value between 1 and 180 days.
        """
        return pulumi.get(self, "unused_access_age")


@pulumi.output_type
class UpdateConfigResponse(dict):
    """
    Definition of UpdateConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxUnavailable":
            suggest = "max_unavailable"
        elif key == "maxUnavailablePercentage":
            suggest = "max_unavailable_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpdateConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpdateConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpdateConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None,
                 max_unavailable_percentage: Optional[int] = None):
        """
        Definition of UpdateConfig
        :param int max_unavailable: The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. This value or maxUnavailablePercentage is required to have a value.The maximum number is 100.
        :param int max_unavailable_percentage: The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or maxUnavailable is required to have a value.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if max_unavailable_percentage is not None:
            pulumi.set(__self__, "max_unavailable_percentage", max_unavailable_percentage)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. This value or maxUnavailablePercentage is required to have a value.The maximum number is 100.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter(name="maxUnavailablePercentage")
    def max_unavailable_percentage(self) -> Optional[int]:
        """
        The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or maxUnavailable is required to have a value.
        """
        return pulumi.get(self, "max_unavailable_percentage")


@pulumi.output_type
class UserIdGroupPairResponse(dict):
    """
    Definition of UserIdGroupPair
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "peeringStatus":
            suggest = "peering_status"
        elif key == "userId":
            suggest = "user_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserIdGroupPairResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserIdGroupPairResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserIdGroupPairResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 group_id: Optional[str] = None,
                 group_name: Optional[str] = None,
                 peering_status: Optional[str] = None,
                 user_id: Optional[str] = None,
                 vpc_id: Optional[str] = None,
                 vpc_peering_connection_id: Optional[str] = None):
        """
        Definition of UserIdGroupPair
        :param str description: <p>A description for the security group rule that references this user ID group pair.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>
        :param str group_id: <p>The ID of the security group.</p>
        :param str group_name: <p>[Default VPC] The name of the security group. For a security group in a nondefault VPC, use the security group ID. </p> <p>For a referenced security group in another VPC, this value is not returned if the referenced security group is deleted.</p>
        :param str peering_status: <p>The status of a VPC peering connection, if applicable.</p>
        :param str user_id: <p>The ID of an Amazon Web Services account.</p> <p>For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.</p>
        :param str vpc_id: <p>The ID of the VPC for the referenced security group, if applicable.</p>
        :param str vpc_peering_connection_id: <p>The ID of the VPC peering connection, if applicable.</p>
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if peering_status is not None:
            pulumi.set(__self__, "peering_status", peering_status)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        <p>A description for the security group rule that references this user ID group pair.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        <p>The ID of the security group.</p>
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        <p>[Default VPC] The name of the security group. For a security group in a nondefault VPC, use the security group ID. </p> <p>For a referenced security group in another VPC, this value is not returned if the referenced security group is deleted.</p>
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="peeringStatus")
    def peering_status(self) -> Optional[str]:
        """
        <p>The status of a VPC peering connection, if applicable.</p>
        """
        return pulumi.get(self, "peering_status")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        <p>The ID of an Amazon Web Services account.</p> <p>For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.</p>
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        <p>The ID of the VPC for the referenced security group, if applicable.</p>
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[str]:
        """
        <p>The ID of the VPC peering connection, if applicable.</p>
        """
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class UserPausedDetailsResponse(dict):
    """
    Definition of UserPausedDetails
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobExpiresAt":
            suggest = "job_expires_at"
        elif key == "jobImminentExpirationHealthEventArn":
            suggest = "job_imminent_expiration_health_event_arn"
        elif key == "jobPausedAt":
            suggest = "job_paused_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPausedDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPausedDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPausedDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_expires_at: Optional[str] = None,
                 job_imminent_expiration_health_event_arn: Optional[str] = None,
                 job_paused_at: Optional[str] = None):
        """
        Definition of UserPausedDetails
        :param str job_expires_at: <p>The date and time, in UTC and extended ISO 8601 format, when the job or job run will expire and be cancelled if you don't resume it first.</p>
        :param str job_imminent_expiration_health_event_arn: <p>The Amazon Resource Name (ARN) of the Health event that Amazon Macie sent to notify you of the job or job run's pending expiration and cancellation. This value is null if a job has been paused for less than 23 days.</p>
        :param str job_paused_at: <p>The date and time, in UTC and extended ISO 8601 format, when you paused the job.</p>
        """
        if job_expires_at is not None:
            pulumi.set(__self__, "job_expires_at", job_expires_at)
        if job_imminent_expiration_health_event_arn is not None:
            pulumi.set(__self__, "job_imminent_expiration_health_event_arn", job_imminent_expiration_health_event_arn)
        if job_paused_at is not None:
            pulumi.set(__self__, "job_paused_at", job_paused_at)

    @property
    @pulumi.getter(name="jobExpiresAt")
    def job_expires_at(self) -> Optional[str]:
        """
        <p>The date and time, in UTC and extended ISO 8601 format, when the job or job run will expire and be cancelled if you don't resume it first.</p>
        """
        return pulumi.get(self, "job_expires_at")

    @property
    @pulumi.getter(name="jobImminentExpirationHealthEventArn")
    def job_imminent_expiration_health_event_arn(self) -> Optional[str]:
        """
        <p>The Amazon Resource Name (ARN) of the Health event that Amazon Macie sent to notify you of the job or job run's pending expiration and cancellation. This value is null if a job has been paused for less than 23 days.</p>
        """
        return pulumi.get(self, "job_imminent_expiration_health_event_arn")

    @property
    @pulumi.getter(name="jobPausedAt")
    def job_paused_at(self) -> Optional[str]:
        """
        <p>The date and time, in UTC and extended ISO 8601 format, when you paused the job.</p>
        """
        return pulumi.get(self, "job_paused_at")


@pulumi.output_type
class UserPoolConfigResponse(dict):
    """
    Definition of UserPoolConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appIdClientRegex":
            suggest = "app_id_client_regex"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "defaultAction":
            suggest = "default_action"
        elif key == "userPoolId":
            suggest = "user_pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPoolConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPoolConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPoolConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id_client_regex: Optional[str] = None,
                 aws_region: Optional[str] = None,
                 default_action: Optional['outputs.DefaultActionEnumValueResponse'] = None,
                 user_pool_id: Optional[str] = None):
        """
        Definition of UserPoolConfig
        :param str app_id_client_regex: <p>A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.</p>
        :param str aws_region: <p>The Amazon Web Services Region in which the user pool was created.</p>
        :param 'DefaultActionEnumValueResponse' default_action: <p>The action that you want your GraphQL API to take when a request that uses Amazon Cognito user pool authentication doesn't match the Amazon Cognito user pool configuration.</p>
        :param str user_pool_id: <p>The user pool ID.</p>
        """
        if app_id_client_regex is not None:
            pulumi.set(__self__, "app_id_client_regex", app_id_client_regex)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if default_action is not None:
            pulumi.set(__self__, "default_action", default_action)
        if user_pool_id is not None:
            pulumi.set(__self__, "user_pool_id", user_pool_id)

    @property
    @pulumi.getter(name="appIdClientRegex")
    def app_id_client_regex(self) -> Optional[str]:
        """
        <p>A regular expression for validating the incoming Amazon Cognito user pool app client ID. If this value isn't set, no filtering is applied.</p>
        """
        return pulumi.get(self, "app_id_client_regex")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        <p>The Amazon Web Services Region in which the user pool was created.</p>
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> Optional['outputs.DefaultActionEnumValueResponse']:
        """
        <p>The action that you want your GraphQL API to take when a request that uses Amazon Cognito user pool authentication doesn't match the Amazon Cognito user pool configuration.</p>
        """
        return pulumi.get(self, "default_action")

    @property
    @pulumi.getter(name="userPoolId")
    def user_pool_id(self) -> Optional[str]:
        """
        <p>The user pool ID.</p>
        """
        return pulumi.get(self, "user_pool_id")


@pulumi.output_type
class VCpuCountRequestResponse(dict):
    """
    Definition of VCpuCountRequest
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Definition of VCpuCountRequest
        :param int max: The maximum number of vCPUs.
        :param int min: The minimum number of vCPUs.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of vCPUs.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class VPCDerivedInfoResponse(dict):
    """
    Definition of VPCDerivedInfo
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCDerivedInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCDerivedInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCDerivedInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zones: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of VPCDerivedInfo
        :param Sequence[str] availability_zones: <p>The list of Availability Zones associated with the VPC subnets.</p>
        :param Sequence[str] security_group_ids: <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
        :param Sequence[str] subnet_ids: <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
        :param str vpc_id: <p>The ID for your VPC. Amazon VPC generates this value when you create a VPC.</p>
        """
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        """
        <p>The list of Availability Zones associated with the VPC subnets.</p>
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        <p>The list of security group IDs associated with the VPC endpoints for the domain.</p>
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        <p>A list of subnet IDs associated with the VPC endpoints for the domain.</p>
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        <p>The ID for your VPC. Amazon VPC generates this value when you create a VPC.</p>
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class VPCResponse(dict):
    """
    Definition of VPC
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcId":
            suggest = "vpc_id"
        elif key == "vpcRegion":
            suggest = "vpc_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VPCResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VPCResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VPCResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_id: Optional[str] = None,
                 vpc_region: Optional[str] = None):
        """
        Definition of VPC
        :param str vpc_id: *Private hosted zones only:* The ID of an Amazon VPC.  For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
        :param str vpc_region: *Private hosted zones only:* The region that an Amazon VPC was created in.  For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
        """
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)
        if vpc_region is not None:
            pulumi.set(__self__, "vpc_region", vpc_region)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        *Private hosted zones only:* The ID of an Amazon VPC.  For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vpcRegion")
    def vpc_region(self) -> Optional[str]:
        """
        *Private hosted zones only:* The region that an Amazon VPC was created in.  For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
        """
        return pulumi.get(self, "vpc_region")


@pulumi.output_type
class VersioningConfigurationResponse(dict):
    """
    Definition of VersioningConfiguration
    """
    def __init__(__self__, *,
                 status: Optional[str] = None):
        """
        Definition of VersioningConfiguration
        :param str status: The versioning state of the bucket.
        """
        if status is None:
            status = 'Suspended'
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The versioning state of the bucket.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ViewerCertificateResponse(dict):
    """
    Definition of ViewerCertificate
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acmCertificateArn":
            suggest = "acm_certificate_arn"
        elif key == "cloudFrontDefaultCertificate":
            suggest = "cloud_front_default_certificate"
        elif key == "iamCertificateId":
            suggest = "iam_certificate_id"
        elif key == "minimumProtocolVersion":
            suggest = "minimum_protocol_version"
        elif key == "sslSupportMethod":
            suggest = "ssl_support_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ViewerCertificateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ViewerCertificateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ViewerCertificateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acm_certificate_arn: Optional[str] = None,
                 cloud_front_default_certificate: Optional[bool] = None,
                 iam_certificate_id: Optional[str] = None,
                 minimum_protocol_version: Optional[str] = None,
                 ssl_support_method: Optional[str] = None):
        """
        Definition of ViewerCertificate
        :param str acm_certificate_arn: In CloudFormation, this field name is ``AcmCertificateArn``. Note the different capitalization.  If the distribution uses ``Aliases`` (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [(ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html), provide the Amazon Resource Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US East (N. Virginia) Region (``us-east-1``). If you specify an ACM certificate ARN, you must also specify values for ``MinimumProtocolVersion`` and ``SSLSupportMethod``. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.)
        :param bool cloud_front_default_certificate: If the distribution uses the CloudFront domain name such as ``d111111abcdef8.cloudfront.net``, set this field to ``true``. If the distribution uses ``Aliases`` (alternate domain names or CNAMEs), omit this field and specify values for the following fields:  +   ``AcmCertificateArn`` or ``IamCertificateId`` (specify a value for one, not both)   +   ``MinimumProtocolVersion``   +   ``SslSupportMethod``
        :param str iam_certificate_id: In CloudFormation, this field name is ``IamCertificateId``. Note the different capitalization.  If the distribution uses ``Aliases`` (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [(IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html), provide the ID of the IAM certificate. If you specify an IAM certificate ID, you must also specify values for ``MinimumProtocolVersion`` and ``SSLSupportMethod``. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.)
        :param str minimum_protocol_version: If the distribution uses ``Aliases`` (alternate domain names or CNAMEs), specify the security policy that you want CloudFront to use for HTTPS connections with viewers. The security policy determines two settings:  +  The minimum SSL/TLS protocol that CloudFront can use to communicate with viewers.  +  The ciphers that CloudFront can use to encrypt the content that it returns to viewers.   For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) and [Supported Protocols and Ciphers Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers) in the *Amazon CloudFront Developer Guide*.  On the CloudFront console, this setting is called *Security Policy*.  When you're using SNI only (you set ``SSLSupportMethod`` to ``sni-only``), you must specify ``TLSv1`` or higher. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.) If the distribution uses the CloudFront domain name such as ``d111111abcdef8.cloudfront.net`` (you set ``CloudFrontDefaultCertificate`` to ``true``), CloudFront automatically sets the security policy to ``TLSv1`` regardless of the value that you set here.
        :param str ssl_support_method: In CloudFormation, this field name is ``SslSupportMethod``. Note the different capitalization.  If the distribution uses ``Aliases`` (alternate domain names or CNAMEs), specify which viewers the distribution accepts HTTPS connections from.  +   ``sni-only``  The distribution accepts HTTPS connections from only viewers that support [server name indication (SNI)](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Server_Name_Indication). This is recommended. Most browsers and clients support SNI.  +   ``vip``  The distribution accepts HTTPS connections from all viewers including those that don't support SNI. This is not recommended, and results in additional monthly charges from CloudFront.  +   ``static-ip`` - Do not specify this value unless your distribution has been enabled for this feature by the CloudFront team. If you have a use case that requires static IP addresses for a distribution, contact CloudFront through the [Center](https://docs.aws.amazon.com/support/home).   If the distribution uses the CloudFront domain name such as ``d111111abcdef8.cloudfront.net``, don't set a value for this field.
        """
        if acm_certificate_arn is not None:
            pulumi.set(__self__, "acm_certificate_arn", acm_certificate_arn)
        if cloud_front_default_certificate is not None:
            pulumi.set(__self__, "cloud_front_default_certificate", cloud_front_default_certificate)
        if iam_certificate_id is not None:
            pulumi.set(__self__, "iam_certificate_id", iam_certificate_id)
        if minimum_protocol_version is not None:
            pulumi.set(__self__, "minimum_protocol_version", minimum_protocol_version)
        if ssl_support_method is not None:
            pulumi.set(__self__, "ssl_support_method", ssl_support_method)

    @property
    @pulumi.getter(name="acmCertificateArn")
    def acm_certificate_arn(self) -> Optional[str]:
        """
        In CloudFormation, this field name is ``AcmCertificateArn``. Note the different capitalization.  If the distribution uses ``Aliases`` (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [(ACM)](https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html), provide the Amazon Resource Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US East (N. Virginia) Region (``us-east-1``). If you specify an ACM certificate ARN, you must also specify values for ``MinimumProtocolVersion`` and ``SSLSupportMethod``. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.)
        """
        return pulumi.get(self, "acm_certificate_arn")

    @property
    @pulumi.getter(name="cloudFrontDefaultCertificate")
    def cloud_front_default_certificate(self) -> Optional[bool]:
        """
        If the distribution uses the CloudFront domain name such as ``d111111abcdef8.cloudfront.net``, set this field to ``true``. If the distribution uses ``Aliases`` (alternate domain names or CNAMEs), omit this field and specify values for the following fields:  +   ``AcmCertificateArn`` or ``IamCertificateId`` (specify a value for one, not both)   +   ``MinimumProtocolVersion``   +   ``SslSupportMethod``
        """
        return pulumi.get(self, "cloud_front_default_certificate")

    @property
    @pulumi.getter(name="iamCertificateId")
    def iam_certificate_id(self) -> Optional[str]:
        """
        In CloudFormation, this field name is ``IamCertificateId``. Note the different capitalization.  If the distribution uses ``Aliases`` (alternate domain names or CNAMEs) and the SSL/TLS certificate is stored in [(IAM)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html), provide the ID of the IAM certificate. If you specify an IAM certificate ID, you must also specify values for ``MinimumProtocolVersion`` and ``SSLSupportMethod``. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.)
        """
        return pulumi.get(self, "iam_certificate_id")

    @property
    @pulumi.getter(name="minimumProtocolVersion")
    def minimum_protocol_version(self) -> Optional[str]:
        """
        If the distribution uses ``Aliases`` (alternate domain names or CNAMEs), specify the security policy that you want CloudFront to use for HTTPS connections with viewers. The security policy determines two settings:  +  The minimum SSL/TLS protocol that CloudFront can use to communicate with viewers.  +  The ciphers that CloudFront can use to encrypt the content that it returns to viewers.   For more information, see [Security Policy](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy) and [Supported Protocols and Ciphers Between Viewers and CloudFront](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers) in the *Amazon CloudFront Developer Guide*.  On the CloudFront console, this setting is called *Security Policy*.  When you're using SNI only (you set ``SSLSupportMethod`` to ``sni-only``), you must specify ``TLSv1`` or higher. (In CloudFormation, the field name is ``SslSupportMethod``. Note the different capitalization.) If the distribution uses the CloudFront domain name such as ``d111111abcdef8.cloudfront.net`` (you set ``CloudFrontDefaultCertificate`` to ``true``), CloudFront automatically sets the security policy to ``TLSv1`` regardless of the value that you set here.
        """
        return pulumi.get(self, "minimum_protocol_version")

    @property
    @pulumi.getter(name="sslSupportMethod")
    def ssl_support_method(self) -> Optional[str]:
        """
        In CloudFormation, this field name is ``SslSupportMethod``. Note the different capitalization.  If the distribution uses ``Aliases`` (alternate domain names or CNAMEs), specify which viewers the distribution accepts HTTPS connections from.  +   ``sni-only``  The distribution accepts HTTPS connections from only viewers that support [server name indication (SNI)](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Server_Name_Indication). This is recommended. Most browsers and clients support SNI.  +   ``vip``  The distribution accepts HTTPS connections from all viewers including those that don't support SNI. This is not recommended, and results in additional monthly charges from CloudFront.  +   ``static-ip`` - Do not specify this value unless your distribution has been enabled for this feature by the CloudFront team. If you have a use case that requires static IP addresses for a distribution, contact CloudFront through the [Center](https://docs.aws.amazon.com/support/home).   If the distribution uses the CloudFront domain name such as ``d111111abcdef8.cloudfront.net``, don't set a value for this field.
        """
        return pulumi.get(self, "ssl_support_method")


@pulumi.output_type
class VirtualizationTypeEnumValueResponse(dict):
    """
    Definition of VirtualizationTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of VirtualizationTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VolumeFromResponse(dict):
    """
    Definition of VolumeFrom
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnly":
            suggest = "read_only"
        elif key == "sourceContainer":
            suggest = "source_container"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeFromResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeFromResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeFromResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_only: Optional[bool] = None,
                 source_container: Optional[str] = None):
        """
        Definition of VolumeFrom
        :param bool read_only: If this value is ``true``, the container has read-only access to the volume. If this value is ``false``, then the container can write to the volume. The default value is ``false``.
        :param str source_container: The name of another container within the same task definition to mount volumes from.
        """
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if source_container is not None:
            pulumi.set(__self__, "source_container", source_container)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        If this value is ``true``, the container has read-only access to the volume. If this value is ``false``, then the container can write to the volume. The default value is ``false``.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="sourceContainer")
    def source_container(self) -> Optional[str]:
        """
        The name of another container within the same task definition to mount volumes from.
        """
        return pulumi.get(self, "source_container")


@pulumi.output_type
class VolumeResponse(dict):
    """
    Definition of Volume
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configuredAtLaunch":
            suggest = "configured_at_launch"
        elif key == "dockerVolumeConfiguration":
            suggest = "docker_volume_configuration"
        elif key == "efsVolumeConfiguration":
            suggest = "efs_volume_configuration"
        elif key == "fSxWindowsFileServerVolumeConfiguration":
            suggest = "f_sx_windows_file_server_volume_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configured_at_launch: Optional[bool] = None,
                 docker_volume_configuration: Optional['outputs.DockerVolumeConfigurationResponse'] = None,
                 efs_volume_configuration: Optional['outputs.EFSVolumeConfigurationResponse'] = None,
                 f_sx_windows_file_server_volume_configuration: Optional['outputs.FSxWindowsFileServerVolumeConfigurationResponse'] = None,
                 host: Optional['outputs.HostVolumePropertiesResponse'] = None,
                 name: Optional[str] = None):
        """
        Definition of Volume
        :param bool configured_at_launch: Indicates whether the volume should be configured at launch time. This is used to create Amazon EBS volumes for standalone tasks or tasks created as part of a service. Each task definition revision may only have one volume configured at launch in the volume configuration. To configure a volume at launch time, use this task definition revision and specify a ``volumeConfigurations`` object when calling the ``CreateService``, ``UpdateService``, ``RunTask`` or ``StartTask`` APIs.
        :param 'DockerVolumeConfigurationResponse' docker_volume_configuration: This parameter is specified when you use Docker volumes. Windows containers only support the use of the ``local`` driver. To use bind mounts, specify the ``host`` parameter instead.  Docker volumes aren't supported by tasks run on FARGATElong. The ``DockerVolumeConfiguration`` property specifies a Docker volume configuration and is used when you use Docker volumes. Docker volumes are only supported when you are using the EC2 launch type. Windows containers only support the use of the ``local`` driver. To use bind mounts, specify a ``host`` instead.
        :param 'EFSVolumeConfigurationResponse' efs_volume_configuration: This parameter is specified when you use an Amazon Elastic File System file system for task storage. This parameter is specified when you're using an Amazon Elastic File System file system for task storage. For more information, see [Amazon EFS volumes](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param 'FSxWindowsFileServerVolumeConfigurationResponse' f_sx_windows_file_server_volume_configuration: This parameter is specified when you use Amazon FSx for Windows File Server file system for task storage. This parameter is specified when you're using [Amazon FSx for Windows File Server](https://docs.aws.amazon.com/fsx/latest/WindowsGuide/what-is.html) file system for task storage. For more information and the input format, see [Amazon FSx for Windows File Server volumes](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/wfsx-volumes.html) in the *Amazon Elastic Container Service Developer Guide*.
        :param 'HostVolumePropertiesResponse' host: This parameter is specified when you use bind mount host volumes. The contents of the ``host`` parameter determine whether your bind mount host volume persists on the host container instance and where it's stored. If the ``host`` parameter is empty, then the Docker daemon assigns a host path for your data volume. However, the data isn't guaranteed to persist after the containers that are associated with it stop running. Windows containers can mount whole directories on the same drive as ``$env:ProgramData``. Windows containers can't mount directories on a different drive, and mount point can't be across drives. For example, you can mount ``C:\\my\\path:C:\\my\\path`` and ``D:\\:D:\\``, but not ``D:\\my\\path:C:\\my\\path`` or ``D:\\:C:\\my\\path``. The ``HostVolumeProperties`` property specifies details on a container instance bind mount host volume.
        :param str name: The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. When using a volume configured at launch, the ``name`` is required and must also be specified as the volume name in the ``ServiceVolumeConfiguration`` or ``TaskVolumeConfiguration`` parameter when creating your service or standalone task. For all other types of volumes, this name is referenced in the ``sourceVolume`` parameter of the ``mountPoints`` object in the container definition. When a volume is using the ``efsVolumeConfiguration``, the name is required.
        """
        if configured_at_launch is not None:
            pulumi.set(__self__, "configured_at_launch", configured_at_launch)
        if docker_volume_configuration is not None:
            pulumi.set(__self__, "docker_volume_configuration", docker_volume_configuration)
        if efs_volume_configuration is not None:
            pulumi.set(__self__, "efs_volume_configuration", efs_volume_configuration)
        if f_sx_windows_file_server_volume_configuration is not None:
            pulumi.set(__self__, "f_sx_windows_file_server_volume_configuration", f_sx_windows_file_server_volume_configuration)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="configuredAtLaunch")
    def configured_at_launch(self) -> Optional[bool]:
        """
        Indicates whether the volume should be configured at launch time. This is used to create Amazon EBS volumes for standalone tasks or tasks created as part of a service. Each task definition revision may only have one volume configured at launch in the volume configuration. To configure a volume at launch time, use this task definition revision and specify a ``volumeConfigurations`` object when calling the ``CreateService``, ``UpdateService``, ``RunTask`` or ``StartTask`` APIs.
        """
        return pulumi.get(self, "configured_at_launch")

    @property
    @pulumi.getter(name="dockerVolumeConfiguration")
    def docker_volume_configuration(self) -> Optional['outputs.DockerVolumeConfigurationResponse']:
        """
        This parameter is specified when you use Docker volumes. Windows containers only support the use of the ``local`` driver. To use bind mounts, specify the ``host`` parameter instead.  Docker volumes aren't supported by tasks run on FARGATElong. The ``DockerVolumeConfiguration`` property specifies a Docker volume configuration and is used when you use Docker volumes. Docker volumes are only supported when you are using the EC2 launch type. Windows containers only support the use of the ``local`` driver. To use bind mounts, specify a ``host`` instead.
        """
        return pulumi.get(self, "docker_volume_configuration")

    @property
    @pulumi.getter(name="efsVolumeConfiguration")
    def efs_volume_configuration(self) -> Optional['outputs.EFSVolumeConfigurationResponse']:
        """
        This parameter is specified when you use an Amazon Elastic File System file system for task storage. This parameter is specified when you're using an Amazon Elastic File System file system for task storage. For more information, see [Amazon EFS volumes](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "efs_volume_configuration")

    @property
    @pulumi.getter(name="fSxWindowsFileServerVolumeConfiguration")
    def f_sx_windows_file_server_volume_configuration(self) -> Optional['outputs.FSxWindowsFileServerVolumeConfigurationResponse']:
        """
        This parameter is specified when you use Amazon FSx for Windows File Server file system for task storage. This parameter is specified when you're using [Amazon FSx for Windows File Server](https://docs.aws.amazon.com/fsx/latest/WindowsGuide/what-is.html) file system for task storage. For more information and the input format, see [Amazon FSx for Windows File Server volumes](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/wfsx-volumes.html) in the *Amazon Elastic Container Service Developer Guide*.
        """
        return pulumi.get(self, "f_sx_windows_file_server_volume_configuration")

    @property
    @pulumi.getter
    def host(self) -> Optional['outputs.HostVolumePropertiesResponse']:
        """
        This parameter is specified when you use bind mount host volumes. The contents of the ``host`` parameter determine whether your bind mount host volume persists on the host container instance and where it's stored. If the ``host`` parameter is empty, then the Docker daemon assigns a host path for your data volume. However, the data isn't guaranteed to persist after the containers that are associated with it stop running. Windows containers can mount whole directories on the same drive as ``$env:ProgramData``. Windows containers can't mount directories on a different drive, and mount point can't be across drives. For example, you can mount ``C:\\my\\path:C:\\my\\path`` and ``D:\\:D:\\``, but not ``D:\\my\\path:C:\\my\\path`` or ``D:\\:C:\\my\\path``. The ``HostVolumeProperties`` property specifies details on a container instance bind mount host volume.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. When using a volume configured at launch, the ``name`` is required and must also be specified as the volume name in the ``ServiceVolumeConfiguration`` or ``TaskVolumeConfiguration`` parameter when creating your service or standalone task. For all other types of volumes, this name is referenced in the ``sourceVolume`` parameter of the ``mountPoints`` object in the container definition. When a volume is using the ``efsVolumeConfiguration``, the name is required.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VolumeTypeEnumValueResponse(dict):
    """
    Definition of VolumeTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of VolumeTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpcConfigResponse(dict):
    """
    Definition of VpcConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterSecurityGroupId":
            suggest = "cluster_security_group_id"
        elif key == "endpointPrivateAccess":
            suggest = "endpoint_private_access"
        elif key == "endpointPublicAccess":
            suggest = "endpoint_public_access"
        elif key == "ipv6AllowedForDualStack":
            suggest = "ipv6_allowed_for_dual_stack"
        elif key == "publicAccessCidrs":
            suggest = "public_access_cidrs"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_security_group_id: Optional[str] = None,
                 endpoint_private_access: Optional[bool] = None,
                 endpoint_public_access: Optional[bool] = None,
                 ipv6_allowed_for_dual_stack: Optional[bool] = None,
                 public_access_cidrs: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None,
                 subnets: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of VpcConfig
        :param str cluster_security_group_id: <p>The cluster security group that was created by Amazon EKS for the cluster. Managed node groups use this security group for control-plane-to-data-plane communication.</p>
        :param bool endpoint_private_access: <p>This parameter indicates whether the Amazon EKS private API server endpoint is enabled. If the Amazon EKS private API server endpoint is enabled, Kubernetes API requests that originate from within your cluster's VPC use the private VPC endpoint instead of traversing the internet. If this value is disabled and you have nodes or Fargate pods in the cluster, then ensure that <code>publicAccessCidrs</code> includes the necessary CIDR blocks for communication with the nodes or Fargate pods. For more information, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html'>Amazon EKS cluster endpoint access control</a> in the <i> <i>Amazon EKS User Guide</i> </i>.</p>
        :param bool endpoint_public_access: <p>Whether the public API server endpoint is enabled.</p>
        :param bool ipv6_allowed_for_dual_stack: Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        :param Sequence[str] public_access_cidrs: <p>The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint.</p>
        :param Sequence[str] security_group_ids: A list of VPC security group IDs.
        :param Sequence[str] subnet_ids: A list of VPC subnet IDs.
        :param Sequence[str] subnets: <p>A list of one or more subnet IDs in your Amazon VPC.</p>
        :param str vpc_id: <p>The VPC associated with your cluster.</p>
        """
        if cluster_security_group_id is not None:
            pulumi.set(__self__, "cluster_security_group_id", cluster_security_group_id)
        if endpoint_private_access is not None:
            pulumi.set(__self__, "endpoint_private_access", endpoint_private_access)
        if endpoint_public_access is not None:
            pulumi.set(__self__, "endpoint_public_access", endpoint_public_access)
        if ipv6_allowed_for_dual_stack is not None:
            pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if public_access_cidrs is not None:
            pulumi.set(__self__, "public_access_cidrs", public_access_cidrs)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="clusterSecurityGroupId")
    def cluster_security_group_id(self) -> Optional[str]:
        """
        <p>The cluster security group that was created by Amazon EKS for the cluster. Managed node groups use this security group for control-plane-to-data-plane communication.</p>
        """
        return pulumi.get(self, "cluster_security_group_id")

    @property
    @pulumi.getter(name="endpointPrivateAccess")
    def endpoint_private_access(self) -> Optional[bool]:
        """
        <p>This parameter indicates whether the Amazon EKS private API server endpoint is enabled. If the Amazon EKS private API server endpoint is enabled, Kubernetes API requests that originate from within your cluster's VPC use the private VPC endpoint instead of traversing the internet. If this value is disabled and you have nodes or Fargate pods in the cluster, then ensure that <code>publicAccessCidrs</code> includes the necessary CIDR blocks for communication with the nodes or Fargate pods. For more information, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html'>Amazon EKS cluster endpoint access control</a> in the <i> <i>Amazon EKS User Guide</i> </i>.</p>
        """
        return pulumi.get(self, "endpoint_private_access")

    @property
    @pulumi.getter(name="endpointPublicAccess")
    def endpoint_public_access(self) -> Optional[bool]:
        """
        <p>Whether the public API server endpoint is enabled.</p>
        """
        return pulumi.get(self, "endpoint_public_access")

    @property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[bool]:
        """
        Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.
        """
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @property
    @pulumi.getter(name="publicAccessCidrs")
    def public_access_cidrs(self) -> Optional[Sequence[str]]:
        """
        <p>The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint.</p>
        """
        return pulumi.get(self, "public_access_cidrs")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of VPC security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        A list of VPC subnet IDs.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        """
        <p>A list of one or more subnet IDs in your Amazon VPC.</p>
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        <p>The VPC associated with your cluster.</p>
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class VpcConfigResponseResponse(dict):
    """
    Definition of VpcConfigResponse
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterSecurityGroupId":
            suggest = "cluster_security_group_id"
        elif key == "endpointPrivateAccess":
            suggest = "endpoint_private_access"
        elif key == "endpointPublicAccess":
            suggest = "endpoint_public_access"
        elif key == "publicAccessCidrs":
            suggest = "public_access_cidrs"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcConfigResponseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcConfigResponseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcConfigResponseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_security_group_id: Optional[str] = None,
                 endpoint_private_access: Optional[bool] = None,
                 endpoint_public_access: Optional[bool] = None,
                 public_access_cidrs: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        """
        Definition of VpcConfigResponse
        :param str cluster_security_group_id: <p>The cluster security group that was created by Amazon EKS for the cluster. Managed node groups use this security group for control-plane-to-data-plane communication.</p>
        :param bool endpoint_private_access: <p>This parameter indicates whether the Amazon EKS private API server endpoint is enabled. If the Amazon EKS private API server endpoint is enabled, Kubernetes API requests that originate from within your cluster's VPC use the private VPC endpoint instead of traversing the internet. If this value is disabled and you have nodes or Fargate pods in the cluster, then ensure that <code>publicAccessCidrs</code> includes the necessary CIDR blocks for communication with the nodes or Fargate pods. For more information, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html'>Amazon EKS cluster endpoint access control</a> in the <i> <i>Amazon EKS User Guide</i> </i>.</p>
        :param bool endpoint_public_access: <p>Whether the public API server endpoint is enabled.</p>
        :param Sequence[str] public_access_cidrs: <p>The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint.</p>
        :param Sequence[str] security_group_ids: <p>The security groups associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Kubernetes control plane.</p>
        :param Sequence[str] subnet_ids: <p>The subnets associated with your cluster.</p>
        :param str vpc_id: <p>The VPC associated with your cluster.</p>
        """
        if cluster_security_group_id is not None:
            pulumi.set(__self__, "cluster_security_group_id", cluster_security_group_id)
        if endpoint_private_access is not None:
            pulumi.set(__self__, "endpoint_private_access", endpoint_private_access)
        if endpoint_public_access is not None:
            pulumi.set(__self__, "endpoint_public_access", endpoint_public_access)
        if public_access_cidrs is not None:
            pulumi.set(__self__, "public_access_cidrs", public_access_cidrs)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="clusterSecurityGroupId")
    def cluster_security_group_id(self) -> Optional[str]:
        """
        <p>The cluster security group that was created by Amazon EKS for the cluster. Managed node groups use this security group for control-plane-to-data-plane communication.</p>
        """
        return pulumi.get(self, "cluster_security_group_id")

    @property
    @pulumi.getter(name="endpointPrivateAccess")
    def endpoint_private_access(self) -> Optional[bool]:
        """
        <p>This parameter indicates whether the Amazon EKS private API server endpoint is enabled. If the Amazon EKS private API server endpoint is enabled, Kubernetes API requests that originate from within your cluster's VPC use the private VPC endpoint instead of traversing the internet. If this value is disabled and you have nodes or Fargate pods in the cluster, then ensure that <code>publicAccessCidrs</code> includes the necessary CIDR blocks for communication with the nodes or Fargate pods. For more information, see <a href='https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html'>Amazon EKS cluster endpoint access control</a> in the <i> <i>Amazon EKS User Guide</i> </i>.</p>
        """
        return pulumi.get(self, "endpoint_private_access")

    @property
    @pulumi.getter(name="endpointPublicAccess")
    def endpoint_public_access(self) -> Optional[bool]:
        """
        <p>Whether the public API server endpoint is enabled.</p>
        """
        return pulumi.get(self, "endpoint_public_access")

    @property
    @pulumi.getter(name="publicAccessCidrs")
    def public_access_cidrs(self) -> Optional[Sequence[str]]:
        """
        <p>The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint.</p>
        """
        return pulumi.get(self, "public_access_cidrs")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        <p>The security groups associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Kubernetes control plane.</p>
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        <p>The subnets associated with your cluster.</p>
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        <p>The VPC associated with your cluster.</p>
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class VpcConfigurationResponse(dict):
    """
    Definition of VpcConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_id: Optional[str] = None):
        """
        Definition of VpcConfiguration
        :param str vpc_id: If this field is specified, this access point will only allow connections from the specified VPC ID.
        """
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        If this field is specified, this access point will only allow connections from the specified VPC ID.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class VpcSecurityGroupMembershipResponse(dict):
    """
    Definition of VpcSecurityGroupMembership
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcSecurityGroupId":
            suggest = "vpc_security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcSecurityGroupMembershipResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcSecurityGroupMembershipResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcSecurityGroupMembershipResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: Optional[str] = None,
                 vpc_security_group_id: Optional[str] = None):
        """
        Definition of VpcSecurityGroupMembership
        :param str status: <p>The status of the VPC security group.</p>
        :param str vpc_security_group_id: <p>The VPC security group ID.</p>
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if vpc_security_group_id is not None:
            pulumi.set(__self__, "vpc_security_group_id", vpc_security_group_id)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        <p>The status of the VPC security group.</p>
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="vpcSecurityGroupId")
    def vpc_security_group_id(self) -> Optional[str]:
        """
        <p>The VPC security group ID.</p>
        """
        return pulumi.get(self, "vpc_security_group_id")


@pulumi.output_type
class WafWebACLSummaryPropertiesResponse(dict):
    """
    Definition of WafWebACLSummary
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WafWebACLSummaryPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WafWebACLSummaryPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WafWebACLSummaryPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsWafWebACLSummaryPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of WafWebACLSummary
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsWafWebACLSummaryPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsWafWebACLSummaryPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class Wafv2LoggingConfigurationPropertiesResponse(dict):
    """
    Definition of Wafv2LoggingConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "awsProperties":
            suggest = "aws_properties"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "awsSourceSchema":
            suggest = "aws_source_schema"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "publicCloudConnectorsResourceId":
            suggest = "public_cloud_connectors_resource_id"
        elif key == "publicCloudResourceName":
            suggest = "public_cloud_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Wafv2LoggingConfigurationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Wafv2LoggingConfigurationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Wafv2LoggingConfigurationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 arn: Optional[str] = None,
                 aws_account_id: Optional[str] = None,
                 aws_properties: Optional['outputs.AwsWafv2LoggingConfigurationPropertiesResponse'] = None,
                 aws_region: Optional[str] = None,
                 aws_source_schema: Optional[str] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 public_cloud_connectors_resource_id: Optional[str] = None,
                 public_cloud_resource_name: Optional[str] = None):
        """
        Definition of Wafv2LoggingConfiguration
        :param str provisioning_state: The status of the last operation.
        :param str arn: Amazon Resource Name (ARN)
        :param str aws_account_id: AWS Account ID
        :param 'AwsWafv2LoggingConfigurationPropertiesResponse' aws_properties: AWS Properties
        :param str aws_region: AWS Region
        :param str aws_source_schema: AWS Source Schema
        :param Mapping[str, str] aws_tags: AWS Tags
        :param str public_cloud_connectors_resource_id: Public Cloud Connectors Resource ID
        :param str public_cloud_resource_name: Public Cloud Resource Name
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if aws_properties is not None:
            pulumi.set(__self__, "aws_properties", aws_properties)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if aws_source_schema is not None:
            pulumi.set(__self__, "aws_source_schema", aws_source_schema)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if public_cloud_connectors_resource_id is not None:
            pulumi.set(__self__, "public_cloud_connectors_resource_id", public_cloud_connectors_resource_id)
        if public_cloud_resource_name is not None:
            pulumi.set(__self__, "public_cloud_resource_name", public_cloud_resource_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The status of the last operation.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN)
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        AWS Account ID
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsProperties")
    def aws_properties(self) -> Optional['outputs.AwsWafv2LoggingConfigurationPropertiesResponse']:
        """
        AWS Properties
        """
        return pulumi.get(self, "aws_properties")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="awsSourceSchema")
    def aws_source_schema(self) -> Optional[str]:
        """
        AWS Source Schema
        """
        return pulumi.get(self, "aws_source_schema")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        AWS Tags
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="publicCloudConnectorsResourceId")
    def public_cloud_connectors_resource_id(self) -> Optional[str]:
        """
        Public Cloud Connectors Resource ID
        """
        return pulumi.get(self, "public_cloud_connectors_resource_id")

    @property
    @pulumi.getter(name="publicCloudResourceName")
    def public_cloud_resource_name(self) -> Optional[str]:
        """
        Public Cloud Resource Name
        """
        return pulumi.get(self, "public_cloud_resource_name")


@pulumi.output_type
class WebhookBuildTypeEnumValueResponse(dict):
    """
    Definition of WebhookBuildTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of WebhookBuildTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebhookFilterResponse(dict):
    """
    Definition of WebhookFilter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeMatchedPattern":
            suggest = "exclude_matched_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_matched_pattern: Optional[bool] = None,
                 pattern: Optional[str] = None,
                 type: Optional['outputs.WebhookFilterTypeEnumValueResponse'] = None):
        """
        Definition of WebhookFilter
        :param bool exclude_matched_pattern: <p> Used to indicate that the <code>pattern</code> determines which webhook events do not trigger a build. If true, then a webhook event that does not match the <code>pattern</code> triggers a build. If false, then a webhook event that matches the <code>pattern</code> triggers a build. </p>
        :param str pattern: <p> For a <code>WebHookFilter</code> that uses <code>EVENT</code> type, a comma-separated string that specifies one or more events. For example, the webhook filter <code>PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED</code> allows all push, pull request created, and pull request updated events to trigger a build. </p> <p> For a <code>WebHookFilter</code> that uses any of the other filter types, a regular expression pattern. For example, a <code>WebHookFilter</code> that uses <code>HEAD_REF</code> for its <code>type</code> and the pattern <code>^refs/heads/</code> triggers a build when the head reference is a branch with a reference name <code>refs/heads/branch-name</code>. </p>
        :param 'WebhookFilterTypeEnumValueResponse' type: <p> The type of webhook filter. There are nine webhook filter types: <code>EVENT</code>, <code>ACTOR_ACCOUNT_ID</code>, <code>HEAD_REF</code>, <code>BASE_REF</code>, <code>FILE_PATH</code>, <code>COMMIT_MESSAGE</code>, <code>TAG_NAME</code>, <code>RELEASE_NAME</code>, and <code>WORKFLOW_NAME</code>. </p> <ul> <li> <p> EVENT </p> <ul> <li> <p> A webhook event triggers a build when the provided <code>pattern</code> matches one of nine event types: <code>PUSH</code>, <code>PULL_REQUEST_CREATED</code>, <code>PULL_REQUEST_UPDATED</code>, <code>PULL_REQUEST_CLOSED</code>, <code>PULL_REQUEST_REOPENED</code>, <code>PULL_REQUEST_MERGED</code>, <code>RELEASED</code>, <code>PRERELEASED</code>, and <code>WORKFLOW_JOB_QUEUED</code>. The <code>EVENT</code> patterns are specified as a comma-separated string. For example, <code>PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED</code> filters all push, pull request created, and pull request updated events. </p> <note> <p> The <code>PULL_REQUEST_REOPENED</code> works with GitHub and GitHub Enterprise only. The <code>RELEASED</code>, <code>PRERELEASED</code>, and <code>WORKFLOW_JOB_QUEUED</code> work with GitHub only.</p> </note> </li> </ul> </li> <li> <p>ACTOR_ACCOUNT_ID</p> <ul> <li> <p> A webhook event triggers a build when a GitHub, GitHub Enterprise, or Bitbucket account ID matches the regular expression <code>pattern</code>. </p> </li> </ul> </li> <li> <p>HEAD_REF</p> <ul> <li> <p> A webhook event triggers a build when the head reference matches the regular expression <code>pattern</code>. For example, <code>refs/heads/branch-name</code> and <code>refs/tags/tag-name</code>. </p> <note> <p> Works with GitHub and GitHub Enterprise push, GitHub and GitHub Enterprise pull request, Bitbucket push, and Bitbucket pull request events.</p> </note> </li> </ul> </li> <li> <p>BASE_REF</p> <ul> <li> <p> A webhook event triggers a build when the base reference matches the regular expression <code>pattern</code>. For example, <code>refs/heads/branch-name</code>. </p> <note> <p> Works with pull request events only. </p> </note> </li> </ul> </li> <li> <p>FILE_PATH</p> <ul> <li> <p> A webhook triggers a build when the path of a changed file matches the regular expression <code>pattern</code>. </p> <note> <p> Works with GitHub and Bitbucket events push and pull requests events. Also works with GitHub Enterprise push events, but does not work with GitHub Enterprise pull request events. </p> </note> </li> </ul> </li> <li> <p>COMMIT_MESSAGE</p> <ul> <li> <p>A webhook triggers a build when the head commit message matches the regular expression <code>pattern</code>.</p> <note> <p> Works with GitHub and Bitbucket events push and pull requests events. Also works with GitHub Enterprise push events, but does not work with GitHub Enterprise pull request events. </p> </note> </li> </ul> </li> <li> <p>TAG_NAME</p> <ul> <li> <p>A webhook triggers a build when the tag name of the release matches the regular expression <code>pattern</code>.</p> <note> <p> Works with <code>RELEASED</code> and <code>PRERELEASED</code> events only. </p> </note> </li> </ul> </li> <li> <p>RELEASE_NAME</p> <ul> <li> <p>A webhook triggers a build when the release name matches the regular expression <code>pattern</code>.</p> <note> <p> Works with <code>RELEASED</code> and <code>PRERELEASED</code> events only. </p> </note> </li> </ul> </li> <li> <p>WORKFLOW_NAME</p> <ul> <li> <p>A webhook triggers a build when the workflow name matches the regular expression <code>pattern</code>.</p> <note> <p> Works with <code>WORKFLOW_JOB_QUEUED</code> events only. </p> </note> </li> </ul> </li> </ul>
        """
        if exclude_matched_pattern is not None:
            pulumi.set(__self__, "exclude_matched_pattern", exclude_matched_pattern)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="excludeMatchedPattern")
    def exclude_matched_pattern(self) -> Optional[bool]:
        """
        <p> Used to indicate that the <code>pattern</code> determines which webhook events do not trigger a build. If true, then a webhook event that does not match the <code>pattern</code> triggers a build. If false, then a webhook event that matches the <code>pattern</code> triggers a build. </p>
        """
        return pulumi.get(self, "exclude_matched_pattern")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        <p> For a <code>WebHookFilter</code> that uses <code>EVENT</code> type, a comma-separated string that specifies one or more events. For example, the webhook filter <code>PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED</code> allows all push, pull request created, and pull request updated events to trigger a build. </p> <p> For a <code>WebHookFilter</code> that uses any of the other filter types, a regular expression pattern. For example, a <code>WebHookFilter</code> that uses <code>HEAD_REF</code> for its <code>type</code> and the pattern <code>^refs/heads/</code> triggers a build when the head reference is a branch with a reference name <code>refs/heads/branch-name</code>. </p>
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def type(self) -> Optional['outputs.WebhookFilterTypeEnumValueResponse']:
        """
        <p> The type of webhook filter. There are nine webhook filter types: <code>EVENT</code>, <code>ACTOR_ACCOUNT_ID</code>, <code>HEAD_REF</code>, <code>BASE_REF</code>, <code>FILE_PATH</code>, <code>COMMIT_MESSAGE</code>, <code>TAG_NAME</code>, <code>RELEASE_NAME</code>, and <code>WORKFLOW_NAME</code>. </p> <ul> <li> <p> EVENT </p> <ul> <li> <p> A webhook event triggers a build when the provided <code>pattern</code> matches one of nine event types: <code>PUSH</code>, <code>PULL_REQUEST_CREATED</code>, <code>PULL_REQUEST_UPDATED</code>, <code>PULL_REQUEST_CLOSED</code>, <code>PULL_REQUEST_REOPENED</code>, <code>PULL_REQUEST_MERGED</code>, <code>RELEASED</code>, <code>PRERELEASED</code>, and <code>WORKFLOW_JOB_QUEUED</code>. The <code>EVENT</code> patterns are specified as a comma-separated string. For example, <code>PUSH, PULL_REQUEST_CREATED, PULL_REQUEST_UPDATED</code> filters all push, pull request created, and pull request updated events. </p> <note> <p> The <code>PULL_REQUEST_REOPENED</code> works with GitHub and GitHub Enterprise only. The <code>RELEASED</code>, <code>PRERELEASED</code>, and <code>WORKFLOW_JOB_QUEUED</code> work with GitHub only.</p> </note> </li> </ul> </li> <li> <p>ACTOR_ACCOUNT_ID</p> <ul> <li> <p> A webhook event triggers a build when a GitHub, GitHub Enterprise, or Bitbucket account ID matches the regular expression <code>pattern</code>. </p> </li> </ul> </li> <li> <p>HEAD_REF</p> <ul> <li> <p> A webhook event triggers a build when the head reference matches the regular expression <code>pattern</code>. For example, <code>refs/heads/branch-name</code> and <code>refs/tags/tag-name</code>. </p> <note> <p> Works with GitHub and GitHub Enterprise push, GitHub and GitHub Enterprise pull request, Bitbucket push, and Bitbucket pull request events.</p> </note> </li> </ul> </li> <li> <p>BASE_REF</p> <ul> <li> <p> A webhook event triggers a build when the base reference matches the regular expression <code>pattern</code>. For example, <code>refs/heads/branch-name</code>. </p> <note> <p> Works with pull request events only. </p> </note> </li> </ul> </li> <li> <p>FILE_PATH</p> <ul> <li> <p> A webhook triggers a build when the path of a changed file matches the regular expression <code>pattern</code>. </p> <note> <p> Works with GitHub and Bitbucket events push and pull requests events. Also works with GitHub Enterprise push events, but does not work with GitHub Enterprise pull request events. </p> </note> </li> </ul> </li> <li> <p>COMMIT_MESSAGE</p> <ul> <li> <p>A webhook triggers a build when the head commit message matches the regular expression <code>pattern</code>.</p> <note> <p> Works with GitHub and Bitbucket events push and pull requests events. Also works with GitHub Enterprise push events, but does not work with GitHub Enterprise pull request events. </p> </note> </li> </ul> </li> <li> <p>TAG_NAME</p> <ul> <li> <p>A webhook triggers a build when the tag name of the release matches the regular expression <code>pattern</code>.</p> <note> <p> Works with <code>RELEASED</code> and <code>PRERELEASED</code> events only. </p> </note> </li> </ul> </li> <li> <p>RELEASE_NAME</p> <ul> <li> <p>A webhook triggers a build when the release name matches the regular expression <code>pattern</code>.</p> <note> <p> Works with <code>RELEASED</code> and <code>PRERELEASED</code> events only. </p> </note> </li> </ul> </li> <li> <p>WORKFLOW_NAME</p> <ul> <li> <p>A webhook triggers a build when the workflow name matches the regular expression <code>pattern</code>.</p> <note> <p> Works with <code>WORKFLOW_JOB_QUEUED</code> events only. </p> </note> </li> </ul> </li> </ul>
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebhookFilterTypeEnumValueResponse(dict):
    """
    Definition of WebhookFilterTypeEnumValue
    """
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        Definition of WebhookFilterTypeEnumValue
        :param str value: Property value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Property value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WebhookResponse(dict):
    """
    Definition of Webhook
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchFilter":
            suggest = "branch_filter"
        elif key == "buildType":
            suggest = "build_type"
        elif key == "filterGroups":
            suggest = "filter_groups"
        elif key == "lastModifiedSecret":
            suggest = "last_modified_secret"
        elif key == "payloadUrl":
            suggest = "payload_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_filter: Optional[str] = None,
                 build_type: Optional['outputs.WebhookBuildTypeEnumValueResponse'] = None,
                 filter_groups: Optional[Sequence['outputs.FilterGroupResponse']] = None,
                 last_modified_secret: Optional[str] = None,
                 payload_url: Optional[str] = None,
                 secret: Optional[str] = None,
                 url: Optional[str] = None):
        """
        Definition of Webhook
        :param str branch_filter: <p>A regular expression used to determine which repository branches are built when a webhook is triggered. If the name of a branch matches the regular expression, then it is built. If <code>branchFilter</code> is empty, then all branches are built.</p> <note> <p>It is recommended that you use <code>filterGroups</code> instead of <code>branchFilter</code>. </p> </note>
        :param 'WebhookBuildTypeEnumValueResponse' build_type: <p>Specifies the type of build this webhook will trigger.</p>
        :param Sequence['FilterGroupResponse'] filter_groups: <p>An array of arrays of <code>WebhookFilter</code> objects used to determine which webhooks are triggered. At least one <code>WebhookFilter</code> in the array must specify <code>EVENT</code> as its <code>type</code>. </p> <p>For a build to be triggered, at least one filter group in the <code>filterGroups</code> array must pass. For a filter group to pass, each of its filters must pass. </p>
        :param str last_modified_secret: <p>A timestamp that indicates the last time a repository's secret token was modified. </p>
        :param str payload_url: <p>The CodeBuild endpoint where webhook events are sent.</p>
        :param str secret: <p>The secret token of the associated repository. </p> <note> <p>A Bitbucket webhook does not support <code>secret</code>. </p> </note>
        :param str url: <p>The URL to the webhook.</p>
        """
        if branch_filter is not None:
            pulumi.set(__self__, "branch_filter", branch_filter)
        if build_type is not None:
            pulumi.set(__self__, "build_type", build_type)
        if filter_groups is not None:
            pulumi.set(__self__, "filter_groups", filter_groups)
        if last_modified_secret is not None:
            pulumi.set(__self__, "last_modified_secret", last_modified_secret)
        if payload_url is not None:
            pulumi.set(__self__, "payload_url", payload_url)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="branchFilter")
    def branch_filter(self) -> Optional[str]:
        """
        <p>A regular expression used to determine which repository branches are built when a webhook is triggered. If the name of a branch matches the regular expression, then it is built. If <code>branchFilter</code> is empty, then all branches are built.</p> <note> <p>It is recommended that you use <code>filterGroups</code> instead of <code>branchFilter</code>. </p> </note>
        """
        return pulumi.get(self, "branch_filter")

    @property
    @pulumi.getter(name="buildType")
    def build_type(self) -> Optional['outputs.WebhookBuildTypeEnumValueResponse']:
        """
        <p>Specifies the type of build this webhook will trigger.</p>
        """
        return pulumi.get(self, "build_type")

    @property
    @pulumi.getter(name="filterGroups")
    def filter_groups(self) -> Optional[Sequence['outputs.FilterGroupResponse']]:
        """
        <p>An array of arrays of <code>WebhookFilter</code> objects used to determine which webhooks are triggered. At least one <code>WebhookFilter</code> in the array must specify <code>EVENT</code> as its <code>type</code>. </p> <p>For a build to be triggered, at least one filter group in the <code>filterGroups</code> array must pass. For a filter group to pass, each of its filters must pass. </p>
        """
        return pulumi.get(self, "filter_groups")

    @property
    @pulumi.getter(name="lastModifiedSecret")
    def last_modified_secret(self) -> Optional[str]:
        """
        <p>A timestamp that indicates the last time a repository's secret token was modified. </p>
        """
        return pulumi.get(self, "last_modified_secret")

    @property
    @pulumi.getter(name="payloadUrl")
    def payload_url(self) -> Optional[str]:
        """
        <p>The CodeBuild endpoint where webhook events are sent.</p>
        """
        return pulumi.get(self, "payload_url")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        <p>The secret token of the associated repository. </p> <note> <p>A Bitbucket webhook does not support <code>secret</code>. </p> </note>
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        <p>The URL to the webhook.</p>
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WebsiteConfigurationResponse(dict):
    """
    Definition of WebsiteConfiguration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDocument":
            suggest = "error_document"
        elif key == "indexDocument":
            suggest = "index_document"
        elif key == "redirectAllRequestsTo":
            suggest = "redirect_all_requests_to"
        elif key == "routingRules":
            suggest = "routing_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebsiteConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebsiteConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebsiteConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_document: Optional[str] = None,
                 index_document: Optional[str] = None,
                 redirect_all_requests_to: Optional['outputs.RedirectAllRequestsToResponse'] = None,
                 routing_rules: Optional[Sequence['outputs.RoutingRuleResponse']] = None):
        """
        Definition of WebsiteConfiguration
        :param str error_document: The name of the error document for the website.
        :param str index_document: The name of the index document for the website.
        :param 'RedirectAllRequestsToResponse' redirect_all_requests_to: The redirect behavior for every request to this bucket's website endpoint.  If you specify this property, you can't specify any other property. Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
        :param Sequence['RoutingRuleResponse'] routing_rules: Rules that define when a redirect is applied and the redirect behavior.
        """
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if redirect_all_requests_to is not None:
            pulumi.set(__self__, "redirect_all_requests_to", redirect_all_requests_to)
        if routing_rules is not None:
            pulumi.set(__self__, "routing_rules", routing_rules)

    @property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[str]:
        """
        The name of the error document for the website.
        """
        return pulumi.get(self, "error_document")

    @property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[str]:
        """
        The name of the index document for the website.
        """
        return pulumi.get(self, "index_document")

    @property
    @pulumi.getter(name="redirectAllRequestsTo")
    def redirect_all_requests_to(self) -> Optional['outputs.RedirectAllRequestsToResponse']:
        """
        The redirect behavior for every request to this bucket's website endpoint.  If you specify this property, you can't specify any other property. Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
        """
        return pulumi.get(self, "redirect_all_requests_to")

    @property
    @pulumi.getter(name="routingRules")
    def routing_rules(self) -> Optional[Sequence['outputs.RoutingRuleResponse']]:
        """
        Rules that define when a redirect is applied and the redirect behavior.
        """
        return pulumi.get(self, "routing_rules")


@pulumi.output_type
class WindowStartTimeResponse(dict):
    """
    Definition of WindowStartTime
    """
    def __init__(__self__, *,
                 hours: Optional[float] = None,
                 minutes: Optional[float] = None):
        """
        Definition of WindowStartTime
        :param float hours: <p>The start hour of the window in Coordinated Universal Time (UTC), using 24-hour time. For example, <code>17</code> refers to 5:00 P.M. UTC.</p>
        :param float minutes: <p>The start minute of the window, in UTC.</p>
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> Optional[float]:
        """
        <p>The start hour of the window in Coordinated Universal Time (UTC), using 24-hour time. For example, <code>17</code> refers to 5:00 P.M. UTC.</p>
        """
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def minutes(self) -> Optional[float]:
        """
        <p>The start minute of the window, in UTC.</p>
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class ZoneAwarenessConfigResponse(dict):
    """
    Definition of ZoneAwarenessConfig
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneCount":
            suggest = "availability_zone_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ZoneAwarenessConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ZoneAwarenessConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ZoneAwarenessConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_count: Optional[int] = None):
        """
        Definition of ZoneAwarenessConfig
        :param int availability_zone_count: <p>If you enabled multiple Availability Zones, this value is the number of zones that you want the domain to use. Valid values are <code>2</code> and <code>3</code>. If your domain is provisioned within a VPC, this value be equal to number of subnets.</p>
        """
        if availability_zone_count is not None:
            pulumi.set(__self__, "availability_zone_count", availability_zone_count)

    @property
    @pulumi.getter(name="availabilityZoneCount")
    def availability_zone_count(self) -> Optional[int]:
        """
        <p>If you enabled multiple Availability Zones, this value is the number of zones that you want the domain to use. Valid values are <code>2</code> and <code>3</code>. If your domain is provisioned within a VPC, this value be equal to number of subnets.</p>
        """
        return pulumi.get(self, "availability_zone_count")


