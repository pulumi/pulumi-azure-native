# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'CaptureDescriptionResponse',
    'CaptureIdentityResponse',
    'ClusterSkuResponse',
    'ConnectionStateResponse',
    'DestinationResponse',
    'EncryptionResponse',
    'GeoDataReplicationPropertiesResponse',
    'IdentityResponse',
    'KeyVaultPropertiesResponse',
    'NWRuleSetIpRulesResponse',
    'NWRuleSetVirtualNetworkRulesResponse',
    'NamespaceReplicaLocationResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'RetentionDescriptionResponse',
    'SkuResponse',
    'SubnetResponse',
    'SystemDataResponse',
    'ThrottlingPolicyResponse',
    'UserAssignedIdentityPropertiesResponse',
    'UserAssignedIdentityResponse',
]

@pulumi.output_type
class CaptureDescriptionResponse(dict):
    """
    Properties to configure capture description for eventhub
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalInSeconds":
            suggest = "interval_in_seconds"
        elif key == "sizeLimitInBytes":
            suggest = "size_limit_in_bytes"
        elif key == "skipEmptyArchives":
            suggest = "skip_empty_archives"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CaptureDescriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CaptureDescriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CaptureDescriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional['outputs.DestinationResponse'] = None,
                 enabled: Optional[bool] = None,
                 encoding: Optional[str] = None,
                 interval_in_seconds: Optional[int] = None,
                 size_limit_in_bytes: Optional[int] = None,
                 skip_empty_archives: Optional[bool] = None):
        """
        Properties to configure capture description for eventhub
        :param 'DestinationResponse' destination: Properties of Destination where capture will be stored. (Storage Account, Blob Names)
        :param bool enabled: A value that indicates whether capture description is enabled. 
        :param str encoding: Enumerates the possible values for the encoding format of capture description. Note: 'AvroDeflate' will be deprecated in New API Version
        :param int interval_in_seconds: The time window allows you to set the frequency with which the capture to Azure Blobs will happen, value should between 60 to 900 seconds
        :param int size_limit_in_bytes: The size window defines the amount of data built up in your Event Hub before an capture operation, value should be between 10485760 to 524288000 bytes
        :param bool skip_empty_archives: A value that indicates whether to Skip Empty Archives
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if size_limit_in_bytes is not None:
            pulumi.set(__self__, "size_limit_in_bytes", size_limit_in_bytes)
        if skip_empty_archives is not None:
            pulumi.set(__self__, "skip_empty_archives", skip_empty_archives)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.DestinationResponse']:
        """
        Properties of Destination where capture will be stored. (Storage Account, Blob Names)
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        A value that indicates whether capture description is enabled. 
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        Enumerates the possible values for the encoding format of capture description. Note: 'AvroDeflate' will be deprecated in New API Version
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[int]:
        """
        The time window allows you to set the frequency with which the capture to Azure Blobs will happen, value should between 60 to 900 seconds
        """
        return pulumi.get(self, "interval_in_seconds")

    @property
    @pulumi.getter(name="sizeLimitInBytes")
    def size_limit_in_bytes(self) -> Optional[int]:
        """
        The size window defines the amount of data built up in your Event Hub before an capture operation, value should be between 10485760 to 524288000 bytes
        """
        return pulumi.get(self, "size_limit_in_bytes")

    @property
    @pulumi.getter(name="skipEmptyArchives")
    def skip_empty_archives(self) -> Optional[bool]:
        """
        A value that indicates whether to Skip Empty Archives
        """
        return pulumi.get(self, "skip_empty_archives")


@pulumi.output_type
class CaptureIdentityResponse(dict):
    """
    A value that indicates whether capture description is enabled.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CaptureIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CaptureIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CaptureIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[str] = None,
                 user_assigned_identity: Optional[str] = None):
        """
        A value that indicates whether capture description is enabled.
        :param str type: Type of Azure Active Directory Managed Identity.
        :param str user_assigned_identity: ARM ID of Managed User Identity. This property is required is the type is UserAssignedIdentity. If type is SystemAssigned, then the System Assigned Identity Associated with the namespace will be used.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of Azure Active Directory Managed Identity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[str]:
        """
        ARM ID of Managed User Identity. This property is required is the type is UserAssignedIdentity. If type is SystemAssigned, then the System Assigned Identity Associated with the namespace will be used.
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class ClusterSkuResponse(dict):
    """
    SKU parameters particular to a cluster instance.
    """
    def __init__(__self__, *,
                 name: str,
                 capacity: Optional[int] = None):
        """
        SKU parameters particular to a cluster instance.
        :param str name: Name of this SKU.
        :param int capacity: The quantity of Event Hubs Cluster Capacity Units contained in this cluster.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this SKU.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        The quantity of Event Hubs Cluster Capacity Units contained in this cluster.
        """
        return pulumi.get(self, "capacity")


@pulumi.output_type
class ConnectionStateResponse(dict):
    """
    ConnectionState information.
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        ConnectionState information.
        :param str description: Description of the connection state.
        :param str status: Status of the connection.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the connection state.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the connection.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DestinationResponse(dict):
    """
    Capture storage details for capture description
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveNameFormat":
            suggest = "archive_name_format"
        elif key == "blobContainer":
            suggest = "blob_container"
        elif key == "dataLakeAccountName":
            suggest = "data_lake_account_name"
        elif key == "dataLakeFolderPath":
            suggest = "data_lake_folder_path"
        elif key == "dataLakeSubscriptionId":
            suggest = "data_lake_subscription_id"
        elif key == "storageAccountResourceId":
            suggest = "storage_account_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_name_format: Optional[str] = None,
                 blob_container: Optional[str] = None,
                 data_lake_account_name: Optional[str] = None,
                 data_lake_folder_path: Optional[str] = None,
                 data_lake_subscription_id: Optional[str] = None,
                 identity: Optional['outputs.CaptureIdentityResponse'] = None,
                 name: Optional[str] = None,
                 storage_account_resource_id: Optional[str] = None):
        """
        Capture storage details for capture description
        :param str archive_name_format: Blob naming convention for archive, e.g. {Namespace}/{EventHub}/{PartitionId}/{Year}/{Month}/{Day}/{Hour}/{Minute}/{Second}. Here all the parameters (Namespace,EventHub .. etc) are mandatory irrespective of order
        :param str blob_container: Blob container Name
        :param str data_lake_account_name: The Azure Data Lake Store name for the captured events
        :param str data_lake_folder_path: The destination folder path for the captured events
        :param str data_lake_subscription_id: Subscription Id of Azure Data Lake Store
        :param 'CaptureIdentityResponse' identity: A value that indicates whether capture description is enabled.
        :param str name: Name for capture destination
        :param str storage_account_resource_id: Resource id of the storage account to be used to create the blobs
        """
        if archive_name_format is not None:
            pulumi.set(__self__, "archive_name_format", archive_name_format)
        if blob_container is not None:
            pulumi.set(__self__, "blob_container", blob_container)
        if data_lake_account_name is not None:
            pulumi.set(__self__, "data_lake_account_name", data_lake_account_name)
        if data_lake_folder_path is not None:
            pulumi.set(__self__, "data_lake_folder_path", data_lake_folder_path)
        if data_lake_subscription_id is not None:
            pulumi.set(__self__, "data_lake_subscription_id", data_lake_subscription_id)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if storage_account_resource_id is not None:
            pulumi.set(__self__, "storage_account_resource_id", storage_account_resource_id)

    @property
    @pulumi.getter(name="archiveNameFormat")
    def archive_name_format(self) -> Optional[str]:
        """
        Blob naming convention for archive, e.g. {Namespace}/{EventHub}/{PartitionId}/{Year}/{Month}/{Day}/{Hour}/{Minute}/{Second}. Here all the parameters (Namespace,EventHub .. etc) are mandatory irrespective of order
        """
        return pulumi.get(self, "archive_name_format")

    @property
    @pulumi.getter(name="blobContainer")
    def blob_container(self) -> Optional[str]:
        """
        Blob container Name
        """
        return pulumi.get(self, "blob_container")

    @property
    @pulumi.getter(name="dataLakeAccountName")
    def data_lake_account_name(self) -> Optional[str]:
        """
        The Azure Data Lake Store name for the captured events
        """
        return pulumi.get(self, "data_lake_account_name")

    @property
    @pulumi.getter(name="dataLakeFolderPath")
    def data_lake_folder_path(self) -> Optional[str]:
        """
        The destination folder path for the captured events
        """
        return pulumi.get(self, "data_lake_folder_path")

    @property
    @pulumi.getter(name="dataLakeSubscriptionId")
    def data_lake_subscription_id(self) -> Optional[str]:
        """
        Subscription Id of Azure Data Lake Store
        """
        return pulumi.get(self, "data_lake_subscription_id")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.CaptureIdentityResponse']:
        """
        A value that indicates whether capture description is enabled.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name for capture destination
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageAccountResourceId")
    def storage_account_resource_id(self) -> Optional[str]:
        """
        Resource id of the storage account to be used to create the blobs
        """
        return pulumi.get(self, "storage_account_resource_id")


@pulumi.output_type
class EncryptionResponse(dict):
    """
    Properties to configure Encryption
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keySource":
            suggest = "key_source"
        elif key == "keyVaultProperties":
            suggest = "key_vault_properties"
        elif key == "requireInfrastructureEncryption":
            suggest = "require_infrastructure_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_source: Optional[str] = None,
                 key_vault_properties: Optional[Sequence['outputs.KeyVaultPropertiesResponse']] = None,
                 require_infrastructure_encryption: Optional[bool] = None):
        """
        Properties to configure Encryption
        :param str key_source: Enumerates the possible value of keySource for Encryption
        :param Sequence['KeyVaultPropertiesResponse'] key_vault_properties: Properties of KeyVault
        :param bool require_infrastructure_encryption: Enable Infrastructure Encryption (Double Encryption)
        """
        if key_source is None:
            key_source = 'Microsoft.KeyVault'
        if key_source is not None:
            pulumi.set(__self__, "key_source", key_source)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        if require_infrastructure_encryption is not None:
            pulumi.set(__self__, "require_infrastructure_encryption", require_infrastructure_encryption)

    @property
    @pulumi.getter(name="keySource")
    def key_source(self) -> Optional[str]:
        """
        Enumerates the possible value of keySource for Encryption
        """
        return pulumi.get(self, "key_source")

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional[Sequence['outputs.KeyVaultPropertiesResponse']]:
        """
        Properties of KeyVault
        """
        return pulumi.get(self, "key_vault_properties")

    @property
    @pulumi.getter(name="requireInfrastructureEncryption")
    def require_infrastructure_encryption(self) -> Optional[bool]:
        """
        Enable Infrastructure Encryption (Double Encryption)
        """
        return pulumi.get(self, "require_infrastructure_encryption")


@pulumi.output_type
class GeoDataReplicationPropertiesResponse(dict):
    """
    GeoDR Replication properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicationLagDurationInSeconds":
            suggest = "max_replication_lag_duration_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GeoDataReplicationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GeoDataReplicationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GeoDataReplicationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locations: Optional[Sequence['outputs.NamespaceReplicaLocationResponse']] = None,
                 max_replication_lag_duration_in_seconds: Optional[int] = None):
        """
        GeoDR Replication properties
        :param Sequence['NamespaceReplicaLocationResponse'] locations: A list of regions where replicas of the namespace are maintained.
        :param int max_replication_lag_duration_in_seconds: The maximum acceptable lag for data replication operations from the primary replica to a quorum of secondary replicas.  When the lag exceeds the configured amount, operations on the primary replica will be failed. The allowed values are 0 and 5 minutes to 1 day.
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if max_replication_lag_duration_in_seconds is not None:
            pulumi.set(__self__, "max_replication_lag_duration_in_seconds", max_replication_lag_duration_in_seconds)

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.NamespaceReplicaLocationResponse']]:
        """
        A list of regions where replicas of the namespace are maintained.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="maxReplicationLagDurationInSeconds")
    def max_replication_lag_duration_in_seconds(self) -> Optional[int]:
        """
        The maximum acceptable lag for data replication operations from the primary replica to a quorum of secondary replicas.  When the lag exceeds the configured amount, operations on the primary replica will be failed. The allowed values are 0 and 5 minutes to 1 day.
        """
        return pulumi.get(self, "max_replication_lag_duration_in_seconds")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Properties to configure Identity for Bring your Own Keys
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Properties to configure Identity for Bring your Own Keys
        :param str principal_id: ObjectId from the KeyVault
        :param str tenant_id: TenantId from the KeyVault
        :param str type: Type of managed service identity.
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: Properties for User Assigned Identities
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        ObjectId from the KeyVault
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        TenantId from the KeyVault
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of managed service identity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        Properties for User Assigned Identities
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class KeyVaultPropertiesResponse(dict):
    """
    Properties to configure keyVault Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyName":
            suggest = "key_name"
        elif key == "keyVaultUri":
            suggest = "key_vault_uri"
        elif key == "keyVersion":
            suggest = "key_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional['outputs.UserAssignedIdentityPropertiesResponse'] = None,
                 key_name: Optional[str] = None,
                 key_vault_uri: Optional[str] = None,
                 key_version: Optional[str] = None):
        """
        Properties to configure keyVault Properties
        :param str key_name: Name of the Key from KeyVault
        :param str key_vault_uri: Uri of KeyVault
        :param str key_version: Key Version
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_vault_uri is not None:
            pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.UserAssignedIdentityPropertiesResponse']:
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        """
        Name of the Key from KeyVault
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> Optional[str]:
        """
        Uri of KeyVault
        """
        return pulumi.get(self, "key_vault_uri")

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[str]:
        """
        Key Version
        """
        return pulumi.get(self, "key_version")


@pulumi.output_type
class NWRuleSetIpRulesResponse(dict):
    """
    The response from the List namespace operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipMask":
            suggest = "ip_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NWRuleSetIpRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NWRuleSetIpRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NWRuleSetIpRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 ip_mask: Optional[str] = None):
        """
        The response from the List namespace operation.
        :param str action: The IP Filter Action
        :param str ip_mask: IP Mask
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if ip_mask is not None:
            pulumi.set(__self__, "ip_mask", ip_mask)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The IP Filter Action
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="ipMask")
    def ip_mask(self) -> Optional[str]:
        """
        IP Mask
        """
        return pulumi.get(self, "ip_mask")


@pulumi.output_type
class NWRuleSetVirtualNetworkRulesResponse(dict):
    """
    The response from the List namespace operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreMissingVnetServiceEndpoint":
            suggest = "ignore_missing_vnet_service_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NWRuleSetVirtualNetworkRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NWRuleSetVirtualNetworkRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NWRuleSetVirtualNetworkRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ignore_missing_vnet_service_endpoint: Optional[bool] = None,
                 subnet: Optional['outputs.SubnetResponse'] = None):
        """
        The response from the List namespace operation.
        :param bool ignore_missing_vnet_service_endpoint: Value that indicates whether to ignore missing Vnet Service Endpoint
        :param 'SubnetResponse' subnet: Subnet properties
        """
        if ignore_missing_vnet_service_endpoint is not None:
            pulumi.set(__self__, "ignore_missing_vnet_service_endpoint", ignore_missing_vnet_service_endpoint)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter(name="ignoreMissingVnetServiceEndpoint")
    def ignore_missing_vnet_service_endpoint(self) -> Optional[bool]:
        """
        Value that indicates whether to ignore missing Vnet Service Endpoint
        """
        return pulumi.get(self, "ignore_missing_vnet_service_endpoint")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.SubnetResponse']:
        """
        Subnet properties
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class NamespaceReplicaLocationResponse(dict):
    """
    Namespace replication properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaState":
            suggest = "replica_state"
        elif key == "clusterArmId":
            suggest = "cluster_arm_id"
        elif key == "locationName":
            suggest = "location_name"
        elif key == "roleType":
            suggest = "role_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceReplicaLocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceReplicaLocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceReplicaLocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replica_state: str,
                 cluster_arm_id: Optional[str] = None,
                 location_name: Optional[str] = None,
                 role_type: Optional[str] = None):
        """
        Namespace replication properties
        :param str replica_state: state of Namespace replica.
        :param str cluster_arm_id: Optional property that denotes the ARM ID of the Cluster. This is required, if a namespace replica should be placed in a Dedicated Event Hub Cluster
        :param str location_name: Azure regions where a replica of the namespace is maintained
        :param str role_type: GeoDR Role Types
        """
        pulumi.set(__self__, "replica_state", replica_state)
        if cluster_arm_id is not None:
            pulumi.set(__self__, "cluster_arm_id", cluster_arm_id)
        if location_name is not None:
            pulumi.set(__self__, "location_name", location_name)
        if role_type is not None:
            pulumi.set(__self__, "role_type", role_type)

    @property
    @pulumi.getter(name="replicaState")
    def replica_state(self) -> str:
        """
        state of Namespace replica.
        """
        return pulumi.get(self, "replica_state")

    @property
    @pulumi.getter(name="clusterArmId")
    def cluster_arm_id(self) -> Optional[str]:
        """
        Optional property that denotes the ARM ID of the Cluster. This is required, if a namespace replica should be placed in a Dedicated Event Hub Cluster
        """
        return pulumi.get(self, "cluster_arm_id")

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> Optional[str]:
        """
        Azure regions where a replica of the namespace is maintained
        """
        return pulumi.get(self, "location_name")

    @property
    @pulumi.getter(name="roleType")
    def role_type(self) -> Optional[str]:
        """
        GeoDR Role Types
        """
        return pulumi.get(self, "role_type")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    Properties of the PrivateEndpointConnection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemData":
            suggest = "system_data"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 location: str,
                 name: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.ConnectionStateResponse'] = None,
                 provisioning_state: Optional[str] = None):
        """
        Properties of the PrivateEndpointConnection.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str location: The geo-location where the resource lives
        :param str name: The name of the resource
        :param 'SystemDataResponse' system_data: The system meta data relating to this resource.
        :param str type: The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
        :param 'PrivateEndpointResponse' private_endpoint: The Private Endpoint resource for this Connection.
        :param 'ConnectionStateResponse' private_link_service_connection_state: Details about the state of the connection.
        :param str provisioning_state: Provisioning state of the Private Endpoint Connection.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        The system meta data relating to this resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.EventHub/Namespaces" or "Microsoft.EventHub/Namespaces/EventHubs"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The Private Endpoint resource for this Connection.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.ConnectionStateResponse']:
        """
        Details about the state of the connection.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Provisioning state of the Private Endpoint Connection.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    PrivateEndpoint information.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        PrivateEndpoint information.
        :param str id: The ARM identifier for Private Endpoint.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ARM identifier for Private Endpoint.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class RetentionDescriptionResponse(dict):
    """
    Properties to configure retention settings for the  eventhub
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "retentionTimeInHours":
            suggest = "retention_time_in_hours"
        elif key == "tombstoneRetentionTimeInHours":
            suggest = "tombstone_retention_time_in_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetentionDescriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetentionDescriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetentionDescriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[str] = None,
                 retention_time_in_hours: Optional[float] = None,
                 tombstone_retention_time_in_hours: Optional[int] = None):
        """
        Properties to configure retention settings for the  eventhub
        :param str cleanup_policy: Enumerates the possible values for cleanup policy
        :param float retention_time_in_hours: Number of hours to retain the events for this Event Hub. This value is only used when cleanupPolicy is Delete. If cleanupPolicy is Compact the returned value of this property is Long.MaxValue 
        :param int tombstone_retention_time_in_hours: Number of hours to retain the tombstone markers of a compacted Event Hub. This value is only used when cleanupPolicy is Compact. Consumer must complete reading the tombstone marker within this specified amount of time if consumer begins from starting offset to ensure they get a valid snapshot for the specific key described by the tombstone marker within the compacted Event Hub
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if retention_time_in_hours is not None:
            pulumi.set(__self__, "retention_time_in_hours", retention_time_in_hours)
        if tombstone_retention_time_in_hours is not None:
            pulumi.set(__self__, "tombstone_retention_time_in_hours", tombstone_retention_time_in_hours)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[str]:
        """
        Enumerates the possible values for cleanup policy
        """
        return pulumi.get(self, "cleanup_policy")

    @property
    @pulumi.getter(name="retentionTimeInHours")
    def retention_time_in_hours(self) -> Optional[float]:
        """
        Number of hours to retain the events for this Event Hub. This value is only used when cleanupPolicy is Delete. If cleanupPolicy is Compact the returned value of this property is Long.MaxValue 
        """
        return pulumi.get(self, "retention_time_in_hours")

    @property
    @pulumi.getter(name="tombstoneRetentionTimeInHours")
    def tombstone_retention_time_in_hours(self) -> Optional[int]:
        """
        Number of hours to retain the tombstone markers of a compacted Event Hub. This value is only used when cleanupPolicy is Compact. Consumer must complete reading the tombstone marker within this specified amount of time if consumer begins from starting offset to ensure they get a valid snapshot for the specific key described by the tombstone marker within the compacted Event Hub
        """
        return pulumi.get(self, "tombstone_retention_time_in_hours")


@pulumi.output_type
class SkuResponse(dict):
    """
    SKU parameters supplied to the create namespace operation
    """
    def __init__(__self__, *,
                 name: str,
                 capacity: Optional[int] = None,
                 tier: Optional[str] = None):
        """
        SKU parameters supplied to the create namespace operation
        :param str name: Name of this SKU.
        :param int capacity: The Event Hubs throughput units for Basic or Standard tiers, where value should be 0 to 20 throughput units. The Event Hubs premium units for Premium tier, where value should be 0 to 10 premium units.
        :param str tier: The billing tier of this particular SKU.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this SKU.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        The Event Hubs throughput units for Basic or Standard tiers, where value should be 0 to 20 throughput units. The Event Hubs premium units for Premium tier, where value should be 0 to 10 premium units.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        The billing tier of this particular SKU.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SubnetResponse(dict):
    """
    Properties supplied for Subnet
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Properties supplied for Subnet
        :param str id: Resource ID of Virtual Network Subnet
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID of Virtual Network Subnet
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The type of identity that last modified the resource.
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class ThrottlingPolicyResponse(dict):
    """
    Properties of the throttling policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricId":
            suggest = "metric_id"
        elif key == "rateLimitThreshold":
            suggest = "rate_limit_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThrottlingPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThrottlingPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThrottlingPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_id: str,
                 name: str,
                 rate_limit_threshold: float,
                 type: str):
        """
        Properties of the throttling policy
        :param str metric_id: Metric Id on which the throttle limit should be set, MetricId can be discovered by hovering over Metric in the Metrics section of Event Hub Namespace inside Azure Portal
        :param str name: The Name of this policy
        :param float rate_limit_threshold: The Threshold limit above which the application group will be throttled.Rate limit is always per second.
        :param str type: Application Group Policy types
               Expected value is 'ThrottlingPolicy'.
        """
        pulumi.set(__self__, "metric_id", metric_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rate_limit_threshold", rate_limit_threshold)
        pulumi.set(__self__, "type", 'ThrottlingPolicy')

    @property
    @pulumi.getter(name="metricId")
    def metric_id(self) -> str:
        """
        Metric Id on which the throttle limit should be set, MetricId can be discovered by hovering over Metric in the Metrics section of Event Hub Namespace inside Azure Portal
        """
        return pulumi.get(self, "metric_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of this policy
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> float:
        """
        The Threshold limit above which the application group will be throttled.Rate limit is always per second.
        """
        return pulumi.get(self, "rate_limit_threshold")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Application Group Policy types
        Expected value is 'ThrottlingPolicy'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class UserAssignedIdentityPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_assigned_identity: Optional[str] = None):
        """
        :param str user_assigned_identity: ARM ID of user Identity selected for encryption
        """
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[str]:
        """
        ARM ID of user Identity selected for encryption
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    Recognized Dictionary value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        Recognized Dictionary value.
        :param str client_id: Client Id of user assigned identity
        :param str principal_id: Principal Id of user assigned identity
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client Id of user assigned identity
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        Principal Id of user assigned identity
        """
        return pulumi.get(self, "principal_id")


