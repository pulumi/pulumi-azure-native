# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ApiManagementGatewaySkuPropertiesArgs',
    'ApiManagementGatewaySkuPropertiesArgsDict',
    'BackendAuthorizationHeaderCredentialsArgs',
    'BackendAuthorizationHeaderCredentialsArgsDict',
    'BackendBaseParametersPoolArgs',
    'BackendBaseParametersPoolArgsDict',
    'BackendCircuitBreakerArgs',
    'BackendCircuitBreakerArgsDict',
    'BackendConfigurationArgs',
    'BackendConfigurationArgsDict',
    'BackendCredentialsContractArgs',
    'BackendCredentialsContractArgsDict',
    'BackendPoolItemArgs',
    'BackendPoolItemArgsDict',
    'BackendPropertiesArgs',
    'BackendPropertiesArgsDict',
    'BackendProxyContractArgs',
    'BackendProxyContractArgsDict',
    'BackendServiceFabricClusterPropertiesArgs',
    'BackendServiceFabricClusterPropertiesArgsDict',
    'BackendSubnetConfigurationArgs',
    'BackendSubnetConfigurationArgsDict',
    'BackendTlsPropertiesArgs',
    'BackendTlsPropertiesArgsDict',
    'BodyDiagnosticSettingsArgs',
    'BodyDiagnosticSettingsArgsDict',
    'CircuitBreakerFailureConditionArgs',
    'CircuitBreakerFailureConditionArgsDict',
    'CircuitBreakerRuleArgs',
    'CircuitBreakerRuleArgsDict',
    'DataMaskingEntityArgs',
    'DataMaskingEntityArgsDict',
    'DataMaskingArgs',
    'DataMaskingArgsDict',
    'FailureStatusCodeRangeArgs',
    'FailureStatusCodeRangeArgsDict',
    'HttpMessageDiagnosticArgs',
    'HttpMessageDiagnosticArgsDict',
    'KeyVaultContractCreatePropertiesArgs',
    'KeyVaultContractCreatePropertiesArgsDict',
    'PipelineDiagnosticSettingsArgs',
    'PipelineDiagnosticSettingsArgsDict',
    'SamplingSettingsArgs',
    'SamplingSettingsArgsDict',
    'X509CertificateNameArgs',
    'X509CertificateNameArgsDict',
]

MYPY = False

if not MYPY:
    class ApiManagementGatewaySkuPropertiesArgsDict(TypedDict):
        """
        API Management gateway resource SKU properties.
        """
        name: pulumi.Input[Union[str, 'SkuType']]
        """
        Name of the Sku.
        """
        capacity: NotRequired[pulumi.Input[int]]
        """
        Capacity of the SKU (number of deployed units of the SKU)
        """
elif False:
    ApiManagementGatewaySkuPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiManagementGatewaySkuPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[Union[str, 'SkuType']],
                 capacity: Optional[pulumi.Input[int]] = None):
        """
        API Management gateway resource SKU properties.
        :param pulumi.Input[Union[str, 'SkuType']] name: Name of the Sku.
        :param pulumi.Input[int] capacity: Capacity of the SKU (number of deployed units of the SKU)
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[Union[str, 'SkuType']]:
        """
        Name of the Sku.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[Union[str, 'SkuType']]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Capacity of the SKU (number of deployed units of the SKU)
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)


if not MYPY:
    class BackendAuthorizationHeaderCredentialsArgsDict(TypedDict):
        """
        Authorization header information.
        """
        parameter: pulumi.Input[str]
        """
        Authentication Parameter value.
        """
        scheme: pulumi.Input[str]
        """
        Authentication Scheme name.
        """
elif False:
    BackendAuthorizationHeaderCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendAuthorizationHeaderCredentialsArgs:
    def __init__(__self__, *,
                 parameter: pulumi.Input[str],
                 scheme: pulumi.Input[str]):
        """
        Authorization header information.
        :param pulumi.Input[str] parameter: Authentication Parameter value.
        :param pulumi.Input[str] scheme: Authentication Scheme name.
        """
        pulumi.set(__self__, "parameter", parameter)
        pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def parameter(self) -> pulumi.Input[str]:
        """
        Authentication Parameter value.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: pulumi.Input[str]):
        pulumi.set(self, "parameter", value)

    @property
    @pulumi.getter
    def scheme(self) -> pulumi.Input[str]:
        """
        Authentication Scheme name.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: pulumi.Input[str]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class BackendBaseParametersPoolArgsDict(TypedDict):
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input['BackendPoolItemArgsDict']]]]
        """
        The list of backend entities belonging to a pool.
        """
elif False:
    BackendBaseParametersPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendBaseParametersPoolArgs:
    def __init__(__self__, *,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['BackendPoolItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BackendPoolItemArgs']]] services: The list of backend entities belonging to a pool.
        """
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackendPoolItemArgs']]]]:
        """
        The list of backend entities belonging to a pool.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackendPoolItemArgs']]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class BackendCircuitBreakerArgsDict(TypedDict):
        """
        The configuration of the backend circuit breaker
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['CircuitBreakerRuleArgsDict']]]]
        """
        The rules for tripping the backend.
        """
elif False:
    BackendCircuitBreakerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendCircuitBreakerArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['CircuitBreakerRuleArgs']]]] = None):
        """
        The configuration of the backend circuit breaker
        :param pulumi.Input[Sequence[pulumi.Input['CircuitBreakerRuleArgs']]] rules: The rules for tripping the backend.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CircuitBreakerRuleArgs']]]]:
        """
        The rules for tripping the backend.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CircuitBreakerRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class BackendConfigurationArgsDict(TypedDict):
        """
        Information regarding how the gateway should integrate with backend systems.
        """
        subnet: NotRequired[pulumi.Input['BackendSubnetConfigurationArgsDict']]
        """
        The default hostname of the data-plane gateway to which requests can be sent.
        """
elif False:
    BackendConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendConfigurationArgs:
    def __init__(__self__, *,
                 subnet: Optional[pulumi.Input['BackendSubnetConfigurationArgs']] = None):
        """
        Information regarding how the gateway should integrate with backend systems.
        :param pulumi.Input['BackendSubnetConfigurationArgs'] subnet: The default hostname of the data-plane gateway to which requests can be sent.
        """
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input['BackendSubnetConfigurationArgs']]:
        """
        The default hostname of the data-plane gateway to which requests can be sent.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input['BackendSubnetConfigurationArgs']]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class BackendCredentialsContractArgsDict(TypedDict):
        """
        Details of the Credentials used to connect to Backend.
        """
        authorization: NotRequired[pulumi.Input['BackendAuthorizationHeaderCredentialsArgsDict']]
        """
        Authorization header authentication
        """
        certificate: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
        """
        certificate_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Client Certificate Ids.
        """
        header: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]
        """
        Header Parameter description.
        """
        query: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]
        """
        Query Parameter description.
        """
elif False:
    BackendCredentialsContractArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendCredentialsContractArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input['BackendAuthorizationHeaderCredentialsArgs']] = None,
                 certificate: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 certificate_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 header: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 query: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None):
        """
        Details of the Credentials used to connect to Backend.
        :param pulumi.Input['BackendAuthorizationHeaderCredentialsArgs'] authorization: Authorization header authentication
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate: List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_ids: List of Client Certificate Ids.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] header: Header Parameter description.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] query: Query Parameter description.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_ids is not None:
            pulumi.set(__self__, "certificate_ids", certificate_ids)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['BackendAuthorizationHeaderCredentialsArgs']]:
        """
        Authorization header authentication
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['BackendAuthorizationHeaderCredentialsArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Client Certificate Ids.
        """
        return pulumi.get(self, "certificate_ids")

    @certificate_ids.setter
    def certificate_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "certificate_ids", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        Header Parameter description.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        Query Parameter description.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class BackendPoolItemArgsDict(TypedDict):
        """
        Backend pool service information
        """
        id: pulumi.Input[str]
        """
        The unique ARM id of the backend entity. The ARM id should refer to an already existing backend entity.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        The priority of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        """
        weight: NotRequired[pulumi.Input[int]]
        """
        The weight of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        """
elif False:
    BackendPoolItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendPoolItemArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 priority: Optional[pulumi.Input[int]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        Backend pool service information
        :param pulumi.Input[str] id: The unique ARM id of the backend entity. The ARM id should refer to an already existing backend entity.
        :param pulumi.Input[int] priority: The priority of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        :param pulumi.Input[int] weight: The weight of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        """
        pulumi.set(__self__, "id", id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The unique ARM id of the backend entity. The ARM id should refer to an already existing backend entity.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        The priority of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        The weight of the backend entity in the backend pool. Must be between 0 and 100. It can be also null if the value not specified.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class BackendPropertiesArgsDict(TypedDict):
        """
        Properties specific to the Backend Type.
        """
        service_fabric_cluster: NotRequired[pulumi.Input['BackendServiceFabricClusterPropertiesArgsDict']]
        """
        Backend Service Fabric Cluster Properties
        """
elif False:
    BackendPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendPropertiesArgs:
    def __init__(__self__, *,
                 service_fabric_cluster: Optional[pulumi.Input['BackendServiceFabricClusterPropertiesArgs']] = None):
        """
        Properties specific to the Backend Type.
        :param pulumi.Input['BackendServiceFabricClusterPropertiesArgs'] service_fabric_cluster: Backend Service Fabric Cluster Properties
        """
        if service_fabric_cluster is not None:
            pulumi.set(__self__, "service_fabric_cluster", service_fabric_cluster)

    @property
    @pulumi.getter(name="serviceFabricCluster")
    def service_fabric_cluster(self) -> Optional[pulumi.Input['BackendServiceFabricClusterPropertiesArgs']]:
        """
        Backend Service Fabric Cluster Properties
        """
        return pulumi.get(self, "service_fabric_cluster")

    @service_fabric_cluster.setter
    def service_fabric_cluster(self, value: Optional[pulumi.Input['BackendServiceFabricClusterPropertiesArgs']]):
        pulumi.set(self, "service_fabric_cluster", value)


if not MYPY:
    class BackendProxyContractArgsDict(TypedDict):
        """
        Details of the Backend WebProxy Server to use in the Request to Backend.
        """
        url: pulumi.Input[str]
        """
        WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all fragments and query strings.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password to connect to the WebProxy Server
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Username to connect to the WebProxy server
        """
elif False:
    BackendProxyContractArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendProxyContractArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Details of the Backend WebProxy Server to use in the Request to Backend.
        :param pulumi.Input[str] url: WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all fragments and query strings.
        :param pulumi.Input[str] password: Password to connect to the WebProxy Server
        :param pulumi.Input[str] username: Username to connect to the WebProxy server
        """
        pulumi.set(__self__, "url", url)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all fragments and query strings.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password to connect to the WebProxy Server
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username to connect to the WebProxy server
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class BackendServiceFabricClusterPropertiesArgsDict(TypedDict):
        """
        Properties of the Service Fabric Type Backend.
        """
        management_endpoints: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The cluster management endpoint.
        """
        client_certificate_id: NotRequired[pulumi.Input[str]]
        """
        The client certificate id for the management endpoint.
        """
        client_certificatethumbprint: NotRequired[pulumi.Input[str]]
        """
        The client certificate thumbprint for the management endpoint. Will be ignored if certificatesIds are provided
        """
        max_partition_resolution_retries: NotRequired[pulumi.Input[int]]
        """
        Maximum number of retries while attempting resolve the partition.
        """
        server_certificate_thumbprints: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Thumbprints of certificates cluster management service uses for tls communication
        """
        server_x509_names: NotRequired[pulumi.Input[Sequence[pulumi.Input['X509CertificateNameArgsDict']]]]
        """
        Server X509 Certificate Names Collection
        """
elif False:
    BackendServiceFabricClusterPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendServiceFabricClusterPropertiesArgs:
    def __init__(__self__, *,
                 management_endpoints: pulumi.Input[Sequence[pulumi.Input[str]]],
                 client_certificate_id: Optional[pulumi.Input[str]] = None,
                 client_certificatethumbprint: Optional[pulumi.Input[str]] = None,
                 max_partition_resolution_retries: Optional[pulumi.Input[int]] = None,
                 server_certificate_thumbprints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 server_x509_names: Optional[pulumi.Input[Sequence[pulumi.Input['X509CertificateNameArgs']]]] = None):
        """
        Properties of the Service Fabric Type Backend.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] management_endpoints: The cluster management endpoint.
        :param pulumi.Input[str] client_certificate_id: The client certificate id for the management endpoint.
        :param pulumi.Input[str] client_certificatethumbprint: The client certificate thumbprint for the management endpoint. Will be ignored if certificatesIds are provided
        :param pulumi.Input[int] max_partition_resolution_retries: Maximum number of retries while attempting resolve the partition.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] server_certificate_thumbprints: Thumbprints of certificates cluster management service uses for tls communication
        :param pulumi.Input[Sequence[pulumi.Input['X509CertificateNameArgs']]] server_x509_names: Server X509 Certificate Names Collection
        """
        pulumi.set(__self__, "management_endpoints", management_endpoints)
        if client_certificate_id is not None:
            pulumi.set(__self__, "client_certificate_id", client_certificate_id)
        if client_certificatethumbprint is not None:
            pulumi.set(__self__, "client_certificatethumbprint", client_certificatethumbprint)
        if max_partition_resolution_retries is not None:
            pulumi.set(__self__, "max_partition_resolution_retries", max_partition_resolution_retries)
        if server_certificate_thumbprints is not None:
            pulumi.set(__self__, "server_certificate_thumbprints", server_certificate_thumbprints)
        if server_x509_names is not None:
            pulumi.set(__self__, "server_x509_names", server_x509_names)

    @property
    @pulumi.getter(name="managementEndpoints")
    def management_endpoints(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The cluster management endpoint.
        """
        return pulumi.get(self, "management_endpoints")

    @management_endpoints.setter
    def management_endpoints(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "management_endpoints", value)

    @property
    @pulumi.getter(name="clientCertificateId")
    def client_certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client certificate id for the management endpoint.
        """
        return pulumi.get(self, "client_certificate_id")

    @client_certificate_id.setter
    def client_certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate_id", value)

    @property
    @pulumi.getter(name="clientCertificatethumbprint")
    def client_certificatethumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        The client certificate thumbprint for the management endpoint. Will be ignored if certificatesIds are provided
        """
        return pulumi.get(self, "client_certificatethumbprint")

    @client_certificatethumbprint.setter
    def client_certificatethumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificatethumbprint", value)

    @property
    @pulumi.getter(name="maxPartitionResolutionRetries")
    def max_partition_resolution_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of retries while attempting resolve the partition.
        """
        return pulumi.get(self, "max_partition_resolution_retries")

    @max_partition_resolution_retries.setter
    def max_partition_resolution_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_partition_resolution_retries", value)

    @property
    @pulumi.getter(name="serverCertificateThumbprints")
    def server_certificate_thumbprints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Thumbprints of certificates cluster management service uses for tls communication
        """
        return pulumi.get(self, "server_certificate_thumbprints")

    @server_certificate_thumbprints.setter
    def server_certificate_thumbprints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "server_certificate_thumbprints", value)

    @property
    @pulumi.getter(name="serverX509Names")
    def server_x509_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['X509CertificateNameArgs']]]]:
        """
        Server X509 Certificate Names Collection
        """
        return pulumi.get(self, "server_x509_names")

    @server_x509_names.setter
    def server_x509_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['X509CertificateNameArgs']]]]):
        pulumi.set(self, "server_x509_names", value)


if not MYPY:
    class BackendSubnetConfigurationArgsDict(TypedDict):
        """
        Information regarding how the subnet to which the gateway should be injected.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ARM ID of the subnet in which the backend systems are hosted.
        """
elif False:
    BackendSubnetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendSubnetConfigurationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Information regarding how the subnet to which the gateway should be injected.
        :param pulumi.Input[str] id: The ARM ID of the subnet in which the backend systems are hosted.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM ID of the subnet in which the backend systems are hosted.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BackendTlsPropertiesArgsDict(TypedDict):
        """
        Properties controlling TLS Certificate Validation.
        """
        validate_certificate_chain: NotRequired[pulumi.Input[bool]]
        """
        Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for this backend host.
        """
        validate_certificate_name: NotRequired[pulumi.Input[bool]]
        """
        Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for this backend host.
        """
elif False:
    BackendTlsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackendTlsPropertiesArgs:
    def __init__(__self__, *,
                 validate_certificate_chain: Optional[pulumi.Input[bool]] = None,
                 validate_certificate_name: Optional[pulumi.Input[bool]] = None):
        """
        Properties controlling TLS Certificate Validation.
        :param pulumi.Input[bool] validate_certificate_chain: Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for this backend host.
        :param pulumi.Input[bool] validate_certificate_name: Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for this backend host.
        """
        if validate_certificate_chain is None:
            validate_certificate_chain = True
        if validate_certificate_chain is not None:
            pulumi.set(__self__, "validate_certificate_chain", validate_certificate_chain)
        if validate_certificate_name is None:
            validate_certificate_name = True
        if validate_certificate_name is not None:
            pulumi.set(__self__, "validate_certificate_name", validate_certificate_name)

    @property
    @pulumi.getter(name="validateCertificateChain")
    def validate_certificate_chain(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for this backend host.
        """
        return pulumi.get(self, "validate_certificate_chain")

    @validate_certificate_chain.setter
    def validate_certificate_chain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_certificate_chain", value)

    @property
    @pulumi.getter(name="validateCertificateName")
    def validate_certificate_name(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for this backend host.
        """
        return pulumi.get(self, "validate_certificate_name")

    @validate_certificate_name.setter
    def validate_certificate_name(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_certificate_name", value)


if not MYPY:
    class BodyDiagnosticSettingsArgsDict(TypedDict):
        """
        Body logging settings.
        """
        bytes: NotRequired[pulumi.Input[int]]
        """
        Number of request body bytes to log.
        """
elif False:
    BodyDiagnosticSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BodyDiagnosticSettingsArgs:
    def __init__(__self__, *,
                 bytes: Optional[pulumi.Input[int]] = None):
        """
        Body logging settings.
        :param pulumi.Input[int] bytes: Number of request body bytes to log.
        """
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)

    @property
    @pulumi.getter
    def bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Number of request body bytes to log.
        """
        return pulumi.get(self, "bytes")

    @bytes.setter
    def bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bytes", value)


if not MYPY:
    class CircuitBreakerFailureConditionArgsDict(TypedDict):
        """
        The trip conditions of the circuit breaker
        """
        count: NotRequired[pulumi.Input[float]]
        """
        The threshold for opening the circuit.
        """
        error_reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The error reasons which are considered as failure.
        """
        interval: NotRequired[pulumi.Input[str]]
        """
        The interval during which the failures are counted.
        """
        percentage: NotRequired[pulumi.Input[float]]
        """
        The threshold for opening the circuit.
        """
        status_code_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['FailureStatusCodeRangeArgsDict']]]]
        """
        The status code ranges which are considered as failure.
        """
elif False:
    CircuitBreakerFailureConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CircuitBreakerFailureConditionArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 error_reasons: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 interval: Optional[pulumi.Input[str]] = None,
                 percentage: Optional[pulumi.Input[float]] = None,
                 status_code_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['FailureStatusCodeRangeArgs']]]] = None):
        """
        The trip conditions of the circuit breaker
        :param pulumi.Input[float] count: The threshold for opening the circuit.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] error_reasons: The error reasons which are considered as failure.
        :param pulumi.Input[str] interval: The interval during which the failures are counted.
        :param pulumi.Input[float] percentage: The threshold for opening the circuit.
        :param pulumi.Input[Sequence[pulumi.Input['FailureStatusCodeRangeArgs']]] status_code_ranges: The status code ranges which are considered as failure.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if error_reasons is not None:
            pulumi.set(__self__, "error_reasons", error_reasons)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if status_code_ranges is not None:
            pulumi.set(__self__, "status_code_ranges", status_code_ranges)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        """
        The threshold for opening the circuit.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="errorReasons")
    def error_reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The error reasons which are considered as failure.
        """
        return pulumi.get(self, "error_reasons")

    @error_reasons.setter
    def error_reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "error_reasons", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        The interval during which the failures are counted.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[float]]:
        """
        The threshold for opening the circuit.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percentage", value)

    @property
    @pulumi.getter(name="statusCodeRanges")
    def status_code_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FailureStatusCodeRangeArgs']]]]:
        """
        The status code ranges which are considered as failure.
        """
        return pulumi.get(self, "status_code_ranges")

    @status_code_ranges.setter
    def status_code_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FailureStatusCodeRangeArgs']]]]):
        pulumi.set(self, "status_code_ranges", value)


if not MYPY:
    class CircuitBreakerRuleArgsDict(TypedDict):
        """
        Rule configuration to trip the backend.
        """
        accept_retry_after: NotRequired[pulumi.Input[bool]]
        """
        flag to accept Retry-After header from the backend.
        """
        failure_condition: NotRequired[pulumi.Input['CircuitBreakerFailureConditionArgsDict']]
        """
        The conditions for tripping the circuit breaker.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The rule name.
        """
        trip_duration: NotRequired[pulumi.Input[str]]
        """
        The duration for which the circuit will be tripped.
        """
elif False:
    CircuitBreakerRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CircuitBreakerRuleArgs:
    def __init__(__self__, *,
                 accept_retry_after: Optional[pulumi.Input[bool]] = None,
                 failure_condition: Optional[pulumi.Input['CircuitBreakerFailureConditionArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 trip_duration: Optional[pulumi.Input[str]] = None):
        """
        Rule configuration to trip the backend.
        :param pulumi.Input[bool] accept_retry_after: flag to accept Retry-After header from the backend.
        :param pulumi.Input['CircuitBreakerFailureConditionArgs'] failure_condition: The conditions for tripping the circuit breaker.
        :param pulumi.Input[str] name: The rule name.
        :param pulumi.Input[str] trip_duration: The duration for which the circuit will be tripped.
        """
        if accept_retry_after is not None:
            pulumi.set(__self__, "accept_retry_after", accept_retry_after)
        if failure_condition is not None:
            pulumi.set(__self__, "failure_condition", failure_condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if trip_duration is not None:
            pulumi.set(__self__, "trip_duration", trip_duration)

    @property
    @pulumi.getter(name="acceptRetryAfter")
    def accept_retry_after(self) -> Optional[pulumi.Input[bool]]:
        """
        flag to accept Retry-After header from the backend.
        """
        return pulumi.get(self, "accept_retry_after")

    @accept_retry_after.setter
    def accept_retry_after(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accept_retry_after", value)

    @property
    @pulumi.getter(name="failureCondition")
    def failure_condition(self) -> Optional[pulumi.Input['CircuitBreakerFailureConditionArgs']]:
        """
        The conditions for tripping the circuit breaker.
        """
        return pulumi.get(self, "failure_condition")

    @failure_condition.setter
    def failure_condition(self, value: Optional[pulumi.Input['CircuitBreakerFailureConditionArgs']]):
        pulumi.set(self, "failure_condition", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tripDuration")
    def trip_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration for which the circuit will be tripped.
        """
        return pulumi.get(self, "trip_duration")

    @trip_duration.setter
    def trip_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trip_duration", value)


if not MYPY:
    class DataMaskingEntityArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[Union[str, 'DataMaskingMode']]]
        """
        Data masking mode.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The name of an entity to mask (e.g. a name of a header or a query parameter).
        """
elif False:
    DataMaskingEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataMaskingEntityArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[Union[str, 'DataMaskingMode']]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Union[str, 'DataMaskingMode']] mode: Data masking mode.
        :param pulumi.Input[str] value: The name of an entity to mask (e.g. a name of a header or a query parameter).
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'DataMaskingMode']]]:
        """
        Data masking mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'DataMaskingMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The name of an entity to mask (e.g. a name of a header or a query parameter).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DataMaskingArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgsDict']]]]
        """
        Masking settings for headers
        """
        query_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgsDict']]]]
        """
        Masking settings for Url query parameters
        """
elif False:
    DataMaskingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataMaskingArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgs']]]] = None,
                 query_params: Optional[pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgs']]] headers: Masking settings for headers
        :param pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgs']]] query_params: Masking settings for Url query parameters
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgs']]]]:
        """
        Masking settings for headers
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgs']]]]:
        """
        Masking settings for Url query parameters
        """
        return pulumi.get(self, "query_params")

    @query_params.setter
    def query_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataMaskingEntityArgs']]]]):
        pulumi.set(self, "query_params", value)


if not MYPY:
    class FailureStatusCodeRangeArgsDict(TypedDict):
        """
        The failure http status code range
        """
        max: NotRequired[pulumi.Input[int]]
        """
        The maximum http status code.
        """
        min: NotRequired[pulumi.Input[int]]
        """
        The minimum http status code.
        """
elif False:
    FailureStatusCodeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FailureStatusCodeRangeArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None):
        """
        The failure http status code range
        :param pulumi.Input[int] max: The maximum http status code.
        :param pulumi.Input[int] min: The minimum http status code.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum http status code.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum http status code.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class HttpMessageDiagnosticArgsDict(TypedDict):
        """
        Http message diagnostic settings.
        """
        body: NotRequired[pulumi.Input['BodyDiagnosticSettingsArgsDict']]
        """
        Body logging settings.
        """
        data_masking: NotRequired[pulumi.Input['DataMaskingArgsDict']]
        """
        Data masking settings.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of HTTP Headers to log.
        """
elif False:
    HttpMessageDiagnosticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpMessageDiagnosticArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input['BodyDiagnosticSettingsArgs']] = None,
                 data_masking: Optional[pulumi.Input['DataMaskingArgs']] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Http message diagnostic settings.
        :param pulumi.Input['BodyDiagnosticSettingsArgs'] body: Body logging settings.
        :param pulumi.Input['DataMaskingArgs'] data_masking: Data masking settings.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] headers: Array of HTTP Headers to log.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if data_masking is not None:
            pulumi.set(__self__, "data_masking", data_masking)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input['BodyDiagnosticSettingsArgs']]:
        """
        Body logging settings.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input['BodyDiagnosticSettingsArgs']]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="dataMasking")
    def data_masking(self) -> Optional[pulumi.Input['DataMaskingArgs']]:
        """
        Data masking settings.
        """
        return pulumi.get(self, "data_masking")

    @data_masking.setter
    def data_masking(self, value: Optional[pulumi.Input['DataMaskingArgs']]):
        pulumi.set(self, "data_masking", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of HTTP Headers to log.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class KeyVaultContractCreatePropertiesArgsDict(TypedDict):
        """
        Create keyVault contract details.
        """
        identity_client_id: NotRequired[pulumi.Input[str]]
        """
        Null for SystemAssignedIdentity or Client Id for UserAssignedIdentity , which will be used to access key vault secret.
        """
        secret_identifier: NotRequired[pulumi.Input[str]]
        """
        Key vault secret identifier for fetching secret. Providing a versioned secret will prevent auto-refresh. This requires API Management service to be configured with aka.ms/apimmsi
        """
elif False:
    KeyVaultContractCreatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultContractCreatePropertiesArgs:
    def __init__(__self__, *,
                 identity_client_id: Optional[pulumi.Input[str]] = None,
                 secret_identifier: Optional[pulumi.Input[str]] = None):
        """
        Create keyVault contract details.
        :param pulumi.Input[str] identity_client_id: Null for SystemAssignedIdentity or Client Id for UserAssignedIdentity , which will be used to access key vault secret.
        :param pulumi.Input[str] secret_identifier: Key vault secret identifier for fetching secret. Providing a versioned secret will prevent auto-refresh. This requires API Management service to be configured with aka.ms/apimmsi
        """
        if identity_client_id is not None:
            pulumi.set(__self__, "identity_client_id", identity_client_id)
        if secret_identifier is not None:
            pulumi.set(__self__, "secret_identifier", secret_identifier)

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Null for SystemAssignedIdentity or Client Id for UserAssignedIdentity , which will be used to access key vault secret.
        """
        return pulumi.get(self, "identity_client_id")

    @identity_client_id.setter
    def identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_client_id", value)

    @property
    @pulumi.getter(name="secretIdentifier")
    def secret_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        Key vault secret identifier for fetching secret. Providing a versioned secret will prevent auto-refresh. This requires API Management service to be configured with aka.ms/apimmsi
        """
        return pulumi.get(self, "secret_identifier")

    @secret_identifier.setter
    def secret_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_identifier", value)


if not MYPY:
    class PipelineDiagnosticSettingsArgsDict(TypedDict):
        """
        Diagnostic settings for incoming/outgoing HTTP messages to the Gateway.
        """
        request: NotRequired[pulumi.Input['HttpMessageDiagnosticArgsDict']]
        """
        Diagnostic settings for request.
        """
        response: NotRequired[pulumi.Input['HttpMessageDiagnosticArgsDict']]
        """
        Diagnostic settings for response.
        """
elif False:
    PipelineDiagnosticSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineDiagnosticSettingsArgs:
    def __init__(__self__, *,
                 request: Optional[pulumi.Input['HttpMessageDiagnosticArgs']] = None,
                 response: Optional[pulumi.Input['HttpMessageDiagnosticArgs']] = None):
        """
        Diagnostic settings for incoming/outgoing HTTP messages to the Gateway.
        :param pulumi.Input['HttpMessageDiagnosticArgs'] request: Diagnostic settings for request.
        :param pulumi.Input['HttpMessageDiagnosticArgs'] response: Diagnostic settings for response.
        """
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['HttpMessageDiagnosticArgs']]:
        """
        Diagnostic settings for request.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['HttpMessageDiagnosticArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['HttpMessageDiagnosticArgs']]:
        """
        Diagnostic settings for response.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['HttpMessageDiagnosticArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class SamplingSettingsArgsDict(TypedDict):
        """
        Sampling settings for Diagnostic.
        """
        percentage: NotRequired[pulumi.Input[float]]
        """
        Rate of sampling for fixed-rate sampling.
        """
        sampling_type: NotRequired[pulumi.Input[Union[str, 'SamplingType']]]
        """
        Sampling type.
        """
elif False:
    SamplingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SamplingSettingsArgs:
    def __init__(__self__, *,
                 percentage: Optional[pulumi.Input[float]] = None,
                 sampling_type: Optional[pulumi.Input[Union[str, 'SamplingType']]] = None):
        """
        Sampling settings for Diagnostic.
        :param pulumi.Input[float] percentage: Rate of sampling for fixed-rate sampling.
        :param pulumi.Input[Union[str, 'SamplingType']] sampling_type: Sampling type.
        """
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if sampling_type is not None:
            pulumi.set(__self__, "sampling_type", sampling_type)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Rate of sampling for fixed-rate sampling.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percentage", value)

    @property
    @pulumi.getter(name="samplingType")
    def sampling_type(self) -> Optional[pulumi.Input[Union[str, 'SamplingType']]]:
        """
        Sampling type.
        """
        return pulumi.get(self, "sampling_type")

    @sampling_type.setter
    def sampling_type(self, value: Optional[pulumi.Input[Union[str, 'SamplingType']]]):
        pulumi.set(self, "sampling_type", value)


if not MYPY:
    class X509CertificateNameArgsDict(TypedDict):
        """
        Properties of server X509Names.
        """
        issuer_certificate_thumbprint: NotRequired[pulumi.Input[str]]
        """
        Thumbprint for the Issuer of the Certificate.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Common Name of the Certificate.
        """
elif False:
    X509CertificateNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class X509CertificateNameArgs:
    def __init__(__self__, *,
                 issuer_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Properties of server X509Names.
        :param pulumi.Input[str] issuer_certificate_thumbprint: Thumbprint for the Issuer of the Certificate.
        :param pulumi.Input[str] name: Common Name of the Certificate.
        """
        if issuer_certificate_thumbprint is not None:
            pulumi.set(__self__, "issuer_certificate_thumbprint", issuer_certificate_thumbprint)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="issuerCertificateThumbprint")
    def issuer_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        Thumbprint for the Issuer of the Certificate.
        """
        return pulumi.get(self, "issuer_certificate_thumbprint")

    @issuer_certificate_thumbprint.setter
    def issuer_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer_certificate_thumbprint", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Common Name of the Certificate.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


