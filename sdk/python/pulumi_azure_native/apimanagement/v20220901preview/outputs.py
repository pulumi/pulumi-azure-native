# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AdditionalLocationResponse',
    'ApiContactInformationResponse',
    'ApiLicenseInformationResponse',
    'ApiManagementServiceIdentityResponse',
    'ApiManagementServiceSkuPropertiesResponse',
    'ApiVersionConstraintResponse',
    'ApiVersionSetContractDetailsResponse',
    'ArmIdWrapperResponse',
    'AuthenticationSettingsContractResponse',
    'AuthorizationErrorResponse',
    'AuthorizationProviderOAuth2GrantTypesResponse',
    'AuthorizationProviderOAuth2SettingsResponse',
    'BackendAuthorizationHeaderCredentialsResponse',
    'BackendCircuitBreakerResponse',
    'BackendCredentialsContractResponse',
    'BackendPropertiesResponse',
    'BackendProxyContractResponse',
    'BackendServiceFabricClusterPropertiesResponse',
    'BackendTlsPropertiesResponse',
    'BodyDiagnosticSettingsResponse',
    'CertificateConfigurationResponse',
    'CertificateInformationResponse',
    'CircuitBreakerFailureConditionResponse',
    'CircuitBreakerRuleResponse',
    'DataMaskingEntityResponse',
    'DataMaskingResponse',
    'EmailTemplateParametersContractPropertiesResponse',
    'FailureStatusCodeRangeResponse',
    'GroupContractPropertiesResponse',
    'HostnameConfigurationResponse',
    'HttpMessageDiagnosticResponse',
    'KeyVaultContractPropertiesResponse',
    'KeyVaultLastAccessStatusContractPropertiesResponse',
    'OAuth2AuthenticationSettingsContractResponse',
    'OpenIdAuthenticationSettingsContractResponse',
    'ParameterContractResponse',
    'ParameterExampleContractResponse',
    'PipelineDiagnosticSettingsResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'RemotePrivateEndpointConnectionWrapperResponse',
    'RepresentationContractResponse',
    'RequestContractResponse',
    'ResourceCollectionResponseValue',
    'ResourceLocationDataContractResponse',
    'ResponseContractResponse',
    'SamplingSettingsResponse',
    'SubscriptionKeyParameterNamesContractResponse',
    'SystemDataResponse',
    'TokenBodyParameterContractResponse',
    'UserIdentityContractResponse',
    'UserIdentityPropertiesResponse',
    'VirtualNetworkConfigurationResponse',
    'WikiDocumentationContractResponse',
    'X509CertificateNameResponse',
]

@pulumi.output_type
class AdditionalLocationResponse(dict):
    """
    Description of an additional API Management resource location.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayRegionalUrl":
            suggest = "gateway_regional_url"
        elif key == "outboundPublicIPAddresses":
            suggest = "outbound_public_ip_addresses"
        elif key == "platformVersion":
            suggest = "platform_version"
        elif key == "privateIPAddresses":
            suggest = "private_ip_addresses"
        elif key == "publicIPAddresses":
            suggest = "public_ip_addresses"
        elif key == "disableGateway":
            suggest = "disable_gateway"
        elif key == "natGatewayState":
            suggest = "nat_gateway_state"
        elif key == "publicIpAddressId":
            suggest = "public_ip_address_id"
        elif key == "virtualNetworkConfiguration":
            suggest = "virtual_network_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdditionalLocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdditionalLocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdditionalLocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway_regional_url: str,
                 location: str,
                 outbound_public_ip_addresses: Sequence[str],
                 platform_version: str,
                 private_ip_addresses: Sequence[str],
                 public_ip_addresses: Sequence[str],
                 sku: 'outputs.ApiManagementServiceSkuPropertiesResponse',
                 disable_gateway: Optional[bool] = None,
                 nat_gateway_state: Optional[str] = None,
                 public_ip_address_id: Optional[str] = None,
                 virtual_network_configuration: Optional['outputs.VirtualNetworkConfigurationResponse'] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        Description of an additional API Management resource location.
        :param str gateway_regional_url: Gateway URL of the API Management service in the Region.
        :param str location: The location name of the additional region among Azure Data center regions.
        :param Sequence[str] outbound_public_ip_addresses: Outbound public IPV4 address prefixes associated with NAT Gateway deployed service. Available only for Premium SKU on stv2 platform.
        :param str platform_version: Compute Platform Version running the service.
        :param Sequence[str] private_ip_addresses: Private Static Load Balanced IP addresses of the API Management service which is deployed in an Internal Virtual Network in a particular additional location. Available only for Basic, Standard, Premium and Isolated SKU.
        :param Sequence[str] public_ip_addresses: Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard, Premium and Isolated SKU.
        :param 'ApiManagementServiceSkuPropertiesResponse' sku: SKU properties of the API Management service.
        :param bool disable_gateway: Property only valid for an Api Management service deployed in multiple locations. This can be used to disable the gateway in this additional location.
        :param str nat_gateway_state: Property can be used to enable NAT Gateway for this API Management service.
        :param str public_ip_address_id: Public Standard SKU IP V4 based IP address to be associated with Virtual Network deployed service in the location. Supported only for Premium SKU being deployed in Virtual Network.
        :param 'VirtualNetworkConfigurationResponse' virtual_network_configuration: Virtual network configuration for the location.
        :param Sequence[str] zones: A list of availability zones denoting where the resource needs to come from.
        """
        AdditionalLocationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gateway_regional_url=gateway_regional_url,
            location=location,
            outbound_public_ip_addresses=outbound_public_ip_addresses,
            platform_version=platform_version,
            private_ip_addresses=private_ip_addresses,
            public_ip_addresses=public_ip_addresses,
            sku=sku,
            disable_gateway=disable_gateway,
            nat_gateway_state=nat_gateway_state,
            public_ip_address_id=public_ip_address_id,
            virtual_network_configuration=virtual_network_configuration,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gateway_regional_url: str,
             location: str,
             outbound_public_ip_addresses: Sequence[str],
             platform_version: str,
             private_ip_addresses: Sequence[str],
             public_ip_addresses: Sequence[str],
             sku: 'outputs.ApiManagementServiceSkuPropertiesResponse',
             disable_gateway: Optional[bool] = None,
             nat_gateway_state: Optional[str] = None,
             public_ip_address_id: Optional[str] = None,
             virtual_network_configuration: Optional['outputs.VirtualNetworkConfigurationResponse'] = None,
             zones: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'gatewayRegionalUrl' in kwargs:
            gateway_regional_url = kwargs['gatewayRegionalUrl']
        if 'outboundPublicIPAddresses' in kwargs:
            outbound_public_ip_addresses = kwargs['outboundPublicIPAddresses']
        if 'platformVersion' in kwargs:
            platform_version = kwargs['platformVersion']
        if 'privateIPAddresses' in kwargs:
            private_ip_addresses = kwargs['privateIPAddresses']
        if 'publicIPAddresses' in kwargs:
            public_ip_addresses = kwargs['publicIPAddresses']
        if 'disableGateway' in kwargs:
            disable_gateway = kwargs['disableGateway']
        if 'natGatewayState' in kwargs:
            nat_gateway_state = kwargs['natGatewayState']
        if 'publicIpAddressId' in kwargs:
            public_ip_address_id = kwargs['publicIpAddressId']
        if 'virtualNetworkConfiguration' in kwargs:
            virtual_network_configuration = kwargs['virtualNetworkConfiguration']

        _setter("gateway_regional_url", gateway_regional_url)
        _setter("location", location)
        _setter("outbound_public_ip_addresses", outbound_public_ip_addresses)
        _setter("platform_version", platform_version)
        _setter("private_ip_addresses", private_ip_addresses)
        _setter("public_ip_addresses", public_ip_addresses)
        _setter("sku", sku)
        if disable_gateway is None:
            disable_gateway = False
        if disable_gateway is not None:
            _setter("disable_gateway", disable_gateway)
        if nat_gateway_state is None:
            nat_gateway_state = 'Disabled'
        if nat_gateway_state is not None:
            _setter("nat_gateway_state", nat_gateway_state)
        if public_ip_address_id is not None:
            _setter("public_ip_address_id", public_ip_address_id)
        if virtual_network_configuration is not None:
            _setter("virtual_network_configuration", virtual_network_configuration)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter(name="gatewayRegionalUrl")
    def gateway_regional_url(self) -> str:
        """
        Gateway URL of the API Management service in the Region.
        """
        return pulumi.get(self, "gateway_regional_url")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The location name of the additional region among Azure Data center regions.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="outboundPublicIPAddresses")
    def outbound_public_ip_addresses(self) -> Sequence[str]:
        """
        Outbound public IPV4 address prefixes associated with NAT Gateway deployed service. Available only for Premium SKU on stv2 platform.
        """
        return pulumi.get(self, "outbound_public_ip_addresses")

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> str:
        """
        Compute Platform Version running the service.
        """
        return pulumi.get(self, "platform_version")

    @property
    @pulumi.getter(name="privateIPAddresses")
    def private_ip_addresses(self) -> Sequence[str]:
        """
        Private Static Load Balanced IP addresses of the API Management service which is deployed in an Internal Virtual Network in a particular additional location. Available only for Basic, Standard, Premium and Isolated SKU.
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="publicIPAddresses")
    def public_ip_addresses(self) -> Sequence[str]:
        """
        Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard, Premium and Isolated SKU.
        """
        return pulumi.get(self, "public_ip_addresses")

    @property
    @pulumi.getter
    def sku(self) -> 'outputs.ApiManagementServiceSkuPropertiesResponse':
        """
        SKU properties of the API Management service.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter(name="disableGateway")
    def disable_gateway(self) -> Optional[bool]:
        """
        Property only valid for an Api Management service deployed in multiple locations. This can be used to disable the gateway in this additional location.
        """
        return pulumi.get(self, "disable_gateway")

    @property
    @pulumi.getter(name="natGatewayState")
    def nat_gateway_state(self) -> Optional[str]:
        """
        Property can be used to enable NAT Gateway for this API Management service.
        """
        return pulumi.get(self, "nat_gateway_state")

    @property
    @pulumi.getter(name="publicIpAddressId")
    def public_ip_address_id(self) -> Optional[str]:
        """
        Public Standard SKU IP V4 based IP address to be associated with Virtual Network deployed service in the location. Supported only for Premium SKU being deployed in Virtual Network.
        """
        return pulumi.get(self, "public_ip_address_id")

    @property
    @pulumi.getter(name="virtualNetworkConfiguration")
    def virtual_network_configuration(self) -> Optional['outputs.VirtualNetworkConfigurationResponse']:
        """
        Virtual network configuration for the location.
        """
        return pulumi.get(self, "virtual_network_configuration")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        A list of availability zones denoting where the resource needs to come from.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class ApiContactInformationResponse(dict):
    """
    API contact information
    """
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 name: Optional[str] = None,
                 url: Optional[str] = None):
        """
        API contact information
        :param str email: The email address of the contact person/organization. MUST be in the format of an email address
        :param str name: The identifying name of the contact person/organization
        :param str url: The URL pointing to the contact information. MUST be in the format of a URL
        """
        ApiContactInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            name=name,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             name: Optional[str] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if email is not None:
            _setter("email", email)
        if name is not None:
            _setter("name", name)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The email address of the contact person/organization. MUST be in the format of an email address
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The identifying name of the contact person/organization
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL pointing to the contact information. MUST be in the format of a URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ApiLicenseInformationResponse(dict):
    """
    API license information
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 url: Optional[str] = None):
        """
        API license information
        :param str name: The license name used for the API
        :param str url: A URL to the license used for the API. MUST be in the format of a URL
        """
        ApiLicenseInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The license name used for the API
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        A URL to the license used for the API. MUST be in the format of a URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ApiManagementServiceIdentityResponse(dict):
    """
    Identity properties of the Api Management service resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiManagementServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiManagementServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiManagementServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserIdentityPropertiesResponse']] = None):
        """
        Identity properties of the Api Management service resource.
        :param str principal_id: The principal id of the identity.
        :param str tenant_id: The client tenant id of the identity.
        :param str type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        :param Mapping[str, 'UserIdentityPropertiesResponse'] user_assigned_identities: The list of user identities associated with the resource. The user identity 
               dictionary key references will be ARM resource ids in the form: 
               '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
                   providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        ApiManagementServiceIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: str,
             tenant_id: str,
             type: str,
             user_assigned_identities: Optional[Mapping[str, 'outputs.UserIdentityPropertiesResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of the identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The client tenant id of the identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserIdentityPropertiesResponse']]:
        """
        The list of user identities associated with the resource. The user identity 
        dictionary key references will be ARM resource ids in the form: 
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
            providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ApiManagementServiceSkuPropertiesResponse(dict):
    """
    API Management service resource SKU properties.
    """
    def __init__(__self__, *,
                 capacity: int,
                 name: str):
        """
        API Management service resource SKU properties.
        :param int capacity: Capacity of the SKU (number of deployed units of the SKU). For Consumption SKU capacity must be specified as 0.
        :param str name: Name of the Sku.
        """
        ApiManagementServiceSkuPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity=capacity,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity: int,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("capacity", capacity)
        _setter("name", name)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Capacity of the SKU (number of deployed units of the SKU). For Consumption SKU capacity must be specified as 0.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Sku.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ApiVersionConstraintResponse(dict):
    """
    Control Plane Apis version constraint for the API Management service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minApiVersion":
            suggest = "min_api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiVersionConstraintResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiVersionConstraintResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiVersionConstraintResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_api_version: Optional[str] = None):
        """
        Control Plane Apis version constraint for the API Management service.
        :param str min_api_version: Limit control plane API calls to API Management service with version equal to or newer than this value.
        """
        ApiVersionConstraintResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            min_api_version=min_api_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             min_api_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'minApiVersion' in kwargs:
            min_api_version = kwargs['minApiVersion']

        if min_api_version is not None:
            _setter("min_api_version", min_api_version)

    @property
    @pulumi.getter(name="minApiVersion")
    def min_api_version(self) -> Optional[str]:
        """
        Limit control plane API calls to API Management service with version equal to or newer than this value.
        """
        return pulumi.get(self, "min_api_version")


@pulumi.output_type
class ApiVersionSetContractDetailsResponse(dict):
    """
    An API Version Set contains the common configuration for a set of API Versions relating 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "versionHeaderName":
            suggest = "version_header_name"
        elif key == "versionQueryName":
            suggest = "version_query_name"
        elif key == "versioningScheme":
            suggest = "versioning_scheme"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiVersionSetContractDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiVersionSetContractDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiVersionSetContractDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 version_header_name: Optional[str] = None,
                 version_query_name: Optional[str] = None,
                 versioning_scheme: Optional[str] = None):
        """
        An API Version Set contains the common configuration for a set of API Versions relating 
        :param str description: Description of API Version Set.
        :param str id: Identifier for existing API Version Set. Omit this value to create a new Version Set.
        :param str name: The display Name of the API Version Set.
        :param str version_header_name: Name of HTTP header parameter that indicates the API Version if versioningScheme is set to `header`.
        :param str version_query_name: Name of query parameter that indicates the API Version if versioningScheme is set to `query`.
        :param str versioning_scheme: An value that determines where the API Version identifier will be located in a HTTP request.
        """
        ApiVersionSetContractDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            name=name,
            version_header_name=version_header_name,
            version_query_name=version_query_name,
            versioning_scheme=versioning_scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             version_header_name: Optional[str] = None,
             version_query_name: Optional[str] = None,
             versioning_scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'versionHeaderName' in kwargs:
            version_header_name = kwargs['versionHeaderName']
        if 'versionQueryName' in kwargs:
            version_query_name = kwargs['versionQueryName']
        if 'versioningScheme' in kwargs:
            versioning_scheme = kwargs['versioningScheme']

        if description is not None:
            _setter("description", description)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if version_header_name is not None:
            _setter("version_header_name", version_header_name)
        if version_query_name is not None:
            _setter("version_query_name", version_query_name)
        if versioning_scheme is not None:
            _setter("versioning_scheme", versioning_scheme)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of API Version Set.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier for existing API Version Set. Omit this value to create a new Version Set.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The display Name of the API Version Set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="versionHeaderName")
    def version_header_name(self) -> Optional[str]:
        """
        Name of HTTP header parameter that indicates the API Version if versioningScheme is set to `header`.
        """
        return pulumi.get(self, "version_header_name")

    @property
    @pulumi.getter(name="versionQueryName")
    def version_query_name(self) -> Optional[str]:
        """
        Name of query parameter that indicates the API Version if versioningScheme is set to `query`.
        """
        return pulumi.get(self, "version_query_name")

    @property
    @pulumi.getter(name="versioningScheme")
    def versioning_scheme(self) -> Optional[str]:
        """
        An value that determines where the API Version identifier will be located in a HTTP request.
        """
        return pulumi.get(self, "versioning_scheme")


@pulumi.output_type
class ArmIdWrapperResponse(dict):
    """
    A wrapper for an ARM resource id
    """
    def __init__(__self__, *,
                 id: str):
        """
        A wrapper for an ARM resource id
        """
        ArmIdWrapperResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class AuthenticationSettingsContractResponse(dict):
    """
    API Authentication Settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth2":
            suggest = "o_auth2"
        elif key == "oAuth2AuthenticationSettings":
            suggest = "o_auth2_authentication_settings"
        elif key == "openidAuthenticationSettings":
            suggest = "openid_authentication_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthenticationSettingsContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthenticationSettingsContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthenticationSettingsContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth2: Optional['outputs.OAuth2AuthenticationSettingsContractResponse'] = None,
                 o_auth2_authentication_settings: Optional[Sequence['outputs.OAuth2AuthenticationSettingsContractResponse']] = None,
                 openid: Optional['outputs.OpenIdAuthenticationSettingsContractResponse'] = None,
                 openid_authentication_settings: Optional[Sequence['outputs.OpenIdAuthenticationSettingsContractResponse']] = None):
        """
        API Authentication Settings.
        :param 'OAuth2AuthenticationSettingsContractResponse' o_auth2: OAuth2 Authentication settings
        :param Sequence['OAuth2AuthenticationSettingsContractResponse'] o_auth2_authentication_settings: Collection of OAuth2 authentication settings included into this API.
        :param 'OpenIdAuthenticationSettingsContractResponse' openid: OpenID Connect Authentication Settings
        :param Sequence['OpenIdAuthenticationSettingsContractResponse'] openid_authentication_settings: Collection of Open ID Connect authentication settings included into this API.
        """
        AuthenticationSettingsContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            o_auth2=o_auth2,
            o_auth2_authentication_settings=o_auth2_authentication_settings,
            openid=openid,
            openid_authentication_settings=openid_authentication_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             o_auth2: Optional['outputs.OAuth2AuthenticationSettingsContractResponse'] = None,
             o_auth2_authentication_settings: Optional[Sequence['outputs.OAuth2AuthenticationSettingsContractResponse']] = None,
             openid: Optional['outputs.OpenIdAuthenticationSettingsContractResponse'] = None,
             openid_authentication_settings: Optional[Sequence['outputs.OpenIdAuthenticationSettingsContractResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'oAuth2' in kwargs:
            o_auth2 = kwargs['oAuth2']
        if 'oAuth2AuthenticationSettings' in kwargs:
            o_auth2_authentication_settings = kwargs['oAuth2AuthenticationSettings']
        if 'openidAuthenticationSettings' in kwargs:
            openid_authentication_settings = kwargs['openidAuthenticationSettings']

        if o_auth2 is not None:
            _setter("o_auth2", o_auth2)
        if o_auth2_authentication_settings is not None:
            _setter("o_auth2_authentication_settings", o_auth2_authentication_settings)
        if openid is not None:
            _setter("openid", openid)
        if openid_authentication_settings is not None:
            _setter("openid_authentication_settings", openid_authentication_settings)

    @property
    @pulumi.getter(name="oAuth2")
    def o_auth2(self) -> Optional['outputs.OAuth2AuthenticationSettingsContractResponse']:
        """
        OAuth2 Authentication settings
        """
        return pulumi.get(self, "o_auth2")

    @property
    @pulumi.getter(name="oAuth2AuthenticationSettings")
    def o_auth2_authentication_settings(self) -> Optional[Sequence['outputs.OAuth2AuthenticationSettingsContractResponse']]:
        """
        Collection of OAuth2 authentication settings included into this API.
        """
        return pulumi.get(self, "o_auth2_authentication_settings")

    @property
    @pulumi.getter
    def openid(self) -> Optional['outputs.OpenIdAuthenticationSettingsContractResponse']:
        """
        OpenID Connect Authentication Settings
        """
        return pulumi.get(self, "openid")

    @property
    @pulumi.getter(name="openidAuthenticationSettings")
    def openid_authentication_settings(self) -> Optional[Sequence['outputs.OpenIdAuthenticationSettingsContractResponse']]:
        """
        Collection of Open ID Connect authentication settings included into this API.
        """
        return pulumi.get(self, "openid_authentication_settings")


@pulumi.output_type
class AuthorizationErrorResponse(dict):
    """
    Authorization error details.
    """
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 message: Optional[str] = None):
        """
        Authorization error details.
        :param str code: Error code
        :param str message: Error message
        """
        AuthorizationErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            message=message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if code is not None:
            _setter("code", code)
        if message is not None:
            _setter("message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        Error code
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Error message
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class AuthorizationProviderOAuth2GrantTypesResponse(dict):
    """
    Authorization Provider oauth2 grant types settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationCode":
            suggest = "authorization_code"
        elif key == "clientCredentials":
            suggest = "client_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationProviderOAuth2GrantTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationProviderOAuth2GrantTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationProviderOAuth2GrantTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_code: Optional[Mapping[str, str]] = None,
                 client_credentials: Optional[Mapping[str, str]] = None):
        """
        Authorization Provider oauth2 grant types settings
        :param Mapping[str, str] authorization_code: OAuth2 authorization code grant parameters
        :param Mapping[str, str] client_credentials: OAuth2 client credential grant parameters
        """
        AuthorizationProviderOAuth2GrantTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization_code=authorization_code,
            client_credentials=client_credentials,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization_code: Optional[Mapping[str, str]] = None,
             client_credentials: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'authorizationCode' in kwargs:
            authorization_code = kwargs['authorizationCode']
        if 'clientCredentials' in kwargs:
            client_credentials = kwargs['clientCredentials']

        if authorization_code is not None:
            _setter("authorization_code", authorization_code)
        if client_credentials is not None:
            _setter("client_credentials", client_credentials)

    @property
    @pulumi.getter(name="authorizationCode")
    def authorization_code(self) -> Optional[Mapping[str, str]]:
        """
        OAuth2 authorization code grant parameters
        """
        return pulumi.get(self, "authorization_code")

    @property
    @pulumi.getter(name="clientCredentials")
    def client_credentials(self) -> Optional[Mapping[str, str]]:
        """
        OAuth2 client credential grant parameters
        """
        return pulumi.get(self, "client_credentials")


@pulumi.output_type
class AuthorizationProviderOAuth2SettingsResponse(dict):
    """
    OAuth2 settings details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grantTypes":
            suggest = "grant_types"
        elif key == "redirectUrl":
            suggest = "redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationProviderOAuth2SettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationProviderOAuth2SettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationProviderOAuth2SettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grant_types: Optional['outputs.AuthorizationProviderOAuth2GrantTypesResponse'] = None,
                 redirect_url: Optional[str] = None):
        """
        OAuth2 settings details
        :param 'AuthorizationProviderOAuth2GrantTypesResponse' grant_types: OAuth2 settings
        :param str redirect_url: Redirect URL to be set in the OAuth application.
        """
        AuthorizationProviderOAuth2SettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grant_types=grant_types,
            redirect_url=redirect_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grant_types: Optional['outputs.AuthorizationProviderOAuth2GrantTypesResponse'] = None,
             redirect_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'grantTypes' in kwargs:
            grant_types = kwargs['grantTypes']
        if 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']

        if grant_types is not None:
            _setter("grant_types", grant_types)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)

    @property
    @pulumi.getter(name="grantTypes")
    def grant_types(self) -> Optional['outputs.AuthorizationProviderOAuth2GrantTypesResponse']:
        """
        OAuth2 settings
        """
        return pulumi.get(self, "grant_types")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[str]:
        """
        Redirect URL to be set in the OAuth application.
        """
        return pulumi.get(self, "redirect_url")


@pulumi.output_type
class BackendAuthorizationHeaderCredentialsResponse(dict):
    """
    Authorization header information.
    """
    def __init__(__self__, *,
                 parameter: str,
                 scheme: str):
        """
        Authorization header information.
        :param str parameter: Authentication Parameter value.
        :param str scheme: Authentication Scheme name.
        """
        BackendAuthorizationHeaderCredentialsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameter=parameter,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameter: str,
             scheme: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("parameter", parameter)
        _setter("scheme", scheme)

    @property
    @pulumi.getter
    def parameter(self) -> str:
        """
        Authentication Parameter value.
        """
        return pulumi.get(self, "parameter")

    @property
    @pulumi.getter
    def scheme(self) -> str:
        """
        Authentication Scheme name.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class BackendCircuitBreakerResponse(dict):
    """
    The configuration of the backend circuit breaker
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.CircuitBreakerRuleResponse']] = None):
        """
        The configuration of the backend circuit breaker
        :param Sequence['CircuitBreakerRuleResponse'] rules: The rules for tripping the backend.
        """
        BackendCircuitBreakerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[Sequence['outputs.CircuitBreakerRuleResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.CircuitBreakerRuleResponse']]:
        """
        The rules for tripping the backend.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class BackendCredentialsContractResponse(dict):
    """
    Details of the Credentials used to connect to Backend.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateIds":
            suggest = "certificate_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendCredentialsContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendCredentialsContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendCredentialsContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization: Optional['outputs.BackendAuthorizationHeaderCredentialsResponse'] = None,
                 certificate: Optional[Sequence[str]] = None,
                 certificate_ids: Optional[Sequence[str]] = None,
                 header: Optional[Mapping[str, Sequence[str]]] = None,
                 query: Optional[Mapping[str, Sequence[str]]] = None):
        """
        Details of the Credentials used to connect to Backend.
        :param 'BackendAuthorizationHeaderCredentialsResponse' authorization: Authorization header authentication
        :param Sequence[str] certificate: List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
        :param Sequence[str] certificate_ids: List of Client Certificate Ids.
        :param Mapping[str, Sequence[str]] header: Header Parameter description.
        :param Mapping[str, Sequence[str]] query: Query Parameter description.
        """
        BackendCredentialsContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization=authorization,
            certificate=certificate,
            certificate_ids=certificate_ids,
            header=header,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization: Optional['outputs.BackendAuthorizationHeaderCredentialsResponse'] = None,
             certificate: Optional[Sequence[str]] = None,
             certificate_ids: Optional[Sequence[str]] = None,
             header: Optional[Mapping[str, Sequence[str]]] = None,
             query: Optional[Mapping[str, Sequence[str]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'certificateIds' in kwargs:
            certificate_ids = kwargs['certificateIds']

        if authorization is not None:
            _setter("authorization", authorization)
        if certificate is not None:
            _setter("certificate", certificate)
        if certificate_ids is not None:
            _setter("certificate_ids", certificate_ids)
        if header is not None:
            _setter("header", header)
        if query is not None:
            _setter("query", query)

    @property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.BackendAuthorizationHeaderCredentialsResponse']:
        """
        Authorization header authentication
        """
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter
    def certificate(self) -> Optional[Sequence[str]]:
        """
        List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Optional[Sequence[str]]:
        """
        List of Client Certificate Ids.
        """
        return pulumi.get(self, "certificate_ids")

    @property
    @pulumi.getter
    def header(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        Header Parameter description.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def query(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        Query Parameter description.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class BackendPropertiesResponse(dict):
    """
    Properties specific to the Backend Type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceFabricCluster":
            suggest = "service_fabric_cluster"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_fabric_cluster: Optional['outputs.BackendServiceFabricClusterPropertiesResponse'] = None):
        """
        Properties specific to the Backend Type.
        :param 'BackendServiceFabricClusterPropertiesResponse' service_fabric_cluster: Backend Service Fabric Cluster Properties
        """
        BackendPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_fabric_cluster=service_fabric_cluster,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_fabric_cluster: Optional['outputs.BackendServiceFabricClusterPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'serviceFabricCluster' in kwargs:
            service_fabric_cluster = kwargs['serviceFabricCluster']

        if service_fabric_cluster is not None:
            _setter("service_fabric_cluster", service_fabric_cluster)

    @property
    @pulumi.getter(name="serviceFabricCluster")
    def service_fabric_cluster(self) -> Optional['outputs.BackendServiceFabricClusterPropertiesResponse']:
        """
        Backend Service Fabric Cluster Properties
        """
        return pulumi.get(self, "service_fabric_cluster")


@pulumi.output_type
class BackendProxyContractResponse(dict):
    """
    Details of the Backend WebProxy Server to use in the Request to Backend.
    """
    def __init__(__self__, *,
                 url: str,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Details of the Backend WebProxy Server to use in the Request to Backend.
        :param str url: WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all fragments and query strings.
        :param str password: Password to connect to the WebProxy Server
        :param str username: Username to connect to the WebProxy server
        """
        BackendProxyContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: str,
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("url", url)
        if password is not None:
            _setter("password", password)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all fragments and query strings.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password to connect to the WebProxy Server
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to connect to the WebProxy server
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class BackendServiceFabricClusterPropertiesResponse(dict):
    """
    Properties of the Service Fabric Type Backend.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementEndpoints":
            suggest = "management_endpoints"
        elif key == "clientCertificateId":
            suggest = "client_certificate_id"
        elif key == "clientCertificatethumbprint":
            suggest = "client_certificatethumbprint"
        elif key == "maxPartitionResolutionRetries":
            suggest = "max_partition_resolution_retries"
        elif key == "serverCertificateThumbprints":
            suggest = "server_certificate_thumbprints"
        elif key == "serverX509Names":
            suggest = "server_x509_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendServiceFabricClusterPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendServiceFabricClusterPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendServiceFabricClusterPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_endpoints: Sequence[str],
                 client_certificate_id: Optional[str] = None,
                 client_certificatethumbprint: Optional[str] = None,
                 max_partition_resolution_retries: Optional[int] = None,
                 server_certificate_thumbprints: Optional[Sequence[str]] = None,
                 server_x509_names: Optional[Sequence['outputs.X509CertificateNameResponse']] = None):
        """
        Properties of the Service Fabric Type Backend.
        :param Sequence[str] management_endpoints: The cluster management endpoint.
        :param str client_certificate_id: The client certificate id for the management endpoint.
        :param str client_certificatethumbprint: The client certificate thumbprint for the management endpoint. Will be ignored if certificatesIds are provided
        :param int max_partition_resolution_retries: Maximum number of retries while attempting resolve the partition.
        :param Sequence[str] server_certificate_thumbprints: Thumbprints of certificates cluster management service uses for tls communication
        :param Sequence['X509CertificateNameResponse'] server_x509_names: Server X509 Certificate Names Collection
        """
        BackendServiceFabricClusterPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            management_endpoints=management_endpoints,
            client_certificate_id=client_certificate_id,
            client_certificatethumbprint=client_certificatethumbprint,
            max_partition_resolution_retries=max_partition_resolution_retries,
            server_certificate_thumbprints=server_certificate_thumbprints,
            server_x509_names=server_x509_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             management_endpoints: Sequence[str],
             client_certificate_id: Optional[str] = None,
             client_certificatethumbprint: Optional[str] = None,
             max_partition_resolution_retries: Optional[int] = None,
             server_certificate_thumbprints: Optional[Sequence[str]] = None,
             server_x509_names: Optional[Sequence['outputs.X509CertificateNameResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'managementEndpoints' in kwargs:
            management_endpoints = kwargs['managementEndpoints']
        if 'clientCertificateId' in kwargs:
            client_certificate_id = kwargs['clientCertificateId']
        if 'clientCertificatethumbprint' in kwargs:
            client_certificatethumbprint = kwargs['clientCertificatethumbprint']
        if 'maxPartitionResolutionRetries' in kwargs:
            max_partition_resolution_retries = kwargs['maxPartitionResolutionRetries']
        if 'serverCertificateThumbprints' in kwargs:
            server_certificate_thumbprints = kwargs['serverCertificateThumbprints']
        if 'serverX509Names' in kwargs:
            server_x509_names = kwargs['serverX509Names']

        _setter("management_endpoints", management_endpoints)
        if client_certificate_id is not None:
            _setter("client_certificate_id", client_certificate_id)
        if client_certificatethumbprint is not None:
            _setter("client_certificatethumbprint", client_certificatethumbprint)
        if max_partition_resolution_retries is not None:
            _setter("max_partition_resolution_retries", max_partition_resolution_retries)
        if server_certificate_thumbprints is not None:
            _setter("server_certificate_thumbprints", server_certificate_thumbprints)
        if server_x509_names is not None:
            _setter("server_x509_names", server_x509_names)

    @property
    @pulumi.getter(name="managementEndpoints")
    def management_endpoints(self) -> Sequence[str]:
        """
        The cluster management endpoint.
        """
        return pulumi.get(self, "management_endpoints")

    @property
    @pulumi.getter(name="clientCertificateId")
    def client_certificate_id(self) -> Optional[str]:
        """
        The client certificate id for the management endpoint.
        """
        return pulumi.get(self, "client_certificate_id")

    @property
    @pulumi.getter(name="clientCertificatethumbprint")
    def client_certificatethumbprint(self) -> Optional[str]:
        """
        The client certificate thumbprint for the management endpoint. Will be ignored if certificatesIds are provided
        """
        return pulumi.get(self, "client_certificatethumbprint")

    @property
    @pulumi.getter(name="maxPartitionResolutionRetries")
    def max_partition_resolution_retries(self) -> Optional[int]:
        """
        Maximum number of retries while attempting resolve the partition.
        """
        return pulumi.get(self, "max_partition_resolution_retries")

    @property
    @pulumi.getter(name="serverCertificateThumbprints")
    def server_certificate_thumbprints(self) -> Optional[Sequence[str]]:
        """
        Thumbprints of certificates cluster management service uses for tls communication
        """
        return pulumi.get(self, "server_certificate_thumbprints")

    @property
    @pulumi.getter(name="serverX509Names")
    def server_x509_names(self) -> Optional[Sequence['outputs.X509CertificateNameResponse']]:
        """
        Server X509 Certificate Names Collection
        """
        return pulumi.get(self, "server_x509_names")


@pulumi.output_type
class BackendTlsPropertiesResponse(dict):
    """
    Properties controlling TLS Certificate Validation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validateCertificateChain":
            suggest = "validate_certificate_chain"
        elif key == "validateCertificateName":
            suggest = "validate_certificate_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendTlsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendTlsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendTlsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 validate_certificate_chain: Optional[bool] = None,
                 validate_certificate_name: Optional[bool] = None):
        """
        Properties controlling TLS Certificate Validation.
        :param bool validate_certificate_chain: Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for this backend host.
        :param bool validate_certificate_name: Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for this backend host.
        """
        BackendTlsPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            validate_certificate_chain=validate_certificate_chain,
            validate_certificate_name=validate_certificate_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             validate_certificate_chain: Optional[bool] = None,
             validate_certificate_name: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'validateCertificateChain' in kwargs:
            validate_certificate_chain = kwargs['validateCertificateChain']
        if 'validateCertificateName' in kwargs:
            validate_certificate_name = kwargs['validateCertificateName']

        if validate_certificate_chain is None:
            validate_certificate_chain = True
        if validate_certificate_chain is not None:
            _setter("validate_certificate_chain", validate_certificate_chain)
        if validate_certificate_name is None:
            validate_certificate_name = True
        if validate_certificate_name is not None:
            _setter("validate_certificate_name", validate_certificate_name)

    @property
    @pulumi.getter(name="validateCertificateChain")
    def validate_certificate_chain(self) -> Optional[bool]:
        """
        Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for this backend host.
        """
        return pulumi.get(self, "validate_certificate_chain")

    @property
    @pulumi.getter(name="validateCertificateName")
    def validate_certificate_name(self) -> Optional[bool]:
        """
        Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for this backend host.
        """
        return pulumi.get(self, "validate_certificate_name")


@pulumi.output_type
class BodyDiagnosticSettingsResponse(dict):
    """
    Body logging settings.
    """
    def __init__(__self__, *,
                 bytes: Optional[int] = None):
        """
        Body logging settings.
        :param int bytes: Number of request body bytes to log.
        """
        BodyDiagnosticSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bytes=bytes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bytes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if bytes is not None:
            _setter("bytes", bytes)

    @property
    @pulumi.getter
    def bytes(self) -> Optional[int]:
        """
        Number of request body bytes to log.
        """
        return pulumi.get(self, "bytes")


@pulumi.output_type
class CertificateConfigurationResponse(dict):
    """
    Certificate configuration which consist of non-trusted intermediates and root certificates.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storeName":
            suggest = "store_name"
        elif key == "certificatePassword":
            suggest = "certificate_password"
        elif key == "encodedCertificate":
            suggest = "encoded_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 store_name: str,
                 certificate: Optional['outputs.CertificateInformationResponse'] = None,
                 certificate_password: Optional[str] = None,
                 encoded_certificate: Optional[str] = None):
        """
        Certificate configuration which consist of non-trusted intermediates and root certificates.
        :param str store_name: The System.Security.Cryptography.x509certificates.StoreName certificate store location. Only Root and CertificateAuthority are valid locations.
        :param 'CertificateInformationResponse' certificate: Certificate information.
        :param str certificate_password: Certificate Password.
        :param str encoded_certificate: Base64 Encoded certificate.
        """
        CertificateConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            store_name=store_name,
            certificate=certificate,
            certificate_password=certificate_password,
            encoded_certificate=encoded_certificate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             store_name: str,
             certificate: Optional['outputs.CertificateInformationResponse'] = None,
             certificate_password: Optional[str] = None,
             encoded_certificate: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'storeName' in kwargs:
            store_name = kwargs['storeName']
        if 'certificatePassword' in kwargs:
            certificate_password = kwargs['certificatePassword']
        if 'encodedCertificate' in kwargs:
            encoded_certificate = kwargs['encodedCertificate']

        _setter("store_name", store_name)
        if certificate is not None:
            _setter("certificate", certificate)
        if certificate_password is not None:
            _setter("certificate_password", certificate_password)
        if encoded_certificate is not None:
            _setter("encoded_certificate", encoded_certificate)

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        """
        The System.Security.Cryptography.x509certificates.StoreName certificate store location. Only Root and CertificateAuthority are valid locations.
        """
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.CertificateInformationResponse']:
        """
        Certificate information.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="certificatePassword")
    def certificate_password(self) -> Optional[str]:
        """
        Certificate Password.
        """
        return pulumi.get(self, "certificate_password")

    @property
    @pulumi.getter(name="encodedCertificate")
    def encoded_certificate(self) -> Optional[str]:
        """
        Base64 Encoded certificate.
        """
        return pulumi.get(self, "encoded_certificate")


@pulumi.output_type
class CertificateInformationResponse(dict):
    """
    SSL certificate information.
    """
    def __init__(__self__, *,
                 expiry: str,
                 subject: str,
                 thumbprint: str):
        """
        SSL certificate information.
        :param str expiry: Expiration date of the certificate. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
        :param str subject: Subject of the certificate.
        :param str thumbprint: Thumbprint of the certificate.
        """
        CertificateInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expiry=expiry,
            subject=subject,
            thumbprint=thumbprint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expiry: str,
             subject: str,
             thumbprint: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("expiry", expiry)
        _setter("subject", subject)
        _setter("thumbprint", thumbprint)

    @property
    @pulumi.getter
    def expiry(self) -> str:
        """
        Expiration date of the certificate. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
        """
        return pulumi.get(self, "expiry")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        Subject of the certificate.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        Thumbprint of the certificate.
        """
        return pulumi.get(self, "thumbprint")


@pulumi.output_type
class CircuitBreakerFailureConditionResponse(dict):
    """
    The trip conditions of the circuit breaker
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorReasons":
            suggest = "error_reasons"
        elif key == "statusCodeRanges":
            suggest = "status_code_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CircuitBreakerFailureConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CircuitBreakerFailureConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CircuitBreakerFailureConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[float] = None,
                 error_reasons: Optional[Sequence[str]] = None,
                 interval: Optional[str] = None,
                 percentage: Optional[float] = None,
                 status_code_ranges: Optional[Sequence['outputs.FailureStatusCodeRangeResponse']] = None):
        """
        The trip conditions of the circuit breaker
        :param float count: The threshold for opening the circuit.
        :param Sequence[str] error_reasons: The error reasons which are considered as failure.
        :param str interval: The interval during which the failures are counted.
        :param float percentage: The threshold for opening the circuit.
        :param Sequence['FailureStatusCodeRangeResponse'] status_code_ranges: The status code ranges which are considered as failure.
        """
        CircuitBreakerFailureConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            error_reasons=error_reasons,
            interval=interval,
            percentage=percentage,
            status_code_ranges=status_code_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[float] = None,
             error_reasons: Optional[Sequence[str]] = None,
             interval: Optional[str] = None,
             percentage: Optional[float] = None,
             status_code_ranges: Optional[Sequence['outputs.FailureStatusCodeRangeResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'errorReasons' in kwargs:
            error_reasons = kwargs['errorReasons']
        if 'statusCodeRanges' in kwargs:
            status_code_ranges = kwargs['statusCodeRanges']

        if count is not None:
            _setter("count", count)
        if error_reasons is not None:
            _setter("error_reasons", error_reasons)
        if interval is not None:
            _setter("interval", interval)
        if percentage is not None:
            _setter("percentage", percentage)
        if status_code_ranges is not None:
            _setter("status_code_ranges", status_code_ranges)

    @property
    @pulumi.getter
    def count(self) -> Optional[float]:
        """
        The threshold for opening the circuit.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="errorReasons")
    def error_reasons(self) -> Optional[Sequence[str]]:
        """
        The error reasons which are considered as failure.
        """
        return pulumi.get(self, "error_reasons")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        The interval during which the failures are counted.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        The threshold for opening the circuit.
        """
        return pulumi.get(self, "percentage")

    @property
    @pulumi.getter(name="statusCodeRanges")
    def status_code_ranges(self) -> Optional[Sequence['outputs.FailureStatusCodeRangeResponse']]:
        """
        The status code ranges which are considered as failure.
        """
        return pulumi.get(self, "status_code_ranges")


@pulumi.output_type
class CircuitBreakerRuleResponse(dict):
    """
    Rule configuration to trip the backend.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureCondition":
            suggest = "failure_condition"
        elif key == "tripDuration":
            suggest = "trip_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CircuitBreakerRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CircuitBreakerRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CircuitBreakerRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_condition: Optional['outputs.CircuitBreakerFailureConditionResponse'] = None,
                 name: Optional[str] = None,
                 trip_duration: Optional[str] = None):
        """
        Rule configuration to trip the backend.
        :param 'CircuitBreakerFailureConditionResponse' failure_condition: The conditions for tripping the circuit breaker.
        :param str name: The rule name.
        :param str trip_duration: The duration for which the circuit will be tripped.
        """
        CircuitBreakerRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_condition=failure_condition,
            name=name,
            trip_duration=trip_duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_condition: Optional['outputs.CircuitBreakerFailureConditionResponse'] = None,
             name: Optional[str] = None,
             trip_duration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'failureCondition' in kwargs:
            failure_condition = kwargs['failureCondition']
        if 'tripDuration' in kwargs:
            trip_duration = kwargs['tripDuration']

        if failure_condition is not None:
            _setter("failure_condition", failure_condition)
        if name is not None:
            _setter("name", name)
        if trip_duration is not None:
            _setter("trip_duration", trip_duration)

    @property
    @pulumi.getter(name="failureCondition")
    def failure_condition(self) -> Optional['outputs.CircuitBreakerFailureConditionResponse']:
        """
        The conditions for tripping the circuit breaker.
        """
        return pulumi.get(self, "failure_condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The rule name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tripDuration")
    def trip_duration(self) -> Optional[str]:
        """
        The duration for which the circuit will be tripped.
        """
        return pulumi.get(self, "trip_duration")


@pulumi.output_type
class DataMaskingEntityResponse(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str mode: Data masking mode.
        :param str value: The name of an entity to mask (e.g. a name of a header or a query parameter).
        """
        DataMaskingEntityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if mode is not None:
            _setter("mode", mode)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Data masking mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The name of an entity to mask (e.g. a name of a header or a query parameter).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DataMaskingResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParams":
            suggest = "query_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataMaskingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataMaskingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataMaskingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.DataMaskingEntityResponse']] = None,
                 query_params: Optional[Sequence['outputs.DataMaskingEntityResponse']] = None):
        """
        :param Sequence['DataMaskingEntityResponse'] headers: Masking settings for headers
        :param Sequence['DataMaskingEntityResponse'] query_params: Masking settings for Url query parameters
        """
        DataMaskingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            query_params=query_params,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Optional[Sequence['outputs.DataMaskingEntityResponse']] = None,
             query_params: Optional[Sequence['outputs.DataMaskingEntityResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'queryParams' in kwargs:
            query_params = kwargs['queryParams']

        if headers is not None:
            _setter("headers", headers)
        if query_params is not None:
            _setter("query_params", query_params)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.DataMaskingEntityResponse']]:
        """
        Masking settings for headers
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[Sequence['outputs.DataMaskingEntityResponse']]:
        """
        Masking settings for Url query parameters
        """
        return pulumi.get(self, "query_params")


@pulumi.output_type
class EmailTemplateParametersContractPropertiesResponse(dict):
    """
    Email Template Parameter contract.
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 title: Optional[str] = None):
        """
        Email Template Parameter contract.
        :param str description: Template parameter description.
        :param str name: Template parameter name.
        :param str title: Template parameter title.
        """
        EmailTemplateParametersContractPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if description is not None:
            _setter("description", description)
        if name is not None:
            _setter("name", name)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Template parameter description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Template parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Template parameter title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class FailureStatusCodeRangeResponse(dict):
    """
    The failure http status code range
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The failure http status code range
        :param int max: The maximum http status code.
        :param int min: The minimum http status code.
        """
        FailureStatusCodeRangeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum http status code.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum http status code.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GroupContractPropertiesResponse(dict):
    """
    Group contract Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "builtIn":
            suggest = "built_in"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupContractPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupContractPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupContractPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 built_in: bool,
                 display_name: str,
                 description: Optional[str] = None,
                 external_id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Group contract Properties.
        :param bool built_in: true if the group is one of the three system groups (Administrators, Developers, or Guests); otherwise false.
        :param str display_name: Group name.
        :param str description: Group description. Can contain HTML formatting tags.
        :param str external_id: For external groups, this property contains the id of the group from the external identity provider, e.g. for Azure Active Directory `aad://<tenant>.onmicrosoft.com/groups/<group object id>`; otherwise the value is null.
        :param str type: Group type.
        """
        GroupContractPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            built_in=built_in,
            display_name=display_name,
            description=description,
            external_id=external_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             built_in: bool,
             display_name: str,
             description: Optional[str] = None,
             external_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'builtIn' in kwargs:
            built_in = kwargs['builtIn']
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if 'externalId' in kwargs:
            external_id = kwargs['externalId']

        _setter("built_in", built_in)
        _setter("display_name", display_name)
        if description is not None:
            _setter("description", description)
        if external_id is not None:
            _setter("external_id", external_id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="builtIn")
    def built_in(self) -> bool:
        """
        true if the group is one of the three system groups (Administrators, Developers, or Guests); otherwise false.
        """
        return pulumi.get(self, "built_in")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Group description. Can contain HTML formatting tags.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        For external groups, this property contains the id of the group from the external identity provider, e.g. for Azure Active Directory `aad://<tenant>.onmicrosoft.com/groups/<group object id>`; otherwise the value is null.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Group type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HostnameConfigurationResponse(dict):
    """
    Custom hostname configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "certificatePassword":
            suggest = "certificate_password"
        elif key == "certificateSource":
            suggest = "certificate_source"
        elif key == "certificateStatus":
            suggest = "certificate_status"
        elif key == "defaultSslBinding":
            suggest = "default_ssl_binding"
        elif key == "encodedCertificate":
            suggest = "encoded_certificate"
        elif key == "identityClientId":
            suggest = "identity_client_id"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "negotiateClientCertificate":
            suggest = "negotiate_client_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostnameConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostnameConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostnameConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: str,
                 type: str,
                 certificate: Optional['outputs.CertificateInformationResponse'] = None,
                 certificate_password: Optional[str] = None,
                 certificate_source: Optional[str] = None,
                 certificate_status: Optional[str] = None,
                 default_ssl_binding: Optional[bool] = None,
                 encoded_certificate: Optional[str] = None,
                 identity_client_id: Optional[str] = None,
                 key_vault_id: Optional[str] = None,
                 negotiate_client_certificate: Optional[bool] = None):
        """
        Custom hostname configuration.
        :param str host_name: Hostname to configure on the Api Management service.
        :param str type: Hostname type.
        :param 'CertificateInformationResponse' certificate: Certificate information.
        :param str certificate_password: Certificate Password.
        :param str certificate_source: Certificate Source.
        :param str certificate_status: Certificate Status.
        :param bool default_ssl_binding: Specify true to setup the certificate associated with this Hostname as the Default SSL Certificate. If a client does not send the SNI header, then this will be the certificate that will be challenged. The property is useful if a service has multiple custom hostname enabled and it needs to decide on the default ssl certificate. The setting only applied to gateway Hostname Type.
        :param str encoded_certificate: Base64 Encoded certificate.
        :param str identity_client_id: System or User Assigned Managed identity clientId as generated by Azure AD, which has GET access to the keyVault containing the SSL certificate.
        :param str key_vault_id: Url to the KeyVault Secret containing the Ssl Certificate. If absolute Url containing version is provided, auto-update of ssl certificate will not work. This requires Api Management service to be configured with aka.ms/apimmsi. The secret should be of type *application/x-pkcs12*
        :param bool negotiate_client_certificate: Specify true to always negotiate client certificate on the hostname. Default Value is false.
        """
        HostnameConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_name=host_name,
            type=type,
            certificate=certificate,
            certificate_password=certificate_password,
            certificate_source=certificate_source,
            certificate_status=certificate_status,
            default_ssl_binding=default_ssl_binding,
            encoded_certificate=encoded_certificate,
            identity_client_id=identity_client_id,
            key_vault_id=key_vault_id,
            negotiate_client_certificate=negotiate_client_certificate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_name: str,
             type: str,
             certificate: Optional['outputs.CertificateInformationResponse'] = None,
             certificate_password: Optional[str] = None,
             certificate_source: Optional[str] = None,
             certificate_status: Optional[str] = None,
             default_ssl_binding: Optional[bool] = None,
             encoded_certificate: Optional[str] = None,
             identity_client_id: Optional[str] = None,
             key_vault_id: Optional[str] = None,
             negotiate_client_certificate: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostName' in kwargs:
            host_name = kwargs['hostName']
        if 'certificatePassword' in kwargs:
            certificate_password = kwargs['certificatePassword']
        if 'certificateSource' in kwargs:
            certificate_source = kwargs['certificateSource']
        if 'certificateStatus' in kwargs:
            certificate_status = kwargs['certificateStatus']
        if 'defaultSslBinding' in kwargs:
            default_ssl_binding = kwargs['defaultSslBinding']
        if 'encodedCertificate' in kwargs:
            encoded_certificate = kwargs['encodedCertificate']
        if 'identityClientId' in kwargs:
            identity_client_id = kwargs['identityClientId']
        if 'keyVaultId' in kwargs:
            key_vault_id = kwargs['keyVaultId']
        if 'negotiateClientCertificate' in kwargs:
            negotiate_client_certificate = kwargs['negotiateClientCertificate']

        _setter("host_name", host_name)
        _setter("type", type)
        if certificate is not None:
            _setter("certificate", certificate)
        if certificate_password is not None:
            _setter("certificate_password", certificate_password)
        if certificate_source is not None:
            _setter("certificate_source", certificate_source)
        if certificate_status is not None:
            _setter("certificate_status", certificate_status)
        if default_ssl_binding is None:
            default_ssl_binding = False
        if default_ssl_binding is not None:
            _setter("default_ssl_binding", default_ssl_binding)
        if encoded_certificate is not None:
            _setter("encoded_certificate", encoded_certificate)
        if identity_client_id is not None:
            _setter("identity_client_id", identity_client_id)
        if key_vault_id is not None:
            _setter("key_vault_id", key_vault_id)
        if negotiate_client_certificate is None:
            negotiate_client_certificate = False
        if negotiate_client_certificate is not None:
            _setter("negotiate_client_certificate", negotiate_client_certificate)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        """
        Hostname to configure on the Api Management service.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Hostname type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def certificate(self) -> Optional['outputs.CertificateInformationResponse']:
        """
        Certificate information.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="certificatePassword")
    def certificate_password(self) -> Optional[str]:
        """
        Certificate Password.
        """
        return pulumi.get(self, "certificate_password")

    @property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> Optional[str]:
        """
        Certificate Source.
        """
        return pulumi.get(self, "certificate_source")

    @property
    @pulumi.getter(name="certificateStatus")
    def certificate_status(self) -> Optional[str]:
        """
        Certificate Status.
        """
        return pulumi.get(self, "certificate_status")

    @property
    @pulumi.getter(name="defaultSslBinding")
    def default_ssl_binding(self) -> Optional[bool]:
        """
        Specify true to setup the certificate associated with this Hostname as the Default SSL Certificate. If a client does not send the SNI header, then this will be the certificate that will be challenged. The property is useful if a service has multiple custom hostname enabled and it needs to decide on the default ssl certificate. The setting only applied to gateway Hostname Type.
        """
        return pulumi.get(self, "default_ssl_binding")

    @property
    @pulumi.getter(name="encodedCertificate")
    def encoded_certificate(self) -> Optional[str]:
        """
        Base64 Encoded certificate.
        """
        return pulumi.get(self, "encoded_certificate")

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[str]:
        """
        System or User Assigned Managed identity clientId as generated by Azure AD, which has GET access to the keyVault containing the SSL certificate.
        """
        return pulumi.get(self, "identity_client_id")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[str]:
        """
        Url to the KeyVault Secret containing the Ssl Certificate. If absolute Url containing version is provided, auto-update of ssl certificate will not work. This requires Api Management service to be configured with aka.ms/apimmsi. The secret should be of type *application/x-pkcs12*
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="negotiateClientCertificate")
    def negotiate_client_certificate(self) -> Optional[bool]:
        """
        Specify true to always negotiate client certificate on the hostname. Default Value is false.
        """
        return pulumi.get(self, "negotiate_client_certificate")


@pulumi.output_type
class HttpMessageDiagnosticResponse(dict):
    """
    Http message diagnostic settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataMasking":
            suggest = "data_masking"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpMessageDiagnosticResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpMessageDiagnosticResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpMessageDiagnosticResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional['outputs.BodyDiagnosticSettingsResponse'] = None,
                 data_masking: Optional['outputs.DataMaskingResponse'] = None,
                 headers: Optional[Sequence[str]] = None):
        """
        Http message diagnostic settings.
        :param 'BodyDiagnosticSettingsResponse' body: Body logging settings.
        :param 'DataMaskingResponse' data_masking: Data masking settings.
        :param Sequence[str] headers: Array of HTTP Headers to log.
        """
        HttpMessageDiagnosticResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body=body,
            data_masking=data_masking,
            headers=headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body: Optional['outputs.BodyDiagnosticSettingsResponse'] = None,
             data_masking: Optional['outputs.DataMaskingResponse'] = None,
             headers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataMasking' in kwargs:
            data_masking = kwargs['dataMasking']

        if body is not None:
            _setter("body", body)
        if data_masking is not None:
            _setter("data_masking", data_masking)
        if headers is not None:
            _setter("headers", headers)

    @property
    @pulumi.getter
    def body(self) -> Optional['outputs.BodyDiagnosticSettingsResponse']:
        """
        Body logging settings.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="dataMasking")
    def data_masking(self) -> Optional['outputs.DataMaskingResponse']:
        """
        Data masking settings.
        """
        return pulumi.get(self, "data_masking")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        """
        Array of HTTP Headers to log.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class KeyVaultContractPropertiesResponse(dict):
    """
    KeyVault contract details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityClientId":
            suggest = "identity_client_id"
        elif key == "lastStatus":
            suggest = "last_status"
        elif key == "secretIdentifier":
            suggest = "secret_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultContractPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultContractPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultContractPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_client_id: Optional[str] = None,
                 last_status: Optional['outputs.KeyVaultLastAccessStatusContractPropertiesResponse'] = None,
                 secret_identifier: Optional[str] = None):
        """
        KeyVault contract details.
        :param str identity_client_id: Null for SystemAssignedIdentity or Client Id for UserAssignedIdentity , which will be used to access key vault secret.
        :param 'KeyVaultLastAccessStatusContractPropertiesResponse' last_status: Last time sync and refresh status of secret from key vault.
        :param str secret_identifier: Key vault secret identifier for fetching secret. Providing a versioned secret will prevent auto-refresh. This requires API Management service to be configured with aka.ms/apimmsi
        """
        KeyVaultContractPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_client_id=identity_client_id,
            last_status=last_status,
            secret_identifier=secret_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_client_id: Optional[str] = None,
             last_status: Optional['outputs.KeyVaultLastAccessStatusContractPropertiesResponse'] = None,
             secret_identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'identityClientId' in kwargs:
            identity_client_id = kwargs['identityClientId']
        if 'lastStatus' in kwargs:
            last_status = kwargs['lastStatus']
        if 'secretIdentifier' in kwargs:
            secret_identifier = kwargs['secretIdentifier']

        if identity_client_id is not None:
            _setter("identity_client_id", identity_client_id)
        if last_status is not None:
            _setter("last_status", last_status)
        if secret_identifier is not None:
            _setter("secret_identifier", secret_identifier)

    @property
    @pulumi.getter(name="identityClientId")
    def identity_client_id(self) -> Optional[str]:
        """
        Null for SystemAssignedIdentity or Client Id for UserAssignedIdentity , which will be used to access key vault secret.
        """
        return pulumi.get(self, "identity_client_id")

    @property
    @pulumi.getter(name="lastStatus")
    def last_status(self) -> Optional['outputs.KeyVaultLastAccessStatusContractPropertiesResponse']:
        """
        Last time sync and refresh status of secret from key vault.
        """
        return pulumi.get(self, "last_status")

    @property
    @pulumi.getter(name="secretIdentifier")
    def secret_identifier(self) -> Optional[str]:
        """
        Key vault secret identifier for fetching secret. Providing a versioned secret will prevent auto-refresh. This requires API Management service to be configured with aka.ms/apimmsi
        """
        return pulumi.get(self, "secret_identifier")


@pulumi.output_type
class KeyVaultLastAccessStatusContractPropertiesResponse(dict):
    """
    Issue contract Update Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeStampUtc":
            suggest = "time_stamp_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultLastAccessStatusContractPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultLastAccessStatusContractPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultLastAccessStatusContractPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[str] = None,
                 message: Optional[str] = None,
                 time_stamp_utc: Optional[str] = None):
        """
        Issue contract Update Properties.
        :param str code: Last status code for sync and refresh of secret from key vault.
        :param str message: Details of the error else empty.
        :param str time_stamp_utc: Last time secret was accessed. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
        """
        KeyVaultLastAccessStatusContractPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            message=message,
            time_stamp_utc=time_stamp_utc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             message: Optional[str] = None,
             time_stamp_utc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'timeStampUtc' in kwargs:
            time_stamp_utc = kwargs['timeStampUtc']

        if code is not None:
            _setter("code", code)
        if message is not None:
            _setter("message", message)
        if time_stamp_utc is not None:
            _setter("time_stamp_utc", time_stamp_utc)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        Last status code for sync and refresh of secret from key vault.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Details of the error else empty.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="timeStampUtc")
    def time_stamp_utc(self) -> Optional[str]:
        """
        Last time secret was accessed. The date conforms to the following format: `yyyy-MM-ddTHH:mm:ssZ` as specified by the ISO 8601 standard.
        """
        return pulumi.get(self, "time_stamp_utc")


@pulumi.output_type
class OAuth2AuthenticationSettingsContractResponse(dict):
    """
    API OAuth2 Authentication settings details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationServerId":
            suggest = "authorization_server_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OAuth2AuthenticationSettingsContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OAuth2AuthenticationSettingsContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OAuth2AuthenticationSettingsContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_server_id: Optional[str] = None,
                 scope: Optional[str] = None):
        """
        API OAuth2 Authentication settings details.
        :param str authorization_server_id: OAuth authorization server identifier.
        :param str scope: operations scope.
        """
        OAuth2AuthenticationSettingsContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization_server_id=authorization_server_id,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization_server_id: Optional[str] = None,
             scope: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'authorizationServerId' in kwargs:
            authorization_server_id = kwargs['authorizationServerId']

        if authorization_server_id is not None:
            _setter("authorization_server_id", authorization_server_id)
        if scope is not None:
            _setter("scope", scope)

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[str]:
        """
        OAuth authorization server identifier.
        """
        return pulumi.get(self, "authorization_server_id")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        operations scope.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class OpenIdAuthenticationSettingsContractResponse(dict):
    """
    API OAuth2 Authentication settings details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bearerTokenSendingMethods":
            suggest = "bearer_token_sending_methods"
        elif key == "openidProviderId":
            suggest = "openid_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdAuthenticationSettingsContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdAuthenticationSettingsContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdAuthenticationSettingsContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bearer_token_sending_methods: Optional[Sequence[str]] = None,
                 openid_provider_id: Optional[str] = None):
        """
        API OAuth2 Authentication settings details.
        :param Sequence[str] bearer_token_sending_methods: How to send token to the server.
        :param str openid_provider_id: OAuth authorization server identifier.
        """
        OpenIdAuthenticationSettingsContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bearer_token_sending_methods=bearer_token_sending_methods,
            openid_provider_id=openid_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bearer_token_sending_methods: Optional[Sequence[str]] = None,
             openid_provider_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bearerTokenSendingMethods' in kwargs:
            bearer_token_sending_methods = kwargs['bearerTokenSendingMethods']
        if 'openidProviderId' in kwargs:
            openid_provider_id = kwargs['openidProviderId']

        if bearer_token_sending_methods is not None:
            _setter("bearer_token_sending_methods", bearer_token_sending_methods)
        if openid_provider_id is not None:
            _setter("openid_provider_id", openid_provider_id)

    @property
    @pulumi.getter(name="bearerTokenSendingMethods")
    def bearer_token_sending_methods(self) -> Optional[Sequence[str]]:
        """
        How to send token to the server.
        """
        return pulumi.get(self, "bearer_token_sending_methods")

    @property
    @pulumi.getter(name="openidProviderId")
    def openid_provider_id(self) -> Optional[str]:
        """
        OAuth authorization server identifier.
        """
        return pulumi.get(self, "openid_provider_id")


@pulumi.output_type
class ParameterContractResponse(dict):
    """
    Operation parameters details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "schemaId":
            suggest = "schema_id"
        elif key == "typeName":
            suggest = "type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ParameterContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ParameterContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ParameterContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 type: str,
                 default_value: Optional[str] = None,
                 description: Optional[str] = None,
                 examples: Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']] = None,
                 required: Optional[bool] = None,
                 schema_id: Optional[str] = None,
                 type_name: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        Operation parameters details.
        :param str name: Parameter name.
        :param str type: Parameter type.
        :param str default_value: Default parameter value.
        :param str description: Parameter description.
        :param Mapping[str, 'ParameterExampleContractResponse'] examples: Exampled defined for the parameter.
        :param bool required: Specifies whether parameter is required or not.
        :param str schema_id: Schema identifier.
        :param str type_name: Type name defined by the schema.
        :param Sequence[str] values: Parameter values.
        """
        ParameterContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            default_value=default_value,
            description=description,
            examples=examples,
            required=required,
            schema_id=schema_id,
            type_name=type_name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             type: str,
             default_value: Optional[str] = None,
             description: Optional[str] = None,
             examples: Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']] = None,
             required: Optional[bool] = None,
             schema_id: Optional[str] = None,
             type_name: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'defaultValue' in kwargs:
            default_value = kwargs['defaultValue']
        if 'schemaId' in kwargs:
            schema_id = kwargs['schemaId']
        if 'typeName' in kwargs:
            type_name = kwargs['typeName']

        _setter("name", name)
        _setter("type", type)
        if default_value is not None:
            _setter("default_value", default_value)
        if description is not None:
            _setter("description", description)
        if examples is not None:
            _setter("examples", examples)
        if required is not None:
            _setter("required", required)
        if schema_id is not None:
            _setter("schema_id", schema_id)
        if type_name is not None:
            _setter("type_name", type_name)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Parameter type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        """
        Default parameter value.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Parameter description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def examples(self) -> Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']]:
        """
        Exampled defined for the parameter.
        """
        return pulumi.get(self, "examples")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Specifies whether parameter is required or not.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[str]:
        """
        Schema identifier.
        """
        return pulumi.get(self, "schema_id")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[str]:
        """
        Type name defined by the schema.
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ParameterExampleContractResponse(dict):
    """
    Parameter example.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalValue":
            suggest = "external_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ParameterExampleContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ParameterExampleContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ParameterExampleContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 external_value: Optional[str] = None,
                 summary: Optional[str] = None,
                 value: Optional[Any] = None):
        """
        Parameter example.
        :param str description: Long description for the example
        :param str external_value: A URL that points to the literal example
        :param str summary: Short description for the example
        :param Any value: Example value. May be a primitive value, or an object.
        """
        ParameterExampleContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            external_value=external_value,
            summary=summary,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             external_value: Optional[str] = None,
             summary: Optional[str] = None,
             value: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'externalValue' in kwargs:
            external_value = kwargs['externalValue']

        if description is not None:
            _setter("description", description)
        if external_value is not None:
            _setter("external_value", external_value)
        if summary is not None:
            _setter("summary", summary)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Long description for the example
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="externalValue")
    def external_value(self) -> Optional[str]:
        """
        A URL that points to the literal example
        """
        return pulumi.get(self, "external_value")

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        """
        Short description for the example
        """
        return pulumi.get(self, "summary")

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        """
        Example value. May be a primitive value, or an object.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PipelineDiagnosticSettingsResponse(dict):
    """
    Diagnostic settings for incoming/outgoing HTTP messages to the Gateway.
    """
    def __init__(__self__, *,
                 request: Optional['outputs.HttpMessageDiagnosticResponse'] = None,
                 response: Optional['outputs.HttpMessageDiagnosticResponse'] = None):
        """
        Diagnostic settings for incoming/outgoing HTTP messages to the Gateway.
        :param 'HttpMessageDiagnosticResponse' request: Diagnostic settings for request.
        :param 'HttpMessageDiagnosticResponse' response: Diagnostic settings for response.
        """
        PipelineDiagnosticSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request=request,
            response=response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request: Optional['outputs.HttpMessageDiagnosticResponse'] = None,
             response: Optional['outputs.HttpMessageDiagnosticResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if request is not None:
            _setter("request", request)
        if response is not None:
            _setter("response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.HttpMessageDiagnosticResponse']:
        """
        Diagnostic settings for request.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.HttpMessageDiagnosticResponse']:
        """
        Diagnostic settings for response.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: str):
        """
        The Private Endpoint resource.
        :param str id: The ARM identifier for Private Endpoint
        """
        PrivateEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[str] = None,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param str description: The reason for approval/rejection of the connection.
        :param str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        PrivateLinkServiceConnectionStateResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions_required=actions_required,
            description=description,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions_required: Optional[str] = None,
             description: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'actionsRequired' in kwargs:
            actions_required = kwargs['actionsRequired']

        if actions_required is not None:
            _setter("actions_required", actions_required)
        if description is not None:
            _setter("description", description)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RemotePrivateEndpointConnectionWrapperResponse(dict):
    """
    Remote Private Endpoint Connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePrivateEndpointConnectionWrapperResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePrivateEndpointConnectionWrapperResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePrivateEndpointConnectionWrapperResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[str],
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_endpoint: Optional['outputs.ArmIdWrapperResponse'] = None,
                 type: Optional[str] = None):
        """
        Remote Private Endpoint Connection resource.
        :param Sequence[str] group_ids: All the Group ids.
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param str id: Private Endpoint connection resource id
        :param str name: Private Endpoint Connection Name
        :param 'ArmIdWrapperResponse' private_endpoint: The resource of private end point.
        :param str type: Private Endpoint Connection Resource Type
        """
        RemotePrivateEndpointConnectionWrapperResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_ids=group_ids,
            private_link_service_connection_state=private_link_service_connection_state,
            provisioning_state=provisioning_state,
            id=id,
            name=name,
            private_endpoint=private_endpoint,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_ids: Sequence[str],
             private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
             provisioning_state: str,
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_endpoint: Optional['outputs.ArmIdWrapperResponse'] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'groupIds' in kwargs:
            group_ids = kwargs['groupIds']
        if 'privateLinkServiceConnectionState' in kwargs:
            private_link_service_connection_state = kwargs['privateLinkServiceConnectionState']
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if 'privateEndpoint' in kwargs:
            private_endpoint = kwargs['privateEndpoint']

        _setter("group_ids", group_ids)
        _setter("private_link_service_connection_state", private_link_service_connection_state)
        _setter("provisioning_state", provisioning_state)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_endpoint is not None:
            _setter("private_endpoint", private_endpoint)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[str]:
        """
        All the Group ids.
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Private Endpoint connection resource id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Private Endpoint Connection Name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.ArmIdWrapperResponse']:
        """
        The resource of private end point.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Private Endpoint Connection Resource Type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RepresentationContractResponse(dict):
    """
    Operation request/response representation details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "formParameters":
            suggest = "form_parameters"
        elif key == "schemaId":
            suggest = "schema_id"
        elif key == "typeName":
            suggest = "type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RepresentationContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RepresentationContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RepresentationContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: str,
                 examples: Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']] = None,
                 form_parameters: Optional[Sequence['outputs.ParameterContractResponse']] = None,
                 schema_id: Optional[str] = None,
                 type_name: Optional[str] = None):
        """
        Operation request/response representation details.
        :param str content_type: Specifies a registered or custom content type for this representation, e.g. application/xml.
        :param Mapping[str, 'ParameterExampleContractResponse'] examples: Exampled defined for the representation.
        :param Sequence['ParameterContractResponse'] form_parameters: Collection of form parameters. Required if 'contentType' value is either 'application/x-www-form-urlencoded' or 'multipart/form-data'..
        :param str schema_id: Schema identifier. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
        :param str type_name: Type name defined by the schema. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
        """
        RepresentationContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_type=content_type,
            examples=examples,
            form_parameters=form_parameters,
            schema_id=schema_id,
            type_name=type_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_type: str,
             examples: Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']] = None,
             form_parameters: Optional[Sequence['outputs.ParameterContractResponse']] = None,
             schema_id: Optional[str] = None,
             type_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'contentType' in kwargs:
            content_type = kwargs['contentType']
        if 'formParameters' in kwargs:
            form_parameters = kwargs['formParameters']
        if 'schemaId' in kwargs:
            schema_id = kwargs['schemaId']
        if 'typeName' in kwargs:
            type_name = kwargs['typeName']

        _setter("content_type", content_type)
        if examples is not None:
            _setter("examples", examples)
        if form_parameters is not None:
            _setter("form_parameters", form_parameters)
        if schema_id is not None:
            _setter("schema_id", schema_id)
        if type_name is not None:
            _setter("type_name", type_name)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        Specifies a registered or custom content type for this representation, e.g. application/xml.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def examples(self) -> Optional[Mapping[str, 'outputs.ParameterExampleContractResponse']]:
        """
        Exampled defined for the representation.
        """
        return pulumi.get(self, "examples")

    @property
    @pulumi.getter(name="formParameters")
    def form_parameters(self) -> Optional[Sequence['outputs.ParameterContractResponse']]:
        """
        Collection of form parameters. Required if 'contentType' value is either 'application/x-www-form-urlencoded' or 'multipart/form-data'..
        """
        return pulumi.get(self, "form_parameters")

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[str]:
        """
        Schema identifier. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
        """
        return pulumi.get(self, "schema_id")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[str]:
        """
        Type name defined by the schema. Applicable only if 'contentType' value is neither 'application/x-www-form-urlencoded' nor 'multipart/form-data'.
        """
        return pulumi.get(self, "type_name")


@pulumi.output_type
class RequestContractResponse(dict):
    """
    Operation request details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryParameters":
            suggest = "query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 headers: Optional[Sequence['outputs.ParameterContractResponse']] = None,
                 query_parameters: Optional[Sequence['outputs.ParameterContractResponse']] = None,
                 representations: Optional[Sequence['outputs.RepresentationContractResponse']] = None):
        """
        Operation request details.
        :param str description: Operation request description.
        :param Sequence['ParameterContractResponse'] headers: Collection of operation request headers.
        :param Sequence['ParameterContractResponse'] query_parameters: Collection of operation request query parameters.
        :param Sequence['RepresentationContractResponse'] representations: Collection of operation request representations.
        """
        RequestContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            headers=headers,
            query_parameters=query_parameters,
            representations=representations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             headers: Optional[Sequence['outputs.ParameterContractResponse']] = None,
             query_parameters: Optional[Sequence['outputs.ParameterContractResponse']] = None,
             representations: Optional[Sequence['outputs.RepresentationContractResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']

        if description is not None:
            _setter("description", description)
        if headers is not None:
            _setter("headers", headers)
        if query_parameters is not None:
            _setter("query_parameters", query_parameters)
        if representations is not None:
            _setter("representations", representations)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Operation request description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.ParameterContractResponse']]:
        """
        Collection of operation request headers.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Sequence['outputs.ParameterContractResponse']]:
        """
        Collection of operation request query parameters.
        """
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter
    def representations(self) -> Optional[Sequence['outputs.RepresentationContractResponse']]:
        """
        Collection of operation request representations.
        """
        return pulumi.get(self, "representations")


@pulumi.output_type
class ResourceCollectionResponseValue(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        """
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        ResourceCollectionResponseValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("id", id)
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourceLocationDataContractResponse(dict):
    """
    Resource location data properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryOrRegion":
            suggest = "country_or_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceLocationDataContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceLocationDataContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceLocationDataContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 city: Optional[str] = None,
                 country_or_region: Optional[str] = None,
                 district: Optional[str] = None):
        """
        Resource location data properties.
        :param str name: A canonical name for the geographic or physical location.
        :param str city: The city or locality where the resource is located.
        :param str country_or_region: The country or region where the resource is located.
        :param str district: The district, state, or province where the resource is located.
        """
        ResourceLocationDataContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            city=city,
            country_or_region=country_or_region,
            district=district,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             city: Optional[str] = None,
             country_or_region: Optional[str] = None,
             district: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'countryOrRegion' in kwargs:
            country_or_region = kwargs['countryOrRegion']

        _setter("name", name)
        if city is not None:
            _setter("city", city)
        if country_or_region is not None:
            _setter("country_or_region", country_or_region)
        if district is not None:
            _setter("district", district)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A canonical name for the geographic or physical location.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        The city or locality where the resource is located.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter(name="countryOrRegion")
    def country_or_region(self) -> Optional[str]:
        """
        The country or region where the resource is located.
        """
        return pulumi.get(self, "country_or_region")

    @property
    @pulumi.getter
    def district(self) -> Optional[str]:
        """
        The district, state, or province where the resource is located.
        """
        return pulumi.get(self, "district")


@pulumi.output_type
class ResponseContractResponse(dict):
    """
    Operation response details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: int,
                 description: Optional[str] = None,
                 headers: Optional[Sequence['outputs.ParameterContractResponse']] = None,
                 representations: Optional[Sequence['outputs.RepresentationContractResponse']] = None):
        """
        Operation response details.
        :param int status_code: Operation response HTTP status code.
        :param str description: Operation response description.
        :param Sequence['ParameterContractResponse'] headers: Collection of operation response headers.
        :param Sequence['RepresentationContractResponse'] representations: Collection of operation response representations.
        """
        ResponseContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status_code=status_code,
            description=description,
            headers=headers,
            representations=representations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status_code: int,
             description: Optional[str] = None,
             headers: Optional[Sequence['outputs.ParameterContractResponse']] = None,
             representations: Optional[Sequence['outputs.RepresentationContractResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'statusCode' in kwargs:
            status_code = kwargs['statusCode']

        _setter("status_code", status_code)
        if description is not None:
            _setter("description", description)
        if headers is not None:
            _setter("headers", headers)
        if representations is not None:
            _setter("representations", representations)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        Operation response HTTP status code.
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Operation response description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.ParameterContractResponse']]:
        """
        Collection of operation response headers.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def representations(self) -> Optional[Sequence['outputs.RepresentationContractResponse']]:
        """
        Collection of operation response representations.
        """
        return pulumi.get(self, "representations")


@pulumi.output_type
class SamplingSettingsResponse(dict):
    """
    Sampling settings for Diagnostic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samplingType":
            suggest = "sampling_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SamplingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SamplingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SamplingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 percentage: Optional[float] = None,
                 sampling_type: Optional[str] = None):
        """
        Sampling settings for Diagnostic.
        :param float percentage: Rate of sampling for fixed-rate sampling.
        :param str sampling_type: Sampling type.
        """
        SamplingSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percentage=percentage,
            sampling_type=sampling_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percentage: Optional[float] = None,
             sampling_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'samplingType' in kwargs:
            sampling_type = kwargs['samplingType']

        if percentage is not None:
            _setter("percentage", percentage)
        if sampling_type is not None:
            _setter("sampling_type", sampling_type)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[float]:
        """
        Rate of sampling for fixed-rate sampling.
        """
        return pulumi.get(self, "percentage")

    @property
    @pulumi.getter(name="samplingType")
    def sampling_type(self) -> Optional[str]:
        """
        Sampling type.
        """
        return pulumi.get(self, "sampling_type")


@pulumi.output_type
class SubscriptionKeyParameterNamesContractResponse(dict):
    """
    Subscription key parameter names details.
    """
    def __init__(__self__, *,
                 header: Optional[str] = None,
                 query: Optional[str] = None):
        """
        Subscription key parameter names details.
        :param str header: Subscription key header name.
        :param str query: Subscription key query string parameter name.
        """
        SubscriptionKeyParameterNamesContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            header=header,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             header: Optional[str] = None,
             query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if header is not None:
            _setter("header", header)
        if query is not None:
            _setter("query", query)

    @property
    @pulumi.getter
    def header(self) -> Optional[str]:
        """
        Subscription key header name.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Subscription key query string parameter name.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TokenBodyParameterContractResponse(dict):
    """
    OAuth acquire token request body parameter (www-url-form-encoded).
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        OAuth acquire token request body parameter (www-url-form-encoded).
        :param str name: body parameter name.
        :param str value: body parameter value.
        """
        TokenBodyParameterContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        body parameter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        body parameter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class UserIdentityContractResponse(dict):
    """
    User identity details.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 provider: Optional[str] = None):
        """
        User identity details.
        :param str id: Identifier value within provider.
        :param str provider: Identity provider name.
        """
        UserIdentityContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            provider=provider,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             provider: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if provider is not None:
            _setter("provider", provider)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Identifier value within provider.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Identity provider name.
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class UserIdentityPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserIdentityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserIdentityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserIdentityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None,
                 principal_id: Optional[str] = None):
        """
        :param str client_id: The client id of user assigned identity.
        :param str principal_id: The principal id of user assigned identity.
        """
        UserIdentityPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            principal_id=principal_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             principal_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'principalId' in kwargs:
            principal_id = kwargs['principalId']

        if client_id is not None:
            _setter("client_id", client_id)
        if principal_id is not None:
            _setter("principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VirtualNetworkConfigurationResponse(dict):
    """
    Configuration of a virtual network to which API Management service is deployed.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetResourceId":
            suggest = "subnet_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnetname: str,
                 vnetid: str,
                 subnet_resource_id: Optional[str] = None):
        """
        Configuration of a virtual network to which API Management service is deployed.
        :param str subnetname: The name of the subnet.
        :param str vnetid: The virtual network ID. This is typically a GUID. Expect a null GUID by default.
        :param str subnet_resource_id: The full resource ID of a subnet in a virtual network to deploy the API Management service in.
        """
        VirtualNetworkConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnetname=subnetname,
            vnetid=vnetid,
            subnet_resource_id=subnet_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnetname: str,
             vnetid: str,
             subnet_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'subnetResourceId' in kwargs:
            subnet_resource_id = kwargs['subnetResourceId']

        _setter("subnetname", subnetname)
        _setter("vnetid", vnetid)
        if subnet_resource_id is not None:
            _setter("subnet_resource_id", subnet_resource_id)

    @property
    @pulumi.getter
    def subnetname(self) -> str:
        """
        The name of the subnet.
        """
        return pulumi.get(self, "subnetname")

    @property
    @pulumi.getter
    def vnetid(self) -> str:
        """
        The virtual network ID. This is typically a GUID. Expect a null GUID by default.
        """
        return pulumi.get(self, "vnetid")

    @property
    @pulumi.getter(name="subnetResourceId")
    def subnet_resource_id(self) -> Optional[str]:
        """
        The full resource ID of a subnet in a virtual network to deploy the API Management service in.
        """
        return pulumi.get(self, "subnet_resource_id")


@pulumi.output_type
class WikiDocumentationContractResponse(dict):
    """
    Wiki documentation details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentationId":
            suggest = "documentation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WikiDocumentationContractResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WikiDocumentationContractResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WikiDocumentationContractResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 documentation_id: Optional[str] = None):
        """
        Wiki documentation details.
        :param str documentation_id: Documentation Identifier
        """
        WikiDocumentationContractResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            documentation_id=documentation_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             documentation_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'documentationId' in kwargs:
            documentation_id = kwargs['documentationId']

        if documentation_id is not None:
            _setter("documentation_id", documentation_id)

    @property
    @pulumi.getter(name="documentationId")
    def documentation_id(self) -> Optional[str]:
        """
        Documentation Identifier
        """
        return pulumi.get(self, "documentation_id")


@pulumi.output_type
class X509CertificateNameResponse(dict):
    """
    Properties of server X509Names.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuerCertificateThumbprint":
            suggest = "issuer_certificate_thumbprint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in X509CertificateNameResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        X509CertificateNameResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        X509CertificateNameResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issuer_certificate_thumbprint: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Properties of server X509Names.
        :param str issuer_certificate_thumbprint: Thumbprint for the Issuer of the Certificate.
        :param str name: Common Name of the Certificate.
        """
        X509CertificateNameResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            issuer_certificate_thumbprint=issuer_certificate_thumbprint,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             issuer_certificate_thumbprint: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'issuerCertificateThumbprint' in kwargs:
            issuer_certificate_thumbprint = kwargs['issuerCertificateThumbprint']

        if issuer_certificate_thumbprint is not None:
            _setter("issuer_certificate_thumbprint", issuer_certificate_thumbprint)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="issuerCertificateThumbprint")
    def issuer_certificate_thumbprint(self) -> Optional[str]:
        """
        Thumbprint for the Issuer of the Certificate.
        """
        return pulumi.get(self, "issuer_certificate_thumbprint")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Common Name of the Certificate.
        """
        return pulumi.get(self, "name")


