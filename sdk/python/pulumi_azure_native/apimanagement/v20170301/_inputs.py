# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AdditionalLocationArgs',
    'AdditionalLocationArgsDict',
    'ApiCreateOrUpdatePropertiesWsdlSelectorArgs',
    'ApiCreateOrUpdatePropertiesWsdlSelectorArgsDict',
    'ApiManagementServiceIdentityArgs',
    'ApiManagementServiceIdentityArgsDict',
    'ApiManagementServiceSkuPropertiesArgs',
    'ApiManagementServiceSkuPropertiesArgsDict',
    'ApiVersionSetContractArgs',
    'ApiVersionSetContractArgsDict',
    'AuthenticationSettingsContractArgs',
    'AuthenticationSettingsContractArgsDict',
    'CertificateConfigurationArgs',
    'CertificateConfigurationArgsDict',
    'HostnameConfigurationArgs',
    'HostnameConfigurationArgsDict',
    'LoggerSamplingContractArgs',
    'LoggerSamplingContractArgsDict',
    'OAuth2AuthenticationSettingsContractArgs',
    'OAuth2AuthenticationSettingsContractArgsDict',
    'SubscriptionKeyParameterNamesContractArgs',
    'SubscriptionKeyParameterNamesContractArgsDict',
    'VirtualNetworkConfigurationArgs',
    'VirtualNetworkConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class AdditionalLocationArgsDict(TypedDict):
        """
        Description of an additional API Management resource location.
        """
        location: pulumi.Input[str]
        """
        The location name of the additional region among Azure Data center regions.
        """
        sku: pulumi.Input['ApiManagementServiceSkuPropertiesArgsDict']
        """
        SKU properties of the API Management service.
        """
        virtual_network_configuration: NotRequired[pulumi.Input['VirtualNetworkConfigurationArgsDict']]
        """
        Virtual network configuration for the location.
        """
elif False:
    AdditionalLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdditionalLocationArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[str],
                 sku: pulumi.Input['ApiManagementServiceSkuPropertiesArgs'],
                 virtual_network_configuration: Optional[pulumi.Input['VirtualNetworkConfigurationArgs']] = None):
        """
        Description of an additional API Management resource location.
        :param pulumi.Input[str] location: The location name of the additional region among Azure Data center regions.
        :param pulumi.Input['ApiManagementServiceSkuPropertiesArgs'] sku: SKU properties of the API Management service.
        :param pulumi.Input['VirtualNetworkConfigurationArgs'] virtual_network_configuration: Virtual network configuration for the location.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "sku", sku)
        if virtual_network_configuration is not None:
            pulumi.set(__self__, "virtual_network_configuration", virtual_network_configuration)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[str]:
        """
        The location name of the additional region among Azure Data center regions.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input['ApiManagementServiceSkuPropertiesArgs']:
        """
        SKU properties of the API Management service.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input['ApiManagementServiceSkuPropertiesArgs']):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter(name="virtualNetworkConfiguration")
    def virtual_network_configuration(self) -> Optional[pulumi.Input['VirtualNetworkConfigurationArgs']]:
        """
        Virtual network configuration for the location.
        """
        return pulumi.get(self, "virtual_network_configuration")

    @virtual_network_configuration.setter
    def virtual_network_configuration(self, value: Optional[pulumi.Input['VirtualNetworkConfigurationArgs']]):
        pulumi.set(self, "virtual_network_configuration", value)


if not MYPY:
    class ApiCreateOrUpdatePropertiesWsdlSelectorArgsDict(TypedDict):
        """
        Criteria to limit import of WSDL to a subset of the document.
        """
        wsdl_endpoint_name: NotRequired[pulumi.Input[str]]
        """
        Name of endpoint(port) to import from WSDL
        """
        wsdl_service_name: NotRequired[pulumi.Input[str]]
        """
        Name of service to import from WSDL
        """
elif False:
    ApiCreateOrUpdatePropertiesWsdlSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiCreateOrUpdatePropertiesWsdlSelectorArgs:
    def __init__(__self__, *,
                 wsdl_endpoint_name: Optional[pulumi.Input[str]] = None,
                 wsdl_service_name: Optional[pulumi.Input[str]] = None):
        """
        Criteria to limit import of WSDL to a subset of the document.
        :param pulumi.Input[str] wsdl_endpoint_name: Name of endpoint(port) to import from WSDL
        :param pulumi.Input[str] wsdl_service_name: Name of service to import from WSDL
        """
        if wsdl_endpoint_name is not None:
            pulumi.set(__self__, "wsdl_endpoint_name", wsdl_endpoint_name)
        if wsdl_service_name is not None:
            pulumi.set(__self__, "wsdl_service_name", wsdl_service_name)

    @property
    @pulumi.getter(name="wsdlEndpointName")
    def wsdl_endpoint_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of endpoint(port) to import from WSDL
        """
        return pulumi.get(self, "wsdl_endpoint_name")

    @wsdl_endpoint_name.setter
    def wsdl_endpoint_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wsdl_endpoint_name", value)

    @property
    @pulumi.getter(name="wsdlServiceName")
    def wsdl_service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of service to import from WSDL
        """
        return pulumi.get(self, "wsdl_service_name")

    @wsdl_service_name.setter
    def wsdl_service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wsdl_service_name", value)


if not MYPY:
    class ApiManagementServiceIdentityArgsDict(TypedDict):
        """
        Identity properties of the Api Management service resource.
        """
        type: pulumi.Input[Union[str, 'ApimIdentityType']]
        """
        The identity type. Currently the only supported type is 'SystemAssigned'.
        """
elif False:
    ApiManagementServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiManagementServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ApimIdentityType']]):
        """
        Identity properties of the Api Management service resource.
        :param pulumi.Input[Union[str, 'ApimIdentityType']] type: The identity type. Currently the only supported type is 'SystemAssigned'.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ApimIdentityType']]:
        """
        The identity type. Currently the only supported type is 'SystemAssigned'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ApimIdentityType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApiManagementServiceSkuPropertiesArgsDict(TypedDict):
        """
        API Management service resource SKU properties.
        """
        name: pulumi.Input[Union[str, 'SkuType']]
        """
        Name of the Sku.
        """
        capacity: NotRequired[pulumi.Input[int]]
        """
        Capacity of the SKU (number of deployed units of the SKU). The default value is 1.
        """
elif False:
    ApiManagementServiceSkuPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiManagementServiceSkuPropertiesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[Union[str, 'SkuType']],
                 capacity: Optional[pulumi.Input[int]] = None):
        """
        API Management service resource SKU properties.
        :param pulumi.Input[Union[str, 'SkuType']] name: Name of the Sku.
        :param pulumi.Input[int] capacity: Capacity of the SKU (number of deployed units of the SKU). The default value is 1.
        """
        pulumi.set(__self__, "name", name)
        if capacity is None:
            capacity = 1
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[Union[str, 'SkuType']]:
        """
        Name of the Sku.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[Union[str, 'SkuType']]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Capacity of the SKU (number of deployed units of the SKU). The default value is 1.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)


if not MYPY:
    class ApiVersionSetContractArgsDict(TypedDict):
        """
        Api Version Set Contract details.
        """
        display_name: pulumi.Input[str]
        """
        Name of API Version Set
        """
        versioning_scheme: pulumi.Input[Union[str, 'VersioningScheme']]
        """
        An value that determines where the API Version identifier will be located in a HTTP request.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of API Version Set.
        """
        version_header_name: NotRequired[pulumi.Input[str]]
        """
        Name of HTTP header parameter that indicates the API Version if versioningScheme is set to `header`.
        """
        version_query_name: NotRequired[pulumi.Input[str]]
        """
        Name of query parameter that indicates the API Version if versioningScheme is set to `query`.
        """
elif False:
    ApiVersionSetContractArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiVersionSetContractArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[str],
                 versioning_scheme: pulumi.Input[Union[str, 'VersioningScheme']],
                 description: Optional[pulumi.Input[str]] = None,
                 version_header_name: Optional[pulumi.Input[str]] = None,
                 version_query_name: Optional[pulumi.Input[str]] = None):
        """
        Api Version Set Contract details.
        :param pulumi.Input[str] display_name: Name of API Version Set
        :param pulumi.Input[Union[str, 'VersioningScheme']] versioning_scheme: An value that determines where the API Version identifier will be located in a HTTP request.
        :param pulumi.Input[str] description: Description of API Version Set.
        :param pulumi.Input[str] version_header_name: Name of HTTP header parameter that indicates the API Version if versioningScheme is set to `header`.
        :param pulumi.Input[str] version_query_name: Name of query parameter that indicates the API Version if versioningScheme is set to `query`.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "versioning_scheme", versioning_scheme)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if version_header_name is not None:
            pulumi.set(__self__, "version_header_name", version_header_name)
        if version_query_name is not None:
            pulumi.set(__self__, "version_query_name", version_query_name)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        Name of API Version Set
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="versioningScheme")
    def versioning_scheme(self) -> pulumi.Input[Union[str, 'VersioningScheme']]:
        """
        An value that determines where the API Version identifier will be located in a HTTP request.
        """
        return pulumi.get(self, "versioning_scheme")

    @versioning_scheme.setter
    def versioning_scheme(self, value: pulumi.Input[Union[str, 'VersioningScheme']]):
        pulumi.set(self, "versioning_scheme", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of API Version Set.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="versionHeaderName")
    def version_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of HTTP header parameter that indicates the API Version if versioningScheme is set to `header`.
        """
        return pulumi.get(self, "version_header_name")

    @version_header_name.setter
    def version_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_header_name", value)

    @property
    @pulumi.getter(name="versionQueryName")
    def version_query_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of query parameter that indicates the API Version if versioningScheme is set to `query`.
        """
        return pulumi.get(self, "version_query_name")

    @version_query_name.setter
    def version_query_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_query_name", value)


if not MYPY:
    class AuthenticationSettingsContractArgsDict(TypedDict):
        """
        API Authentication Settings.
        """
        o_auth2: NotRequired[pulumi.Input['OAuth2AuthenticationSettingsContractArgsDict']]
        """
        OAuth2 Authentication settings
        """
elif False:
    AuthenticationSettingsContractArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationSettingsContractArgs:
    def __init__(__self__, *,
                 o_auth2: Optional[pulumi.Input['OAuth2AuthenticationSettingsContractArgs']] = None):
        """
        API Authentication Settings.
        :param pulumi.Input['OAuth2AuthenticationSettingsContractArgs'] o_auth2: OAuth2 Authentication settings
        """
        if o_auth2 is not None:
            pulumi.set(__self__, "o_auth2", o_auth2)

    @property
    @pulumi.getter(name="oAuth2")
    def o_auth2(self) -> Optional[pulumi.Input['OAuth2AuthenticationSettingsContractArgs']]:
        """
        OAuth2 Authentication settings
        """
        return pulumi.get(self, "o_auth2")

    @o_auth2.setter
    def o_auth2(self, value: Optional[pulumi.Input['OAuth2AuthenticationSettingsContractArgs']]):
        pulumi.set(self, "o_auth2", value)


if not MYPY:
    class CertificateConfigurationArgsDict(TypedDict):
        """
        Certificate configuration which consist of non-trusted intermediates and root certificates.
        """
        store_name: pulumi.Input[str]
        """
        The local certificate store location. Only Root and CertificateAuthority are valid locations.
        """
        certificate_password: NotRequired[pulumi.Input[str]]
        """
        Certificate Password.
        """
        encoded_certificate: NotRequired[pulumi.Input[str]]
        """
        Base64 Encoded certificate.
        """
elif False:
    CertificateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateConfigurationArgs:
    def __init__(__self__, *,
                 store_name: pulumi.Input[str],
                 certificate_password: Optional[pulumi.Input[str]] = None,
                 encoded_certificate: Optional[pulumi.Input[str]] = None):
        """
        Certificate configuration which consist of non-trusted intermediates and root certificates.
        :param pulumi.Input[str] store_name: The local certificate store location. Only Root and CertificateAuthority are valid locations.
        :param pulumi.Input[str] certificate_password: Certificate Password.
        :param pulumi.Input[str] encoded_certificate: Base64 Encoded certificate.
        """
        pulumi.set(__self__, "store_name", store_name)
        if certificate_password is not None:
            pulumi.set(__self__, "certificate_password", certificate_password)
        if encoded_certificate is not None:
            pulumi.set(__self__, "encoded_certificate", encoded_certificate)

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> pulumi.Input[str]:
        """
        The local certificate store location. Only Root and CertificateAuthority are valid locations.
        """
        return pulumi.get(self, "store_name")

    @store_name.setter
    def store_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "store_name", value)

    @property
    @pulumi.getter(name="certificatePassword")
    def certificate_password(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate Password.
        """
        return pulumi.get(self, "certificate_password")

    @certificate_password.setter
    def certificate_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_password", value)

    @property
    @pulumi.getter(name="encodedCertificate")
    def encoded_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 Encoded certificate.
        """
        return pulumi.get(self, "encoded_certificate")

    @encoded_certificate.setter
    def encoded_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoded_certificate", value)


if not MYPY:
    class HostnameConfigurationArgsDict(TypedDict):
        """
        Custom hostname configuration.
        """
        host_name: pulumi.Input[str]
        """
        Hostname to configure on the Api Management service.
        """
        type: pulumi.Input['HostnameType']
        """
        Hostname type.
        """
        certificate_password: NotRequired[pulumi.Input[str]]
        """
        Certificate Password.
        """
        default_ssl_binding: NotRequired[pulumi.Input[bool]]
        """
        Specify true to setup the certificate associated with this Hostname as the Default SSL Certificate. If a client does not send the SNI header, then this will be the certificate that will be challenged. The property is useful if a service has multiple custom hostname enabled and it needs to decide on the default ssl certificate. The setting only applied to Proxy Hostname Type.
        """
        encoded_certificate: NotRequired[pulumi.Input[str]]
        """
        Base64 Encoded certificate.
        """
        key_vault_id: NotRequired[pulumi.Input[str]]
        """
        Url to the KeyVault Secret containing the Ssl Certificate. If absolute Url containing version is provided, auto-update of ssl certificate will not work. This requires Api Management service to be configured with MSI. The secret should be of type *application/x-pkcs12*
        """
        negotiate_client_certificate: NotRequired[pulumi.Input[bool]]
        """
        Specify true to always negotiate client certificate on the hostname. Default Value is false.
        """
elif False:
    HostnameConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostnameConfigurationArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[str],
                 type: pulumi.Input['HostnameType'],
                 certificate_password: Optional[pulumi.Input[str]] = None,
                 default_ssl_binding: Optional[pulumi.Input[bool]] = None,
                 encoded_certificate: Optional[pulumi.Input[str]] = None,
                 key_vault_id: Optional[pulumi.Input[str]] = None,
                 negotiate_client_certificate: Optional[pulumi.Input[bool]] = None):
        """
        Custom hostname configuration.
        :param pulumi.Input[str] host_name: Hostname to configure on the Api Management service.
        :param pulumi.Input['HostnameType'] type: Hostname type.
        :param pulumi.Input[str] certificate_password: Certificate Password.
        :param pulumi.Input[bool] default_ssl_binding: Specify true to setup the certificate associated with this Hostname as the Default SSL Certificate. If a client does not send the SNI header, then this will be the certificate that will be challenged. The property is useful if a service has multiple custom hostname enabled and it needs to decide on the default ssl certificate. The setting only applied to Proxy Hostname Type.
        :param pulumi.Input[str] encoded_certificate: Base64 Encoded certificate.
        :param pulumi.Input[str] key_vault_id: Url to the KeyVault Secret containing the Ssl Certificate. If absolute Url containing version is provided, auto-update of ssl certificate will not work. This requires Api Management service to be configured with MSI. The secret should be of type *application/x-pkcs12*
        :param pulumi.Input[bool] negotiate_client_certificate: Specify true to always negotiate client certificate on the hostname. Default Value is false.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "type", type)
        if certificate_password is not None:
            pulumi.set(__self__, "certificate_password", certificate_password)
        if default_ssl_binding is None:
            default_ssl_binding = False
        if default_ssl_binding is not None:
            pulumi.set(__self__, "default_ssl_binding", default_ssl_binding)
        if encoded_certificate is not None:
            pulumi.set(__self__, "encoded_certificate", encoded_certificate)
        if key_vault_id is not None:
            pulumi.set(__self__, "key_vault_id", key_vault_id)
        if negotiate_client_certificate is None:
            negotiate_client_certificate = False
        if negotiate_client_certificate is not None:
            pulumi.set(__self__, "negotiate_client_certificate", negotiate_client_certificate)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[str]:
        """
        Hostname to configure on the Api Management service.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['HostnameType']:
        """
        Hostname type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['HostnameType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="certificatePassword")
    def certificate_password(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate Password.
        """
        return pulumi.get(self, "certificate_password")

    @certificate_password.setter
    def certificate_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_password", value)

    @property
    @pulumi.getter(name="defaultSslBinding")
    def default_ssl_binding(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify true to setup the certificate associated with this Hostname as the Default SSL Certificate. If a client does not send the SNI header, then this will be the certificate that will be challenged. The property is useful if a service has multiple custom hostname enabled and it needs to decide on the default ssl certificate. The setting only applied to Proxy Hostname Type.
        """
        return pulumi.get(self, "default_ssl_binding")

    @default_ssl_binding.setter
    def default_ssl_binding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "default_ssl_binding", value)

    @property
    @pulumi.getter(name="encodedCertificate")
    def encoded_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 Encoded certificate.
        """
        return pulumi.get(self, "encoded_certificate")

    @encoded_certificate.setter
    def encoded_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoded_certificate", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        Url to the KeyVault Secret containing the Ssl Certificate. If absolute Url containing version is provided, auto-update of ssl certificate will not work. This requires Api Management service to be configured with MSI. The secret should be of type *application/x-pkcs12*
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_id", value)

    @property
    @pulumi.getter(name="negotiateClientCertificate")
    def negotiate_client_certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify true to always negotiate client certificate on the hostname. Default Value is false.
        """
        return pulumi.get(self, "negotiate_client_certificate")

    @negotiate_client_certificate.setter
    def negotiate_client_certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negotiate_client_certificate", value)


if not MYPY:
    class LoggerSamplingContractArgsDict(TypedDict):
        """
        Sampling settings contract.
        """
        evaluation_interval: NotRequired[pulumi.Input[str]]
        """
        Rate re-evaluation interval in ISO8601 format.
        """
        initial_percentage: NotRequired[pulumi.Input[float]]
        """
        Initial sampling rate.
        """
        max_percentage: NotRequired[pulumi.Input[float]]
        """
        Maximum allowed rate of sampling.
        """
        max_telemetry_items_per_second: NotRequired[pulumi.Input[int]]
        """
        Target rate of telemetry items per second.
        """
        min_percentage: NotRequired[pulumi.Input[float]]
        """
        Minimum allowed rate of sampling.
        """
        moving_average_ratio: NotRequired[pulumi.Input[float]]
        """
        Moving average ration assigned to most recent value.
        """
        percentage: NotRequired[pulumi.Input[float]]
        """
        Rate of sampling for fixed-rate sampling.
        """
        percentage_decrease_timeout: NotRequired[pulumi.Input[str]]
        """
        Duration in ISO8601 format after which it's allowed to lower the sampling rate.
        """
        percentage_increase_timeout: NotRequired[pulumi.Input[str]]
        """
        Duration in ISO8601 format after which it's allowed to increase the sampling rate.
        """
        sampling_type: NotRequired[pulumi.Input[Union[str, 'SamplingType']]]
        """
        Sampling type.
        """
elif False:
    LoggerSamplingContractArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoggerSamplingContractArgs:
    def __init__(__self__, *,
                 evaluation_interval: Optional[pulumi.Input[str]] = None,
                 initial_percentage: Optional[pulumi.Input[float]] = None,
                 max_percentage: Optional[pulumi.Input[float]] = None,
                 max_telemetry_items_per_second: Optional[pulumi.Input[int]] = None,
                 min_percentage: Optional[pulumi.Input[float]] = None,
                 moving_average_ratio: Optional[pulumi.Input[float]] = None,
                 percentage: Optional[pulumi.Input[float]] = None,
                 percentage_decrease_timeout: Optional[pulumi.Input[str]] = None,
                 percentage_increase_timeout: Optional[pulumi.Input[str]] = None,
                 sampling_type: Optional[pulumi.Input[Union[str, 'SamplingType']]] = None):
        """
        Sampling settings contract.
        :param pulumi.Input[str] evaluation_interval: Rate re-evaluation interval in ISO8601 format.
        :param pulumi.Input[float] initial_percentage: Initial sampling rate.
        :param pulumi.Input[float] max_percentage: Maximum allowed rate of sampling.
        :param pulumi.Input[int] max_telemetry_items_per_second: Target rate of telemetry items per second.
        :param pulumi.Input[float] min_percentage: Minimum allowed rate of sampling.
        :param pulumi.Input[float] moving_average_ratio: Moving average ration assigned to most recent value.
        :param pulumi.Input[float] percentage: Rate of sampling for fixed-rate sampling.
        :param pulumi.Input[str] percentage_decrease_timeout: Duration in ISO8601 format after which it's allowed to lower the sampling rate.
        :param pulumi.Input[str] percentage_increase_timeout: Duration in ISO8601 format after which it's allowed to increase the sampling rate.
        :param pulumi.Input[Union[str, 'SamplingType']] sampling_type: Sampling type.
        """
        if evaluation_interval is not None:
            pulumi.set(__self__, "evaluation_interval", evaluation_interval)
        if initial_percentage is not None:
            pulumi.set(__self__, "initial_percentage", initial_percentage)
        if max_percentage is not None:
            pulumi.set(__self__, "max_percentage", max_percentage)
        if max_telemetry_items_per_second is not None:
            pulumi.set(__self__, "max_telemetry_items_per_second", max_telemetry_items_per_second)
        if min_percentage is not None:
            pulumi.set(__self__, "min_percentage", min_percentage)
        if moving_average_ratio is not None:
            pulumi.set(__self__, "moving_average_ratio", moving_average_ratio)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)
        if percentage_decrease_timeout is not None:
            pulumi.set(__self__, "percentage_decrease_timeout", percentage_decrease_timeout)
        if percentage_increase_timeout is not None:
            pulumi.set(__self__, "percentage_increase_timeout", percentage_increase_timeout)
        if sampling_type is not None:
            pulumi.set(__self__, "sampling_type", sampling_type)

    @property
    @pulumi.getter(name="evaluationInterval")
    def evaluation_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Rate re-evaluation interval in ISO8601 format.
        """
        return pulumi.get(self, "evaluation_interval")

    @evaluation_interval.setter
    def evaluation_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluation_interval", value)

    @property
    @pulumi.getter(name="initialPercentage")
    def initial_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Initial sampling rate.
        """
        return pulumi.get(self, "initial_percentage")

    @initial_percentage.setter
    def initial_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "initial_percentage", value)

    @property
    @pulumi.getter(name="maxPercentage")
    def max_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum allowed rate of sampling.
        """
        return pulumi.get(self, "max_percentage")

    @max_percentage.setter
    def max_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_percentage", value)

    @property
    @pulumi.getter(name="maxTelemetryItemsPerSecond")
    def max_telemetry_items_per_second(self) -> Optional[pulumi.Input[int]]:
        """
        Target rate of telemetry items per second.
        """
        return pulumi.get(self, "max_telemetry_items_per_second")

    @max_telemetry_items_per_second.setter
    def max_telemetry_items_per_second(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_telemetry_items_per_second", value)

    @property
    @pulumi.getter(name="minPercentage")
    def min_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum allowed rate of sampling.
        """
        return pulumi.get(self, "min_percentage")

    @min_percentage.setter
    def min_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_percentage", value)

    @property
    @pulumi.getter(name="movingAverageRatio")
    def moving_average_ratio(self) -> Optional[pulumi.Input[float]]:
        """
        Moving average ration assigned to most recent value.
        """
        return pulumi.get(self, "moving_average_ratio")

    @moving_average_ratio.setter
    def moving_average_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "moving_average_ratio", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Rate of sampling for fixed-rate sampling.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percentage", value)

    @property
    @pulumi.getter(name="percentageDecreaseTimeout")
    def percentage_decrease_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Duration in ISO8601 format after which it's allowed to lower the sampling rate.
        """
        return pulumi.get(self, "percentage_decrease_timeout")

    @percentage_decrease_timeout.setter
    def percentage_decrease_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "percentage_decrease_timeout", value)

    @property
    @pulumi.getter(name="percentageIncreaseTimeout")
    def percentage_increase_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Duration in ISO8601 format after which it's allowed to increase the sampling rate.
        """
        return pulumi.get(self, "percentage_increase_timeout")

    @percentage_increase_timeout.setter
    def percentage_increase_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "percentage_increase_timeout", value)

    @property
    @pulumi.getter(name="samplingType")
    def sampling_type(self) -> Optional[pulumi.Input[Union[str, 'SamplingType']]]:
        """
        Sampling type.
        """
        return pulumi.get(self, "sampling_type")

    @sampling_type.setter
    def sampling_type(self, value: Optional[pulumi.Input[Union[str, 'SamplingType']]]):
        pulumi.set(self, "sampling_type", value)


if not MYPY:
    class OAuth2AuthenticationSettingsContractArgsDict(TypedDict):
        """
        API OAuth2 Authentication settings details.
        """
        authorization_server_id: NotRequired[pulumi.Input[str]]
        """
        OAuth authorization server identifier.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        operations scope.
        """
elif False:
    OAuth2AuthenticationSettingsContractArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OAuth2AuthenticationSettingsContractArgs:
    def __init__(__self__, *,
                 authorization_server_id: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None):
        """
        API OAuth2 Authentication settings details.
        :param pulumi.Input[str] authorization_server_id: OAuth authorization server identifier.
        :param pulumi.Input[str] scope: operations scope.
        """
        if authorization_server_id is not None:
            pulumi.set(__self__, "authorization_server_id", authorization_server_id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="authorizationServerId")
    def authorization_server_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth authorization server identifier.
        """
        return pulumi.get(self, "authorization_server_id")

    @authorization_server_id.setter
    def authorization_server_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_server_id", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        operations scope.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class SubscriptionKeyParameterNamesContractArgsDict(TypedDict):
        """
        Subscription key parameter names details.
        """
        header: NotRequired[pulumi.Input[str]]
        """
        Subscription key header name.
        """
        query: NotRequired[pulumi.Input[str]]
        """
        Subscription key query string parameter name.
        """
elif False:
    SubscriptionKeyParameterNamesContractArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionKeyParameterNamesContractArgs:
    def __init__(__self__, *,
                 header: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        """
        Subscription key parameter names details.
        :param pulumi.Input[str] header: Subscription key header name.
        :param pulumi.Input[str] query: Subscription key query string parameter name.
        """
        if header is not None:
            pulumi.set(__self__, "header", header)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[str]]:
        """
        Subscription key header name.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        Subscription key query string parameter name.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class VirtualNetworkConfigurationArgsDict(TypedDict):
        """
        Configuration of a virtual network to which API Management service is deployed.
        """
        subnet_resource_id: NotRequired[pulumi.Input[str]]
        """
        The full resource ID of a subnet in a virtual network to deploy the API Management service in.
        """
elif False:
    VirtualNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkConfigurationArgs:
    def __init__(__self__, *,
                 subnet_resource_id: Optional[pulumi.Input[str]] = None):
        """
        Configuration of a virtual network to which API Management service is deployed.
        :param pulumi.Input[str] subnet_resource_id: The full resource ID of a subnet in a virtual network to deploy the API Management service in.
        """
        if subnet_resource_id is not None:
            pulumi.set(__self__, "subnet_resource_id", subnet_resource_id)

    @property
    @pulumi.getter(name="subnetResourceId")
    def subnet_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The full resource ID of a subnet in a virtual network to deploy the API Management service in.
        """
        return pulumi.get(self, "subnet_resource_id")

    @subnet_resource_id.setter
    def subnet_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_resource_id", value)


